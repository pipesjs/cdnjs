(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.mapboxgl = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
'use strict';

var featureFilter = require('feature-filter');
var Buffer = require('./buffer');
var StyleLayer = require('../style/style_layer');
var util = require('../util/util');
var StructArrayType = require('../util/struct_array');

module.exports = Bucket;

/**
 * Instantiate the appropriate subclass of `Bucket` for `options`.
 * @private
 * @param options See `Bucket` constructor options
 * @returns {Bucket}
 */
Bucket.create = function(options) {
    var Classes = {
        fill: require('./bucket/fill_bucket'),
        line: require('./bucket/line_bucket'),
        circle: require('./bucket/circle_bucket'),
        symbol: require('./bucket/symbol_bucket')
    };
    return new Classes[options.layer.type](options);
};


/**
 * The maximum extent of a feature that can be safely stored in the buffer.
 * In practice, all features are converted to this extent before being added.
 *
 * Positions are stored as signed 16bit integers.
 * One bit is lost for signedness to support featuers extending past the left edge of the tile.
 * One bit is lost because the line vertex buffer packs 1 bit of other data into the int.
 * One bit is lost to support features extending past the extent on the right edge of the tile.
 * This leaves us with 2^13 = 8192
 *
 * @private
 * @readonly
 */
Bucket.EXTENT = 8192;

/**
 * The `Bucket` class is the single point of knowledge about turning vector
 * tiles into WebGL buffers.
 *
 * `Bucket` is an abstract class. A subclass exists for each Mapbox GL
 * style spec layer type. Because `Bucket` is an abstract class,
 * instances should be created via the `Bucket.create` method.
 *
 * For performance reasons, `Bucket` creates its "add"s methods at
 * runtime using `new Function(...)`.
 *
 * @class Bucket
 * @private
 * @param options
 * @param {number} options.zoom Zoom level of the buffers being built. May be
 *     a fractional zoom level.
 * @param options.layer A Mapbox GL style layer object
 * @param {Object.<string, Buffer>} options.buffers The set of `Buffer`s being
 *     built for this tile. This object facilitates sharing of `Buffer`s be
       between `Bucket`s.
 */
function Bucket(options) {
    this.zoom = options.zoom;
    this.overscaling = options.overscaling;
    this.layer = options.layer;

    this.layerIDs = [this.layer.id];
    this.type = this.layer.type;
    this.features = [];
    this.id = this.layer.id;
    this.index = options.index;
    this.sourceLayer = this.layer.sourceLayer;
    this.sourceLayerIndex = options.sourceLayerIndex;
    this.minZoom = this.layer.minzoom;
    this.maxZoom = this.layer.maxzoom;

    if (options.elementGroups) {
        this.elementGroups = options.elementGroups;
        this.buffers = util.mapObject(options.arrays, function(array, bufferName) {
            var arrayType = options.arrayTypes[bufferName];
            var type = (arrayType.members[0].name === 'vertices' ? Buffer.BufferType.ELEMENT : Buffer.BufferType.VERTEX);
            return new Buffer(array, arrayType, type);
        });
    }
}

/**
 * Build the buffers! Features are set directly to the `features` property.
 * @private
 */
Bucket.prototype.populateBuffers = function() {
    this.createStyleLayer();
    this.createArrays();

    for (var i = 0; i < this.features.length; i++) {
        this.addFeature(this.features[i]);
    }

    this.trimArrays();
};

/**
 * Check if there is enough space available in the current element group for
 * `vertexLength` vertices. If not, append a new elementGroup. Should be called
 * by `populateBuffers` and its callees.
 * @private
 * @param {string} shaderName the name of the shader associated with the buffer that will receive the vertices
 * @param {number} vertexLength The number of vertices that will be inserted to the buffer.
 */
Bucket.prototype.makeRoomFor = function(shaderName, numVertices) {
    var groups = this.elementGroups[shaderName];
    var currentGroup = groups.length && groups[groups.length - 1];

    if (!currentGroup || currentGroup.vertexLength + numVertices > 65535) {
        var vertexArray = this.arrays[this.getBufferName(shaderName, 'vertex')];
        var elementArray = this.arrays[this.getBufferName(shaderName, 'element')];
        var secondElementArray = this.arrays[this.getBufferName(shaderName, 'secondElement')];

        currentGroup = new ElementGroup(
            vertexArray.length,
            elementArray && elementArray.length,
            secondElementArray && secondElementArray.length
        );
        groups.push(currentGroup);
    }

    return currentGroup;
};

/**
 * Start using a new shared `buffers` object and recreate instances of `Buffer`
 * as necessary.
 * @private
 */
Bucket.prototype.createArrays = function() {
    var elementGroups = this.elementGroups = {};
    var arrays = this.arrays = {};
    var arrayTypes = this.arrayTypes = {};

    for (var shaderName in this.shaderInterfaces) {
        var shaderInterface = this.shaderInterfaces[shaderName];

        if (shaderInterface.vertexBuffer) {
            var vertexBufferName = this.getBufferName(shaderName, 'vertex');
            var vertexAddMethodName = this.getAddMethodName(shaderName, 'vertex');

            var VertexArrayType = new StructArrayType({
                members: shaderInterface.attributes,
                alignment: Buffer.VERTEX_ATTRIBUTE_ALIGNMENT
            });

            arrays[vertexBufferName] = new VertexArrayType();
            arrayTypes[vertexBufferName] = VertexArrayType.serialize();

            this[vertexAddMethodName] = this[vertexAddMethodName] || createVertexAddMethod(
                shaderName,
                shaderInterface,
                this.getBufferName(shaderName, 'vertex')
            );
        }


        if (shaderInterface.elementBuffer) {
            var elementBufferName = this.getBufferName(shaderName, 'element');
            var ElementArrayType = createElementBufferType(shaderInterface.elementBufferComponents);
            arrays[elementBufferName] = new ElementArrayType();
            arrayTypes[elementBufferName] = ElementArrayType.serialize();
            this[this.getAddMethodName(shaderName, 'element')] = createElementAddMethod(this.arrays[elementBufferName]);
        }

        if (shaderInterface.secondElementBuffer) {
            var secondElementBufferName = this.getBufferName(shaderName, 'secondElement');
            var SecondElementArrayType = createElementBufferType(shaderInterface.secondElementBufferComponents);
            arrays[secondElementBufferName] = new SecondElementArrayType();
            arrayTypes[secondElementBufferName] = SecondElementArrayType.serialize();
            this[this.getAddMethodName(shaderName, 'secondElement')] = createElementAddMethod(this.arrays[secondElementBufferName]);
        }

        elementGroups[shaderName] = [];
    }
};

Bucket.prototype.destroy = function(gl) {
    for (var k in this.buffers) {
        this.buffers[k].destroy(gl);
    }
};

Bucket.prototype.trimArrays = function() {
    for (var bufferName in this.arrays) {
        this.arrays[bufferName].trim();
    }
};

/**
 * Get the name of the method used to add an item to a buffer.
 * @param {string} shaderName The name of the shader that will use the buffer
 * @param {string} type One of "vertex", "element", or "secondElement"
 * @returns {string}
 */
Bucket.prototype.getAddMethodName = function(shaderName, type) {
    return 'add' + capitalize(shaderName) + capitalize(type);
};

/**
 * Get the name of a buffer.
 * @param {string} shaderName The name of the shader that will use the buffer
 * @param {string} type One of "vertex", "element", or "secondElement"
 * @returns {string}
 */
Bucket.prototype.getBufferName = function(shaderName, type) {
    return shaderName + capitalize(type);
};

Bucket.prototype.serialize = function() {
    return {
        layer: {
            id: this.layer.id,
            type: this.layer.type
        },
        zoom: this.zoom,
        elementGroups: this.elementGroups,
        arrays: util.mapObject(this.arrays, function(array) {
            return array.serialize();
        }),
        arrayTypes: this.arrayTypes
    };
};

Bucket.prototype.createStyleLayer = function() {
    if (!(this.layer instanceof StyleLayer)) {
        this.layer = StyleLayer.create(this.layer);
        this.layer.recalculate(this.zoom, { lastIntegerZoom: Infinity, lastIntegerZoomTime: 0, lastZoom: 0 });
    }
};

Bucket.prototype.createFilter = function() {
    if (!this.filter) {
        this.filter = featureFilter(this.layer.filter);
    }
};


var createVertexAddMethodCache = {};
function createVertexAddMethod(shaderName, shaderInterface, bufferName) {
    var pushArgs = [];
    for (var i = 0; i < shaderInterface.attributes.length; i++) {
        pushArgs = pushArgs.concat(shaderInterface.attributes[i].value);
    }

    var body = 'return this.arrays.' + bufferName + '.emplaceBack(' + pushArgs.join(', ') + ');';

    if (!createVertexAddMethodCache[body]) {
        createVertexAddMethodCache[body] = new Function(shaderInterface.attributeArgs, body);
    }

    return createVertexAddMethodCache[body];
}

function createElementAddMethod(buffer) {
    return function(one, two, three) {
        return buffer.emplaceBack(one, two, three);
    };
}

function createElementBufferType(components) {
    return new StructArrayType({
        members: [{
            type: Buffer.ELEMENT_ATTRIBUTE_TYPE,
            name: 'vertices',
            components: components || 3
        }]});
}

function capitalize(string) {
    return string.charAt(0).toUpperCase() + string.slice(1);
}

function ElementGroup(vertexStartIndex, elementStartIndex, secondElementStartIndex) {
    // the offset into the vertex buffer of the first vertex in this group
    this.vertexStartIndex = vertexStartIndex;
    this.elementStartIndex = elementStartIndex;
    this.secondElementStartIndex = secondElementStartIndex;
    this.elementLength = 0;
    this.vertexLength = 0;
    this.secondElementLength = 0;
}

},{"../style/style_layer":47,"../util/struct_array":102,"../util/util":104,"./bucket/circle_bucket":2,"./bucket/fill_bucket":3,"./bucket/line_bucket":4,"./bucket/symbol_bucket":5,"./buffer":6,"feature-filter":113}],2:[function(require,module,exports){
'use strict';

var Bucket = require('../bucket');
var util = require('../../util/util');
var loadGeometry = require('../load_geometry');
var EXTENT = Bucket.EXTENT;

module.exports = CircleBucket;

/**
 * Circles are represented by two triangles.
 *
 * Each corner has a pos that is the center of the circle and an extrusion
 * vector that is where it points.
 * @private
 */
function CircleBucket() {
    Bucket.apply(this, arguments);
}

CircleBucket.prototype = util.inherit(Bucket, {});

CircleBucket.prototype.shaderInterfaces = {
    circle: {
        vertexBuffer: true,
        elementBuffer: true,

        attributeArgs: ['x', 'y', 'extrudeX', 'extrudeY'],

        attributes: [{
            name: 'pos',
            components: 2,
            type: 'Int16',
            value: [
                '(x * 2) + ((extrudeX + 1) / 2)',
                '(y * 2) + ((extrudeY + 1) / 2)'
            ]
        }]
    }
};

CircleBucket.prototype.addFeature = function(feature) {

    var geometries = loadGeometry(feature);
    for (var j = 0; j < geometries.length; j++) {
        var geometry = geometries[j];

        for (var k = 0; k < geometry.length; k++) {
            var group = this.makeRoomFor('circle', 4);

            var x = geometry[k].x;
            var y = geometry[k].y;

            // Do not include points that are outside the tile boundaries.
            if (x < 0 || x >= EXTENT || y < 0 || y >= EXTENT) continue;

            // this geometry will be of the Point type, and we'll derive
            // two triangles from it.
            //
            // ┌─────────┐
            // │ 3     2 │
            // │         │
            // │ 0     1 │
            // └─────────┘

            var index = this.addCircleVertex(x, y, -1, -1) - group.vertexStartIndex;
            this.addCircleVertex(x, y, 1, -1);
            this.addCircleVertex(x, y, 1, 1);
            this.addCircleVertex(x, y, -1, 1);
            group.vertexLength += 4;

            this.addCircleElement(index, index + 1, index + 2);
            this.addCircleElement(index, index + 3, index + 2);
            group.elementLength += 2;
        }
    }

};

},{"../../util/util":104,"../bucket":1,"../load_geometry":8}],3:[function(require,module,exports){
'use strict';

var Bucket = require('../bucket');
var util = require('../../util/util');
var loadGeometry = require('../load_geometry');

module.exports = FillBucket;

function FillBucket() {
    Bucket.apply(this, arguments);
}

FillBucket.prototype = util.inherit(Bucket, {});

FillBucket.prototype.shaderInterfaces = {
    fill: {
        vertexBuffer: true,
        elementBuffer: true,
        secondElementBuffer: true,
        secondElementBufferComponents: 2,

        attributeArgs: ['x', 'y'],

        attributes: [{
            name: 'pos',
            components: 2,
            type: 'Int16',
            value: ['x', 'y']
        }]
    }
};

FillBucket.prototype.addFeature = function(feature) {
    var lines = loadGeometry(feature);
    for (var i = 0; i < lines.length; i++) {
        this.addFill(lines[i]);
    }
};

FillBucket.prototype.addFill = function(vertices) {
    if (vertices.length < 3) {
        //console.warn('a fill must have at least three vertices');
        return;
    }

    // Calculate the total number of vertices we're going to produce so that we
    // can resize the buffer beforehand, or detect whether the current line
    // won't fit into the buffer anymore.
    // In order to be able to use the vertex buffer for drawing the antialiased
    // outlines, we separate all polygon vertices with a degenerate (out-of-
    // viewplane) vertex.

    var len = vertices.length;

    // Expand this geometry buffer to hold all the required vertices.
    var group = this.makeRoomFor('fill', len + 1);

    // We're generating triangle fans, so we always start with the first coordinate in this polygon.
    var firstIndex, prevIndex;
    for (var i = 0; i < vertices.length; i++) {
        var currentVertex = vertices[i];

        var currentIndex = this.addFillVertex(currentVertex.x, currentVertex.y) - group.vertexStartIndex;
        group.vertexLength++;
        if (i === 0) firstIndex = currentIndex;

        // Only add triangles that have distinct vertices.
        if (i >= 2 && (currentVertex.x !== vertices[0].x || currentVertex.y !== vertices[0].y)) {
            this.addFillElement(firstIndex, prevIndex, currentIndex);
            group.elementLength++;
        }

        if (i >= 1) {
            this.addFillSecondElement(prevIndex, currentIndex);
            group.secondElementLength++;
        }

        prevIndex = currentIndex;
    }
};

},{"../../util/util":104,"../bucket":1,"../load_geometry":8}],4:[function(require,module,exports){
'use strict';

var Bucket = require('../bucket');
var util = require('../../util/util');
var loadGeometry = require('../load_geometry');
var EXTENT = Bucket.EXTENT;

// NOTE ON EXTRUDE SCALE:
// scale the extrusion vector so that the normal length is this value.
// contains the "texture" normals (-1..1). this is distinct from the extrude
// normals for line joins, because the x-value remains 0 for the texture
// normal array, while the extrude normal actually moves the vertex to create
// the acute/bevelled line join.
var EXTRUDE_SCALE = 63;

/*
 * Sharp corners cause dashed lines to tilt because the distance along the line
 * is the same at both the inner and outer corners. To improve the appearance of
 * dashed lines we add extra points near sharp corners so that a smaller part
 * of the line is tilted.
 *
 * COS_HALF_SHARP_CORNER controls how sharp a corner has to be for us to add an
 * extra vertex. The default is 75 degrees.
 *
 * The newly created vertices are placed SHARP_CORNER_OFFSET pixels from the corner.
 */
var COS_HALF_SHARP_CORNER = Math.cos(75 / 2 * (Math.PI / 180));
var SHARP_CORNER_OFFSET = 15;

// The number of bits that is used to store the line distance in the buffer.
var LINE_DISTANCE_BUFFER_BITS = 14;

// We don't have enough bits for the line distance as we'd like to have, so
// use this value to scale the line distance (in tile units) down to a smaller
// value. This lets us store longer distances while sacrificing precision.
var LINE_DISTANCE_SCALE = 1 / 2;

// The maximum line distance, in tile units, that fits in the buffer.
var MAX_LINE_DISTANCE = Math.pow(2, LINE_DISTANCE_BUFFER_BITS) / LINE_DISTANCE_SCALE;


module.exports = LineBucket;

/**
 * @private
 */
function LineBucket() {
    Bucket.apply(this, arguments);
}

LineBucket.prototype = util.inherit(Bucket, {});

LineBucket.prototype.shaderInterfaces = {
    line: {
        vertexBuffer: true,
        elementBuffer: true,

        attributeArgs: ['point', 'extrude', 'tx', 'ty', 'dir', 'linesofar'],

        attributes: [{
            name: 'pos',
            components: 2,
            type: 'Int16',
            value: [
                '(point.x << 1) | tx',
                '(point.y << 1) | ty'
            ]
        }, {
            name: 'data',
            components: 4,
            type: 'Uint8',
            value: [
                // add 128 to store an byte in an unsigned byte
                'Math.round(' + EXTRUDE_SCALE + ' * extrude.x) + 128',
                'Math.round(' + EXTRUDE_SCALE + ' * extrude.y) + 128',

                // Encode the -1/0/1 direction value into the first two bits of .z of a_data.
                // Combine it with the lower 6 bits of `linesofar` (shifted by 2 bites to make
                // room for the direction value). The upper 8 bits of `linesofar` are placed in
                // the `w` component. `linesofar` is scaled down by `LINE_DISTANCE_SCALE` so that
                // we can store longer distances while sacrificing precision.
                '((dir === 0 ? 0 : (dir < 0 ? -1 : 1)) + 1) | (((linesofar * ' + LINE_DISTANCE_SCALE + ') & 0x3F) << 2)',
                '(linesofar * ' + LINE_DISTANCE_SCALE + ') >> 6'
            ]
        }]
    }
};

LineBucket.prototype.addFeature = function(feature) {
    var lines = loadGeometry(feature);
    for (var i = 0; i < lines.length; i++) {
        this.addLine(
            lines[i],
            this.layer.layout['line-join'],
            this.layer.layout['line-cap'],
            this.layer.layout['line-miter-limit'],
            this.layer.layout['line-round-limit']
        );
    }
};

LineBucket.prototype.addLine = function(vertices, join, cap, miterLimit, roundLimit) {

    var len = vertices.length;
    // If the line has duplicate vertices at the end, adjust length to remove them.
    while (len > 2 && vertices[len - 1].equals(vertices[len - 2])) {
        len--;
    }

    if (vertices.length < 2) {
        //console.warn('a line must have at least two vertices');
        return;
    }

    if (join === 'bevel') miterLimit = 1.05;

    var sharpCornerOffset = SHARP_CORNER_OFFSET * (EXTENT / (512 * this.overscaling));

    var firstVertex = vertices[0],
        lastVertex = vertices[len - 1],
        closed = firstVertex.equals(lastVertex);

    // we could be more precise, but it would only save a negligible amount of space
    this.makeRoomFor('line', len * 10);

    if (len === 2 && closed) {
        // console.warn('a line may not have coincident points');
        return;
    }

    this.distance = 0;

    var beginCap = cap,
        endCap = closed ? 'butt' : cap,
        startOfLine = true,
        currentVertex, prevVertex, nextVertex, prevNormal, nextNormal, offsetA, offsetB;

    // the last three vertices added
    this.e1 = this.e2 = this.e3 = -1;

    if (closed) {
        currentVertex = vertices[len - 2];
        nextNormal = firstVertex.sub(currentVertex)._unit()._perp();
    }

    for (var i = 0; i < len; i++) {

        nextVertex = closed && i === len - 1 ?
            vertices[1] : // if the line is closed, we treat the last vertex like the first
            vertices[i + 1]; // just the next vertex

        // if two consecutive vertices exist, skip the current one
        if (nextVertex && vertices[i].equals(nextVertex)) continue;

        if (nextNormal) prevNormal = nextNormal;
        if (currentVertex) prevVertex = currentVertex;

        currentVertex = vertices[i];

        // Calculate the normal towards the next vertex in this line. In case
        // there is no next vertex, pretend that the line is continuing straight,
        // meaning that we are just using the previous normal.
        nextNormal = nextVertex ? nextVertex.sub(currentVertex)._unit()._perp() : prevNormal;

        // If we still don't have a previous normal, this is the beginning of a
        // non-closed line, so we're doing a straight "join".
        prevNormal = prevNormal || nextNormal;

        // Determine the normal of the join extrusion. It is the angle bisector
        // of the segments between the previous line and the next line.
        var joinNormal = prevNormal.add(nextNormal)._unit();

        /*  joinNormal     prevNormal
         *             ↖      ↑
         *                .________. prevVertex
         *                |
         * nextNormal  ←  |  currentVertex
         *                |
         *     nextVertex !
         *
         */

        // Calculate the length of the miter (the ratio of the miter to the width).
        // Find the cosine of the angle between the next and join normals
        // using dot product. The inverse of that is the miter length.
        var cosHalfAngle = joinNormal.x * nextNormal.x + joinNormal.y * nextNormal.y;
        var miterLength = 1 / cosHalfAngle;

        var isSharpCorner = cosHalfAngle < COS_HALF_SHARP_CORNER && prevVertex && nextVertex;

        if (isSharpCorner && i > 0) {
            var prevSegmentLength = currentVertex.dist(prevVertex);
            if (prevSegmentLength > 2 * sharpCornerOffset) {
                var newPrevVertex = currentVertex.sub(currentVertex.sub(prevVertex)._mult(sharpCornerOffset / prevSegmentLength)._round());
                this.distance += newPrevVertex.dist(prevVertex);
                this.addCurrentVertex(newPrevVertex, this.distance, prevNormal.mult(1), 0, 0, false);
                prevVertex = newPrevVertex;
            }
        }

        // The join if a middle vertex, otherwise the cap.
        var middleVertex = prevVertex && nextVertex;
        var currentJoin = middleVertex ? join : nextVertex ? beginCap : endCap;

        if (middleVertex && currentJoin === 'round') {
            if (miterLength < roundLimit) {
                currentJoin = 'miter';
            } else if (miterLength <= 2) {
                currentJoin = 'fakeround';
            }
        }

        if (currentJoin === 'miter' && miterLength > miterLimit) {
            currentJoin = 'bevel';
        }

        if (currentJoin === 'bevel') {
            // The maximum extrude length is 128 / 63 = 2 times the width of the line
            // so if miterLength >= 2 we need to draw a different type of bevel where.
            if (miterLength > 2) currentJoin = 'flipbevel';

            // If the miterLength is really small and the line bevel wouldn't be visible,
            // just draw a miter join to save a triangle.
            if (miterLength < miterLimit) currentJoin = 'miter';
        }

        // Calculate how far along the line the currentVertex is
        if (prevVertex) this.distance += currentVertex.dist(prevVertex);

        if (currentJoin === 'miter') {

            joinNormal._mult(miterLength);
            this.addCurrentVertex(currentVertex, this.distance, joinNormal, 0, 0, false);

        } else if (currentJoin === 'flipbevel') {
            // miter is too big, flip the direction to make a beveled join

            if (miterLength > 100) {
                // Almost parallel lines
                joinNormal = nextNormal.clone();

            } else {
                var direction = prevNormal.x * nextNormal.y - prevNormal.y * nextNormal.x > 0 ? -1 : 1;
                var bevelLength = miterLength * prevNormal.add(nextNormal).mag() / prevNormal.sub(nextNormal).mag();
                joinNormal._perp()._mult(bevelLength * direction);
            }
            this.addCurrentVertex(currentVertex, this.distance, joinNormal, 0, 0, false);
            this.addCurrentVertex(currentVertex, this.distance, joinNormal.mult(-1), 0, 0, false);

        } else if (currentJoin === 'bevel' || currentJoin === 'fakeround') {
            var lineTurnsLeft = (prevNormal.x * nextNormal.y - prevNormal.y * nextNormal.x) > 0;
            var offset = -Math.sqrt(miterLength * miterLength - 1);
            if (lineTurnsLeft) {
                offsetB = 0;
                offsetA = offset;
            } else {
                offsetA = 0;
                offsetB = offset;
            }

            // Close previous segment with a bevel
            if (!startOfLine) {
                this.addCurrentVertex(currentVertex, this.distance, prevNormal, offsetA, offsetB, false);
            }

            if (currentJoin === 'fakeround') {
                // The join angle is sharp enough that a round join would be visible.
                // Bevel joins fill the gap between segments with a single pie slice triangle.
                // Create a round join by adding multiple pie slices. The join isn't actually round, but
                // it looks like it is at the sizes we render lines at.

                // Add more triangles for sharper angles.
                // This math is just a good enough approximation. It isn't "correct".
                var n = Math.floor((0.5 - (cosHalfAngle - 0.5)) * 8);
                var approxFractionalJoinNormal;

                for (var m = 0; m < n; m++) {
                    approxFractionalJoinNormal = nextNormal.mult((m + 1) / (n + 1))._add(prevNormal)._unit();
                    this.addPieSliceVertex(currentVertex, this.distance, approxFractionalJoinNormal, lineTurnsLeft);
                }

                this.addPieSliceVertex(currentVertex, this.distance, joinNormal, lineTurnsLeft);

                for (var k = n - 1; k >= 0; k--) {
                    approxFractionalJoinNormal = prevNormal.mult((k + 1) / (n + 1))._add(nextNormal)._unit();
                    this.addPieSliceVertex(currentVertex, this.distance, approxFractionalJoinNormal, lineTurnsLeft);
                }
            }

            // Start next segment
            if (nextVertex) {
                this.addCurrentVertex(currentVertex, this.distance, nextNormal, -offsetA, -offsetB, false);
            }

        } else if (currentJoin === 'butt') {
            if (!startOfLine) {
                // Close previous segment with a butt
                this.addCurrentVertex(currentVertex, this.distance, prevNormal, 0, 0, false);
            }

            // Start next segment with a butt
            if (nextVertex) {
                this.addCurrentVertex(currentVertex, this.distance, nextNormal, 0, 0, false);
            }

        } else if (currentJoin === 'square') {

            if (!startOfLine) {
                // Close previous segment with a square cap
                this.addCurrentVertex(currentVertex, this.distance, prevNormal, 1, 1, false);

                // The segment is done. Unset vertices to disconnect segments.
                this.e1 = this.e2 = -1;
            }

            // Start next segment
            if (nextVertex) {
                this.addCurrentVertex(currentVertex, this.distance, nextNormal, -1, -1, false);
            }

        } else if (currentJoin === 'round') {

            if (!startOfLine) {
                // Close previous segment with butt
                this.addCurrentVertex(currentVertex, this.distance, prevNormal, 0, 0, false);

                // Add round cap or linejoin at end of segment
                this.addCurrentVertex(currentVertex, this.distance, prevNormal, 1, 1, true);

                // The segment is done. Unset vertices to disconnect segments.
                this.e1 = this.e2 = -1;
            }


            // Start next segment with a butt
            if (nextVertex) {
                // Add round cap before first segment
                this.addCurrentVertex(currentVertex, this.distance, nextNormal, -1, -1, true);

                this.addCurrentVertex(currentVertex, this.distance, nextNormal, 0, 0, false);
            }
        }

        if (isSharpCorner && i < len - 1) {
            var nextSegmentLength = currentVertex.dist(nextVertex);
            if (nextSegmentLength > 2 * sharpCornerOffset) {
                var newCurrentVertex = currentVertex.add(nextVertex.sub(currentVertex)._mult(sharpCornerOffset / nextSegmentLength)._round());
                this.distance += newCurrentVertex.dist(currentVertex);
                this.addCurrentVertex(newCurrentVertex, this.distance, nextNormal.mult(1), 0, 0, false);
                currentVertex = newCurrentVertex;
            }
        }

        startOfLine = false;
    }

};

/**
 * Add two vertices to the buffers.
 *
 * @param {Object} currentVertex the line vertex to add buffer vertices for
 * @param {number} distance the distance from the beginning of the line to the vertex
 * @param {number} endLeft extrude to shift the left vertex along the line
 * @param {number} endRight extrude to shift the left vertex along the line
 * @param {boolean} round whether this is a round cap
 * @private
 */
LineBucket.prototype.addCurrentVertex = function(currentVertex, distance, normal, endLeft, endRight, round) {
    var tx = round ? 1 : 0;
    var extrude;
    var group = this.elementGroups.line[this.elementGroups.line.length - 1];
    group.vertexLength += 2;

    extrude = normal.clone();
    if (endLeft) extrude._sub(normal.perp()._mult(endLeft));
    this.e3 = this.addLineVertex(currentVertex, extrude, tx, 0, endLeft, distance) - group.vertexStartIndex;
    if (this.e1 >= 0 && this.e2 >= 0) {
        this.addLineElement(this.e1, this.e2, this.e3);
        group.elementLength++;
    }
    this.e1 = this.e2;
    this.e2 = this.e3;

    extrude = normal.mult(-1);
    if (endRight) extrude._sub(normal.perp()._mult(endRight));
    this.e3 = this.addLineVertex(currentVertex, extrude, tx, 1, -endRight, distance) - group.vertexStartIndex;
    if (this.e1 >= 0 && this.e2 >= 0) {
        this.addLineElement(this.e1, this.e2, this.e3);
        group.elementLength++;
    }
    this.e1 = this.e2;
    this.e2 = this.e3;

    // There is a maximum "distance along the line" that we can store in the buffers.
    // When we get close to the distance, reset it to zero and add the vertex again with
    // a distance of zero. The max distance is determined by the number of bits we allocate
    // to `linesofar`.
    if (distance > MAX_LINE_DISTANCE / 2) {
        this.distance = 0;
        this.addCurrentVertex(currentVertex, this.distance, normal, endLeft, endRight, round);
    }
};

/**
 * Add a single new vertex and a triangle using two previous vertices.
 * This adds a pie slice triangle near a join to simulate round joins
 *
 * @param {Object} currentVertex the line vertex to add buffer vertices for
 * @param {number} distance the distance from the beggining of the line to the vertex
 * @param {Object} extrude the offset of the new vertex from the currentVertex
 * @param {boolean} whether the line is turning left or right at this angle
 * @private
 */
LineBucket.prototype.addPieSliceVertex = function(currentVertex, distance, extrude, lineTurnsLeft) {
    var ty = lineTurnsLeft ? 1 : 0;
    extrude = extrude.mult(lineTurnsLeft ? -1 : 1);
    var group = this.elementGroups.line[this.elementGroups.line.length - 1];

    this.e3 = this.addLineVertex(currentVertex, extrude, 0, ty, 0, distance) - group.vertexStartIndex;
    group.vertexLength++;

    if (this.e1 >= 0 && this.e2 >= 0) {
        this.addLineElement(this.e1, this.e2, this.e3);
        group.elementLength++;
    }

    if (lineTurnsLeft) {
        this.e2 = this.e3;
    } else {
        this.e1 = this.e3;
    }
};

},{"../../util/util":104,"../bucket":1,"../load_geometry":8}],5:[function(require,module,exports){
'use strict';

var Point = require('point-geometry');

var Bucket = require('../bucket');
var Anchor = require('../../symbol/anchor');
var getAnchors = require('../../symbol/get_anchors');
var resolveTokens = require('../../util/token');
var Quads = require('../../symbol/quads');
var Shaping = require('../../symbol/shaping');
var resolveText = require('../../symbol/resolve_text');
var mergeLines = require('../../symbol/mergelines');
var clipLine = require('../../symbol/clip_line');
var util = require('../../util/util');
var loadGeometry = require('../load_geometry');
var CollisionFeature = require('../../symbol/collision_feature');

var shapeText = Shaping.shapeText;
var shapeIcon = Shaping.shapeIcon;
var getGlyphQuads = Quads.getGlyphQuads;
var getIconQuads = Quads.getIconQuads;

var EXTENT = Bucket.EXTENT;

module.exports = SymbolBucket;

function SymbolBucket(options) {
    Bucket.apply(this, arguments);
    this.showCollisionBoxes = options.showCollisionBoxes;
    this.overscaling = options.overscaling;
    this.collisionBoxArray = options.collisionBoxArray;
}

SymbolBucket.prototype = util.inherit(Bucket, {});

var shaderAttributeArgs = ['x', 'y', 'ox', 'oy', 'tx', 'ty', 'minzoom', 'maxzoom', 'labelminzoom'];

var shaderAttributes = [{
    name: 'pos',
    components: 2,
    type: 'Int16',
    value: ['x', 'y']
}, {
    name: 'offset',
    components: 2,
    type: 'Int16',
    value: [
        'Math.round(ox * 64)', // use 1/64 pixels for placement
        'Math.round(oy * 64)'
    ]
}, {
    name: 'data1',
    components: 4,
    type: 'Uint8',
    value: [
        'tx / 4',                   // tex
        'ty / 4',                   // tex
        '(labelminzoom || 0) * 10', // labelminzoom
        '0'
    ]
}, {
    name: 'data2',
    components: 2,
    type: 'Uint8',
    value: [
        '(minzoom || 0) * 10',             // minzoom
        'Math.min(maxzoom || 25, 25) * 10' // minzoom
    ]
}];

SymbolBucket.prototype.shaderInterfaces = {

    glyph: {
        vertexBuffer: true,
        elementBuffer: true,
        attributeArgs: shaderAttributeArgs,
        attributes: shaderAttributes
    },

    icon: {
        vertexBuffer: true,
        elementBuffer: true,
        attributeArgs: shaderAttributeArgs,
        attributes: shaderAttributes
    },

    collisionBox: {
        vertexBuffer: true,

        attributeArgs: ['point', 'extrude', 'maxZoom', 'placementZoom'],

        attributes: [{
            name: 'pos',
            components: 2,
            type: 'Int16',
            value: [ 'point.x', 'point.y' ]
        }, {
            name: 'extrude',
            components: 2,
            type: 'Int16',
            value: [
                'Math.round(extrude.x)',
                'Math.round(extrude.y)'
            ]
        }, {
            name: 'data',
            components: 2,
            type: 'Uint8',
            value: [
                'maxZoom * 10',
                'placementZoom * 10'
            ]
        }]
    }
};

SymbolBucket.prototype.populateBuffers = function(collisionTile, stacks, icons) {
    this.createStyleLayer();

    // To reduce the number of labels that jump around when zooming we need
    // to use a text-size value that is the same for all zoom levels.
    // This calculates text-size at a high zoom level so that all tiles can
    // use the same value when calculating anchor positions.
    var zoomHistory = { lastIntegerZoom: Infinity, lastIntegerZoomTime: 0, lastZoom: 0 };
    this.adjustedTextMaxSize = this.layer.getLayoutValue('text-size', 18, zoomHistory);
    this.adjustedTextSize = this.layer.getLayoutValue('text-size', this.zoom + 1, zoomHistory);
    this.adjustedIconMaxSize = this.layer.getLayoutValue('icon-size', 18, zoomHistory);
    this.adjustedIconSize = this.layer.getLayoutValue('icon-size', this.zoom + 1, zoomHistory);

    var tileSize = 512 * this.overscaling;
    this.tilePixelRatio = EXTENT / tileSize;
    this.compareText = {};
    this.symbolInstances = [];
    this.iconsNeedLinear = false;

    var layout = this.layer.layout;
    var features = this.features;
    var textFeatures = this.textFeatures;

    var horizontalAlign = 0.5,
        verticalAlign = 0.5;

    switch (layout['text-anchor']) {
    case 'right':
    case 'top-right':
    case 'bottom-right':
        horizontalAlign = 1;
        break;
    case 'left':
    case 'top-left':
    case 'bottom-left':
        horizontalAlign = 0;
        break;
    }

    switch (layout['text-anchor']) {
    case 'bottom':
    case 'bottom-right':
    case 'bottom-left':
        verticalAlign = 1;
        break;
    case 'top':
    case 'top-right':
    case 'top-left':
        verticalAlign = 0;
        break;
    }

    var justify = layout['text-justify'] === 'right' ? 1 :
        layout['text-justify'] === 'left' ? 0 :
        0.5;

    var oneEm = 24;
    var lineHeight = layout['text-line-height'] * oneEm;
    var maxWidth = layout['symbol-placement'] !== 'line' ? layout['text-max-width'] * oneEm : 0;
    var spacing = layout['text-letter-spacing'] * oneEm;
    var textOffset = [layout['text-offset'][0] * oneEm, layout['text-offset'][1] * oneEm];
    var fontstack = layout['text-font'].join(',');

    var geometries = [];
    for (var g = 0; g < features.length; g++) {
        geometries.push(loadGeometry(features[g]));
    }

    if (layout['symbol-placement'] === 'line') {
        // Merge adjacent lines with the same text to improve labelling.
        // It's better to place labels on one long line than on many short segments.
        var merged = mergeLines(features, textFeatures, geometries);

        geometries = merged.geometries;
        features = merged.features;
        textFeatures = merged.textFeatures;
    }

    var shapedText, shapedIcon;

    for (var k = 0; k < features.length; k++) {
        if (!geometries[k]) continue;

        if (textFeatures[k]) {
            shapedText = shapeText(textFeatures[k], stacks[fontstack], maxWidth,
                    lineHeight, horizontalAlign, verticalAlign, justify, spacing, textOffset);
        } else {
            shapedText = null;
        }

        if (layout['icon-image']) {
            var iconName = resolveTokens(features[k].properties, layout['icon-image']);
            var image = icons[iconName];
            shapedIcon = shapeIcon(image, layout);

            if (image) {
                if (this.sdfIcons === undefined) {
                    this.sdfIcons = image.sdf;
                } else if (this.sdfIcons !== image.sdf) {
                    console.warn('Style sheet warning: Cannot mix SDF and non-SDF icons in one buffer');
                }
                if (image.pixelRatio !== 1) {
                    this.iconsNeedLinear = true;
                }
            }
        } else {
            shapedIcon = null;
        }

        if (shapedText || shapedIcon) {
            this.addFeature(geometries[k], shapedText, shapedIcon, features[k].index);
        }
    }

    this.placeFeatures(collisionTile, this.showCollisionBoxes);

    this.trimArrays();
};

SymbolBucket.prototype.addFeature = function(lines, shapedText, shapedIcon, featureIndex) {
    var layout = this.layer.layout;

    var glyphSize = 24;

    var fontScale = this.adjustedTextSize / glyphSize,
        textMaxSize = this.adjustedTextMaxSize !== undefined ? this.adjustedTextMaxSize : this.adjustedTextSize,
        textBoxScale = this.tilePixelRatio * fontScale,
        textMaxBoxScale = this.tilePixelRatio * textMaxSize / glyphSize,
        iconBoxScale = this.tilePixelRatio * this.adjustedIconSize,
        symbolMinDistance = this.tilePixelRatio * layout['symbol-spacing'],
        avoidEdges = layout['symbol-avoid-edges'],
        textPadding = layout['text-padding'] * this.tilePixelRatio,
        iconPadding = layout['icon-padding'] * this.tilePixelRatio,
        textMaxAngle = layout['text-max-angle'] / 180 * Math.PI,
        textAlongLine = layout['text-rotation-alignment'] === 'map' && layout['symbol-placement'] === 'line',
        iconAlongLine = layout['icon-rotation-alignment'] === 'map' && layout['symbol-placement'] === 'line',
        mayOverlap = layout['text-allow-overlap'] || layout['icon-allow-overlap'] ||
            layout['text-ignore-placement'] || layout['icon-ignore-placement'],
        isLine = layout['symbol-placement'] === 'line',
        textRepeatDistance = symbolMinDistance / 2;

    if (isLine) {
        lines = clipLine(lines, 0, 0, EXTENT, EXTENT);
    }

    for (var i = 0; i < lines.length; i++) {
        var line = lines[i];

        // Calculate the anchor points around which you want to place labels
        var anchors;
        if (isLine) {
            anchors = getAnchors(
                line,
                symbolMinDistance,
                textMaxAngle,
                shapedText,
                shapedIcon,
                glyphSize,
                textMaxBoxScale,
                this.overscaling,
                EXTENT
            );
        } else {
            anchors = [ new Anchor(line[0].x, line[0].y, 0) ];
        }

        // For each potential label, create the placement features used to check for collisions, and the quads use for rendering.
        for (var j = 0, len = anchors.length; j < len; j++) {
            var anchor = anchors[j];

            if (shapedText && isLine) {
                if (this.anchorIsTooClose(shapedText.text, textRepeatDistance, anchor)) {
                    continue;
                }
            }

            var inside = !(anchor.x < 0 || anchor.x > EXTENT || anchor.y < 0 || anchor.y > EXTENT);

            if (avoidEdges && !inside) continue;

            // Normally symbol layers are drawn across tile boundaries. Only symbols
            // with their anchors within the tile boundaries are added to the buffers
            // to prevent symbols from being drawn twice.
            //
            // Symbols in layers with overlap are sorted in the y direction so that
            // symbols lower on the canvas are drawn on top of symbols near the top.
            // To preserve this order across tile boundaries these symbols can't
            // be drawn across tile boundaries. Instead they need to be included in
            // the buffers for both tiles and clipped to tile boundaries at draw time.
            var addToBuffers = inside || mayOverlap;

            this.symbolInstances.push(new SymbolInstance(anchor, line, shapedText, shapedIcon, layout,
                        addToBuffers, this.symbolInstances.length, this.collisionBoxArray, featureIndex, this.sourceLayerIndex, this.index,
                        textBoxScale, textPadding, textAlongLine,
                        iconBoxScale, iconPadding, iconAlongLine));
        }
    }
};

SymbolBucket.prototype.anchorIsTooClose = function(text, repeatDistance, anchor) {
    var compareText = this.compareText;
    if (!(text in compareText)) {
        compareText[text] = [];
    } else {
        var otherAnchors = compareText[text];
        for (var k = otherAnchors.length - 1; k >= 0; k--) {
            if (anchor.dist(otherAnchors[k]) < repeatDistance) {
                // If it's within repeatDistance of one anchor, stop looking
                return true;
            }
        }
    }
    // If anchor is not within repeatDistance of any other anchor, add to array
    compareText[text].push(anchor);
    return false;
};

SymbolBucket.prototype.placeFeatures = function(collisionTile, showCollisionBoxes) {
    // Calculate which labels can be shown and when they can be shown and
    // create the bufers used for rendering.

    this.createArrays();

    var elementGroups = this.elementGroups = {
        glyph: [],
        icon: [],
        sdfIcons: this.sdfIcons,
        iconsNeedLinear: this.iconsNeedLinear
    };

    var layout = this.layer.layout;
    var maxScale = collisionTile.maxScale;

    elementGroups.glyph.adjustedSize = this.adjustedTextSize;
    elementGroups.icon.adjustedSize = this.adjustedIconSize;

    // Transfer the name of the fonstack back to the main thread along with the buffers.
    // The draw function needs to know which fonstack's glyph atlas to bind when rendering.
    elementGroups.glyph.fontstack = layout['text-font'].join(',');

    var textAlongLine = layout['text-rotation-alignment'] === 'map' && layout['symbol-placement'] === 'line';
    var iconAlongLine = layout['icon-rotation-alignment'] === 'map' && layout['symbol-placement'] === 'line';

    var mayOverlap = layout['text-allow-overlap'] || layout['icon-allow-overlap'] ||
        layout['text-ignore-placement'] || layout['icon-ignore-placement'];

    // Sort symbols by their y position on the canvas so that they lower symbols
    // are drawn on top of higher symbols.
    // Don't sort symbols that won't overlap because it isn't necessary and
    // because it causes more labels to pop in and out when rotating.
    if (mayOverlap) {
        var angle = collisionTile.angle;
        var sin = Math.sin(angle),
            cos = Math.cos(angle);

        this.symbolInstances.sort(function(a, b) {
            var aRotated = (sin * a.x + cos * a.y) | 0;
            var bRotated = (sin * b.x + cos * b.y) | 0;
            return (aRotated - bRotated) || (b.index - a.index);
        });
    }

    for (var p = 0; p < this.symbolInstances.length; p++) {
        var symbolInstance = this.symbolInstances[p];
        var hasText = symbolInstance.hasText;
        var hasIcon = symbolInstance.hasIcon;

        var iconWithoutText = layout['text-optional'] || !hasText,
            textWithoutIcon = layout['icon-optional'] || !hasIcon;


        // Calculate the scales at which the text and icon can be placed without collision.

        var glyphScale = hasText ?
            collisionTile.placeCollisionFeature(symbolInstance.textCollisionFeature,
                    layout['text-allow-overlap'], layout['symbol-avoid-edges']) :
            collisionTile.minScale;

        var iconScale = hasIcon ?
            collisionTile.placeCollisionFeature(symbolInstance.iconCollisionFeature,
                    layout['icon-allow-overlap'], layout['symbol-avoid-edges']) :
            collisionTile.minScale;


        // Combine the scales for icons and text.

        if (!iconWithoutText && !textWithoutIcon) {
            iconScale = glyphScale = Math.max(iconScale, glyphScale);
        } else if (!textWithoutIcon && glyphScale) {
            glyphScale = Math.max(iconScale, glyphScale);
        } else if (!iconWithoutText && iconScale) {
            iconScale = Math.max(iconScale, glyphScale);
        }


        // Insert final placement into collision tree and add glyphs/icons to buffers

        if (hasText) {
            collisionTile.insertCollisionFeature(symbolInstance.textCollisionFeature, glyphScale, layout['text-ignore-placement']);
            if (glyphScale <= maxScale) {
                this.addSymbols('glyph', symbolInstance.glyphQuads, glyphScale, layout['text-keep-upright'], textAlongLine, collisionTile.angle);
            }
        }

        if (hasIcon) {
            collisionTile.insertCollisionFeature(symbolInstance.iconCollisionFeature, iconScale, layout['icon-ignore-placement']);
            if (iconScale <= maxScale) {
                this.addSymbols('icon', symbolInstance.iconQuads, iconScale, layout['icon-keep-upright'], iconAlongLine, collisionTile.angle);
            }
        }

    }

    if (showCollisionBoxes) this.addToDebugBuffers(collisionTile);
};

SymbolBucket.prototype.addSymbols = function(shaderName, quads, scale, keepUpright, alongLine, placementAngle) {

    var group = this.makeRoomFor(shaderName, 4 * quads.length);

    // TODO manual curry
    var addElement = this[this.getAddMethodName(shaderName, 'element')].bind(this);
    var addVertex = this[this.getAddMethodName(shaderName, 'vertex')].bind(this);

    var zoom = this.zoom;
    var placementZoom = Math.max(Math.log(scale) / Math.LN2 + zoom, 0);

    for (var k = 0; k < quads.length; k++) {

        var symbol = quads[k],
            angle = symbol.angle;

        // drop upside down versions of glyphs
        var a = (angle + placementAngle + Math.PI) % (Math.PI * 2);
        if (keepUpright && alongLine && (a <= Math.PI / 2 || a > Math.PI * 3 / 2)) continue;

        var tl = symbol.tl,
            tr = symbol.tr,
            bl = symbol.bl,
            br = symbol.br,
            tex = symbol.tex,
            anchorPoint = symbol.anchorPoint,

            minZoom = Math.max(zoom + Math.log(symbol.minScale) / Math.LN2, placementZoom),
            maxZoom = Math.min(zoom + Math.log(symbol.maxScale) / Math.LN2, 25);

        if (maxZoom <= minZoom) continue;

        // Lower min zoom so that while fading out the label it can be shown outside of collision-free zoom levels
        if (minZoom === placementZoom) minZoom = 0;

        var index = addVertex(anchorPoint.x, anchorPoint.y, tl.x, tl.y, tex.x, tex.y, minZoom, maxZoom, placementZoom) - group.vertexStartIndex;
        addVertex(anchorPoint.x, anchorPoint.y, tr.x, tr.y, tex.x + tex.w, tex.y, minZoom, maxZoom, placementZoom);
        addVertex(anchorPoint.x, anchorPoint.y, bl.x, bl.y, tex.x, tex.y + tex.h, minZoom, maxZoom, placementZoom);
        addVertex(anchorPoint.x, anchorPoint.y, br.x, br.y, tex.x + tex.w, tex.y + tex.h, minZoom, maxZoom, placementZoom);
        group.vertexLength += 4;

        addElement(index, index + 1, index + 2);
        addElement(index + 1, index + 2, index + 3);
        group.elementLength += 2;
    }

};

SymbolBucket.prototype.updateIcons = function(icons) {
    this.createStyleLayer();

    var iconValue = this.layer.layout['icon-image'];
    if (!iconValue) return;

    for (var i = 0; i < this.features.length; i++) {
        var iconName = resolveTokens(this.features[i].properties, iconValue);
        if (iconName)
            icons[iconName] = true;
    }
};

SymbolBucket.prototype.updateFont = function(stacks) {
    this.createStyleLayer();

    var fontName = this.layer.layout['text-font'],
        stack = stacks[fontName] = stacks[fontName] || {};

    this.textFeatures = resolveText(this.features, this.layer.layout, stack);
};

SymbolBucket.prototype.addToDebugBuffers = function(collisionTile) {
    this.elementGroups.collisionBox = [];
    var group = this.makeRoomFor('collisionBox', 0);
    var angle = -collisionTile.angle;
    var yStretch = collisionTile.yStretch;

    for (var j = 0; j < this.symbolInstances.length; j++) {
        for (var i = 0; i < 2; i++) {
            var feature = this.symbolInstances[j][i === 0 ? 'textCollisionFeature' : 'iconCollisionFeature'];
            if (!feature) continue;

            for (var b = feature.boxStartIndex; b < feature.boxEndIndex; b++) {
                var box = this.collisionBoxArray.get(b);
                var anchorPoint = box.anchorPoint;

                var tl = new Point(box.x1, box.y1 * yStretch)._rotate(angle);
                var tr = new Point(box.x2, box.y1 * yStretch)._rotate(angle);
                var bl = new Point(box.x1, box.y2 * yStretch)._rotate(angle);
                var br = new Point(box.x2, box.y2 * yStretch)._rotate(angle);

                var maxZoom = Math.max(0, Math.min(25, this.zoom + Math.log(box.maxScale) / Math.LN2));
                var placementZoom = Math.max(0, Math.min(25, this.zoom + Math.log(box.placementScale) / Math.LN2));

                this.addCollisionBoxVertex(anchorPoint, tl, maxZoom, placementZoom);
                this.addCollisionBoxVertex(anchorPoint, tr, maxZoom, placementZoom);
                this.addCollisionBoxVertex(anchorPoint, tr, maxZoom, placementZoom);
                this.addCollisionBoxVertex(anchorPoint, br, maxZoom, placementZoom);
                this.addCollisionBoxVertex(anchorPoint, br, maxZoom, placementZoom);
                this.addCollisionBoxVertex(anchorPoint, bl, maxZoom, placementZoom);
                this.addCollisionBoxVertex(anchorPoint, bl, maxZoom, placementZoom);
                this.addCollisionBoxVertex(anchorPoint, tl, maxZoom, placementZoom);
                group.vertexLength += 8;
            }
        }
    }
};

function SymbolInstance(anchor, line, shapedText, shapedIcon, layout, addToBuffers, index, collisionBoxArray, featureIndex, sourceLayerIndex, bucketIndex,
                        textBoxScale, textPadding, textAlongLine,
                        iconBoxScale, iconPadding, iconAlongLine) {

    this.x = anchor.x;
    this.y = anchor.y;
    this.index = index;
    this.hasText = !!shapedText;
    this.hasIcon = !!shapedIcon;

    if (this.hasText) {
        this.glyphQuads = addToBuffers ? getGlyphQuads(anchor, shapedText, textBoxScale, line, layout, textAlongLine) : [];
        this.textCollisionFeature = new CollisionFeature(collisionBoxArray, line, anchor, featureIndex, sourceLayerIndex, bucketIndex,
                shapedText, textBoxScale, textPadding, textAlongLine, false);
    }

    if (this.hasIcon) {
        this.iconQuads = addToBuffers ? getIconQuads(anchor, shapedIcon, iconBoxScale, line, layout, iconAlongLine) : [];
        this.iconCollisionFeature = new CollisionFeature(collisionBoxArray, line, anchor, featureIndex, sourceLayerIndex, bucketIndex,
                shapedIcon, iconBoxScale, iconPadding, iconAlongLine, true);
    }
}

},{"../../symbol/anchor":57,"../../symbol/clip_line":59,"../../symbol/collision_feature":61,"../../symbol/get_anchors":63,"../../symbol/mergelines":66,"../../symbol/quads":67,"../../symbol/resolve_text":68,"../../symbol/shaping":69,"../../util/token":103,"../../util/util":104,"../bucket":1,"../load_geometry":8,"point-geometry":162}],6:[function(require,module,exports){
'use strict';

module.exports = Buffer;

/**
 * The `Buffer` class turns a `StructArray` into a WebGL buffer. Each member of the StructArray's
 * Struct type is converted to a WebGL atribute.
 *
 * @class Buffer
 * @private
 * @param {object} array A serialized StructArray.
 * @param {object} arrayType A serialized StructArrayType.
 * @param {BufferType} type
 */
function Buffer(array, arrayType, type) {
    this.arrayBuffer = array.arrayBuffer;
    this.length = array.length;
    this.attributes = arrayType.members;
    this.itemSize = arrayType.bytesPerElement;
    this.type = type;
}

/**
 * Bind this buffer to a WebGL context.
 * @private
 * @param gl The WebGL context
 */
Buffer.prototype.bind = function(gl) {
    var type = gl[this.type];

    if (!this.buffer) {
        this.buffer = gl.createBuffer();
        gl.bindBuffer(type, this.buffer);
        gl.bufferData(type, this.arrayBuffer, gl.STATIC_DRAW);

        // dump array buffer once it's bound to gl
        this.arrayBuffer = null;
    } else {
        gl.bindBuffer(type, this.buffer);
    }
};

/**
 * Destroy the GL buffer bound to the given WebGL context
 * @private
 * @param gl The WebGL context
 */
Buffer.prototype.destroy = function(gl) {
    if (this.buffer) {
        gl.deleteBuffer(this.buffer);
    }
};

/**
 * @enum {string} BufferAttributeType
 * @private
 * @readonly
 */
var AttributeType = {
    Int8:   'BYTE',
    Uint8:  'UNSIGNED_BYTE',
    Int16:  'SHORT',
    Uint16: 'UNSIGNED_SHORT'
};

/**
 * Set the attribute pointers in a WebGL context according to the buffer's attribute layout
 * @private
 * @param gl The WebGL context
 * @param shader The active WebGL shader
 * @param {number} offset The offset of the attribute data in the currently bound GL buffer.
 */
Buffer.prototype.setAttribPointers = function(gl, shader, offset) {
    for (var i = 0; i < this.attributes.length; i++) {
        var attrib = this.attributes[i];

        gl.vertexAttribPointer(
            shader['a_' + attrib.name], attrib.components, gl[AttributeType[attrib.type]],
            false, this.itemSize, offset + attrib.offset);
    }
};

/**
 * @enum {string} BufferType
 * @private
 * @readonly
 */
Buffer.BufferType = {
    VERTEX: 'ARRAY_BUFFER',
    ELEMENT: 'ELEMENT_ARRAY_BUFFER'
};

/**
 * An `BufferType.ELEMENT` buffer holds indicies of a corresponding `BufferType.VERTEX` buffer.
 * These indicies are stored in the `BufferType.ELEMENT` buffer as `UNSIGNED_SHORT`s.
 *
 * @private
 * @readonly
 */
Buffer.ELEMENT_ATTRIBUTE_TYPE = 'Uint16';

/**
 * WebGL performs best if vertex attribute offsets are aligned to 4 byte boundaries.
 * @private
 * @readonly
 */
Buffer.VERTEX_ATTRIBUTE_ALIGNMENT = 4;

},{}],7:[function(require,module,exports){
'use strict';

var Point = require('point-geometry');
var loadGeometry = require('./load_geometry');
var EXTENT = require('./bucket').EXTENT;
var featureFilter = require('feature-filter');
var StructArrayType = require('../util/struct_array');
var Grid = require('../util/grid');
var DictionaryCoder = require('../util/dictionary_coder');
var vt = require('vector-tile');
var Protobuf = require('pbf');
var GeoJSONFeature = require('../util/vectortile_to_geojson');
var arraysIntersect = require('../util/util').arraysIntersect;

var intersection = require('../util/intersection_tests');
var multiPolygonIntersectsBufferedMultiPoint = intersection.multiPolygonIntersectsBufferedMultiPoint;
var multiPolygonIntersectsMultiPolygon = intersection.multiPolygonIntersectsMultiPolygon;
var multiPolygonIntersectsBufferedMultiLine = intersection.multiPolygonIntersectsBufferedMultiLine;


var FeatureIndexArray = new StructArrayType({
    members: [
        // the index of the feature in the original vectortile
        { type: 'Uint32', name: 'featureIndex' },
        // the source layer the feature appears in
        { type: 'Uint16', name: 'sourceLayerIndex' },
        // the bucket the feature appears in
        { type: 'Uint16', name: 'bucketIndex' }
    ]});

module.exports = FeatureIndex;

function FeatureIndex(coord, overscaling, collisionTile) {
    if (coord.grid) {
        var serialized = coord;
        var rawTileData = overscaling;
        coord = serialized.coord;
        overscaling = serialized.overscaling;
        this.grid = new Grid(serialized.grid);
        this.featureIndexArray = new FeatureIndexArray(serialized.featureIndexArray);
        this.rawTileData = rawTileData;
        this.bucketLayerIDs = serialized.bucketLayerIDs;
    } else {
        this.grid = new Grid(16, EXTENT, 0);
        this.featureIndexArray = new FeatureIndexArray();
    }
    this.coord = coord;
    this.overscaling = overscaling;
    this.x = coord.x;
    this.y = coord.y;
    this.z = coord.z - Math.log(overscaling) / Math.LN2;
    this.setCollisionTile(collisionTile);
}

FeatureIndex.prototype.insert = function(feature, featureIndex, sourceLayerIndex, bucketIndex) {
    var key = this.featureIndexArray.length;
    this.featureIndexArray.emplaceBack(featureIndex, sourceLayerIndex, bucketIndex);
    var geometry = loadGeometry(feature);

    for (var r = 0; r < geometry.length; r++) {
        var ring = geometry[r];

        // TODO: skip holes when we start using vector tile spec 2.0

        var bbox = [Infinity, Infinity, -Infinity, -Infinity];
        for (var i = 0; i < ring.length; i++) {
            var p = ring[i];
            bbox[0] = Math.min(bbox[0], p.x);
            bbox[1] = Math.min(bbox[1], p.y);
            bbox[2] = Math.max(bbox[2], p.x);
            bbox[3] = Math.max(bbox[3], p.y);
        }

        this.grid.insert(key, bbox[0], bbox[1], bbox[2], bbox[3]);
    }
};

FeatureIndex.prototype.setCollisionTile = function(collisionTile) {
    this.collisionTile = collisionTile;
};

FeatureIndex.prototype.serialize = function() {
    var data = {
        coord: this.coord,
        overscaling: this.overscaling,
        grid: this.grid.toArrayBuffer(),
        featureIndexArray: this.featureIndexArray.serialize(),
        bucketLayerIDs: this.bucketLayerIDs
    };
    return {
        data: data,
        transferables: [data.grid, data.featureIndexArray.arrayBuffer]
    };
};

function translateDistance(translate) {
    return Math.sqrt(translate[0] * translate[0] + translate[1] * translate[1]);
}

// Finds features in this tile at a particular position.
FeatureIndex.prototype.query = function(args, styleLayers) {
    if (!this.vtLayers) {
        this.vtLayers = new vt.VectorTile(new Protobuf(new Uint8Array(this.rawTileData))).layers;
        this.sourceLayerCoder = new DictionaryCoder(this.vtLayers ? Object.keys(this.vtLayers).sort() : ['_geojsonTileLayer']);
    }

    var result = {};

    var params = args.params || {},
        pixelsToTileUnits = EXTENT / args.tileSize / args.scale,
        filter = featureFilter(params.filter);

    // Features are indexed their original geometries. The rendered geometries may
    // be buffered, translated or offset. Figure out how much the search radius needs to be
    // expanded by to include these features.
    var additionalRadius = 0;
    for (var id in styleLayers) {
        var styleLayer = styleLayers[id];
        var paint = styleLayer.paint;

        var styleLayerDistance = 0;
        if (styleLayer.type === 'line') {
            styleLayerDistance = getLineWidth(paint) / 2 + Math.abs(paint['line-offset']) + translateDistance(paint['line-translate']);
        } else if (styleLayer.type === 'fill') {
            styleLayerDistance = translateDistance(paint['fill-translate']);
        } else if (styleLayer.type === 'circle') {
            styleLayerDistance = paint['circle-radius'] + translateDistance(paint['circle-translate']);
        }
        additionalRadius = Math.max(additionalRadius, styleLayerDistance * pixelsToTileUnits);
    }

    var queryGeometry = args.queryGeometry.map(function(q) {
        return q.map(function(p) {
            return new Point(p.x, p.y);
        });
    });

    var minX = Infinity;
    var minY = Infinity;
    var maxX = -Infinity;
    var maxY = -Infinity;
    for (var i = 0; i < queryGeometry.length; i++) {
        var ring = queryGeometry[i];
        for (var k = 0; k < ring.length; k++) {
            var p = ring[k];
            minX = Math.min(minX, p.x);
            minY = Math.min(minY, p.y);
            maxX = Math.max(maxX, p.x);
            maxY = Math.max(maxY, p.y);
        }
    }

    var matching = this.grid.query(minX - additionalRadius, minY - additionalRadius, maxX + additionalRadius, maxY + additionalRadius);
    matching.sort(topDownFeatureComparator);
    this.filterMatching(result, matching, this.featureIndexArray, queryGeometry, filter, params.layers, styleLayers, args.bearing, pixelsToTileUnits);

    var matchingSymbols = this.collisionTile.queryRenderedSymbols(minX, minY, maxX, maxY, args.scale);
    matchingSymbols.sort();
    this.filterMatching(result, matchingSymbols, this.collisionTile.collisionBoxArray, queryGeometry, filter, params.layers, styleLayers, args.bearing, pixelsToTileUnits);

    return result;
};

function topDownFeatureComparator(a, b) {
    return b - a;
}

function getLineWidth(paint) {
    if (paint['line-gap-width'] > 0) {
        return paint['line-gap-width'] + 2 * paint['line-width'];
    } else {
        return paint['line-width'];
    }
}

FeatureIndex.prototype.filterMatching = function(result, matching, array, queryGeometry, filter, filterLayerIDs, styleLayers, bearing, pixelsToTileUnits) {
    var previousIndex;
    for (var k = 0; k < matching.length; k++) {
        var index = matching[k];

        // don't check the same feature more than once
        if (index === previousIndex) continue;
        previousIndex = index;

        var match = array.get(index);

        var layerIDs = this.bucketLayerIDs[match.bucketIndex];
        if (filterLayerIDs && !arraysIntersect(filterLayerIDs, layerIDs)) continue;

        var sourceLayerName = this.sourceLayerCoder.decode(match.sourceLayerIndex);
        var sourceLayer = this.vtLayers[sourceLayerName];
        var feature = sourceLayer.feature(match.featureIndex);

        if (!filter(feature)) continue;

        var geometry = null;

        for (var l = 0; l < layerIDs.length; l++) {
            var layerID = layerIDs[l];

            if (filterLayerIDs && filterLayerIDs.indexOf(layerID) < 0) {
                continue;
            }

            var styleLayer = styleLayers[layerID];
            if (!styleLayer) continue;

            var translatedPolygon;
            if (styleLayer.type !== 'symbol') {
                // all symbols already match the style

                if (!geometry) geometry = loadGeometry(feature);

                var paint = styleLayer.paint;

                if (styleLayer.type === 'line') {
                    translatedPolygon = translate(queryGeometry,
                            paint['line-translate'], paint['line-translate-anchor'],
                            bearing, pixelsToTileUnits);
                    var halfWidth = getLineWidth(paint) / 2 * pixelsToTileUnits;
                    if (paint['line-offset']) {
                        geometry = offsetLine(geometry, paint['line-offset'] * pixelsToTileUnits);
                    }
                    if (!multiPolygonIntersectsBufferedMultiLine(translatedPolygon, geometry, halfWidth)) continue;

                } else if (styleLayer.type === 'fill') {
                    translatedPolygon = translate(queryGeometry,
                            paint['fill-translate'], paint['fill-translate-anchor'],
                            bearing, pixelsToTileUnits);
                    if (!multiPolygonIntersectsMultiPolygon(translatedPolygon, geometry)) continue;

                } else if (styleLayer.type === 'circle') {
                    translatedPolygon = translate(queryGeometry,
                            paint['circle-translate'], paint['circle-translate-anchor'],
                            bearing, pixelsToTileUnits);
                    var circleRadius = paint['circle-radius'] * pixelsToTileUnits;
                    if (!multiPolygonIntersectsBufferedMultiPoint(translatedPolygon, geometry, circleRadius)) continue;
                }
            }

            var geojsonFeature = new GeoJSONFeature(feature, this.z, this.x, this.y);
            geojsonFeature.layer = styleLayer.serialize({
                includeRefProperties: true
            });
            var layerResult = result[layerID];
            if (layerResult === undefined) {
                layerResult = result[layerID] = [];
            }
            layerResult.push(geojsonFeature);
        }
    }
};

function translate(queryGeometry, translate, translateAnchor, bearing, pixelsToTileUnits) {
    if (!translate[0] && !translate[1]) {
        return queryGeometry;
    }

    translate = Point.convert(translate);

    if (translateAnchor === "viewport") {
        translate._rotate(-bearing);
    }

    var translated = [];
    for (var i = 0; i < queryGeometry.length; i++) {
        var ring = queryGeometry[i];
        var translatedRing = [];
        for (var k = 0; k < ring.length; k++) {
            translatedRing.push(ring[k].sub(translate._mult(pixelsToTileUnits)));
        }
        translated.push(translatedRing);
    }
    return translated;
}

function offsetLine(rings, offset) {
    var newRings = [];
    var zero = new Point(0, 0);
    for (var k = 0; k < rings.length; k++) {
        var ring = rings[k];
        var newRing = [];
        for (var i = 0; i < ring.length; i++) {
            var a = ring[i - 1];
            var b = ring[i];
            var c = ring[i + 1];
            var aToB = i === 0 ? zero : b.sub(a)._unit()._perp();
            var bToC = i === ring.length - 1 ? zero : c.sub(b)._unit()._perp();
            var extrude = aToB._add(bToC)._unit();

            var cosHalfAngle = extrude.x * bToC.x + extrude.y * bToC.y;
            extrude._mult(1 / cosHalfAngle);

            newRing.push(extrude._mult(offset)._add(b));
        }
        newRings.push(newRing);
    }
    return newRings;
}

},{"../util/dictionary_coder":94,"../util/grid":97,"../util/intersection_tests":99,"../util/struct_array":102,"../util/util":104,"../util/vectortile_to_geojson":105,"./bucket":1,"./load_geometry":8,"feature-filter":113,"pbf":160,"point-geometry":162,"vector-tile":168}],8:[function(require,module,exports){
'use strict';

var EXTENT = require('./bucket').EXTENT;

/**
 * Loads a geometry from a VectorTileFeature and scales it to the common extent
 * used internally.
 * @private
 */
module.exports = function loadGeometry(feature) {
    var scale = EXTENT / feature.extent;
    var geometry = feature.loadGeometry();
    for (var r = 0; r < geometry.length; r++) {
        var ring = geometry[r];
        for (var p = 0; p < ring.length; p++) {
            var point = ring[p];
            // round here because mapbox-gl-native uses integers to represent
            // points and we need to do the same to avoid renering differences.
            point.x = Math.round(point.x * scale);
            point.y = Math.round(point.y * scale);
        }
    }
    return geometry;
};

},{"./bucket":1}],9:[function(require,module,exports){
'use strict';

module.exports = Coordinate;

/**
 * A coordinate is a column, row, zoom combination, often used
 * as the data component of a tile.
 *
 * @param {number} column
 * @param {number} row
 * @param {number} zoom
 * @private
 */
function Coordinate(column, row, zoom) {
    this.column = column;
    this.row = row;
    this.zoom = zoom;
}

Coordinate.prototype = {

    /**
     * Create a clone of this coordinate that can be mutated without
     * changing the original coordinate
     *
     * @returns {Coordinate} clone
     * @private
     * var coord = new Coordinate(0, 0, 0);
     * var c2 = coord.clone();
     * // since coord is cloned, modifying a property of c2 does
     * // not modify it.
     * c2.zoom = 2;
     */
    clone: function() {
        return new Coordinate(this.column, this.row, this.zoom);
    },

    /**
     * Zoom this coordinate to a given zoom level. This returns a new
     * coordinate object, not mutating the old one.
     *
     * @param {number} zoom
     * @returns {Coordinate} zoomed coordinate
     * @private
     * @example
     * var coord = new Coordinate(0, 0, 0);
     * var c2 = coord.zoomTo(1);
     * c2 // equals new Coordinate(0, 0, 1);
     */
    zoomTo: function(zoom) { return this.clone()._zoomTo(zoom); },

    /**
     * Subtract the column and row values of this coordinate from those
     * of another coordinate. The other coordinat will be zoomed to the
     * same level as `this` before the subtraction occurs
     *
     * @param {Coordinate} c other coordinate
     * @returns {Coordinate} result
     * @private
     */
    sub: function(c) { return this.clone()._sub(c); },

    _zoomTo: function(zoom) {
        var scale = Math.pow(2, zoom - this.zoom);
        this.column *= scale;
        this.row *= scale;
        this.zoom = zoom;
        return this;
    },

    _sub: function(c) {
        c = c.zoomTo(this.zoom);
        this.column -= c.column;
        this.row -= c.row;
        return this;
    }
};

},{}],10:[function(require,module,exports){
'use strict';

module.exports = LngLat;

var wrap = require('../util/util').wrap;

/**
 * Create a longitude, latitude object from a given longitude and latitude pair in degrees.
 * Mapbox GL uses Longitude, Latitude coordinate order to match GeoJSON.
 *
 * Note that any Mapbox GL method that accepts a `LngLat` object can also accept an
 * `Array` and will perform an implicit conversion.  The following lines are equivalent:
 ```
 map.setCenter([-73.9749, 40.7736]);
 map.setCenter( new mapboxgl.LngLat(-73.9749, 40.7736) );
 ```
 *
 * @class LngLat
 * @classdesc A representation of a longitude, latitude point, in degrees.
 * @param {number} lng longitude
 * @param {number} lat latitude
 * @example
 * var ll = new mapboxgl.LngLat(-73.9749, 40.7736);
 */
function LngLat(lng, lat) {
    if (isNaN(lng) || isNaN(lat)) {
        throw new Error('Invalid LngLat object: (' + lng + ', ' + lat + ')');
    }
    this.lng = +lng;
    this.lat = +lat;
    if (this.lat > 90 || this.lat < -90) {
        throw new Error('Invalid LngLat latitude value: must be between -90 and 90');
    }
}

/**
 * Return a new `LngLat` object whose longitude is wrapped to the range (-180, 180).
 *
 * @returns {LngLat} wrapped LngLat object
 * @example
 * var ll = new mapboxgl.LngLat(286.0251, 40.7736);
 * var wrapped = ll.wrap();
 * wrapped.lng; // = -73.9749
 */
LngLat.prototype.wrap = function () {
    return new LngLat(wrap(this.lng, -180, 180), this.lat);
};

/**
 * Return a `LngLat` as an array
 *
 * @returns {array} [lng, lat]
 * @example
 * var ll = new mapboxgl.LngLat(-73.9749, 40.7736);
 * ll.toArray(); // = [-73.9749, 40.7736]
 */
LngLat.prototype.toArray = function () {
    return [this.lng, this.lat];
};

/**
 * Return a `LngLat` as a string
 *
 * @returns {string} "LngLat(lng, lat)"
 * @example
 * var ll = new mapboxgl.LngLat(-73.9749, 40.7736);
 * ll.toString(); // = "LngLat(-73.9749, 40.7736)"
 */
LngLat.prototype.toString = function () {
    return 'LngLat(' + this.lng + ', ' + this.lat + ')';
};

/**
 * Convert an array to a `LngLat` object, or return an existing `LngLat` object
 * unchanged.
 *
 * @param {Array<number>|LngLat} input `input` to convert
 * @returns {LngLat} LngLat object or original input
 * @example
 * var arr = [-73.9749, 40.7736];
 * var ll = mapboxgl.LngLat.convert(arr);
 * ll;   // = LngLat {lng: -73.9749, lat: 40.7736}
 */
LngLat.convert = function (input) {
    if (input instanceof LngLat) {
        return input;
    }
    if (Array.isArray(input)) {
        return new LngLat(input[0], input[1]);
    }
    return input;
};

},{"../util/util":104}],11:[function(require,module,exports){
'use strict';

module.exports = LngLatBounds;

var LngLat = require('./lng_lat');

/**
 * Creates a bounding box from the given pair of points. If parameteres are omitted, a `null` bounding box is created.
 *
 * @class LngLatBounds
 * @classdesc A representation of rectangular box on the earth, defined by its southwest and northeast points in longitude and latitude.
 * @param {LngLat} sw southwest
 * @param {LngLat} ne northeast
 * @example
 * var sw = new mapboxgl.LngLat(-73.9876, 40.7661);
 * var ne = new mapboxgl.LngLat(-73.9397, 40.8002);
 * var llb = new mapboxgl.LngLatBounds(sw, ne);
 */
function LngLatBounds(sw, ne) {
    if (!sw) {
        return;
    } else if (ne) {
        this.extend(sw).extend(ne);
    } else if (sw.length === 4) {
        this.extend([sw[0], sw[1]]).extend([sw[2], sw[3]]);
    } else {
        this.extend(sw[0]).extend(sw[1]);
    }
}

LngLatBounds.prototype = {

    /**
     * Extend the bounds to include a given LngLat or LngLatBounds.
     *
     * @param {LngLat|LngLatBounds} obj object to extend to
     * @returns {LngLatBounds} `this`
     */
    extend: function(obj) {
        var sw = this._sw,
            ne = this._ne,
            sw2, ne2;

        if (obj instanceof LngLat) {
            sw2 = obj;
            ne2 = obj;

        } else if (obj instanceof LngLatBounds) {
            sw2 = obj._sw;
            ne2 = obj._ne;

            if (!sw2 || !ne2) return this;

        } else {
            return obj ? this.extend(LngLat.convert(obj) || LngLatBounds.convert(obj)) : this;
        }

        if (!sw && !ne) {
            this._sw = new LngLat(sw2.lng, sw2.lat);
            this._ne = new LngLat(ne2.lng, ne2.lat);

        } else {
            sw.lng = Math.min(sw2.lng, sw.lng);
            sw.lat = Math.min(sw2.lat, sw.lat);
            ne.lng = Math.max(ne2.lng, ne.lng);
            ne.lat = Math.max(ne2.lat, ne.lat);
        }

        return this;
    },

    /**
     * Get the point equidistant from this box's corners
     * @returns {LngLat} centerpoint
     * @example
     * var llb = new mapboxgl.LngLatBounds([-73.9876, 40.7661], [-73.9397, 40.8002]);
     * llb.getCenter(); // = LngLat {lng: -73.96365, lat: 40.78315}
     */
    getCenter: function() {
        return new LngLat((this._sw.lng + this._ne.lng) / 2, (this._sw.lat + this._ne.lat) / 2);
    },

    /**
     * Get southwest corner
     * @returns {LngLat} southwest
     */
    getSouthWest: function() { return this._sw; },

    /**
     * Get northeast corner
     * @returns {LngLat} northeast
     */
    getNorthEast: function() { return this._ne; },

    /**
     * Get northwest corner
     * @returns {LngLat} northwest
     */
    getNorthWest: function() { return new LngLat(this.getWest(), this.getNorth()); },

    /**
     * Get southeast corner
     * @returns {LngLat} southeast
     */
    getSouthEast: function() { return new LngLat(this.getEast(), this.getSouth()); },

    /**
     * Get west edge longitude
     * @returns {number} west
     */
    getWest:  function() { return this._sw.lng; },

    /**
     * Get south edge latitude
     * @returns {number} south
     */
    getSouth: function() { return this._sw.lat; },

    /**
     * Get east edge longitude
     * @returns {number} east
     */
    getEast:  function() { return this._ne.lng; },

    /**
     * Get north edge latitude
     * @returns {number} north
     */
    getNorth: function() { return this._ne.lat; },

    /**
     * Return a `LngLatBounds` as an array
     *
     * @returns {array} [lng, lat]
     * @example
     * var llb = new mapboxgl.LngLatBounds([-73.9876, 40.7661], [-73.9397, 40.8002]);
     * llb.toArray(); // = [[-73.9876, 40.7661], [-73.9397, 40.8002]]
     */
    toArray: function () {
        return [this._sw.toArray(), this._ne.toArray()];
    },

    /**
     * Return a `LngLatBounds` as a string
     *
     * @returns {string} "LngLatBounds(LngLat(lng, lat), LngLat(lng, lat))"
     * @example
     * var llb = new mapboxgl.LngLatBounds([-73.9876, 40.7661], [-73.9397, 40.8002]);
     * llb.toString(); // = "LngLatBounds(LngLat(-73.9876, 40.7661), LngLat(-73.9397, 40.8002))"
     */
    toString: function () {
        return 'LngLatBounds(' + this._sw.toString() + ', ' + this._ne.toString() + ')';
    }
};

/**
 * Convert an array to a `LngLatBounds` object, or return an existing
 * `LngLatBounds` object unchanged.
 *
 * Calls `LngLat#convert` internally to convert arrays as `LngLat` values.
 *
 * @param {LngLatBounds|Array<number>|Array<Array<number>>} input input to convert to a LngLatBounds
 * @returns {LngLatBounds} LngLatBounds object or original input
 * @example
 * var arr = [[-73.9876, 40.7661], [-73.9397, 40.8002]];
 * var llb = mapboxgl.LngLatBounds.convert(arr);
 * llb;   // = LngLatBounds {_sw: LngLat {lng: -73.9876, lat: 40.7661}, _ne: LngLat {lng: -73.9397, lat: 40.8002}}
 */
LngLatBounds.convert = function (input) {
    if (!input || input instanceof LngLatBounds) return input;
    return new LngLatBounds(input);
};

},{"./lng_lat":10}],12:[function(require,module,exports){
'use strict';

var LngLat = require('./lng_lat'),
    Point = require('point-geometry'),
    Coordinate = require('./coordinate'),
    wrap = require('../util/util').wrap,
    interp = require('../util/interpolate'),
    glmatrix = require('gl-matrix');

var vec4 = glmatrix.vec4,
    mat4 = glmatrix.mat4,
    mat2 = glmatrix.mat2;

module.exports = Transform;

/**
 * A single transform, generally used for a single tile to be
 * scaled, rotated, and zoomed.
 *
 * @param {number} minZoom
 * @param {number} maxZoom
 * @private
 */
function Transform(minZoom, maxZoom) {
    this.tileSize = 512; // constant

    this._minZoom = minZoom || 0;
    this._maxZoom = maxZoom || 22;

    this.latRange = [-85.05113, 85.05113];

    this.width = 0;
    this.height = 0;
    this._center = new LngLat(0, 0);
    this.zoom = 0;
    this.angle = 0;
    this._altitude = 1.5;
    this._pitch = 0;
    this._unmodified = true;
}

Transform.prototype = {
    get minZoom() { return this._minZoom; },
    set minZoom(zoom) {
        if (this._minZoom === zoom) return;
        this._minZoom = zoom;
        this.zoom = Math.max(this.zoom, zoom);
    },

    get maxZoom() { return this._maxZoom; },
    set maxZoom(zoom) {
        if (this._maxZoom === zoom) return;
        this._maxZoom = zoom;
        this.zoom = Math.min(this.zoom, zoom);
    },

    get worldSize() {
        return this.tileSize * this.scale;
    },

    get centerPoint() {
        return this.size._div(2);
    },

    get size() {
        return new Point(this.width, this.height);
    },

    get bearing() {
        return -this.angle / Math.PI * 180;
    },
    set bearing(bearing) {
        var b = -wrap(bearing, -180, 180) * Math.PI / 180;
        if (this.angle === b) return;
        this._unmodified = false;
        this.angle = b;
        this._calcProjMatrix();

        // 2x2 matrix for rotating points
        this.rotationMatrix = mat2.create();
        mat2.rotate(this.rotationMatrix, this.rotationMatrix, this.angle);
    },

    get pitch() {
        return this._pitch / Math.PI * 180;
    },
    set pitch(pitch) {
        var p = Math.min(60, pitch) / 180 * Math.PI;
        if (this._pitch === p) return;
        this._unmodified = false;
        this._pitch = p;
        this._calcProjMatrix();
    },

    get altitude() {
        return this._altitude;
    },
    set altitude(altitude) {
        var a = Math.max(0.75, altitude);
        if (this._altitude === a) return;
        this._unmodified = false;
        this._altitude = a;
        this._calcProjMatrix();
    },

    get zoom() { return this._zoom; },
    set zoom(zoom) {
        var z = Math.min(Math.max(zoom, this.minZoom), this.maxZoom);
        if (this._zoom === z) return;
        this._unmodified = false;
        this._zoom = z;
        this.scale = this.zoomScale(z);
        this.tileZoom = Math.floor(z);
        this.zoomFraction = z - this.tileZoom;
        this._calcProjMatrix();
        this._constrain();
    },

    get center() { return this._center; },
    set center(center) {
        if (center.lat === this._center.lat && center.lng === this._center.lng) return;
        this._unmodified = false;
        this._center = center;
        this._calcProjMatrix();
        this._constrain();
    },

    resize: function(width, height) {
        this.width = width;
        this.height = height;

        // The extrusion matrix
        this.exMatrix = mat4.create();
        mat4.ortho(this.exMatrix, 0, width, height, 0, 0, -1);

        this._calcProjMatrix();
        this._constrain();
    },

    get unmodified() { return this._unmodified; },

    zoomScale: function(zoom) { return Math.pow(2, zoom); },
    scaleZoom: function(scale) { return Math.log(scale) / Math.LN2; },

    project: function(lnglat, worldSize) {
        return new Point(
            this.lngX(lnglat.lng, worldSize),
            this.latY(lnglat.lat, worldSize));
    },

    unproject: function(point, worldSize) {
        return new LngLat(
            this.xLng(point.x, worldSize),
            this.yLat(point.y, worldSize));
    },

    get x() { return this.lngX(this.center.lng); },
    get y() { return this.latY(this.center.lat); },

    get point() { return new Point(this.x, this.y); },

    /**
     * latitude to absolute x coord
     * @param {number} lon
     * @param {number} [worldSize=this.worldSize]
     * @returns {number} pixel coordinate
     * @private
     */
    lngX: function(lng, worldSize) {
        return (180 + lng) * (worldSize || this.worldSize) / 360;
    },
    /**
     * latitude to absolute y coord
     * @param {number} lat
     * @param {number} [worldSize=this.worldSize]
     * @returns {number} pixel coordinate
     * @private
     */
    latY: function(lat, worldSize) {
        var y = 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + lat * Math.PI / 360));
        return (180 - y) * (worldSize || this.worldSize) / 360;
    },

    xLng: function(x, worldSize) {
        return x * 360 / (worldSize || this.worldSize) - 180;
    },
    yLat: function(y, worldSize) {
        var y2 = 180 - y * 360 / (worldSize || this.worldSize);
        return 360 / Math.PI * Math.atan(Math.exp(y2 * Math.PI / 180)) - 90;
    },

    panBy: function(offset) {
        var point = this.centerPoint._add(offset);
        this.center = this.pointLocation(point);
    },

    setLocationAtPoint: function(lnglat, point) {
        var c = this.locationCoordinate(lnglat);
        var coordAtPoint = this.pointCoordinate(point);
        var coordCenter = this.pointCoordinate(this.centerPoint);
        var translate = coordAtPoint._sub(c);
        this._unmodified = false;
        this.center = this.coordinateLocation(coordCenter._sub(translate));
    },

    /**
     * Given a location, return the screen point that corresponds to it
     * @param {LngLat} lnglat location
     * @returns {Point} screen point
     * @private
     */
    locationPoint: function(lnglat) {
        return this.coordinatePoint(this.locationCoordinate(lnglat));
    },

    /**
     * Given a point on screen, return its lnglat
     * @param {Point} p screen point
     * @returns {LngLat} lnglat location
     * @private
     */
    pointLocation: function(p) {
        return this.coordinateLocation(this.pointCoordinate(p));
    },

    /**
     * Given a geographical lnglat, return an unrounded
     * coordinate that represents it at this transform's zoom level and
     * worldsize.
     * @param {LngLat} lnglat
     * @returns {Coordinate}
     * @private
     */
    locationCoordinate: function(lnglat) {
        var k = this.zoomScale(this.tileZoom) / this.worldSize,
            ll = LngLat.convert(lnglat);

        return new Coordinate(
            this.lngX(ll.lng) * k,
            this.latY(ll.lat) * k,
            this.tileZoom);
    },

    /**
     * Given a Coordinate, return its geographical position.
     * @param {Coordinate} coord
     * @returns {LngLat} lnglat
     * @private
     */
    coordinateLocation: function(coord) {
        var worldSize = this.zoomScale(coord.zoom);
        return new LngLat(
            this.xLng(coord.column, worldSize),
            this.yLat(coord.row, worldSize));
    },

    pointCoordinate: function(p) {

        var targetZ = 0;

        var matrix = this.coordinatePointMatrix(this.tileZoom);
        mat4.invert(matrix, matrix);

        if (!matrix) throw new Error("failed to invert matrix");

        // since we don't know the correct projected z value for the point,
        // unproject two points to get a line and then find the point on that
        // line with z=0

        var coord0 = [p.x, p.y, 0, 1];
        var coord1 = [p.x, p.y, 1, 1];

        vec4.transformMat4(coord0, coord0, matrix);
        vec4.transformMat4(coord1, coord1, matrix);

        var w0 = coord0[3];
        var w1 = coord1[3];
        var x0 = coord0[0] / w0;
        var x1 = coord1[0] / w1;
        var y0 = coord0[1] / w0;
        var y1 = coord1[1] / w1;
        var z0 = coord0[2] / w0;
        var z1 = coord1[2] / w1;


        var t = z0 === z1 ? 0 : (targetZ - z0) / (z1 - z0);

        return new Coordinate(
            interp(x0, x1, t),
            interp(y0, y1, t),
            this.tileZoom);
    },

    /**
     * Given a coordinate, return the screen point that corresponds to it
     * @param {Coordinate} coord
     * @returns {Point} screen point
     * @private
     */
    coordinatePoint: function(coord) {
        var matrix = this.coordinatePointMatrix(coord.zoom);
        var p = [coord.column, coord.row, 0, 1];
        vec4.transformMat4(p, p, matrix);
        return new Point(p[0] / p[3], p[1] / p[3]);
    },

    coordinatePointMatrix: function(z) {
        var proj = mat4.copy(new Float64Array(16), this.projMatrix);
        var scale = this.worldSize / this.zoomScale(z);
        mat4.scale(proj, proj, [scale, scale, 1]);
        mat4.multiply(proj, this.getPixelMatrix(), proj);
        return proj;
    },

    /**
     * converts gl coordinates -1..1 to pixels 0..width
     * @returns {Object} matrix
     * @private
     */
    getPixelMatrix: function() {
        var m = mat4.create();
        mat4.scale(m, m, [this.width / 2, -this.height / 2, 1]);
        mat4.translate(m, m, [1, -1, 0]);
        return m;
    },

    _constrain: function() {
        if (!this.center || !this.width || !this.height || this._constraining) return;

        this._constraining = true;

        var minY, maxY, minX, maxX, sy, sx, x2, y2,
            size = this.size,
            unmodified = this._unmodified;

        if (this.latRange) {
            minY = this.latY(this.latRange[1]);
            maxY = this.latY(this.latRange[0]);
            sy = maxY - minY < size.y ? size.y / (maxY - minY) : 0;
        }

        if (this.lngRange) {
            minX = this.lngX(this.lngRange[0]);
            maxX = this.lngX(this.lngRange[1]);
            sx = maxX - minX < size.x ? size.x / (maxX - minX) : 0;
        }

        // how much the map should scale to fit the screen into given latitude/longitude ranges
        var s = Math.max(sx || 0, sy || 0);

        if (s) {
            this.center = this.unproject(new Point(
                sx ? (maxX + minX) / 2 : this.x,
                sy ? (maxY + minY) / 2 : this.y));
            this.zoom += this.scaleZoom(s);
            this._unmodified = unmodified;
            this._constraining = false;
            return;
        }

        if (this.latRange) {
            var y = this.y,
                h2 = size.y / 2;

            if (y - h2 < minY) y2 = minY + h2;
            if (y + h2 > maxY) y2 = maxY - h2;
        }

        if (this.lngRange) {
            var x = this.x,
                w2 = size.x / 2;

            if (x - w2 < minX) x2 = minX + w2;
            if (x + w2 > maxX) x2 = maxX - w2;
        }

        // pan the map if the screen goes off the range
        if (x2 !== undefined || y2 !== undefined) {
            this.center = this.unproject(new Point(
                x2 !== undefined ? x2 : this.x,
                y2 !== undefined ? y2 : this.y));
        }

        this._unmodified = unmodified;
        this._constraining = false;
    },

    _calcProjMatrix: function() {
        var m = new Float64Array(16);

        // Find the distance from the center point to the center top in altitude units using law of sines.
        var halfFov = Math.atan(0.5 / this.altitude);
        var topHalfSurfaceDistance = Math.sin(halfFov) * this.altitude / Math.sin(Math.PI / 2 - this._pitch - halfFov);

        // Calculate z value of the farthest fragment that should be rendered.
        var farZ = Math.cos(Math.PI / 2 - this._pitch) * topHalfSurfaceDistance + this.altitude;

        mat4.perspective(m, 2 * Math.atan((this.height / 2) / this.altitude), this.width / this.height, 0.1, farZ);

        mat4.translate(m, m, [0, 0, -this.altitude]);

        // After the rotateX, z values are in pixel units. Convert them to
        // altitude units. 1 altitude unit = the screen height.
        mat4.scale(m, m, [1, -1, 1 / this.height]);

        mat4.rotateX(m, m, this._pitch);
        mat4.rotateZ(m, m, this.angle);
        mat4.translate(m, m, [-this.x, -this.y, 0]);

        this.projMatrix = m;
    }
};

},{"../util/interpolate":98,"../util/util":104,"./coordinate":9,"./lng_lat":10,"gl-matrix":124,"point-geometry":162}],13:[function(require,module,exports){
'use strict';

// Font data From Hershey Simplex Font
// http://paulbourke.net/dataformats/hershey/
var simplexFont = {
    " ": [16, []],
    "!": [10, [5, 21, 5, 7, -1, -1, 5, 2, 4, 1, 5, 0, 6, 1, 5, 2]],
    "\"": [16, [4, 21, 4, 14, -1, -1, 12, 21, 12, 14]],
    "#": [21, [11, 25, 4, -7, -1, -1, 17, 25, 10, -7, -1, -1, 4, 12, 18, 12, -1, -1, 3, 6, 17, 6]],
    "$": [20, [8, 25, 8, -4, -1, -1, 12, 25, 12, -4, -1, -1, 17, 18, 15, 20, 12, 21, 8, 21, 5, 20, 3, 18, 3, 16, 4, 14, 5, 13, 7, 12, 13, 10, 15, 9, 16, 8, 17, 6, 17, 3, 15, 1, 12, 0, 8, 0, 5, 1, 3, 3]],
    "%": [24, [21, 21, 3, 0, -1, -1, 8, 21, 10, 19, 10, 17, 9, 15, 7, 14, 5, 14, 3, 16, 3, 18, 4, 20, 6, 21, 8, 21, 10, 20, 13, 19, 16, 19, 19, 20, 21, 21, -1, -1, 17, 7, 15, 6, 14, 4, 14, 2, 16, 0, 18, 0, 20, 1, 21, 3, 21, 5, 19, 7, 17, 7]],
    "&": [26, [23, 12, 23, 13, 22, 14, 21, 14, 20, 13, 19, 11, 17, 6, 15, 3, 13, 1, 11, 0, 7, 0, 5, 1, 4, 2, 3, 4, 3, 6, 4, 8, 5, 9, 12, 13, 13, 14, 14, 16, 14, 18, 13, 20, 11, 21, 9, 20, 8, 18, 8, 16, 9, 13, 11, 10, 16, 3, 18, 1, 20, 0, 22, 0, 23, 1, 23, 2]],
    "'": [10, [5, 19, 4, 20, 5, 21, 6, 20, 6, 18, 5, 16, 4, 15]],
    "(": [14, [11, 25, 9, 23, 7, 20, 5, 16, 4, 11, 4, 7, 5, 2, 7, -2, 9, -5, 11, -7]],
    ")": [14, [3, 25, 5, 23, 7, 20, 9, 16, 10, 11, 10, 7, 9, 2, 7, -2, 5, -5, 3, -7]],
    "*": [16, [8, 21, 8, 9, -1, -1, 3, 18, 13, 12, -1, -1, 13, 18, 3, 12]],
    "+": [26, [13, 18, 13, 0, -1, -1, 4, 9, 22, 9]],
    ",": [10, [6, 1, 5, 0, 4, 1, 5, 2, 6, 1, 6, -1, 5, -3, 4, -4]],
    "-": [26, [4, 9, 22, 9]],
    ".": [10, [5, 2, 4, 1, 5, 0, 6, 1, 5, 2]],
    "/": [22, [20, 25, 2, -7]],
    "0": [20, [9, 21, 6, 20, 4, 17, 3, 12, 3, 9, 4, 4, 6, 1, 9, 0, 11, 0, 14, 1, 16, 4, 17, 9, 17, 12, 16, 17, 14, 20, 11, 21, 9, 21]],
    "1": [20, [6, 17, 8, 18, 11, 21, 11, 0]],
    "2": [20, [4, 16, 4, 17, 5, 19, 6, 20, 8, 21, 12, 21, 14, 20, 15, 19, 16, 17, 16, 15, 15, 13, 13, 10, 3, 0, 17, 0]],
    "3": [20, [5, 21, 16, 21, 10, 13, 13, 13, 15, 12, 16, 11, 17, 8, 17, 6, 16, 3, 14, 1, 11, 0, 8, 0, 5, 1, 4, 2, 3, 4]],
    "4": [20, [13, 21, 3, 7, 18, 7, -1, -1, 13, 21, 13, 0]],
    "5": [20, [15, 21, 5, 21, 4, 12, 5, 13, 8, 14, 11, 14, 14, 13, 16, 11, 17, 8, 17, 6, 16, 3, 14, 1, 11, 0, 8, 0, 5, 1, 4, 2, 3, 4]],
    "6": [20, [16, 18, 15, 20, 12, 21, 10, 21, 7, 20, 5, 17, 4, 12, 4, 7, 5, 3, 7, 1, 10, 0, 11, 0, 14, 1, 16, 3, 17, 6, 17, 7, 16, 10, 14, 12, 11, 13, 10, 13, 7, 12, 5, 10, 4, 7]],
    "7": [20, [17, 21, 7, 0, -1, -1, 3, 21, 17, 21]],
    "8": [20, [8, 21, 5, 20, 4, 18, 4, 16, 5, 14, 7, 13, 11, 12, 14, 11, 16, 9, 17, 7, 17, 4, 16, 2, 15, 1, 12, 0, 8, 0, 5, 1, 4, 2, 3, 4, 3, 7, 4, 9, 6, 11, 9, 12, 13, 13, 15, 14, 16, 16, 16, 18, 15, 20, 12, 21, 8, 21]],
    "9": [20, [16, 14, 15, 11, 13, 9, 10, 8, 9, 8, 6, 9, 4, 11, 3, 14, 3, 15, 4, 18, 6, 20, 9, 21, 10, 21, 13, 20, 15, 18, 16, 14, 16, 9, 15, 4, 13, 1, 10, 0, 8, 0, 5, 1, 4, 3]],
    ":": [10, [5, 14, 4, 13, 5, 12, 6, 13, 5, 14, -1, -1, 5, 2, 4, 1, 5, 0, 6, 1, 5, 2]],
    ";": [10, [5, 14, 4, 13, 5, 12, 6, 13, 5, 14, -1, -1, 6, 1, 5, 0, 4, 1, 5, 2, 6, 1, 6, -1, 5, -3, 4, -4]],
    "<": [24, [20, 18, 4, 9, 20, 0]],
    "=": [26, [4, 12, 22, 12, -1, -1, 4, 6, 22, 6]],
    ">": [24, [4, 18, 20, 9, 4, 0]],
    "?": [18, [3, 16, 3, 17, 4, 19, 5, 20, 7, 21, 11, 21, 13, 20, 14, 19, 15, 17, 15, 15, 14, 13, 13, 12, 9, 10, 9, 7, -1, -1, 9, 2, 8, 1, 9, 0, 10, 1, 9, 2]],
    "@": [27, [18, 13, 17, 15, 15, 16, 12, 16, 10, 15, 9, 14, 8, 11, 8, 8, 9, 6, 11, 5, 14, 5, 16, 6, 17, 8, -1, -1, 12, 16, 10, 14, 9, 11, 9, 8, 10, 6, 11, 5, -1, -1, 18, 16, 17, 8, 17, 6, 19, 5, 21, 5, 23, 7, 24, 10, 24, 12, 23, 15, 22, 17, 20, 19, 18, 20, 15, 21, 12, 21, 9, 20, 7, 19, 5, 17, 4, 15, 3, 12, 3, 9, 4, 6, 5, 4, 7, 2, 9, 1, 12, 0, 15, 0, 18, 1, 20, 2, 21, 3, -1, -1, 19, 16, 18, 8, 18, 6, 19, 5]],
    "A": [18, [9, 21, 1, 0, -1, -1, 9, 21, 17, 0, -1, -1, 4, 7, 14, 7]],
    "B": [21, [4, 21, 4, 0, -1, -1, 4, 21, 13, 21, 16, 20, 17, 19, 18, 17, 18, 15, 17, 13, 16, 12, 13, 11, -1, -1, 4, 11, 13, 11, 16, 10, 17, 9, 18, 7, 18, 4, 17, 2, 16, 1, 13, 0, 4, 0]],
    "C": [21, [18, 16, 17, 18, 15, 20, 13, 21, 9, 21, 7, 20, 5, 18, 4, 16, 3, 13, 3, 8, 4, 5, 5, 3, 7, 1, 9, 0, 13, 0, 15, 1, 17, 3, 18, 5]],
    "D": [21, [4, 21, 4, 0, -1, -1, 4, 21, 11, 21, 14, 20, 16, 18, 17, 16, 18, 13, 18, 8, 17, 5, 16, 3, 14, 1, 11, 0, 4, 0]],
    "E": [19, [4, 21, 4, 0, -1, -1, 4, 21, 17, 21, -1, -1, 4, 11, 12, 11, -1, -1, 4, 0, 17, 0]],
    "F": [18, [4, 21, 4, 0, -1, -1, 4, 21, 17, 21, -1, -1, 4, 11, 12, 11]],
    "G": [21, [18, 16, 17, 18, 15, 20, 13, 21, 9, 21, 7, 20, 5, 18, 4, 16, 3, 13, 3, 8, 4, 5, 5, 3, 7, 1, 9, 0, 13, 0, 15, 1, 17, 3, 18, 5, 18, 8, -1, -1, 13, 8, 18, 8]],
    "H": [22, [4, 21, 4, 0, -1, -1, 18, 21, 18, 0, -1, -1, 4, 11, 18, 11]],
    "I": [8, [4, 21, 4, 0]],
    "J": [16, [12, 21, 12, 5, 11, 2, 10, 1, 8, 0, 6, 0, 4, 1, 3, 2, 2, 5, 2, 7]],
    "K": [21, [4, 21, 4, 0, -1, -1, 18, 21, 4, 7, -1, -1, 9, 12, 18, 0]],
    "L": [17, [4, 21, 4, 0, -1, -1, 4, 0, 16, 0]],
    "M": [24, [4, 21, 4, 0, -1, -1, 4, 21, 12, 0, -1, -1, 20, 21, 12, 0, -1, -1, 20, 21, 20, 0]],
    "N": [22, [4, 21, 4, 0, -1, -1, 4, 21, 18, 0, -1, -1, 18, 21, 18, 0]],
    "O": [22, [9, 21, 7, 20, 5, 18, 4, 16, 3, 13, 3, 8, 4, 5, 5, 3, 7, 1, 9, 0, 13, 0, 15, 1, 17, 3, 18, 5, 19, 8, 19, 13, 18, 16, 17, 18, 15, 20, 13, 21, 9, 21]],
    "P": [21, [4, 21, 4, 0, -1, -1, 4, 21, 13, 21, 16, 20, 17, 19, 18, 17, 18, 14, 17, 12, 16, 11, 13, 10, 4, 10]],
    "Q": [22, [9, 21, 7, 20, 5, 18, 4, 16, 3, 13, 3, 8, 4, 5, 5, 3, 7, 1, 9, 0, 13, 0, 15, 1, 17, 3, 18, 5, 19, 8, 19, 13, 18, 16, 17, 18, 15, 20, 13, 21, 9, 21, -1, -1, 12, 4, 18, -2]],
    "R": [21, [4, 21, 4, 0, -1, -1, 4, 21, 13, 21, 16, 20, 17, 19, 18, 17, 18, 15, 17, 13, 16, 12, 13, 11, 4, 11, -1, -1, 11, 11, 18, 0]],
    "S": [20, [17, 18, 15, 20, 12, 21, 8, 21, 5, 20, 3, 18, 3, 16, 4, 14, 5, 13, 7, 12, 13, 10, 15, 9, 16, 8, 17, 6, 17, 3, 15, 1, 12, 0, 8, 0, 5, 1, 3, 3]],
    "T": [16, [8, 21, 8, 0, -1, -1, 1, 21, 15, 21]],
    "U": [22, [4, 21, 4, 6, 5, 3, 7, 1, 10, 0, 12, 0, 15, 1, 17, 3, 18, 6, 18, 21]],
    "V": [18, [1, 21, 9, 0, -1, -1, 17, 21, 9, 0]],
    "W": [24, [2, 21, 7, 0, -1, -1, 12, 21, 7, 0, -1, -1, 12, 21, 17, 0, -1, -1, 22, 21, 17, 0]],
    "X": [20, [3, 21, 17, 0, -1, -1, 17, 21, 3, 0]],
    "Y": [18, [1, 21, 9, 11, 9, 0, -1, -1, 17, 21, 9, 11]],
    "Z": [20, [17, 21, 3, 0, -1, -1, 3, 21, 17, 21, -1, -1, 3, 0, 17, 0]],
    "[": [14, [4, 25, 4, -7, -1, -1, 5, 25, 5, -7, -1, -1, 4, 25, 11, 25, -1, -1, 4, -7, 11, -7]],
    "\\": [14, [0, 21, 14, -3]],
    "]": [14, [9, 25, 9, -7, -1, -1, 10, 25, 10, -7, -1, -1, 3, 25, 10, 25, -1, -1, 3, -7, 10, -7]],
    "^": [16, [6, 15, 8, 18, 10, 15, -1, -1, 3, 12, 8, 17, 13, 12, -1, -1, 8, 17, 8, 0]],
    "_": [16, [0, -2, 16, -2]],
    "`": [10, [6, 21, 5, 20, 4, 18, 4, 16, 5, 15, 6, 16, 5, 17]],
    "a": [19, [15, 14, 15, 0, -1, -1, 15, 11, 13, 13, 11, 14, 8, 14, 6, 13, 4, 11, 3, 8, 3, 6, 4, 3, 6, 1, 8, 0, 11, 0, 13, 1, 15, 3]],
    "b": [19, [4, 21, 4, 0, -1, -1, 4, 11, 6, 13, 8, 14, 11, 14, 13, 13, 15, 11, 16, 8, 16, 6, 15, 3, 13, 1, 11, 0, 8, 0, 6, 1, 4, 3]],
    "c": [18, [15, 11, 13, 13, 11, 14, 8, 14, 6, 13, 4, 11, 3, 8, 3, 6, 4, 3, 6, 1, 8, 0, 11, 0, 13, 1, 15, 3]],
    "d": [19, [15, 21, 15, 0, -1, -1, 15, 11, 13, 13, 11, 14, 8, 14, 6, 13, 4, 11, 3, 8, 3, 6, 4, 3, 6, 1, 8, 0, 11, 0, 13, 1, 15, 3]],
    "e": [18, [3, 8, 15, 8, 15, 10, 14, 12, 13, 13, 11, 14, 8, 14, 6, 13, 4, 11, 3, 8, 3, 6, 4, 3, 6, 1, 8, 0, 11, 0, 13, 1, 15, 3]],
    "f": [12, [10, 21, 8, 21, 6, 20, 5, 17, 5, 0, -1, -1, 2, 14, 9, 14]],
    "g": [19, [15, 14, 15, -2, 14, -5, 13, -6, 11, -7, 8, -7, 6, -6, -1, -1, 15, 11, 13, 13, 11, 14, 8, 14, 6, 13, 4, 11, 3, 8, 3, 6, 4, 3, 6, 1, 8, 0, 11, 0, 13, 1, 15, 3]],
    "h": [19, [4, 21, 4, 0, -1, -1, 4, 10, 7, 13, 9, 14, 12, 14, 14, 13, 15, 10, 15, 0]],
    "i": [8, [3, 21, 4, 20, 5, 21, 4, 22, 3, 21, -1, -1, 4, 14, 4, 0]],
    "j": [10, [5, 21, 6, 20, 7, 21, 6, 22, 5, 21, -1, -1, 6, 14, 6, -3, 5, -6, 3, -7, 1, -7]],
    "k": [17, [4, 21, 4, 0, -1, -1, 14, 14, 4, 4, -1, -1, 8, 8, 15, 0]],
    "l": [8, [4, 21, 4, 0]],
    "m": [30, [4, 14, 4, 0, -1, -1, 4, 10, 7, 13, 9, 14, 12, 14, 14, 13, 15, 10, 15, 0, -1, -1, 15, 10, 18, 13, 20, 14, 23, 14, 25, 13, 26, 10, 26, 0]],
    "n": [19, [4, 14, 4, 0, -1, -1, 4, 10, 7, 13, 9, 14, 12, 14, 14, 13, 15, 10, 15, 0]],
    "o": [19, [8, 14, 6, 13, 4, 11, 3, 8, 3, 6, 4, 3, 6, 1, 8, 0, 11, 0, 13, 1, 15, 3, 16, 6, 16, 8, 15, 11, 13, 13, 11, 14, 8, 14]],
    "p": [19, [4, 14, 4, -7, -1, -1, 4, 11, 6, 13, 8, 14, 11, 14, 13, 13, 15, 11, 16, 8, 16, 6, 15, 3, 13, 1, 11, 0, 8, 0, 6, 1, 4, 3]],
    "q": [19, [15, 14, 15, -7, -1, -1, 15, 11, 13, 13, 11, 14, 8, 14, 6, 13, 4, 11, 3, 8, 3, 6, 4, 3, 6, 1, 8, 0, 11, 0, 13, 1, 15, 3]],
    "r": [13, [4, 14, 4, 0, -1, -1, 4, 8, 5, 11, 7, 13, 9, 14, 12, 14]],
    "s": [17, [14, 11, 13, 13, 10, 14, 7, 14, 4, 13, 3, 11, 4, 9, 6, 8, 11, 7, 13, 6, 14, 4, 14, 3, 13, 1, 10, 0, 7, 0, 4, 1, 3, 3]],
    "t": [12, [5, 21, 5, 4, 6, 1, 8, 0, 10, 0, -1, -1, 2, 14, 9, 14]],
    "u": [19, [4, 14, 4, 4, 5, 1, 7, 0, 10, 0, 12, 1, 15, 4, -1, -1, 15, 14, 15, 0]],
    "v": [16, [2, 14, 8, 0, -1, -1, 14, 14, 8, 0]],
    "w": [22, [3, 14, 7, 0, -1, -1, 11, 14, 7, 0, -1, -1, 11, 14, 15, 0, -1, -1, 19, 14, 15, 0]],
    "x": [17, [3, 14, 14, 0, -1, -1, 14, 14, 3, 0]],
    "y": [16, [2, 14, 8, 0, -1, -1, 14, 14, 8, 0, 6, -4, 4, -6, 2, -7, 1, -7]],
    "z": [17, [14, 14, 3, 0, -1, -1, 3, 14, 14, 14, -1, -1, 3, 0, 14, 0]],
    "{": [14, [9, 25, 7, 24, 6, 23, 5, 21, 5, 19, 6, 17, 7, 16, 8, 14, 8, 12, 6, 10, -1, -1, 7, 24, 6, 22, 6, 20, 7, 18, 8, 17, 9, 15, 9, 13, 8, 11, 4, 9, 8, 7, 9, 5, 9, 3, 8, 1, 7, 0, 6, -2, 6, -4, 7, -6, -1, -1, 6, 8, 8, 6, 8, 4, 7, 2, 6, 1, 5, -1, 5, -3, 6, -5, 7, -6, 9, -7]],
    "|": [8, [4, 25, 4, -7]],
    "}": [14, [5, 25, 7, 24, 8, 23, 9, 21, 9, 19, 8, 17, 7, 16, 6, 14, 6, 12, 8, 10, -1, -1, 7, 24, 8, 22, 8, 20, 7, 18, 6, 17, 5, 15, 5, 13, 6, 11, 10, 9, 6, 7, 5, 5, 5, 3, 6, 1, 7, 0, 8, -2, 8, -4, 7, -6, -1, -1, 8, 8, 6, 6, 6, 4, 7, 2, 8, 1, 9, -1, 9, -3, 8, -5, 7, -6, 5, -7]],
    "~": [24, [3, 6, 3, 8, 4, 11, 6, 12, 8, 12, 10, 11, 14, 8, 16, 7, 18, 7, 20, 8, 21, 10, -1, -1, 3, 8, 4, 10, 6, 11, 8, 11, 10, 10, 14, 7, 16, 6, 18, 6, 20, 7, 21, 10, 21, 12]]
};

module.exports = function textVertices(text, left, baseline, scale) {
    scale = scale || 1;

    var strokes = [],
        i, len, j, len2, glyph, x, y, prev;

    for (i = 0, len = text.length; i < len; i++) {
        glyph = simplexFont[text[i]];
        if (!glyph) continue;
        prev = null;

        for (j = 0, len2 = glyph[1].length; j < len2; j += 2) {
            if (glyph[1][j] === -1 && glyph[1][j + 1] === -1) {
                prev = null;

            } else {
                x = left + glyph[1][j] * scale;
                y = baseline - glyph[1][j + 1] * scale;
                if (prev) {
                    strokes.push(prev.x, prev.y, x, y);
                }
                prev = {x: x, y: y};
            }
        }
        left += glyph[0] * scale;
    }

    return strokes;
};

},{}],14:[function(require,module,exports){
'use strict';

/**
 * mapboxgl is a A WebGL JavaScript interactive maps library that can render
 * [Mapbox vector tiles](https://www.mapbox.com/blog/vector-tiles/).
 *
 * @module mapboxgl
 * @summary WebGL JavaScript map library
 */

// jshint -W079
var mapboxgl = module.exports = {};

mapboxgl.Map = require('./ui/map');
mapboxgl.Control = require('./ui/control/control');
mapboxgl.Navigation = require('./ui/control/navigation');
mapboxgl.Geolocate = require('./ui/control/geolocate');
mapboxgl.Attribution = require('./ui/control/attribution');
mapboxgl.Popup = require('./ui/popup');

mapboxgl.GeoJSONSource = require('./source/geojson_source');
mapboxgl.VideoSource = require('./source/video_source');
mapboxgl.ImageSource = require('./source/image_source');

mapboxgl.Style = require('./style/style');

mapboxgl.LngLat = require('./geo/lng_lat');
mapboxgl.LngLatBounds = require('./geo/lng_lat_bounds');
mapboxgl.Point = require('point-geometry');

mapboxgl.Evented = require('./util/evented');
mapboxgl.util = require('./util/util');

mapboxgl.supported = require('./util/browser').supported;

var ajax = require('./util/ajax');
mapboxgl.util.getJSON = ajax.getJSON;
mapboxgl.util.getArrayBuffer = ajax.getArrayBuffer;

var config = require('./util/config');
mapboxgl.config = config;

Object.defineProperty(mapboxgl, 'accessToken', {
    get: function() { return config.ACCESS_TOKEN; },
    set: function(token) { config.ACCESS_TOKEN = token; }
});

},{"./geo/lng_lat":10,"./geo/lng_lat_bounds":11,"./source/geojson_source":28,"./source/image_source":30,"./source/video_source":38,"./style/style":44,"./ui/control/attribution":72,"./ui/control/control":73,"./ui/control/geolocate":74,"./ui/control/navigation":75,"./ui/map":85,"./ui/popup":86,"./util/ajax":88,"./util/browser":89,"./util/config":93,"./util/evented":95,"./util/util":104,"point-geometry":162}],15:[function(require,module,exports){
'use strict';

var TilePyramid = require('../source/tile_pyramid');
var pyramid = new TilePyramid({ tileSize: 512 });
var util = require('../util/util');
var pixelsToTileUnits = require('../source/pixels_to_tile_units');

module.exports = drawBackground;

function drawBackground(painter, source, layer) {
    var gl = painter.gl;
    var transform = painter.transform;
    var color = util.premultiply(layer.paint['background-color'], layer.paint['background-opacity']);
    var image = layer.paint['background-pattern'];
    var opacity = layer.paint['background-opacity'];
    var shader;

    var imagePosA = image ? painter.spriteAtlas.getPosition(image.from, true) : null;
    var imagePosB = image ? painter.spriteAtlas.getPosition(image.to, true) : null;

    painter.setDepthSublayer(0);
    if (imagePosA && imagePosB) {

        if (painter.isOpaquePass) return;

        // Draw texture fill
        shader = painter.patternShader;
        gl.switchShader(shader);
        gl.uniform1i(shader.u_image, 0);
        gl.uniform2fv(shader.u_pattern_tl_a, imagePosA.tl);
        gl.uniform2fv(shader.u_pattern_br_a, imagePosA.br);
        gl.uniform2fv(shader.u_pattern_tl_b, imagePosB.tl);
        gl.uniform2fv(shader.u_pattern_br_b, imagePosB.br);
        gl.uniform1f(shader.u_opacity, opacity);

        gl.uniform1f(shader.u_mix, image.t);

        painter.spriteAtlas.bind(gl, true);

    } else {
        // Draw filling rectangle.
        if (painter.isOpaquePass !== (color[3] === 1)) return;

        shader = painter.fillShader;
        gl.switchShader(shader);
        gl.uniform4fv(shader.u_color, color);
    }

    gl.disable(gl.STENCIL_TEST);

    gl.bindBuffer(gl.ARRAY_BUFFER, painter.tileExtentBuffer);
    gl.vertexAttribPointer(shader.a_pos, painter.tileExtentBuffer.itemSize, gl.SHORT, false, 0, 0);

    // We need to draw the background in tiles in order to use calculatePosMatrix
    // which applies the projection matrix (transform.projMatrix). Otherwise
    // the depth and stencil buffers get into a bad state.
    // This can be refactored into a single draw call once earcut lands and
    // we don't have so much going on in the stencil buffer.
    var coords = pyramid.coveringTiles(transform);
    for (var c = 0; c < coords.length; c++) {
        var coord = coords[c];
        var tileSize = 512;
        // var pixelsToTileUnitsBound = pixelsToTileUnits.bind({coord:coord, tileSize: tileSize});
        if (imagePosA && imagePosB) {
            var imageSizeScaledA = [
                (imagePosA.size[0] * image.fromScale),
                (imagePosA.size[1] * image.fromScale)
            ];
            var imageSizeScaledB = [
                (imagePosB.size[0] * image.toScale),
                (imagePosB.size[1] * image.toScale)
            ];
            var tile = {coord:coord, tileSize: tileSize};

            gl.uniform2fv(shader.u_patternscale_a, [
                1 / pixelsToTileUnits(tile, imageSizeScaledA[0], painter.transform.tileZoom),
                1 / pixelsToTileUnits(tile, imageSizeScaledA[1], painter.transform.tileZoom)
            ]);

            gl.uniform2fv(shader.u_patternscale_b, [
                1 / pixelsToTileUnits(tile, imageSizeScaledB[0], painter.transform.tileZoom),
                1 / pixelsToTileUnits(tile, imageSizeScaledB[1], painter.transform.tileZoom)
            ]);
            var tileSizeAtNearestZoom = tileSize * Math.pow(2, painter.transform.tileZoom - coord.z);

            var offsetAx = ((tileSizeAtNearestZoom / imageSizeScaledA[0]) % 1) * (coord.x + coord.w * Math.pow(2, coord.z));
            var offsetAy = ((tileSizeAtNearestZoom / imageSizeScaledA[1]) % 1) * coord.y;

            var offsetBx = ((tileSizeAtNearestZoom / imageSizeScaledB[0]) % 1) * (coord.x + coord.w * Math.pow(2, coord.z));
            var offsetBy = ((tileSizeAtNearestZoom / imageSizeScaledB[1]) % 1) * coord.y;

            gl.uniform2fv(shader.u_offset_a, [offsetAx, offsetAy]);
            gl.uniform2fv(shader.u_offset_b, [offsetBx, offsetBy]);
        }

        gl.setPosMatrix(painter.calculatePosMatrix(coord));
        gl.drawArrays(gl.TRIANGLE_STRIP, 0, painter.tileExtentBuffer.itemCount);
    }

    gl.stencilMask(0x00);
    gl.stencilFunc(gl.EQUAL, 0x80, 0x80);
}


},{"../source/pixels_to_tile_units":31,"../source/tile_pyramid":36,"../util/util":104}],16:[function(require,module,exports){
'use strict';

var browser = require('../util/browser');
var util = require('../util/util');

module.exports = drawCircles;

function drawCircles(painter, source, layer, coords) {
    if (painter.isOpaquePass) return;

    var gl = painter.gl;

    var shader = painter.circleShader;
    painter.gl.switchShader(shader);

    painter.setDepthSublayer(0);
    painter.depthMask(false);

    // Allow circles to be drawn across boundaries, so that
    // large circles are not clipped to tiles
    gl.disable(gl.STENCIL_TEST);

    // antialiasing factor: this is a minimum blur distance that serves as
    // a faux-antialiasing for the circle. since blur is a ratio of the circle's
    // size and the intent is to keep the blur at roughly 1px, the two
    // are inversely related.
    var antialias = 1 / browser.devicePixelRatio / layer.paint['circle-radius'];

    var color = util.premultiply(layer.paint['circle-color'], layer.paint['circle-opacity']);
    gl.uniform4fv(shader.u_color, color);
    gl.uniform1f(shader.u_blur, Math.max(layer.paint['circle-blur'], antialias));
    gl.uniform1f(shader.u_size, layer.paint['circle-radius']);

    for (var i = 0; i < coords.length; i++) {
        var coord = coords[i];

        var tile = source.getTile(coord);
        var bucket = tile.getBucket(layer);
        if (!bucket) continue;
        var elementGroups = bucket.elementGroups.circle;
        if (!elementGroups) continue;

        var vertex = bucket.buffers.circleVertex;
        var elements = bucket.buffers.circleElement;

        gl.setPosMatrix(painter.translatePosMatrix(
            painter.calculatePosMatrix(coord, source.maxzoom),
            tile,
            layer.paint['circle-translate'],
            layer.paint['circle-translate-anchor']
        ));
        gl.setExMatrix(painter.transform.exMatrix);

        for (var k = 0; k < elementGroups.length; k++) {
            var group = elementGroups[k];
            var offset = group.vertexStartIndex * vertex.itemSize;

            vertex.bind(gl);
            vertex.setAttribPointers(gl, shader, offset);

            elements.bind(gl);

            var count = group.elementLength * 3;
            var elementOffset = group.elementStartIndex * elements.itemSize;
            gl.drawElements(gl.TRIANGLES, count, gl.UNSIGNED_SHORT, elementOffset);
        }
    }
}

},{"../util/browser":89,"../util/util":104}],17:[function(require,module,exports){
'use strict';

module.exports = drawCollisionDebug;

function drawCollisionDebug(painter, source, layer, coords) {
    var gl = painter.gl;
    var shader = painter.collisionBoxShader;
    gl.enable(gl.STENCIL_TEST);
    gl.switchShader(shader);

    for (var i = 0; i < coords.length; i++) {
        var coord = coords[i];
        var tile = source.getTile(coord);
        var bucket = tile.getBucket(layer);
        if (!bucket) continue;
        var elementGroups = bucket.elementGroups.collisionBox;

        if (!elementGroups) continue;
        if (!bucket.buffers) continue;
        if (elementGroups[0].vertexLength === 0) continue;

        var buffer = bucket.buffers.collisionBoxVertex;
        buffer.bind(gl);
        buffer.setAttribPointers(gl, shader, 0);

        var posMatrix = painter.calculatePosMatrix(coord, source.maxzoom);
        gl.setPosMatrix(posMatrix);

        painter.enableTileClippingMask(coord);

        gl.lineWidth(1);
        gl.uniform1f(shader.u_scale, Math.pow(2, painter.transform.zoom - tile.coord.z));
        gl.uniform1f(shader.u_zoom, painter.transform.zoom * 10);
        gl.uniform1f(shader.u_maxzoom, (tile.coord.z + 1) * 10);

        gl.drawArrays(
            gl.LINES,
            elementGroups[0].vertexStartIndex,
            elementGroups[0].vertexLength
        );

    }
}

},{}],18:[function(require,module,exports){
'use strict';

var textVertices = require('../lib/debugtext');
var browser = require('../util/browser');
var mat4 = require('gl-matrix').mat4;
var EXTENT = require('../data/bucket').EXTENT;

module.exports = drawDebug;

function drawDebug(painter, source, coords) {
    if (painter.isOpaquePass) return;
    if (!painter.options.debug) return;

    for (var i = 0; i < coords.length; i++) {
        drawDebugTile(painter, source, coords[i]);
    }
}

function drawDebugTile(painter, source, coord) {
    var gl = painter.gl;

    gl.disable(gl.STENCIL_TEST);
    gl.lineWidth(1 * browser.devicePixelRatio);

    var posMatrix = painter.calculatePosMatrix(coord, source.maxzoom);
    var shader = painter.debugShader;
    gl.switchShader(shader, posMatrix);

    // draw bounding rectangle
    gl.bindBuffer(gl.ARRAY_BUFFER, painter.debugBuffer);
    gl.vertexAttribPointer(shader.a_pos, painter.debugBuffer.itemSize, gl.SHORT, false, 0, 0);
    gl.uniform4f(shader.u_color, 1, 0, 0, 1);
    gl.drawArrays(gl.LINE_STRIP, 0, painter.debugBuffer.itemCount);

    var vertices = textVertices(coord.toString(), 50, 200, 5);
    gl.bindBuffer(gl.ARRAY_BUFFER, painter.debugTextBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Int16Array(vertices), gl.STREAM_DRAW);
    gl.vertexAttribPointer(shader.a_pos, painter.debugTextBuffer.itemSize, gl.SHORT, false, 0, 0);
    gl.uniform4f(shader.u_color, 1, 1, 1, 1);

    // Draw the halo with multiple 1px lines instead of one wider line because
    // the gl spec doesn't guarantee support for lines with width > 1.
    var tileSize = source.getTile(coord).tileSize;
    var onePixel = EXTENT / (Math.pow(2, painter.transform.zoom - coord.z) * tileSize);
    var translations = [[-1, -1], [-1, 1], [1, -1], [1, 1]];
    for (var i = 0; i < translations.length; i++) {
        var translation = translations[i];
        gl.setPosMatrix(mat4.translate([], posMatrix, [onePixel * translation[0], onePixel * translation[1], 0]));
        gl.drawArrays(gl.LINES, 0, vertices.length / painter.debugTextBuffer.itemSize);
    }

    gl.uniform4f(shader.u_color, 0, 0, 0, 1);
    gl.setPosMatrix(posMatrix);
    gl.drawArrays(gl.LINES, 0, vertices.length / painter.debugTextBuffer.itemSize);
}

},{"../data/bucket":1,"../lib/debugtext":13,"../util/browser":89,"gl-matrix":124}],19:[function(require,module,exports){
'use strict';

var util = require('../util/util');
var pixelsToTileUnits = require('../source/pixels_to_tile_units');

module.exports = draw;

function draw(painter, source, layer, coords) {
    var gl = painter.gl;
    gl.enable(gl.STENCIL_TEST);

    var color = util.premultiply(layer.paint['fill-color'], layer.paint['fill-opacity']);
    var image = layer.paint['fill-pattern'];
    var strokeColor = util.premultiply(layer.paint['fill-outline-color'], layer.paint['fill-opacity']);

    // Draw fill
    if (image ? !painter.isOpaquePass : painter.isOpaquePass === (color[3] === 1)) {
        // Once we switch to earcut drawing we can pull most of the WebGL setup
        // outside of this coords loop.
        for (var i = 0; i < coords.length; i++) {
            drawFill(painter, source, layer, coords[i]);
        }
    }

    // Draw stroke
    if (!painter.isOpaquePass && layer.paint['fill-antialias'] && !(layer.paint['fill-pattern'] && !strokeColor)) {
        gl.switchShader(painter.outlineShader);
        gl.lineWidth(2);
        painter.depthMask(false);

        if (strokeColor) {
            // If we defined a different color for the fill outline, we are
            // going to ignore the bits in 0x07 and just care about the global
            // clipping mask.
            painter.setDepthSublayer(2);

        } else {
            // Otherwise, we only want to drawFill the antialiased parts that are
            // *outside* the current shape. This is important in case the fill
            // or stroke color is translucent. If we wouldn't clip to outside
            // the current shape, some pixels from the outline stroke overlapped
            // the (non-antialiased) fill.
            painter.setDepthSublayer(0);
        }

        gl.uniform2f(painter.outlineShader.u_world, gl.drawingBufferWidth, gl.drawingBufferHeight);
        gl.uniform4fv(painter.outlineShader.u_color, strokeColor ? strokeColor : color);

        for (var j = 0; j < coords.length; j++) {
            drawStroke(painter, source, layer, coords[j]);
        }
    }
}

function drawFill(painter, source, layer, coord) {
    var tile = source.getTile(coord);
    var bucket = tile.getBucket(layer);
    if (!bucket) return;
    var elementGroups = bucket.elementGroups.fill;
    if (!elementGroups) return;

    var gl = painter.gl;

    var color = util.premultiply(layer.paint['fill-color'], layer.paint['fill-opacity']);
    var image = layer.paint['fill-pattern'];
    var opacity = layer.paint['fill-opacity'];

    var posMatrix = painter.calculatePosMatrix(coord, source.maxzoom);
    var translatedPosMatrix = painter.translatePosMatrix(posMatrix, tile, layer.paint['fill-translate'], layer.paint['fill-translate-anchor']);

    // Draw the stencil mask.
    painter.setDepthSublayer(1);

    // We're only drawFilling to the first seven bits (== support a maximum of
    // 8 overlapping polygons in one place before we get rendering errors).
    gl.stencilMask(0x07);
    gl.clear(gl.STENCIL_BUFFER_BIT);

    // Draw front facing triangles. Wherever the 0x80 bit is 1, we are
    // increasing the lower 7 bits by one if the triangle is a front-facing
    // triangle. This means that all visible polygons should be in CCW
    // orientation, while all holes (see below) are in CW orientation.
    painter.enableTileClippingMask(coord);

    // When we do a nonzero fill, we count the number of times a pixel is
    // covered by a counterclockwise polygon, and subtract the number of
    // times it is "uncovered" by a clockwise polygon.
    gl.stencilOpSeparate(gl.FRONT, gl.KEEP, gl.KEEP, gl.INCR_WRAP);
    gl.stencilOpSeparate(gl.BACK, gl.KEEP, gl.KEEP, gl.DECR_WRAP);

    // When drawFilling a shape, we first drawFill all shapes to the stencil buffer
    // and incrementing all areas where polygons are
    gl.colorMask(false, false, false, false);
    painter.depthMask(false);

    // Draw the actual triangle fan into the stencil buffer.
    gl.switchShader(painter.fillShader, translatedPosMatrix);

    // Draw all buffers
    var vertex = bucket.buffers.fillVertex;
    vertex.bind(gl);

    var elements = bucket.buffers.fillElement;
    elements.bind(gl);

    for (var i = 0; i < elementGroups.length; i++) {
        var group = elementGroups[i];
        var offset = group.vertexStartIndex * vertex.itemSize;
        vertex.setAttribPointers(gl, painter.fillShader, offset);

        var count = group.elementLength * 3;
        var elementOffset = group.elementStartIndex * elements.itemSize;
        gl.drawElements(gl.TRIANGLES, count, gl.UNSIGNED_SHORT, elementOffset);
    }

    // Now that we have the stencil mask in the stencil buffer, we can start
    // writing to the color buffer.
    gl.colorMask(true, true, true, true);
    painter.depthMask(true);

    // From now on, we don't want to update the stencil buffer anymore.
    gl.stencilOp(gl.KEEP, gl.KEEP, gl.KEEP);
    gl.stencilMask(0x0);
    var shader;

    if (image) {
        // Draw texture fill
        var imagePosA = painter.spriteAtlas.getPosition(image.from, true);
        var imagePosB = painter.spriteAtlas.getPosition(image.to, true);
        if (!imagePosA || !imagePosB) return;

        shader = painter.patternShader;
        gl.switchShader(shader, posMatrix);
        gl.uniform1i(shader.u_image, 0);
        gl.uniform2fv(shader.u_pattern_tl_a, imagePosA.tl);
        gl.uniform2fv(shader.u_pattern_br_a, imagePosA.br);
        gl.uniform2fv(shader.u_pattern_tl_b, imagePosB.tl);
        gl.uniform2fv(shader.u_pattern_br_b, imagePosB.br);
        gl.uniform1f(shader.u_opacity, opacity);
        gl.uniform1f(shader.u_mix, image.t);

        var imageSizeScaledA = [
            (imagePosA.size[0] * image.fromScale),
            (imagePosA.size[1] * image.fromScale)
        ];
        var imageSizeScaledB = [
            (imagePosB.size[0] * image.toScale),
            (imagePosB.size[1] * image.toScale)
        ];

        gl.uniform2fv(shader.u_patternscale_a, [
            1 / pixelsToTileUnits(tile, imageSizeScaledA[0], painter.transform.tileZoom),
            1 / pixelsToTileUnits(tile, imageSizeScaledA[1], painter.transform.tileZoom)
        ]);

        gl.uniform2fv(shader.u_patternscale_b, [
            1 / pixelsToTileUnits(tile, imageSizeScaledB[0], painter.transform.tileZoom),
            1 / pixelsToTileUnits(tile, imageSizeScaledB[1], painter.transform.tileZoom)
        ]);

        var tileSizeAtNearestZoom = tile.tileSize * Math.pow(2, painter.transform.tileZoom - tile.coord.z);

        // shift images to match at tile boundaries
        var offsetAx = ((tileSizeAtNearestZoom / imageSizeScaledA[0]) % 1) * (tile.coord.x + coord.w * Math.pow(2, tile.coord.z));
        var offsetAy = ((tileSizeAtNearestZoom / imageSizeScaledA[1]) % 1) * tile.coord.y;

        var offsetBx = ((tileSizeAtNearestZoom / imageSizeScaledB[0]) % 1) * (tile.coord.x + coord.w * Math.pow(2, tile.coord.z));
        var offsetBy = ((tileSizeAtNearestZoom / imageSizeScaledB[1]) % 1) * tile.coord.y;

        gl.uniform2fv(shader.u_offset_a, [offsetAx, offsetAy]);
        gl.uniform2fv(shader.u_offset_b, [offsetBx, offsetBy]);

        gl.activeTexture(gl.TEXTURE0);
        painter.spriteAtlas.bind(gl, true);

    } else {
        // Draw filling rectangle.
        shader = painter.fillShader;
        gl.switchShader(shader, posMatrix);
        gl.uniform4fv(shader.u_color, color);
    }

    // Only draw regions that we marked
    gl.stencilFunc(gl.NOTEQUAL, 0x0, 0x07);
    gl.bindBuffer(gl.ARRAY_BUFFER, painter.tileExtentBuffer);
    gl.vertexAttribPointer(shader.a_pos, painter.tileExtentBuffer.itemSize, gl.SHORT, false, 0, 0);
    gl.drawArrays(gl.TRIANGLE_STRIP, 0, painter.tileExtentBuffer.itemCount);

    gl.stencilMask(0x00);
}

function drawStroke(painter, source, layer, coord) {
    var tile = source.getTile(coord);
    var bucket = tile.getBucket(layer);
    if (!bucket) return;

    var gl = painter.gl;
    var elementGroups = bucket.elementGroups.fill;

    gl.setPosMatrix(painter.translatePosMatrix(
        painter.calculatePosMatrix(coord, source.maxzoom),
        tile,
        layer.paint['fill-translate'],
        layer.paint['fill-translate-anchor']
    ));

    // Draw all buffers
    var vertex = bucket.buffers.fillVertex;
    var elements = bucket.buffers.fillSecondElement;
    vertex.bind(gl);
    elements.bind(gl);

    painter.enableTileClippingMask(coord);

    for (var k = 0; k < elementGroups.length; k++) {
        var group = elementGroups[k];
        var offset = group.vertexStartIndex * vertex.itemSize;
        vertex.setAttribPointers(gl, painter.outlineShader, offset);

        var count = group.secondElementLength * 2;
        var elementOffset = group.secondElementStartIndex * elements.itemSize;
        gl.drawElements(gl.LINES, count, gl.UNSIGNED_SHORT, elementOffset);
    }
}

},{"../source/pixels_to_tile_units":31,"../util/util":104}],20:[function(require,module,exports){
'use strict';

var browser = require('../util/browser');
var mat2 = require('gl-matrix').mat2;
var util = require('../util/util');
var pixelsToTileUnits = require('../source/pixels_to_tile_units');

/**
 * Draw a line. Under the hood this will read elements from
 * a tile, dash textures from a lineAtlas, and style properties from a layer.
 * @param {Object} painter
 * @param {Object} layer
 * @param {Object} posMatrix
 * @param {Tile} tile
 * @returns {undefined} draws with the painter
 * @private
 */
module.exports = function drawLine(painter, source, layer, coords) {
    if (painter.isOpaquePass) return;
    painter.setDepthSublayer(0);
    painter.depthMask(false);

    var hasData = coords.some(function(coord) {
        var bucket = source.getTile(coord).getBucket(layer);
        return bucket && bucket.elementGroups.line;
    });
    if (!hasData) return;

    var gl = painter.gl;
    gl.enable(gl.STENCIL_TEST);

    // don't draw zero-width lines
    if (layer.paint['line-width'] <= 0) return;

    // the distance over which the line edge fades out.
    // Retina devices need a smaller distance to avoid aliasing.
    var antialiasing = 1 / browser.devicePixelRatio;

    var blur = layer.paint['line-blur'] + antialiasing;
    var edgeWidth = layer.paint['line-width'] / 2;
    var inset = -1;
    var offset = 0;
    var shift = 0;

    if (layer.paint['line-gap-width'] > 0) {
        inset = layer.paint['line-gap-width'] / 2 + antialiasing * 0.5;
        edgeWidth = layer.paint['line-width'];

        // shift outer lines half a pixel towards the middle to eliminate the crack
        offset = inset - antialiasing / 2;
    }

    var outset = offset + edgeWidth + antialiasing / 2 + shift;
    var color = util.premultiply(layer.paint['line-color'], layer.paint['line-opacity']);

    var tr = painter.transform;

    var antialiasingMatrix = mat2.create();
    mat2.scale(antialiasingMatrix, antialiasingMatrix, [1, Math.cos(tr._pitch)]);
    mat2.rotate(antialiasingMatrix, antialiasingMatrix, painter.transform.angle);

    // calculate how much longer the real world distance is at the top of the screen
    // than at the middle of the screen.
    var topedgelength = Math.sqrt(tr.height * tr.height / 4  * (1 + tr.altitude * tr.altitude));
    var x = tr.height / 2 * Math.tan(tr._pitch);
    var extra = (topedgelength + x) / topedgelength - 1;

    var dasharray = layer.paint['line-dasharray'];
    var image = layer.paint['line-pattern'];
    var shader, posA, posB, imagePosA, imagePosB;

    if (dasharray) {
        shader = painter.linesdfpatternShader;
        gl.switchShader(shader);

        gl.uniform2fv(shader.u_linewidth, [ outset, inset ]);
        gl.uniform1f(shader.u_blur, blur);
        gl.uniform4fv(shader.u_color, color);

        posA = painter.lineAtlas.getDash(dasharray.from, layer.layout['line-cap'] === 'round');
        posB = painter.lineAtlas.getDash(dasharray.to, layer.layout['line-cap'] === 'round');

        gl.uniform1i(shader.u_image, 0);
        gl.activeTexture(gl.TEXTURE0);
        painter.lineAtlas.bind(gl);

        gl.uniform1f(shader.u_tex_y_a, posA.y);
        gl.uniform1f(shader.u_tex_y_b, posB.y);
        gl.uniform1f(shader.u_mix, dasharray.t);

        gl.uniform1f(shader.u_extra, extra);
        gl.uniform1f(shader.u_offset, -layer.paint['line-offset']);
        gl.uniformMatrix2fv(shader.u_antialiasingmatrix, false, antialiasingMatrix);

    } else if (image) {
        imagePosA = painter.spriteAtlas.getPosition(image.from, true);
        imagePosB = painter.spriteAtlas.getPosition(image.to, true);
        if (!imagePosA || !imagePosB) return;

        shader = painter.linepatternShader;
        gl.switchShader(shader);

        gl.uniform1i(shader.u_image, 0);
        gl.activeTexture(gl.TEXTURE0);
        painter.spriteAtlas.bind(gl, true);

        gl.uniform2fv(shader.u_linewidth, [ outset, inset ]);
        gl.uniform1f(shader.u_blur, blur);
        gl.uniform2fv(shader.u_pattern_tl_a, imagePosA.tl);
        gl.uniform2fv(shader.u_pattern_br_a, imagePosA.br);
        gl.uniform2fv(shader.u_pattern_tl_b, imagePosB.tl);
        gl.uniform2fv(shader.u_pattern_br_b, imagePosB.br);
        gl.uniform1f(shader.u_fade, image.t);
        gl.uniform1f(shader.u_opacity, layer.paint['line-opacity']);

        gl.uniform1f(shader.u_extra, extra);
        gl.uniform1f(shader.u_offset, -layer.paint['line-offset']);
        gl.uniformMatrix2fv(shader.u_antialiasingmatrix, false, antialiasingMatrix);

    } else {
        shader = painter.lineShader;
        gl.switchShader(shader);

        gl.uniform2fv(shader.u_linewidth, [ outset, inset ]);
        gl.uniform1f(shader.u_blur, blur);
        gl.uniform1f(shader.u_extra, extra);
        gl.uniform1f(shader.u_offset, -layer.paint['line-offset']);
        gl.uniformMatrix2fv(shader.u_antialiasingmatrix, false, antialiasingMatrix);
        gl.uniform4fv(shader.u_color, color);
    }

    for (var k = 0; k < coords.length; k++) {
        var coord = coords[k];
        var tile = source.getTile(coord);
        var bucket = tile.getBucket(layer);
        if (!bucket) continue;
        var elementGroups = bucket.elementGroups.line;
        if (!elementGroups) continue;

        painter.enableTileClippingMask(coord);

        // set uniforms that are different for each tile
        var posMatrix = painter.translatePosMatrix(painter.calculatePosMatrix(coord, source.maxzoom), tile, layer.paint['line-translate'], layer.paint['line-translate-anchor']);

        gl.setPosMatrix(posMatrix);
        gl.setExMatrix(painter.transform.exMatrix);
        var ratio = 1 / pixelsToTileUnits(tile, 1, painter.transform.zoom);

        if (dasharray) {
            var widthA = posA.width * dasharray.fromScale;
            var widthB = posB.width * dasharray.toScale;
            var scaleA = [1 / pixelsToTileUnits(tile, widthA, painter.transform.tileZoom), -posA.height / 2];
            var scaleB = [1 / pixelsToTileUnits(tile, widthB, painter.transform.tileZoom), -posB.height / 2];
            var gamma = painter.lineAtlas.width / (Math.min(widthA, widthB) * 256 * browser.devicePixelRatio) / 2;
            gl.uniform1f(shader.u_ratio, ratio);
            gl.uniform2fv(shader.u_patternscale_a, scaleA);
            gl.uniform2fv(shader.u_patternscale_b, scaleB);
            gl.uniform1f(shader.u_sdfgamma, gamma);

        } else if (image) {
            gl.uniform1f(shader.u_ratio, ratio);
            gl.uniform2fv(shader.u_pattern_size_a, [
                pixelsToTileUnits(tile, imagePosA.size[0] * image.fromScale, painter.transform.tileZoom),
                imagePosB.size[1]
            ]);
            gl.uniform2fv(shader.u_pattern_size_b, [
                pixelsToTileUnits(tile, imagePosB.size[0] * image.toScale, painter.transform.tileZoom),
                imagePosB.size[1]
            ]);

        } else {
            gl.uniform1f(shader.u_ratio, ratio);
        }

        var vertex = bucket.buffers.lineVertex;
        vertex.bind(gl);
        var element = bucket.buffers.lineElement;
        element.bind(gl);

        for (var i = 0; i < elementGroups.length; i++) {
            var group = elementGroups[i];
            var vtxOffset = group.vertexStartIndex * vertex.itemSize;
            gl.vertexAttribPointer(shader.a_pos, 2, gl.SHORT, false, 8, vtxOffset + 0);
            gl.vertexAttribPointer(shader.a_data, 4, gl.UNSIGNED_BYTE, false, 8, vtxOffset + 4);

            var count = group.elementLength * 3;
            var elementOffset = group.elementStartIndex * element.itemSize;
            gl.drawElements(gl.TRIANGLES, count, gl.UNSIGNED_SHORT, elementOffset);
        }
    }

};

},{"../source/pixels_to_tile_units":31,"../util/browser":89,"../util/util":104,"gl-matrix":124}],21:[function(require,module,exports){
'use strict';

var util = require('../util/util');

module.exports = drawRaster;

function drawRaster(painter, source, layer, coords) {
    if (painter.isOpaquePass) return;

    var gl = painter.gl;

    gl.enable(gl.DEPTH_TEST);
    painter.depthMask(true);

    // Change depth function to prevent double drawing in areas where tiles overlap.
    gl.depthFunc(gl.LESS);

    var minTileZ = coords.length && coords[0].z;

    for (var i = 0; i < coords.length; i++) {
        var coord = coords[i];
        // set the lower zoom level to sublayer 0, and higher zoom levels to higher sublayers
        painter.setDepthSublayer(coord.z - minTileZ);
        drawRasterTile(painter, source, layer, coord);
    }

    gl.depthFunc(gl.LEQUAL);
}

function drawRasterTile(painter, source, layer, coord) {

    var gl = painter.gl;

    gl.disable(gl.STENCIL_TEST);

    var tile = source.getTile(coord);
    var posMatrix = painter.calculatePosMatrix(coord, source.maxzoom);

    var shader = painter.rasterShader;
    gl.switchShader(shader, posMatrix);

    // color parameters
    gl.uniform1f(shader.u_brightness_low, layer.paint['raster-brightness-min']);
    gl.uniform1f(shader.u_brightness_high, layer.paint['raster-brightness-max']);
    gl.uniform1f(shader.u_saturation_factor, saturationFactor(layer.paint['raster-saturation']));
    gl.uniform1f(shader.u_contrast_factor, contrastFactor(layer.paint['raster-contrast']));
    gl.uniform3fv(shader.u_spin_weights, spinWeights(layer.paint['raster-hue-rotate']));

    var parentTile = tile.source && tile.source._pyramid.findLoadedParent(coord, 0, {}),
        opacities = getOpacities(tile, parentTile, layer, painter.transform);

    var parentScaleBy, parentTL;

    gl.activeTexture(gl.TEXTURE0);
    gl.bindTexture(gl.TEXTURE_2D, tile.texture);

    if (parentTile) {
        gl.activeTexture(gl.TEXTURE1);
        gl.bindTexture(gl.TEXTURE_2D, parentTile.texture);

        parentScaleBy = Math.pow(2, parentTile.coord.z - tile.coord.z);
        parentTL = [tile.coord.x * parentScaleBy % 1, tile.coord.y * parentScaleBy % 1];
    } else {
        opacities[1] = 0;
    }

    // cross-fade parameters
    gl.uniform2fv(shader.u_tl_parent, parentTL || [0, 0]);
    gl.uniform1f(shader.u_scale_parent, parentScaleBy || 1);
    gl.uniform1f(shader.u_buffer_scale, 1);
    gl.uniform1f(shader.u_opacity0, opacities[0]);
    gl.uniform1f(shader.u_opacity1, opacities[1]);
    gl.uniform1i(shader.u_image0, 0);
    gl.uniform1i(shader.u_image1, 1);

    gl.bindBuffer(gl.ARRAY_BUFFER, tile.boundsBuffer || painter.tileExtentBuffer);

    gl.vertexAttribPointer(shader.a_pos,         2, gl.SHORT, false, 8, 0);
    gl.vertexAttribPointer(shader.a_texture_pos, 2, gl.SHORT, false, 8, 4);
    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
}

function spinWeights(angle) {
    angle *= Math.PI / 180;
    var s = Math.sin(angle);
    var c = Math.cos(angle);
    return [
        (2 * c + 1) / 3,
        (-Math.sqrt(3) * s - c + 1) / 3,
        (Math.sqrt(3) * s - c + 1) / 3
    ];
}

function contrastFactor(contrast) {
    return contrast > 0 ?
        1 / (1 - contrast) :
        1 + contrast;
}

function saturationFactor(saturation) {
    return saturation > 0 ?
        1 - 1 / (1.001 - saturation) :
        -saturation;
}

function getOpacities(tile, parentTile, layer, transform) {
    var opacity = [1, 0];
    var fadeDuration = layer.paint['raster-fade-duration'];

    if (tile.source && fadeDuration > 0) {
        var now = new Date().getTime();

        var sinceTile = (now - tile.timeAdded) / fadeDuration;
        var sinceParent = parentTile ? (now - parentTile.timeAdded) / fadeDuration : -1;

        var idealZ = tile.source._pyramid.coveringZoomLevel(transform);
        var parentFurther = parentTile ? Math.abs(parentTile.coord.z - idealZ) > Math.abs(tile.coord.z - idealZ) : false;

        if (!parentTile || parentFurther) {
            // if no parent or parent is older
            opacity[0] = util.clamp(sinceTile, 0, 1);
            opacity[1] = 1 - opacity[0];
        } else {
            // parent is younger, zooming out
            opacity[0] = util.clamp(1 - sinceParent, 0, 1);
            opacity[1] = 1 - opacity[0];
        }
    }

    var op = layer.paint['raster-opacity'];
    opacity[0] *= op;
    opacity[1] *= op;

    return opacity;
}

},{"../util/util":104}],22:[function(require,module,exports){
'use strict';

var mat4 = require('gl-matrix').mat4;

var browser = require('../util/browser');
var drawCollisionDebug = require('./draw_collision_debug');
var util = require('../util/util');
var pixelsToTileUnits = require('../source/pixels_to_tile_units');


module.exports = drawSymbols;

function drawSymbols(painter, source, layer, coords) {
    if (painter.isOpaquePass) return;

    var drawAcrossEdges = !(layer.layout['text-allow-overlap'] || layer.layout['icon-allow-overlap'] ||
        layer.layout['text-ignore-placement'] || layer.layout['icon-ignore-placement']);

    var gl = painter.gl;

    // Disable the stencil test so that labels aren't clipped to tile boundaries.
    //
    // Layers with features that may be drawn overlapping aren't clipped. These
    // layers are sorted in the y direction, and to draw the correct ordering near
    // tile edges the icons are included in both tiles and clipped when drawing.
    if (drawAcrossEdges) {
        gl.disable(gl.STENCIL_TEST);
    } else {
        gl.enable(gl.STENCIL_TEST);
    }

    painter.setDepthSublayer(0);
    painter.depthMask(false);
    gl.disable(gl.DEPTH_TEST);

    var tile, elementGroups, bucket, posMatrix;

    for (var i = 0; i < coords.length; i++) {
        tile = source.getTile(coords[i]);
        bucket = tile.getBucket(layer);
        if (!bucket) continue;
        elementGroups = bucket.elementGroups;
        if (!elementGroups.icon.length) continue;

        posMatrix = painter.calculatePosMatrix(coords[i], source.maxzoom);
        painter.enableTileClippingMask(coords[i]);
        drawSymbol(painter, layer, posMatrix, tile, bucket, elementGroups.icon, 'icon', elementGroups.sdfIcons, elementGroups.iconsNeedLinear);
    }

    for (var j = 0; j < coords.length; j++) {
        tile = source.getTile(coords[j]);
        bucket = tile.getBucket(layer);
        if (!bucket) continue;
        elementGroups = bucket.elementGroups;
        if (!elementGroups.glyph.length) continue;

        posMatrix = painter.calculatePosMatrix(coords[j], source.maxzoom);
        painter.enableTileClippingMask(coords[j]);
        drawSymbol(painter, layer, posMatrix, tile, bucket, elementGroups.glyph, 'text', true, false);
    }

    gl.enable(gl.DEPTH_TEST);

    drawCollisionDebug(painter, source, layer, coords);
}

var defaultSizes = {
    icon: 1,
    text: 24
};

function drawSymbol(painter, layer, posMatrix, tile, bucket, elementGroups, prefix, sdf, iconsNeedLinear) {
    var gl = painter.gl;

    posMatrix = painter.translatePosMatrix(posMatrix, tile, layer.paint[prefix + '-translate'], layer.paint[prefix + '-translate-anchor']);

    var tr = painter.transform;
    var alignedWithMap = layer.layout[prefix + '-rotation-alignment'] === 'map';
    var skewed = alignedWithMap;
    var exMatrix, s, gammaScale;

    if (skewed) {
        exMatrix = mat4.create();
        s = pixelsToTileUnits(tile, 1, painter.transform.zoom);
        gammaScale = 1 / Math.cos(tr._pitch);
    } else {
        exMatrix = mat4.clone(painter.transform.exMatrix);
        s = painter.transform.altitude;
        gammaScale = 1;
    }
    mat4.scale(exMatrix, exMatrix, [s, s, 1]);

    var fontSize = layer.layout[prefix + '-size'];
    var fontScale = fontSize / defaultSizes[prefix];
    mat4.scale(exMatrix, exMatrix, [ fontScale, fontScale, 1 ]);

    // calculate how much longer the real world distance is at the top of the screen
    // than at the middle of the screen.
    var topedgelength = Math.sqrt(tr.height * tr.height / 4  * (1 + tr.altitude * tr.altitude));
    var x = tr.height / 2 * Math.tan(tr._pitch);
    var extra = (topedgelength + x) / topedgelength - 1;

    var text = prefix === 'text';
    var shader, vertex, elements, texsize;

    if (!text && !painter.style.sprite.loaded())
        return;

    gl.activeTexture(gl.TEXTURE0);

    if (sdf) {
        shader = painter.sdfShader;
    } else {
        shader = painter.iconShader;
    }

    if (text) {
        // use the fonstack used when parsing the tile, not the fontstack
        // at the current zoom level (layout['text-font']).
        var fontstack = elementGroups.fontstack;
        var glyphAtlas = fontstack && painter.glyphSource.getGlyphAtlas(fontstack);
        if (!glyphAtlas) return;

        glyphAtlas.updateTexture(gl);
        vertex = bucket.buffers.glyphVertex;
        elements = bucket.buffers.glyphElement;
        texsize = [glyphAtlas.width / 4, glyphAtlas.height / 4];
    } else {
        var mapMoving = painter.options.rotating || painter.options.zooming;
        var iconScaled = fontScale !== 1 || browser.devicePixelRatio !== painter.spriteAtlas.pixelRatio || iconsNeedLinear;
        var iconTransformed = alignedWithMap || painter.transform.pitch;
        painter.spriteAtlas.bind(gl, sdf || mapMoving || iconScaled || iconTransformed);
        vertex = bucket.buffers.iconVertex;
        elements = bucket.buffers.iconElement;
        texsize = [painter.spriteAtlas.width / 4, painter.spriteAtlas.height / 4];
    }

    gl.switchShader(shader, posMatrix, exMatrix);
    gl.uniform1i(shader.u_texture, 0);
    gl.uniform2fv(shader.u_texsize, texsize);
    gl.uniform1i(shader.u_skewed, skewed);
    gl.uniform1f(shader.u_extra, extra);

    // adjust min/max zooms for variable font sizes
    var zoomAdjust = Math.log(fontSize / elementGroups.adjustedSize) / Math.LN2 || 0;


    gl.uniform1f(shader.u_zoom, (painter.transform.zoom - zoomAdjust) * 10); // current zoom level

    var f = painter.frameHistory.getFadeProperties(300);
    gl.uniform1f(shader.u_fadedist, f.fadedist * 10);
    gl.uniform1f(shader.u_minfadezoom, Math.floor(f.minfadezoom * 10));
    gl.uniform1f(shader.u_maxfadezoom, Math.floor(f.maxfadezoom * 10));
    gl.uniform1f(shader.u_fadezoom, (painter.transform.zoom + f.bump) * 10);

    var group, offset, count, elementOffset;

    elements.bind(gl);

    if (sdf) {
        var sdfPx = 8;
        var blurOffset = 1.19;
        var haloOffset = 6;
        var gamma = 0.105 * defaultSizes[prefix] / fontSize / browser.devicePixelRatio;

        if (layer.paint[prefix + '-halo-width']) {
            var haloColor = util.premultiply(layer.paint[prefix + '-halo-color'], layer.paint[prefix + '-opacity']);

            // Draw halo underneath the text.
            gl.uniform1f(shader.u_gamma, (layer.paint[prefix + '-halo-blur'] * blurOffset / fontScale / sdfPx + gamma) * gammaScale);
            gl.uniform4fv(shader.u_color, haloColor);
            gl.uniform1f(shader.u_buffer, (haloOffset - layer.paint[prefix + '-halo-width'] / fontScale) / sdfPx);

            for (var j = 0; j < elementGroups.length; j++) {
                group = elementGroups[j];
                offset = group.vertexStartIndex * vertex.itemSize;
                vertex.bind(gl);
                vertex.setAttribPointers(gl, shader, offset);

                count = group.elementLength * 3;
                elementOffset = group.elementStartIndex * elements.itemSize;
                gl.drawElements(gl.TRIANGLES, count, gl.UNSIGNED_SHORT, elementOffset);
            }
        }

        var color = util.premultiply(layer.paint[prefix + '-color'], layer.paint[prefix + '-opacity']);
        gl.uniform1f(shader.u_gamma, gamma * gammaScale);
        gl.uniform4fv(shader.u_color, color);
        gl.uniform1f(shader.u_buffer, (256 - 64) / 256);

        for (var i = 0; i < elementGroups.length; i++) {
            group = elementGroups[i];
            offset = group.vertexStartIndex * vertex.itemSize;
            vertex.bind(gl);
            vertex.setAttribPointers(gl, shader, offset);

            count = group.elementLength * 3;
            elementOffset = group.elementStartIndex * elements.itemSize;
            gl.drawElements(gl.TRIANGLES, count, gl.UNSIGNED_SHORT, elementOffset);
        }

    } else {
        gl.uniform1f(shader.u_opacity, layer.paint['icon-opacity']);
        for (var k = 0; k < elementGroups.length; k++) {
            group = elementGroups[k];
            offset = group.vertexStartIndex * vertex.itemSize;
            vertex.bind(gl);
            vertex.setAttribPointers(gl, shader, offset);

            count = group.elementLength * 3;
            elementOffset = group.elementStartIndex * elements.itemSize;
            gl.drawElements(gl.TRIANGLES, count, gl.UNSIGNED_SHORT, elementOffset);
        }
    }
}

},{"../source/pixels_to_tile_units":31,"../util/browser":89,"../util/util":104,"./draw_collision_debug":17,"gl-matrix":124}],23:[function(require,module,exports){
'use strict';

module.exports = FrameHistory;

function FrameHistory() {
    this.frameHistory = [];
}

FrameHistory.prototype.getFadeProperties = function(duration) {
    if (duration === undefined) duration = 300;
    var currentTime = (new Date()).getTime();

    // Remove frames until only one is outside the duration, or until there are only three
    while (this.frameHistory.length > 3 && this.frameHistory[1].time + duration < currentTime) {
        this.frameHistory.shift();
    }

    if (this.frameHistory[1].time + duration < currentTime) {
        this.frameHistory[0].z = this.frameHistory[1].z;
    }

    var frameLen = this.frameHistory.length;
    if (frameLen < 3) console.warn('there should never be less than three frames in the history');

    // Find the range of zoom levels we want to fade between
    var startingZ = this.frameHistory[0].z,
        lastFrame = this.frameHistory[frameLen - 1],
        endingZ = lastFrame.z,
        lowZ = Math.min(startingZ, endingZ),
        highZ = Math.max(startingZ, endingZ);

    // Calculate the speed of zooming, and how far it would zoom in terms of zoom levels in one duration
    var zoomDiff = lastFrame.z - this.frameHistory[1].z,
        timeDiff = lastFrame.time - this.frameHistory[1].time;
    var fadedist = zoomDiff / (timeDiff / duration);

    if (isNaN(fadedist)) console.warn('fadedist should never be NaN');

    // At end of a zoom when the zoom stops changing continue pretending to zoom at that speed
    // bump is how much farther it would have been if it had continued zooming at the same rate
    var bump = (currentTime - lastFrame.time) / duration * fadedist;

    return {
        fadedist: fadedist,
        minfadezoom: lowZ,
        maxfadezoom: highZ,
        bump: bump
    };
};

// Record frame history that will be used to calculate fading params
FrameHistory.prototype.record = function(zoom) {
    var currentTime = (new Date()).getTime();

    // first frame ever
    if (!this.frameHistory.length) {
        this.frameHistory.push({time: 0, z: zoom }, {time: 0, z: zoom });
    }

    if (this.frameHistory.length === 2 || this.frameHistory[this.frameHistory.length - 1].z !== zoom) {
        this.frameHistory.push({
            time: currentTime,
            z: zoom
        });
    }
};

},{}],24:[function(require,module,exports){
'use strict';

var shaders = require('./shaders');
var util = require('../util/util');

exports.extend = function(context) {
    var origLineWidth = context.lineWidth,
        lineWidthRange = context.getParameter(context.ALIASED_LINE_WIDTH_RANGE);

    context.lineWidth = function(width) {
        origLineWidth.call(context, util.clamp(width, lineWidthRange[0], lineWidthRange[1]));
    };

    context.getShader = function(name, type) {
        var typeString = type === this.FRAGMENT_SHADER ? 'fragment' : 'vertex';
        if (!shaders[name] || !shaders[name][typeString]) {
            throw new Error("Could not find shader " + name);
        }

        var shader = this.createShader(type);
        var shaderSource = shaders[name][typeString];

        this.shaderSource(shader, shaderSource);
        this.compileShader(shader);
        if (!this.getShaderParameter(shader, this.COMPILE_STATUS)) {
            throw new Error(name + ' ' + typeString + this.getShaderInfoLog(shader));
        }
        return shader;
    };

    context.initializeShader = function(name, attributes, uniforms) {
        var shader = {
            program: this.createProgram(),
            fragment: this.getShader(name, this.FRAGMENT_SHADER),
            vertex: this.getShader(name, this.VERTEX_SHADER),
            attributes: []
        };
        this.attachShader(shader.program, shader.vertex);
        this.attachShader(shader.program, shader.fragment);
        this.linkProgram(shader.program);

        if (!this.getProgramParameter(shader.program, this.LINK_STATUS)) {
            console.error(name + ' ERROR: ' + this.getProgramInfoLog(shader.program));
        } else {
            for (var i = 0; i < attributes.length; i++) {
                shader[attributes[i]] = this.getAttribLocation(shader.program, attributes[i]);
                shader.attributes.push(shader[attributes[i]]);
            }
            for (var k = 0; k < uniforms.length; k++) {
                shader[uniforms[k]] = this.getUniformLocation(shader.program, uniforms[k]);
            }
        }

        return shader;
    };

    // Switches to a different shader program.
    context.switchShader = function(shader, posMatrix, exMatrix) {
        if (this.currentShader !== shader) {
            this.useProgram(shader.program);

            // Disable all attributes from the existing shader that aren't used in
            // the new shader. Note: attribute indices are *not* program specific!
            var enabled = this.currentShader ? this.currentShader.attributes : [];
            var required = shader.attributes;

            for (var i = 0; i < enabled.length; i++) {
                if (required.indexOf(enabled[i]) < 0) {
                    this.disableVertexAttribArray(enabled[i]);
                }
            }

            // Enable all attributes for the new shader.
            for (var j = 0; j < required.length; j++) {
                if (enabled.indexOf(required[j]) < 0) {
                    this.enableVertexAttribArray(required[j]);
                }
            }

            this.currentShader = shader;
        }

        if (posMatrix !== undefined) context.setPosMatrix(posMatrix);
        if (exMatrix !== undefined) context.setExMatrix(exMatrix);
    };

    // Update the matrices if necessary. Note: This relies on object identity!
    // This means changing the matrix values without the actual matrix object
    // will FAIL to update the matrix properly.
    context.setPosMatrix = function(posMatrix) {
        var shader = this.currentShader;
        if (shader.posMatrix !== posMatrix) {
            this.uniformMatrix4fv(shader.u_matrix, false, posMatrix);
            shader.posMatrix = posMatrix;
        }
    };

    // Update the matrices if necessary. Note: This relies on object identity!
    // This means changing the matrix values without the actual matrix object
    // will FAIL to update the matrix properly.
    context.setExMatrix = function(exMatrix) {
        var shader = this.currentShader;
        if (exMatrix && shader.exMatrix !== exMatrix && shader.u_exmatrix) {
            this.uniformMatrix4fv(shader.u_exmatrix, false, exMatrix);
            shader.exMatrix = exMatrix;
        }
    };

    context.vertexAttrib2fv = function(attribute, values) {
        context.vertexAttrib2f(attribute, values[0], values[1]);
    };

    context.vertexAttrib3fv = function(attribute, values) {
        context.vertexAttrib3f(attribute, values[0], values[1], values[2]);
    };

    context.vertexAttrib4fv = function(attribute, values) {
        context.vertexAttrib4f(attribute, values[0], values[1], values[2], values[3]);
    };

    return context;
};

},{"../util/util":104,"./shaders":27}],25:[function(require,module,exports){
'use strict';

module.exports = LineAtlas;

/**
 * A LineAtlas lets us reuse rendered dashed lines
 * by writing many of them to a texture and then fetching their positions
 * using .getDash.
 *
 * @param {number} width
 * @param {number} height
 * @private
 */
function LineAtlas(width, height) {
    this.width = width;
    this.height = height;
    this.nextRow = 0;

    this.bytes = 4;
    this.data = new Uint8Array(this.width * this.height * this.bytes);

    this.positions = {};
}

LineAtlas.prototype.setSprite = function(sprite) {
    this.sprite = sprite;
};

/**
 * Get or create a dash line pattern.
 *
 * @param {Array<number>} dasharray
 * @param {boolean} round whether to add circle caps in between dash segments
 * @returns {Object} position of dash texture in { y, height, width }
 * @private
 */
LineAtlas.prototype.getDash = function(dasharray, round) {
    var key = dasharray.join(",") + round;

    if (!this.positions[key]) {
        this.positions[key] = this.addDash(dasharray, round);
    }
    return this.positions[key];
};

LineAtlas.prototype.addDash = function(dasharray, round) {

    var n = round ? 7 : 0;
    var height = 2 * n + 1;
    var offset = 128;

    if (this.nextRow + height > this.height) {
        console.warn('LineAtlas out of space');
        return null;
    }

    var length = 0;
    for (var i = 0; i < dasharray.length; i++) {
        length += dasharray[i];
    }

    var stretch = this.width / length;
    var halfWidth = stretch / 2;

    // If dasharray has an odd length, both the first and last parts
    // are dashes and should be joined seamlessly.
    var oddLength = dasharray.length % 2 === 1;

    for (var y = -n; y <= n; y++) {
        var row = this.nextRow + n + y;
        var index = this.width * row;

        var left = oddLength ? -dasharray[dasharray.length - 1] : 0;
        var right = dasharray[0];
        var partIndex = 1;

        for (var x = 0; x < this.width; x++) {

            while (right < x / stretch) {
                left = right;
                right = right + dasharray[partIndex];

                if (oddLength && partIndex === dasharray.length - 1) {
                    right += dasharray[0];
                }

                partIndex++;
            }

            var distLeft = Math.abs(x - left * stretch);
            var distRight = Math.abs(x - right * stretch);
            var dist = Math.min(distLeft, distRight);
            var inside = (partIndex % 2) === 1;
            var signedDistance;

            if (round) {
                // Add circle caps
                var distMiddle = n ? y / n * (halfWidth + 1) : 0;
                if (inside) {
                    var distEdge = halfWidth - Math.abs(distMiddle);
                    signedDistance = Math.sqrt(dist * dist + distEdge * distEdge);
                } else {
                    signedDistance = halfWidth - Math.sqrt(dist * dist + distMiddle * distMiddle);
                }
            } else {
                signedDistance = (inside ? 1 : -1) * dist;
            }

            this.data[3 + (index + x) * 4] = Math.max(0, Math.min(255, signedDistance + offset));
        }
    }

    var pos = {
        y: (this.nextRow + n + 0.5) / this.height,
        height: 2 * n / this.height,
        width: length
    };

    this.nextRow += height;
    this.dirty = true;

    return pos;
};

LineAtlas.prototype.bind = function(gl) {
    if (!this.texture) {
        this.texture = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, this.texture);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, this.width, this.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, this.data);

    } else {
        gl.bindTexture(gl.TEXTURE_2D, this.texture);

        if (this.dirty) {
            this.dirty = false;
            gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, this.width, this.height, gl.RGBA, gl.UNSIGNED_BYTE, this.data);
        }
    }
};

},{}],26:[function(require,module,exports){
'use strict';

var glutil = require('./gl_util');
var browser = require('../util/browser');
var mat4 = require('gl-matrix').mat4;
var FrameHistory = require('./frame_history');
var TileCoord = require('../source/tile_coord');
var TilePyramid = require('../source/tile_pyramid');
var EXTENT = require('../data/bucket').EXTENT;
var pixelsToTileUnits = require('../source/pixels_to_tile_units');

module.exports = Painter;

/**
 * Initialize a new painter object.
 *
 * @param {Canvas} gl an experimental-webgl drawing context
 */
function Painter(gl, transform) {
    this.gl = glutil.extend(gl);
    this.transform = transform;

    this.reusableTextures = {};
    this.preFbos = {};

    this.frameHistory = new FrameHistory();

    this.setup();

    // Within each layer there are multiple distinct z-planes that can be drawn to.
    // This is implemented using the WebGL depth buffer.
    this.numSublayers = TilePyramid.maxUnderzooming + TilePyramid.maxOverzooming + 1;
    this.depthEpsilon = 1 / Math.pow(2, 16);
}

/*
 * Update the GL viewport, projection matrix, and transforms to compensate
 * for a new width and height value.
 */
Painter.prototype.resize = function(width, height) {
    var gl = this.gl;

    this.width = width * browser.devicePixelRatio;
    this.height = height * browser.devicePixelRatio;
    gl.viewport(0, 0, this.width, this.height);

};


Painter.prototype.setup = function() {
    var gl = this.gl;

    gl.verbose = true;

    // We are blending the new pixels *behind* the existing pixels. That way we can
    // draw front-to-back and use then stencil buffer to cull opaque pixels early.
    gl.enable(gl.BLEND);
    gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);

    gl.enable(gl.STENCIL_TEST);

    gl.enable(gl.DEPTH_TEST);
    gl.depthFunc(gl.LEQUAL);

    this._depthMask = false;
    gl.depthMask(false);

    // Initialize shaders
    this.debugShader = gl.initializeShader('debug',
        ['a_pos'],
        ['u_matrix', 'u_color']);

    this.rasterShader = gl.initializeShader('raster',
        ['a_pos', 'a_texture_pos'],
        ['u_matrix', 'u_brightness_low', 'u_brightness_high', 'u_saturation_factor', 'u_spin_weights', 'u_contrast_factor', 'u_opacity0', 'u_opacity1', 'u_image0', 'u_image1', 'u_tl_parent', 'u_scale_parent', 'u_buffer_scale']);

    this.circleShader = gl.initializeShader('circle',
        ['a_pos'],
        ['u_matrix', 'u_exmatrix', 'u_blur', 'u_size', 'u_color']);

    this.lineShader = gl.initializeShader('line',
        ['a_pos', 'a_data'],
        ['u_matrix', 'u_linewidth', 'u_color', 'u_ratio', 'u_blur', 'u_extra', 'u_antialiasingmatrix', 'u_offset', 'u_exmatrix']);

    this.linepatternShader = gl.initializeShader('linepattern',
        ['a_pos', 'a_data'],
        ['u_matrix', 'u_linewidth', 'u_ratio', 'u_pattern_size_a', 'u_pattern_size_b', 'u_pattern_tl_a', 'u_pattern_br_a', 'u_pattern_tl_b', 'u_pattern_br_b', 'u_blur', 'u_fade', 'u_opacity', 'u_extra', 'u_antialiasingmatrix', 'u_offset']);

    this.linesdfpatternShader = gl.initializeShader('linesdfpattern',
        ['a_pos', 'a_data'],
        ['u_matrix', 'u_linewidth', 'u_color', 'u_ratio', 'u_blur', 'u_patternscale_a', 'u_tex_y_a', 'u_patternscale_b', 'u_tex_y_b', 'u_image', 'u_sdfgamma', 'u_mix', 'u_extra', 'u_antialiasingmatrix', 'u_offset']);

    this.sdfShader = gl.initializeShader('sdf',
        ['a_pos', 'a_offset', 'a_data1', 'a_data2'],
        ['u_matrix', 'u_exmatrix', 'u_texture', 'u_texsize', 'u_color', 'u_gamma', 'u_buffer', 'u_zoom', 'u_fadedist', 'u_minfadezoom', 'u_maxfadezoom', 'u_fadezoom', 'u_skewed', 'u_extra']);

    this.iconShader = gl.initializeShader('icon',
        ['a_pos', 'a_offset', 'a_data1', 'a_data2'],
        ['u_matrix', 'u_exmatrix', 'u_texture', 'u_texsize', 'u_zoom', 'u_fadedist', 'u_minfadezoom', 'u_maxfadezoom', 'u_fadezoom', 'u_opacity', 'u_skewed', 'u_extra']);

    this.outlineShader = gl.initializeShader('outline',
        ['a_pos'],
        ['u_matrix', 'u_color', 'u_world']
    );

    this.patternShader = gl.initializeShader('pattern',
        ['a_pos'],
        ['u_matrix', 'u_pattern_tl_a', 'u_pattern_br_a', 'u_pattern_tl_b', 'u_pattern_br_b', 'u_mix', 'u_patternscale_a', 'u_patternscale_b', 'u_opacity', 'u_image', 'u_offset_a', 'u_offset_b']
    );

    this.fillShader = gl.initializeShader('fill',
        ['a_pos'],
        ['u_matrix', 'u_color']
    );

    this.collisionBoxShader = gl.initializeShader('collisionbox',
        ['a_pos', 'a_extrude', 'a_data'],
        ['u_matrix', 'u_scale', 'u_zoom', 'u_maxzoom']
    );

    this.identityMatrix = mat4.create();

    // The backgroundBuffer is used when drawing to the full *canvas*
    this.backgroundBuffer = gl.createBuffer();
    this.backgroundBuffer.itemSize = 2;
    this.backgroundBuffer.itemCount = 4;
    gl.bindBuffer(gl.ARRAY_BUFFER, this.backgroundBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Int16Array([-1, -1, 1, -1, -1, 1, 1, 1]), gl.STATIC_DRAW);

    // The tileExtentBuffer is used when drawing to a full *tile*
    this.tileExtentBuffer = gl.createBuffer();
    this.tileExtentBuffer.itemSize = 4;
    this.tileExtentBuffer.itemCount = 4;
    gl.bindBuffer(gl.ARRAY_BUFFER, this.tileExtentBuffer);
    gl.bufferData(
        gl.ARRAY_BUFFER,
        new Int16Array([
            // tile coord x, tile coord y, texture coord x, texture coord y
            0, 0, 0, 0,
            EXTENT, 0, 32767, 0,
            0, EXTENT, 0, 32767,
            EXTENT, EXTENT,  32767, 32767
        ]),
        gl.STATIC_DRAW);

    // The debugBuffer is used to draw tile outlines for debugging
    this.debugBuffer = gl.createBuffer();
    this.debugBuffer.itemSize = 2;
    this.debugBuffer.itemCount = 5;
    gl.bindBuffer(gl.ARRAY_BUFFER, this.debugBuffer);
    gl.bufferData(
        gl.ARRAY_BUFFER,
        new Int16Array([
            0, 0, EXTENT, 0, EXTENT, EXTENT, 0, EXTENT, 0, 0]),
        gl.STATIC_DRAW);

    // The debugTextBuffer is used to draw tile IDs for debugging
    this.debugTextBuffer = gl.createBuffer();
    this.debugTextBuffer.itemSize = 2;
};

/*
 * Reset the color buffers of the drawing canvas.
 */
Painter.prototype.clearColor = function() {
    var gl = this.gl;
    gl.clearColor(0, 0, 0, 0);
    gl.clear(gl.COLOR_BUFFER_BIT);
};

/*
 * Reset the drawing canvas by clearing the stencil buffer so that we can draw
 * new tiles at the same location, while retaining previously drawn pixels.
 */
Painter.prototype.clearStencil = function() {
    var gl = this.gl;
    gl.clearStencil(0x0);
    gl.stencilMask(0xFF);
    gl.clear(gl.STENCIL_BUFFER_BIT);
};

Painter.prototype.clearDepth = function() {
    var gl = this.gl;
    gl.clearDepth(1);
    this.depthMask(true);
    gl.clear(gl.DEPTH_BUFFER_BIT);
};

Painter.prototype._renderTileClippingMasks = function(coords, sourceMaxZoom) {
    var gl = this.gl;
    gl.colorMask(false, false, false, false);
    this.depthMask(false);
    gl.disable(gl.DEPTH_TEST);
    gl.enable(gl.STENCIL_TEST);

    // Only write clipping IDs to the last 5 bits. The first three are used for drawing fills.
    gl.stencilMask(0xF8);
    // Tests will always pass, and ref value will be written to stencil buffer.
    gl.stencilOp(gl.KEEP, gl.KEEP, gl.REPLACE);

    var idNext = 1;
    this._tileClippingMaskIDs = {};
    for (var i = 0; i < coords.length; i++) {
        var coord = coords[i];
        var id = this._tileClippingMaskIDs[coord.id] = (idNext++) << 3;

        gl.stencilFunc(gl.ALWAYS, id, 0xF8);

        gl.switchShader(this.fillShader, this.calculatePosMatrix(coord, sourceMaxZoom));

        // Draw the clipping mask
        gl.bindBuffer(gl.ARRAY_BUFFER, this.tileExtentBuffer);
        gl.vertexAttribPointer(this.fillShader.a_pos, this.tileExtentBuffer.itemSize, gl.SHORT, false, 8, 0);
        gl.drawArrays(gl.TRIANGLE_STRIP, 0, this.tileExtentBuffer.itemCount);
    }

    gl.stencilMask(0x00);
    gl.colorMask(true, true, true, true);
    this.depthMask(true);
    gl.enable(gl.DEPTH_TEST);
};

Painter.prototype.enableTileClippingMask = function(coord) {
    var gl = this.gl;
    gl.stencilFunc(gl.EQUAL, this._tileClippingMaskIDs[coord.id], 0xF8);
};

// Overridden by headless tests.
Painter.prototype.prepareBuffers = function() {};
Painter.prototype.bindDefaultFramebuffer = function() {
    var gl = this.gl;
    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
};

var draw = {
    symbol: require('./draw_symbol'),
    circle: require('./draw_circle'),
    line: require('./draw_line'),
    fill: require('./draw_fill'),
    raster: require('./draw_raster'),
    background: require('./draw_background'),
    debug: require('./draw_debug')
};

Painter.prototype.render = function(style, options) {
    this.style = style;
    this.options = options;

    this.lineAtlas = style.lineAtlas;

    this.spriteAtlas = style.spriteAtlas;
    this.spriteAtlas.setSprite(style.sprite);

    this.glyphSource = style.glyphSource;

    this.frameHistory.record(this.transform.zoom);

    this.prepareBuffers();
    this.clearColor();
    this.clearDepth();

    this.depthRange = (style._order.length + 2) * this.numSublayers * this.depthEpsilon;

    this.renderPass({isOpaquePass: true});
    this.renderPass({isOpaquePass: false});
};

Painter.prototype.renderPass = function(options) {
    var groups = this.style._groups;
    var isOpaquePass = options.isOpaquePass;
    this.currentLayer = isOpaquePass ? this.style._order.length : -1;

    for (var i = 0; i < groups.length; i++) {
        var group = groups[isOpaquePass ? groups.length - 1 - i : i];
        var source = this.style.sources[group.source];

        var coords = [];
        if (source) {
            coords = source.getVisibleCoordinates();
            this.clearStencil();
            if (source.prepare) source.prepare();
            if (source.isTileClipped) {
                this._renderTileClippingMasks(coords, source.maxzoom);
            }
        }

        if (isOpaquePass) {
            this.gl.disable(this.gl.BLEND);
            this.isOpaquePass = true;
        } else {
            this.gl.enable(this.gl.BLEND);
            this.isOpaquePass = false;
            coords.reverse();
        }

        for (var j = 0; j < group.length; j++) {
            var layer = group[isOpaquePass ? group.length - 1 - j : j];
            this.currentLayer += isOpaquePass ? -1 : 1;
            this.renderLayer(this, source, layer, coords);
        }

        if (source) {
            draw.debug(this, source, coords);
        }
    }
};

Painter.prototype.depthMask = function(mask) {
    if (mask !== this._depthMask) {
        this._depthMask = mask;
        this.gl.depthMask(mask);
    }
};

Painter.prototype.renderLayer = function(painter, source, layer, coords) {
    if (layer.isHidden(this.transform.zoom)) return;
    if (layer.type !== 'background' && !coords.length) return;
    draw[layer.type](painter, source, layer, coords);
};

// Draws non-opaque areas. This is for debugging purposes.
Painter.prototype.drawStencilBuffer = function() {
    var gl = this.gl;
    gl.switchShader(this.fillShader, this.identityMatrix);

    gl.stencilMask(0x00);
    gl.stencilFunc(gl.EQUAL, 0x80, 0x80);

    // Drw the filling quad where the stencil buffer isn't set.
    gl.bindBuffer(gl.ARRAY_BUFFER, this.backgroundBuffer);
    gl.vertexAttribPointer(this.fillShader.a_pos, this.backgroundBuffer.itemSize, gl.SHORT, false, 0, 0);

    gl.uniform4fv(this.fillShader.u_color, [0, 0, 0, 0.5]);
    gl.drawArrays(gl.TRIANGLE_STRIP, 0, this.tileExtentBuffer.itemCount);
};

Painter.prototype.setDepthSublayer = function(n) {
    var farDepth = 1 - ((1 + this.currentLayer) * this.numSublayers + n) * this.depthEpsilon;
    var nearDepth = farDepth - 1 + this.depthRange;
    this.gl.depthRange(nearDepth, farDepth);
};

Painter.prototype.translatePosMatrix = function(matrix, tile, translate, anchor) {
    if (!translate[0] && !translate[1]) return matrix;

    if (anchor === 'viewport') {
        var sinA = Math.sin(-this.transform.angle);
        var cosA = Math.cos(-this.transform.angle);
        translate = [
            translate[0] * cosA - translate[1] * sinA,
            translate[0] * sinA + translate[1] * cosA
        ];
    }

    var translation = [
        pixelsToTileUnits(tile, translate[0], this.transform.zoom),
        pixelsToTileUnits(tile, translate[1], this.transform.zoom),
        0
    ];

    var translatedMatrix = new Float32Array(16);
    mat4.translate(translatedMatrix, matrix, translation);
    return translatedMatrix;
};

/**
 * Calculate the posMatrix that this tile uses to display itself in a map,
 * given a coordinate as (z, x, y) and a transform
 * @param {Object} transform
 * @private
 */
Painter.prototype.calculatePosMatrix = function(coord, maxZoom) {

    if (coord instanceof TileCoord) {
        coord = coord.toCoordinate();
    }
    var transform = this.transform;

    if (maxZoom === undefined) maxZoom = Infinity;

    // Initialize model-view matrix that converts from the tile coordinates
    // to screen coordinates.

    // if z > maxzoom then the tile is actually a overscaled maxzoom tile,
    // so calculate the matrix the maxzoom tile would use.
    var z = Math.min(coord.zoom, maxZoom);
    var x = coord.column;
    var y = coord.row;

    var scale = transform.worldSize / Math.pow(2, z);

    // The position matrix
    var posMatrix = new Float64Array(16);

    mat4.identity(posMatrix);
    mat4.translate(posMatrix, posMatrix, [x * scale, y * scale, 0]);
    mat4.scale(posMatrix, posMatrix, [ scale / EXTENT, scale / EXTENT, 1 ]);
    mat4.multiply(posMatrix, transform.projMatrix, posMatrix);

    return new Float32Array(posMatrix);
};

Painter.prototype.saveTexture = function(texture) {
    var textures = this.reusableTextures[texture.size];
    if (!textures) {
        this.reusableTextures[texture.size] = [texture];
    } else {
        textures.push(texture);
    }
};


Painter.prototype.getTexture = function(size) {
    var textures = this.reusableTextures[size];
    return textures && textures.length > 0 ? textures.pop() : null;
};

},{"../data/bucket":1,"../source/pixels_to_tile_units":31,"../source/tile_coord":35,"../source/tile_pyramid":36,"../util/browser":89,"./draw_background":15,"./draw_circle":16,"./draw_debug":18,"./draw_fill":19,"./draw_line":20,"./draw_raster":21,"./draw_symbol":22,"./frame_history":23,"./gl_util":24,"gl-matrix":124}],27:[function(require,module,exports){
'use strict';


var path = require('path');

// Must be written out long-form for brfs.
module.exports = {
    debug: {
        fragment: "precision mediump float;\n\nuniform lowp vec4 u_color;\n\nvoid main() {\n    gl_FragColor = u_color;\n}\n",
        vertex: "precision highp float;\n\nattribute vec2 a_pos;\n\nuniform mat4 u_matrix;\n\nvoid main() {\n    gl_Position = u_matrix * vec4(a_pos, step(32767.0, a_pos.x), 1);\n}\n"
    },
    fill: {
        fragment: "precision mediump float;\n\nuniform lowp vec4 u_color;\n\nvoid main() {\n    gl_FragColor = u_color;\n}\n",
        vertex: "precision highp float;\n\nattribute vec2 a_pos;\nuniform mat4 u_matrix;\n\nvoid main() {\n    gl_Position = u_matrix * vec4(a_pos, 0, 1);\n}\n"
    },
    circle: {
        fragment: "precision mediump float;\n\nuniform lowp vec4 u_color;\nuniform lowp float u_blur;\n\nvarying vec2 v_extrude;\n\nvoid main() {\n    float t = smoothstep(1.0 - u_blur, 1.0, length(v_extrude));\n    gl_FragColor = u_color * (1.0 - t);\n}\n",
        vertex: "precision highp float;\n\nuniform mat4 u_matrix;\nuniform mat4 u_exmatrix;\nuniform mediump float u_size;\n\nattribute vec2 a_pos;\n\nvarying vec2 v_extrude;\n\nvoid main(void) {\n    // unencode the extrusion vector that we snuck into the a_pos vector\n    v_extrude = vec2(mod(a_pos, 2.0) * 2.0 - 1.0);\n\n    vec4 extrude = u_exmatrix * vec4(v_extrude * u_size, 0, 0);\n    // multiply a_pos by 0.5, since we had it * 2 in order to sneak\n    // in extrusion data\n    gl_Position = u_matrix * vec4(floor(a_pos * 0.5), 0, 1);\n\n    // gl_Position is divided by gl_Position.w after this shader runs.\n    // Multiply the extrude by it so that it isn't affected by it.\n    gl_Position += extrude * gl_Position.w;\n}\n"
    },
    line: {
        fragment: "precision mediump float;\n\nuniform vec2 u_linewidth;\nuniform lowp vec4 u_color;\nuniform float u_blur;\n\nvarying vec2 v_normal;\nvarying float v_linesofar;\nvarying float v_gamma_scale;\n\nvoid main() {\n    // Calculate the distance of the pixel from the line in pixels.\n    float dist = length(v_normal) * u_linewidth.s;\n\n    // Calculate the antialiasing fade factor. This is either when fading in\n    // the line in case of an offset line (v_linewidth.t) or when fading out\n    // (v_linewidth.s)\n    float blur = u_blur * v_gamma_scale;\n    float alpha = clamp(min(dist - (u_linewidth.t - blur), u_linewidth.s - dist) / blur, 0.0, 1.0);\n\n    gl_FragColor = u_color * alpha;\n}\n",
        vertex: "precision highp float;\n\n// floor(127 / 2) == 63.0\n// the maximum allowed miter limit is 2.0 at the moment. the extrude normal is\n// stored in a byte (-128..127). we scale regular normals up to length 63, but\n// there are also \"special\" normals that have a bigger length (of up to 126 in\n// this case).\n// #define scale 63.0\n#define scale 0.015873016\n\nattribute vec2 a_pos;\nattribute vec4 a_data;\n\nuniform mat4 u_matrix;\nuniform float u_ratio;\nuniform mediump vec2 u_linewidth;\nuniform float u_extra;\nuniform mat2 u_antialiasingmatrix;\nuniform mediump float u_offset;\n\nvarying vec2 v_normal;\nvarying float v_linesofar;\nvarying float v_gamma_scale;\n\nvoid main() {\n    vec2 a_extrude = a_data.xy - 128.0;\n    float a_direction = mod(a_data.z, 4.0) - 1.0;\n\n    // We store the texture normals in the most insignificant bit\n    // transform y so that 0 => -1 and 1 => 1\n    // In the texture normal, x is 0 if the normal points straight up/down and 1 if it's a round cap\n    // y is 1 if the normal points up, and -1 if it points down\n    mediump vec2 normal = mod(a_pos, 2.0);\n    normal.y = sign(normal.y - 0.5);\n    v_normal = normal;\n\n    // Scale the extrusion vector down to a normal and then up by the line width\n    // of this vertex.\n    mediump vec4 dist = vec4(u_linewidth.s * a_extrude * scale, 0.0, 0.0);\n\n    // Calculate the offset when drawing a line that is to the side of the actual line.\n    // We do this by creating a vector that points towards the extrude, but rotate\n    // it when we're drawing round end points (a_direction = -1 or 1) since their\n    // extrude vector points in another direction.\n    mediump float u = 0.5 * a_direction;\n    mediump float t = 1.0 - abs(u);\n    mediump vec2 offset = u_offset * a_extrude * scale * normal.y * mat2(t, -u, u, t);\n\n    // Remove the texture normal bit of the position before scaling it with the\n    // model/view matrix.\n    gl_Position = u_matrix * vec4(floor(a_pos * 0.5) + (offset + dist.xy) / u_ratio, 0.0, 1.0);\n\n    // position of y on the screen\n    float y = gl_Position.y / gl_Position.w;\n\n    // how much features are squished in the y direction by the tilt\n    float squish_scale = length(a_extrude) / length(u_antialiasingmatrix * a_extrude);\n\n    // how much features are squished in all directions by the perspectiveness\n    float perspective_scale = 1.0 / (1.0 - min(y * u_extra, 0.9));\n\n    v_gamma_scale = perspective_scale * squish_scale;\n}\n"
    },
    linepattern: {
        fragment: "precision mediump float;\n\nuniform vec2 u_linewidth;\nuniform float u_point;\nuniform float u_blur;\n\nuniform vec2 u_pattern_size_a;\nuniform vec2 u_pattern_size_b;\nuniform vec2 u_pattern_tl_a;\nuniform vec2 u_pattern_br_a;\nuniform vec2 u_pattern_tl_b;\nuniform vec2 u_pattern_br_b;\nuniform float u_fade;\nuniform float u_opacity;\n\nuniform sampler2D u_image;\n\nvarying vec2 v_normal;\nvarying float v_linesofar;\nvarying float v_gamma_scale;\n\nvoid main() {\n    // Calculate the distance of the pixel from the line in pixels.\n    float dist = length(v_normal) * u_linewidth.s;\n\n    // Calculate the antialiasing fade factor. This is either when fading in\n    // the line in case of an offset line (v_linewidth.t) or when fading out\n    // (v_linewidth.s)\n    float blur = u_blur * v_gamma_scale;\n    float alpha = clamp(min(dist - (u_linewidth.t - blur), u_linewidth.s - dist) / blur, 0.0, 1.0);\n\n    float x_a = mod(v_linesofar / u_pattern_size_a.x, 1.0);\n    float x_b = mod(v_linesofar / u_pattern_size_b.x, 1.0);\n    float y_a = 0.5 + (v_normal.y * u_linewidth.s / u_pattern_size_a.y);\n    float y_b = 0.5 + (v_normal.y * u_linewidth.s / u_pattern_size_b.y);\n    vec2 pos = mix(u_pattern_tl_a, u_pattern_br_a, vec2(x_a, y_a));\n    vec2 pos2 = mix(u_pattern_tl_b, u_pattern_br_b, vec2(x_b, y_b));\n\n    vec4 color = mix(texture2D(u_image, pos), texture2D(u_image, pos2), u_fade);\n\n    alpha *= u_opacity;\n\n    gl_FragColor = color * alpha;\n}\n",
        vertex: "precision highp float;\n\n// floor(127 / 2) == 63.0\n// the maximum allowed miter limit is 2.0 at the moment. the extrude normal is\n// stored in a byte (-128..127). we scale regular normals up to length 63, but\n// there are also \"special\" normals that have a bigger length (of up to 126 in\n// this case).\n// #define scale 63.0\n#define scale 0.015873016\n\n// We scale the distance before adding it to the buffers so that we can store\n// long distances for long segments. Use this value to unscale the distance.\n#define LINE_DISTANCE_SCALE 2.0\n\nattribute vec2 a_pos;\nattribute vec4 a_data;\n\nuniform mat4 u_matrix;\nuniform mediump float u_ratio;\nuniform mediump vec2 u_linewidth;\nuniform float u_extra;\nuniform mat2 u_antialiasingmatrix;\nuniform mediump float u_offset;\n\nvarying vec2 v_normal;\nvarying float v_linesofar;\nvarying float v_gamma_scale;\n\nvoid main() {\n    vec2 a_extrude = a_data.xy - 128.0;\n    float a_direction = mod(a_data.z, 4.0) - 1.0;\n    float a_linesofar = (floor(a_data.z / 4.0) + a_data.w * 64.0) * LINE_DISTANCE_SCALE;\n\n    // We store the texture normals in the most insignificant bit\n    // transform y so that 0 => -1 and 1 => 1\n    // In the texture normal, x is 0 if the normal points straight up/down and 1 if it's a round cap\n    // y is 1 if the normal points up, and -1 if it points down\n    mediump vec2 normal = mod(a_pos, 2.0);\n    normal.y = sign(normal.y - 0.5);\n    v_normal = normal;\n\n    // Scale the extrusion vector down to a normal and then up by the line width\n    // of this vertex.\n    mediump vec2 extrude = a_extrude * scale;\n    mediump vec2 dist = u_linewidth.s * extrude;\n\n    // Calculate the offset when drawing a line that is to the side of the actual line.\n    // We do this by creating a vector that points towards the extrude, but rotate\n    // it when we're drawing round end points (a_direction = -1 or 1) since their\n    // extrude vector points in another direction.\n    mediump float u = 0.5 * a_direction;\n    mediump float t = 1.0 - abs(u);\n    mediump vec2 offset = u_offset * a_extrude * scale * normal.y * mat2(t, -u, u, t);\n\n    // Remove the texture normal bit of the position before scaling it with the\n    // model/view matrix.\n    gl_Position = u_matrix * vec4(floor(a_pos * 0.5) + (offset + dist.xy) / u_ratio, 0.0, 1.0);\n    v_linesofar = a_linesofar;\n\n    // position of y on the screen\n    float y = gl_Position.y / gl_Position.w;\n\n    // how much features are squished in the y direction by the tilt\n    float squish_scale = length(a_extrude) / length(u_antialiasingmatrix * a_extrude);\n\n    // how much features are squished in all directions by the perspectiveness\n    float perspective_scale = 1.0 / (1.0 - min(y * u_extra, 0.9));\n\n    v_gamma_scale = perspective_scale * squish_scale;\n}\n"
    },
    linesdfpattern: {
        fragment: "precision mediump float;\n\nuniform vec2 u_linewidth;\nuniform lowp vec4 u_color;\nuniform float u_blur;\nuniform sampler2D u_image;\nuniform float u_sdfgamma;\nuniform float u_mix;\n\nvarying vec2 v_normal;\nvarying vec2 v_tex_a;\nvarying vec2 v_tex_b;\nvarying float v_gamma_scale;\n\nvoid main() {\n    // Calculate the distance of the pixel from the line in pixels.\n    float dist = length(v_normal) * u_linewidth.s;\n\n    // Calculate the antialiasing fade factor. This is either when fading in\n    // the line in case of an offset line (v_linewidth.t) or when fading out\n    // (v_linewidth.s)\n    float blur = u_blur * v_gamma_scale;\n    float alpha = clamp(min(dist - (u_linewidth.t - blur), u_linewidth.s - dist) / blur, 0.0, 1.0);\n\n    float sdfdist_a = texture2D(u_image, v_tex_a).a;\n    float sdfdist_b = texture2D(u_image, v_tex_b).a;\n    float sdfdist = mix(sdfdist_a, sdfdist_b, u_mix);\n    alpha *= smoothstep(0.5 - u_sdfgamma, 0.5 + u_sdfgamma, sdfdist);\n\n    gl_FragColor = u_color * alpha;\n}\n",
        vertex: "precision highp float;\n\n// floor(127 / 2) == 63.0\n// the maximum allowed miter limit is 2.0 at the moment. the extrude normal is\n// stored in a byte (-128..127). we scale regular normals up to length 63, but\n// there are also \"special\" normals that have a bigger length (of up to 126 in\n// this case).\n// #define scale 63.0\n#define scale 0.015873016\n\n// We scale the distance before adding it to the buffers so that we can store\n// long distances for long segments. Use this value to unscale the distance.\n#define LINE_DISTANCE_SCALE 2.0\n\nattribute vec2 a_pos;\nattribute vec4 a_data;\n\nuniform mat4 u_matrix;\nuniform mediump vec2 u_linewidth;\nuniform mediump float u_ratio;\nuniform vec2 u_patternscale_a;\nuniform float u_tex_y_a;\nuniform vec2 u_patternscale_b;\nuniform float u_tex_y_b;\nuniform float u_extra;\nuniform mat2 u_antialiasingmatrix;\nuniform mediump float u_offset;\n\nvarying vec2 v_normal;\nvarying vec2 v_tex_a;\nvarying vec2 v_tex_b;\nvarying float v_gamma_scale;\n\nvoid main() {\n    vec2 a_extrude = a_data.xy - 128.0;\n    float a_direction = mod(a_data.z, 4.0) - 1.0;\n    float a_linesofar = (floor(a_data.z / 4.0) + a_data.w * 64.0) * LINE_DISTANCE_SCALE;\n\n    // We store the texture normals in the most insignificant bit\n    // transform y so that 0 => -1 and 1 => 1\n    // In the texture normal, x is 0 if the normal points straight up/down and 1 if it's a round cap\n    // y is 1 if the normal points up, and -1 if it points down\n    mediump vec2 normal = mod(a_pos, 2.0);\n    normal.y = sign(normal.y - 0.5);\n    v_normal = normal;\n\n    // Scale the extrusion vector down to a normal and then up by the line width\n    // of this vertex.\n    mediump vec4 dist = vec4(u_linewidth.s * a_extrude * scale, 0.0, 0.0);\n\n    // Calculate the offset when drawing a line that is to the side of the actual line.\n    // We do this by creating a vector that points towards the extrude, but rotate\n    // it when we're drawing round end points (a_direction = -1 or 1) since their\n    // extrude vector points in another direction.\n    mediump float u = 0.5 * a_direction;\n    mediump float t = 1.0 - abs(u);\n    mediump vec2 offset = u_offset * a_extrude * scale * normal.y * mat2(t, -u, u, t);\n\n    // Remove the texture normal bit of the position before scaling it with the\n    // model/view matrix.\n    gl_Position = u_matrix * vec4(floor(a_pos * 0.5) + (offset + dist.xy) / u_ratio, 0.0, 1.0);\n\n    v_tex_a = vec2(a_linesofar * u_patternscale_a.x, normal.y * u_patternscale_a.y + u_tex_y_a);\n    v_tex_b = vec2(a_linesofar * u_patternscale_b.x, normal.y * u_patternscale_b.y + u_tex_y_b);\n\n    // position of y on the screen\n    float y = gl_Position.y / gl_Position.w;\n\n    // how much features are squished in the y direction by the tilt\n    float squish_scale = length(a_extrude) / length(u_antialiasingmatrix * a_extrude);\n\n    // how much features are squished in all directions by the perspectiveness\n    float perspective_scale = 1.0 / (1.0 - min(y * u_extra, 0.9));\n\n    v_gamma_scale = perspective_scale * squish_scale;\n}\n"
    },
    outline: {
        fragment: "precision mediump float;\n\nuniform lowp vec4 u_color;\n\nvarying vec2 v_pos;\n\nvoid main() {\n    float dist = length(v_pos - gl_FragCoord.xy);\n    float alpha = smoothstep(1.0, 0.0, dist);\n    gl_FragColor = u_color * alpha;\n}\n",
        vertex: "precision highp float;\n\nattribute vec2 a_pos;\n\nuniform mat4 u_matrix;\nuniform vec2 u_world;\n\nvarying vec2 v_pos;\n\nvoid main() {\n    gl_Position = u_matrix * vec4(a_pos, 0, 1);\n    v_pos = (gl_Position.xy/gl_Position.w + 1.0) / 2.0 * u_world;\n}\n"
    },
    pattern: {
        fragment: "precision mediump float;\n\nuniform float u_opacity;\nuniform vec2 u_pattern_tl_a;\nuniform vec2 u_pattern_br_a;\nuniform vec2 u_pattern_tl_b;\nuniform vec2 u_pattern_br_b;\nuniform float u_mix;\n\nuniform sampler2D u_image;\n\nvarying vec2 v_pos_a;\nvarying vec2 v_pos_b;\n\nvoid main() {\n\n    vec2 imagecoord = mod(v_pos_a, 1.0);\n    vec2 pos = mix(u_pattern_tl_a, u_pattern_br_a, imagecoord);\n    vec4 color1 = texture2D(u_image, pos);\n\n    vec2 imagecoord_b = mod(v_pos_b, 1.0);\n    vec2 pos2 = mix(u_pattern_tl_b, u_pattern_br_b, imagecoord_b);\n    vec4 color2 = texture2D(u_image, pos2);\n\n    gl_FragColor = mix(color1, color2, u_mix) * u_opacity;\n}\n",
        vertex: "precision highp float;\n\nuniform mat4 u_matrix;\nuniform vec2 u_patternscale_a;\nuniform vec2 u_patternscale_b;\nuniform vec2 u_offset_a;\nuniform vec2 u_offset_b;\n\nattribute vec2 a_pos;\n\nvarying vec2 v_pos_a;\nvarying vec2 v_pos_b;\n\nvoid main() {\n    gl_Position = u_matrix * vec4(a_pos, 0, 1);\n    v_pos_a = u_patternscale_a * a_pos + u_offset_a;\n    v_pos_b = u_patternscale_b * a_pos + u_offset_b;\n}\n"
    },
    raster: {
        fragment: "precision mediump float;\n\nuniform float u_opacity0;\nuniform float u_opacity1;\nuniform sampler2D u_image0;\nuniform sampler2D u_image1;\nvarying vec2 v_pos0;\nvarying vec2 v_pos1;\n\nuniform float u_brightness_low;\nuniform float u_brightness_high;\n\nuniform float u_saturation_factor;\nuniform float u_contrast_factor;\nuniform vec3 u_spin_weights;\n\nvoid main() {\n\n    // read and cross-fade colors from the main and parent tiles\n    vec4 color0 = texture2D(u_image0, v_pos0);\n    vec4 color1 = texture2D(u_image1, v_pos1);\n    vec4 color = color0 * u_opacity0 + color1 * u_opacity1;\n    vec3 rgb = color.rgb;\n\n    // spin\n    rgb = vec3(\n        dot(rgb, u_spin_weights.xyz),\n        dot(rgb, u_spin_weights.zxy),\n        dot(rgb, u_spin_weights.yzx));\n\n    // saturation\n    float average = (color.r + color.g + color.b) / 3.0;\n    rgb += (average - rgb) * u_saturation_factor;\n\n    // contrast\n    rgb = (rgb - 0.5) * u_contrast_factor + 0.5;\n\n    // brightness\n    vec3 u_high_vec = vec3(u_brightness_low, u_brightness_low, u_brightness_low);\n    vec3 u_low_vec = vec3(u_brightness_high, u_brightness_high, u_brightness_high);\n\n    gl_FragColor = vec4(mix(u_high_vec, u_low_vec, rgb), color.a);\n}\n",
        vertex: "precision highp float;\n\nuniform mat4 u_matrix;\nuniform vec2 u_tl_parent;\nuniform float u_scale_parent;\nuniform float u_buffer_scale;\n\nattribute vec2 a_pos;\nattribute vec2 a_texture_pos;\n\nvarying vec2 v_pos0;\nvarying vec2 v_pos1;\n\nvoid main() {\n    gl_Position = u_matrix * vec4(a_pos, 0, 1);\n    v_pos0 = (((a_texture_pos / 32767.0) - 0.5) / u_buffer_scale ) + 0.5;\n    v_pos1 = (v_pos0 * u_scale_parent) + u_tl_parent;\n}\n"
    },
    icon: {
        fragment: "precision mediump float;\n\nuniform sampler2D u_texture;\n\nvarying vec2 v_tex;\nvarying float v_alpha;\n\nvoid main() {\n    gl_FragColor = texture2D(u_texture, v_tex) * v_alpha;\n}\n",
        vertex: "precision highp float;\n\nattribute vec2 a_pos;\nattribute vec2 a_offset;\nattribute vec4 a_data1;\nattribute vec4 a_data2;\n\n\n// matrix is for the vertex position, exmatrix is for rotating and projecting\n// the extrusion vector.\nuniform mat4 u_matrix;\nuniform mat4 u_exmatrix;\nuniform mediump float u_zoom;\nuniform mediump float u_fadedist;\nuniform mediump float u_minfadezoom;\nuniform mediump float u_maxfadezoom;\nuniform mediump float u_fadezoom;\nuniform lowp float u_opacity;\nuniform bool u_skewed;\nuniform float u_extra;\n\nuniform vec2 u_texsize;\n\nvarying vec2 v_tex;\nvarying float v_alpha;\n\nvoid main() {\n    vec2 a_tex = a_data1.xy;\n    mediump float a_labelminzoom = a_data1[2];\n    mediump vec2 a_zoom = a_data2.st;\n    mediump float a_minzoom = a_zoom[0];\n    mediump float a_maxzoom = a_zoom[1];\n\n    float a_fadedist = 10.0;\n\n    // u_zoom is the current zoom level adjusted for the change in font size\n    mediump float z = 2.0 - step(a_minzoom, u_zoom) - (1.0 - step(a_maxzoom, u_zoom));\n\n    // fade out labels\n    mediump float alpha = clamp((u_fadezoom - a_labelminzoom) / u_fadedist, 0.0, 1.0);\n\n    if (u_fadedist >= 0.0) {\n        v_alpha = alpha;\n    } else {\n        v_alpha = 1.0 - alpha;\n    }\n    if (u_maxfadezoom < a_labelminzoom) {\n        v_alpha = 0.0;\n    }\n    if (u_minfadezoom >= a_labelminzoom) {\n        v_alpha = 1.0;\n    }\n\n    // if label has been faded out, clip it\n    z += step(v_alpha, 0.0);\n\n    if (u_skewed) {\n        vec4 extrude = u_exmatrix * vec4(a_offset / 64.0, 0, 0);\n        gl_Position = u_matrix * vec4(a_pos + extrude.xy, 0, 1);\n        gl_Position.z += z * gl_Position.w;\n    } else {\n        vec4 extrude = u_exmatrix * vec4(a_offset / 64.0, z, 0);\n        gl_Position = u_matrix * vec4(a_pos, 0, 1) + extrude;\n    }\n\n    v_tex = a_tex / u_texsize;\n\n    v_alpha *= u_opacity;\n}\n"
    },
    sdf: {
        fragment: "precision mediump float;\n\nuniform sampler2D u_texture;\nuniform lowp vec4 u_color;\nuniform lowp float u_buffer;\nuniform lowp float u_gamma;\n\nvarying vec2 v_tex;\nvarying float v_alpha;\nvarying float v_gamma_scale;\n\nvoid main() {\n    lowp float gamma = u_gamma * v_gamma_scale;\n    lowp float dist = texture2D(u_texture, v_tex).a;\n    lowp float alpha = smoothstep(u_buffer - gamma, u_buffer + gamma, dist) * v_alpha;\n    gl_FragColor = u_color * alpha;\n}\n",
        vertex: "precision highp float;\n\nattribute vec2 a_pos;\nattribute vec2 a_offset;\nattribute vec4 a_data1;\nattribute vec4 a_data2;\n\n\n// matrix is for the vertex position, exmatrix is for rotating and projecting\n// the extrusion vector.\nuniform mat4 u_matrix;\nuniform mat4 u_exmatrix;\n\nuniform mediump float u_zoom;\nuniform mediump float u_fadedist;\nuniform mediump float u_minfadezoom;\nuniform mediump float u_maxfadezoom;\nuniform mediump float u_fadezoom;\nuniform bool u_skewed;\nuniform float u_extra;\n\nuniform vec2 u_texsize;\n\nvarying vec2 v_tex;\nvarying float v_alpha;\nvarying float v_gamma_scale;\n\nvoid main() {\n    vec2 a_tex = a_data1.xy;\n    mediump float a_labelminzoom = a_data1[2];\n    mediump vec2 a_zoom = a_data2.st;\n    mediump float a_minzoom = a_zoom[0];\n    mediump float a_maxzoom = a_zoom[1];\n\n    // u_zoom is the current zoom level adjusted for the change in font size\n    mediump float z = 2.0 - step(a_minzoom, u_zoom) - (1.0 - step(a_maxzoom, u_zoom));\n\n    // fade out labels\n    mediump float alpha = clamp((u_fadezoom - a_labelminzoom) / u_fadedist, 0.0, 1.0);\n\n    if (u_fadedist >= 0.0) {\n        v_alpha = alpha;\n    } else {\n        v_alpha = 1.0 - alpha;\n    }\n    if (u_maxfadezoom < a_labelminzoom) {\n        v_alpha = 0.0;\n    }\n    if (u_minfadezoom >= a_labelminzoom) {\n        v_alpha = 1.0;\n    }\n\n    // if label has been faded out, clip it\n    z += step(v_alpha, 0.0);\n\n    if (u_skewed) {\n        vec4 extrude = u_exmatrix * vec4(a_offset / 64.0, 0, 0);\n        gl_Position = u_matrix * vec4(a_pos + extrude.xy, 0, 1);\n        gl_Position.z += z * gl_Position.w;\n    } else {\n        vec4 extrude = u_exmatrix * vec4(a_offset / 64.0, z, 0);\n        gl_Position = u_matrix * vec4(a_pos, 0, 1) + extrude;\n    }\n\n    // position of y on the screen\n    float y = gl_Position.y / gl_Position.w;\n    // how much features are squished in all directions by the perspectiveness\n    float perspective_scale = 1.0 / (1.0 - y * u_extra);\n    v_gamma_scale = perspective_scale;\n\n    v_tex = a_tex / u_texsize;\n}\n"
    },
    collisionbox: {
        fragment: "precision mediump float;\n\nuniform float u_zoom;\nuniform float u_maxzoom;\n\nvarying float v_max_zoom;\nvarying float v_placement_zoom;\n\nvoid main() {\n\n    float alpha = 0.5;\n\n    gl_FragColor = vec4(0.0, 1.0, 0.0, 1.0) * alpha;\n\n    if (v_placement_zoom > u_zoom) {\n        gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0) * alpha;\n    }\n\n    if (u_zoom >= v_max_zoom) {\n        gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0) * alpha * 0.25;\n    }\n\n    if (v_placement_zoom >= u_maxzoom) {\n        gl_FragColor = vec4(0.0, 0.0, 1.0, 1.0) * alpha * 0.2;\n    }\n}\n",
        vertex: "precision highp float;\n\nattribute vec2 a_pos;\nattribute vec2 a_extrude;\nattribute vec2 a_data;\n\nuniform mat4 u_matrix;\nuniform float u_scale;\n\nvarying float v_max_zoom;\nvarying float v_placement_zoom;\n\nvoid main() {\n     gl_Position = u_matrix * vec4(a_pos + a_extrude / u_scale, 0.0, 1.0);\n\n     v_max_zoom = a_data.x;\n     v_placement_zoom = a_data.y;\n}\n"
    }
};

},{"path":108}],28:[function(require,module,exports){
'use strict';

var util = require('../util/util');
var Evented = require('../util/evented');
var TilePyramid = require('./tile_pyramid');
var Source = require('./source');
var urlResolve = require('resolve-url');
var EXTENT = require('../data/bucket').EXTENT;

module.exports = GeoJSONSource;

/**
 * Create a GeoJSON data source instance given an options object
 * @class GeoJSONSource
 * @param {Object} [options]
 * @param {Object|string} options.data A GeoJSON data object or URL to it. The latter is preferable in case of large GeoJSON files.
 * @param {number} [options.maxzoom=18] Maximum zoom to preserve detail at.
 * @param {number} [options.buffer] Tile buffer on each side in pixels.
 * @param {number} [options.tolerance] Simplification tolerance (higher means simpler) in pixels.
 * @param {number} [options.cluster] If the data is a collection of point features, setting this to true clusters the points by radius into groups.
 * @param {number} [options.clusterRadius=50] Radius of each cluster when clustering points, in pixels.
 * @param {number} [options.clusterMaxZoom] Max zoom to cluster points on. Defaults to one zoom less than `maxzoom` (so that last zoom features are not clustered).

 * @example
 * var sourceObj = new mapboxgl.GeoJSONSource({
 *    data: {
 *        "type": "FeatureCollection",
 *        "features": [{
 *            "type": "Feature",
 *            "geometry": {
 *                "type": "Point",
 *                "coordinates": [
 *                    -76.53063297271729,
 *                    39.18174077994108
 *                ]
 *            }
 *        }]
 *    }
 * });
 * map.addSource('some id', sourceObj); // add
 * map.removeSource('some id');  // remove
 */
function GeoJSONSource(options) {
    options = options || {};

    this._data = options.data;

    if (options.maxzoom !== undefined) this.maxzoom = options.maxzoom;

    var scale = EXTENT / this.tileSize;

    this.geojsonVtOptions = {
        buffer: (options.buffer !== undefined ? options.buffer : 128) * scale,
        tolerance: (options.tolerance !== undefined ? options.tolerance : 0.375) * scale,
        extent: EXTENT,
        maxZoom: this.maxzoom
    };

    this.cluster = options.cluster || false;
    this.superclusterOptions = {
        maxZoom: Math.max(options.clusterMaxZoom, this.maxzoom - 1) || (this.maxzoom - 1),
        extent: EXTENT,
        radius: (options.clusterRadius || 50) * scale,
        log: false
    };

    this._pyramid = new TilePyramid({
        tileSize: this.tileSize,
        minzoom: this.minzoom,
        maxzoom: this.maxzoom,
        reparseOverscaled: true,
        load: this._loadTile.bind(this),
        abort: this._abortTile.bind(this),
        unload: this._unloadTile.bind(this),
        add: this._addTile.bind(this),
        remove: this._removeTile.bind(this),
        redoPlacement: this._redoTilePlacement.bind(this)
    });
}

GeoJSONSource.prototype = util.inherit(Evented, /** @lends GeoJSONSource.prototype */{
    minzoom: 0,
    maxzoom: 18,
    tileSize: 512,
    _dirty: true,
    isTileClipped: true,

    /**
     * Update source geojson data and rerender map
     *
     * @param {Object|string} data A GeoJSON data object or URL to it. The latter is preferable in case of large GeoJSON files.
     * @returns {GeoJSONSource} this
     */
    setData: function(data) {
        this._data = data;
        this._dirty = true;

        this.fire('change');

        if (this.map)
            this.update(this.map.transform);

        return this;
    },

    onAdd: function(map) {
        this.map = map;
    },

    loaded: function() {
        return this._loaded && this._pyramid.loaded();
    },

    update: function(transform) {
        if (this._dirty) {
            this._updateData();
        }

        if (this._loaded) {
            this._pyramid.update(this.used, transform);
        }
    },

    reload: function() {
        if (this._loaded) {
            this._pyramid.reload();
        }
    },

    serialize: function() {
        return {
            type: 'geojson',
            data: this._data
        };
    },

    getVisibleCoordinates: Source._getVisibleCoordinates,
    getTile: Source._getTile,

    queryRenderedFeatures: Source._queryRenderedVectorFeatures,
    querySourceFeatures: Source._querySourceFeatures,

    _updateData: function() {
        this._dirty = false;
        var options = {
            tileSize: this.tileSize,
            source: this.id,
            geojsonVtOptions: this.geojsonVtOptions,
            cluster: this.cluster,
            superclusterOptions: this.superclusterOptions
        };

        var data = this._data;
        if (typeof data === 'string') {
            options.url = typeof window != 'undefined' ? urlResolve(window.location.href, data) : data;
        } else {
            options.data = JSON.stringify(data);
        }
        this.workerID = this.dispatcher.send('parse geojson', options, function(err) {
            this._loaded = true;
            if (err) {
                this.fire('error', {error: err});
            } else {
                this._pyramid.reload();
                this.fire('change');
            }

        }.bind(this));
    },

    _loadTile: function(tile) {
        var overscaling = tile.coord.z > this.maxzoom ? Math.pow(2, tile.coord.z - this.maxzoom) : 1;
        var params = {
            uid: tile.uid,
            coord: tile.coord,
            zoom: tile.coord.z,
            maxZoom: this.maxzoom,
            tileSize: this.tileSize,
            source: this.id,
            overscaling: overscaling,
            angle: this.map.transform.angle,
            pitch: this.map.transform.pitch,
            showCollisionBoxes: this.map.showCollisionBoxes
        };

        tile.workerID = this.dispatcher.send('load geojson tile', params, function(err, data) {

            tile.unloadVectorData(this.map.painter);

            if (tile.aborted)
                return;

            if (err) {
                this.fire('tile.error', {tile: tile});
                return;
            }

            tile.loadVectorData(data);

            if (tile.redoWhenDone) {
                tile.redoWhenDone = false;
                tile.redoPlacement(this);
            }

            this.fire('tile.load', {tile: tile});

        }.bind(this), this.workerID);
    },

    _abortTile: function(tile) {
        tile.aborted = true;
    },

    _addTile: function(tile) {
        this.fire('tile.add', {tile: tile});
    },

    _removeTile: function(tile) {
        this.fire('tile.remove', {tile: tile});
    },

    _unloadTile: function(tile) {
        tile.unloadVectorData(this.map.painter);
        this.dispatcher.send('remove tile', { uid: tile.uid, source: this.id }, null, tile.workerID);
    },

    redoPlacement: Source.redoPlacement,

    _redoTilePlacement: function(tile) {
        tile.redoPlacement(this);
    }
});

},{"../data/bucket":1,"../util/evented":95,"../util/util":104,"./source":33,"./tile_pyramid":36,"resolve-url":164}],29:[function(require,module,exports){
'use strict';

var Point = require('point-geometry');
var VectorTileFeature = require('vector-tile').VectorTileFeature;
var EXTENT = require('../data/bucket').EXTENT;

module.exports = GeoJSONWrapper;

// conform to vectortile api
function GeoJSONWrapper(features) {
    this.features = features;
    this.length = features.length;
    this.extent = EXTENT;
}

GeoJSONWrapper.prototype.feature = function(i) {
    return new FeatureWrapper(this.features[i]);
};

function FeatureWrapper(feature) {
    this.type = feature.type;
    this.rawGeometry = feature.type === 1 ? [feature.geometry] : feature.geometry;
    this.properties = feature.tags;
    this.extent = EXTENT;
}

FeatureWrapper.prototype.loadGeometry = function() {
    var rings = this.rawGeometry;
    this.geometry = [];

    for (var i = 0; i < rings.length; i++) {
        var ring = rings[i],
            newRing = [];
        for (var j = 0; j < ring.length; j++) {
            newRing.push(new Point(ring[j][0], ring[j][1]));
        }
        this.geometry.push(newRing);
    }
    return this.geometry;
};

FeatureWrapper.prototype.bbox = function() {
    if (!this.geometry) this.loadGeometry();

    var rings = this.geometry,
        x1 = Infinity,
        x2 = -Infinity,
        y1 = Infinity,
        y2 = -Infinity;

    for (var i = 0; i < rings.length; i++) {
        var ring = rings[i];

        for (var j = 0; j < ring.length; j++) {
            var coord = ring[j];

            x1 = Math.min(x1, coord.x);
            x2 = Math.max(x2, coord.x);
            y1 = Math.min(y1, coord.y);
            y2 = Math.max(y2, coord.y);
        }
    }

    return [x1, y1, x2, y2];
};

FeatureWrapper.prototype.toGeoJSON = VectorTileFeature.prototype.toGeoJSON;

},{"../data/bucket":1,"point-geometry":162,"vector-tile":168}],30:[function(require,module,exports){
'use strict';

var util = require('../util/util');
var Tile = require('./tile');
var TileCoord = require('./tile_coord');
var LngLat = require('../geo/lng_lat');
var Point = require('point-geometry');
var Evented = require('../util/evented');
var ajax = require('../util/ajax');
var EXTENT = require('../data/bucket').EXTENT;

module.exports = ImageSource;

/**
 * Create an Image source instance given an options object
 * @class ImageSource
 * @param {Object} [options]
 * @param {string} options.url A string URL of an image file
 * @param {Array} options.coordinates Four geographical [lng, lat] coordinates in clockwise order defining the corners (starting with top left) of the image. Does not have to be a rectangle.
 * @example
 * var sourceObj = new mapboxgl.ImageSource({
 *    url: 'https://www.mapbox.com/images/foo.png',
 *    coordinates: [
 *        [-76.54335737228394, 39.18579907229748],
 *        [-76.52803659439087, 39.1838364847587],
 *        [-76.5295386314392, 39.17683392507606],
 *        [-76.54520273208618, 39.17876344106642]
 *    ]
 * });
 * map.addSource('some id', sourceObj); // add
 * map.removeSource('some id');  // remove
 */
function ImageSource(options) {
    this.urls = options.urls;
    this.coordinates = options.coordinates;

    ajax.getImage(options.url, function(err, image) {
        // @TODO handle errors via event.
        if (err) return;

        this.image = image;

        this.image.addEventListener('load', function() {
            this.map._rerender();
        }.bind(this));

        this._loaded = true;

        if (this.map) {
            this.setCoordinates(options.coordinates);
        }
    }.bind(this));
}

ImageSource.prototype = util.inherit(Evented, {
    onAdd: function(map) {
        this.map = map;
        if (this.image) {
            this.setCoordinates(this.coordinates);
        }
    },

    /**
     * Update image coordinates and rerender map
     *
     * @param {Array} coordinates Four geographical [lng, lat] coordinates in clockwise order defining the corners (starting with top left) of the image. Does not have to be a rectangle.
     * @returns {ImageSource} this
     */
    setCoordinates: function(coordinates) {
        this.coordinates = coordinates;

        // Calculate which mercator tile is suitable for rendering the image in
        // and create a buffer with the corner coordinates. These coordinates
        // may be outside the tile, because raster tiles aren't clipped when rendering.

        var map = this.map;
        var cornerZ0Coords = coordinates.map(function(coord) {
            return map.transform.locationCoordinate(LngLat.convert(coord)).zoomTo(0);
        });

        var centerCoord = this.centerCoord = util.getCoordinatesCenter(cornerZ0Coords);
        centerCoord.column = Math.round(centerCoord.column);
        centerCoord.row = Math.round(centerCoord.row);

        var tileCoords = cornerZ0Coords.map(function(coord) {
            var zoomedCoord = coord.zoomTo(centerCoord.zoom);
            return new Point(
                Math.round((zoomedCoord.column - centerCoord.column) * EXTENT),
                Math.round((zoomedCoord.row - centerCoord.row) * EXTENT));
        });

        var gl = map.painter.gl;
        var maxInt16 = 32767;
        var array = new Int16Array([
            tileCoords[0].x, tileCoords[0].y, 0, 0,
            tileCoords[1].x, tileCoords[1].y, maxInt16, 0,
            tileCoords[3].x, tileCoords[3].y, 0, maxInt16,
            tileCoords[2].x, tileCoords[2].y, maxInt16, maxInt16
        ]);

        this.tile = new Tile(new TileCoord(centerCoord.zoom, centerCoord.column, centerCoord.row));
        this.tile.buckets = {};

        this.tile.boundsBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, this.tile.boundsBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, array, gl.STATIC_DRAW);

        this.fire('change');

        return this;
    },

    loaded: function() {
        return this.image && this.image.complete;
    },

    update: function() {
        // noop
    },

    reload: function() {
        // noop
    },

    prepare: function() {
        if (!this._loaded || !this.loaded()) return;

        var painter = this.map.painter;
        var gl = painter.gl;

        if (!this.tile.texture) {
            this.tile.texture = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, this.tile.texture);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, this.image);
        } else {
            gl.bindTexture(gl.TEXTURE_2D, this.tile.texture);
            gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, gl.RGBA, gl.UNSIGNED_BYTE, this.image);
        }
    },

    getVisibleCoordinates: function() {
        if (this.tile) return [this.tile.coord];
        else return [];
    },

    getTile: function() {
        return this.tile;
    },

    serialize: function() {
        return {
            type: 'image',
            urls: this.urls,
            coordinates: this.coordinates
        };
    }
});

},{"../data/bucket":1,"../geo/lng_lat":10,"../util/ajax":88,"../util/evented":95,"../util/util":104,"./tile":34,"./tile_coord":35,"point-geometry":162}],31:[function(require,module,exports){
'use strict';

var Bucket = require('../data/bucket');

/**
 * Converts a pixel value at a the given zoom level to tile units.
 *
 * The shaders mostly calculate everything in tile units so style
 * properties need to be converted from pixels to tile units using this.
 *
 * For example, a translation by 30 pixels at zoom 6.5 will be a
 * translation by pixelsToTileUnits(30, 6.5) tile units.
 *
 * @param {object} tile a {Tile object} will work well, but any object that follows the format {coord: {TileCord object}, tileSize: {number}} will work
 * @param {number} pixelValue
 * @param {number} z
 * @returns {number} value in tile units
 * @private
 */
module.exports = function(tile, pixelValue, z) {
    return pixelValue * (Bucket.EXTENT / (tile.tileSize * Math.pow(2, z - tile.coord.z)));
};


},{"../data/bucket":1}],32:[function(require,module,exports){
'use strict';

var util = require('../util/util');
var ajax = require('../util/ajax');
var Evented = require('../util/evented');
var Source = require('./source');
var normalizeURL = require('../util/mapbox').normalizeTileURL;

module.exports = RasterTileSource;

function RasterTileSource(options) {
    util.extend(this, util.pick(options, ['url', 'tileSize']));

    Source._loadTileJSON.call(this, options);
}

RasterTileSource.prototype = util.inherit(Evented, {
    minzoom: 0,
    maxzoom: 22,
    roundZoom: true,
    tileSize: 512,
    _loaded: false,

    onAdd: function(map) {
        this.map = map;
    },

    loaded: function() {
        return this._pyramid && this._pyramid.loaded();
    },

    update: function(transform) {
        if (this._pyramid) {
            this._pyramid.update(this.used, transform, this.map.style.rasterFadeDuration);
        }
    },

    reload: function() {
        // noop
    },

    serialize: function() {
        return {
            type: 'raster',
            url: this.url,
            tileSize: this.tileSize
        };
    },

    getVisibleCoordinates: Source._getVisibleCoordinates,
    getTile: Source._getTile,

    _loadTile: function(tile) {
        var url = normalizeURL(tile.coord.url(this.tiles), this.url, this.tileSize);

        tile.request = ajax.getImage(url, done.bind(this));

        function done(err, img) {
            delete tile.request;

            if (tile.aborted)
                return;

            if (err) {
                tile.errored = true;
                this.fire('tile.error', {tile: tile, error: err});
                return;
            }

            var gl = this.map.painter.gl;
            tile.texture = this.map.painter.getTexture(img.width);
            if (tile.texture) {
                gl.bindTexture(gl.TEXTURE_2D, tile.texture);
                gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, gl.RGBA, gl.UNSIGNED_BYTE, img);
            } else {
                tile.texture = gl.createTexture();
                gl.bindTexture(gl.TEXTURE_2D, tile.texture);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_NEAREST);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
                gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, true);
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, img);
                tile.texture.size = img.width;
            }
            gl.generateMipmap(gl.TEXTURE_2D);

            tile.timeAdded = new Date().getTime();
            this.map.animationLoop.set(this.style.rasterFadeDuration);

            tile.source = this;
            tile.loaded = true;

            this.fire('tile.load', {tile: tile});
        }
    },

    _abortTile: function(tile) {
        tile.aborted = true;

        if (tile.request) {
            tile.request.abort();
            delete tile.request;
        }
    },

    _addTile: function(tile) {
        this.fire('tile.add', {tile: tile});
    },

    _removeTile: function(tile) {
        this.fire('tile.remove', {tile: tile});
    },

    _unloadTile: function(tile) {
        if (tile.texture) this.map.painter.saveTexture(tile.texture);
    }
});

},{"../util/ajax":88,"../util/evented":95,"../util/mapbox":101,"../util/util":104,"./source":33}],33:[function(require,module,exports){
'use strict';

var util = require('../util/util');
var ajax = require('../util/ajax');
var browser = require('../util/browser');
var TilePyramid = require('./tile_pyramid');
var normalizeURL = require('../util/mapbox').normalizeSourceURL;
var TileCoord = require('./tile_coord');

exports._loadTileJSON = function(options) {
    var loaded = function(err, tileJSON) {
        if (err) {
            this.fire('error', {error: err});
            return;
        }

        util.extend(this, util.pick(tileJSON,
            ['tiles', 'minzoom', 'maxzoom', 'attribution']));

        if (tileJSON.vector_layers) {
            this.vectorLayers = tileJSON.vector_layers;
            this.vectorLayerIds = this.vectorLayers.map(function(layer) { return layer.id; });
        }

        this._pyramid = new TilePyramid({
            tileSize: this.tileSize,
            minzoom: this.minzoom,
            maxzoom: this.maxzoom,
            roundZoom: this.roundZoom,
            reparseOverscaled: this.reparseOverscaled,
            load: this._loadTile.bind(this),
            abort: this._abortTile.bind(this),
            unload: this._unloadTile.bind(this),
            add: this._addTile.bind(this),
            remove: this._removeTile.bind(this),
            redoPlacement: this._redoTilePlacement ? this._redoTilePlacement.bind(this) : undefined
        });

        this.fire('load');
    }.bind(this);

    if (options.url) {
        ajax.getJSON(normalizeURL(options.url), loaded);
    } else {
        browser.frame(loaded.bind(this, null, options));
    }
};

exports.redoPlacement = function() {
    if (!this._pyramid) {
        return;
    }

    var ids = this._pyramid.orderedIDs();
    for (var i = 0; i < ids.length; i++) {
        var tile = this._pyramid.getTile(ids[i]);
        this._redoTilePlacement(tile);
    }
};

exports._getTile = function(coord) {
    return this._pyramid.getTile(coord.id);
};

exports._getVisibleCoordinates = function() {
    if (!this._pyramid) return [];
    else return this._pyramid.renderedIDs().map(TileCoord.fromID);
};

function sortTilesIn(a, b) {
    var coordA = a.tile.coord;
    var coordB = b.tile.coord;
    return (coordA.z - coordB.z) || (coordA.y - coordB.y) || (coordA.x - coordB.x);
}

function mergeRenderedFeatureLayers(tiles) {
    var result = tiles[0] || {};
    for (var i = 1; i < tiles.length; i++) {
        var tile = tiles[i];
        for (var layerID in tile) {
            var tileFeatures = tile[layerID];
            var resultFeatures = result[layerID];
            if (resultFeatures === undefined) {
                resultFeatures = result[layerID] = tileFeatures;
            } else {
                for (var f = 0; f < tileFeatures.length; f++) {
                    resultFeatures.push(tileFeatures[f]);
                }
            }
        }
    }
    return result;
}

exports._queryRenderedVectorFeatures = function(queryGeometry, params, classes, zoom, bearing) {
    if (!this._pyramid)
        return {};

    var tilesIn = this._pyramid.tilesIn(queryGeometry);

    tilesIn.sort(sortTilesIn);

    var styleLayers = this.map.style._layers;

    var renderedFeatureLayers = [];
    for (var r = 0; r < tilesIn.length; r++) {
        var tileIn = tilesIn[r];
        if (!tileIn.tile.featureIndex) continue;

        renderedFeatureLayers.push(tileIn.tile.featureIndex.query({
            queryGeometry: tileIn.queryGeometry,
            scale: tileIn.scale,
            tileSize: tileIn.tile.tileSize,
            bearing: bearing,
            params: params
        }, styleLayers));
    }
    return mergeRenderedFeatureLayers(renderedFeatureLayers);
};

exports._querySourceFeatures = function(params) {
    if (!this._pyramid) {
        return [];
    }

    var pyramid = this._pyramid;
    var tiles = pyramid.renderedIDs().map(function(id) {
        return pyramid.getTile(id);
    });

    var result = [];

    var dataTiles = {};
    for (var i = 0; i < tiles.length; i++) {
        var tile = tiles[i];
        var dataID = new TileCoord(Math.min(tile.sourceMaxZoom, tile.coord.z), tile.coord.x, tile.coord.y, 0).id;
        if (!dataTiles[dataID]) {
            dataTiles[dataID] = true;
            tile.querySourceFeatures(result, params);
        }
    }

    return result;
};

/*
 * Create a tiled data source instance given an options object
 *
 * @param {Object} options
 * @param {string} options.type Either `raster` or `vector`.
 * @param {string} options.url A tile source URL. This should either be `mapbox://{mapid}` or a full `http[s]` url that points to a TileJSON endpoint.
 * @param {Array} options.tiles An array of tile sources. If `url` is not specified, `tiles` can be used instead to specify tile sources, as in the TileJSON spec. Other TileJSON keys such as `minzoom` and `maxzoom` can be specified in a source object if `tiles` is used.
 * @param {string} options.id An optional `id` to assign to the source
 * @param {number} [options.tileSize=512] Optional tile size (width and height in pixels, assuming tiles are square). This option is only configurable for raster sources
 * @example
 * var sourceObj = new mapboxgl.Source.create({
 *    type: 'vector',
 *    url: 'mapbox://mapbox.mapbox-streets-v5'
 * });
 * map.addSource('some id', sourceObj); // add
 * map.removeSource('some id');  // remove
 */
exports.create = function(source) {
    // This is not at file scope in order to avoid a circular require.
    var sources = {
        vector: require('./vector_tile_source'),
        raster: require('./raster_tile_source'),
        geojson: require('./geojson_source'),
        video: require('./video_source'),
        image: require('./image_source')
    };

    return exports.is(source) ? source : new sources[source.type](source);
};

exports.is = function(source) {
    // This is not at file scope in order to avoid a circular require.
    var sources = {
        vector: require('./vector_tile_source'),
        raster: require('./raster_tile_source'),
        geojson: require('./geojson_source'),
        video: require('./video_source'),
        image: require('./image_source')
    };

    for (var type in sources) {
        if (source instanceof sources[type]) {
            return true;
        }
    }

    return false;
};

},{"../util/ajax":88,"../util/browser":89,"../util/mapbox":101,"../util/util":104,"./geojson_source":28,"./image_source":30,"./raster_tile_source":32,"./tile_coord":35,"./tile_pyramid":36,"./vector_tile_source":37,"./video_source":38}],34:[function(require,module,exports){
'use strict';

var util = require('../util/util');
var Bucket = require('../data/bucket');
var FeatureIndex = require('../data/feature_index');
var vt = require('vector-tile');
var Protobuf = require('pbf');
var GeoJSONFeature = require('../util/vectortile_to_geojson');
var featureFilter = require('feature-filter');
var CollisionTile = require('../symbol/collision_tile');
var CollisionBoxArray = require('../symbol/collision_box');

module.exports = Tile;

/**
 * A tile object is the combination of a Coordinate, which defines
 * its place, as well as a unique ID and data tracking for its content
 *
 * @param {Coordinate} coord
 * @param {number} size
 * @private
 */
function Tile(coord, size, sourceMaxZoom) {
    this.coord = coord;
    this.uid = util.uniqueId();
    this.loaded = false; // TODO rename loaded
    this.isUnloaded = false;
    this.uses = 0;
    this.tileSize = size;
    this.sourceMaxZoom = sourceMaxZoom;
    this.buckets = {};
}

Tile.prototype = {

    /**
     * Given a data object with a 'buffers' property, load it into
     * this tile's elementGroups and buffers properties and set loaded
     * to true. If the data is null, like in the case of an empty
     * GeoJSON tile, no-op but still set loaded to true.
     * @param {Object} data
     * @returns {undefined}
     * @private
     */
    loadVectorData: function(data) {
        this.loaded = true;

        // empty GeoJSON tile
        if (!data) return;

        this.collisionBoxArray = new CollisionBoxArray(data.collisionBoxArray);
        this.collisionTile = new CollisionTile(data.collisionTile, this.collisionBoxArray);
        this.featureIndex = new FeatureIndex(data.featureIndex, data.rawTileData, this.collisionTile);
        this.rawTileData = data.rawTileData;
        this.buckets = unserializeBuckets(data.buckets);
    },

    /**
     * given a data object and a GL painter, destroy and re-create
     * all of its buffers.
     * @param {Object} data
     * @param {Object} painter
     * @returns {undefined}
     * @private
     */
    reloadSymbolData: function(data, painter) {
        if (this.isUnloaded) return;

        this.collisionTile = new CollisionTile(data.collisionTile, this.collisionBoxArray);
        this.featureIndex.setCollisionTile(this.collisionTile);

        // Destroy and delete existing symbol buckets
        for (var id in this.buckets) {
            var bucket = this.buckets[id];
            if (bucket.type === 'symbol') {
                bucket.destroy(painter.gl);
                delete this.buckets[id];
            }
        }

        // Add new symbol buckets
        util.extend(this.buckets, unserializeBuckets(data.buckets));
    },

    /**
     * Make sure that this tile doesn't own any data within a given
     * painter, so that it doesn't consume any memory or maintain
     * any references to the painter.
     * @param {Object} painter gl painter object
     * @returns {undefined}
     * @private
     */
    unloadVectorData: function(painter) {
        for (var id in this.buckets) {
            var bucket = this.buckets[id];
            bucket.destroy(painter.gl);
        }

        this.buckets = null;
        this.loaded = false;
        this.isUnloaded = true;
    },

    redoPlacement: function(source) {
        if (!this.loaded || this.redoingPlacement) {
            this.redoWhenDone = true;
            return;
        }

        this.redoingPlacement = true;

        source.dispatcher.send('redo placement', {
            uid: this.uid,
            source: source.id,
            angle: source.map.transform.angle,
            pitch: source.map.transform.pitch,
            showCollisionBoxes: source.map.showCollisionBoxes
        }, done.bind(this), this.workerID);

        function done(_, data) {
            this.reloadSymbolData(data, source.map.painter);
            source.fire('tile.load', {tile: this});

            this.redoingPlacement = false;
            if (this.redoWhenDone) {
                this.redoPlacement(source);
                this.redoWhenDone = false;
            }
        }
    },

    getBucket: function(layer) {
        return this.buckets && this.buckets[layer.ref || layer.id];
    },

    querySourceFeatures: function(result, params) {
        if (!this.rawTileData) return;

        if (!this.vtLayers) {
            this.vtLayers = new vt.VectorTile(new Protobuf(new Uint8Array(this.rawTileData))).layers;
        }

        var layer = this.vtLayers._geojsonTileLayer || this.vtLayers[params.sourceLayer];

        if (!layer) return;

        var filter = featureFilter(params.filter);
        var coord = { z: this.coord.z, x: this.coord.x, y: this.coord.y };

        for (var i = 0; i < layer.length; i++) {
            var feature = layer.feature(i);
            if (filter(feature)) {
                var geojsonFeature = new GeoJSONFeature(feature, this.coord.z, this.coord.x, this.coord.y);
                geojsonFeature.tile = coord;
                result.push(geojsonFeature);
            }
        }
    }
};

function unserializeBuckets(input) {
    var output = {};
    for (var i = 0; i < input.length; i++) {
        var bucket = Bucket.create(input[i]);
        output[bucket.id] = bucket;
    }
    return output;
}

},{"../data/bucket":1,"../data/feature_index":7,"../symbol/collision_box":60,"../symbol/collision_tile":62,"../util/util":104,"../util/vectortile_to_geojson":105,"feature-filter":113,"pbf":160,"vector-tile":168}],35:[function(require,module,exports){
'use strict';

var assert = require('assert');
var Coordinate = require('../geo/coordinate');

module.exports = TileCoord;

function TileCoord(z, x, y, w) {
    assert(!isNaN(z) && z >= 0 && z % 1 === 0);
    assert(!isNaN(x) && x >= 0 && x % 1 === 0);
    assert(!isNaN(y) && y >= 0 && y % 1 === 0);

    if (isNaN(w)) w = 0;

    this.z = +z;
    this.x = +x;
    this.y = +y;
    this.w = +w;

    // calculate id
    w *= 2;
    if (w < 0) w = w * -1 - 1;
    var dim = 1 << this.z;
    this.id = ((dim * dim * w + dim * this.y + this.x) * 32) + this.z;
}

TileCoord.prototype.toString = function() {
    return this.z + "/" + this.x + "/" + this.y;
};

TileCoord.prototype.toCoordinate = function() {
    var zoom = this.z;
    var tileScale = Math.pow(2, zoom);
    var row = this.y;
    var column = this.x + tileScale * this.w;
    return new Coordinate(column, row, zoom);
};

// Parse a packed integer id into a TileCoord object
TileCoord.fromID = function(id) {
    var z = id % 32, dim = 1 << z;
    var xy = ((id - z) / 32);
    var x = xy % dim, y = ((xy - x) / dim) % dim;
    var w = Math.floor(xy / (dim * dim));
    if (w % 2 !== 0) w = w * -1 - 1;
    w /= 2;
    return new TileCoord(z, x, y, w);
};

// given a list of urls, choose a url template and return a tile URL
TileCoord.prototype.url = function(urls, sourceMaxZoom) {
    return urls[(this.x + this.y) % urls.length]
        .replace('{prefix}', (this.x % 16).toString(16) + (this.y % 16).toString(16))
        .replace('{z}', Math.min(this.z, sourceMaxZoom || this.z))
        .replace('{x}', this.x)
        .replace('{y}', this.y);
};

// Return the coordinate of the parent tile
TileCoord.prototype.parent = function(sourceMaxZoom) {
    if (this.z === 0) return null;

    // the id represents an overscaled tile, return the same coordinates with a lower z
    if (this.z > sourceMaxZoom) {
        return new TileCoord(this.z - 1, this.x, this.y, this.w);
    }

    return new TileCoord(this.z - 1, Math.floor(this.x / 2), Math.floor(this.y / 2), this.w);
};

TileCoord.prototype.wrapped = function() {
    return new TileCoord(this.z, this.x, this.y, 0);
};

// Return the coordinates of the tile's children
TileCoord.prototype.children = function(sourceMaxZoom) {

    if (this.z >= sourceMaxZoom) {
        // return a single tile coord representing a an overscaled tile
        return [new TileCoord(this.z + 1, this.x, this.y, this.w)];
    }

    var z = this.z + 1;
    var x = this.x * 2;
    var y = this.y * 2;
    return [
        new TileCoord(z, x, y, this.w),
        new TileCoord(z, x + 1, y, this.w),
        new TileCoord(z, x, y + 1, this.w),
        new TileCoord(z, x + 1, y + 1, this.w)
    ];
};

// Taken from polymaps src/Layer.js
// https://github.com/simplegeo/polymaps/blob/master/src/Layer.js#L333-L383

function edge(a, b) {
    if (a.row > b.row) { var t = a; a = b; b = t; }
    return {
        x0: a.column,
        y0: a.row,
        x1: b.column,
        y1: b.row,
        dx: b.column - a.column,
        dy: b.row - a.row
    };
}

function scanSpans(e0, e1, ymin, ymax, scanLine) {
    var y0 = Math.max(ymin, Math.floor(e1.y0));
    var y1 = Math.min(ymax, Math.ceil(e1.y1));

    // sort edges by x-coordinate
    if ((e0.x0 === e1.x0 && e0.y0 === e1.y0) ?
            (e0.x0 + e1.dy / e0.dy * e0.dx < e1.x1) :
            (e0.x1 - e1.dy / e0.dy * e0.dx < e1.x0)) {
        var t = e0; e0 = e1; e1 = t;
    }

    // scan lines!
    var m0 = e0.dx / e0.dy;
    var m1 = e1.dx / e1.dy;
    var d0 = e0.dx > 0; // use y + 1 to compute x0
    var d1 = e1.dx < 0; // use y + 1 to compute x1
    for (var y = y0; y < y1; y++) {
        var x0 = m0 * Math.max(0, Math.min(e0.dy, y + d0 - e0.y0)) + e0.x0;
        var x1 = m1 * Math.max(0, Math.min(e1.dy, y + d1 - e1.y0)) + e1.x0;
        scanLine(Math.floor(x1), Math.ceil(x0), y);
    }
}

function scanTriangle(a, b, c, ymin, ymax, scanLine) {
    var ab = edge(a, b),
        bc = edge(b, c),
        ca = edge(c, a);

    var t;

    // sort edges by y-length
    if (ab.dy > bc.dy) { t = ab; ab = bc; bc = t; }
    if (ab.dy > ca.dy) { t = ab; ab = ca; ca = t; }
    if (bc.dy > ca.dy) { t = bc; bc = ca; ca = t; }

    // scan span! scan span!
    if (ab.dy) scanSpans(ca, ab, ymin, ymax, scanLine);
    if (bc.dy) scanSpans(ca, bc, ymin, ymax, scanLine);
}

TileCoord.cover = function(z, bounds, actualZ) {
    var tiles = 1 << z;
    var t = {};

    function scanLine(x0, x1, y) {
        var x, wx, coord;
        if (y >= 0 && y <= tiles) {
            for (x = x0; x < x1; x++) {
                wx = (x % tiles + tiles) % tiles;
                coord = new TileCoord(actualZ, wx, y, Math.floor(x / tiles));
                t[coord.id] = coord;
            }
        }
    }

    // Divide the screen up in two triangles and scan each of them:
    // +---/
    // | / |
    // /---+
    scanTriangle(bounds[0], bounds[1], bounds[2], 0, tiles, scanLine);
    scanTriangle(bounds[2], bounds[3], bounds[0], 0, tiles, scanLine);

    return Object.keys(t).map(function(id) {
        return t[id];
    });
};

},{"../geo/coordinate":9,"assert":106}],36:[function(require,module,exports){
'use strict';

var Tile = require('./tile');
var TileCoord = require('./tile_coord');
var Point = require('point-geometry');
var Cache = require('../util/lru_cache');
var Coordinate = require('../geo/coordinate');
var util = require('../util/util');
var EXTENT = require('../data/bucket').EXTENT;

module.exports = TilePyramid;

/**
 * A tile pyramid is a specialized cache and datastructure
 * that contains tiles. It's used by sources to manage their
 * data.
 *
 * @param {Object} options
 * @param {number} options.tileSize
 * @param {number} options.minzoom
 * @param {number} options.maxzoom
 * @private
 */
function TilePyramid(options) {
    this.tileSize = options.tileSize;
    this.minzoom = options.minzoom;
    this.maxzoom = options.maxzoom;
    this.roundZoom = options.roundZoom;
    this.reparseOverscaled = options.reparseOverscaled;

    this._load = options.load;
    this._abort = options.abort;
    this._unload = options.unload;
    this._add = options.add;
    this._remove = options.remove;
    this._redoPlacement = options.redoPlacement;

    this._tiles = {};
    this._cache = new Cache(0, function(tile) { return this._unload(tile); }.bind(this));

    this._filterRendered = this._filterRendered.bind(this);
}


TilePyramid.maxOverzooming = 10;
TilePyramid.maxUnderzooming = 3;

TilePyramid.prototype = {
    /**
     * Confirm that every tracked tile is loaded.
     * @returns {boolean} whether all tiles are loaded.
     * @private
     */
    loaded: function() {
        for (var t in this._tiles) {
            if (!this._tiles[t].loaded && !this._tiles[t].errored)
                return false;
        }
        return true;
    },

    /**
     * Return all tile ids ordered with z-order, and cast to numbers
     * @returns {Array<number>} ids
     * @private
     */
    orderedIDs: function() {
        return Object.keys(this._tiles).map(Number).sort(compareKeyZoom);
    },

    renderedIDs: function() {
        return this.orderedIDs().filter(this._filterRendered);
    },

    _filterRendered: function(id) {
        return this._tiles[id].loaded && !this._coveredTiles[id];
    },

    reload: function() {
        this._cache.reset();
        for (var i in this._tiles) {
            this._load(this._tiles[i]);
        }
    },

    /**
     * Get a specific tile by id
     * @param {string|number} id tile id
     * @returns {Object} tile
     * @private
     */
    getTile: function(id) {
        return this._tiles[id];
    },

    /**
     * get the zoom level adjusted for the difference in map and source tilesizes
     * @param {Object} transform
     * @returns {number} zoom level
     * @private
     */
    getZoom: function(transform) {
        return transform.zoom + Math.log(transform.tileSize / this.tileSize) / Math.LN2;
    },

    /**
     * Return a zoom level that will cover all tiles in a given transform
     * @param {Object} transform
     * @returns {number} zoom level
     * @private
     */
    coveringZoomLevel: function(transform) {
        return (this.roundZoom ? Math.round : Math.floor)(this.getZoom(transform));
    },

    /**
     * Given a transform, return all coordinates that could cover that
     * transform for a covering zoom level.
     * @param {Object} transform
     * @returns {Array<Tile>} tiles
     * @private
     */
    coveringTiles: function(transform) {
        var z = this.coveringZoomLevel(transform);
        var actualZ = z;

        if (z < this.minzoom) return [];
        if (z > this.maxzoom) z = this.maxzoom;

        var tr = transform,
            tileCenter = tr.locationCoordinate(tr.center)._zoomTo(z),
            centerPoint = new Point(tileCenter.column - 0.5, tileCenter.row - 0.5);

        return TileCoord.cover(z, [
            tr.pointCoordinate(new Point(0, 0))._zoomTo(z),
            tr.pointCoordinate(new Point(tr.width, 0))._zoomTo(z),
            tr.pointCoordinate(new Point(tr.width, tr.height))._zoomTo(z),
            tr.pointCoordinate(new Point(0, tr.height))._zoomTo(z)
        ], this.reparseOverscaled ? actualZ : z).sort(function(a, b) {
            return centerPoint.dist(a) - centerPoint.dist(b);
        });
    },

    /**
     * Recursively find children of the given tile (up to maxCoveringZoom) that are already loaded;
     * adds found tiles to retain object; returns true if any child is found.
     *
     * @param {Coordinate} coord
     * @param {number} maxCoveringZoom
     * @param {boolean} retain
     * @returns {boolean} whether the operation was complete
     * @private
     */
    findLoadedChildren: function(coord, maxCoveringZoom, retain) {
        var found = false;

        for (var id in this._tiles) {
            var tile = this._tiles[id];

            // only consider loaded tiles on higher zoom levels (up to maxCoveringZoom)
            if (retain[id] || !tile.loaded || tile.coord.z <= coord.z || tile.coord.z > maxCoveringZoom) continue;

            // disregard tiles that are not descendants of the given tile coordinate
            var z2 = Math.pow(2, Math.min(tile.coord.z, this.maxzoom) - Math.min(coord.z, this.maxzoom));
            if (Math.floor(tile.coord.x / z2) !== coord.x ||
                Math.floor(tile.coord.y / z2) !== coord.y)
                continue;

            // found loaded child
            retain[id] = true;
            found = true;

            // loop through parents; retain the topmost loaded one if found
            while (tile && tile.coord.z - 1 > coord.z) {
                var parentId = tile.coord.parent(this.maxzoom).id;
                tile = this._tiles[parentId];

                if (tile && tile.loaded) {
                    delete retain[id];
                    retain[parentId] = true;
                }
            }
        }
        return found;
    },

    /**
     * Find a loaded parent of the given tile (up to minCoveringZoom);
     * adds the found tile to retain object and returns the tile if found
     *
     * @param {Coordinate} coord
     * @param {number} minCoveringZoom
     * @param {boolean} retain
     * @returns {Tile} tile object
     * @private
     */
    findLoadedParent: function(coord, minCoveringZoom, retain) {
        for (var z = coord.z - 1; z >= minCoveringZoom; z--) {
            coord = coord.parent(this.maxzoom);
            var tile = this._tiles[coord.id];
            if (tile && tile.loaded) {
                retain[coord.id] = true;
                return tile;
            }
            if (this._cache.has(coord.id)) {
                this.addTile(coord);
                retain[coord.id] = true;
                return this._tiles[coord.id];
            }
        }
    },

    /**
     * Resizes the tile cache based on the current viewport's size.
     *
     * Larger viewports use more tiles and need larger caches. Larger viewports
     * are more likely to be found on devices with more memory and on pages where
     * the map is more important.
     *
     * @private
     */
    updateCacheSize: function(transform) {
        var widthInTiles = Math.ceil(transform.width / transform.tileSize) + 1;
        var heightInTiles = Math.ceil(transform.height / transform.tileSize) + 1;
        var approxTilesInView = widthInTiles * heightInTiles;
        var commonZoomRange = 5;
        this._cache.setMaxSize(Math.floor(approxTilesInView * commonZoomRange));
    },

    /**
     * Removes tiles that are outside the viewport and adds new tiles that
     * are inside the viewport.
     * @private
     */
    update: function(used, transform, fadeDuration) {
        var i;
        var coord;
        var tile;

        this.updateCacheSize(transform);

        // Determine the overzooming/underzooming amounts.
        var zoom = (this.roundZoom ? Math.round : Math.floor)(this.getZoom(transform));
        var minCoveringZoom = Math.max(zoom - TilePyramid.maxOverzooming, this.minzoom);
        var maxCoveringZoom = Math.max(zoom + TilePyramid.maxUnderzooming,  this.minzoom);

        // Retain is a list of tiles that we shouldn't delete, even if they are not
        // the most ideal tile for the current viewport. This may include tiles like
        // parent or child tiles that are *already* loaded.
        var retain = {};
        var now = new Date().getTime();

        // Covered is a list of retained tiles who's areas are full covered by other,
        // better, retained tiles. They are not drawn separately.
        this._coveredTiles = {};

        var required = used ? this.coveringTiles(transform) : [];
        for (i = 0; i < required.length; i++) {
            coord = required[i];
            tile = this.addTile(coord);

            retain[coord.id] = true;

            if (tile.loaded)
                continue;

            // The tile we require is not yet loaded.
            // Retain child or parent tiles that cover the same area.
            if (!this.findLoadedChildren(coord, maxCoveringZoom, retain)) {
                this.findLoadedParent(coord, minCoveringZoom, retain);
            }
        }

        var parentsForFading = {};

        var ids = Object.keys(retain);
        for (var k = 0; k < ids.length; k++) {
            var id = ids[k];
            coord = TileCoord.fromID(id);
            tile = this._tiles[id];
            if (tile && tile.timeAdded > now - (fadeDuration || 0)) {
                // This tile is still fading in. Find tiles to cross-fade with it.
                if (this.findLoadedChildren(coord, maxCoveringZoom, retain)) {
                    retain[id] = true;
                }
                this.findLoadedParent(coord, minCoveringZoom, parentsForFading);
            }
        }

        var fadedParent;
        for (fadedParent in parentsForFading) {
            if (!retain[fadedParent]) {
                // If a tile is only needed for fading, mark it as covered so that it isn't rendered on it's own.
                this._coveredTiles[fadedParent] = true;
            }
        }
        for (fadedParent in parentsForFading) {
            retain[fadedParent] = true;
        }

        // Remove the tiles we don't need anymore.
        var remove = util.keysDifference(this._tiles, retain);
        for (i = 0; i < remove.length; i++) {
            this.removeTile(+remove[i]);
        }

        this.transform = transform;
    },

    /**
     * Add a tile, given its coordinate, to the pyramid.
     * @param {Coordinate} coord
     * @returns {Coordinate} the coordinate.
     * @private
     */
    addTile: function(coord) {
        var tile = this._tiles[coord.id];
        if (tile)
            return tile;

        var wrapped = coord.wrapped();
        tile = this._tiles[wrapped.id];

        if (!tile) {
            tile = this._cache.get(wrapped.id);
            if (tile && this._redoPlacement) {
                this._redoPlacement(tile);
            }
        }

        if (!tile) {
            var zoom = coord.z;
            var overscaling = zoom > this.maxzoom ? Math.pow(2, zoom - this.maxzoom) : 1;
            tile = new Tile(wrapped, this.tileSize * overscaling, this.maxzoom);
            this._load(tile);
        }

        tile.uses++;
        this._tiles[coord.id] = tile;
        this._add(tile, coord);

        return tile;
    },

    /**
     * Remove a tile, given its id, from the pyramid
     * @param {string|number} id tile id
     * @returns {undefined} nothing
     * @private
     */
    removeTile: function(id) {
        var tile = this._tiles[id];
        if (!tile)
            return;

        tile.uses--;
        delete this._tiles[id];
        this._remove(tile);

        if (tile.uses > 0)
            return;

        if (tile.loaded) {
            this._cache.add(tile.coord.wrapped().id, tile);
        } else {
            this._abort(tile);
            this._unload(tile);
        }
    },

    /**
     * Remove all tiles from this pyramid
     * @private
     */
    clearTiles: function() {
        for (var id in this._tiles)
            this.removeTile(id);
        this._cache.reset();
    },

    /**
     * Search through our current tiles and attempt to find the tiles that
     * cover the given bounds.
     * @param {Array<Coordinate>} queryGeometry coordinates of the corners of bounding rectangle
     * @returns {Array<Object>} result items have {tile, minX, maxX, minY, maxY}, where min/max bounding values are the given bounds transformed in into the coordinate space of this tile.
     * @private
     */
    tilesIn: function(queryGeometry) {
        var tileResults = {};
        var ids = this.orderedIDs();

        var minX = Infinity;
        var minY = Infinity;
        var maxX = -Infinity;
        var maxY = -Infinity;
        var z = queryGeometry[0].zoom;

        for (var k = 0; k < queryGeometry.length; k++) {
            var p = queryGeometry[k];
            minX = Math.min(minX, p.column);
            minY = Math.min(minY, p.row);
            maxX = Math.max(maxX, p.column);
            maxY = Math.max(maxY, p.row);
        }

        for (var i = 0; i < ids.length; i++) {
            var tile = this._tiles[ids[i]];
            var coord = TileCoord.fromID(ids[i]);

            var tileSpaceBounds = [
                coordinateToTilePoint(coord, tile.sourceMaxZoom, new Coordinate(minX, minY, z)),
                coordinateToTilePoint(coord, tile.sourceMaxZoom, new Coordinate(maxX, maxY, z))
            ];

            if (tileSpaceBounds[0].x < EXTENT && tileSpaceBounds[0].y < EXTENT &&
                tileSpaceBounds[1].x >= 0 && tileSpaceBounds[1].y >= 0) {

                var tileSpaceQueryGeometry = [];
                for (var j = 0; j < queryGeometry.length; j++) {
                    tileSpaceQueryGeometry.push(coordinateToTilePoint(coord, tile.sourceMaxZoom, queryGeometry[j]));
                }

                var tileResult = tileResults[tile.coord.id];
                if (tileResult === undefined) {
                    tileResult = tileResults[tile.coord.id] = {
                        tile: tile,
                        queryGeometry: [],
                        scale: Math.pow(2, this.transform.zoom - tile.coord.z)
                    };
                }

                // Wrapped tiles share one tileResult object but can have multiple queryGeometry parts
                tileResult.queryGeometry.push(tileSpaceQueryGeometry);
            }
        }

        var results = [];
        for (var t in tileResults) {
            results.push(tileResults[t]);
        }
        return results;
    }
};

/**
 * Convert a coordinate to a point in a tile's coordinate space.
 * @param {Coordinate} tileCoord
 * @param {Coordinate} coord
 * @returns {Object} position
 * @private
 */
function coordinateToTilePoint(tileCoord, sourceMaxZoom, coord) {
    var zoomedCoord = coord.zoomTo(Math.min(tileCoord.z, sourceMaxZoom));
    return {
        x: (zoomedCoord.column - (tileCoord.x + tileCoord.w * Math.pow(2, tileCoord.z))) * EXTENT,
        y: (zoomedCoord.row - tileCoord.y) * EXTENT
    };

}

function compareKeyZoom(a, b) {
    return (a % 32) - (b % 32);
}

},{"../data/bucket":1,"../geo/coordinate":9,"../util/lru_cache":100,"../util/util":104,"./tile":34,"./tile_coord":35,"point-geometry":162}],37:[function(require,module,exports){
'use strict';

var util = require('../util/util');
var Evented = require('../util/evented');
var Source = require('./source');
var normalizeURL = require('../util/mapbox').normalizeTileURL;

module.exports = VectorTileSource;

function VectorTileSource(options) {
    util.extend(this, util.pick(options, ['url', 'tileSize']));
    this._options = util.extend({ type: 'vector' }, options);

    if (this.tileSize !== 512) {
        throw new Error('vector tile sources must have a tileSize of 512');
    }

    Source._loadTileJSON.call(this, options);
}

VectorTileSource.prototype = util.inherit(Evented, {
    minzoom: 0,
    maxzoom: 22,
    tileSize: 512,
    reparseOverscaled: true,
    _loaded: false,
    isTileClipped: true,

    onAdd: function(map) {
        this.map = map;
    },

    loaded: function() {
        return this._pyramid && this._pyramid.loaded();
    },

    update: function(transform) {
        if (this._pyramid) {
            this._pyramid.update(this.used, transform);
        }
    },

    reload: function() {
        if (this._pyramid) {
            this._pyramid.reload();
        }
    },

    serialize: function() {
        return util.extend({}, this._options);
    },

    getVisibleCoordinates: Source._getVisibleCoordinates,
    getTile: Source._getTile,

    queryRenderedFeatures: Source._queryRenderedVectorFeatures,
    querySourceFeatures: Source._querySourceFeatures,

    _loadTile: function(tile) {
        var overscaling = tile.coord.z > this.maxzoom ? Math.pow(2, tile.coord.z - this.maxzoom) : 1;
        var params = {
            url: normalizeURL(tile.coord.url(this.tiles, this.maxzoom), this.url),
            uid: tile.uid,
            coord: tile.coord,
            zoom: tile.coord.z,
            tileSize: this.tileSize * overscaling,
            source: this.id,
            overscaling: overscaling,
            angle: this.map.transform.angle,
            pitch: this.map.transform.pitch,
            showCollisionBoxes: this.map.showCollisionBoxes
        };

        if (tile.workerID) {
            params.rawTileData = tile.rawTileData;
            this.dispatcher.send('reload tile', params, this._tileLoaded.bind(this, tile), tile.workerID);
        } else {
            tile.workerID = this.dispatcher.send('load tile', params, this._tileLoaded.bind(this, tile));
        }
    },

    _tileLoaded: function(tile, err, data) {
        if (tile.aborted)
            return;

        if (err) {
            tile.errored = true;
            this.fire('tile.error', {tile: tile, error: err});
            return;
        }

        tile.loadVectorData(data);

        if (tile.redoWhenDone) {
            tile.redoWhenDone = false;
            tile.redoPlacement(this);
        }

        this.fire('tile.load', {tile: tile});
        this.fire('tile.stats', data.bucketStats);
    },

    _abortTile: function(tile) {
        tile.aborted = true;
        this.dispatcher.send('abort tile', { uid: tile.uid, source: this.id }, null, tile.workerID);
    },

    _addTile: function(tile) {
        this.fire('tile.add', {tile: tile});
    },

    _removeTile: function(tile) {
        this.fire('tile.remove', {tile: tile});
    },

    _unloadTile: function(tile) {
        tile.unloadVectorData(this.map.painter);
        this.dispatcher.send('remove tile', { uid: tile.uid, source: this.id }, null, tile.workerID);
    },

    redoPlacement: Source.redoPlacement,

    _redoTilePlacement: function(tile) {
        tile.redoPlacement(this);
    }
});

},{"../util/evented":95,"../util/mapbox":101,"../util/util":104,"./source":33}],38:[function(require,module,exports){
'use strict';

var util = require('../util/util');
var Tile = require('./tile');
var TileCoord = require('./tile_coord');
var LngLat = require('../geo/lng_lat');
var Point = require('point-geometry');
var Evented = require('../util/evented');
var ajax = require('../util/ajax');
var EXTENT = require('../data/bucket').EXTENT;

module.exports = VideoSource;

/**
 * Create a Video data source instance given an options object
 * @class VideoSource
 * @param {Object} [options]
 * @param {Array<string>} options.urls An array of URLs to video files
 * @param {Array} options.coordinates Four geographical [lng, lat] coordinates in clockwise order defining the corners (starting with top left) of the video. Does not have to be a rectangle.
 * @example
 * var sourceObj = new mapboxgl.VideoSource({
 *    url: [
 *        'https://www.mapbox.com/videos/baltimore-smoke.mp4',
 *        'https://www.mapbox.com/videos/baltimore-smoke.webm'
 *    ],
 *    coordinates: [
 *        [-76.54335737228394, 39.18579907229748],
 *        [-76.52803659439087, 39.1838364847587],
 *        [-76.5295386314392, 39.17683392507606],
 *        [-76.54520273208618, 39.17876344106642]
 *    ]
 * });
 * map.addSource('some id', sourceObj); // add
 * map.removeSource('some id');  // remove
 */
function VideoSource(options) {
    this.urls = options.urls;
    this.coordinates = options.coordinates;

    ajax.getVideo(options.urls, function(err, video) {
        // @TODO handle errors via event.
        if (err) return;

        this.video = video;
        this.video.loop = true;

        var loopID;

        // start repainting when video starts playing
        this.video.addEventListener('playing', function() {
            loopID = this.map.style.animationLoop.set(Infinity);
            this.map._rerender();
        }.bind(this));

        // stop repainting when video stops
        this.video.addEventListener('pause', function() {
            this.map.style.animationLoop.cancel(loopID);
        }.bind(this));

        this._loaded = true;

        if (this.map) {
            this.video.play();
            this.setCoordinates(options.coordinates);
        }
    }.bind(this));
}

VideoSource.prototype = util.inherit(Evented, /** @lends VideoSource.prototype */{
    roundZoom: true,

    /**
     * Return the HTML video element.
     *
     * @returns {Object}
     */
    getVideo: function() {
        return this.video;
    },

    onAdd: function(map) {
        this.map = map;
        if (this.video) {
            this.video.play();
            this.setCoordinates(this.coordinates);
        }
    },

    /**
     * Update video coordinates and rerender map
     *
     * @param {Array} coordinates Four geographical [lng, lat] coordinates in clockwise order defining the corners (starting with top left) of the video. Does not have to be a rectangle.
     * @returns {VideoSource} this
     */
    setCoordinates: function(coordinates) {
        this.coordinates = coordinates;

        // Calculate which mercator tile is suitable for rendering the video in
        // and create a buffer with the corner coordinates. These coordinates
        // may be outside the tile, because raster tiles aren't clipped when rendering.

        var map = this.map;
        var cornerZ0Coords = coordinates.map(function(coord) {
            return map.transform.locationCoordinate(LngLat.convert(coord)).zoomTo(0);
        });

        var centerCoord = this.centerCoord = util.getCoordinatesCenter(cornerZ0Coords);
        centerCoord.column = Math.round(centerCoord.column);
        centerCoord.row = Math.round(centerCoord.row);


        var tileCoords = cornerZ0Coords.map(function(coord) {
            var zoomedCoord = coord.zoomTo(centerCoord.zoom);
            return new Point(
                Math.round((zoomedCoord.column - centerCoord.column) * EXTENT),
                Math.round((zoomedCoord.row - centerCoord.row) * EXTENT));
        });

        var gl = map.painter.gl;
        var maxInt16 = 32767;
        var array = new Int16Array([
            tileCoords[0].x, tileCoords[0].y, 0, 0,
            tileCoords[1].x, tileCoords[1].y, maxInt16, 0,
            tileCoords[3].x, tileCoords[3].y, 0, maxInt16,
            tileCoords[2].x, tileCoords[2].y, maxInt16, maxInt16
        ]);

        this.tile = new Tile(new TileCoord(centerCoord.zoom, centerCoord.column, centerCoord.row));
        this.tile.buckets = {};

        this.tile.boundsBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, this.tile.boundsBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, array, gl.STATIC_DRAW);

        this.fire('change');

        return this;
    },

    loaded: function() {
        return this.video && this.video.readyState >= 2;
    },

    update: function() {
        // noop
    },

    reload: function() {
        // noop
    },

    prepare: function() {
        if (!this._loaded) return;
        if (this.video.readyState < 2) return; // not enough data for current position

        var gl = this.map.painter.gl;
        if (!this.tile.texture) {
            this.tile.texture = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, this.tile.texture);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, this.video);
        } else {
            gl.bindTexture(gl.TEXTURE_2D, this.tile.texture);
            gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, gl.RGBA, gl.UNSIGNED_BYTE, this.video);
        }

        this._currentTime = this.video.currentTime;
    },

    getVisibleCoordinates: function() {
        if (this.tile) return [this.tile.coord];
        else return [];
    },

    getTile: function() {
        return this.tile;
    },

    serialize: function() {
        return {
            type: 'video',
            urls: this.urls,
            coordinates: this.coordinates
        };
    }
});

},{"../data/bucket":1,"../geo/lng_lat":10,"../util/ajax":88,"../util/evented":95,"../util/util":104,"./tile":34,"./tile_coord":35,"point-geometry":162}],39:[function(require,module,exports){
'use strict';

var Actor = require('../util/actor');
var WorkerTile = require('./worker_tile');
var util = require('../util/util');
var ajax = require('../util/ajax');
var vt = require('vector-tile');
var Protobuf = require('pbf');
var supercluster = require('supercluster');

var geojsonvt = require('geojson-vt');
var rewind = require('geojson-rewind');
var GeoJSONWrapper = require('./geojson_wrapper');
var vtpbf = require('vt-pbf');

module.exports = function(self) {
    return new Worker(self);
};

function Worker(self) {
    this.self = self;
    this.actor = new Actor(self, this);
    this.loading = {};

    this.loaded = {};
    this.layers = [];
    this.geoJSONIndexes = {};
}

util.extend(Worker.prototype, {
    'set layers': function(layers) {
        this.layers = layers;
    },

    'update layers': function(layers) {
        var layersById = {};
        var i;
        for (i = 0; i < layers.length; i++) {
            layersById[layers[i].id] = layers[i];
        }
        for (i = 0; i < this.layers.length; i++) {
            this.layers[i] = layersById[this.layers[i].id] || this.layers[i];
        }
    },

    'load tile': function(params, callback) {
        var source = params.source,
            uid = params.uid;

        if (!this.loading[source])
            this.loading[source] = {};


        var tile = this.loading[source][uid] = new WorkerTile(params);

        tile.xhr = ajax.getArrayBuffer(params.url, done.bind(this));

        function done(err, data) {
            delete this.loading[source][uid];

            if (err) return callback(err);

            tile.data = new vt.VectorTile(new Protobuf(new Uint8Array(data)));
            tile.parse(tile.data, this.layers, this.actor, data, callback);

            this.loaded[source] = this.loaded[source] || {};
            this.loaded[source][uid] = tile;
        }
    },

    'reload tile': function(params, callback) {
        var loaded = this.loaded[params.source],
            uid = params.uid;
        if (loaded && loaded[uid]) {
            var tile = loaded[uid];
            tile.parse(tile.data, this.layers, this.actor, params.rawTileData, callback);
        }
    },

    'abort tile': function(params) {
        var loading = this.loading[params.source],
            uid = params.uid;
        if (loading && loading[uid]) {
            loading[uid].xhr.abort();
            delete loading[uid];
        }
    },

    'remove tile': function(params) {
        var loaded = this.loaded[params.source],
            uid = params.uid;
        if (loaded && loaded[uid]) {
            delete loaded[uid];
        }
    },

    'redo placement': function(params, callback) {
        var loaded = this.loaded[params.source],
            loading = this.loading[params.source],
            uid = params.uid;

        if (loaded && loaded[uid]) {
            var tile = loaded[uid];
            var result = tile.redoPlacement(params.angle, params.pitch, params.showCollisionBoxes);

            if (result.result) {
                callback(null, result.result, result.transferables);
            }

        } else if (loading && loading[uid]) {
            loading[uid].angle = params.angle;
        }
    },

    'parse geojson': function(params, callback) {
        var indexData = function(err, data) {
            rewind(data, true);
            if (err) return callback(err);
            if (typeof data != 'object') {
                return callback(new Error("Input data is not a valid GeoJSON object."));
            }
            try {
                this.geoJSONIndexes[params.source] = params.cluster ?
                    supercluster(params.superclusterOptions).load(data.features) :
                    geojsonvt(data, params.geojsonVtOptions);
            } catch (err) {
                return callback(err);
            }
            callback(null);
        }.bind(this);

        // Not, because of same origin issues, urls must either include an
        // explicit origin or absolute path.
        // ie: /foo/bar.json or http://example.com/bar.json
        // but not ../foo/bar.json
        if (params.url) {
            ajax.getJSON(params.url, indexData);
        } else if (typeof params.data === 'string') {
            indexData(null, JSON.parse(params.data));
        } else {
            return callback(new Error("Input data is not a valid GeoJSON object."));
        }
    },

    'load geojson tile': function(params, callback) {
        var source = params.source,
            coord = params.coord;

        if (!this.geoJSONIndexes[source]) return callback(null, null); // we couldn't load the file

        // console.time('tile ' + coord.z + ' ' + coord.x + ' ' + coord.y);

        var geoJSONTile = this.geoJSONIndexes[source].getTile(Math.min(coord.z, params.maxZoom), coord.x, coord.y);

        // console.timeEnd('tile ' + coord.z + ' ' + coord.x + ' ' + coord.y);

        // if (!geoJSONTile) console.log('not found', this.geoJSONIndexes[source], coord);

        var tile = geoJSONTile ? new WorkerTile(params) : undefined;

        this.loaded[source] = this.loaded[source] || {};
        this.loaded[source][params.uid] = tile;

        if (geoJSONTile) {
            var geojsonWrapper = new GeoJSONWrapper(geoJSONTile.features);
            geojsonWrapper.name = '_geojsonTileLayer';
            var rawTileData = vtpbf({ layers: { '_geojsonTileLayer': geojsonWrapper }}).buffer;
            tile.parse(geojsonWrapper, this.layers, this.actor, rawTileData, callback);
        } else {
            return callback(null, null); // nothing in the given tile
        }
    }
});

},{"../util/actor":87,"../util/ajax":88,"../util/util":104,"./geojson_wrapper":29,"./worker_tile":40,"geojson-rewind":114,"geojson-vt":119,"pbf":160,"supercluster":166,"vector-tile":168,"vt-pbf":172}],40:[function(require,module,exports){
'use strict';

var FeatureIndex = require('../data/feature_index');
var CollisionTile = require('../symbol/collision_tile');
var Bucket = require('../data/bucket');
var CollisionBoxArray = require('../symbol/collision_box');
var DictionaryCoder = require('../util/dictionary_coder');

module.exports = WorkerTile;

function WorkerTile(params) {
    this.coord = params.coord;
    this.uid = params.uid;
    this.zoom = params.zoom;
    this.tileSize = params.tileSize;
    this.source = params.source;
    this.overscaling = params.overscaling;
    this.angle = params.angle;
    this.pitch = params.pitch;
    this.showCollisionBoxes = params.showCollisionBoxes;
}

WorkerTile.prototype.parse = function(data, layers, actor, rawTileData, callback) {

    this.status = 'parsing';
    this.data = data;

    this.collisionBoxArray = new CollisionBoxArray();
    var collisionTile = new CollisionTile(this.angle, this.pitch, this.collisionBoxArray);
    var featureIndex = new FeatureIndex(this.coord, this.overscaling, collisionTile, data.layers);
    var sourceLayerCoder = new DictionaryCoder(data.layers ? Object.keys(data.layers).sort() : ['_geojsonTileLayer']);

    var stats = { _total: 0 };

    var tile = this;
    var bucketsById = {};
    var bucketsBySourceLayer = {};
    var i;
    var layer;
    var sourceLayerId;
    var bucket;

    // Map non-ref layers to buckets.
    for (i = 0; i < layers.length; i++) {
        layer = layers[i];

        if (layer.source !== this.source) continue;
        if (layer.ref) continue;
        if (layer.minzoom && this.zoom < layer.minzoom) continue;
        if (layer.maxzoom && this.zoom >= layer.maxzoom) continue;
        if (layer.layout && layer.layout.visibility === 'none') continue;

        bucket = Bucket.create({
            layer: layer,
            index: i,
            zoom: this.zoom,
            overscaling: this.overscaling,
            showCollisionBoxes: this.showCollisionBoxes,
            collisionBoxArray: this.collisionBoxArray,
            sourceLayerIndex: sourceLayerCoder.encode(layer['source-layer'] || '_geojsonTileLayer')
        });
        bucket.createFilter();

        bucketsById[layer.id] = bucket;

        if (data.layers) { // vectortile
            sourceLayerId = layer['source-layer'];
            bucketsBySourceLayer[sourceLayerId] = bucketsBySourceLayer[sourceLayerId] || {};
            bucketsBySourceLayer[sourceLayerId][layer.id] = bucket;
        }
    }

    // Index ref layers.
    for (i = 0; i < layers.length; i++) {
        layer = layers[i];
        if (layer.source === this.source && layer.ref && bucketsById[layer.ref]) {
            bucketsById[layer.ref].layerIDs.push(layer.id);
        }
    }

    // read each layer, and sort its features into buckets
    if (data.layers) { // vectortile
        for (sourceLayerId in bucketsBySourceLayer) {
            layer = data.layers[sourceLayerId];
            if (layer) {
                sortLayerIntoBuckets(layer, bucketsBySourceLayer[sourceLayerId]);
            }
        }
    } else { // geojson
        sortLayerIntoBuckets(data, bucketsById);
    }

    function sortLayerIntoBuckets(layer, buckets) {
        for (var i = 0; i < layer.length; i++) {
            var feature = layer.feature(i);
            feature.index = i;
            for (var id in buckets) {
                if (buckets[id].filter(feature))
                    buckets[id].features.push(feature);
            }
        }
    }

    var buckets = [],
        symbolBuckets = this.symbolBuckets = [],
        otherBuckets = [];

    featureIndex.bucketLayerIDs = {};

    for (var id in bucketsById) {
        bucket = bucketsById[id];
        if (bucket.features.length === 0) continue;

        featureIndex.bucketLayerIDs[bucket.index] = bucket.layerIDs;

        buckets.push(bucket);

        if (bucket.type === 'symbol')
            symbolBuckets.push(bucket);
        else
            otherBuckets.push(bucket);
    }

    var icons = {};
    var stacks = {};
    var deps = 0;


    if (symbolBuckets.length > 0) {

        // Get dependencies for symbol buckets
        for (i = symbolBuckets.length - 1; i >= 0; i--) {
            symbolBuckets[i].updateIcons(icons);
            symbolBuckets[i].updateFont(stacks);
        }

        for (var fontName in stacks) {
            stacks[fontName] = Object.keys(stacks[fontName]).map(Number);
        }
        icons = Object.keys(icons);

        actor.send('get glyphs', {uid: this.uid, stacks: stacks}, function(err, newStacks) {
            stacks = newStacks;
            gotDependency(err);
        });

        if (icons.length) {
            actor.send('get icons', {icons: icons}, function(err, newIcons) {
                icons = newIcons;
                gotDependency(err);
            });
        } else {
            gotDependency();
        }
    }

    // immediately parse non-symbol buckets (they have no dependencies)
    for (i = otherBuckets.length - 1; i >= 0; i--) {
        parseBucket(this, otherBuckets[i]);
    }

    if (symbolBuckets.length === 0)
        return done();

    function gotDependency(err) {
        if (err) return callback(err);
        deps++;
        if (deps === 2) {
            // all symbol bucket dependencies fetched; parse them in proper order
            for (var i = symbolBuckets.length - 1; i >= 0; i--) {
                parseBucket(tile, symbolBuckets[i]);
            }
            done();
        }
    }

    function parseBucket(tile, bucket) {
        var now = Date.now();
        bucket.populateBuffers(collisionTile, stacks, icons);
        var time = Date.now() - now;


        if (bucket.type !== 'symbol') {
            for (var i = 0; i < bucket.features.length; i++) {
                var feature = bucket.features[i];
                featureIndex.insert(feature, feature.index, bucket.sourceLayerIndex, bucket.index);
            }
        }

        bucket.features = null;

        stats._total += time;
        stats[bucket.id] = (stats[bucket.id] || 0) + time;
    }

    function done() {
        tile.status = 'done';

        if (tile.redoPlacementAfterDone) {
            tile.redoPlacement(tile.angle, tile.pitch, null);
            tile.redoPlacementAfterDone = false;
        }

        var featureIndex_ = featureIndex.serialize();
        var collisionTile_ = collisionTile.serialize();
        var collisionBoxArray = tile.collisionBoxArray.serialize();
        var transferables = [rawTileData].concat(featureIndex_.transferables).concat(collisionTile_.transferables);

        var nonEmptyBuckets = buckets.filter(isBucketEmpty);

        callback(null, {
            buckets: nonEmptyBuckets.map(serializeBucket),
            bucketStats: stats, // TODO put this in a separate message?
            featureIndex: featureIndex_.data,
            collisionTile: collisionTile_.data,
            collisionBoxArray: collisionBoxArray,
            rawTileData: rawTileData
        }, getTransferables(nonEmptyBuckets).concat(transferables));
    }
};

WorkerTile.prototype.redoPlacement = function(angle, pitch, showCollisionBoxes) {
    if (this.status !== 'done') {
        this.redoPlacementAfterDone = true;
        this.angle = angle;
        return {};
    }

    var collisionTile = new CollisionTile(angle, pitch, this.collisionBoxArray);

    var buckets = this.symbolBuckets;

    for (var i = buckets.length - 1; i >= 0; i--) {
        buckets[i].placeFeatures(collisionTile, showCollisionBoxes);
    }

    var collisionTile_ = collisionTile.serialize();

    var nonEmptyBuckets = buckets.filter(isBucketEmpty);

    return {
        result: {
            buckets: nonEmptyBuckets.map(serializeBucket),
            collisionTile: collisionTile_.data
        },
        transferables: getTransferables(nonEmptyBuckets).concat(collisionTile_.transferables)
    };
};

function isBucketEmpty(bucket) {
    for (var bufferName in bucket.arrays) {
        if (bucket.arrays[bufferName].length > 0) return true;
    }
    return false;
}

function serializeBucket(bucket) {
    return bucket.serialize();
}

function getTransferables(buckets) {
    var transferables = [];
    for (var i in buckets) {
        var bucket = buckets[i];
        for (var j in bucket.arrays) {
            transferables.push(bucket.arrays[j].arrayBuffer);
        }
    }
    return transferables;
}

},{"../data/bucket":1,"../data/feature_index":7,"../symbol/collision_box":60,"../symbol/collision_tile":62,"../util/dictionary_coder":94}],41:[function(require,module,exports){
'use strict';

module.exports = AnimationLoop;

function AnimationLoop() {
    this.n = 0;
    this.times = [];
}

// Are all animations done?
AnimationLoop.prototype.stopped = function() {
    this.times = this.times.filter(function(t) {
        return t.time >= (new Date()).getTime();
    });
    return !this.times.length;
};

// Add a new animation that will run t milliseconds
// Returns an id that can be used to cancel it layer
AnimationLoop.prototype.set = function(t) {
    this.times.push({ id: this.n, time: t + (new Date()).getTime() });
    return this.n++;
};

// Cancel an animation
AnimationLoop.prototype.cancel = function(n) {
    this.times = this.times.filter(function(t) {
        return t.id !== n;
    });
};

},{}],42:[function(require,module,exports){
'use strict';

var Evented = require('../util/evented');
var ajax = require('../util/ajax');
var browser = require('../util/browser');
var normalizeURL = require('../util/mapbox').normalizeSpriteURL;

module.exports = ImageSprite;

function ImageSprite(base) {
    this.base = base;
    this.retina = browser.devicePixelRatio > 1;

    var format = this.retina ? '@2x' : '';

    ajax.getJSON(normalizeURL(base, format, '.json'), function(err, data) {
        if (err) {
            this.fire('error', {error: err});
            return;
        }

        this.data = data;
        if (this.img) this.fire('load');
    }.bind(this));

    ajax.getImage(normalizeURL(base, format, '.png'), function(err, img) {
        if (err) {
            this.fire('error', {error: err});
            return;
        }

        // premultiply the sprite
        var data = img.getData();
        var newdata = img.data = new Uint8Array(data.length);
        for (var i = 0; i < data.length; i += 4) {
            var alpha = data[i + 3] / 255;
            newdata[i + 0] = data[i + 0] * alpha;
            newdata[i + 1] = data[i + 1] * alpha;
            newdata[i + 2] = data[i + 2] * alpha;
            newdata[i + 3] = data[i + 3];
        }

        this.img = img;
        if (this.data) this.fire('load');
    }.bind(this));
}

ImageSprite.prototype = Object.create(Evented);

ImageSprite.prototype.toJSON = function() {
    return this.base;
};

ImageSprite.prototype.loaded = function() {
    return !!(this.data && this.img);
};

ImageSprite.prototype.resize = function(/*gl*/) {
    if (browser.devicePixelRatio > 1 !== this.retina) {
        var newSprite = new ImageSprite(this.base);
        newSprite.on('load', function() {
            this.img = newSprite.img;
            this.data = newSprite.data;
            this.retina = newSprite.retina;
        }.bind(this));
    }
};

function SpritePosition() {}
SpritePosition.prototype = { x: 0, y: 0, width: 0, height: 0, pixelRatio: 1, sdf: false };

ImageSprite.prototype.getSpritePosition = function(name) {
    if (!this.loaded()) return new SpritePosition();

    var pos = this.data && this.data[name];
    if (pos && this.img) return pos;

    return new SpritePosition();
};

},{"../util/ajax":88,"../util/browser":89,"../util/evented":95,"../util/mapbox":101}],43:[function(require,module,exports){
'use strict';

var parseCSSColor = require('csscolorparser').parseCSSColor;
var util = require('../util/util');

var colorCache = {};

function parseColor(input) {

    if (colorCache[input]) {
        return colorCache[input];

    // RGBA array
    } else if (Array.isArray(input)) {
        return input;

    // GL function
    } else if (input && input.stops) {
        return util.extend({}, input, {
            stops: input.stops.map(parseFunctionStopColor)
        });

    // Color string
    } else if (typeof input === 'string') {
        var parsedColor = parseCSSColor(input);
        if (!parsedColor) { throw new Error('Invalid color ' + input); }

        var output = colorDowngrade(parsedColor);
        colorCache[input] = output;
        return output;

    } else {
        throw new Error('Invalid color ' + input);
    }

}

function parseFunctionStopColor(stop) {
    return [stop[0], parseColor(stop[1])];
}

function colorDowngrade(color) {
    return [color[0] / 255, color[1] / 255, color[2] / 255, color[3] / 1];
}

module.exports = parseColor;

},{"../util/util":104,"csscolorparser":112}],44:[function(require,module,exports){
'use strict';

var Evented = require('../util/evented');
var styleBatch = require('./style_batch');
var StyleLayer = require('./style_layer');
var ImageSprite = require('./image_sprite');
var GlyphSource = require('../symbol/glyph_source');
var SpriteAtlas = require('../symbol/sprite_atlas');
var LineAtlas = require('../render/line_atlas');
var util = require('../util/util');
var ajax = require('../util/ajax');
var normalizeURL = require('../util/mapbox').normalizeStyleURL;
var browser = require('../util/browser');
var Dispatcher = require('../util/dispatcher');
var AnimationLoop = require('./animation_loop');
var validateStyle = require('./validate_style');

module.exports = Style;

function Style(stylesheet, animationLoop) {
    this.animationLoop = animationLoop || new AnimationLoop();
    this.dispatcher = new Dispatcher(Math.max(1), this);
    this.spriteAtlas = new SpriteAtlas(512, 512);
    this.lineAtlas = new LineAtlas(256, 512);

    this._layers = {};
    this._order  = [];
    this._groups = [];
    this.sources = {};

    this.zoomHistory = {};

    util.bindAll([
        '_forwardSourceEvent',
        '_forwardTileEvent',
        '_forwardLayerEvent',
        '_redoPlacement'
    ], this);

    var loaded = function(err, stylesheet) {
        if (err) {
            this.fire('error', {error: err});
            return;
        }

        if (validateStyle.emitErrors(this, validateStyle(stylesheet))) return;

        this._loaded = true;
        this.stylesheet = stylesheet;

        var sources = stylesheet.sources;
        for (var id in sources) {
            this.addSource(id, sources[id]);
        }

        if (stylesheet.sprite) {
            this.sprite = new ImageSprite(stylesheet.sprite);
            this.sprite.on('load', this.fire.bind(this, 'change'));
        }

        this.glyphSource = new GlyphSource(stylesheet.glyphs);
        this._resolve();
        this.fire('load');
    }.bind(this);

    if (typeof stylesheet === 'string') {
        ajax.getJSON(normalizeURL(stylesheet), loaded);
    } else {
        browser.frame(loaded.bind(this, null, stylesheet));
    }

    this.on('source.load', function(event) {
        var source = event.source;
        if (source && source.vectorLayerIds) {
            for (var layerId in this._layers) {
                var layer = this._layers[layerId];
                if (layer.source === source.id) {
                    this._validateLayer(layer);
                }
            }
        }
    });
}

Style.prototype = util.inherit(Evented, {
    _loaded: false,

    _validateLayer: function(layer) {
        var source = this.sources[layer.source];

        if (!layer.sourceLayer) return;
        if (!source) return;
        if (!source.vectorLayerIds) return;

        if (source.vectorLayerIds.indexOf(layer.sourceLayer) === -1) {
            this.fire('error', {
                error: new Error(
                    'Source layer "' + layer.sourceLayer + '" ' +
                    'does not exist on source "' + source.id + '" ' +
                    'as specified by style layer "' + layer.id + '"'
                )
            });
        }
    },

    loaded: function() {
        if (!this._loaded)
            return false;

        for (var id in this.sources)
            if (!this.sources[id].loaded())
                return false;

        if (this.sprite && !this.sprite.loaded())
            return false;

        return true;
    },

    _resolve: function() {
        var layer, layerJSON;

        this._layers = {};
        this._order  = this.stylesheet.layers.map(function(layer) {
            return layer.id;
        });

        // resolve all layers WITHOUT a ref
        for (var i = 0; i < this.stylesheet.layers.length; i++) {
            layerJSON = this.stylesheet.layers[i];
            if (layerJSON.ref) continue;
            layer = StyleLayer.create(layerJSON);
            this._layers[layer.id] = layer;
            layer.on('error', this._forwardLayerEvent);
        }

        // resolve all layers WITH a ref
        for (var j = 0; j < this.stylesheet.layers.length; j++) {
            layerJSON = this.stylesheet.layers[j];
            if (!layerJSON.ref) continue;
            var refLayer = this.getLayer(layerJSON.ref);
            layer = StyleLayer.create(layerJSON, refLayer);
            this._layers[layer.id] = layer;
            layer.on('error', this._forwardLayerEvent);
        }

        this._groupLayers();
        this._broadcastLayers();
    },

    _groupLayers: function() {
        var group;

        this._groups = [];

        // Split into groups of consecutive top-level layers with the same source.
        for (var i = 0; i < this._order.length; ++i) {
            var layer = this._layers[this._order[i]];

            if (!group || layer.source !== group.source) {
                group = [];
                group.source = layer.source;
                this._groups.push(group);
            }

            group.push(layer);
        }
    },

    _broadcastLayers: function(ids) {
        this.dispatcher.broadcast(ids ? 'update layers' : 'set layers', this._serializeLayers(ids));
    },

    _serializeLayers: function(ids) {
        ids = ids || this._order;
        var serialized = [];
        var options = {includeRefProperties: true};
        for (var i = 0; i < ids.length; i++) {
            serialized.push(this._layers[ids[i]].serialize(options));
        }
        return serialized;
    },

    _cascade: function(classes, options) {
        if (!this._loaded) return;

        options = options || {
            transition: true
        };

        for (var id in this._layers) {
            this._layers[id].cascade(classes, options,
                this.stylesheet.transition || {},
                this.animationLoop);
        }

        this.fire('change');
    },

    _recalculate: function(z) {
        for (var sourceId in this.sources)
            this.sources[sourceId].used = false;

        this._updateZoomHistory(z);

        this.rasterFadeDuration = 300;
        for (var layerId in this._layers) {
            var layer = this._layers[layerId];

            layer.recalculate(z, this.zoomHistory);
            if (!layer.isHidden(z) && layer.source) {
                this.sources[layer.source].used = true;
            }
        }

        var maxZoomTransitionDuration = 300;
        if (Math.floor(this.z) !== Math.floor(z)) {
            this.animationLoop.set(maxZoomTransitionDuration);
        }

        this.z = z;
        this.fire('zoom');
    },

    _updateZoomHistory: function(z) {

        var zh = this.zoomHistory;

        if (zh.lastIntegerZoom === undefined) {
            // first time
            zh.lastIntegerZoom = Math.floor(z);
            zh.lastIntegerZoomTime = 0;
            zh.lastZoom = z;
        }

        // check whether an integer zoom level as passed since the last frame
        // and if yes, record it with the time. Used for transitioning patterns.
        if (Math.floor(zh.lastZoom) < Math.floor(z)) {
            zh.lastIntegerZoom = Math.floor(z);
            zh.lastIntegerZoomTime = Date.now();

        } else if (Math.floor(zh.lastZoom) > Math.floor(z)) {
            zh.lastIntegerZoom = Math.floor(z + 1);
            zh.lastIntegerZoomTime = Date.now();
        }

        zh.lastZoom = z;
    },

    /**
     * Apply multiple style mutations in a batch
     * @param {function} work Function which accepts the StyleBatch interface
     * @private
     */
    batch: function(work) {
        styleBatch(this, work);
    },

    addSource: function(id, source) {
        this.batch(function(batch) {
            batch.addSource(id, source);
        });

        return this;
    },

    /**
     * Remove a source from this stylesheet, given its id.
     * @param {string} id id of the source to remove
     * @returns {Style} this style
     * @throws {Error} if no source is found with the given ID
     * @private
     */
    removeSource: function(id) {
        this.batch(function(batch) {
            batch.removeSource(id);
        });

        return this;
    },

    /**
     * Get a source by id.
     * @param {string} id id of the desired source
     * @returns {Object} source
     * @private
     */
    getSource: function(id) {
        return this.sources[id];
    },

    /**
     * Add a layer to the map style. The layer will be inserted before the layer with
     * ID `before`, or appended if `before` is omitted.
     * @param {StyleLayer|Object} layer
     * @param {string=} before  ID of an existing layer to insert before
     * @fires layer.add
     * @returns {Style} `this`
     * @private
     */
    addLayer: function(layer, before) {
        this.batch(function(batch) {
            batch.addLayer(layer, before);
        });

        return this;
    },

    /**
     * Remove a layer from this stylesheet, given its id.
     * @param {string} id id of the layer to remove
     * @returns {Style} this style
     * @throws {Error} if no layer is found with the given ID
     * @private
     */
    removeLayer: function(id) {
        this.batch(function(batch) {
            batch.removeLayer(id);
        });

        return this;
    },

    /**
     * Return the style layer object with the given `id`.
     *
     * @param {string} id - id of the desired layer
     * @returns {?Object} a layer, if one with the given `id` exists
     * @private
     */
    getLayer: function(id) {
        return this._layers[id];
    },

    /**
     * If a layer has a `ref` property that makes it derive some values
     * from another layer, return that referent layer. Otherwise,
     * returns the layer itself.
     * @param {string} id the layer's id
     * @returns {Layer} the referent layer or the layer itself
     * @private
     */
    getReferentLayer: function(id) {
        var layer = this.getLayer(id);
        if (layer.ref) {
            layer = this.getLayer(layer.ref);
        }
        return layer;
    },

    setFilter: function(layer, filter) {
        this.batch(function(batch) {
            batch.setFilter(layer, filter);
        });

        return this;
    },

    setLayerZoomRange: function(layerId, minzoom, maxzoom) {
        this.batch(function(batch) {
            batch.setLayerZoomRange(layerId, minzoom, maxzoom);
        });

        return this;
    },

    /**
     * Get a layer's filter object
     * @param {string} layer the layer to inspect
     * @returns {*} the layer's filter, if any
     * @private
     */
    getFilter: function(layer) {
        return this.getReferentLayer(layer).filter;
    },

    /**
     * Get a layout property's value from a given layer
     * @param {string} layer the layer to inspect
     * @param {string} name the name of the layout property
     * @returns {*} the property value
     * @private
     */
    getLayoutProperty: function(layer, name) {
        return this.getReferentLayer(layer).getLayoutProperty(name);
    },

    getPaintProperty: function(layer, name, klass) {
        return this.getLayer(layer).getPaintProperty(name, klass);
    },

    serialize: function() {
        return util.filterObject({
            version: this.stylesheet.version,
            name: this.stylesheet.name,
            metadata: this.stylesheet.metadata,
            center: this.stylesheet.center,
            zoom: this.stylesheet.zoom,
            bearing: this.stylesheet.bearing,
            pitch: this.stylesheet.pitch,
            sprite: this.stylesheet.sprite,
            glyphs: this.stylesheet.glyphs,
            transition: this.stylesheet.transition,
            sources: util.mapObject(this.sources, function(source) {
                return source.serialize();
            }),
            layers: this._order.map(function(id) {
                return this._layers[id].serialize();
            }, this)
        }, function(value) { return value !== undefined; });
    },

    _flattenRenderedFeatures: function(sourceResults) {
        var features = [];
        for (var l = this._order.length - 1; l >= 0; l--) {
            var layerID = this._order[l];
            for (var s = 0; s < sourceResults.length; s++) {
                var layerFeatures = sourceResults[s][layerID];
                if (layerFeatures) {
                    for (var f = 0; f < layerFeatures.length; f++) {
                        features.push(layerFeatures[f]);
                    }
                }
            }
        }
        return features;
    },

    queryRenderedFeatures: function(queryGeometry, params, classes, zoom, bearing) {
        var sourceResults = [];
        for (var id in this.sources) {
            var source = this.sources[id];
            if (source.queryRenderedFeatures) {
                sourceResults.push(source.queryRenderedFeatures(queryGeometry, params, classes, zoom, bearing));
            }
        }
        return this._flattenRenderedFeatures(sourceResults);
    },

    _remove: function() {
        this.dispatcher.remove();
    },

    _reloadSource: function(id) {
        this.sources[id].reload();
    },

    _updateSources: function(transform) {
        for (var id in this.sources) {
            this.sources[id].update(transform);
        }
    },

    _redoPlacement: function() {
        for (var id in this.sources) {
            if (this.sources[id].redoPlacement) this.sources[id].redoPlacement();
        }
    },

    _forwardSourceEvent: function(e) {
        this.fire('source.' + e.type, util.extend({source: e.target}, e));
    },

    _forwardTileEvent: function(e) {
        this.fire(e.type, util.extend({source: e.target}, e));
    },

    _forwardLayerEvent: function(e) {
        this.fire('layer.' + e.type, util.extend({layer: {id: e.target.id}}, e));
    },

    // Callbacks from web workers

    'get sprite json': function(params, callback) {
        var sprite = this.sprite;
        if (sprite.loaded()) {
            callback(null, { sprite: sprite.data, retina: sprite.retina });
        } else {
            sprite.on('load', function() {
                callback(null, { sprite: sprite.data, retina: sprite.retina });
            });
        }
    },

    'get icons': function(params, callback) {
        var sprite = this.sprite;
        var spriteAtlas = this.spriteAtlas;
        if (sprite.loaded()) {
            spriteAtlas.setSprite(sprite);
            spriteAtlas.addIcons(params.icons, callback);
        } else {
            sprite.on('load', function() {
                spriteAtlas.setSprite(sprite);
                spriteAtlas.addIcons(params.icons, callback);
            });
        }
    },

    'get glyphs': function(params, callback) {
        var stacks = params.stacks,
            remaining = Object.keys(stacks).length,
            allGlyphs = {};

        for (var fontName in stacks) {
            this.glyphSource.getSimpleGlyphs(fontName, stacks[fontName], params.uid, done);
        }

        function done(err, glyphs, fontName) {
            if (err) console.error(err);

            allGlyphs[fontName] = glyphs;
            remaining--;

            if (remaining === 0)
                callback(null, allGlyphs);
        }
    }
});

},{"../render/line_atlas":25,"../symbol/glyph_source":65,"../symbol/sprite_atlas":70,"../util/ajax":88,"../util/browser":89,"../util/dispatcher":91,"../util/evented":95,"../util/mapbox":101,"../util/util":104,"./animation_loop":41,"./image_sprite":42,"./style_batch":45,"./style_layer":47,"./validate_style":56}],45:[function(require,module,exports){
'use strict';

var Source = require('../source/source');
var StyleLayer = require('./style_layer');
var validateStyle = require('./validate_style');
var styleSpec = require('./style_spec');
var util = require('../util/util');

function styleBatch(style, work) {
    if (!style._loaded) {
        throw new Error('Style is not done loading');
    }

    var batch = Object.create(styleBatch.prototype);

    batch._style = style;
    batch._groupLayers = false;
    batch._updateAllLayers = false;
    batch._updatedLayers = {};
    batch._updatedSources = {};
    batch._events = [];
    batch._change = false;

    work(batch);

    if (batch._groupLayers) {
        batch._style._groupLayers();
    }

    if (batch._updateAllLayers) {
        batch._style._broadcastLayers();

    } else {
        var updatedIds = Object.keys(batch._updatedLayers);
        if (updatedIds.length) {
            batch._style._broadcastLayers(updatedIds);
        }
    }

    Object.keys(batch._updatedSources).forEach(function(sourceId) {
        batch._style._reloadSource(sourceId);
    });

    batch._events.forEach(function(args) {
        batch._style.fire.apply(batch._style, args);
    });

    if (batch._change) {
        batch._style.fire('change');
    }
}

styleBatch.prototype = {

    addLayer: function(layer, before) {
        if (!(layer instanceof StyleLayer)) {
            if (validateStyle.emitErrors(this._style, validateStyle.layer({
                key: 'layers.' + layer.id,
                value: layer,
                style: this._style.serialize(),
                styleSpec: styleSpec,
                // this layer is not in the style.layers array, so we pass an
                // impossible array index
                arrayIndex: -1
            }))) return this;

            var refLayer = layer.ref && this._style.getLayer(layer.ref);
            layer = StyleLayer.create(layer, refLayer);
        }
        this._style._validateLayer(layer);

        layer.on('error', this._style._forwardLayerEvent);

        this._style._layers[layer.id] = layer;
        this._style._order.splice(before ? this._style._order.indexOf(before) : Infinity, 0, layer.id);

        this._groupLayers = true;
        this._updateAllLayers = true;
        if (layer.source) {
            this._updatedSources[layer.source] = true;
        }
        this._events.push(['layer.add', {layer: layer}]);
        this._change = true;

        return this;
    },

    removeLayer: function(id) {
        var layer = this._style._layers[id];
        if (layer === undefined) {
            throw new Error('There is no layer with this ID');
        }
        for (var i in this._style._layers) {
            if (this._style._layers[i].ref === id) {
                this.removeLayer(i);
            }
        }

        layer.off('error', this._style._forwardLayerEvent);

        delete this._style._layers[id];
        this._style._order.splice(this._style._order.indexOf(id), 1);

        this._groupLayers = true;
        this._updateAllLayers = true;
        this._events.push(['layer.remove', {layer: layer}]);
        this._change = true;

        return this;
    },

    setPaintProperty: function(layerId, name, value, klass) {
        this._style.getLayer(layerId).setPaintProperty(name, value, klass);
        this._change = true;

        return this;
    },

    setLayoutProperty: function(layerId, name, value) {
        var layer = this._style.getReferentLayer(layerId);
        layerId = layer.id;

        if (layer.getLayoutProperty(name) === value) return this;

        layer.setLayoutProperty(name, value);

        this._updatedLayers[layerId] = true;

        if (layer.source) {
            this._updatedSources[layer.source] = true;
        }
        this._change = true;

        return this;
    },

    setFilter: function(layerId, filter) {
        var layer = this._style.getReferentLayer(layerId);
        layerId = layer.id;

        if (validateStyle.emitErrors(this._style, validateStyle.filter({
            key: 'layers.' + layerId + '.filter',
            value: filter,
            style: this._style.serialize(),
            styleSpec: styleSpec
        }))) return this;

        if (util.deepEqual(layer.filter, filter)) return this;
        layer.filter = filter;

        this._updatedLayers[layerId] = true;
        if (layer.source) {
            this._updatedSources[layer.source] = true;
        }
        this._change = true;

        return this;
    },

    setLayerZoomRange: function(layerId, minzoom, maxzoom) {
        var layer = this._style.getReferentLayer(layerId);
        layerId = layer.id;

        if (layer.minzoom === minzoom && layer.maxzoom === maxzoom) return this;

        if (minzoom != null) {
            layer.minzoom = minzoom;
        }
        if (maxzoom != null) {
            layer.maxzoom = maxzoom;
        }

        this._updatedLayers[layerId] = true;
        if (layer.source) {
            this._updatedSources[layer.source] = true;
        }
        this._change = true;

        return this;
    },

    addSource: function(id, source) {
        if (!this._style._loaded) {
            throw new Error('Style is not done loading');
        }
        if (this._style.sources[id] !== undefined) {
            throw new Error('There is already a source with this ID');
        }

        if (!Source.is(source)) {
            if (validateStyle.emitErrors(this._style, validateStyle.source({
                key: 'sources.' + id,
                style: this._style.serialize(),
                value: source,
                styleSpec: styleSpec
            }))) return this;
        }

        source = Source.create(source);
        this._style.sources[id] = source;
        source.id = id;
        source.style = this._style;
        source.dispatcher = this._style.dispatcher;
        source
            .on('load', this._style._forwardSourceEvent)
            .on('error', this._style._forwardSourceEvent)
            .on('change', this._style._forwardSourceEvent)
            .on('tile.add', this._style._forwardTileEvent)
            .on('tile.load', this._style._forwardTileEvent)
            .on('tile.error', this._style._forwardTileEvent)
            .on('tile.remove', this._style._forwardTileEvent)
            .on('tile.stats', this._style._forwardTileEvent);

        this._events.push(['source.add', {source: source}]);
        this._change = true;

        return this;
    },

    removeSource: function(id) {
        if (this._style.sources[id] === undefined) {
            throw new Error('There is no source with this ID');
        }
        var source = this._style.sources[id];
        delete this._style.sources[id];
        source
            .off('load', this._style._forwardSourceEvent)
            .off('error', this._style._forwardSourceEvent)
            .off('change', this._style._forwardSourceEvent)
            .off('tile.add', this._style._forwardTileEvent)
            .off('tile.load', this._style._forwardTileEvent)
            .off('tile.error', this._style._forwardTileEvent)
            .off('tile.remove', this._style._forwardTileEvent)
            .off('tile.stats', this._style._forwardTileEvent);

        this._events.push(['source.remove', {source: source}]);
        this._change = true;

        return this;
    }
};

module.exports = styleBatch;

},{"../source/source":33,"../util/util":104,"./style_layer":47,"./style_spec":54,"./validate_style":56}],46:[function(require,module,exports){
'use strict';

var MapboxGLFunction = require('mapbox-gl-function');
var parseColor = require('./parse_color');

module.exports = StyleDeclaration;

function StyleDeclaration(reference, value) {
    this.type = reference.type;
    this.transitionable = reference.transition;
    this.value = value;
    this.isFunction = !!value.stops;

    // immutable representation of value. used for comparison
    this.json = JSON.stringify(this.value);

    var parsedValue = this.type === 'color' ? parseColor(this.value) : value;
    if (reference.function === 'interpolated') {
        this.calculate = MapboxGLFunction.interpolated(parsedValue);
    } else {
        this.calculate = MapboxGLFunction['piecewise-constant'](parsedValue);
        if (reference.transition) {
            this.calculate = transitioned(this.calculate);
        }
    }
}

function transitioned(calculate) {
    return function(z, zh, duration) {
        var fraction = z % 1;
        var t = Math.min((Date.now() - zh.lastIntegerZoomTime) / duration, 1);
        var fromScale = 1;
        var toScale = 1;
        var mix, from, to;

        if (z > zh.lastIntegerZoom) {
            mix = fraction + (1 - fraction) * t;
            fromScale *= 2;
            from = calculate(z - 1);
            to = calculate(z);
        } else {
            mix = 1 - (1 - t) * fraction;
            to = calculate(z);
            from = calculate(z + 1);
            fromScale /= 2;
        }

        return {
            from: from,
            fromScale: fromScale,
            to: to,
            toScale: toScale,
            t: mix
        };
    };
}

},{"./parse_color":43,"mapbox-gl-function":134}],47:[function(require,module,exports){
'use strict';

var util = require('../util/util');
var StyleTransition = require('./style_transition');
var StyleDeclaration = require('./style_declaration');
var styleSpec = require('./style_spec');
var validateStyle = require('./validate_style');
var parseColor = require('./parse_color');
var Evented = require('../util/evented');

module.exports = StyleLayer;

var TRANSITION_SUFFIX = '-transition';

StyleLayer.create = function(layer, refLayer) {
    var Classes = {
        background: require('./style_layer/background_style_layer'),
        circle: require('./style_layer/circle_style_layer'),
        fill: require('./style_layer/fill_style_layer'),
        line: require('./style_layer/line_style_layer'),
        raster: require('./style_layer/raster_style_layer'),
        symbol: require('./style_layer/symbol_style_layer')
    };
    return new Classes[(refLayer || layer).type](layer, refLayer);
};

function StyleLayer(layer, refLayer) {
    this.id = layer.id;
    this.ref = layer.ref;
    this.metadata = layer.metadata;
    this.type = (refLayer || layer).type;
    this.source = (refLayer || layer).source;
    this.sourceLayer = (refLayer || layer)['source-layer'];
    this.minzoom = (refLayer || layer).minzoom;
    this.maxzoom = (refLayer || layer).maxzoom;
    this.filter = (refLayer || layer).filter;

    this.paint = {};
    this.layout = {};

    this._paintSpecifications = styleSpec['paint_' + this.type];
    this._layoutSpecifications = styleSpec['layout_' + this.type];

    this._paintTransitions = {}; // {[propertyName]: StyleTransition}
    this._paintTransitionOptions = {}; // {[className]: {[propertyName]: { duration:Number, delay:Number }}}
    this._paintDeclarations = {}; // {[className]: {[propertyName]: StyleDeclaration}}
    this._layoutDeclarations = {}; // {[propertyName]: StyleDeclaration}

    // Resolve paint declarations
    for (var key in layer) {
        var match = key.match(/^paint(?:\.(.*))?$/);
        if (match) {
            var klass = match[1] || '';
            for (var paintName in layer[key]) {
                this.setPaintProperty(paintName, layer[key][paintName], klass);
            }
        }
    }

    // Resolve layout declarations
    if (this.ref) {
        this._layoutDeclarations = refLayer._layoutDeclarations;
    } else {
        for (var layoutName in layer.layout) {
            this.setLayoutProperty(layoutName, layer.layout[layoutName]);
        }
    }

    this.recalculateStatic();
}

StyleLayer.prototype = util.inherit(Evented, {

    setLayoutProperty: function(name, value) {

        if (value == null) {
            delete this._layoutDeclarations[name];
        } else {
            if (validateStyle.emitErrors(this, validateStyle.layoutProperty({
                key: 'layers.' + this.id + '.layout.' + name,
                layerType: this.type,
                objectKey: name,
                value: value,
                styleSpec: styleSpec
            }))) return;
            this._layoutDeclarations[name] = new StyleDeclaration(this._layoutSpecifications[name], value);
        }
    },

    getLayoutProperty: function(name) {
        return (
            this._layoutDeclarations[name] &&
            this._layoutDeclarations[name].value
        );
    },

    getLayoutValue: function(name, zoom, zoomHistory) {
        var specification = this._layoutSpecifications[name];
        var declaration = this._layoutDeclarations[name];

        if (declaration) {
            return declaration.calculate(zoom, zoomHistory);
        } else {
            return specification.default;
        }
    },

    setPaintProperty: function(name, value, klass) {
        var validateStyleKey = 'layers.' + this.id + (klass ? '["paint.' + klass + '"].' : '.paint.') + name;

        if (util.endsWith(name, TRANSITION_SUFFIX)) {
            if (!this._paintTransitionOptions[klass || '']) {
                this._paintTransitionOptions[klass || ''] = {};
            }
            if (value === null || value === undefined) {
                delete this._paintTransitionOptions[klass || ''][name];
            } else {
                if (validateStyle.emitErrors(this, validateStyle.paintProperty({
                    key: validateStyleKey,
                    layerType: this.type,
                    objectKey: name,
                    value: value,
                    styleSpec: styleSpec
                }))) return;
                this._paintTransitionOptions[klass || ''][name] = value;
            }
        } else {
            if (!this._paintDeclarations[klass || '']) {
                this._paintDeclarations[klass || ''] = {};
            }
            if (value === null || value === undefined) {
                delete this._paintDeclarations[klass || ''][name];
            } else {
                if (validateStyle.emitErrors(this, validateStyle.paintProperty({
                    key: validateStyleKey,
                    layerType: this.type,
                    objectKey: name,
                    value: value,
                    styleSpec: styleSpec
                }))) return;
                this._paintDeclarations[klass || ''][name] = new StyleDeclaration(this._paintSpecifications[name], value);
            }
        }
    },

    getPaintProperty: function(name, klass) {
        klass = klass || '';
        if (util.endsWith(name, TRANSITION_SUFFIX)) {
            return (
                this._paintTransitionOptions[klass] &&
                this._paintTransitionOptions[klass][name]
            );
        } else {
            return (
                this._paintDeclarations[klass] &&
                this._paintDeclarations[klass][name] &&
                this._paintDeclarations[klass][name].value
            );
        }
    },

    getPaintValue: function(name, zoom, zoomHistory) {
        var specification = this._paintSpecifications[name];
        var transition = this._paintTransitions[name];

        if (transition) {
            return transition.at(zoom, zoomHistory);
        } else if (specification.type === 'color' && specification.default) {
            return parseColor(specification.default);
        } else {
            return specification.default;
        }
    },

    isHidden: function(zoom) {
        if (this.minzoom && zoom < this.minzoom) return true;
        if (this.maxzoom && zoom >= this.maxzoom) return true;
        if (this.layout['visibility'] === 'none') return true;
        if (this.paint[this.type + '-opacity'] === 0) return true;
        return false;
    },

    // update classes
    cascade: function(classes, options, globalTransitionOptions, animationLoop) {
        var oldTransitions = this._paintTransitions;
        var newTransitions = this._paintTransitions = {};
        var that = this;

        // Apply new declarations in all active classes
        for (var klass in this._paintDeclarations) {
            if (klass !== "" && !classes[klass]) continue;
            for (var name in this._paintDeclarations[klass]) {
                applyDeclaration(name, this._paintDeclarations[klass][name]);
            }
        }

        // Apply removed declarations
        var removedNames = util.keysDifference(oldTransitions, newTransitions);
        for (var i = 0; i < removedNames.length; i++) {
            var spec = this._paintSpecifications[removedNames[i]];
            applyDeclaration(removedNames[i], new StyleDeclaration(spec, spec.default));
        }

        this.recalculateStatic();

        function applyDeclaration(name, declaration) {
            var oldTransition = options.transition ? oldTransitions[name] : undefined;

            if (oldTransition && oldTransition.declaration.json === declaration.json) {
                newTransitions[name] = oldTransition;

            } else {
                var newTransition = new StyleTransition(declaration, oldTransition, util.extend(
                    {duration: 300, delay: 0},
                    globalTransitionOptions,
                    that.getPaintProperty(name + TRANSITION_SUFFIX)
                ));

                if (!newTransition.instant()) {
                    newTransition.loopID = animationLoop.set(newTransition.endTime - (new Date()).getTime());
                }

                if (oldTransition) {
                    animationLoop.cancel(oldTransition.loopID);
                }

                newTransitions[name] = newTransition;
            }
        }
    },

    recalculateStatic: function() {
        for (var paintName in this._paintSpecifications) {
            if (!(paintName in this._paintTransitions))
                this.paint[paintName] = this.getPaintValue(paintName);
        }
        this._layoutFunctions = {};
        for (var layoutName in this._layoutSpecifications) {
            var declaration = this._layoutDeclarations[layoutName];
            if (declaration && declaration.isFunction) {
                this._layoutFunctions[layoutName] = true;
            } else {
                this.layout[layoutName] = this.getLayoutValue(layoutName);
            }
        }
    },

    // update zoom
    recalculate: function(zoom, zoomHistory) {
        for (var paintName in this._paintTransitions) {
            this.paint[paintName] = this.getPaintValue(paintName, zoom, zoomHistory);
        }
        for (var layoutName in this._layoutFunctions) {
            this.layout[layoutName] = this.getLayoutValue(layoutName, zoom, zoomHistory);
        }
    },

    serialize: function(options) {
        var output = {
            'id': this.id,
            'ref': this.ref,
            'metadata': this.metadata,
            'minzoom': this.minzoom,
            'maxzoom': this.maxzoom
        };

        for (var klass in this._paintDeclarations) {
            var key = klass === '' ? 'paint' : 'paint.' + klass;
            output[key] = util.mapObject(this._paintDeclarations[klass], getDeclarationValue);
        }

        if (!this.ref || (options && options.includeRefProperties)) {
            util.extend(output, {
                'type': this.type,
                'source': this.source,
                'source-layer': this.sourceLayer,
                'filter': this.filter,
                'layout': util.mapObject(this._layoutDeclarations, getDeclarationValue)
            });
        }

        return util.filterObject(output, function(value, key) {
            return value !== undefined && !(key === 'layout' && !Object.keys(value).length);
        });
    }
});

function getDeclarationValue(declaration) {
    return declaration.value;
}

},{"../util/evented":95,"../util/util":104,"./parse_color":43,"./style_declaration":46,"./style_layer/background_style_layer":48,"./style_layer/circle_style_layer":49,"./style_layer/fill_style_layer":50,"./style_layer/line_style_layer":51,"./style_layer/raster_style_layer":52,"./style_layer/symbol_style_layer":53,"./style_spec":54,"./style_transition":55,"./validate_style":56}],48:[function(require,module,exports){
'use strict';

var util = require('../../util/util');
var StyleLayer = require('../style_layer');

function BackgroundStyleLayer() {
    StyleLayer.apply(this, arguments);
}

module.exports = BackgroundStyleLayer;

BackgroundStyleLayer.prototype = util.inherit(StyleLayer, {});

},{"../../util/util":104,"../style_layer":47}],49:[function(require,module,exports){
'use strict';

var util = require('../../util/util');
var StyleLayer = require('../style_layer');

function CircleStyleLayer() {
    StyleLayer.apply(this, arguments);
}

module.exports = CircleStyleLayer;

CircleStyleLayer.prototype = util.inherit(StyleLayer, {});

},{"../../util/util":104,"../style_layer":47}],50:[function(require,module,exports){
'use strict';

var util = require('../../util/util');
var StyleLayer = require('../style_layer');

function FillStyleLayer() {
    StyleLayer.apply(this, arguments);
}

module.exports = FillStyleLayer;

FillStyleLayer.prototype = util.inherit(StyleLayer, {});

},{"../../util/util":104,"../style_layer":47}],51:[function(require,module,exports){
'use strict';

var util = require('../../util/util');
var StyleLayer = require('../style_layer');

function LineStyleLayer() {
    StyleLayer.apply(this, arguments);
}

module.exports = LineStyleLayer;

LineStyleLayer.prototype = util.inherit(StyleLayer, {

    getPaintValue: function(name, zoom, zoomHistory) {
        var value = StyleLayer.prototype.getPaintValue.call(this, name, zoom, zoomHistory);

        // If the line is dashed, scale the dash lengths by the line
        // width at the previous round zoom level.
        if (value && name === 'line-dasharray') {
            var flooredZoom = Math.floor(zoom);
            if (this._flooredZoom !== flooredZoom) {
                this._flooredZoom = flooredZoom;
                this._flooredLineWidth = this.getPaintValue('line-width', flooredZoom, Infinity);
            }

            value.fromScale *= this._flooredLineWidth;
            value.toScale *= this._flooredLineWidth;
        }

        return value;
    }
});

},{"../../util/util":104,"../style_layer":47}],52:[function(require,module,exports){
'use strict';

var util = require('../../util/util');
var StyleLayer = require('../style_layer');

function RasterStyleLayer() {
    StyleLayer.apply(this, arguments);
}

module.exports = RasterStyleLayer;

RasterStyleLayer.prototype = util.inherit(StyleLayer, {});

},{"../../util/util":104,"../style_layer":47}],53:[function(require,module,exports){
'use strict';

var util = require('../../util/util');
var StyleLayer = require('../style_layer');

function SymbolStyleLayer() {
    StyleLayer.apply(this, arguments);
}

module.exports = SymbolStyleLayer;

SymbolStyleLayer.prototype = util.inherit(StyleLayer, {

    isHidden: function() {
        if (StyleLayer.prototype.isHidden.apply(this, arguments)) return true;

        var isTextHidden = this.paint['text-opacity'] === 0 || !this.layout['text-field'];
        var isIconHidden = this.paint['icon-opacity'] === 0 || !this.layout['icon-image'];
        if (isTextHidden && isIconHidden) return true;

        return false;
    },

    getLayoutValue: function(name, zoom, zoomHistory) {
        if (name === 'text-rotation-alignment' &&
                this.getLayoutValue('symbol-placement', zoom, zoomHistory) === 'line' &&
                !this.getLayoutProperty('text-rotation-alignment')) {
            return 'map';
        } else if (name === 'icon-rotation-alignment' &&
                this.getLayoutValue('symbol-placement', zoom, zoomHistory) === 'line' &&
                !this.getLayoutProperty('icon-rotation-alignment')) {
            return 'map';
        } else {
            return StyleLayer.prototype.getLayoutValue.apply(this, arguments);
        }
    }

});

},{"../../util/util":104,"../style_layer":47}],54:[function(require,module,exports){
'use strict';

module.exports = require('mapbox-gl-style-spec/reference/latest');

},{"mapbox-gl-style-spec/reference/latest":155}],55:[function(require,module,exports){
'use strict';

var util = require('../util/util');
var interpolate = require('../util/interpolate');

module.exports = StyleTransition;

/*
 * Represents a transition between two declarations
 */
function StyleTransition(declaration, oldTransition, value) {

    this.declaration = declaration;
    this.startTime = this.endTime = (new Date()).getTime();

    var type = declaration.type;
    if ((type === 'string' || type === 'array') && declaration.transitionable) {
        this.interp = interpZoomTransitioned;
    } else {
        this.interp = interpolate[type];
    }

    this.oldTransition = oldTransition;
    this.duration = value.duration || 0;
    this.delay = value.delay || 0;

    if (!this.instant()) {
        this.endTime = this.startTime + this.duration + this.delay;
        this.ease = util.easeCubicInOut;
    }

    if (oldTransition && oldTransition.endTime <= this.startTime) {
        // Old transition is done running, so we can
        // delete its reference to its old transition.

        delete oldTransition.oldTransition;
    }
}

StyleTransition.prototype.instant = function() {
    return !this.oldTransition || !this.interp || (this.duration === 0 && this.delay === 0);
};

/*
 * Return the value of the transitioning property at zoom level `z` and optional time `t`
 */
StyleTransition.prototype.at = function(z, zoomHistory, t) {

    var value = this.declaration.calculate(z, zoomHistory, this.duration);

    if (this.instant()) return value;

    t = t || Date.now();

    if (t < this.endTime) {
        var oldValue = this.oldTransition.at(z, zoomHistory, this.startTime);
        var eased = this.ease((t - this.startTime - this.delay) / this.duration);
        value = this.interp(oldValue, value, eased);
    }

    return value;

};

function interpZoomTransitioned(from, to, t) {
    return {
        from: from.to,
        fromScale: from.toScale,
        to: to.to,
        toScale: to.toScale,
        t: t
    };
}

},{"../util/interpolate":98,"../util/util":104}],56:[function(require,module,exports){
'use strict';

module.exports = require('mapbox-gl-style-spec/lib/validate_style.min');

module.exports.emitErrors = function throwErrors(emitter, errors) {
    if (errors && errors.length) {
        for (var i = 0; i < errors.length; i++) {
            emitter.fire('error', { error: new Error(errors[i].message) });
        }
        return true;
    } else {
        return false;
    }
};

},{"mapbox-gl-style-spec/lib/validate_style.min":154}],57:[function(require,module,exports){
'use strict';

var Point = require('point-geometry');

module.exports = Anchor;

function Anchor(x, y, angle, segment) {
    this.x = x;
    this.y = y;
    this.angle = angle;

    if (segment !== undefined) {
        this.segment = segment;
    }
}

Anchor.prototype = Object.create(Point.prototype);

Anchor.prototype.clone = function() {
    return new Anchor(this.x, this.y, this.angle, this.segment);
};

},{"point-geometry":162}],58:[function(require,module,exports){
'use strict';

module.exports = checkMaxAngle;

/**
 * Labels placed around really sharp angles aren't readable. Check if any
 * part of the potential label has a combined angle that is too big.
 *
 * @param {Array<Point>} line
 * @param {Anchor} anchor The point on the line around which the label is anchored.
 * @param {number} labelLength The length of the label in geometry units.
 * @param {number} windowSize The check fails if the combined angles within a part of the line that is `windowSize` long is too big.
 * @param {number} maxAngle The maximum combined angle that any window along the label is allowed to have.
 *
 * @returns {boolean} whether the label should be placed
 * @private
 */
function checkMaxAngle(line, anchor, labelLength, windowSize, maxAngle) {

    // horizontal labels always pass
    if (anchor.segment === undefined) return true;

    var p = anchor;
    var index = anchor.segment + 1;
    var anchorDistance = 0;

    // move backwards along the line to the first segment the label appears on
    while (anchorDistance > -labelLength / 2) {
        index--;

        // there isn't enough room for the label after the beginning of the line
        if (index < 0) return false;

        anchorDistance -= line[index].dist(p);
        p = line[index];
    }

    anchorDistance += line[index].dist(line[index + 1]);
    index++;

    // store recent corners and their total angle difference
    var recentCorners = [];
    var recentAngleDelta = 0;

    // move forwards by the length of the label and check angles along the way
    while (anchorDistance < labelLength / 2) {
        var prev = line[index - 1];
        var current = line[index];
        var next = line[index + 1];

        // there isn't enough room for the label before the end of the line
        if (!next) return false;

        var angleDelta = prev.angleTo(current) - current.angleTo(next);
        // restrict angle to -pi..pi range
        angleDelta = Math.abs(((angleDelta + 3 * Math.PI) % (Math.PI * 2)) - Math.PI);

        recentCorners.push({
            distance: anchorDistance,
            angleDelta: angleDelta
        });
        recentAngleDelta += angleDelta;

        // remove corners that are far enough away from the list of recent anchors
        while (anchorDistance - recentCorners[0].distance > windowSize) {
            recentAngleDelta -= recentCorners.shift().angleDelta;
        }

        // the sum of angles within the window area exceeds the maximum allowed value. check fails.
        if (recentAngleDelta > maxAngle) return false;

        index++;
        anchorDistance += current.dist(next);
    }

    // no part of the line had an angle greater than the maximum allowed. check passes.
    return true;
}

},{}],59:[function(require,module,exports){
'use strict';

var Point = require('point-geometry');

module.exports = clipLine;

/**
 * Returns the part of a multiline that intersects with the provided rectangular box.
 *
 * @param {Array<Array<Point>>} lines
 * @param {number} x1 the left edge of the box
 * @param {number} y1 the top edge of the box
 * @param {number} x2 the right edge of the box
 * @param {number} y2 the bottom edge of the box
 * @returns {Array<Array<Point>>} lines
 * @private
 */
function clipLine(lines, x1, y1, x2, y2) {
    var clippedLines = [];

    for (var l = 0; l < lines.length; l++) {
        var line = lines[l];
        var clippedLine;

        for (var i = 0; i < line.length - 1; i++) {
            var p0 = line[i];
            var p1 = line[i + 1];


            if (p0.x < x1 && p1.x < x1) {
                continue;
            } else if (p0.x < x1) {
                p0 = new Point(x1, p0.y + (p1.y - p0.y) * ((x1 - p0.x) / (p1.x - p0.x)))._round();
            } else if (p1.x < x1) {
                p1 = new Point(x1, p0.y + (p1.y - p0.y) * ((x1 - p0.x) / (p1.x - p0.x)))._round();
            }

            if (p0.y < y1 && p1.y < y1) {
                continue;
            } else if (p0.y < y1) {
                p0 = new Point(p0.x + (p1.x - p0.x) * ((y1 - p0.y) / (p1.y - p0.y)), y1)._round();
            } else if (p1.y < y1) {
                p1 = new Point(p0.x + (p1.x - p0.x) * ((y1 - p0.y) / (p1.y - p0.y)), y1)._round();
            }

            if (p0.x >= x2 && p1.x >= x2) {
                continue;
            } else if (p0.x >= x2) {
                p0 = new Point(x2, p0.y + (p1.y - p0.y) * ((x2 - p0.x) / (p1.x - p0.x)))._round();
            } else if (p1.x >= x2) {
                p1 = new Point(x2, p0.y + (p1.y - p0.y) * ((x2 - p0.x) / (p1.x - p0.x)))._round();
            }

            if (p0.y >= y2 && p1.y >= y2) {
                continue;
            } else if (p0.y >= y2) {
                p0 = new Point(p0.x + (p1.x - p0.x) * ((y2 - p0.y) / (p1.y - p0.y)), y2)._round();
            } else if (p1.y >= y2) {
                p1 = new Point(p0.x + (p1.x - p0.x) * ((y2 - p0.y) / (p1.y - p0.y)), y2)._round();
            }

            if (!clippedLine || !p0.equals(clippedLine[clippedLine.length - 1])) {
                clippedLine = [p0];
                clippedLines.push(clippedLine);
            }

            clippedLine.push(p1);
        }
    }

    return clippedLines;
}

},{"point-geometry":162}],60:[function(require,module,exports){
'use strict';

var StructArrayType = require('../util/struct_array');
var util = require('../util/util');
var Point = require('point-geometry');

/**
 * A collision box represents an area of the map that that is covered by a
 * label. CollisionFeature uses one or more of these collision boxes to
 * represent all the area covered by a single label. They are used to
 * prevent collisions between labels.
 *
 * A collision box actually represents a 3d volume. The first two dimensions,
 * x and y, are specified with `anchor` along with `x1`, `y1`, `x2`, `y2`.
 * The third dimension, zoom, is limited by `maxScale` which determines
 * how far in the z dimensions the box extends.
 *
 * As you zoom in on a map, all points on the map get further and further apart
 * but labels stay roughly the same size. Labels cover less real world area on
 * the map at higher zoom levels than they do at lower zoom levels. This is why
 * areas are are represented with an anchor point and offsets from that point
 * instead of just using four absolute points.
 *
 * Line labels are represented by a set of these boxes spaced out along a line.
 * When you zoom in, line labels cover less real world distance along the line
 * than they used to. Collision boxes near the edges that used to cover label
 * no longer do. If a box doesn't cover the label anymore it should be ignored
 * when doing collision checks. `maxScale` is how much you can scale the map
 * before the label isn't within the box anymore.
 * For example
 * lower zoom:
 * https://cloud.githubusercontent.com/assets/1421652/8060094/4d975f76-0e91-11e5-84b1-4edeb30a5875.png
 * slightly higher zoom:
 * https://cloud.githubusercontent.com/assets/1421652/8060061/26ae1c38-0e91-11e5-8c5a-9f380bf29f0a.png
 * In the zoomed in image the two grey boxes on either side don't cover the
 * label anymore. Their maxScale is smaller than the current scale.
 *
 *
 * @class CollisionBoxArray
 * @private
 */

var CollisionBoxArray = module.exports = new StructArrayType({
    members: [
        // the box is centered around the anchor point
        { type: 'Int16', name: 'anchorPointX' },
        { type: 'Int16', name: 'anchorPointY' },

        // distances to the edges from the anchor
        { type: 'Int16', name: 'x1' },
        { type: 'Int16', name: 'y1' },
        { type: 'Int16', name: 'x2' },
        { type: 'Int16', name: 'y2' },

        // the box is only valid for scales < maxScale.
        // The box does not block other boxes at scales >= maxScale;
        { type: 'Float32', name: 'maxScale' },

        // the index of the feature in the original vectortile
        { type: 'Uint32', name: 'featureIndex' },
        // the source layer the feature appears in
        { type: 'Uint16', name: 'sourceLayerIndex' },
        // the bucket the feature appears in
        { type: 'Uint16', name: 'bucketIndex' },

        // rotated and scaled bbox used for indexing
        { type: 'Int16', name: 'bbox0' },
        { type: 'Int16', name: 'bbox1' },
        { type: 'Int16', name: 'bbox2' },
        { type: 'Int16', name: 'bbox3' },

        { type: 'Float32', name: 'placementScale' }
    ]});

util.extendAll(CollisionBoxArray.prototype.StructType.prototype, {
    get anchorPoint() {
        return new Point(this.anchorPointX, this.anchorPointY);
    }
});

},{"../util/struct_array":102,"../util/util":104,"point-geometry":162}],61:[function(require,module,exports){
'use strict';

module.exports = CollisionFeature;

/**
 * A CollisionFeature represents the area of the tile covered by a single label.
 * It is used with CollisionTile to check if the label overlaps with any
 * previous labels. A CollisionFeature is mostly just a set of CollisionBox
 * objects.
 *
 * @class CollisionFeature
 * @param {Array<Point>} line The geometry the label is placed on.
 * @param {Anchor} anchor The point along the line around which the label is anchored.
 * @param {VectorTileFeature} feature The VectorTileFeature that this CollisionFeature was created for.
 * @param {Array<string>} layerIDs The IDs of the layers that this CollisionFeature is a part of.
 * @param {Object} shaped The text or icon shaping results.
 * @param {number} boxScale A magic number used to convert from glyph metrics units to geometry units.
 * @param {number} padding The amount of padding to add around the label edges.
 * @param {boolean} alignLine Whether the label is aligned with the line or the viewport.
 *
 * @private
 */
function CollisionFeature(collisionBoxArray, line, anchor, featureIndex, sourceLayerIndex, bucketIndex, shaped, boxScale, padding, alignLine, straight) {

    var y1 = shaped.top * boxScale - padding;
    var y2 = shaped.bottom * boxScale + padding;
    var x1 = shaped.left * boxScale - padding;
    var x2 = shaped.right * boxScale + padding;

    this.boxStartIndex = collisionBoxArray.length;

    if (alignLine) {

        var height = y2 - y1;
        var length = x2 - x1;

        if (height > 0) {
            // set minimum box height to avoid very many small labels
            height = Math.max(10 * boxScale, height);

            if (straight) {
                // used for icon labels that are aligned with the line, but don't curve along it
                var vector = line[anchor.segment + 1].sub(line[anchor.segment])._unit()._mult(length);
                var straightLine = [anchor.sub(vector), anchor.add(vector)];
                this._addLineCollisionBoxes(collisionBoxArray, straightLine, anchor, 0, length, height, featureIndex, sourceLayerIndex, bucketIndex);
            } else {
                // used for text labels that curve along a line
                this._addLineCollisionBoxes(collisionBoxArray, line, anchor, anchor.segment, length, height, featureIndex, sourceLayerIndex, bucketIndex);
            }
        }

    } else {
        collisionBoxArray.emplaceBack(anchor.x, anchor.y, x1, y1, x2, y2, Infinity, featureIndex, sourceLayerIndex, bucketIndex,
                0, 0, 0, 0, 0);
    }

    this.boxEndIndex = collisionBoxArray.length;
}

/**
 * Create a set of CollisionBox objects for a line.
 *
 * @param {Array<Point>} line
 * @param {Anchor} anchor
 * @param {number} labelLength The length of the label in geometry units.
 * @param {Anchor} anchor The point along the line around which the label is anchored.
 * @param {VectorTileFeature} feature The VectorTileFeature that this CollisionFeature was created for.
 * @param {number} boxSize The size of the collision boxes that will be created.
 *
 * @private
 */
CollisionFeature.prototype._addLineCollisionBoxes = function(collisionBoxArray, line, anchor, segment, labelLength, boxSize, featureIndex, sourceLayerIndex, bucketIndex) {
    var step = boxSize / 2;
    var nBoxes = Math.floor(labelLength / step);

    // offset the center of the first box by half a box so that the edge of the
    // box is at the edge of the label.
    var firstBoxOffset = -boxSize / 2;

    var bboxes = this.boxes;

    var p = anchor;
    var index = segment + 1;
    var anchorDistance = firstBoxOffset;

    // move backwards along the line to the first segment the label appears on
    do {
        index--;

        // there isn't enough room for the label after the beginning of the line
        // checkMaxAngle should have already caught this
        if (index < 0) return bboxes;

        anchorDistance -= line[index].dist(p);
        p = line[index];
    } while (anchorDistance > -labelLength / 2);

    var segmentLength = line[index].dist(line[index + 1]);

    for (var i = 0; i < nBoxes; i++) {
        // the distance the box will be from the anchor
        var boxDistanceToAnchor = -labelLength / 2 + i * step;

        // the box is not on the current segment. Move to the next segment.
        while (anchorDistance + segmentLength < boxDistanceToAnchor) {
            anchorDistance += segmentLength;
            index++;

            // There isn't enough room before the end of the line.
            if (index + 1 >= line.length) return bboxes;

            segmentLength = line[index].dist(line[index + 1]);
        }

        // the distance the box will be from the beginning of the segment
        var segmentBoxDistance = boxDistanceToAnchor - anchorDistance;

        var p0 = line[index];
        var p1 = line[index + 1];
        var boxAnchorPoint = p1.sub(p0)._unit()._mult(segmentBoxDistance)._add(p0)._round();

        var distanceToInnerEdge = Math.max(Math.abs(boxDistanceToAnchor - firstBoxOffset) - step / 2, 0);
        var maxScale = labelLength / 2 / distanceToInnerEdge;

        collisionBoxArray.emplaceBack(boxAnchorPoint.x, boxAnchorPoint.y,
                -boxSize / 2, -boxSize / 2, boxSize / 2, boxSize / 2, maxScale,
                featureIndex, sourceLayerIndex, bucketIndex,
                0, 0, 0, 0, 0);
    }

    return bboxes;
};

},{}],62:[function(require,module,exports){
'use strict';

var Point = require('point-geometry');
var EXTENT = require('../data/bucket').EXTENT;
var Grid = require('../util/grid');

module.exports = CollisionTile;

/**
 * A collision tile used to prevent symbols from overlapping. It keep tracks of
 * where previous symbols have been placed and is used to check if a new
 * symbol overlaps with any previously added symbols.
 *
 * @class CollisionTile
 * @param {number} angle
 * @param {number} pitch
 * @private
 */
function CollisionTile(angle, pitch, collisionBoxArray) {
    if (typeof angle === 'object') {
        var serialized = angle;
        collisionBoxArray = pitch;
        angle = serialized.angle;
        pitch = serialized.pitch;
        this.grid = new Grid(serialized.grid);
        this.ignoredGrid = new Grid(serialized.ignoredGrid);
    } else {
        this.grid = new Grid(12, EXTENT, 6);
        this.ignoredGrid = new Grid(12, EXTENT, 0);
    }

    this.angle = angle;
    this.pitch = pitch;

    var sin = Math.sin(angle),
        cos = Math.cos(angle);
    this.rotationMatrix = [cos, -sin, sin, cos];
    this.reverseRotationMatrix = [cos, sin, -sin, cos];

    // Stretch boxes in y direction to account for the map tilt.
    this.yStretch = 1 / Math.cos(pitch / 180 * Math.PI);

    // The amount the map is squished depends on the y position.
    // Sort of account for this by making all boxes a bit bigger.
    this.yStretch = Math.pow(this.yStretch, 1.3);

    this.collisionBoxArray = collisionBoxArray;
    if (collisionBoxArray.length === 0) {
        // the first collisionBoxArray is passed to a CollisionTile

        // tempCollisionBox
        collisionBoxArray.emplaceBack();

        var maxInt16 = 32767;
        //left
        collisionBoxArray.emplaceBack(0, 0, 0, -maxInt16, 0, maxInt16, maxInt16,
                0, 0, 0, 0, 0, 0, 0, 0,
                0);
        // right
        collisionBoxArray.emplaceBack(EXTENT, 0, 0, -maxInt16, 0, maxInt16, maxInt16,
                0, 0, 0, 0, 0, 0, 0, 0,
                0);
        // top
        collisionBoxArray.emplaceBack(0, 0, -maxInt16, 0, maxInt16, 0, maxInt16,
                0, 0, 0, 0, 0, 0, 0, 0,
                0);
        // bottom
        collisionBoxArray.emplaceBack(0, EXTENT, -maxInt16, 0, maxInt16, 0, maxInt16,
                0, 0, 0, 0, 0, 0, 0, 0,
                0);
    }

    this.tempCollisionBox = collisionBoxArray.get(0);
    this.edges = [
        collisionBoxArray.get(1),
        collisionBoxArray.get(2),
        collisionBoxArray.get(3),
        collisionBoxArray.get(4)
    ];
}

CollisionTile.prototype.serialize = function() {
    var data = {
        angle: this.angle,
        pitch: this.pitch,
        grid: this.grid.toArrayBuffer(),
        ignoredGrid: this.ignoredGrid.toArrayBuffer()
    };
    return {
        data: data,
        transferables: [data.grid, data.ignoredGrid]
    };
};

CollisionTile.prototype.minScale = 0.25;
CollisionTile.prototype.maxScale = 2;


/**
 * Find the scale at which the collisionFeature can be shown without
 * overlapping with other features.
 *
 * @param {CollisionFeature} collisionFeature
 * @returns {number} placementScale
 * @private
 */
CollisionTile.prototype.placeCollisionFeature = function(collisionFeature, allowOverlap, avoidEdges) {

    var collisionBoxArray = this.collisionBoxArray;
    var minPlacementScale = this.minScale;
    var rotationMatrix = this.rotationMatrix;
    var yStretch = this.yStretch;

    for (var b = collisionFeature.boxStartIndex; b < collisionFeature.boxEndIndex; b++) {

        var box = collisionBoxArray.get(b);

        var anchorPoint = box.anchorPoint._matMult(rotationMatrix);
        var x = anchorPoint.x;
        var y = anchorPoint.y;

        var x1 = x + box.x1;
        var y1 = y + box.y1 * yStretch;
        var x2 = x + box.x2;
        var y2 = y + box.y2 * yStretch;

        box.bbox0 = x1;
        box.bbox1 = y1;
        box.bbox2 = x2;
        box.bbox3 = y2;

        if (!allowOverlap) {
            var blockingBoxes = this.grid.query(x1, y1, x2, y2);

            for (var i = 0; i < blockingBoxes.length; i++) {
                var blocking = collisionBoxArray.get(blockingBoxes[i]);
                var blockingAnchorPoint = blocking.anchorPoint._matMult(rotationMatrix);

                minPlacementScale = this.getPlacementScale(minPlacementScale, anchorPoint, box, blockingAnchorPoint, blocking);
                if (minPlacementScale >= this.maxScale) {
                    return minPlacementScale;
                }
            }
        }

        if (avoidEdges) {
            var rotatedCollisionBox;

            if (this.angle) {
                var reverseRotationMatrix = this.reverseRotationMatrix;
                var tl = new Point(box.x1, box.y1).matMult(reverseRotationMatrix);
                var tr = new Point(box.x2, box.y1).matMult(reverseRotationMatrix);
                var bl = new Point(box.x1, box.y2).matMult(reverseRotationMatrix);
                var br = new Point(box.x2, box.y2).matMult(reverseRotationMatrix);

                rotatedCollisionBox = this.tempCollisionBox;
                rotatedCollisionBox.anchorPointX = box.anchorPoint.x;
                rotatedCollisionBox.anchorPointY = box.anchorPoint.y;
                rotatedCollisionBox.x1 = Math.min(tl.x, tr.x, bl.x, br.x);
                rotatedCollisionBox.y1 = Math.min(tl.y, tr.x, bl.x, br.x);
                rotatedCollisionBox.x2 = Math.max(tl.x, tr.x, bl.x, br.x);
                rotatedCollisionBox.y2 = Math.max(tl.y, tr.x, bl.x, br.x);
                rotatedCollisionBox.maxScale = box.maxScale;
            } else {
                rotatedCollisionBox = box;
            }

            for (var k = 0; k < this.edges.length; k++) {
                var edgeBox = this.edges[k];
                minPlacementScale = this.getPlacementScale(minPlacementScale, box.anchorPoint, rotatedCollisionBox, edgeBox.anchorPoint, edgeBox);
                if (minPlacementScale >= this.maxScale) {
                    return minPlacementScale;
                }
            }
        }
    }

    return minPlacementScale;
};

CollisionTile.prototype.queryRenderedSymbols = function(minX, minY, maxX, maxY, scale) {
    var sourceLayerFeatures = {};
    var result = [];

    var collisionBoxArray = this.collisionBoxArray;
    var rotationMatrix = this.rotationMatrix;
    var anchorPoint = new Point(minX, minY)._matMult(rotationMatrix);

    var queryBox = this.tempCollisionBox;
    queryBox.anchorX = anchorPoint.x;
    queryBox.anchorY = anchorPoint.y;
    queryBox.x1 = 0;
    queryBox.y1 = 0;
    queryBox.x2 = maxX - minX;
    queryBox.y2 = maxY - minY;
    queryBox.maxScale = scale;

    // maxScale is stored using a Float32. Convert `scale` to the stored Float32 value.
    scale = queryBox.maxScale;

    var searchBox = [
        anchorPoint.x + queryBox.x1 / scale,
        anchorPoint.y + queryBox.y1 / scale * this.yStretch,
        anchorPoint.x + queryBox.x2 / scale,
        anchorPoint.y + queryBox.y2 / scale * this.yStretch
    ];

    var blockingBoxKeys = this.grid.query(searchBox[0], searchBox[1], searchBox[2], searchBox[3]);
    var blockingBoxKeys2 = this.ignoredGrid.query(searchBox[0], searchBox[1], searchBox[2], searchBox[3]);
    for (var k = 0; k < blockingBoxKeys2.length; k++) {
        blockingBoxKeys.push(blockingBoxKeys2[k]);
    }

    for (var i = 0; i < blockingBoxKeys.length; i++) {
        var blocking = collisionBoxArray.get(blockingBoxKeys[i]);

        var sourceLayer = blocking.sourceLayerIndex;
        var featureIndex = blocking.featureIndex;
        if (sourceLayerFeatures[sourceLayer] === undefined) {
            sourceLayerFeatures[sourceLayer] = {};
        }

        if (!sourceLayerFeatures[sourceLayer][featureIndex]) {
            var blockingAnchorPoint = blocking.anchorPoint.matMult(rotationMatrix);
            var minPlacementScale = this.getPlacementScale(this.minScale, anchorPoint, queryBox, blockingAnchorPoint, blocking);
            if (minPlacementScale >= scale) {
                sourceLayerFeatures[sourceLayer][featureIndex] = true;
                result.push(blockingBoxKeys[i]);
            }
        }
    }

    return result;
};

CollisionTile.prototype.getPlacementScale = function(minPlacementScale, anchorPoint, box, blockingAnchorPoint, blocking) {

    // Find the lowest scale at which the two boxes can fit side by side without overlapping.
    // Original algorithm:
    var anchorDiffX = anchorPoint.x - blockingAnchorPoint.x;
    var anchorDiffY = anchorPoint.y - blockingAnchorPoint.y;
    var s1 = (blocking.x1 - box.x2) / anchorDiffX; // scale at which new box is to the left of old box
    var s2 = (blocking.x2 - box.x1) / anchorDiffX; // scale at which new box is to the right of old box
    var s3 = (blocking.y1 - box.y2) * this.yStretch / anchorDiffY; // scale at which new box is to the top of old box
    var s4 = (blocking.y2 - box.y1) * this.yStretch / anchorDiffY; // scale at which new box is to the bottom of old box

    if (isNaN(s1) || isNaN(s2)) s1 = s2 = 1;
    if (isNaN(s3) || isNaN(s4)) s3 = s4 = 1;

    var collisionFreeScale = Math.min(Math.max(s1, s2), Math.max(s3, s4));
    var blockingMaxScale = blocking.maxScale;
    var boxMaxScale = box.maxScale;

    if (collisionFreeScale > blockingMaxScale) {
        // After a box's maxScale the label has shrunk enough that the box is no longer needed to cover it,
        // so unblock the new box at the scale that the old box disappears.
        collisionFreeScale = blockingMaxScale;
    }

    if (collisionFreeScale > boxMaxScale) {
        // If the box can only be shown after it is visible, then the box can never be shown.
        // But the label can be shown after this box is not visible.
        collisionFreeScale = boxMaxScale;
    }

    if (collisionFreeScale > minPlacementScale &&
            collisionFreeScale >= blocking.placementScale) {
        // If this collision occurs at a lower scale than previously found collisions
        // and the collision occurs while the other label is visible

        // this this is the lowest scale at which the label won't collide with anything
        minPlacementScale = collisionFreeScale;
    }

    return minPlacementScale;
};


/**
 * Remember this collisionFeature and what scale it was placed at to block
 * later features from overlapping with it.
 *
 * @param {CollisionFeature} collisionFeature
 * @param {number} minPlacementScale
 * @private
 */
CollisionTile.prototype.insertCollisionFeature = function(collisionFeature, minPlacementScale, ignorePlacement) {

    var grid = ignorePlacement ? this.ignoredGrid : this.grid;
    var collisionBoxArray = this.collisionBoxArray;

    for (var k = collisionFeature.boxStartIndex; k < collisionFeature.boxEndIndex; k++) {
        var box = collisionBoxArray.get(k);
        box.placementScale = minPlacementScale;
        if (minPlacementScale < this.maxScale) {
            grid.insert(k, box.bbox0, box.bbox1, box.bbox2, box.bbox3);
        }
    }
};

},{"../data/bucket":1,"../util/grid":97,"point-geometry":162}],63:[function(require,module,exports){
'use strict';

var interpolate = require('../util/interpolate');
var Anchor = require('../symbol/anchor');
var checkMaxAngle = require('./check_max_angle');

module.exports = getAnchors;

function getAnchors(line, spacing, maxAngle, shapedText, shapedIcon, glyphSize, boxScale, overscaling, tileExtent) {

    // Resample a line to get anchor points for labels and check that each
    // potential label passes text-max-angle check and has enough froom to fit
    // on the line.

    var angleWindowSize = shapedText ?
        3 / 5 * glyphSize * boxScale :
        0;

    var labelLength = Math.max(
        shapedText ? shapedText.right - shapedText.left : 0,
        shapedIcon ? shapedIcon.right - shapedIcon.left : 0);

    // Is the line continued from outside the tile boundary?
    var isLineContinued = line[0].x === 0 || line[0].x === tileExtent || line[0].y === 0 || line[0].y === tileExtent;

    // Is the label long, relative to the spacing?
    // If so, adjust the spacing so there is always a minimum space of `spacing / 4` between label edges.
    if (spacing - labelLength * boxScale  < spacing / 4) {
        spacing = labelLength * boxScale + spacing / 4;
    }

    // Offset the first anchor by:
    // Either half the label length plus a fixed extra offset if the line is not continued
    // Or half the spacing if the line is continued.

    // For non-continued lines, add a bit of fixed extra offset to avoid collisions at T intersections.
    var fixedExtraOffset = glyphSize * 2;

    var offset = !isLineContinued ?
        ((labelLength / 2 + fixedExtraOffset) * boxScale * overscaling) % spacing :
        (spacing / 2 * overscaling) % spacing;

    return resample(line, offset, spacing, angleWindowSize, maxAngle, labelLength * boxScale, isLineContinued, false, tileExtent);
}


function resample(line, offset, spacing, angleWindowSize, maxAngle, labelLength, isLineContinued, placeAtMiddle, tileExtent) {

    var halfLabelLength = labelLength / 2;
    var lineLength = 0;
    for (var k = 0; k < line.length - 1; k++) {
        lineLength += line[k].dist(line[k + 1]);
    }

    var distance = 0,
        markedDistance = offset - spacing;

    var anchors = [];

    for (var i = 0; i < line.length - 1; i++) {

        var a = line[i],
            b = line[i + 1];

        var segmentDist = a.dist(b),
            angle = b.angleTo(a);

        while (markedDistance + spacing < distance + segmentDist) {
            markedDistance += spacing;

            var t = (markedDistance - distance) / segmentDist,
                x = interpolate(a.x, b.x, t),
                y = interpolate(a.y, b.y, t);

            // Check that the point is within the tile boundaries and that
            // the label would fit before the beginning and end of the line
            // if placed at this point.
            if (x >= 0 && x < tileExtent && y >= 0 && y < tileExtent &&
                    markedDistance - halfLabelLength >= 0 &&
                    markedDistance + halfLabelLength <= lineLength) {
                var anchor = new Anchor(x, y, angle, i)._round();

                if (!angleWindowSize || checkMaxAngle(line, anchor, labelLength, angleWindowSize, maxAngle)) {
                    anchors.push(anchor);
                }
            }
        }

        distance += segmentDist;
    }

    if (!placeAtMiddle && !anchors.length && !isLineContinued) {
        // The first attempt at finding anchors at which labels can be placed failed.
        // Try again, but this time just try placing one anchor at the middle of the line.
        // This has the most effect for short lines in overscaled tiles, since the
        // initial offset used in overscaled tiles is calculated to align labels with positions in
        // parent tiles instead of placing the label as close to the beginning as possible.
        anchors = resample(line, distance / 2, spacing, angleWindowSize, maxAngle, labelLength, isLineContinued, true, tileExtent);
    }

    return anchors;
}

},{"../symbol/anchor":57,"../util/interpolate":98,"./check_max_angle":58}],64:[function(require,module,exports){
'use strict';

var ShelfPack = require('shelf-pack');

module.exports = GlyphAtlas;
function GlyphAtlas(width, height) {
    this.width = width;
    this.height = height;

    this.bin = new ShelfPack(width, height);
    this.index = {};
    this.ids = {};
    this.data = new Uint8Array(width * height);
}

GlyphAtlas.prototype.getGlyphs = function() {
    var glyphs = {},
        split,
        name,
        id;

    for (var key in this.ids) {
        split = key.split('#');
        name = split[0];
        id = split[1];

        if (!glyphs[name]) glyphs[name] = [];
        glyphs[name].push(id);
    }

    return glyphs;
};

GlyphAtlas.prototype.getRects = function() {
    var rects = {},
        split,
        name,
        id;

    for (var key in this.ids) {
        split = key.split('#');
        name = split[0];
        id = split[1];

        if (!rects[name]) rects[name] = {};
        rects[name][id] = this.index[key];
    }

    return rects;
};


GlyphAtlas.prototype.addGlyph = function(id, name, glyph, buffer) {
    if (!glyph) {
        // console.warn('missing glyph', code, String.fromCharCode(code));
        return null;
    }
    var key = name + "#" + glyph.id;

    // The glyph is already in this texture.
    if (this.index[key]) {
        if (this.ids[key].indexOf(id) < 0) {
            this.ids[key].push(id);
        }
        return this.index[key];
    }

    // The glyph bitmap has zero width.
    if (!glyph.bitmap) {
        return null;
    }

    var bufferedWidth = glyph.width + buffer * 2;
    var bufferedHeight = glyph.height + buffer * 2;

    // Add a 1px border around every image.
    var padding = 1;
    var packWidth = bufferedWidth + 2 * padding;
    var packHeight = bufferedHeight + 2 * padding;

    // Increase to next number divisible by 4, but at least 1.
    // This is so we can scale down the texture coordinates and pack them
    // into 2 bytes rather than 4 bytes.
    packWidth += (4 - packWidth % 4);
    packHeight += (4 - packHeight % 4);

    var rect = this.bin.allocate(packWidth, packHeight);
    if (rect.x < 0) {
        this.resize();
        rect = this.bin.allocate(packWidth, packHeight);
    }
    if (rect.x < 0) {
        console.warn('glyph bitmap overflow');
        return { glyph: glyph, rect: null };
    }

    this.index[key] = rect;
    this.ids[key] = [id];

    var target = this.data;
    var source = glyph.bitmap;
    for (var y = 0; y < bufferedHeight; y++) {
        var y1 = this.width * (rect.y + y + padding) + rect.x + padding;
        var y2 = bufferedWidth * y;
        for (var x = 0; x < bufferedWidth; x++) {
            target[y1 + x] = source[y2 + x];
        }
    }

    this.dirty = true;

    return rect;
};

GlyphAtlas.prototype.resize = function() {
    var origw = this.width,
        origh = this.height;

    // For now, don't grow the atlas beyond 1024x1024 because of how
    // texture coords pack into unsigned byte in symbol bucket.
    if (origw > 512 || origh > 512) return;

    if (this.texture) {
        if (this.gl) {
            this.gl.deleteTexture(this.texture);
        }
        this.texture = null;
    }

    this.width *= 2;
    this.height *= 2;
    this.bin.resize(this.width, this.height);

    var buf = new ArrayBuffer(this.width * this.height),
        src, dst;
    for (var i = 0; i < origh; i++) {
        src = new Uint8Array(this.data.buffer, origh * i, origw);
        dst = new Uint8Array(buf, origh * i * 2, origw);
        dst.set(src);
    }
    this.data = new Uint8Array(buf);
};

GlyphAtlas.prototype.bind = function(gl) {
    this.gl = gl;
    if (!this.texture) {
        this.texture = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, this.texture);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.ALPHA, this.width, this.height, 0, gl.ALPHA, gl.UNSIGNED_BYTE, null);

    } else {
        gl.bindTexture(gl.TEXTURE_2D, this.texture);
    }
};

GlyphAtlas.prototype.updateTexture = function(gl) {
    this.bind(gl);
    if (this.dirty) {
        gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, this.width, this.height, gl.ALPHA, gl.UNSIGNED_BYTE, this.data);
        this.dirty = false;
    }
};

},{"shelf-pack":165}],65:[function(require,module,exports){
'use strict';

var normalizeURL = require('../util/mapbox').normalizeGlyphsURL;
var getArrayBuffer = require('../util/ajax').getArrayBuffer;
var Glyphs = require('../util/glyphs');
var GlyphAtlas = require('../symbol/glyph_atlas');
var Protobuf = require('pbf');

module.exports = GlyphSource;

/**
 * A glyph source has a URL from which to load new glyphs and manages
 * GlyphAtlases in which to store glyphs used by the requested fontstacks
 * and ranges.
 *
 * @param {string} url glyph template url
 * @private
 */
function GlyphSource(url) {
    this.url = url && normalizeURL(url);
    this.atlases = {};
    this.stacks = {};
    this.loading = {};
}

GlyphSource.prototype.getSimpleGlyphs = function(fontstack, glyphIDs, uid, callback) {
    if (this.stacks[fontstack] === undefined) {
        this.stacks[fontstack] = {};
    }
    if (this.atlases[fontstack] === undefined) {
        this.atlases[fontstack] = new GlyphAtlas(128, 128);
    }

    var glyphs = {};
    var stack = this.stacks[fontstack];
    var atlas = this.atlases[fontstack];

    // the number of pixels the sdf bitmaps are padded by
    var buffer = 3;

    var missing = {};
    var remaining = 0;
    var range;

    for (var i = 0; i < glyphIDs.length; i++) {
        var glyphID = glyphIDs[i];
        range = Math.floor(glyphID / 256);

        if (stack[range]) {
            var glyph = stack[range].glyphs[glyphID];
            var rect  = atlas.addGlyph(uid, fontstack, glyph, buffer);
            if (glyph) glyphs[glyphID] = new SimpleGlyph(glyph, rect, buffer);
        } else {
            if (missing[range] === undefined) {
                missing[range] = [];
                remaining++;
            }
            missing[range].push(glyphID);
        }
    }

    if (!remaining) callback(undefined, glyphs, fontstack);

    var onRangeLoaded = function(err, range, data) {
        // TODO not be silent about errors
        if (!err) {
            var stack = this.stacks[fontstack][range] = data.stacks[0];
            for (var i = 0; i < missing[range].length; i++) {
                var glyphID = missing[range][i];
                var glyph = stack.glyphs[glyphID];
                var rect  = atlas.addGlyph(uid, fontstack, glyph, buffer);
                if (glyph) glyphs[glyphID] = new SimpleGlyph(glyph, rect, buffer);
            }
        }
        remaining--;
        if (!remaining) callback(undefined, glyphs, fontstack);
    }.bind(this);

    for (var r in missing) {
        this.loadRange(fontstack, r, onRangeLoaded);
    }
};

// A simplified representation of the glyph containing only the properties needed for shaping.
function SimpleGlyph(glyph, rect, buffer) {
    var padding = 1;
    this.advance = glyph.advance;
    this.left = glyph.left - buffer - padding;
    this.top = glyph.top + buffer + padding;
    this.rect = rect;
}

GlyphSource.prototype.loadRange = function(fontstack, range, callback) {
    if (range * 256 > 65535) return callback('glyphs > 65535 not supported');

    if (this.loading[fontstack] === undefined) {
        this.loading[fontstack] = {};
    }
    var loading = this.loading[fontstack];

    if (loading[range]) {
        loading[range].push(callback);
    } else {
        loading[range] = [callback];

        var rangeName = (range * 256) + '-' + (range * 256 + 255);
        var url = glyphUrl(fontstack, rangeName, this.url);

        getArrayBuffer(url, function(err, data) {
            var glyphs = !err && new Glyphs(new Protobuf(new Uint8Array(data)));
            for (var i = 0; i < loading[range].length; i++) {
                loading[range][i](err, range, glyphs);
            }
            delete loading[range];
        });
    }
};

GlyphSource.prototype.getGlyphAtlas = function(fontstack) {
    return this.atlases[fontstack];
};

/**
 * Use CNAME sharding to load a specific glyph range over a randomized
 * but consistent subdomain.
 * @param {string} fontstack comma-joined fonts
 * @param {string} range comma-joined range
 * @param {url} url templated url
 * @param {string} [subdomains=abc] subdomains as a string where each letter is one.
 * @returns {string} a url to load that section of glyphs
 * @private
 */
function glyphUrl(fontstack, range, url, subdomains) {
    subdomains = subdomains || 'abc';

    return url
        .replace('{s}', subdomains[fontstack.length % subdomains.length])
        .replace('{fontstack}', fontstack)
        .replace('{range}', range);
}

},{"../symbol/glyph_atlas":64,"../util/ajax":88,"../util/glyphs":96,"../util/mapbox":101,"pbf":160}],66:[function(require,module,exports){
'use strict';

module.exports = function (features, textFeatures, geometries) {

    var leftIndex = {},
        rightIndex = {},
        mergedFeatures = [],
        mergedGeom = [],
        mergedTexts = [],
        mergedIndex = 0,
        k;

    function add(k) {
        mergedFeatures.push(features[k]);
        mergedGeom.push(geometries[k]);
        mergedTexts.push(textFeatures[k]);
        mergedIndex++;
    }

    function mergeFromRight(leftKey, rightKey, geom) {
        var i = rightIndex[leftKey];
        delete rightIndex[leftKey];
        rightIndex[rightKey] = i;

        mergedGeom[i][0].pop();
        mergedGeom[i][0] = mergedGeom[i][0].concat(geom[0]);
        return i;
    }

    function mergeFromLeft(leftKey, rightKey, geom) {
        var i = leftIndex[rightKey];
        delete leftIndex[rightKey];
        leftIndex[leftKey] = i;

        mergedGeom[i][0].shift();
        mergedGeom[i][0] = geom[0].concat(mergedGeom[i][0]);
        return i;
    }

    function getKey(text, geom, onRight) {
        var point = onRight ? geom[0][geom[0].length - 1] : geom[0][0];
        return text + ':' + point.x + ':' + point.y;
    }

    for (k = 0; k < features.length; k++) {
        var geom = geometries[k],
            text = textFeatures[k];

        if (!text) {
            add(k);
            continue;
        }

        var leftKey = getKey(text, geom),
            rightKey = getKey(text, geom, true);

        if ((leftKey in rightIndex) && (rightKey in leftIndex) && (rightIndex[leftKey] !== leftIndex[rightKey])) {
            // found lines with the same text adjacent to both ends of the current line, merge all three
            var j = mergeFromLeft(leftKey, rightKey, geom);
            var i = mergeFromRight(leftKey, rightKey, mergedGeom[j]);

            delete leftIndex[leftKey];
            delete rightIndex[rightKey];

            rightIndex[getKey(text, mergedGeom[i], true)] = i;
            mergedGeom[j] = null;

        } else if (leftKey in rightIndex) {
            // found mergeable line adjacent to the start of the current line, merge
            mergeFromRight(leftKey, rightKey, geom);

        } else if (rightKey in leftIndex) {
            // found mergeable line adjacent to the end of the current line, merge
            mergeFromLeft(leftKey, rightKey, geom);

        } else {
            // no adjacent lines, add as a new item
            add(k);
            leftIndex[leftKey] = mergedIndex - 1;
            rightIndex[rightKey] = mergedIndex - 1;
        }
    }

    return {
        features: mergedFeatures,
        textFeatures: mergedTexts,
        geometries: mergedGeom
    };
};

},{}],67:[function(require,module,exports){
'use strict';

var Point = require('point-geometry');

module.exports = {
    getIconQuads: getIconQuads,
    getGlyphQuads: getGlyphQuads
};

var minScale = 0.5; // underscale by 1 zoom level

/**
 * A textured quad for rendering a single icon or glyph.
 *
 * The zoom range the glyph can be shown is defined by minScale and maxScale.
 *
 * @param {Point} anchorPoint the point the symbol is anchored around
 * @param {Point} tl The offset of the top left corner from the anchor.
 * @param {Point} tr The offset of the top right corner from the anchor.
 * @param {Point} bl The offset of the bottom left corner from the anchor.
 * @param {Point} br The offset of the bottom right corner from the anchor.
 * @param {Object} tex The texture coordinates.
 * @param {number} angle The angle of the label at it's center, not the angle of this quad.
 * @param {number} minScale The minimum scale, relative to the tile's intended scale, that the glyph can be shown at.
 * @param {number} maxScale The maximum scale, relative to the tile's intended scale, that the glyph can be shown at.
 *
 * @class SymbolQuad
 * @private
 */
function SymbolQuad(anchorPoint, tl, tr, bl, br, tex, angle, minScale, maxScale) {
    this.anchorPoint = anchorPoint;
    this.tl = tl;
    this.tr = tr;
    this.bl = bl;
    this.br = br;
    this.tex = tex;
    this.angle = angle;
    this.minScale = minScale;
    this.maxScale = maxScale;
}

/**
 * Create the quads used for rendering an icon.
 *
 * @param {Anchor} anchor
 * @param {PositionedIcon} shapedIcon
 * @param {number} boxScale A magic number for converting glyph metric units to geometry units.
 * @param {Array<Array<Point>>} line
 * @param {LayoutProperties} layout
 * @param {boolean} alongLine Whether the icon should be placed along the line.
 * @returns {Array<SymbolQuad>}
 * @private
 */
function getIconQuads(anchor, shapedIcon, boxScale, line, layout, alongLine) {

    var rect = shapedIcon.image.rect;

    var border = 1;
    var left = shapedIcon.left - border;
    var right = left + rect.w / shapedIcon.image.pixelRatio;
    var top = shapedIcon.top - border;
    var bottom = top + rect.h / shapedIcon.image.pixelRatio;
    var tl = new Point(left, top);
    var tr = new Point(right, top);
    var br = new Point(right, bottom);
    var bl = new Point(left, bottom);

    var angle = layout['icon-rotate'] * Math.PI / 180;
    if (alongLine) {
        var prev = line[anchor.segment];
        if (anchor.y === prev.y && anchor.x === prev.x && anchor.segment + 1 < line.length) {
            var next = line[anchor.segment + 1];
            angle += Math.atan2(anchor.y - next.y, anchor.x - next.x) + Math.PI;
        } else {
            angle += Math.atan2(anchor.y - prev.y, anchor.x - prev.x);
        }
    }

    if (angle) {
        var sin = Math.sin(angle),
            cos = Math.cos(angle),
            matrix = [cos, -sin, sin, cos];

        tl = tl.matMult(matrix);
        tr = tr.matMult(matrix);
        bl = bl.matMult(matrix);
        br = br.matMult(matrix);
    }

    return [new SymbolQuad(new Point(anchor.x, anchor.y), tl, tr, bl, br, shapedIcon.image.rect, 0, minScale, Infinity)];
}

/**
 * Create the quads used for rendering a text label.
 *
 * @param {Anchor} anchor
 * @param {Shaping} shaping
 * @param {number} boxScale A magic number for converting from glyph metric units to geometry units.
 * @param {Array<Array<Point>>} line
 * @param {LayoutProperties} layout
 * @param {boolean} alongLine Whether the label should be placed along the line.
 * @returns {Array<SymbolQuad>}
 * @private
 */
function getGlyphQuads(anchor, shaping, boxScale, line, layout, alongLine) {

    var textRotate = layout['text-rotate'] * Math.PI / 180;
    var keepUpright = layout['text-keep-upright'];

    var positionedGlyphs = shaping.positionedGlyphs;
    var quads = [];

    for (var k = 0; k < positionedGlyphs.length; k++) {
        var positionedGlyph = positionedGlyphs[k];
        var glyph = positionedGlyph.glyph;
        var rect = glyph.rect;

        if (!rect) continue;

        var centerX = (positionedGlyph.x + glyph.advance / 2) * boxScale;

        var glyphInstances;
        var labelMinScale = minScale;
        if (alongLine) {
            glyphInstances = [];
            labelMinScale = getSegmentGlyphs(glyphInstances, anchor, centerX, line, anchor.segment, true);
            if (keepUpright) {
                labelMinScale = Math.min(labelMinScale, getSegmentGlyphs(glyphInstances, anchor, centerX, line, anchor.segment, false));
            }

        } else {
            glyphInstances = [{
                anchorPoint: new Point(anchor.x, anchor.y),
                offset: 0,
                angle: 0,
                maxScale: Infinity,
                minScale: minScale
            }];
        }

        var x1 = positionedGlyph.x + glyph.left,
            y1 = positionedGlyph.y - glyph.top,
            x2 = x1 + rect.w,
            y2 = y1 + rect.h,

            otl = new Point(x1, y1),
            otr = new Point(x2, y1),
            obl = new Point(x1, y2),
            obr = new Point(x2, y2);

        for (var i = 0; i < glyphInstances.length; i++) {

            var instance = glyphInstances[i],
                tl = otl,
                tr = otr,
                bl = obl,
                br = obr,
                angle = instance.angle + textRotate;

            if (angle) {
                var sin = Math.sin(angle),
                    cos = Math.cos(angle),
                    matrix = [cos, -sin, sin, cos];

                tl = tl.matMult(matrix);
                tr = tr.matMult(matrix);
                bl = bl.matMult(matrix);
                br = br.matMult(matrix);
            }

            // Prevent label from extending past the end of the line
            var glyphMinScale = Math.max(instance.minScale, labelMinScale);

            var glyphAngle = (anchor.angle + textRotate + instance.offset + 2 * Math.PI) % (2 * Math.PI);
            quads.push(new SymbolQuad(instance.anchorPoint, tl, tr, bl, br, rect, glyphAngle, glyphMinScale, instance.maxScale));

        }
    }

    return quads;
}

/**
 * We can only render glyph quads that slide along a straight line. To draw
 * curved lines we need an instance of a glyph for each segment it appears on.
 * This creates all the instances of a glyph that are necessary to render a label.
 *
 * We need a
 * @param {Array<Object>} glyphInstances An empty array that glyphInstances are added to.
 * @param {Anchor} anchor
 * @param {number} offset The glyph's offset from the center of the label.
 * @param {Array<Point>} line
 * @param {number} segment The index of the segment of the line on which the anchor exists.
 * @param {boolean} forward If true get the glyphs that come later on the line, otherwise get the glyphs that come earlier.
 *
 * @returns {Array<Object>} glyphInstances
 * @private
 */
function getSegmentGlyphs(glyphs, anchor, offset, line, segment, forward) {
    var upsideDown = !forward;

    if (offset < 0) forward = !forward;

    if (forward) segment++;

    var newAnchorPoint = new Point(anchor.x, anchor.y);
    var end = line[segment];
    var prevScale = Infinity;

    offset = Math.abs(offset);

    var placementScale = minScale;

    while (true) {
        var distance = newAnchorPoint.dist(end);
        var scale = offset / distance;

        // Get the angle of the line segment
        var angle = Math.atan2(end.y - newAnchorPoint.y, end.x - newAnchorPoint.x);
        if (!forward) angle += Math.PI;
        if (upsideDown) angle += Math.PI;

        glyphs.push({
            anchorPoint: newAnchorPoint,
            offset: upsideDown ? Math.PI : 0,
            minScale: scale,
            maxScale: prevScale,
            angle: (angle + 2 * Math.PI) % (2 * Math.PI)
        });

        if (scale <= placementScale) break;

        newAnchorPoint = end;

        // skip duplicate nodes
        while (newAnchorPoint.equals(end)) {
            segment += forward ? 1 : -1;
            end = line[segment];
            if (!end) {
                return scale;
            }
        }

        var unit = end.sub(newAnchorPoint)._unit();
        newAnchorPoint = newAnchorPoint.sub(unit._mult(distance));

        prevScale = scale;
    }

    return placementScale;
}

},{"point-geometry":162}],68:[function(require,module,exports){
'use strict';

var resolveTokens = require('../util/token');

module.exports = resolveText;

/**
 * For an array of features determine what glyphs need to be loaded
 * and apply any text preprocessing. The remaining users of text should
 * use the `textFeatures` key returned by this function rather than accessing
 * feature text directly.
 * @private
 */
function resolveText(features, layoutProperties, codepoints) {
    var textFeatures = [];

    for (var i = 0, fl = features.length; i < fl; i++) {
        var text = resolveTokens(features[i].properties, layoutProperties['text-field']);
        if (!text) {
            textFeatures[i] = null;
            continue;
        }
        text = text.toString();

        var transform = layoutProperties['text-transform'];
        if (transform === 'uppercase') {
            text = text.toLocaleUpperCase();
        } else if (transform === 'lowercase') {
            text = text.toLocaleLowerCase();
        }

        for (var j = 0; j < text.length; j++) {
            codepoints[text.charCodeAt(j)] = true;
        }

        // Track indexes of features with text.
        textFeatures[i] = text;
    }

    return textFeatures;
}

},{"../util/token":103}],69:[function(require,module,exports){
'use strict';

module.exports = {
    shapeText: shapeText,
    shapeIcon: shapeIcon
};


// The position of a glyph relative to the text's anchor point.
function PositionedGlyph(codePoint, x, y, glyph) {
    this.codePoint = codePoint;
    this.x = x;
    this.y = y;
    this.glyph = glyph;
}

// A collection of positioned glyphs and some metadata
function Shaping(positionedGlyphs, text, top, bottom, left, right) {
    this.positionedGlyphs = positionedGlyphs;
    this.text = text;
    this.top = top;
    this.bottom = bottom;
    this.left = left;
    this.right = right;
}

function shapeText(text, glyphs, maxWidth, lineHeight, horizontalAlign, verticalAlign, justify, spacing, translate) {

    var positionedGlyphs = [];
    var shaping = new Shaping(positionedGlyphs, text, translate[1], translate[1], translate[0], translate[0]);

    // the y offset *should* be part of the font metadata
    var yOffset = -17;

    var x = 0;
    var y = yOffset;

    for (var i = 0; i < text.length; i++) {
        var codePoint = text.charCodeAt(i);
        var glyph = glyphs[codePoint];

        if (!glyph) continue;

        positionedGlyphs.push(new PositionedGlyph(codePoint, x, y, glyph));
        x += glyph.advance + spacing;
    }

    if (!positionedGlyphs.length) return false;

    linewrap(shaping, glyphs, lineHeight, maxWidth, horizontalAlign, verticalAlign, justify, translate);

    return shaping;
}

var invisible = {
    0x20:   true, // space
    0x200b: true  // zero-width space
};

var breakable = {
    0x20:   true, // space
    0x26:   true, // ampersand
    0x2b:   true, // plus sign
    0x2d:   true, // hyphen-minus
    0x2f:   true, // solidus
    0xad:   true, // soft hyphen
    0xb7:   true, // middle dot
    0x200b: true, // zero-width space
    0x2010: true, // hyphen
    0x2013: true  // en dash
};

function linewrap(shaping, glyphs, lineHeight, maxWidth, horizontalAlign, verticalAlign, justify, translate) {
    var lastSafeBreak = null;

    var lengthBeforeCurrentLine = 0;
    var lineStartIndex = 0;
    var line = 0;

    var maxLineLength = 0;

    var positionedGlyphs = shaping.positionedGlyphs;

    if (maxWidth) {
        for (var i = 0; i < positionedGlyphs.length; i++) {
            var positionedGlyph = positionedGlyphs[i];

            positionedGlyph.x -= lengthBeforeCurrentLine;
            positionedGlyph.y += lineHeight * line;

            if (positionedGlyph.x > maxWidth && lastSafeBreak !== null) {

                var lineLength = positionedGlyphs[lastSafeBreak + 1].x;
                maxLineLength = Math.max(lineLength, maxLineLength);

                for (var k = lastSafeBreak + 1; k <= i; k++) {
                    positionedGlyphs[k].y += lineHeight;
                    positionedGlyphs[k].x -= lineLength;
                }

                if (justify) {
                    // Collapse invisible characters.
                    var lineEnd = lastSafeBreak;
                    if (invisible[positionedGlyphs[lastSafeBreak].codePoint]) {
                        lineEnd--;
                    }

                    justifyLine(positionedGlyphs, glyphs, lineStartIndex, lineEnd, justify);
                }

                lineStartIndex = lastSafeBreak + 1;
                lastSafeBreak = null;
                lengthBeforeCurrentLine += lineLength;
                line++;
            }

            if (breakable[positionedGlyph.codePoint]) {
                lastSafeBreak = i;
            }
        }
    }

    var lastPositionedGlyph = positionedGlyphs[positionedGlyphs.length - 1];
    var lastLineLength = lastPositionedGlyph.x + glyphs[lastPositionedGlyph.codePoint].advance;
    maxLineLength = Math.max(maxLineLength, lastLineLength);

    var height = (line + 1) * lineHeight;

    justifyLine(positionedGlyphs, glyphs, lineStartIndex, positionedGlyphs.length - 1, justify);
    align(positionedGlyphs, justify, horizontalAlign, verticalAlign, maxLineLength, lineHeight, line, translate);

    // Calculate the bounding box
    shaping.top += -verticalAlign * height;
    shaping.bottom = shaping.top + height;
    shaping.left += -horizontalAlign * maxLineLength;
    shaping.right = shaping.left + maxLineLength;
}

function justifyLine(positionedGlyphs, glyphs, start, end, justify) {
    var lastAdvance = glyphs[positionedGlyphs[end].codePoint].advance;
    var lineIndent = (positionedGlyphs[end].x + lastAdvance) * justify;

    for (var j = start; j <= end; j++) {
        positionedGlyphs[j].x -= lineIndent;
    }

}

function align(positionedGlyphs, justify, horizontalAlign, verticalAlign, maxLineLength, lineHeight, line, translate) {
    var shiftX = (justify - horizontalAlign) * maxLineLength + translate[0];
    var shiftY = (-verticalAlign * (line + 1) + 0.5) * lineHeight + translate[1];

    for (var j = 0; j < positionedGlyphs.length; j++) {
        positionedGlyphs[j].x += shiftX;
        positionedGlyphs[j].y += shiftY;
    }
}


function shapeIcon(image, layout) {
    if (!image || !image.rect) return null;

    var dx = layout['icon-offset'][0];
    var dy = layout['icon-offset'][1];
    var x1 = dx - image.width / 2;
    var x2 = x1 + image.width;
    var y1 = dy - image.height / 2;
    var y2 = y1 + image.height;

    return new PositionedIcon(image, y1, y2, x1, x2);
}

function PositionedIcon(image, top, bottom, left, right) {
    this.image = image;
    this.top = top;
    this.bottom = bottom;
    this.left = left;
    this.right = right;
}

},{}],70:[function(require,module,exports){
'use strict';

var ShelfPack = require('shelf-pack');
var browser = require('../util/browser');

module.exports = SpriteAtlas;
function SpriteAtlas(width, height) {
    this.width = width;
    this.height = height;

    this.bin = new ShelfPack(width, height);
    this.images = {};
    this.data = false;
    this.texture = 0; // WebGL ID
    this.filter = 0; // WebGL ID
    this.pixelRatio = 1;
    this.dirty = true;
}

function copyBitmap(src, srcStride, srcX, srcY, dst, dstStride, dstX, dstY, width, height, wrap) {
    var srcI = srcY * srcStride + srcX;
    var dstI = dstY * dstStride + dstX;
    var x, y;

    if (wrap) {
        // add 1 pixel wrapped padding on each side of the image
        dstI -= dstStride;
        for (y = -1; y <= height; y++, srcI = ((y + height) % height + srcY) * srcStride + srcX, dstI += dstStride) {
            for (x = -1; x <= width; x++) {
                dst[dstI + x] = src[srcI + ((x + width) % width)];
            }
        }

    } else {
        for (y = 0; y < height; y++, srcI += srcStride, dstI += dstStride) {
            for (x = 0; x < width; x++) {
                dst[dstI + x] = src[srcI + x];
            }
        }
    }
}

SpriteAtlas.prototype.allocateImage = function(pixelWidth, pixelHeight) {

    pixelWidth = pixelWidth / this.pixelRatio;
    pixelHeight = pixelHeight / this.pixelRatio;

    // Increase to next number divisible by 4, but at least 1.
    // This is so we can scale down the texture coordinates and pack them
    // into 2 bytes rather than 4 bytes.
    // Pad icons to prevent them from polluting neighbours during linear interpolation
    var padding = 2;
    var packWidth = pixelWidth + padding + (4 - (pixelWidth + padding) % 4);
    var packHeight = pixelHeight + padding + (4 - (pixelHeight + padding) % 4);// + 4;

    // We have to allocate a new area in the bin, and store an empty image in it.
    // Add a 1px border around every image.
    var rect = this.bin.allocate(packWidth, packHeight);
    if (rect.x < 0) {
        console.warn('SpriteAtlas out of space.');
        return rect;
    }

    return rect;
};

SpriteAtlas.prototype.getImage = function(name, wrap) {
    if (this.images[name]) {
        return this.images[name];
    }

    if (!this.sprite) {
        return null;
    }

    var pos = this.sprite.getSpritePosition(name);
    if (!pos.width || !pos.height) {
        return null;
    }

    var rect = this.allocateImage(pos.width, pos.height);
    if (rect.x < 0) {
        return rect;
    }

    var image = new AtlasImage(rect, pos.width / pos.pixelRatio, pos.height / pos.pixelRatio, pos.sdf, pos.pixelRatio / this.pixelRatio);
    this.images[name] = image;

    this.copy(rect, pos, wrap);

    return image;
};


// Return position of a repeating fill pattern.
SpriteAtlas.prototype.getPosition = function(name, repeating) {
    var image = this.getImage(name, repeating);
    var rect = image && image.rect;

    if (!rect) {
        return null;
    }

    var width = image.width * image.pixelRatio;
    var height = image.height * image.pixelRatio;
    var padding = 1;

    return {
        size: [image.width, image.height],
        tl: [(rect.x + padding)         / this.width, (rect.y + padding)          / this.height],
        br: [(rect.x + padding + width) / this.width, (rect.y + padding + height) / this.height]
    };
};


SpriteAtlas.prototype.allocate = function() {
    if (!this.data) {
        var w = Math.floor(this.width * this.pixelRatio);
        var h = Math.floor(this.height * this.pixelRatio);
        this.data = new Uint32Array(w * h);
        for (var i = 0; i < this.data.length; i++) {
            this.data[i] = 0;
        }
    }
};


SpriteAtlas.prototype.copy = function(dst, src, wrap) {
    if (!this.sprite.img.data) return;
    var srcImg = new Uint32Array(this.sprite.img.data.buffer);

    this.allocate();
    var dstImg = this.data;

    var padding = 1;

    copyBitmap(
        /* source buffer */  srcImg,
        /* source stride */  this.sprite.img.width,
        /* source x */       src.x,
        /* source y */       src.y,
        /* dest buffer */    dstImg,
        /* dest stride */    this.width * this.pixelRatio,
        /* dest x */         (dst.x + padding) * this.pixelRatio,
        /* dest y */         (dst.y + padding) * this.pixelRatio,
        /* icon dimension */ src.width,
        /* icon dimension */ src.height,
        /* wrap */ wrap
    );

    this.dirty = true;
};

SpriteAtlas.prototype.setSprite = function(sprite) {
    if (sprite) {
        this.pixelRatio = browser.devicePixelRatio > 1 ? 2 : 1;

        if (this.canvas) {
            this.canvas.width = this.width * this.pixelRatio;
            this.canvas.height = this.height * this.pixelRatio;
        }
    }
    this.sprite = sprite;
};

SpriteAtlas.prototype.addIcons = function(icons, callback) {
    for (var i = 0; i < icons.length; i++) {
        this.getImage(icons[i]);
    }

    callback(null, this.images);
};

SpriteAtlas.prototype.bind = function(gl, linear) {
    var first = false;
    if (!this.texture) {
        this.texture = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, this.texture);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        first = true;
    } else {
        gl.bindTexture(gl.TEXTURE_2D, this.texture);
    }

    var filterVal = linear ? gl.LINEAR : gl.NEAREST;
    if (filterVal !== this.filter) {
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, filterVal);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, filterVal);
        this.filter = filterVal;
    }

    if (this.dirty) {
        this.allocate();

        if (first) {
            gl.texImage2D(
                gl.TEXTURE_2D, // enum target
                0, // ind level
                gl.RGBA, // ind internalformat
                this.width * this.pixelRatio, // GLsizei width
                this.height * this.pixelRatio, // GLsizei height
                0, // ind border
                gl.RGBA, // enum format
                gl.UNSIGNED_BYTE, // enum type
                new Uint8Array(this.data.buffer) // Object data
            );
        } else {
            gl.texSubImage2D(
                gl.TEXTURE_2D, // enum target
                0, // int level
                0, // int xoffset
                0, // int yoffset
                this.width * this.pixelRatio, // long width
                this.height * this.pixelRatio, // long height
                gl.RGBA, // enum format
                gl.UNSIGNED_BYTE, // enum type
                new Uint8Array(this.data.buffer) // Object pixels
            );
        }

        this.dirty = false;
    }
};

function AtlasImage(rect, width, height, sdf, pixelRatio) {
    this.rect = rect;
    this.width = width;
    this.height = height;
    this.sdf = sdf;
    this.pixelRatio = pixelRatio;
}

},{"../util/browser":89,"shelf-pack":165}],71:[function(require,module,exports){
'use strict';

var util = require('../util/util');
var interpolate = require('../util/interpolate');
var browser = require('../util/browser');
var LngLat = require('../geo/lng_lat');
var LngLatBounds = require('../geo/lng_lat_bounds');
var Point = require('point-geometry');

/**
 * Options common to Map#jumpTo, Map#easeTo, and Map#flyTo, controlling the destination
 * location, zoom level, bearing and pitch. All properties are options; unspecified
 * options will default to the current value for that property.
 *
 * @typedef {Object} CameraOptions
 * @property {LngLat} center Map center
 * @property {number} zoom Map zoom level
 * @property {number} bearing Map rotation bearing in degrees counter-clockwise from north
 * @property {number} pitch Map angle in degrees at which the camera is looking at the ground
 * @property {LngLat} around If zooming, the zoom center (defaults to map center)
 */

/**
 * Options common to map movement methods that involve animation, such as Map#panBy and
 * Map#easeTo, controlling the duration of the animation and easing function. All properties
 * are optional.
 *
 * @typedef {Object} AnimationOptions
 * @property {number} duration Number in milliseconds
 * @property {Function} easing
 * @property {Array} offset point, origin of movement relative to map center
 * @property {boolean} animate When set to false, no animation happens
 */

var Camera = module.exports = function() {};

util.extend(Camera.prototype, /** @lends Map.prototype */{
    /**
     * Get the current view geographical point.
     * @returns {LngLat}
     */
    getCenter: function() { return this.transform.center; },

    /**
     * Sets a map location. Equivalent to `jumpTo({center: center})`.
     *
     * @param {LngLat} center Map center to jump to
     * @param {EventData} [eventData] Data to propagate to any event receivers
     * @fires movestart
     * @fires moveend
     * @returns {Map} `this`
     * @example
     * map.setCenter([-74, 38]);
     */
    setCenter: function(center, eventData) {
        this.jumpTo({center: center}, eventData);
        return this;
    },

    /**
     * Pan by a certain number of pixels
     *
     * @param {Array<number>} offset [x, y]
     * @param {AnimationOptions} [options]
     * @param {EventData} [eventData] Data to propagate to any event receivers
     * @fires movestart
     * @fires moveend
     * @returns {Map} `this`
     */
    panBy: function(offset, options, eventData) {
        this.panTo(this.transform.center,
            util.extend({offset: Point.convert(offset).mult(-1)}, options), eventData);
        return this;
    },

    /**
     * Pan to a certain location with easing
     *
     * @param {LngLat} lnglat Location to pan to
     * @param {AnimationOptions} [options]
     * @param {EventData} [eventData] Data to propagate to any event receivers
     * @fires movestart
     * @fires moveend
     * @returns {Map} `this`
     */
    panTo: function(lnglat, options, eventData) {
        return this.easeTo(util.extend({
            center: lnglat
        }, options), eventData);
    },


    /**
     * Get the current zoom
     * @returns {number}
     */
    getZoom: function() { return this.transform.zoom; },

    /**
     * Sets a map zoom. Equivalent to `jumpTo({zoom: zoom})`.
     *
     * @param {number} zoom Map zoom level
     * @param {EventData} [eventData] Data to propagate to any event receivers
     * @fires movestart
     * @fires zoomstart
     * @fires move
     * @fires zoom
     * @fires moveend
     * @fires zoomend
     * @returns {Map} `this`
     * @example
     * // zoom the map to 5
     * map.setZoom(5);
     */
    setZoom: function(zoom, eventData) {
        this.jumpTo({zoom: zoom}, eventData);
        return this;
    },

    /**
     * Zooms to a certain zoom level with easing.
     *
     * @param {number} zoom
     * @param {AnimationOptions} [options]
     * @param {EventData} [eventData] Data to propagate to any event receivers
     * @fires movestart
     * @fires zoomstart
     * @fires move
     * @fires zoom
     * @fires moveend
     * @fires zoomend
     * @returns {Map} `this`
     */
    zoomTo: function(zoom, options, eventData) {
        return this.easeTo(util.extend({
            zoom: zoom
        }, options), eventData);
    },

    /**
     * Zoom in by 1 level
     *
     * @param {AnimationOptions} [options]
     * @param {EventData} [eventData] Data to propagate to any event receivers
     * @fires movestart
     * @fires zoomstart
     * @fires move
     * @fires zoom
     * @fires moveend
     * @fires zoomend
     * @returns {Map} `this`
     */
    zoomIn: function(options, eventData) {
        this.zoomTo(this.getZoom() + 1, options, eventData);
        return this;
    },

    /**
     * Zoom out by 1 level
     *
     * @param {AnimationOptions} [options]
     * @param {EventData} [eventData] Data to propagate to any event receivers
     * @fires movestart
     * @fires zoomstart
     * @fires move
     * @fires zoom
     * @fires moveend
     * @fires zoomend
     * @returns {Map} `this`
     */
    zoomOut: function(options, eventData) {
        this.zoomTo(this.getZoom() - 1, options, eventData);
        return this;
    },


    /**
     * Get the current bearing in degrees
     * @returns {number}
     */
    getBearing: function() { return this.transform.bearing; },

    /**
     * Sets a map rotation. Equivalent to `jumpTo({bearing: bearing})`.
     *
     * @param {number} bearing Map rotation bearing in degrees counter-clockwise from north
     * @param {EventData} [eventData] Data to propagate to any event receivers
     * @fires movestart
     * @fires moveend
     * @returns {Map} `this`
     * @example
     * // rotate the map to 90 degrees
     * map.setBearing(90);
     */
    setBearing: function(bearing, eventData) {
        this.jumpTo({bearing: bearing}, eventData);
        return this;
    },

    /**
     * Rotate bearing by a certain number of degrees with easing
     *
     * @param {number} bearing
     * @param {AnimationOptions} [options]
     * @param {EventData} [eventData] Data to propagate to any event receivers
     * @fires movestart
     * @fires moveend
     * @returns {Map} `this`
     */
    rotateTo: function(bearing, options, eventData) {
        return this.easeTo(util.extend({
            bearing: bearing
        }, options), eventData);
    },

    /**
     * Sets map bearing to 0 (north) with easing
     *
     * @param {AnimationOptions} [options]
     * @param {EventData} [eventData] Data to propagate to any event receivers
     * @fires movestart
     * @fires moveend
     * @returns {Map} `this`
     */
    resetNorth: function(options, eventData) {
        this.rotateTo(0, util.extend({duration: 1000}, options), eventData);
        return this;
    },

    /**
     * Animates map bearing to 0 (north) if it's already close to it.
     *
     * @param {AnimationOptions} [options]
     * @param {EventData} [eventData] Data to propagate to any event receivers
     * @fires movestart
     * @fires moveend
     * @returns {Map} `this`
     */
    snapToNorth: function(options, eventData) {
        if (Math.abs(this.getBearing()) < this.options.bearingSnap) {
            return this.resetNorth(options, eventData);
        }
        return this;
    },

    /**
     * Get the current angle in degrees
     * @returns {number}
     */
    getPitch: function() { return this.transform.pitch; },

    /**
     * Sets a map angle. Equivalent to `jumpTo({pitch: pitch})`.
     *
     * @param {number} pitch The angle at which the camera is looking at the ground
     * @param {EventData} [eventData] Data to propagate to any event receivers
     * @fires movestart
     * @fires moveend
     * @returns {Map} `this`
     */
    setPitch: function(pitch, eventData) {
        this.jumpTo({pitch: pitch}, eventData);
        return this;
    },


    /**
     * Zoom to contain certain geographical bounds
     *
     * @param {LngLatBounds|Array<Array<number>>} bounds [[minLng, minLat], [maxLng, maxLat]]
     * @param {Object} options
     * @param {boolean} [options.linear] When true, the map transitions to the new camera using
     *     {@link #Map.easeTo}. When false, the map transitions using {@link #Map.flyTo}. See
     *     {@link #Map.flyTo} for information on options specific to that animation transition.
     * @param {Function} options.easing
     * @param {number} options.padding how much padding there is around the given bounds on each side in pixels
     * @param {number} options.maxZoom The resulting zoom level will be at most
     *     this value.
     * @param {EventData} [eventData] Data to propagate to any event receivers
     * @fires movestart
     * @fires moveend
     * @returns {Map} `this`
     */
    fitBounds: function(bounds, options, eventData) {

        options = util.extend({
            padding: 0,
            offset: [0, 0],
            maxZoom: Infinity
        }, options);

        bounds = LngLatBounds.convert(bounds);

        var offset = Point.convert(options.offset),
            tr = this.transform,
            nw = tr.project(bounds.getNorthWest()),
            se = tr.project(bounds.getSouthEast()),
            size = se.sub(nw),
            scaleX = (tr.width - options.padding * 2 - Math.abs(offset.x) * 2) / size.x,
            scaleY = (tr.height - options.padding * 2 - Math.abs(offset.y) * 2) / size.y;

        options.center = tr.unproject(nw.add(se).div(2));
        options.zoom = Math.min(tr.scaleZoom(tr.scale * Math.min(scaleX, scaleY)), options.maxZoom);
        options.bearing = 0;

        return options.linear ?
            this.easeTo(options, eventData) :
            this.flyTo(options, eventData);
    },

    /**
     * Change any combination of center, zoom, bearing, and pitch, without
     * a transition. The map will retain the current values for any options
     * not included in `options`.
     *
     * @param {CameraOptions} options map view options
     * @param {EventData} [eventData] Data to propagate to any event receivers
     * @fires movestart
     * @fires zoomstart
     * @fires move
     * @fires zoom
     * @fires rotate
     * @fires pitch
     * @fires zoomend
     * @fires moveend
     * @returns {Map} `this`
     */
    jumpTo: function(options, eventData) {
        this.stop();

        var tr = this.transform,
            zoomChanged = false,
            bearingChanged = false,
            pitchChanged = false;

        if ('zoom' in options && tr.zoom !== +options.zoom) {
            zoomChanged = true;
            tr.zoom = +options.zoom;
        }

        if ('center' in options) {
            tr.center = LngLat.convert(options.center);
        }

        if ('bearing' in options && tr.bearing !== +options.bearing) {
            bearingChanged = true;
            tr.bearing = +options.bearing;
        }

        if ('pitch' in options && tr.pitch !== +options.pitch) {
            pitchChanged = true;
            tr.pitch = +options.pitch;
        }

        this.fire('movestart', eventData)
            .fire('move', eventData);

        if (zoomChanged) {
            this.fire('zoomstart', eventData)
                .fire('zoom', eventData)
                .fire('zoomend', eventData);
        }

        if (bearingChanged) {
            this.fire('rotate', eventData);
        }

        if (pitchChanged) {
            this.fire('pitch', eventData);
        }

        return this.fire('moveend', eventData);
    },

    /**
     * Change any combination of center, zoom, bearing, and pitch, with a smooth animation
     * between old and new values. The map will retain the current values for any options
     * not included in `options`.
     *
     * @param {CameraOptions|AnimationOptions} options map view and animation options
     * @param {EventData} [eventData] Data to propagate to any event receivers
     * @fires movestart
     * @fires zoomstart
     * @fires move
     * @fires zoom
     * @fires rotate
     * @fires pitch
     * @fires zoomend
     * @fires moveend
     * @returns {Map} `this`
     */
    easeTo: function(options, eventData) {
        this.stop();

        options = util.extend({
            offset: [0, 0],
            duration: 500,
            easing: util.ease
        }, options);

        var tr = this.transform,
            offset = Point.convert(options.offset),
            startZoom = this.getZoom(),
            startBearing = this.getBearing(),
            startPitch = this.getPitch(),

            zoom = 'zoom' in options ? +options.zoom : startZoom,
            bearing = 'bearing' in options ? this._normalizeBearing(options.bearing, startBearing) : startBearing,
            pitch = 'pitch' in options ? +options.pitch : startPitch,

            toLngLat,
            toPoint;

        if ('center' in options) {
            toLngLat = LngLat.convert(options.center);
            toPoint = tr.centerPoint.add(offset);
        } else if ('around' in options) {
            toLngLat = LngLat.convert(options.around);
            toPoint = tr.locationPoint(toLngLat);
        } else {
            toPoint = tr.centerPoint.add(offset);
            toLngLat = tr.pointLocation(toPoint);
        }

        var fromPoint = tr.locationPoint(toLngLat);

        if (options.animate === false) options.duration = 0;

        this.zooming = (zoom !== startZoom);
        this.rotating = (startBearing !== bearing);
        this.pitching = (pitch !== startPitch);

        if (!options.noMoveStart) {
            this.fire('movestart', eventData);
        }
        if (this.zooming) {
            this.fire('zoomstart', eventData);
        }

        clearTimeout(this._onEaseEnd);

        this._ease(function (k) {
            if (this.zooming) {
                tr.zoom = interpolate(startZoom, zoom, k);
            }

            if (this.rotating) {
                tr.bearing = interpolate(startBearing, bearing, k);
            }

            if (this.pitching) {
                tr.pitch = interpolate(startPitch, pitch, k);
            }

            tr.setLocationAtPoint(toLngLat, fromPoint.add(toPoint.sub(fromPoint)._mult(k)));

            this.fire('move', eventData);
            if (this.zooming) {
                this.fire('zoom', eventData);
            }
            if (this.rotating) {
                this.fire('rotate', eventData);
            }
            if (this.pitching) {
                this.fire('pitch', eventData);
            }
        }, function() {
            if (options.delayEndEvents) {
                this._onEaseEnd = setTimeout(this._easeToEnd.bind(this, eventData), options.delayEndEvents);
            } else {
                this._easeToEnd(eventData);
            }
        }.bind(this), options);

        return this;
    },

    _easeToEnd: function(eventData) {
        if (this.zooming) {
            this.fire('zoomend', eventData);
        }
        this.fire('moveend', eventData);

        this.zooming = false;
        this.rotating = false;
        this.pitching = false;
    },

    /**
     * Change any combination of center, zoom, bearing, and pitch, animated along a curve that
     * evokes flight. The transition animation seamlessly incorporates zooming and panning to help
     * the user find his or her bearings even after traversing a great distance.
     *
     * @param {CameraOptions|AnimationOptions} options map view and animation options
     * @param {number} [options.curve=1.42] Relative amount of zooming that takes place along the
     *     flight path. A high value maximizes zooming for an exaggerated animation, while a low
     *     value minimizes zooming for something closer to {@link #Map.easeTo}. 1.42 is the average
     *     value selected by participants in the user study in
     *     [van Wijk (2003)](https://www.win.tue.nl/~vanwijk/zoompan.pdf). A value of
     *     `Math.pow(6, 0.25)` would be equivalent to the root mean squared average velocity. A
     *     value of 1 would produce a circular motion.
     * @param {number} [options.minZoom] Zero-based zoom level at the peak of the flight path. If
     *     `options.curve` is specified, this option is ignored.
     * @param {number} [options.speed=1.2] Average speed of the animation. A speed of 1.2 means that
     *     the map appears to move along the flight path by 1.2 times `options.curve` screenfuls every
     *     second. A _screenful_ is the visible span in pixels. It does not correspond to a fixed
     *     physical distance but rather varies by zoom level.
     * @param {number} [options.screenSpeed] Average speed of the animation, measured in screenfuls
     *     per second, assuming a linear timing curve. If `options.speed` is specified, this option
     *     is ignored.
     * @param {Function} [options.easing] Transition timing curve
     * @param {EventData} [eventData] Data to propagate to any event receivers
     * @fires movestart
     * @fires zoomstart
     * @fires move
     * @fires zoom
     * @fires rotate
     * @fires pitch
     * @fires zoomend
     * @fires moveend
     * @returns {this}
     * @example
     * // fly with default options to null island
     * map.flyTo({center: [0, 0], zoom: 9});
     * // using flyTo options
     * map.flyTo({
     *   center: [0, 0],
     *   zoom: 9,
     *   speed: 0.2,
     *   curve: 1,
     *   easing: function(t) {
     *     return t;
     *   }
     * });
     */
    flyTo: function(options, eventData) {
        // This method implements an “optimal path” animation, as detailed in:
        //
        // Van Wijk, Jarke J.; Nuij, Wim A. A. “Smooth and efficient zooming and panning.” INFOVIS
        //   ’03. pp. 15–22. <https://www.win.tue.nl/~vanwijk/zoompan.pdf#page=5>.
        //
        // Where applicable, local variable documentation begins with the associated variable or
        // function in van Wijk (2003).

        this.stop();

        options = util.extend({
            offset: [0, 0],
            speed: 1.2,
            curve: 1.42,
            easing: util.ease
        }, options);

        var tr = this.transform,
            offset = Point.convert(options.offset),
            startZoom = this.getZoom(),
            startBearing = this.getBearing(),
            startPitch = this.getPitch();

        var center = 'center' in options ? LngLat.convert(options.center) : this.getCenter();
        var zoom = 'zoom' in options ?  +options.zoom : startZoom;
        var bearing = 'bearing' in options ? this._normalizeBearing(options.bearing, startBearing) : startBearing;
        var pitch = 'pitch' in options ? +options.pitch : startPitch;

        // If a path crossing the antimeridian would be shorter, extend the final coordinate so that
        // interpolating between the two endpoints will cross it.
        if (Math.abs(tr.center.lng) + Math.abs(center.lng) > 180) {
            if (tr.center.lng > 0 && center.lng < 0) {
                center.lng += 360;
            } else if (tr.center.lng < 0 && center.lng > 0) {
                center.lng -= 360;
            }
        }

        var scale = tr.zoomScale(zoom - startZoom),
            from = tr.point,
            to = 'center' in options ? tr.project(center).sub(offset.div(scale)) : from;

        var startWorldSize = tr.worldSize,
            rho = options.curve,

            // w₀: Initial visible span, measured in pixels at the initial scale.
            w0 = Math.max(tr.width, tr.height),
            // w₁: Final visible span, measured in pixels with respect to the initial scale.
            w1 = w0 / scale,
            // Length of the flight path as projected onto the ground plane, measured in pixels from
            // the world image origin at the initial scale.
            u1 = to.sub(from).mag();

        if ('minZoom' in options) {
            var minZoom = util.clamp(Math.min(options.minZoom, startZoom, zoom), tr.minZoom, tr.maxZoom);
            // w<sub>m</sub>: Maximum visible span, measured in pixels with respect to the initial
            // scale.
            var wMax = w0 / tr.zoomScale(minZoom - startZoom);
            rho = Math.sqrt(wMax / u1 * 2);
        }

        // ρ²
        var rho2 = rho * rho;

        /**
         * rᵢ: Returns the zoom-out factor at one end of the animation.
         *
         * @param i 0 for the ascent or 1 for the descent.
         * @private
         */
        function r(i) {
            var b = (w1 * w1 - w0 * w0 + (i ? -1 : 1) * rho2 * rho2 * u1 * u1) / (2 * (i ? w1 : w0) * rho2 * u1);
            return Math.log(Math.sqrt(b * b + 1) - b);
        }

        function sinh(n) { return (Math.exp(n) - Math.exp(-n)) / 2; }
        function cosh(n) { return (Math.exp(n) + Math.exp(-n)) / 2; }
        function tanh(n) { return sinh(n) / cosh(n); }

        // r₀: Zoom-out factor during ascent.
        var r0 = r(0),
            /**
             * w(s): Returns the visible span on the ground, measured in pixels with respect to the
             * initial scale.
             *
             * Assumes an angular field of view of 2 arctan ½ ≈ 53°.
             * @private
             */
            w = function (s) { return (cosh(r0) / cosh(r0 + rho * s)); },
            /**
             * u(s): Returns the distance along the flight path as projected onto the ground plane,
             * measured in pixels from the world image origin at the initial scale.
             * @private
             */
            u = function (s) { return w0 * ((cosh(r0) * tanh(r0 + rho * s) - sinh(r0)) / rho2) / u1; },
            // S: Total length of the flight path, measured in ρ-screenfuls.
            S = (r(1) - r0) / rho;

        // When u₀ = u₁, the optimal path doesn’t require both ascent and descent.
        if (Math.abs(u1) < 0.000001) {
            // Perform a more or less instantaneous transition if the path is too short.
            if (Math.abs(w0 - w1) < 0.000001) return this.easeTo(options);

            var k = w1 < w0 ? -1 : 1;
            S = Math.abs(Math.log(w1 / w0)) / rho;

            u = function() { return 0; };
            w = function(s) { return Math.exp(k * rho * s); };
        }

        if ('duration' in options) {
            options.duration = +options.duration;
        } else {
            var V = 'screenSpeed' in options ? +options.screenSpeed / rho : +options.speed;
            options.duration = 1000 * S / V;
        }

        this.zooming = true;
        if (startBearing !== bearing) this.rotating = true;
        if (startPitch !== pitch) this.pitching = true;

        this.fire('movestart', eventData);
        this.fire('zoomstart', eventData);

        this._ease(function (k) {
            // s: The distance traveled along the flight path, measured in ρ-screenfuls.
            var s = k * S,
                us = u(s);

            tr.zoom = startZoom + tr.scaleZoom(1 / w(s));
            tr.center = tr.unproject(from.add(to.sub(from).mult(us)), startWorldSize);

            if (this.rotating) {
                tr.bearing = interpolate(startBearing, bearing, k);
            }
            if (this.pitching) {
                tr.pitch = interpolate(startPitch, pitch, k);
            }

            this.fire('move', eventData);
            this.fire('zoom', eventData);
            if (this.rotating) {
                this.fire('rotate', eventData);
            }
            if (this.pitching) {
                this.fire('pitch', eventData);
            }
        }, function() {
            this.fire('zoomend', eventData);
            this.fire('moveend', eventData);
            this.zooming = false;
            this.rotating = false;
            this.pitching = false;
        }, options);

        return this;
    },

    isEasing: function() {
        return !!this._abortFn;
    },

    /**
     * Stop current animation
     *
     * @returns {Map} `this`
     */
    stop: function() {
        if (this._abortFn) {
            this._abortFn();
            this._finishEase();
        }
        return this;
    },

    _ease: function(frame, finish, options) {
        this._finishFn = finish;
        this._abortFn = browser.timed(function (t) {
            frame.call(this, options.easing(t));
            if (t === 1) {
                this._finishEase();
            }
        }, options.animate === false ? 0 : options.duration, this);
    },

    _finishEase: function() {
        delete this._abortFn;
        // The finish function might emit events which trigger new eases, which
        // set a new _finishFn. Ensure we don't delete it unintentionally.
        var finish = this._finishFn;
        delete this._finishFn;
        finish.call(this);
    },

    // convert bearing so that it's numerically close to the current one so that it interpolates properly
    _normalizeBearing: function(bearing, currentBearing) {
        bearing = util.wrap(bearing, -180, 180);
        var diff = Math.abs(bearing - currentBearing);
        if (Math.abs(bearing - 360 - currentBearing) < diff) bearing -= 360;
        if (Math.abs(bearing + 360 - currentBearing) < diff) bearing += 360;
        return bearing;
    },

    _updateEasing: function(duration, zoom, bezier) {
        var easing;

        if (this.ease) {
            var ease = this.ease,
                t = (Date.now() - ease.start) / ease.duration,
                speed = ease.easing(t + 0.01) - ease.easing(t),

                // Quick hack to make new bezier that is continuous with last
                x = 0.27 / Math.sqrt(speed * speed + 0.0001) * 0.01,
                y = Math.sqrt(0.27 * 0.27 - x * x);

            easing = util.bezier(x, y, 0.25, 1);
        } else {
            easing = bezier ? util.bezier.apply(util, bezier) : util.ease;
        }

        // store information on current easing
        this.ease = {
            start: (new Date()).getTime(),
            to: Math.pow(2, zoom),
            duration: duration,
            easing: easing
        };

        return easing;
    }
});

},{"../geo/lng_lat":10,"../geo/lng_lat_bounds":11,"../util/browser":89,"../util/interpolate":98,"../util/util":104,"point-geometry":162}],72:[function(require,module,exports){
'use strict';

var Control = require('./control');
var DOM = require('../../util/dom');
var util = require('../../util/util');

module.exports = Attribution;

/**
 * Creates an attribution control
 * @class Attribution
 * @param {Object} [options]
 * @param {string} [options.position='bottom-right'] A string indicating the control's position on the map. Options are `top-right`, `top-left`, `bottom-right`, `bottom-left`
 * @example
 * var map = new mapboxgl.Map({attributionControl: false})
 *     .addControl(new mapboxgl.Attribution({position: 'top-left'}));
 */
function Attribution(options) {
    util.setOptions(this, options);
}

Attribution.prototype = util.inherit(Control, {
    options: {
        position: 'bottom-right'
    },

    onAdd: function(map) {
        var className = 'mapboxgl-ctrl-attrib',
            container = this._container = DOM.create('div', className, map.getContainer());

        this._update();
        map.on('source.load', this._update.bind(this));
        map.on('source.change', this._update.bind(this));
        map.on('source.remove', this._update.bind(this));
        map.on('moveend', this._updateEditLink.bind(this));

        return container;
    },

    _update: function() {
        var attributions = [];

        if (this._map.style) {
            for (var id in this._map.style.sources) {
                var source = this._map.style.sources[id];
                if (source.attribution && attributions.indexOf(source.attribution) < 0) {
                    attributions.push(source.attribution);
                }
            }
        }

        this._container.innerHTML = attributions.join(' | ');
        this._editLink = this._container.getElementsByClassName('mapbox-improve-map')[0];
        this._updateEditLink();
    },

    _updateEditLink: function() {
        if (this._editLink) {
            var center = this._map.getCenter();
            this._editLink.href = 'https://www.mapbox.com/map-feedback/#/' +
                    center.lng + '/' + center.lat + '/' + Math.round(this._map.getZoom() + 1);
        }
    }
});

},{"../../util/dom":92,"../../util/util":104,"./control":73}],73:[function(require,module,exports){
'use strict';

module.exports = Control;

/**
 * A base class for map-related interface elements.
 *
 * @class Control
 */
function Control() {}

Control.prototype = {
    /**
     * Add this control to the map, returning the control itself
     * for chaining. This will insert the control's DOM element into
     * the map's DOM element if the control has a `position` specified.
     *
     * @param {Map} map
     * @returns {Control} `this`
     */
    addTo: function(map) {
        this._map = map;
        var container = this._container = this.onAdd(map);
        if (this.options && this.options.position) {
            var pos = this.options.position;
            var corner = map._controlCorners[pos];
            container.className += ' mapboxgl-ctrl';
            if (pos.indexOf('bottom') !== -1) {
                corner.insertBefore(container, corner.firstChild);
            } else {
                corner.appendChild(container);
            }
        }

        return this;
    },

    /**
     * Remove this control from the map it has been added to.
     *
     * @returns {Control} `this`
     */
    remove: function() {
        this._container.parentNode.removeChild(this._container);
        if (this.onRemove) this.onRemove(this._map);
        this._map = null;
        return this;
    }
};

},{}],74:[function(require,module,exports){
'use strict';

var Control = require('./control');
var browser = require('../../util/browser');
var DOM = require('../../util/dom');
var util = require('../../util/util');

module.exports = Geolocate;

var geoOptions = { enableHighAccuracy: false, timeout: 6000 /* 6sec */ };


/**
 * Creates a geolocation control
 * @class Geolocate
 * @param {Object} [options]
 * @param {string} [options.position='top-right'] A string indicating the control's position on the map. Options are `top-right`, `top-left`, `bottom-right`, `bottom-left`
 * @example
 * map.addControl(new mapboxgl.Geolocate({position: 'top-left'})); // position is optional
 */
function Geolocate(options) {
    util.setOptions(this, options);
}

Geolocate.prototype = util.inherit(Control, {
    options: {
        position: 'top-right'
    },

    onAdd: function(map) {
        var className = 'mapboxgl-ctrl';

        var container = this._container = DOM.create('div', className + '-group', map.getContainer());
        if (!browser.supportsGeolocation) return container;

        this._container.addEventListener('contextmenu', this._onContextMenu.bind(this));

        this._geolocateButton = DOM.create('button', (className + '-icon ' + className + '-geolocate'), this._container);
        this._geolocateButton.addEventListener('click', this._onClickGeolocate.bind(this));
        return container;
    },

    _onContextMenu: function(e) {
        e.preventDefault();
    },

    _onClickGeolocate: function() {
        navigator.geolocation.getCurrentPosition(this._success.bind(this), this._error.bind(this), geoOptions);

        // This timeout ensures that we still call finish() even if
        // the user declines to share their location in Firefox
        this._timeoutId = setTimeout(this._finish.bind(this), 10000 /* 10sec */);
    },

    _success: function(position) {
        this._map.jumpTo({
            center: [position.coords.longitude, position.coords.latitude],
            zoom: 17,
            bearing: 0,
            pitch: 0
        });
        this._finish();
    },

    _error: function() {
        this._finish();
    },

    _finish: function() {
        if (this._timeoutId) { clearTimeout(this._timeoutId); }
        this._timeoutId = undefined;
    }

});


},{"../../util/browser":89,"../../util/dom":92,"../../util/util":104,"./control":73}],75:[function(require,module,exports){
'use strict';

var Control = require('./control');
var DOM = require('../../util/dom');
var util = require('../../util/util');

module.exports = Navigation;

/**
 * Creates a navigation control with zoom buttons and a compass
 * @class Navigation
 * @param {Object} [options]
 * @param {string} [options.position='top-right'] A string indicating the control's position on the map. Options are `top-right`, `top-left`, `bottom-right`, `bottom-left`
 * @example
 * map.addControl(new mapboxgl.Navigation({position: 'top-left'})); // position is optional
 */
function Navigation(options) {
    util.setOptions(this, options);
}

Navigation.prototype = util.inherit(Control, {
    options: {
        position: 'top-right'
    },

    onAdd: function(map) {
        var className = 'mapboxgl-ctrl';

        var container = this._container = DOM.create('div', className + '-group', map.getContainer());
        this._container.addEventListener('contextmenu', this._onContextMenu.bind(this));

        this._zoomInButton = this._createButton(className + '-icon ' + className + '-zoom-in', map.zoomIn.bind(map));
        this._zoomOutButton = this._createButton(className + '-icon ' + className + '-zoom-out', map.zoomOut.bind(map));
        this._compass = this._createButton(className + '-icon ' + className + '-compass', map.resetNorth.bind(map));

        this._compassArrow = DOM.create('div', 'arrow', this._compass);

        this._compass.addEventListener('mousedown', this._onCompassDown.bind(this));
        this._onCompassMove = this._onCompassMove.bind(this);
        this._onCompassUp = this._onCompassUp.bind(this);

        map.on('rotate', this._rotateCompassArrow.bind(this));
        this._rotateCompassArrow();

        this._el = map.getCanvasContainer();

        return container;
    },

    _onContextMenu: function(e) {
        e.preventDefault();
    },

    _onCompassDown: function(e) {
        if (e.button !== 0) return;

        DOM.disableDrag();
        document.addEventListener('mousemove', this._onCompassMove);
        document.addEventListener('mouseup', this._onCompassUp);

        this._el.dispatchEvent(copyMouseEvent(e));
        e.stopPropagation();
    },

    _onCompassMove: function(e) {
        if (e.button !== 0) return;

        this._el.dispatchEvent(copyMouseEvent(e));
        e.stopPropagation();
    },

    _onCompassUp: function(e) {
        if (e.button !== 0) return;

        document.removeEventListener('mousemove', this._onCompassMove);
        document.removeEventListener('mouseup', this._onCompassUp);
        DOM.enableDrag();

        this._el.dispatchEvent(copyMouseEvent(e));
        e.stopPropagation();
    },

    _createButton: function(className, fn) {
        var a = DOM.create('button', className, this._container);
        a.addEventListener('click', function() { fn(); });
        return a;
    },

    _rotateCompassArrow: function() {
        var rotate = 'rotate(' + (this._map.transform.angle * (180 / Math.PI)) + 'deg)';
        this._compassArrow.style.transform = rotate;
    }
});


function copyMouseEvent(e) {
    return new MouseEvent(e.type, {
        button: 2,    // right click
        buttons: 2,   // right click
        bubbles: true,
        cancelable: true,
        detail: e.detail,
        view: e.view,
        screenX: e.screenX,
        screenY: e.screenY,
        clientX: e.clientX,
        clientY: e.clientY,
        movementX: e.movementX,
        movementY: e.movementY,
        ctrlKey: e.ctrlKey,
        shiftKey: e.shiftKey,
        altKey: e.altKey,
        metaKey: e.metaKey
    });
}


},{"../../util/dom":92,"../../util/util":104,"./control":73}],76:[function(require,module,exports){
'use strict';

var DOM = require('../../util/dom'),
    LngLatBounds = require('../../geo/lng_lat_bounds'),
    util = require('../../util/util');

module.exports = BoxZoomHandler;

/**
 * The `BoxZoomHandler` allows a user to zoom the map to fit a bounding box.
 * The bounding box is defined by holding `shift` while dragging the cursor.
 * @class BoxZoomHandler
 */
function BoxZoomHandler(map) {
    this._map = map;
    this._el = map.getCanvasContainer();
    this._container = map.getContainer();

    util.bindHandlers(this);
}

BoxZoomHandler.prototype = {

    _enabled: false,
    _active: false,

    /**
     * Returns the current enabled/disabled state of the "box zoom" interaction.
     * @returns {boolean} enabled state
     */
    isEnabled: function () {
        return this._enabled;
    },

    /**
     * Returns true if the "box zoom" interaction is currently active, i.e. currently being used.
     * @returns {boolean} active state
     */
    isActive: function () {
        return this._active;
    },

    /**
     * Enable the "box zoom" interaction.
     * @example
     *   map.boxZoom.enable();
     */
    enable: function () {
        if (this.isEnabled()) return;
        this._el.addEventListener('mousedown', this._onMouseDown, false);
        this._enabled = true;
    },

    /**
     * Disable the "box zoom" interaction.
     * @example
     *   map.boxZoom.disable();
     */
    disable: function () {
        if (!this.isEnabled()) return;
        this._el.removeEventListener('mousedown', this._onMouseDown);
        this._enabled = false;
    },

    _onMouseDown: function (e) {
        if (!(e.shiftKey && e.button === 0)) return;

        document.addEventListener('mousemove', this._onMouseMove, false);
        document.addEventListener('keydown', this._onKeyDown, false);
        document.addEventListener('mouseup', this._onMouseUp, false);

        DOM.disableDrag();
        this._startPos = DOM.mousePos(this._el, e);
        this._active = true;
    },

    _onMouseMove: function (e) {
        var p0 = this._startPos,
            p1 = DOM.mousePos(this._el, e);

        if (!this._box) {
            this._box = DOM.create('div', 'mapboxgl-boxzoom', this._container);
            this._container.classList.add('mapboxgl-crosshair');
            this._fireEvent('boxzoomstart', e);
        }

        var minX = Math.min(p0.x, p1.x),
            maxX = Math.max(p0.x, p1.x),
            minY = Math.min(p0.y, p1.y),
            maxY = Math.max(p0.y, p1.y);

        DOM.setTransform(this._box, 'translate(' + minX + 'px,' + minY + 'px)');

        this._box.style.width = (maxX - minX) + 'px';
        this._box.style.height = (maxY - minY) + 'px';
    },

    _onMouseUp: function (e) {
        if (e.button !== 0) return;

        var p0 = this._startPos,
            p1 = DOM.mousePos(this._el, e),
            bounds = new LngLatBounds(this._map.unproject(p0), this._map.unproject(p1));

        this._finish();

        if (p0.x === p1.x && p0.y === p1.y) {
            this._fireEvent('boxzoomcancel', e);
        } else {
            this._map
                .fitBounds(bounds, {linear: true})
                .fire('boxzoomend', { originalEvent: e, boxZoomBounds: bounds });
        }
    },

    _onKeyDown: function (e) {
        if (e.keyCode === 27) {
            this._finish();
            this._fireEvent('boxzoomcancel', e);
        }
    },

    _finish: function () {
        this._active = false;

        document.removeEventListener('mousemove', this._onMouseMove, false);
        document.removeEventListener('keydown', this._onKeyDown, false);
        document.removeEventListener('mouseup', this._onMouseUp, false);

        this._container.classList.remove('mapboxgl-crosshair');

        if (this._box) {
            this._box.parentNode.removeChild(this._box);
            this._box = null;
        }

        DOM.enableDrag();
    },

    _fireEvent: function (type, e) {
        return this._map.fire(type, { originalEvent: e });
    }
};


/**
 * Boxzoom start event. This event is emitted at the start of a box zoom interaction.
 *
 * @event boxzoomstart
 * @memberof Map
 * @instance
 * @property {EventData} data Original event data
 */

/**
 * Boxzoom end event. This event is emitted at the end of a box zoom interaction
 *
 * @event boxzoomend
 * @memberof Map
 * @instance
 * @type {Object}
 * @property {Event} originalEvent the original DOM event
 * @property {LngLatBounds} boxZoomBounds the bounds of the box zoom target
 */

/**
 * Boxzoom cancel event.  This event is emitted when the user cancels a box zoom interaction,
 *   or when the box zoom does not meet the minimum size threshold.
 *
 * @event boxzoomcancel
 * @memberof Map
 * @instance
 * @property {EventData} data Original event data
 */

},{"../../geo/lng_lat_bounds":11,"../../util/dom":92,"../../util/util":104}],77:[function(require,module,exports){
'use strict';

module.exports = DoubleClickZoomHandler;

/**
 * The `DoubleClickZoomHandler` allows a user to zoom the map around point by
 * double clicking.
 * @class DoubleClickZoomHandler
 */
function DoubleClickZoomHandler(map) {
    this._map = map;
    this._onDblClick = this._onDblClick.bind(this);
}

DoubleClickZoomHandler.prototype = {

    _enabled: false,

    /**
     * Returns the current enabled/disabled state of the "double click to zoom" interaction.
     * @returns {boolean} enabled state
     */
    isEnabled: function () {
        return this._enabled;
    },

    /**
     * Enable the "double click to zoom" interaction.
     * @example
     *   map.doubleClickZoom.enable();
     */
    enable: function () {
        if (this.isEnabled()) return;
        this._map.on('dblclick', this._onDblClick);
        this._enabled = true;
    },

    /**
     * Disable the "double click to zoom" interaction.
     * @example
     *   map.doubleClickZoom.disable();
     */
    disable: function () {
        if (!this.isEnabled()) return;
        this._map.off('dblclick', this._onDblClick);
        this._enabled = false;
    },

    _onDblClick: function (e) {
        this._map.zoomTo(this._map.getZoom() +
            (e.originalEvent.shiftKey ? -1 : 1), {around: e.lngLat});
    }
};

},{}],78:[function(require,module,exports){
'use strict';

var DOM = require('../../util/dom'),
    util = require('../../util/util');

module.exports = DragPanHandler;

var inertiaLinearity = 0.3,
    inertiaEasing = util.bezier(0, 0, inertiaLinearity, 1),
    inertiaMaxSpeed = 1400, // px/s
    inertiaDeceleration = 2500; // px/s^2


/**
 * The `DragPanHandler` allows a user to pan the map by clicking and dragging
 * the cursor.
 * @class DragPanHandler
 */
function DragPanHandler(map) {
    this._map = map;
    this._el = map.getCanvasContainer();

    util.bindHandlers(this);
}

DragPanHandler.prototype = {

    _enabled: false,
    _active: false,

    /**
     * Returns the current enabled/disabled state of the "drag to pan" interaction.
     * @returns {boolean} enabled state
     */
    isEnabled: function () {
        return this._enabled;
    },

    /**
     * Returns true if the "drag to pan" interaction is currently active, i.e. currently being used.
     * @returns {boolean} active state
     */
    isActive: function () {
        return this._active;
    },

    /**
     * Enable the "drag to pan" interaction.
     * @example
     *   map.dragPan.enable();
     */
    enable: function () {
        if (this.isEnabled()) return;
        this._el.addEventListener('mousedown', this._onDown);
        this._el.addEventListener('touchstart', this._onDown);
        this._enabled = true;
    },

    /**
     * Disable the "drag to pan" interaction.
     * @example
     *   map.dragPan.disable();
     */
    disable: function () {
        if (!this.isEnabled()) return;
        this._el.removeEventListener('mousedown', this._onDown);
        this._el.removeEventListener('touchstart', this._onDown);
        this._enabled = false;
    },

    _onDown: function (e) {
        if (this._ignoreEvent(e)) return;
        if (this.isActive()) return;

        if (e.touches) {
            document.addEventListener('touchmove', this._onMove);
            document.addEventListener('touchend', this._onTouchEnd);
        } else {
            document.addEventListener('mousemove', this._onMove);
            document.addEventListener('mouseup', this._onMouseUp);
        }

        this._active = false;
        this._startPos = this._pos = DOM.mousePos(this._el, e);
        this._inertia = [[Date.now(), this._pos]];
    },

    _onMove: function (e) {
        if (this._ignoreEvent(e)) return;

        if (!this.isActive()) {
            this._active = true;
            this._fireEvent('dragstart', e);
            this._fireEvent('movestart', e);
        }

        var pos = DOM.mousePos(this._el, e),
            map = this._map;

        map.stop();
        this._drainInertiaBuffer();
        this._inertia.push([Date.now(), pos]);

        map.transform.setLocationAtPoint(map.transform.pointLocation(this._pos), pos);

        this._fireEvent('drag', e);
        this._fireEvent('move', e);

        this._pos = pos;

        e.preventDefault();
    },

    _onUp: function (e) {
        if (!this.isActive()) return;

        this._active = false;
        this._fireEvent('dragend', e);
        this._drainInertiaBuffer();

        var finish = function() {
            this._fireEvent('moveend', e);
        }.bind(this);

        var inertia = this._inertia;
        if (inertia.length < 2) {
            finish();
            return;
        }

        var last = inertia[inertia.length - 1],
            first = inertia[0],
            flingOffset = last[1].sub(first[1]),
            flingDuration = (last[0] - first[0]) / 1000;

        if (flingDuration === 0 || last[1].equals(first[1])) {
            finish();
            return;
        }

        // calculate px/s velocity & adjust for increased initial animation speed when easing out
        var velocity = flingOffset.mult(inertiaLinearity / flingDuration),
            speed = velocity.mag(); // px/s

        if (speed > inertiaMaxSpeed) {
            speed = inertiaMaxSpeed;
            velocity._unit()._mult(speed);
        }

        var duration = speed / (inertiaDeceleration * inertiaLinearity),
            offset = velocity.mult(-duration / 2);

        this._map.panBy(offset, {
            duration: duration * 1000,
            easing: inertiaEasing,
            noMoveStart: true
        }, { originalEvent: e });
    },

    _onMouseUp: function (e) {
        if (this._ignoreEvent(e)) return;
        this._onUp(e);
        document.removeEventListener('mousemove', this._onMove);
        document.removeEventListener('mouseup', this._onMouseUp);
    },

    _onTouchEnd: function (e) {
        if (this._ignoreEvent(e)) return;
        this._onUp(e);
        document.removeEventListener('touchmove', this._onMove);
        document.removeEventListener('touchend', this._onTouchEnd);
    },

    _fireEvent: function (type, e) {
        return this._map.fire(type, { originalEvent: e });
    },

    _ignoreEvent: function (e) {
        var map = this._map;

        if (map.boxZoom && map.boxZoom.isActive()) return true;
        if (map.dragRotate && map.dragRotate.isActive()) return true;
        if (e.touches) {
            return (e.touches.length > 1);
        } else {
            if (e.ctrlKey) return true;
            var buttons = 1,  // left button
                button = 0;   // left button
            return (e.type === 'mousemove' ? e.buttons & buttons === 0 : e.button !== button);
        }
    },

    _drainInertiaBuffer: function () {
        var inertia = this._inertia,
            now = Date.now(),
            cutoff = 160;   // msec

        while (inertia.length > 0 && now - inertia[0][0] > cutoff) inertia.shift();
    }
};


/**
 * Drag start event. This event is emitted at the start of a user-initiated pan interaction.
 *
 * @event dragstart
 * @memberof Map
 * @instance
 * @property {EventData} data Original event data
 */

/**
 * Drag event. This event is emitted repeatedly during a user-initiated pan interaction.
 *
 * @event drag
 * @memberof Map
 * @instance
 * @property {EventData} data Original event data
 */

/**
 * Drag end event. This event is emitted at the end of a user-initiated pan interaction.
 *
 * @event dragend
 * @memberof Map
 * @instance
 * @property {EventData} data Original event data
 */

},{"../../util/dom":92,"../../util/util":104}],79:[function(require,module,exports){
'use strict';

var DOM = require('../../util/dom'),
    Point = require('point-geometry'),
    util = require('../../util/util');

module.exports = DragRotateHandler;

var inertiaLinearity = 0.25,
    inertiaEasing = util.bezier(0, 0, inertiaLinearity, 1),
    inertiaMaxSpeed = 180, // deg/s
    inertiaDeceleration = 720; // deg/s^2


/**
 * The `DragRotateHandler` allows a user to rotate the map by clicking and
 * dragging the cursor while holding the right mouse button or the `ctrl` key.
 * @class DragRotateHandler
 */
function DragRotateHandler(map) {
    this._map = map;
    this._el = map.getCanvasContainer();

    util.bindHandlers(this);
}

DragRotateHandler.prototype = {

    _enabled: false,
    _active: false,

    /**
     * Returns the current enabled/disabled state of the "drag to rotate" interaction.
     * @returns {boolean} enabled state
     */
    isEnabled: function () {
        return this._enabled;
    },

    /**
     * Returns true if the "drag to rotate" interaction is currently active, i.e. currently being used.
     * @returns {boolean} active state
     */
    isActive: function () {
        return this._active;
    },

    /**
     * Enable the "drag to rotate" interaction.
     * @example
     *   map.dragRotate.enable();
     */
    enable: function () {
        if (this.isEnabled()) return;
        this._el.addEventListener('mousedown', this._onDown);
        this._enabled = true;
    },

    /**
     * Disable the "drag to rotate" interaction.
     * @example
     *   map.dragRotate.disable();
     */
    disable: function () {
        if (!this.isEnabled()) return;
        this._el.removeEventListener('mousedown', this._onDown);
        this._enabled = false;
    },

    _onDown: function (e) {
        if (this._ignoreEvent(e)) return;
        if (this.isActive()) return;

        document.addEventListener('mousemove', this._onMove);
        document.addEventListener('mouseup', this._onUp);

        this._active = false;
        this._inertia = [[Date.now(), this._map.getBearing()]];
        this._startPos = this._pos = DOM.mousePos(this._el, e);
        this._center = this._map.transform.centerPoint;  // Center of rotation

        // If the first click was too close to the center, move the center of rotation by 200 pixels
        // in the direction of the click.
        var startToCenter = this._startPos.sub(this._center),
            startToCenterDist = startToCenter.mag();

        if (startToCenterDist < 200) {
            this._center = this._startPos.add(new Point(-200, 0)._rotate(startToCenter.angle()));
        }

        e.preventDefault();
    },

    _onMove: function (e) {
        if (this._ignoreEvent(e)) return;

        if (!this.isActive()) {
            this._active = true;
            this._fireEvent('rotatestart', e);
            this._fireEvent('movestart', e);
        }

        var map = this._map;
        map.stop();

        var p1 = this._pos,
            p2 = DOM.mousePos(this._el, e),
            center = this._center,
            bearingDiff = p1.sub(center).angleWith(p2.sub(center)) / Math.PI * 180,
            bearing = map.getBearing() - bearingDiff,
            inertia = this._inertia,
            last = inertia[inertia.length - 1];

        this._drainInertiaBuffer();
        inertia.push([Date.now(), map._normalizeBearing(bearing, last[1])]);

        map.transform.bearing = bearing;

        this._fireEvent('rotate', e);
        this._fireEvent('move', e);

        this._pos = p2;
    },

    _onUp: function (e) {
        if (this._ignoreEvent(e)) return;
        document.removeEventListener('mousemove', this._onMove);
        document.removeEventListener('mouseup', this._onUp);

        if (!this.isActive()) return;

        this._active = false;
        this._fireEvent('rotateend', e);
        this._drainInertiaBuffer();

        var map = this._map,
            mapBearing = map.getBearing(),
            inertia = this._inertia;

        var finish = function() {
            if (Math.abs(mapBearing) < map.options.bearingSnap) {
                map.resetNorth({noMoveStart: true}, { originalEvent: e });
            } else {
                this._fireEvent('moveend', e);
            }
        }.bind(this);

        if (inertia.length < 2) {
            finish();
            return;
        }

        var first = inertia[0],
            last = inertia[inertia.length - 1],
            previous = inertia[inertia.length - 2],
            bearing = map._normalizeBearing(mapBearing, previous[1]),
            flingDiff = last[1] - first[1],
            sign = flingDiff < 0 ? -1 : 1,
            flingDuration = (last[0] - first[0]) / 1000;

        if (flingDiff === 0 || flingDuration === 0) {
            finish();
            return;
        }

        var speed = Math.abs(flingDiff * (inertiaLinearity / flingDuration));  // deg/s
        if (speed > inertiaMaxSpeed) {
            speed = inertiaMaxSpeed;
        }

        var duration = speed / (inertiaDeceleration * inertiaLinearity),
            offset = sign * speed * (duration / 2);

        bearing += offset;

        if (Math.abs(map._normalizeBearing(bearing, 0)) < map.options.bearingSnap) {
            bearing = map._normalizeBearing(0, bearing);
        }

        map.rotateTo(bearing, {
            duration: duration * 1000,
            easing: inertiaEasing,
            noMoveStart: true
        }, { originalEvent: e });
    },

    _fireEvent: function (type, e) {
        return this._map.fire(type, { originalEvent: e });
    },

    _ignoreEvent: function (e) {
        var map = this._map;

        if (map.boxZoom && map.boxZoom.isActive()) return true;
        if (map.dragPan && map.dragPan.isActive()) return true;
        if (e.touches) {
            return (e.touches.length > 1);
        } else {
            var buttons = (e.ctrlKey ? 1 : 2),  // ? ctrl+left button : right button
                button = (e.ctrlKey ? 0 : 2);   // ? ctrl+left button : right button
            return (e.type === 'mousemove' ? e.buttons & buttons === 0 : e.button !== button);
        }
    },

    _drainInertiaBuffer: function () {
        var inertia = this._inertia,
            now = Date.now(),
            cutoff = 160;   //msec

        while (inertia.length > 0 && now - inertia[0][0] > cutoff)
            inertia.shift();
    }

};


/**
 * Rotate start event. This event is emitted at the start of a user-initiated rotate interaction.
 *
 * @event rotatestart
 * @memberof Map
 * @instance
 * @property {EventData} data Original event data
 */

/**
 * Rotate event. This event is emitted repeatedly during a user-initiated rotate interaction.
 *
 * @event rotate
 * @memberof Map
 * @instance
 * @property {EventData} data Original event data
 */

/**
 * Rotate end event. This event is emitted at the end of a user-initiated rotate interaction.
 *
 * @event rotateend
 * @memberof Map
 * @instance
 * @property {EventData} data Original event data
 */

},{"../../util/dom":92,"../../util/util":104,"point-geometry":162}],80:[function(require,module,exports){
'use strict';

module.exports = KeyboardHandler;


var panDelta = 80,
    rotateDelta = 2,
    pitchDelta = 5;

/**
 * The `KeyboardHandler` allows a user to zoom, rotate, and pan the map using
 * following keyboard shortcuts:
 *  * `=` / `+`: increase zoom level by 1
 *  * `Shift-=` / `Shift-+`: increase zoom level by 2
 *  * `-`: decrease zoom level by 1
 *  * `Shift--`: decrease zoom level by 2
 *  * Arrow keys: pan by 80 pixels
 *  * `Shift+⇢`: increase rotation by 2 degrees
 *  * `Shift+⇠`: decrease rotation by 2 degrees
 *  * `Shift+⇡`: increase pitch by 5 degrees
 *  * `Shift+⇣`: decrease pitch by 5 degrees
 * @class KeyboardHandler
 */
function KeyboardHandler(map) {
    this._map = map;
    this._el = map.getCanvasContainer();

    this._onKeyDown = this._onKeyDown.bind(this);
}

KeyboardHandler.prototype = {

    _enabled: false,

    /**
     * Returns the current enabled/disabled state of keyboard interaction.
     * @returns {boolean} enabled state
     */
    isEnabled: function () {
        return this._enabled;
    },

    /**
     * Enable the ability to interact with the map using keyboard input.
     * @example
     *   map.keyboard.enable();
     */
    enable: function () {
        if (this.isEnabled()) return;
        this._el.addEventListener('keydown', this._onKeyDown, false);
        this._enabled = true;
    },

    /**
     * Disable the ability to interact with the map using keyboard input.
     * @example
     *   map.keyboard.disable();
     */
    disable: function () {
        if (!this.isEnabled()) return;
        this._el.removeEventListener('keydown', this._onKeyDown);
        this._enabled = false;
    },

    _onKeyDown: function (e) {
        if (e.altKey || e.ctrlKey || e.metaKey) return;

        var map = this._map,
            eventData = { originalEvent: e };

        switch (e.keyCode) {
        case 61:
        case 107:
        case 171:
        case 187:
            map.zoomTo(Math.round(map.getZoom()) + (e.shiftKey ? 2 : 1), eventData);
            break;

        case 189:
        case 109:
        case 173:
            map.zoomTo(Math.round(map.getZoom()) - (e.shiftKey ? 2 : 1), eventData);
            break;

        case 37:
            if (e.shiftKey) {
                map.easeTo({ bearing: map.getBearing() - rotateDelta }, eventData);
            } else {
                e.preventDefault();
                map.panBy([-panDelta, 0], eventData);
            }
            break;

        case 39:
            if (e.shiftKey) {
                map.easeTo({ bearing: map.getBearing() + rotateDelta }, eventData);
            } else {
                e.preventDefault();
                map.panBy([panDelta, 0], eventData);
            }
            break;

        case 38:
            if (e.shiftKey) {
                map.easeTo({ pitch: map.getPitch() + pitchDelta }, eventData);
            } else {
                e.preventDefault();
                map.panBy([0, -panDelta], eventData);
            }
            break;

        case 40:
            if (e.shiftKey) {
                map.easeTo({ pitch: Math.max(map.getPitch() - pitchDelta, 0) }, eventData);
            } else {
                e.preventDefault();
                map.panBy([0, panDelta], eventData);
            }
            break;
        }
    }
};

},{}],81:[function(require,module,exports){
'use strict';

var DOM = require('../../util/dom'),
    browser = require('../../util/browser'),
    util = require('../../util/util');

module.exports = ScrollZoomHandler;


var ua = typeof navigator !== 'undefined' ? navigator.userAgent.toLowerCase() : '',
    firefox = ua.indexOf('firefox') !== -1,
    safari = ua.indexOf('safari') !== -1 && ua.indexOf('chrom') === -1;


/**
 * The `ScrollZoomHandler` allows a user to zoom the map by scrolling.
 * @class ScrollZoomHandler
 */
function ScrollZoomHandler(map) {
    this._map = map;
    this._el = map.getCanvasContainer();

    util.bindHandlers(this);
}

ScrollZoomHandler.prototype = {

    _enabled: false,

    /**
     * Returns the current enabled/disabled state of the "scroll to zoom" interaction.
     * @returns {boolean} enabled state
     */
    isEnabled: function () {
        return this._enabled;
    },

    /**
     * Enable the "scroll to zoom" interaction.
     * @example
     *   map.scrollZoom.enable();
     */
    enable: function () {
        if (this.isEnabled()) return;
        this._el.addEventListener('wheel', this._onWheel, false);
        this._el.addEventListener('mousewheel', this._onWheel, false);
        this._enabled = true;
    },

    /**
     * Disable the "scroll to zoom" interaction.
     * @example
     *   map.scrollZoom.disable();
     */
    disable: function () {
        if (!this.isEnabled()) return;
        this._el.removeEventListener('wheel', this._onWheel);
        this._el.removeEventListener('mousewheel', this._onWheel);
        this._enabled = false;
    },

    _onWheel: function (e) {
        var value;

        if (e.type === 'wheel') {
            value = e.deltaY;
            // Firefox doubles the values on retina screens...
            if (firefox && e.deltaMode === window.WheelEvent.DOM_DELTA_PIXEL) value /= browser.devicePixelRatio;
            if (e.deltaMode === window.WheelEvent.DOM_DELTA_LINE) value *= 40;

        } else if (e.type === 'mousewheel') {
            value = -e.wheelDeltaY;
            if (safari) value = value / 3;
        }

        var now = browser.now(),
            timeDelta = now - (this._time || 0);

        this._pos = DOM.mousePos(this._el, e);
        this._time = now;

        if (value !== 0 && (value % 4.000244140625) === 0) {
            // This one is definitely a mouse wheel event.
            this._type = 'wheel';
            // Normalize this value to match trackpad.
            value = Math.floor(value / 4);

        } else if (value !== 0 && Math.abs(value) < 4) {
            // This one is definitely a trackpad event because it is so small.
            this._type = 'trackpad';

        } else if (timeDelta > 400) {
            // This is likely a new scroll action.
            this._type = null;
            this._lastValue = value;

            // Start a timeout in case this was a singular event, and dely it by up to 40ms.
            this._timeout = setTimeout(this._onTimeout, 40);

        } else if (!this._type) {
            // This is a repeating event, but we don't know the type of event just yet.
            // If the delta per time is small, we assume it's a fast trackpad; otherwise we switch into wheel mode.
            this._type = (Math.abs(timeDelta * value) < 200) ? 'trackpad' : 'wheel';

            // Make sure our delayed event isn't fired again, because we accumulate
            // the previous event (which was less than 40ms ago) into this event.
            if (this._timeout) {
                clearTimeout(this._timeout);
                this._timeout = null;
                value += this._lastValue;
            }
        }

        // Slow down zoom if shift key is held for more precise zooming
        if (e.shiftKey && value) value = value / 4;

        // Only fire the callback if we actually know what type of scrolling device the user uses.
        if (this._type) this._zoom(-value, e);

        e.preventDefault();
    },

    _onTimeout: function () {
        this._type = 'wheel';
        this._zoom(-this._lastValue);
    },

    _zoom: function (delta, e) {
        if (delta === 0) return;
        var map = this._map;

        // Scale by sigmoid of scroll wheel delta.
        var scale = 2 / (1 + Math.exp(-Math.abs(delta / 100)));
        if (delta < 0 && scale !== 0) scale = 1 / scale;

        var fromScale = map.ease ? map.ease.to : map.transform.scale,
            targetZoom = map.transform.scaleZoom(fromScale * scale);

        map.zoomTo(targetZoom, {
            duration: 0,
            around: map.unproject(this._pos),
            delayEndEvents: 200
        }, { originalEvent: e });
    }
};


/**
 * Zoom start event. This event is emitted just before the map begins a transition from one
 * zoom level to another, either as a result of user interaction or the use of methods such as `Map#jumpTo`.
 *
 * @event zoomstart
 * @memberof Map
 * @instance
 * @property {EventData} data Original event data, if fired interactively
 */

/**
 * Zoom event. This event is emitted repeatedly during animated transitions from one zoom level to
 * another, either as a result of user interaction or the use of methods such as `Map#jumpTo`.
 *
 * @event zoom
 * @memberof Map
 * @instance
 * @property {EventData} data Original event data, if fired interactively
 */

/**
 * Zoom end event. This event is emitted just after the map completes a transition from one
 * zoom level to another, either as a result of user interaction or the use of methods such as `Map#jumpTo`.
 *
 * @event zoomend
 * @memberof Map
 * @instance
 * @property {EventData} data Original event data, if fired interactively
 */

},{"../../util/browser":89,"../../util/dom":92,"../../util/util":104}],82:[function(require,module,exports){
'use strict';

var DOM = require('../../util/dom'),
    util = require('../../util/util');

module.exports = TouchZoomRotateHandler;

var inertiaLinearity = 0.15,
    inertiaEasing = util.bezier(0, 0, inertiaLinearity, 1),
    inertiaDeceleration = 12, // scale / s^2
    inertiaMaxSpeed = 2.5, // scale / s
    significantScaleThreshold = 0.15,
    significantRotateThreshold = 4;


/**
 * The `TouchZoomRotateHandler` allows a user to zoom and rotate the map by
 * pinching on a touchscreen.
 * @class TouchZoomRotateHandler
 */
function TouchZoomRotateHandler(map) {
    this._map = map;
    this._el = map.getCanvasContainer();

    util.bindHandlers(this);
}

TouchZoomRotateHandler.prototype = {

    _enabled: false,

    /**
     * Returns the current enabled/disabled state of the "pinch to rotate and zoom" interaction.
     * @returns {boolean} enabled state
     */
    isEnabled: function () {
        return this._enabled;
    },

    /**
     * Enable the "pinch to rotate and zoom" interaction.
     * @example
     *   map.touchZoomRotate.enable();
     */
    enable: function () {
        if (this.isEnabled()) return;
        this._el.addEventListener('touchstart', this._onStart, false);
        this._enabled = true;
    },

    /**
     * Disable the "pinch to rotate and zoom" interaction.
     * @example
     *   map.touchZoomRotate.disable();
     */
    disable: function () {
        if (!this.isEnabled()) return;
        this._el.removeEventListener('touchstart', this._onStart);
        this._enabled = false;
    },

    /**
     * Disable the "pinch to rotate" interaction, leaving the "pinch to zoom"
     * interaction enabled.
     * @example
     *   map.touchZoomRotate.disableRotation();
     */
    disableRotation: function() {
        this._rotationDisabled = true;
    },

    /**
     * Enable the "pinch to rotate" interaction, undoing a call to
     * `disableRotation`.
     * @example
     *   map.touchZoomRotate.enable();
     *   map.touchZoomRotate.enableRotation();
     */
    enableRotation: function() {
        this._rotationDisabled = false;
    },

    _onStart: function (e) {
        if (e.touches.length !== 2) return;

        var p0 = DOM.mousePos(this._el, e.touches[0]),
            p1 = DOM.mousePos(this._el, e.touches[1]);

        this._startVec = p0.sub(p1);
        this._startScale = this._map.transform.scale;
        this._startBearing = this._map.transform.bearing;
        this._gestureIntent = undefined;
        this._inertia = [];

        document.addEventListener('touchmove', this._onMove, false);
        document.addEventListener('touchend', this._onEnd, false);
    },

    _onMove: function (e) {
        if (e.touches.length !== 2) return;

        var p0 = DOM.mousePos(this._el, e.touches[0]),
            p1 = DOM.mousePos(this._el, e.touches[1]),
            p = p0.add(p1).div(2),
            vec = p0.sub(p1),
            scale = vec.mag() / this._startVec.mag(),
            bearing = this._rotationDisabled ? 0 : vec.angleWith(this._startVec) * 180 / Math.PI,
            map = this._map;

        // Determine 'intent' by whichever threshold is surpassed first,
        // then keep that state for the duration of this gesture.
        if (!this._gestureIntent) {
            var scalingSignificantly = (Math.abs(1 - scale) > significantScaleThreshold),
                rotatingSignificantly = (Math.abs(bearing) > significantRotateThreshold);

            if (rotatingSignificantly) {
                this._gestureIntent = 'rotate';
            } else if (scalingSignificantly) {
                this._gestureIntent = 'zoom';
            }

            if (this._gestureIntent) {
                this._startVec = vec;
                this._startScale = map.transform.scale;
                this._startBearing = map.transform.bearing;
            }

        } else {
            var param = { duration: 0, around: map.unproject(p) };

            if (this._gestureIntent === 'rotate') {
                param.bearing = this._startBearing + bearing;
            }
            if (this._gestureIntent === 'zoom' || this._gestureIntent === 'rotate') {
                param.zoom = map.transform.scaleZoom(this._startScale * scale);
            }

            map.stop();
            this._drainInertiaBuffer();
            this._inertia.push([Date.now(), scale, p]);

            map.easeTo(param, { originalEvent: e });
        }

        e.preventDefault();
    },

    _onEnd: function (e) {
        document.removeEventListener('touchmove', this._onMove);
        document.removeEventListener('touchend', this._onEnd);
        this._drainInertiaBuffer();

        var inertia = this._inertia,
            map = this._map;

        if (inertia.length < 2) {
            map.snapToNorth({}, { originalEvent: e });
            return;
        }

        var last = inertia[inertia.length - 1],
            first = inertia[0],
            lastScale = map.transform.scaleZoom(this._startScale * last[1]),
            firstScale = map.transform.scaleZoom(this._startScale * first[1]),
            scaleOffset = lastScale - firstScale,
            scaleDuration = (last[0] - first[0]) / 1000,
            p = last[2];

        if (scaleDuration === 0 || lastScale === firstScale) {
            map.snapToNorth({}, { originalEvent: e });
            return;
        }

        // calculate scale/s speed and adjust for increased initial animation speed when easing
        var speed = scaleOffset * inertiaLinearity / scaleDuration; // scale/s

        if (Math.abs(speed) > inertiaMaxSpeed) {
            if (speed > 0) {
                speed = inertiaMaxSpeed;
            } else {
                speed = -inertiaMaxSpeed;
            }
        }

        var duration = Math.abs(speed / (inertiaDeceleration * inertiaLinearity)) * 1000,
            targetScale = lastScale + speed * duration / 2000;

        if (targetScale < 0) {
            targetScale = 0;
        }

        map.easeTo({
            zoom: targetScale,
            duration: duration,
            easing: inertiaEasing,
            around: map.unproject(p)
        }, { originalEvent: e });
    },

    _drainInertiaBuffer: function() {
        var inertia = this._inertia,
            now = Date.now(),
            cutoff = 160; // msec

        while (inertia.length > 2 && now - inertia[0][0] > cutoff) inertia.shift();
    }
};

},{"../../util/dom":92,"../../util/util":104}],83:[function(require,module,exports){
'use strict';

/*
 * Adds positional coordinates to URL hashes. Passed as an option to the map object
 *
 * @class mapboxgl.Hash
 * @returns {Hash} `this`
 */
module.exports = Hash;

var util = require('../util/util');

function Hash() {
    util.bindAll([
        '_onHashChange',
        '_updateHash'
    ], this);
}

Hash.prototype = {
    /* Map element to listen for coordinate changes
     *
     * @param {Object} map
     * @returns {Hash} `this`
     */
    addTo: function(map) {
        this._map = map;
        window.addEventListener('hashchange', this._onHashChange, false);
        this._map.on('moveend', this._updateHash);
        return this;
    },

    /* Removes hash
     *
     * @returns {Popup} `this`
     */
    remove: function() {
        window.removeEventListener('hashchange', this._onHashChange, false);
        this._map.off('moveend', this._updateHash);
        delete this._map;
        return this;
    },

    _onHashChange: function() {
        var loc = location.hash.replace('#', '').split('/');
        if (loc.length >= 3) {
            this._map.jumpTo({
                center: [+loc[2], +loc[1]],
                zoom: +loc[0],
                bearing: +(loc[3] || 0)
            });
            return true;
        }
        return false;
    },

    _updateHash: function() {
        var center = this._map.getCenter(),
            zoom = this._map.getZoom(),
            bearing = this._map.getBearing(),
            precision = Math.max(0, Math.ceil(Math.log(zoom) / Math.LN2)),

            hash = '#' + (Math.round(zoom * 100) / 100) +
                '/' + center.lat.toFixed(precision) +
                '/' + center.lng.toFixed(precision) +
                (bearing ? '/' + (Math.round(bearing * 10) / 10) : '');

        window.history.replaceState('', '', hash);
    }
};

},{"../util/util":104}],84:[function(require,module,exports){
'use strict';

var handlers = {
    scrollZoom: require('./handler/scroll_zoom'),
    boxZoom: require('./handler/box_zoom'),
    dragRotate: require('./handler/drag_rotate'),
    dragPan: require('./handler/drag_pan'),
    keyboard: require('./handler/keyboard'),
    doubleClickZoom: require('./handler/dblclick_zoom'),
    touchZoomRotate: require('./handler/touch_zoom_rotate')
};

var DOM = require('../util/dom'),
    util = require('../util/util'),
    Point = require('point-geometry');

module.exports = Interaction;

function Interaction(map) {
    this._map = map;
    this._el = map.getCanvasContainer();

    for (var name in handlers) {
        map[name] = new handlers[name](map);
    }

    util.bindHandlers(this);
}

Interaction.prototype = {
    enable: function () {
        var options = this._map.options,
            el = this._el;

        for (var name in handlers) {
            if (options[name]) this._map[name].enable();
        }

        el.addEventListener('mousedown', this._onMouseDown, false);
        el.addEventListener('mouseup', this._onMouseUp, false);
        el.addEventListener('mousemove', this._onMouseMove, false);
        el.addEventListener('touchstart', this._onTouchStart, false);
        el.addEventListener('touchend', this._onTouchEnd, false);
        el.addEventListener('touchmove', this._onTouchMove, false);
        el.addEventListener('touchcancel', this._onTouchCancel, false);
        el.addEventListener('click', this._onClick, false);
        el.addEventListener('dblclick', this._onDblClick, false);
        el.addEventListener('contextmenu', this._onContextMenu, false);
    },

    disable: function () {
        var options = this._map.options,
            el = this._el;

        for (var name in handlers) {
            if (options[name]) this._map[name].disable();
        }

        el.removeEventListener('mousedown', this._onMouseDown);
        el.removeEventListener('mouseup', this._onMouseUp);
        el.removeEventListener('mousemove', this._onMouseMove);
        el.removeEventListener('touchstart', this._onTouchStart);
        el.removeEventListener('touchend', this._onTouchEnd);
        el.removeEventListener('touchmove', this._onTouchMove);
        el.removeEventListener('touchcancel', this._onTouchCancel);
        el.removeEventListener('click', this._onClick);
        el.removeEventListener('dblclick', this._onDblClick);
        el.removeEventListener('contextmenu', this._onContextMenu);
    },

    _onMouseDown: function (e) {
        this._map.stop();
        this._startPos = DOM.mousePos(this._el, e);
        this._fireMouseEvent('mousedown', e);
    },

    _onMouseUp: function (e) {
        var map = this._map,
            rotating = map.dragRotate && map.dragRotate.isActive();

        if (this._contextMenuEvent && !rotating) {
            this._fireMouseEvent('contextmenu', this._contextMenuEvent);
        }

        this._contextMenuEvent = null;
        this._fireMouseEvent('mouseup', e);
    },

    _onMouseMove: function (e) {
        var map = this._map,
            el = this._el;

        if (map.dragPan && map.dragPan.isActive()) return;
        if (map.dragRotate && map.dragRotate.isActive()) return;

        var target = e.toElement || e.target;
        while (target && target !== el) target = target.parentNode;
        if (target !== el) return;

        this._fireMouseEvent('mousemove', e);
    },

    _onTouchStart: function (e) {
        this._map.stop();
        this._fireTouchEvent('touchstart', e);

        if (!e.touches || e.touches.length > 1) return;

        if (!this._tapped) {
            this._tapped = setTimeout(this._onTouchTimeout, 300);

        } else {
            clearTimeout(this._tapped);
            this._tapped = null;
            this._fireMouseEvent('dblclick', e);
        }
    },

    _onTouchMove: function (e) {
        this._fireTouchEvent('touchmove', e);
    },

    _onTouchEnd: function (e) {
        this._fireTouchEvent('touchend', e);
    },

    _onTouchCancel: function (e) {
        this._fireTouchEvent('touchcancel', e);
    },

    _onTouchTimeout: function () {
        this._tapped = null;
    },

    _onClick: function (e) {
        var pos = DOM.mousePos(this._el, e);

        if (pos.equals(this._startPos)) {
            this._fireMouseEvent('click', e);
        }
    },

    _onDblClick: function (e) {
        this._fireMouseEvent('dblclick', e);
        e.preventDefault();
    },

    _onContextMenu: function (e) {
        this._contextMenuEvent = e;
        e.preventDefault();
    },

    _fireMouseEvent: function (type, e) {
        var pos = DOM.mousePos(this._el, e);

        return this._map.fire(type, {
            lngLat: this._map.unproject(pos),
            point: pos,
            originalEvent: e
        });
    },

    _fireTouchEvent: function (type, e) {
        var touches = DOM.touchPos(this._el, e),
            singular = touches.reduce(function (prev, curr, i, arr) {
                return prev.add(curr.div(arr.length));
            }, new Point(0, 0));

        return this._map.fire(type, {
            lngLat: this._map.unproject(singular),
            point: singular,
            lngLats: touches.map(function(t) { return this._map.unproject(t); }, this),
            points: touches,
            originalEvent: e
        });
    }
};


/**
 * When an event [fires]{@link #Evented.fire} as a result of a
 * user interaction, the event will be called with an EventData
 * object containing the original DOM event along with coordinates of
 * the event target.
 *
 * @typedef {Object} EventData
 * @property {Event} originalEvent The original DOM event
 * @property {Point} point The pixel location of the event
 * @property {LngLat} lngLat The geographic location of the event
 * @example
 * map.on('click', function(data) {
 *   var e = data && data.originalEvent;
 *   console.log('got click ' + (e ? 'button = ' + e.button : ''));
 * });
 */

/**
 * Mouse down event.
 *
 * @event mousedown
 * @memberof Map
 * @instance
 * @property {EventData} data Original event data
 */

/**
 * Mouse up event.
 *
 * @event mouseup
 * @memberof Map
 * @instance
 * @property {EventData} data Original event data
 */

/**
 * Mouse move event.
 *
 * @event mousemove
 * @memberof Map
 * @instance
 * @property {EventData} data Original event data
 */

/**
 * Touch start event.
 *
 * @event touchstart
 * @memberof Map
 * @instance
 * @property {EventData} data Original event data
 */

/**
 * Touch end event.
 *
 * @event touchend
 * @memberof Map
 * @instance
 * @property {EventData} data Original event data
 */

/**
 * Touch move event.
 *
 * @event touchmove
 * @memberof Map
 * @instance
 * @property {EventData} data Original event data
 */

/**
 * Touch cancel event.
 *
 * @event touchcancel
 * @memberof Map
 * @instance
 * @property {EventData} data Original event data
 */

/**
 * Click event.
 *
 * @event click
 * @memberof Map
 * @instance
 * @property {EventData} data Original event data
 */

/**
 * Double click event.
 *
 * @event dblclick
 * @memberof Map
 * @instance
 * @property {EventData} data Original event data
 */

/**
 * Context menu event.
 *
 * @event contextmenu
 * @memberof Map
 * @instance
 * @property {EventData} data Original event data, if available
 */

/**
 * Load event. This event is emitted immediately after all necessary resources have been downloaded
 * and the first visually complete rendering has occurred.
 *
 * @event load
 * @memberof Map
 * @instance
 * @type {Object}
 */

/**
 * Move start event. This event is emitted just before the map begins a transition from one
 * view to another, either as a result of user interaction or the use of methods such as `Map#jumpTo`.
 *
 * @event movestart
 * @memberof Map
 * @instance
 * @property {EventData} data Original event data, if fired interactively
 */

/**
 * Move event. This event is emitted repeatedly during animated transitions from one view to
 * another, either as a result of user interaction or the use of methods such as `Map#jumpTo`.
 *
 * @event move
 * @memberof Map
 * @instance
 * @property {EventData} data Original event data, if fired interactively
 */

/**
 * Move end event. This event is emitted just after the map completes a transition from one
 * view to another, either as a result of user interaction or the use of methods such as `Map#jumpTo`.
 *
 * @event moveend
 * @memberof Map
 * @instance
 * @property {EventData} data Original event data, if fired interactively
 */

},{"../util/dom":92,"../util/util":104,"./handler/box_zoom":76,"./handler/dblclick_zoom":77,"./handler/drag_pan":78,"./handler/drag_rotate":79,"./handler/keyboard":80,"./handler/scroll_zoom":81,"./handler/touch_zoom_rotate":82,"point-geometry":162}],85:[function(require,module,exports){
'use strict';

var Canvas = require('../util/canvas');
var util = require('../util/util');
var browser = require('../util/browser');
var Evented = require('../util/evented');
var DOM = require('../util/dom');

var Style = require('../style/style');
var AnimationLoop = require('../style/animation_loop');
var Painter = require('../render/painter');

var Transform = require('../geo/transform');
var Hash = require('./hash');

var Interaction = require('./interaction');

var Camera = require('./camera');
var LngLat = require('../geo/lng_lat');
var LngLatBounds = require('../geo/lng_lat_bounds');
var Point = require('point-geometry');
var Attribution = require('./control/attribution');

var defaultMinZoom = 0;
var defaultMaxZoom = 20;
/**
 * Options common to Map#addClass, Map#removeClass, and Map#setClasses, controlling
 * whether or not to smoothly transition property changes triggered by the class change.
 *
 * @typedef {Object} StyleOptions
 * @property {boolean} transition
 */

/**
 * Creates a map instance.
 * @class Map
 * @param {Object} options
 * @param {string|Element} options.container HTML element to initialize the map in (or element id as string)
 * @param {number} [options.minZoom=0] Minimum zoom of the map
 * @param {number} [options.maxZoom=20] Maximum zoom of the map
 * @param {Object|string} [options.style] Map style. This must be an an object conforming to the schema described in the [style reference](https://mapbox.com/mapbox-gl-style-spec/), or a URL to a JSON style. To load a style from the Mapbox API, you can use a URL of the form `mapbox://styles/:owner/:style`, where `:owner` is your Mapbox account name and `:style` is the style ID. Or you can use one of the predefined Mapbox styles:
 *   * `mapbox://styles/mapbox/basic-v8` - Simple and flexible starting template.
 *   * `mapbox://styles/mapbox/bright-v8` - Template for complex custom basemaps.
 *   * `mapbox://styles/mapbox/streets-v8` - A ready-to-use basemap, perfect for minor customization or incorporating your own data.
 *   * `mapbox://styles/mapbox/light-v8` - Subtle light backdrop for data vizualizations.
 *   * `mapbox://styles/mapbox/dark-v8` - Subtle dark backdrop for data vizualizations.
 * @param {boolean} [options.hash=false] If `true`, the map will track and update the page URL according to map position
 * @param {boolean} [options.interactive=true] If `false`, no mouse, touch, or keyboard listeners are attached to the map, so it will not respond to input
 * @param {number} [options.bearingSnap=7] Snap to north threshold in degrees.
 * @param {Array} [options.classes] Style class names with which to initialize the map
 * @param {boolean} [options.attributionControl=true] If `true`, an attribution control will be added to the map.
 * @param {boolean} [options.failIfMajorPerformanceCaveat=false] If `true`, map creation will fail if the implementation determines that the performance of the created WebGL context would be dramatically lower than expected.
 * @param {boolean} [options.preserveDrawingBuffer=false] If `true`, The maps canvas can be exported to a PNG using `map.getCanvas().toDataURL();`. This is false by default as a performance optimization.
 * @param {LngLatBounds|Array<Array<number>>} [options.maxBounds] If set, the map is constrained to the given bounds.
 * @param {boolean} [options.scrollZoom=true] If `true`, enable the "scroll to zoom" interaction (see `ScrollZoomHandler`)
 * @param {boolean} [options.boxZoom=true] If `true`, enable the "box zoom" interaction (see `BoxZoomHandler`)
 * @param {boolean} [options.dragRotate=true] If `true`, enable the "drag to rotate" interaction (see `DragRotateHandler`).
 * @param {boolean} [options.dragPan=true] If `true`, enable the "drag to pan" interaction (see `DragPanHandler`).
 * @param {boolean} [options.keyboard=true] If `true`, enable keyboard shortcuts (see `KeyboardHandler`).
 * @param {boolean} [options.doubleClickZoom=true] If `true`, enable the "double click to zoom" interaction (see `DoubleClickZoomHandler`).
 * @param {boolean} [options.touchZoomRotate=true] If `true`, enable the "pinch to rotate and zoom" interaction (see `TouchZoomRotateHandler`).
 * @example
 * var map = new mapboxgl.Map({
 *   container: 'map',
 *   center: [-122.420679, 37.772537],
 *   zoom: 13,
 *   style: style_object,
 *   hash: true
 * });
 */
var Map = module.exports = function(options) {

    options = util.inherit(this.options, options);
    this._interactive = options.interactive;
    this._failIfMajorPerformanceCaveat = options.failIfMajorPerformanceCaveat;
    this._preserveDrawingBuffer = options.preserveDrawingBuffer;

    if (typeof options.container === 'string') {
        this._container = document.getElementById(options.container);
    } else {
        this._container = options.container;
    }

    this.animationLoop = new AnimationLoop();
    this.transform = new Transform(options.minZoom, options.maxZoom);

    if (options.maxBounds) {
        this.setMaxBounds(options.maxBounds);
    }

    util.bindAll([
        '_forwardStyleEvent',
        '_forwardSourceEvent',
        '_forwardLayerEvent',
        '_forwardTileEvent',
        '_onStyleLoad',
        '_onStyleChange',
        '_onSourceAdd',
        '_onSourceRemove',
        '_onSourceUpdate',
        '_onWindowResize',
        'onError',
        '_update',
        '_render'
    ], this);

    this._setupContainer();
    this._setupPainter();

    this.on('move', this._update.bind(this, false));
    this.on('zoom', this._update.bind(this, true));
    this.on('moveend', function() {
        this.animationLoop.set(300); // text fading
        this._rerender();
    }.bind(this));

    if (typeof window !== 'undefined') {
        window.addEventListener('resize', this._onWindowResize, false);
    }

    this.interaction = new Interaction(this);

    if (options.interactive) {
        this.interaction.enable();
    }

    this._hash = options.hash && (new Hash()).addTo(this);
    // don't set position from options if set through hash
    if (!this._hash || !this._hash._onHashChange()) {
        this.jumpTo(options);
    }

    this.stacks = {};
    this._classes = {};

    this.resize();

    if (options.classes) this.setClasses(options.classes);
    if (options.style) this.setStyle(options.style);
    if (options.attributionControl) this.addControl(new Attribution(options.attributionControl));

    this.on('style.error', this.onError);
    this.on('source.error', this.onError);
    this.on('tile.error', this.onError);
    this.on('layer.error', this.onError);
};

util.extend(Map.prototype, Evented);
util.extend(Map.prototype, Camera.prototype);
util.extend(Map.prototype, /** @lends Map.prototype */{

    options: {
        center: [0, 0],
        zoom: 0,
        bearing: 0,
        pitch: 0,

        minZoom: defaultMinZoom,
        maxZoom: defaultMaxZoom,

        interactive: true,

        scrollZoom: true,
        boxZoom: true,
        dragRotate: true,
        dragPan: true,
        keyboard: true,
        doubleClickZoom: true,
        touchZoomRotate: true,

        bearingSnap: 7,

        hash: false,

        attributionControl: true,

        failIfMajorPerformanceCaveat: false,
        preserveDrawingBuffer: false
    },

    /**
     * Adds a control to the map, calling `control.addTo(this)`.
     *
     * @param {Control} control
     * @returns {Map} `this`
     */
    addControl: function(control) {
        control.addTo(this);
        return this;
    },

    /**
     * Adds a style class to a map
     *
     * @param {string} klass name of style class
     * @param {StyleOptions} [options]
     * @fires change
     * @returns {Map} `this`
     */
    addClass: function(klass, options) {
        if (this._classes[klass]) return;
        this._classes[klass] = true;
        if (this.style) this.style._cascade(this._classes, options);
    },

    /**
     * Removes a style class from a map
     *
     * @param {string} klass name of style class
     * @param {StyleOptions} [options]
     * @fires change
     * @returns {Map} `this`
     */
    removeClass: function(klass, options) {
        if (!this._classes[klass]) return;
        delete this._classes[klass];
        if (this.style) this.style._cascade(this._classes, options);
    },

    /**
     * Helper method to add more than one class
     *
     * @param {Array<string>} klasses An array of class names
     * @param {StyleOptions} [options]
     * @fires change
     * @returns {Map} `this`
     */
    setClasses: function(klasses, options) {
        this._classes = {};
        for (var i = 0; i < klasses.length; i++) {
            this._classes[klasses[i]] = true;
        }
        if (this.style) this.style._cascade(this._classes, options);
    },

    /**
     * Check whether a style class is active
     *
     * @param {string} klass Name of style class
     * @returns {boolean}
     */
    hasClass: function(klass) {
        return !!this._classes[klass];
    },

    /**
     * Return an array of the current active style classes
     *
     * @returns {boolean}
     */
    getClasses: function() {
        return Object.keys(this._classes);
    },

    /**
     * Detect the map's new width and height and resize it.
     *
     * @returns {Map} `this`
     */
    resize: function() {
        var width = 0, height = 0;

        if (this._container) {
            width = this._container.offsetWidth || 400;
            height = this._container.offsetHeight || 300;
        }

        this._canvas.resize(width, height);
        this.transform.resize(width, height);
        this.painter.resize(width, height);

        return this
            .fire('movestart')
            .fire('move')
            .fire('resize')
            .fire('moveend');
    },

    /**
     * Get the map's geographical bounds.
     *
     * @returns {LngLatBounds}
     */
    getBounds: function() {
        var bounds = new LngLatBounds(
            this.transform.pointLocation(new Point(0, 0)),
            this.transform.pointLocation(this.transform.size));

        if (this.transform.angle || this.transform.pitch) {
            bounds.extend(this.transform.pointLocation(new Point(this.transform.size.x, 0)));
            bounds.extend(this.transform.pointLocation(new Point(0, this.transform.size.y)));
        }

        return bounds;
    },

    /**
     * Set constraint on the map's geographical bounds. Pan or zoom operations that would result in
     * displaying regions that fall outside of the bounds instead result in displaying the map at the
     * closest point and/or zoom level of the requested operation that is within the max bounds.
     *
     * @param {LngLatBounds | Array<Array<number>> | null | undefined} lnglatbounds Desired max bounds of the map. If null or undefined, function removes any bounds constraints on the map.
     * @returns {Map} `this`
     */
    setMaxBounds: function (lnglatbounds) {
        if (lnglatbounds) {
            var b = LngLatBounds.convert(lnglatbounds);
            this.transform.lngRange = [b.getWest(), b.getEast()];
            this.transform.latRange = [b.getSouth(), b.getNorth()];
            this.transform._constrain();
            this._update();
        } else if (lnglatbounds === null || lnglatbounds === undefined) {
            this.transform.lngRange = [];
            this.transform.latRange = [];
            this._update();
        }
        return this;

    },
    /**
     * Set the map's minimum zoom level, and zooms map to that level if it is currently below it. If no parameter provided, unsets the current minimum zoom (sets it to 0)
     * @param {zoom} any number between 0 and 20
     * @returns {Map} `this`
     */
    setMinZoom: function(minZoom) {

        minZoom = minZoom === null || minZoom === undefined ? defaultMinZoom : minZoom;

        if (minZoom >= defaultMinZoom && minZoom <= this.transform.maxZoom) {
            this.transform.minZoom = minZoom;
            this._update();

            if (this.getZoom() < minZoom) this.setZoom(minZoom);

            return this;
        }

        else throw new Error('minZoom must be between ' + defaultMinZoom + ' and the current maxZoom, inclusive');
    },

    /**
     * Set the map's maximum zoom level, and zooms map to that level if it is currently above it. If no parameter provided, unsets the current maximum zoom (sets it to 20)
     * @param {zoom} any number between 0 and 20
     * @returns {Map} `this`
     */
    setMaxZoom: function(maxZoom) {

        maxZoom = maxZoom === null || maxZoom === undefined ? defaultMaxZoom : maxZoom;

        if (maxZoom >= this.transform.minZoom && maxZoom <= defaultMaxZoom) {
            this.transform.maxZoom = maxZoom;
            this._update();

            if (this.getZoom() > maxZoom) this.setZoom(maxZoom);

            return this;
        }

        else throw new Error('maxZoom must be between the current minZoom and ' + defaultMaxZoom + ', inclusive');
    },
    /**
     * Get pixel coordinates (relative to map container) given a geographical location
     *
     * @param {LngLat} lnglat
     * @returns {Object} `x` and `y` coordinates
     */
    project: function(lnglat) {
        return this.transform.locationPoint(LngLat.convert(lnglat));
    },

    /**
     * Get geographical coordinates given pixel coordinates
     *
     * @param {Array<number>} point [x, y] pixel coordinates
     * @returns {LngLat}
     */
    unproject: function(point) {
        return this.transform.pointLocation(Point.convert(point));
    },

    /**
     * Query rendered features within a point or rectangle.
     *
     * @param {Point|Array<number>|Array<Point>|Array<Array<number>>} [pointOrBox] Either [x, y] pixel coordinates of a point, or [[x1, y1], [x2, y2]] pixel coordinates of opposite corners of bounding rectangle. Optional: use entire viewport if omitted.
     * @param {Object} params
     * @param {Array<string>} [params.layers] Only query features from layers with these layer IDs.
     * @param {Array} [params.filter] A mapbox-gl-style-spec filter.
     *
     * @returns {Array<Object>} features - An array of [GeoJSON](http://geojson.org/) features matching the query parameters. The GeoJSON properties of each feature are taken from the original source. Each feature object also contains a top-level `layer` property whose value is an object representing the style layer to which the feature belongs. Layout and paint properties in this object contain values which are fully evaluated for the given zoom level and feature.
     *
     * @example
     * var features = map.queryRenderedFeatures([20, 35], { layers: ['my-layer-name'] });
     *
     * @example
     * var features = map.queryRenderedFeatures([[10, 20], [30, 50]], { layers: ['my-layer-name'] });
     */
    queryRenderedFeatures: function(pointOrBox, params) {
        if (!(pointOrBox instanceof Point || Array.isArray(pointOrBox))) {
            params = pointOrBox;
            pointOrBox = undefined;
        }
        var queryGeometry = this._makeQueryGeometry(pointOrBox);
        return this.style.queryRenderedFeatures(queryGeometry, params, this._classes, this.transform.zoom, this.transform.angle);
    },

    _makeQueryGeometry: function(pointOrBox) {
        if (pointOrBox === undefined) {
            // bounds was omitted: use full viewport
            pointOrBox = [
                Point.convert([0, 0]),
                Point.convert([this.transform.width, this.transform.height])
            ];
        }

        var queryGeometry;
        var isPoint = pointOrBox instanceof Point || typeof pointOrBox[0] === 'number';

        if (isPoint) {
            var point = Point.convert(pointOrBox);
            queryGeometry = [point];
        } else {
            var box = [Point.convert(pointOrBox[0]), Point.convert(pointOrBox[1])];
            queryGeometry = [
                box[0],
                new Point(box[1].x, box[0].y),
                box[1],
                new Point(box[0].x, box[1].y),
                box[0]
            ];
        }

        queryGeometry = queryGeometry.map(function(p) {
            return this.transform.pointCoordinate(p);
        }.bind(this));

        return queryGeometry;
    },

    /**
     * Get data from vector tiles as an array of GeoJSON Features.
     *
     * @param {string} sourceID source ID
     * @param {Object} params
     * @param {string} [params.sourceLayer] The name of the vector tile layer to get features from.
     * @param {Array} [params.filter] A mapbox-gl-style-spec filter.
     *
     * @returns {Array<Object>} features - An array of [GeoJSON](http://geojson.org/) features matching the query parameters. The GeoJSON properties of each feature are taken from the original source. Each feature object also contains a top-level `layer` property whose value is an object representing the style layer to which the feature belongs. Layout and paint properties in this object contain values which are fully evaluated for the given zoom level and feature.
     */
    querySourceFeatures: function(sourceID, params) {
        var source = this.getSource(sourceID);
        return source && source.querySourceFeatures ?
            source.querySourceFeatures(params) :
            [];
    },

    /**
     * Apply multiple style mutations in a batch
     *
     * @param {function} work Function which accepts a `StyleBatch` object,
     *      a subset of `Map`, with `addLayer`, `removeLayer`,
     *      `setPaintProperty`, `setLayoutProperty`, `setFilter`,
     *      `setLayerZoomRange`, `addSource`, and `removeSource`
     *
     * @example
     * map.batch(function (batch) {
     *     batch.addLayer(layer1);
     *     batch.addLayer(layer2);
     *     ...
     *     batch.addLayer(layerN);
     * });
     *
     */
    batch: function(work) {
        this.style.batch(work);

        this.style._cascade(this._classes);
        this._update(true);
    },

    /**
     * Replaces the map's style object
     *
     * @param {Object} style A style object formatted as JSON
     * @returns {Map} `this`
     */
    setStyle: function(style) {
        if (this.style) {
            this.style
                .off('load', this._onStyleLoad)
                .off('error', this._forwardStyleEvent)
                .off('change', this._onStyleChange)
                .off('source.add', this._onSourceAdd)
                .off('source.remove', this._onSourceRemove)
                .off('source.load', this._onSourceUpdate)
                .off('source.error', this._forwardSourceEvent)
                .off('source.change', this._onSourceUpdate)
                .off('layer.add', this._forwardLayerEvent)
                .off('layer.remove', this._forwardLayerEvent)
                .off('layer.error', this._forwardLayerEvent)
                .off('tile.add', this._forwardTileEvent)
                .off('tile.remove', this._forwardTileEvent)
                .off('tile.load', this._update)
                .off('tile.error', this._forwardTileEvent)
                .off('tile.stats', this._forwardTileEvent)
                ._remove();

            this.off('rotate', this.style._redoPlacement);
            this.off('pitch', this.style._redoPlacement);
        }

        if (!style) {
            this.style = null;
            return this;
        } else if (style instanceof Style) {
            this.style = style;
        } else {
            this.style = new Style(style, this.animationLoop);
        }

        this.style
            .on('load', this._onStyleLoad)
            .on('error', this._forwardStyleEvent)
            .on('change', this._onStyleChange)
            .on('source.add', this._onSourceAdd)
            .on('source.remove', this._onSourceRemove)
            .on('source.load', this._onSourceUpdate)
            .on('source.error', this._forwardSourceEvent)
            .on('source.change', this._onSourceUpdate)
            .on('layer.add', this._forwardLayerEvent)
            .on('layer.remove', this._forwardLayerEvent)
            .on('layer.error', this._forwardLayerEvent)
            .on('tile.add', this._forwardTileEvent)
            .on('tile.remove', this._forwardTileEvent)
            .on('tile.load', this._update)
            .on('tile.error', this._forwardTileEvent)
            .on('tile.stats', this._forwardTileEvent);

        this.on('rotate', this.style._redoPlacement);
        this.on('pitch', this.style._redoPlacement);

        return this;
    },

    /**
     * Get a style object that can be used to recreate the map's style
     *
     * @returns {Object} style
     */
    getStyle: function() {
        return this.style.serialize();
    },

    /**
     * Add a source to the map style.
     *
     * @param {string} id ID of the source. Must not be used by any existing source.
     * @param {Object} source source specification, following the
     * [Mapbox GL Style Reference](https://www.mapbox.com/mapbox-gl-style-spec/#sources)
     * @fires source.add
     * @returns {Map} `this`
     */
    addSource: function(id, source) {
        this.style.addSource(id, source);
        return this;
    },

    /**
     * Remove an existing source from the map style.
     *
     * @param {string} id ID of the source to remove
     * @fires source.remove
     * @returns {Map} `this`
     */
    removeSource: function(id) {
        this.style.removeSource(id);
        return this;
    },

    /**
     * Return the style source object with the given `id`.
     *
     * @param {string} id source ID
     * @returns {Object}
     */
    getSource: function(id) {
        return this.style.getSource(id);
    },

    /**
     * Add a layer to the map style. The layer will be inserted before the layer with
     * ID `before`, or appended if `before` is omitted.
     * @param {StyleLayer|Object} layer
     * @param {string=} before  ID of an existing layer to insert before
     * @fires layer.add
     * @returns {Map} `this`
     */
    addLayer: function(layer, before) {
        this.style.addLayer(layer, before);
        this.style._cascade(this._classes);
        return this;
    },

    /**
     * Remove the layer with the given `id` from the map. Any layers which refer to the
     * specified layer via a `ref` property are also removed.
     *
     * @param {string} id layer id
     * @throws {Error} if no layer with the given `id` exists
     * @fires layer.remove
     * @returns {Map} `this`
     */
    removeLayer: function(id) {
        this.style.removeLayer(id);
        this.style._cascade(this._classes);
        return this;
    },

    /**
     * Return the style layer object with the given `id`.
     *
     * @param {string} id layer id
     * @returns {?Object} a layer, if one with the given `id` exists
     */
    getLayer: function(id) {
        return this.style.getLayer(id);
    },

    /**
     * Set the filter for a given style layer.
     *
     * @param {string} layer ID of a layer
     * @param {Array} filter filter specification, as defined in the [Style Specification](https://www.mapbox.com/mapbox-gl-style-spec/#types-filter)
     * @returns {Map} `this`
     */
    setFilter: function(layer, filter) {
        this.style.setFilter(layer, filter);
        return this;
    },

    /**
     * Set the zoom extent for a given style layer.
     *
     * @param {string} layerId ID of a layer
     * @param {number} minzoom minimum zoom extent
     * @param {number} maxzoom maximum zoom extent
     * @returns {Map} `this`
     */
    setLayerZoomRange: function(layerId, minzoom, maxzoom) {
        this.style.setLayerZoomRange(layerId, minzoom, maxzoom);
        return this;
    },

    /**
     * Get the filter for a given style layer.
     *
     * @param {string} layer ID of a layer
     * @returns {Array} filter specification, as defined in the [Style Specification](https://www.mapbox.com/mapbox-gl-style-spec/#filter)
     */
    getFilter: function(layer) {
        return this.style.getFilter(layer);
    },

    /**
     * Set the value of a paint property in a given style layer.
     *
     * @param {string} layer ID of a layer
     * @param {string} name name of a paint property
     * @param {*} value value for the paint propery; must have the type appropriate for the property as defined in the [Style Specification](https://www.mapbox.com/mapbox-gl-style-spec/)
     * @param {string=} klass optional class specifier for the property
     * @returns {Map} `this`
     */
    setPaintProperty: function(layer, name, value, klass) {
        this.batch(function(batch) {
            batch.setPaintProperty(layer, name, value, klass);
        });

        return this;
    },

    /**
     * Get the value of a paint property in a given style layer.
     *
     * @param {string} layer ID of a layer
     * @param {string} name name of a paint property
     * @param {string=} klass optional class specifier for the property
     * @returns {*} value for the paint propery
     */
    getPaintProperty: function(layer, name, klass) {
        return this.style.getPaintProperty(layer, name, klass);
    },

    /**
     * Set the value of a layout property in a given style layer.
     *
     * @param {string} layer ID of a layer
     * @param {string} name name of a layout property
     * @param {*} value value for the layout propery; must have the type appropriate for the property as defined in the [Style Specification](https://www.mapbox.com/mapbox-gl-style-spec/)
     * @returns {Map} `this`
     */
    setLayoutProperty: function(layer, name, value) {
        this.batch(function(batch) {
            batch.setLayoutProperty(layer, name, value);
        });

        return this;
    },

    /**
     * Get the value of a layout property in a given style layer.
     *
     * @param {string} layer ID of a layer
     * @param {string} name name of a layout property
     * @param {string=} klass optional class specifier for the property
     * @returns {*} value for the layout propery
     */
    getLayoutProperty: function(layer, name) {
        return this.style.getLayoutProperty(layer, name);
    },

    /**
     * Get the Map's container as an HTML element
     * @returns {HTMLElement} container
     */
    getContainer: function() {
        return this._container;
    },

    /**
     * Get the container for the map `canvas` element.
     *
     * If you want to add non-GL overlays to the map, you should append them to this element. This
     * is the element to which event bindings for map interactivity such as panning and zooming are
     * attached. It will receive bubbled events for child elements such as the `canvas`, but not for
     * map controls.
     *
     * @returns {HTMLElement} container
     */
    getCanvasContainer: function() {
        return this._canvasContainer;
    },

    /**
     * Get the Map's canvas as an HTML canvas
     * @returns {HTMLElement} canvas
     */
    getCanvas: function() {
        return this._canvas.getElement();
    },

    _setupContainer: function() {
        var container = this._container;
        container.classList.add('mapboxgl-map');

        var canvasContainer = this._canvasContainer = DOM.create('div', 'mapboxgl-canvas-container', container);
        if (this._interactive) {
            canvasContainer.classList.add('mapboxgl-interactive');
        }
        this._canvas = new Canvas(this, canvasContainer);

        var controlContainer = this._controlContainer = DOM.create('div', 'mapboxgl-control-container', container);
        var corners = this._controlCorners = {};
        ['top-left', 'top-right', 'bottom-left', 'bottom-right'].forEach(function (pos) {
            corners[pos] = DOM.create('div', 'mapboxgl-ctrl-' + pos, controlContainer);
        });
    },

    _setupPainter: function() {
        var gl = this._canvas.getWebGLContext({
            failIfMajorPerformanceCaveat: this._failIfMajorPerformanceCaveat,
            preserveDrawingBuffer: this._preserveDrawingBuffer
        });

        if (!gl) {
            console.error('Failed to initialize WebGL');
            return;
        }

        this.painter = new Painter(gl, this.transform);
    },

    /**
     * WebGL Context Lost event.
     *
     * @event webglcontextlost
     * @memberof Map
     * @instance
     * @type {Object}
     * @property {Event} originalEvent the original DOM event
     */
    _contextLost: function(event) {
        event.preventDefault();
        if (this._frameId) {
            browser.cancelFrame(this._frameId);
        }
        this.fire("webglcontextlost", {originalEvent: event});
    },

    /**
     * WebGL Context Restored event.
     *
     * @event webglcontextrestored
     * @memberof Map
     * @instance
     * @type {Object}
     */
    _contextRestored: function(event) {
        this._setupPainter();
        this.resize();
        this._update();
        this.fire("webglcontextrestored", {originalEvent: event});
    },

    /**
     * Is this map fully loaded? If the style isn't loaded
     * or it has a change to the sources or style that isn't
     * propagated to its style, return false.
     *
     * @returns {boolean} whether the map is loaded
     */
    loaded: function() {
        if (this._styleDirty || this._sourcesDirty)
            return false;
        if (!this.style || !this.style.loaded())
            return false;
        return true;
    },

    /**
     * Update this map's style and sources, and re-render the map.
     *
     * @param {boolean} updateStyle mark the map's style for reprocessing as
     * well as its sources
     * @returns {Map} this
     * @private
     */
    _update: function(updateStyle) {
        if (!this.style) return this;

        this._styleDirty = this._styleDirty || updateStyle;
        this._sourcesDirty = true;

        this._rerender();

        return this;
    },

    /**
     * Call when a (re-)render of the map is required, e.g. when the
     * user panned or zoomed,f or new data is available.
     * @returns {Map} this
     * @private
     */
    _render: function() {
        if (this.style && this._styleDirty) {
            this._styleDirty = false;
            this.style._recalculate(this.transform.zoom);
        }

        if (this.style && this._sourcesDirty) {
            this._sourcesDirty = false;
            this.style._updateSources(this.transform);
        }

        this.painter.render(this.style, {
            debug: this.showTileBoundaries,
            vertices: this.vertices,
            rotating: this.rotating,
            zooming: this.zooming
        });

        this.fire('render');

        if (this.loaded() && !this._loaded) {
            this._loaded = true;
            this.fire('load');
        }

        this._frameId = null;

        if (!this.animationLoop.stopped()) {
            this._styleDirty = true;
        }

        if (this._sourcesDirty || this._repaint || !this.animationLoop.stopped()) {
            this._rerender();
        }

        return this;
    },

    /**
     * Destroys the map's underlying resources, including web workers and DOM elements. Afterwards,
     * you must not call any further methods on this Map instance.
     *
     * @returns {undefined}
     */
    remove: function() {
        if (this._hash) this._hash.remove();
        browser.cancelFrame(this._frameId);
        this.setStyle(null);
        if (typeof window !== 'undefined') {
            window.removeEventListener('resize', this._onWindowResize, false);
        }
        removeNode(this._canvasContainer);
        removeNode(this._controlContainer);
        this._container.classList.remove('mapboxgl-map');
    },

    /**
     * A default error handler for `style.error`, `source.error`, `layer.error`,
     * and `tile.error` events.
     * It logs the error via `console.error`.
     *
     * @example
     * // Disable the default error handler
     * map.off('style.error', map.onError);
     * map.off('source.error', map.onError);
     * map.off('tile.error', map.onError);
     * map.off('layer.error', map.onError);
     */
    onError: function(e) {
        console.error(e.error);
    },

    _rerender: function() {
        if (this.style && !this._frameId) {
            this._frameId = browser.frame(this._render);
        }
    },

    _forwardStyleEvent: function(e) {
        this.fire('style.' + e.type, util.extend({style: e.target}, e));
    },

    _forwardSourceEvent: function(e) {
        this.fire(e.type, util.extend({style: e.target}, e));
    },

    _forwardLayerEvent: function(e) {
        this.fire(e.type, util.extend({style: e.target}, e));
    },

    _forwardTileEvent: function(e) {
        this.fire(e.type, util.extend({style: e.target}, e));
    },

    _onStyleLoad: function(e) {
        if (this.transform.unmodified) {
            this.jumpTo(this.style.stylesheet);
        }
        this.style._cascade(this._classes, {transition: false});
        this._forwardStyleEvent(e);
    },

    _onStyleChange: function(e) {
        this._update(true);
        this._forwardStyleEvent(e);
    },

    _onSourceAdd: function(e) {
        var source = e.source;
        if (source.onAdd)
            source.onAdd(this);
        this._forwardSourceEvent(e);
    },

    _onSourceRemove: function(e) {
        var source = e.source;
        if (source.onRemove)
            source.onRemove(this);
        this._forwardSourceEvent(e);
    },

    _onSourceUpdate: function(e) {
        this._update();
        this._forwardSourceEvent(e);
    },

    _onWindowResize: function() {
        this.stop().resize()._update();
    }
});

util.extendAll(Map.prototype, /** @lends Map.prototype */{

    /**
     * Draw an outline around each rendered tile for debugging.
     *
     * @name showTileBoundaries
     * @type {boolean}
     */
    _showTileBoundaries: false,
    get showTileBoundaries() { return this._showTileBoundaries; },
    set showTileBoundaries(value) {
        if (this._showTileBoundaries === value) return;
        this._showTileBoundaries = value;
        this._update();
    },

    /**
     * Draw boxes around all symbols in the data source, showing which were
     * rendered and which were hidden due to collisions with other symbols for
     * style debugging.
     *
     * @name showCollisionBoxes
     * @type {boolean}
     */
    _showCollisionBoxes: false,
    get showCollisionBoxes() { return this._showCollisionBoxes; },
    set showCollisionBoxes(value) {
        if (this._showCollisionBoxes === value) return;
        this._showCollisionBoxes = value;
        this.style._redoPlacement();
    },

    /**
     * Enable continuous repaint to analyze performance
     *
     * @name repaint
     * @type {boolean}
     */
    _repaint: false,
    get repaint() { return this._repaint; },
    set repaint(value) { this._repaint = value; this._update(); },

    // show vertices
    _vertices: false,
    get vertices() { return this._vertices; },
    set vertices(value) { this._vertices = value; this._update(); }
});

function removeNode(node) {
    if (node.parentNode) {
        node.parentNode.removeChild(node);
    }
}

},{"../geo/lng_lat":10,"../geo/lng_lat_bounds":11,"../geo/transform":12,"../render/painter":26,"../style/animation_loop":41,"../style/style":44,"../util/browser":89,"../util/canvas":90,"../util/dom":92,"../util/evented":95,"../util/util":104,"./camera":71,"./control/attribution":72,"./hash":83,"./interaction":84,"point-geometry":162}],86:[function(require,module,exports){
'use strict';

module.exports = Popup;

var util = require('../util/util');
var Evented = require('../util/evented');
var DOM = require('../util/dom');
var LngLat = require('../geo/lng_lat');

/**
 * Creates a popup component
 * @class Popup
 * @param {Object} options
 * @param {boolean} options.closeButton
 * @param {boolean} options.closeOnClick
 * @param {string} options.anchor - One of "top", "bottom", "left", "right", "top-left",
 * "top-right", "bottom-left", or "bottom-right", describing where the popup's anchor
 * relative to the coordinate set via `setLngLat`.
 * @example
 * var tooltip = new mapboxgl.Popup()
 *   .setLngLat(e.lngLat)
 *   .setHTML("<h1>Hello World!</h1>")
 *   .addTo(map);
 */
function Popup(options) {
    util.setOptions(this, options);
    util.bindAll([
        '_update',
        '_onClickClose'],
        this);
}

Popup.prototype = util.inherit(Evented, /** @lends Popup.prototype */{
    options: {
        closeButton: true,
        closeOnClick: true
    },

    /**
     * Attaches the popup to a map
     * @param {Map} map
     * @returns {Popup} `this`
     */
    addTo: function(map) {
        this._map = map;
        this._map.on('move', this._update);
        if (this.options.closeOnClick) {
            this._map.on('click', this._onClickClose);
        }
        this._update();
        return this;
    },

    /**
     * Removes the popup from the map
     * @example
     * var popup = new mapboxgl.Popup().addTo(map);
     * popup.remove();
     * @returns {Popup} `this`
     */
    remove: function() {
        if (this._content && this._content.parentNode) {
            this._content.parentNode.removeChild(this._content);
        }

        if (this._container) {
            this._container.parentNode.removeChild(this._container);
            delete this._container;
        }

        if (this._map) {
            this._map.off('move', this._update);
            this._map.off('click', this._onClickClose);
            delete this._map;
        }

        return this;
    },

    /**
     * Get the current coordinates of popup element relative to map
     * @returns {LngLat}
     */
    getLngLat: function() {
        return this._lngLat;
    },

    /**
     * Set the coordinates of a popup element to a map
     * @param {LngLat} lnglat
     * @returns {Popup} `this`
     */
    setLngLat: function(lnglat) {
        this._lngLat = LngLat.convert(lnglat);
        this._update();
        return this;
    },

    /**
     * Fill a popup element with text only content
     * @param {string} text
     * @returns {Popup} `this`
     */
    setText: function(text) {
        this._createContent();
        this._content.appendChild(document.createTextNode(text));

        this._update();
        return this;
    },

    /**
     * Fill a popup element with HTML content
     * @param {string} html
     * @returns {Popup} `this`
     */
    setHTML: function(html) {
        this._createContent();

        var temp = document.createElement('body'), child;
        temp.innerHTML = html;
        while (true) {
            child = temp.firstChild;
            if (!child) break;
            this._content.appendChild(child);
        }

        this._update();
        return this;
    },

    _createContent: function() {
        if (this._content && this._content.parentNode) {
            this._content.parentNode.removeChild(this._content);
        }

        this._content = DOM.create('div', 'mapboxgl-popup-content', this._container);

        if (this.options.closeButton) {
            this._closeButton = DOM.create('button', 'mapboxgl-popup-close-button', this._content);
            this._closeButton.innerHTML = '&#215;';
            this._closeButton.addEventListener('click', this._onClickClose);
        }
    },

    _update: function() {
        if (!this._map || !this._lngLat || !this._content) { return; }

        if (!this._container) {
            this._container = DOM.create('div', 'mapboxgl-popup', this._map.getContainer());
            this._tip       = DOM.create('div', 'mapboxgl-popup-tip', this._container);
            this._container.appendChild(this._content);
        }

        var pos = this._map.project(this._lngLat).round(),
            anchor = this.options.anchor;

        if (!anchor) {
            var width = this._container.offsetWidth,
                height = this._container.offsetHeight;

            if (pos.y < height) {
                anchor = ['top'];
            } else if (pos.y > this._map.transform.height - height) {
                anchor = ['bottom'];
            } else {
                anchor = [];
            }

            if (pos.x < width / 2) {
                anchor.push('left');
            } else if (pos.x > this._map.transform.width - width / 2) {
                anchor.push('right');
            }

            if (anchor.length === 0) {
                anchor = 'bottom';
            } else {
                anchor = anchor.join('-');
            }
        }

        var anchorTranslate = {
            'top': 'translate(-50%,0)',
            'top-left': 'translate(0,0)',
            'top-right': 'translate(-100%,0)',
            'bottom': 'translate(-50%,-100%)',
            'bottom-left': 'translate(0,-100%)',
            'bottom-right': 'translate(-100%,-100%)',
            'left': 'translate(0,-50%)',
            'right': 'translate(-100%,-50%)'
        };

        var classList = this._container.classList;
        for (var key in anchorTranslate) {
            classList.remove('mapboxgl-popup-anchor-' + key);
        }
        classList.add('mapboxgl-popup-anchor-' + anchor);

        DOM.setTransform(this._container, anchorTranslate[anchor] + ' translate(' + pos.x + 'px,' + pos.y + 'px)');
    },

    _onClickClose: function() {
        this.remove();
    }
});

},{"../geo/lng_lat":10,"../util/dom":92,"../util/evented":95,"../util/util":104}],87:[function(require,module,exports){
'use strict';

module.exports = Actor;

/**
 * An implementation of the [Actor design pattern](http://en.wikipedia.org/wiki/Actor_model)
 * that maintains the relationship between asynchronous tasks and the objects
 * that spin them off - in this case, tasks like parsing parts of styles,
 * owned by the styles
 *
 * @param {WebWorker} target
 * @param {WebWorker} parent
 * @private
 */
function Actor(target, parent) {
    this.target = target;
    this.parent = parent;
    this.callbacks = {};
    this.callbackID = 0;
    this.receive = this.receive.bind(this);
    this.target.addEventListener('message', this.receive, false);
}

Actor.prototype.receive = function(message) {
    var data = message.data,
        callback;

    if (data.type === '<response>') {
        callback = this.callbacks[data.id];
        delete this.callbacks[data.id];
        callback(data.error || null, data.data);
    } else if (typeof data.id !== 'undefined') {
        var id = data.id;
        this.parent[data.type](data.data, function(err, data, buffers) {
            this.postMessage({
                type: '<response>',
                id: String(id),
                error: err ? String(err) : null,
                data: data
            }, buffers);
        }.bind(this));
    } else {
        this.parent[data.type](data.data);
    }
};

Actor.prototype.send = function(type, data, callback, buffers) {
    var id = null;
    if (callback) this.callbacks[id = this.callbackID++] = callback;
    this.postMessage({ type: type, id: String(id), data: data }, buffers);
};

/**
 * Wrapped postMessage API that abstracts around IE's lack of
 * `transferList` support.
 *
 * @param {Object} message
 * @param {Object} transferList
 * @private
 */
Actor.prototype.postMessage = function(message, transferList) {
    this.target.postMessage(message, transferList);
};

},{}],88:[function(require,module,exports){
'use strict';

exports.getJSON = function(url, callback) {
    var xhr = new XMLHttpRequest();
    xhr.open('GET', url, true);
    xhr.setRequestHeader('Accept', 'application/json');
    xhr.onerror = function(e) {
        callback(e);
    };
    xhr.onload = function() {
        if (xhr.status >= 200 && xhr.status < 300 && xhr.response) {
            var data;
            try {
                data = JSON.parse(xhr.response);
            } catch (err) {
                return callback(err);
            }
            callback(null, data);
        } else {
            callback(new Error(xhr.statusText));
        }
    };
    xhr.send();
    return xhr;
};

exports.getArrayBuffer = function(url, callback) {
    var xhr = new XMLHttpRequest();
    xhr.open('GET', url, true);
    xhr.responseType = 'arraybuffer';
    xhr.onerror = function(e) {
        callback(e);
    };
    xhr.onload = function() {
        if (xhr.status >= 200 && xhr.status < 300 && xhr.response) {
            callback(null, xhr.response);
        } else {
            callback(new Error(xhr.statusText));
        }
    };
    xhr.send();
    return xhr;
};

function sameOrigin(url) {
    var a = document.createElement('a');
    a.href = url;
    return a.protocol === document.location.protocol && a.host === document.location.host;
}

exports.getImage = function(url, callback) {
    return exports.getArrayBuffer(url, function(err, imgData) {
        if (err) return callback(err);
        var img = new Image();
        img.onload = function() {
            callback(null, img);
            (window.URL || window.webkitURL).revokeObjectURL(img.src);
        };
        var blob = new Blob([new Uint8Array(imgData)], { type: 'image/png' });
        img.src = (window.URL || window.webkitURL).createObjectURL(blob);
        img.getData = function() {
            var canvas = document.createElement('canvas');
            var context = canvas.getContext('2d');
            canvas.width = img.width;
            canvas.height = img.height;
            context.drawImage(img, 0, 0);
            return context.getImageData(0, 0, img.width, img.height).data;
        };
        return img;
    });
};

exports.getVideo = function(urls, callback) {
    var video = document.createElement('video');
    video.onloadstart = function() {
        callback(null, video);
    };
    for (var i = 0; i < urls.length; i++) {
        var s = document.createElement('source');
        if (!sameOrigin(urls[i])) {
            video.crossOrigin = 'Anonymous';
        }
        s.src = urls[i];
        video.appendChild(s);
    }
    video.getData = function() { return video; };
    return video;
};

},{}],89:[function(require,module,exports){
'use strict';

var Canvas = require('./canvas');

/**
 * Unlike js/util/browser.js, this code is written with the expectation
 * of a browser environment with a global 'window' object
 * @module browser
 * @private
 */

/**
 * Provides a function that outputs milliseconds: either performance.now()
 * or a fallback to Date.now()
 */
module.exports.now = (function() {
    if (window.performance &&
        window.performance.now) {
        return window.performance.now.bind(window.performance);
    } else {
        return Date.now.bind(Date);
    }
}());

var frame = window.requestAnimationFrame ||
    window.mozRequestAnimationFrame ||
    window.webkitRequestAnimationFrame ||
    window.msRequestAnimationFrame;

exports.frame = function(fn) {
    return frame(fn);
};

var cancel = window.cancelAnimationFrame ||
    window.mozCancelAnimationFrame ||
    window.webkitCancelAnimationFrame ||
    window.msCancelAnimationFrame;

exports.cancelFrame = function(id) {
    cancel(id);
};

exports.timed = function (fn, dur, ctx) {
    if (!dur) {
        fn.call(ctx, 1);
        return null;
    }

    var abort = false,
        start = module.exports.now();

    function tick(now) {
        if (abort) return;
        now = module.exports.now();

        if (now >= start + dur) {
            fn.call(ctx, 1);
        } else {
            fn.call(ctx, (now - start) / dur);
            exports.frame(tick);
        }
    }

    exports.frame(tick);

    return function() { abort = true; };
};

exports.supportsWebGL = {};

/**
 * Test whether the basic JavaScript and DOM features required for Mapbox GL are present.
 * @param {Object} options
 * @param {boolean} [options.failIfMajorPerformanceCaveat=false] If `true`, map creation will fail if the implementation determines that the performance of the created WebGL context would be dramatically lower than expected.
 * @return {boolean} Returns true if Mapbox GL should be expected to work, and false if not.
 * @memberof mapboxgl
 * @static
 */
exports.supported = function(options) {

    var supports = [

        function() { return typeof window !== 'undefined'; },

        function() { return typeof document !== 'undefined'; },

        function () {
            return !!(Array.prototype &&
                Array.prototype.every &&
                Array.prototype.filter &&
                Array.prototype.forEach &&
                Array.prototype.indexOf &&
                Array.prototype.lastIndexOf &&
                Array.prototype.map &&
                Array.prototype.some &&
                Array.prototype.reduce &&
                Array.prototype.reduceRight &&
                Array.isArray);
        },

        function() {
            return !!(Function.prototype && Function.prototype.bind) &&
                !!(Object.keys &&
                    Object.create &&
                    Object.getPrototypeOf &&
                    Object.getOwnPropertyNames &&
                    Object.isSealed &&
                    Object.isFrozen &&
                    Object.isExtensible &&
                    Object.getOwnPropertyDescriptor &&
                    Object.defineProperty &&
                    Object.defineProperties &&
                    Object.seal &&
                    Object.freeze &&
                    Object.preventExtensions);
        },

        function() {
            return 'JSON' in window && 'parse' in JSON && 'stringify' in JSON;
        },

        function() {
            var opt = (options && options.failIfMajorPerformanceCaveat) || false,
                fimpc = 'fimpc_' + String(opt);
            if (exports.supportsWebGL[fimpc] === undefined) {
                var canvas = new Canvas();
                exports.supportsWebGL[fimpc] = canvas.supportsWebGLContext(opt);
            }
            return exports.supportsWebGL[fimpc];
        },

        function() { return 'Worker' in window; }
    ];

    for (var i = 0; i < supports.length; i++) {
        if (!supports[i]()) return false;
    }
    return true;
};

exports.hardwareConcurrency = navigator.hardwareConcurrency || 8;

Object.defineProperty(exports, 'devicePixelRatio', {
    get: function() { return window.devicePixelRatio; }
});

exports.supportsWebp = false;

var webpImgTest = document.createElement('img');
webpImgTest.onload = function() {
    exports.supportsWebp = true;
};
webpImgTest.src = 'data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAQAAAAfQ//73v/+BiOh/AAA=';

exports.supportsGeolocation = !!navigator.geolocation;

},{"./canvas":90}],90:[function(require,module,exports){
'use strict';

var util = require('../util');

module.exports = Canvas;

function Canvas(parent, container) {
    this.canvas = document.createElement('canvas');

    if (parent && container) {
        this.canvas.style.position = 'absolute';
        this.canvas.classList.add('mapboxgl-canvas');
        this.canvas.addEventListener('webglcontextlost', parent._contextLost.bind(parent), false);
        this.canvas.addEventListener('webglcontextrestored', parent._contextRestored.bind(parent), false);
        this.canvas.setAttribute('tabindex', 0);
        container.appendChild(this.canvas);
    }
}

Canvas.prototype.resize = function(width, height) {
    var pixelRatio = window.devicePixelRatio || 1;

    // Request the required canvas size taking the pixelratio into account.
    this.canvas.width = pixelRatio * width;
    this.canvas.height = pixelRatio * height;

    // Maintain the same canvas size, potentially downscaling it for HiDPI displays
    this.canvas.style.width = width + 'px';
    this.canvas.style.height = height + 'px';
};

var requiredContextAttributes = {
    antialias: false,
    alpha: true,
    stencil: true,
    depth: true
};

Canvas.prototype.getWebGLContext = function(attributes) {
    attributes = util.extend({}, attributes, requiredContextAttributes);

    return this.canvas.getContext('webgl', attributes) ||
        this.canvas.getContext('experimental-webgl', attributes);
};

Canvas.prototype.supportsWebGLContext = function(failIfMajorPerformanceCaveat) {
    var attributes = util.extend({
        failIfMajorPerformanceCaveat: failIfMajorPerformanceCaveat
    }, requiredContextAttributes);

    if ('probablySupportsContext' in this.canvas) {
        return this.canvas.probablySupportsContext('webgl', attributes) ||
            this.canvas.probablySupportsContext('experimental-webgl', attributes);
    } else if ('supportsContext' in this.canvas) {
        return this.canvas.supportsContext('webgl', attributes) ||
            this.canvas.supportsContext('experimental-webgl', attributes);
    }

    return !!window.WebGLRenderingContext && !!this.getWebGLContext(failIfMajorPerformanceCaveat);
};

Canvas.prototype.getElement = function() {
    return this.canvas;
};

},{"../util":104}],91:[function(require,module,exports){
'use strict';

var Actor = require('../actor');
var WebWorkify = require('webworkify');

module.exports = Dispatcher;

function Dispatcher(length, parent) {
    this.actors = [];
    this.currentActor = 0;
    for (var i = 0; i < length; i++) {
        var worker = new WebWorkify(require('../../source/worker'));
        var actor = new Actor(worker, parent);
        actor.name = "Worker " + i;
        this.actors.push(actor);
    }
}

Dispatcher.prototype = {
    broadcast: function(type, data) {
        for (var i = 0; i < this.actors.length; i++) {
            this.actors[i].send(type, data);
        }
    },

    send: function(type, data, callback, targetID, buffers) {
        if (typeof targetID !== 'number' || isNaN(targetID)) {
            // Use round robin to send requests to web workers.
            targetID = this.currentActor = (this.currentActor + 1) % this.actors.length;
        }

        this.actors[targetID].send(type, data, callback, buffers);
        return targetID;
    },

    remove: function() {
        for (var i = 0; i < this.actors.length; i++) {
            this.actors[i].target.terminate();
        }
        this.actors = [];
    }
};

},{"../../source/worker":39,"../actor":87,"webworkify":175}],92:[function(require,module,exports){
'use strict';

var Point = require('point-geometry');

exports.create = function (tagName, className, container) {
    var el = document.createElement(tagName);
    if (className) el.className = className;
    if (container) container.appendChild(el);
    return el;
};

var docStyle = document.documentElement.style;

function testProp(props) {
    for (var i = 0; i < props.length; i++) {
        if (props[i] in docStyle) {
            return props[i];
        }
    }
}

var selectProp = testProp(['userSelect', 'MozUserSelect', 'WebkitUserSelect', 'msUserSelect']),
    userSelect;
exports.disableDrag = function () {
    if (selectProp) {
        userSelect = docStyle[selectProp];
        docStyle[selectProp] = 'none';
    }
};
exports.enableDrag = function () {
    if (selectProp) {
        docStyle[selectProp] = userSelect;
    }
};

var transformProp = testProp(['transform', 'WebkitTransform']);
exports.setTransform = function(el, value) {
    el.style[transformProp] = value;
};

// Suppress the next click, but only if it's immediate.
function suppressClick(e) {
    e.preventDefault();
    e.stopPropagation();
    window.removeEventListener('click', suppressClick, true);
}
exports.suppressClick = function() {
    window.addEventListener('click', suppressClick, true);
    window.setTimeout(function() {
        window.removeEventListener('click', suppressClick, true);
    }, 0);
};

exports.mousePos = function (el, e) {
    var rect = el.getBoundingClientRect();
    e = e.touches ? e.touches[0] : e;
    return new Point(
        e.clientX - rect.left - el.clientLeft,
        e.clientY - rect.top - el.clientTop
    );
};

exports.touchPos = function (el, e) {
    var rect = el.getBoundingClientRect(),
        points = [];
    for (var i = 0; i < e.touches.length; i++) {
        points.push(new Point(
            e.touches[i].clientX - rect.left - el.clientLeft,
            e.touches[i].clientY - rect.top - el.clientTop
        ));
    }
    return points;
};

},{"point-geometry":162}],93:[function(require,module,exports){
'use strict';

module.exports = {
    API_URL: 'https://api.mapbox.com',
    REQUIRE_ACCESS_TOKEN: true
};

},{}],94:[function(require,module,exports){
'use strict';

module.exports = DictionaryCoder;

function DictionaryCoder(strings) {
    this._stringToNumber = {};
    this._numberToString = [];
    for (var i = 0; i < strings.length; i++) {
        var string = strings[i];
        this._stringToNumber[string] = i;
        this._numberToString[i] = string;
    }
}

DictionaryCoder.prototype.encode = function(string) {
    return this._stringToNumber[string];
};

DictionaryCoder.prototype.decode = function(n) {
    return this._numberToString[n];
};

},{}],95:[function(require,module,exports){
'use strict';

var util = require('./util');

/**
 * Methods mixed in to other classes for event capabilities.
 * @mixin Evented
 */
var Evented = {

    /**
     * Subscribe to a specified event with a listener function the latter gets the data object that was passed to `fire` and additionally `target` and `type` properties
     *
     * @param {string} type Event type
     * @param {Function} listener Function to be called when the event is fired
     */
    on: function(type, fn) {
        this._events = this._events || {};
        this._events[type] = this._events[type] || [];
        this._events[type].push(fn);

        return this;
    },

    /**
     * Remove a event listener
     *
     * @param {string} [type] Event type. If none is specified, remove all listeners
     * @param {Function} [listener] Function to be called when the event is fired. If none is specified all listeners are removed
     */
    off: function(type, fn) {
        if (!type) {
            // clear all listeners if no arguments specified
            delete this._events;
            return this;
        }

        if (!this.listens(type)) return this;

        if (fn) {
            var idx = this._events[type].indexOf(fn);
            if (idx >= 0) {
                this._events[type].splice(idx, 1);
            }
            if (!this._events[type].length) {
                delete this._events[type];
            }
        } else {
            delete this._events[type];
        }

        return this;
    },

    /**
     * Call a function once when an event has fired
     *
     * @param {string} type Event type.
     * @param {Function} listener Function to be called once when the event is fired
     */
    once: function(type, fn) {
        var wrapper = function(data) {
            this.off(type, wrapper);
            fn.call(this, data);
        }.bind(this);
        this.on(type, wrapper);
        return this;
    },

    /**
     * Fire event of a given string type with the given data object
     *
     * @param {string} type Event type
     * @param {Object} [data] Optional data passed to the event receiver (e.g. {@link #EventData})
     * @returns {Object} `this`
     */
    fire: function(type, data) {
        if (!this.listens(type)) return this;

        data = util.extend({}, data);
        util.extend(data, {type: type, target: this});

        // make sure adding/removing listeners inside other listeners won't cause infinite loop
        var listeners = this._events[type].slice();

        for (var i = 0; i < listeners.length; i++) {
            listeners[i].call(this, data);
        }

        return this;
    },

    /**
     * Check if an event is registered to a type
     * @param {string} type Event type
     * @returns {boolean} `true` if there is at least one registered listener for events of type `type`
     */
    listens: function(type) {
        return !!(this._events && this._events[type]);
    }
};

module.exports = Evented;

},{"./util":104}],96:[function(require,module,exports){
'use strict';

module.exports = Glyphs;

function Glyphs(pbf, end) {
    this.stacks = pbf.readFields(readFontstacks, [], end);
}

function readFontstacks(tag, stacks, pbf) {
    if (tag === 1) {
        var fontstack = pbf.readMessage(readFontstack, {glyphs: {}});
        stacks.push(fontstack);
    }
}

function readFontstack(tag, fontstack, pbf) {
    if (tag === 1) fontstack.name = pbf.readString();
    else if (tag === 2) fontstack.range = pbf.readString();
    else if (tag === 3) {
        var glyph = pbf.readMessage(readGlyph, {});
        fontstack.glyphs[glyph.id] = glyph;
    }
}

function readGlyph(tag, glyph, pbf) {
    if (tag === 1) glyph.id = pbf.readVarint();
    else if (tag === 2) glyph.bitmap = pbf.readBytes();
    else if (tag === 3) glyph.width = pbf.readVarint();
    else if (tag === 4) glyph.height = pbf.readVarint();
    else if (tag === 5) glyph.left = pbf.readSVarint();
    else if (tag === 6) glyph.top = pbf.readSVarint();
    else if (tag === 7) glyph.advance = pbf.readVarint();
}

},{}],97:[function(require,module,exports){
'use strict';

module.exports = Grid;

var NUM_PARAMS = 3;

function Grid(n, extent, padding) {
    var cells = this.cells = [];

    if (n instanceof ArrayBuffer) {
        this.arrayBuffer = n;
        var array = new Int32Array(this.arrayBuffer);
        n = array[0];
        extent = array[1];
        padding = array[2];

        this.d = n + 2 * padding;
        for (var k = 0; k < this.d * this.d; k++) {
            var start = array[NUM_PARAMS + k];
            var end = array[NUM_PARAMS + k + 1];
            cells.push(start === end ?
                    null :
                    array.subarray(start, end));
        }
        var keysOffset = array[NUM_PARAMS + cells.length];
        var bboxesOffset = array[NUM_PARAMS + cells.length + 1];
        this.keys = array.subarray(keysOffset, bboxesOffset);
        this.bboxes = array.subarray(bboxesOffset);
    } else {
        this.d = n + 2 * padding;
        for (var i = 0; i < this.d * this.d; i++) {
            cells.push([]);
        }
        this.keys = [];
        this.bboxes = [];
    }

    this.n = n;
    this.extent = extent;
    this.padding = padding;
    this.scale = n / extent;
    this.uid = 0;

    var p = (padding / n) * extent;
    this.min = -p;
    this.max = extent + p;
}


Grid.prototype.insert = function(key, x1, y1, x2, y2) {
    this._forEachCell(x1, y1, x2, y2, this._insertCell, this.uid++);
    this.keys.push(key);
    this.bboxes.push(x1);
    this.bboxes.push(y1);
    this.bboxes.push(x2);
    this.bboxes.push(y2);
};

Grid.prototype._insertCell = function(x1, y1, x2, y2, cellIndex, uid) {
    this.cells[cellIndex].push(uid);
};

Grid.prototype.query = function(x1, y1, x2, y2) {
    var min = this.min;
    var max = this.max;
    if (x1 <= min && y1 <= min && max <= x2 && max <= y2) {
        return this.keys.slice();

    } else {
        var result = [];
        var seenUids = {};
        this._forEachCell(x1, y1, x2, y2, this._queryCell, result, seenUids);
        return result;
    }
};

Grid.prototype._queryCell = function(x1, y1, x2, y2, cellIndex, result, seenUids) {
    var cell = this.cells[cellIndex];
    if (cell !== null) {
        var keys = this.keys;
        var bboxes = this.bboxes;
        for (var u = 0; u < cell.length; u++) {
            var uid = cell[u];
            if (seenUids[uid] === undefined) {
                var offset = uid * 4;
                if ((x1 <= bboxes[offset + 2]) &&
                    (y1 <= bboxes[offset + 3]) &&
                    (x2 >= bboxes[offset + 0]) &&
                    (y2 >= bboxes[offset + 1])) {
                    seenUids[uid] = true;
                    result.push(keys[uid]);
                } else {
                    seenUids[uid] = false;
                }
            }
        }
    }
};

Grid.prototype._forEachCell = function(x1, y1, x2, y2, fn, arg1, arg2) {
    var cx1 = this._convertToCellCoord(x1);
    var cy1 = this._convertToCellCoord(y1);
    var cx2 = this._convertToCellCoord(x2);
    var cy2 = this._convertToCellCoord(y2);
    for (var x = cx1; x <= cx2; x++) {
        for (var y = cy1; y <= cy2; y++) {
            var cellIndex = this.d * y + x;
            if (fn.call(this, x1, y1, x2, y2, cellIndex, arg1, arg2)) return;
        }
    }
};

Grid.prototype._convertToCellCoord = function(x) {
    return Math.max(0, Math.min(this.d - 1, Math.floor(x * this.scale) + this.padding));
};

Grid.prototype.toArrayBuffer = function() {
    if (this.arrayBuffer) return this.arrayBuffer;

    var cells = this.cells;

    var metadataLength = NUM_PARAMS + this.cells.length + 1 + 1;
    var totalCellLength = 0;
    for (var i = 0; i < this.cells.length; i++) {
        totalCellLength += this.cells[i].length;
    }

    var array = new Int32Array(metadataLength + totalCellLength + this.keys.length + this.bboxes.length);
    array[0] = this.n;
    array[1] = this.extent;
    array[2] = this.padding;

    var offset = metadataLength;
    for (var k = 0; k < cells.length; k++) {
        var cell = cells[k];
        array[NUM_PARAMS + k] = offset;
        array.set(cell, offset);
        offset += cell.length;
    }

    array[NUM_PARAMS + cells.length] = offset;
    array.set(this.keys, offset);
    offset += this.keys.length;

    array[NUM_PARAMS + cells.length + 1] = offset;
    array.set(this.bboxes, offset);
    offset += this.bboxes.length;

    return array.buffer;
};

},{}],98:[function(require,module,exports){
'use strict';

module.exports = interpolate;

function interpolate(a, b, t) {
    return (a * (1 - t)) + (b * t);
}

interpolate.number = interpolate;

interpolate.vec2 = function(from, to, t) {
    return [
        interpolate(from[0], to[0], t),
        interpolate(from[1], to[1], t)
    ];
};

/*
 * Interpolate between two colors given as 4-element arrays.
 *
 * @param {Color} from
 * @param {Color} to
 * @param {number} t interpolation factor between 0 and 1
 * @returns {Color} interpolated color
 */
interpolate.color = function(from, to, t) {
    return [
        interpolate(from[0], to[0], t),
        interpolate(from[1], to[1], t),
        interpolate(from[2], to[2], t),
        interpolate(from[3], to[3], t)
    ];
};

interpolate.array = function(from, to, t) {
    return from.map(function(d, i) {
        return interpolate(d, to[i], t);
    });
};

},{}],99:[function(require,module,exports){
'use strict';

module.exports = {
    multiPolygonIntersectsBufferedMultiPoint: multiPolygonIntersectsBufferedMultiPoint,
    multiPolygonIntersectsMultiPolygon: multiPolygonIntersectsMultiPolygon,
    multiPolygonIntersectsBufferedMultiLine: multiPolygonIntersectsBufferedMultiLine
};

function multiPolygonIntersectsBufferedMultiPoint(multiPolygon, rings, radius) {
    for (var j = 0; j < multiPolygon.length; j++) {
        var polygon = multiPolygon[j];
        for (var i = 0; i < rings.length; i++) {
            var ring = rings[i];
            for (var k = 0; k < ring.length; k++) {
                var point = ring[k];
                if (polygonContainsPoint(polygon, point)) return true;
                if (pointIntersectsBufferedLine(point, polygon, radius)) return true;
            }
        }
    }
    return false;
}

function multiPolygonIntersectsMultiPolygon(multiPolygonA, multiPolygonB) {

    if (multiPolygonA.length === 1 && multiPolygonA[0].length === 1) {
        return multiPolygonContainsPoint(multiPolygonB, multiPolygonA[0][0]);
    }

    for (var m = 0; m < multiPolygonB.length; m++) {
        var ring = multiPolygonB[m];
        for (var n = 0; n < ring.length; n++) {
            if (multiPolygonContainsPoint(multiPolygonA, ring[n])) return true;
        }
    }

    for (var j = 0; j < multiPolygonA.length; j++) {
        var polygon = multiPolygonA[j];
        for (var i = 0; i < polygon.length; i++) {
            if (multiPolygonContainsPoint(multiPolygonB, polygon[i])) return true;
        }

        for (var k = 0; k < multiPolygonB.length; k++) {
            if (lineIntersectsLine(polygon, multiPolygonB[k])) return true;
        }
    }

    return false;
}

function multiPolygonIntersectsBufferedMultiLine(multiPolygon, multiLine, radius) {
    for (var i = 0; i < multiLine.length; i++) {
        var line = multiLine[i];

        for (var j = 0; j < multiPolygon.length; j++) {
            var polygon = multiPolygon[j];

            if (polygon.length >= 3) {
                for (var k = 0; k < line.length; k++) {
                    if (polygonContainsPoint(polygon, line[k])) return true;
                }
            }

            if (lineIntersectsBufferedLine(polygon, line, radius)) return true;
        }
    }
    return false;
}

function lineIntersectsBufferedLine(lineA, lineB, radius) {

    if (lineA.length > 1) {
        if (lineIntersectsLine(lineA, lineB)) return true;

        // Check whether any point in either line is within radius of the other line
        for (var j = 0; j < lineB.length; j++) {
            if (pointIntersectsBufferedLine(lineB[j], lineA, radius)) return true;
        }
    }

    for (var k = 0; k < lineA.length; k++) {
        if (pointIntersectsBufferedLine(lineA[k], lineB, radius)) return true;
    }

    return false;
}

function lineIntersectsLine(lineA, lineB) {
    for (var i = 0; i < lineA.length - 1; i++) {
        var a0 = lineA[i];
        var a1 = lineA[i + 1];
        for (var j = 0; j < lineB.length - 1; j++) {
            var b0 = lineB[j];
            var b1 = lineB[j + 1];
            if (lineSegmentIntersectsLineSegment(a0, a1, b0, b1)) return true;
        }
    }
    return false;
}


// http://bryceboe.com/2006/10/23/line-segment-intersection-algorithm/
function isCounterClockwise(a, b, c) {
    return (c.y - a.y) * (b.x - a.x) > (b.y - a.y) * (c.x - a.x);
}

function lineSegmentIntersectsLineSegment(a0, a1, b0, b1) {
    return isCounterClockwise(a0, b0, b1) !== isCounterClockwise(a1, b0, b1) &&
        isCounterClockwise(a0, a1, b0) !== isCounterClockwise(a0, a1, b1);
}

function pointIntersectsBufferedLine(p, line, radius) {
    var radiusSquared = radius * radius;

    if (line.length === 1) return p.distSqr(line[0]) < radiusSquared;

    for (var i = 1; i < line.length; i++) {
        // Find line segments that have a distance <= radius^2 to p
        // In that case, we treat the line as "containing point p".
        var v = line[i - 1], w = line[i];
        if (distToSegmentSquared(p, v, w) < radiusSquared) return true;
    }
    return false;
}

// Code from http://stackoverflow.com/a/1501725/331379.
function distToSegmentSquared(p, v, w) {
    var l2 = v.distSqr(w);
    if (l2 === 0) return p.distSqr(v);
    var t = ((p.x - v.x) * (w.x - v.x) + (p.y - v.y) * (w.y - v.y)) / l2;
    if (t < 0) return p.distSqr(v);
    if (t > 1) return p.distSqr(w);
    return p.distSqr(w.sub(v)._mult(t)._add(v));
}

// point in polygon ray casting algorithm
function multiPolygonContainsPoint(rings, p) {
    var c = false,
        ring, p1, p2;

    for (var k = 0; k < rings.length; k++) {
        ring = rings[k];
        for (var i = 0, j = ring.length - 1; i < ring.length; j = i++) {
            p1 = ring[i];
            p2 = ring[j];
            if (((p1.y > p.y) !== (p2.y > p.y)) && (p.x < (p2.x - p1.x) * (p.y - p1.y) / (p2.y - p1.y) + p1.x)) {
                c = !c;
            }
        }
    }
    return c;
}

function polygonContainsPoint(ring, p) {
    var c = false;
    for (var i = 0, j = ring.length - 1; i < ring.length; j = i++) {
        var p1 = ring[i];
        var p2 = ring[j];
        if (((p1.y > p.y) !== (p2.y > p.y)) && (p.x < (p2.x - p1.x) * (p.y - p1.y) / (p2.y - p1.y) + p1.x)) {
            c = !c;
        }
    }
    return c;
}

},{}],100:[function(require,module,exports){
'use strict';

module.exports = LRUCache;

/**
 * A [least-recently-used cache](http://en.wikipedia.org/wiki/Cache_algorithms)
 * with hash lookup made possible by keeping a list of keys in parallel to
 * an array of dictionary of values
 *
 * @param {number} max number of permitted values
 * @param {Function} onRemove callback called with items when they expire
 * @private
 */
function LRUCache(max, onRemove) {
    this.max = max;
    this.onRemove = onRemove;
    this.reset();
}

/**
 * Clear the cache
 *
 * @returns {LRUCache} this cache
 * @private
 */
LRUCache.prototype.reset = function() {
    for (var key in this.data) {
        this.onRemove(this.data[key]);
    }

    this.data = {};
    this.order = [];

    return this;
};

/**
 * Add a key, value combination to the cache, trimming its size if this pushes
 * it over max length.
 *
 * @param {string} key lookup key for the item
 * @param {*} data any value
 *
 * @returns {LRUCache} this cache
 * @private
 */
LRUCache.prototype.add = function(key, data) {

    if (this.has(key)) {
        this.order.splice(this.order.indexOf(key), 1);
        this.data[key] = data;
        this.order.push(key);

    } else {
        this.data[key] = data;
        this.order.push(key);

        if (this.order.length > this.max) {
            var removedData = this.get(this.order[0]);
            if (removedData) this.onRemove(removedData);
        }
    }

    return this;
};

/**
 * Determine whether the value attached to `key` is present
 *
 * @param {string} key the key to be looked-up
 * @returns {boolean} whether the cache has this value
 * @private
 */
LRUCache.prototype.has = function(key) {
    return key in this.data;
};

/**
 * List all keys in the cache
 *
 * @returns {Array<string>} an array of keys in this cache.
 * @private
 */
LRUCache.prototype.keys = function() {
    return this.order;
};

/**
 * Get the value attached to a specific key. If the key is not found,
 * returns `null`
 *
 * @param {string} key the key to look up
 * @returns {*} the data, or null if it isn't found
 * @private
 */
LRUCache.prototype.get = function(key) {
    if (!this.has(key)) { return null; }

    var data = this.data[key];

    delete this.data[key];
    this.order.splice(this.order.indexOf(key), 1);

    return data;
};

/**
 * Change the max size of the cache.
 *
 * @param {number} max the max size of the cache
 * @returns {LRUCache} this cache
 * @private
 */
LRUCache.prototype.setMaxSize = function(max) {
    this.max = max;

    while (this.order.length > this.max) {
        var removedData = this.get(this.order[0]);
        if (removedData) this.onRemove(removedData);
    }

    return this;
};

},{}],101:[function(require,module,exports){
'use strict';

var config = require('./config');
var browser = require('./browser');

function normalizeURL(url, pathPrefix, accessToken) {
    accessToken = accessToken || config.ACCESS_TOKEN;

    if (!accessToken && config.REQUIRE_ACCESS_TOKEN) {
        throw new Error('An API access token is required to use Mapbox GL. ' +
            'See https://www.mapbox.com/developers/api/#access-tokens');
    }

    url = url.replace(/^mapbox:\/\//, config.API_URL + pathPrefix);
    url += url.indexOf('?') !== -1 ? '&access_token=' : '?access_token=';

    if (config.REQUIRE_ACCESS_TOKEN) {
        if (accessToken[0] === 's') {
            throw new Error('Use a public access token (pk.*) with Mapbox GL JS, not a secret access token (sk.*). ' +
                'See https://www.mapbox.com/developers/api/#access-tokens');
        }

        url += accessToken;
    }

    return url;
}

module.exports.normalizeStyleURL = function(url, accessToken) {
    if (!url.match(/^mapbox:\/\/styles\//))
        return url;

    var split = url.split('/');
    var user = split[3];
    var style = split[4];
    var draft = split[5] ? '/draft' : '';
    return normalizeURL('mapbox://' + user + '/' + style + draft, '/styles/v1/', accessToken);
};

module.exports.normalizeSourceURL = function(url, accessToken) {
    if (!url.match(/^mapbox:\/\//))
        return url;

    // TileJSON requests need a secure flag appended to their URLs so
    // that the server knows to send SSL-ified resource references.
    return normalizeURL(url + '.json', '/v4/', accessToken) + '&secure';
};

module.exports.normalizeGlyphsURL = function(url, accessToken) {
    if (!url.match(/^mapbox:\/\//))
        return url;

    var user = url.split('/')[3];
    return normalizeURL('mapbox://' + user + '/{fontstack}/{range}.pbf', '/fonts/v1/', accessToken);
};

module.exports.normalizeSpriteURL = function(url, format, ext, accessToken) {
    if (!url.match(/^mapbox:\/\/sprites\//))
        return url + format + ext;

    var split = url.split('/');
    var user = split[3];
    var style = split[4];
    var draft = split[5] ? '/draft' : '';
    return normalizeURL('mapbox://' + user + '/' + style + draft + '/sprite' + format + ext, '/styles/v1/', accessToken);
};

module.exports.normalizeTileURL = function(url, sourceUrl, tileSize) {
    if (!sourceUrl || !sourceUrl.match(/^mapbox:\/\//))
        return url;

    // The v4 mapbox tile API supports 512x512 image tiles only when @2x
    // is appended to the tile URL. If `tileSize: 512` is specified for
    // a Mapbox raster source force the @2x suffix even if a non hidpi
    // device.
    url = url.replace(/([?&]access_token=)tk\.[^&]+/, '$1' + config.ACCESS_TOKEN);
    var extension = browser.supportsWebp ? 'webp' : '$1';
    return url.replace(/\.((?:png|jpg)\d*)(?=$|\?)/, browser.devicePixelRatio >= 2 || tileSize === 512 ? '@2x.' + extension : '.' + extension);
};

},{"./browser":89,"./config":93}],102:[function(require,module,exports){
'use strict';

// Note: all "sizes" are measured in bytes

var assert = require('assert');

module.exports = StructArrayType;

var viewTypes = {
    'Int8': Int8Array,
    'Uint8': Uint8Array,
    'Uint8Clamped': Uint8ClampedArray,
    'Int16': Int16Array,
    'Uint16': Uint16Array,
    'Int32': Int32Array,
    'Uint32': Uint32Array,
    'Float32': Float32Array,
    'Float64': Float64Array
};

/**
 * @typedef StructMember
 * @private
 * @property {string} name
 * @property {string} type
 * @property {number} components
 */

var structArrayTypeCache = {};

/**
 * `StructArrayType` is used to create new `StructArray` types.
 *
 * `StructArray` provides an abstraction over `ArrayBuffer` and `TypedArray` making it behave like
 * an array of typed structs. A StructArray is comprised of elements. Each element has a set of
 * members that are defined when the `StructArrayType` is created.
 *
 * StructArrays useful for creating large arrays that:
 * - can be transferred from workers as a Transferable object
 * - can be copied cheaply
 * - use less memory for lower-precision members
 * - can be used as buffers in WebGL.
 *
 * @class StructArrayType
 * @param {Array.<StructMember>}
 * @param options
 * @param {number} options.alignment Use `4` to align members to 4 byte boundaries. Default is 1.
 *
 * @example
 *
 * var PointArrayType = new StructArrayType({
 *  members: [
 *      { type: 'Int16', name: 'x' },
 *      { type: 'Int16', name: 'y' }
 *  ]});
 *
 *  var pointArray = new PointArrayType();
 *  pointArray.emplaceBack(10, 15);
 *  pointArray.emplaceBack(20, 35);
 *
 *  point = pointArray.get(0);
 *  assert(point.x === 10);
 *  assert(point.y === 15);
 *
 * @private
 */
function StructArrayType(options) {

    var key = JSON.stringify(options);
    if (structArrayTypeCache[key]) {
        return structArrayTypeCache[key];
    }

    if (options.alignment === undefined) options.alignment = 1;

    function StructType() {
        Struct.apply(this, arguments);
    }

    StructType.prototype = Object.create(Struct.prototype);

    var offset = 0;
    var maxSize = 0;
    var usedTypes = ['Uint8'];

    StructType.prototype.members = options.members.map(function(member) {
        member = {
            name: member.name,
            type: member.type,
            components: member.components || 1
        };

        assert(member.name.length);
        assert(member.type in viewTypes);

        if (usedTypes.indexOf(member.type) < 0) usedTypes.push(member.type);

        var typeSize = sizeOf(member.type);
        maxSize = Math.max(maxSize, typeSize);
        member.offset = offset = align(offset, Math.max(options.alignment, typeSize));

        for (var c = 0; c < member.components; c++) {
            Object.defineProperty(StructType.prototype, member.name + (member.components === 1 ? '' : c), {
                get: createGetter(member, c),
                set: createSetter(member, c)
            });
        }

        offset += typeSize * member.components;

        return member;
    });

    StructType.prototype.alignment = options.alignment;
    StructType.prototype.size = align(offset, Math.max(maxSize, options.alignment));

    function StructArrayType() {
        StructArray.apply(this, arguments);
    }

    StructArrayType.serialize = serializeStructArrayType;

    StructArrayType.prototype = Object.create(StructArray.prototype);
    StructArrayType.prototype.StructType = StructType;
    StructArrayType.prototype.bytesPerElement = StructType.prototype.size;
    StructArrayType.prototype.emplaceBack = createEmplaceBack(StructType.prototype.members, StructType.prototype.size);
    StructArrayType.prototype._usedTypes = usedTypes;


    structArrayTypeCache[key] = StructArrayType;

    return StructArrayType;
}

/**
 * Serialize the StructArray type. This serializes the *type* not an instance of the type.
 * @private
 */
function serializeStructArrayType() {
    return {
        members: this.prototype.StructType.prototype.members,
        alignment: this.prototype.StructType.prototype.alignment,
        bytesPerElement: this.prototype.bytesPerElement
    };
}


function align(offset, size) {
    return Math.ceil(offset / size) * size;
}

function sizeOf(type) {
    return viewTypes[type].BYTES_PER_ELEMENT;
}

function getArrayViewName(type) {
    return type.toLowerCase();
}


/*
 * > I saw major perf gains by shortening the source of these generated methods (i.e. renaming
 * > elementIndex to i) (likely due to v8 inlining heuristics).
 * - lucaswoj
 */
function createEmplaceBack(members, bytesPerElement) {
    var usedTypeSizes = [];
    var argNames = [];
    var body = '' +
    'var i = this.length;\n' +
    'this.length++;\n' +
    'if (this.length > this.capacity) this._resize(this.length);\n';

    for (var m = 0; m < members.length; m++) {
        var member = members[m];
        var size = sizeOf(member.type);

        if (usedTypeSizes.indexOf(size) < 0) {
            usedTypeSizes.push(size);
            body += 'var o' + size.toFixed(0) + ' = i * ' + (bytesPerElement / size).toFixed(0) + ';\n';
        }

        for (var c = 0; c < member.components; c++) {
            var argName = 'v' + argNames.length;
            var index = 'o' + size.toFixed(0) + ' + ' + (member.offset / size + c).toFixed(0);
            body += 'this.' + getArrayViewName(member.type) + '[' + index + '] = ' + argName + ';\n';
            argNames.push(argName);
        }
    }

    body += 'return i;';

    return new Function(argNames, body);
}

function createMemberComponentString(member, component) {
    var elementOffset = 'this._pos' + sizeOf(member.type).toFixed(0);
    var componentOffset = (member.offset / sizeOf(member.type) + component).toFixed(0);
    var index = elementOffset + ' + ' + componentOffset;
    return 'this._structArray.' + getArrayViewName(member.type) + '[' + index + ']';

}

function createGetter(member, c) {
    return new Function([], 'return ' + createMemberComponentString(member, c) + ';');
}

function createSetter(member, c) {
    return new Function(['x'], createMemberComponentString(member, c) + ' = x;');
}

/**
 * @class Struct
 * @param {StructArray} structArray The StructArray the struct is stored in
 * @param {number} index The index of the struct in the StructArray.
 * @private
 */
function Struct(structArray, index) {
    this._structArray = structArray;
    this._pos1 = index * this.size;
    this._pos2 = this._pos1 / 2;
    this._pos4 = this._pos1 / 4;
    this._pos8 = this._pos1 / 8;
}

/**
 * @class StructArray
 * The StructArray class is inherited by the custom StructArrayType classes created with
 * `new StructArrayType(members, options)`.
 * @private
 */
function StructArray(serialized) {
    if (serialized !== undefined) {
    // Create from an serialized StructArray
        this.arrayBuffer = serialized.arrayBuffer;
        this.length = serialized.length;
        this.capacity = this.arrayBuffer.byteLength / this.bytesPerElement;
        this._refreshViews();

    // Create a new StructArray
    } else {
        this.length = 0;
        this.capacity = 0;
        this._resize(this.DEFAULT_CAPACITY);
    }
}

/**
 * @property {number}
 * @private
 * @readonly
 */
StructArray.prototype.DEFAULT_CAPACITY = 128;

/**
 * @property {number}
 * @private
 * @readonly
 */
StructArray.prototype.RESIZE_MULTIPLIER = 5;

/**
 * Serialize this StructArray instance
 * @private
 */
StructArray.prototype.serialize = function() {
    this.trim();
    return {
        length: this.length,
        arrayBuffer: this.arrayBuffer
    };
};

/**
 * Return the Struct at the given location in the array.
 * @private
 * @param {number} index The index of the element.
 */
StructArray.prototype.get = function(index) {
    return new this.StructType(this, index);
};

/**
 * Resize the array to discard unused capacity.
 * @private
 */
StructArray.prototype.trim = function() {
    if (this.length !== this.capacity) {
        this.capacity = this.length;
        this.arrayBuffer = this.arrayBuffer.slice(0, this.length * this.bytesPerElement);
        this._refreshViews();
    }
};

/**
 * Resize the array so that it fits at least `n` elements.
 * @private
 * @param {number} n The number of elements that must fit in the array after the resize.
 */
StructArray.prototype._resize = function(n) {
    this.capacity = Math.max(n, Math.floor(this.capacity * this.RESIZE_MULTIPLIER));
    this.arrayBuffer = new ArrayBuffer(this.capacity * this.bytesPerElement);

    var oldUint8Array = this.uint8;
    this._refreshViews();
    if (oldUint8Array) this.uint8.set(oldUint8Array);
};

/**
 * Create TypedArray views for the current ArrayBuffer.
 * @private
 */
StructArray.prototype._refreshViews = function() {
    for (var t = 0; t < this._usedTypes.length; t++) {
        var type = this._usedTypes[t];
        this[getArrayViewName(type)] = new viewTypes[type](this.arrayBuffer);
    }
};


},{"assert":106}],103:[function(require,module,exports){
'use strict';

module.exports = resolveTokens;

/**
 * Replace tokens in a string template with values in an object
 *
 * @param {Object} properties a key/value relationship between tokens and replacements
 * @param {string} text the template string
 * @returns {string} the template with tokens replaced
 * @private
 */
function resolveTokens(properties, text) {
    return text.replace(/{([^{}()\[\]<>$=:;.,^]+)}/g, function(match, key) {
        return key in properties ? properties[key] : '';
    });
}

},{}],104:[function(require,module,exports){
'use strict';

var UnitBezier = require('unitbezier');
var Coordinate = require('../geo/coordinate');

/**
 * Given a value `t` that varies between 0 and 1, return
 * an interpolation function that eases between 0 and 1 in a pleasing
 * cubic in-out fashion.
 *
 * @param {number} t input
 * @returns {number} input
 * @private
 */
exports.easeCubicInOut = function (t) {
    if (t <= 0) return 0;
    if (t >= 1) return 1;
    var t2 = t * t,
        t3 = t2 * t;
    return 4 * (t < 0.5 ? t3 : 3 * (t - t2) + t3 - 0.75);
};

/**
 * Given given (x, y), (x1, y1) control points for a bezier curve,
 * return a function that interpolates along that curve.
 *
 * @param {number} p1x control point 1 x coordinate
 * @param {number} p1y control point 1 y coordinate
 * @param {number} p2x control point 2 x coordinate
 * @param {number} p2y control point 2 y coordinate
 * @returns {Function} interpolator: receives number value, returns
 * number value.
 * @private
 */
exports.bezier = function(p1x, p1y, p2x, p2y) {
    var bezier = new UnitBezier(p1x, p1y, p2x, p2y);
    return function(t) {
        return bezier.solve(t);
    };
};

/**
 * A default bezier-curve powered easing function with
 * control points (0.25, 0.1) and (0.25, 1)
 *
 * @param {number} t
 * @returns {number} output
 * @private
 */
exports.ease = exports.bezier(0.25, 0.1, 0.25, 1);

/**
 * Given a four-element array of numbers that represents a color in
 * RGBA, return a version for which the RGB components are multiplied
 * by the A (alpha) component
 *
 * @param {Array<number>} color color array
 * @param {number} [additionalOpacity] additional opacity to be multiplied into
 *     the color's alpha component.
 * @returns {Array<number>} premultiplied color array
 * @private
 */
exports.premultiply = function (color, additionalOpacity) {
    if (!color) return null;
    var opacity = color[3] * additionalOpacity;
    return [
        color[0] * opacity,
        color[1] * opacity,
        color[2] * opacity,
        opacity
    ];
};

/**
 * constrain n to the given range via min + max
 *
 * @param {number} n value
 * @param {number} min the minimum value to be returned
 * @param {number} max the maximum value to be returned
 * @returns {number} the clamped value
 * @private
 */
exports.clamp = function (n, min, max) {
    return Math.min(max, Math.max(min, n));
};

/*
 * constrain n to the given range, excluding the minimum, via modular arithmetic
 * @param {number} n value
 * @param {number} min the minimum value to be returned, exclusive
 * @param {number} max the maximum value to be returned, inclusive
 * @returns {number} constrained number
 * @private
 */
exports.wrap = function (n, min, max) {
    var d = max - min;
    var w = ((n - min) % d + d) % d + min;
    return (w === min) ? max : w;
};

/*
 * return the first non-null and non-undefined argument to this function.
 * @returns {*} argument
 * @private
 */
exports.coalesce = function() {
    for (var i = 0; i < arguments.length; i++) {
        var arg = arguments[i];
        if (arg !== null && arg !== undefined)
            return arg;
    }
};

/*
 * Call an asynchronous function on an array of arguments,
 * calling `callback` with the completed results of all calls.
 *
 * @param {Array<*>} array input to each call of the async function.
 * @param {Function} fn an async function with signature (data, callback)
 * @param {Function} callback a callback run after all async work is done.
 * called with an array, containing the results of each async call.
 * @returns {undefined}
 * @private
 */
exports.asyncAll = function (array, fn, callback) {
    if (!array.length) { return callback(null, []); }
    var remaining = array.length;
    var results = new Array(array.length);
    var error = null;
    array.forEach(function (item, i) {
        fn(item, function (err, result) {
            if (err) error = err;
            results[i] = result;
            if (--remaining === 0) callback(error, results);
        });
    });
};

/*
 * Compute the difference between the keys in one object and the keys
 * in another object.
 *
 * @param {Object} obj
 * @param {Object} other
 * @returns {Array<string>} keys difference
 * @private
 */
exports.keysDifference = function (obj, other) {
    var difference = [];
    for (var i in obj) {
        if (!(i in other)) {
            difference.push(i);
        }
    }
    return difference;
};

/**
 * Given a destination object and optionally many source objects,
 * copy all properties from the source objects into the destination.
 * The last source object given overrides properties from previous
 * source objects.
 * @param {Object} dest destination object
 * @param {...Object} sources sources from which properties are pulled
 * @returns {Object} dest
 * @private
 */
exports.extend = function (dest) {
    for (var i = 1; i < arguments.length; i++) {
        var src = arguments[i];
        for (var k in src) {
            dest[k] = src[k];
        }
    }
    return dest;
};

/**
 * Extend a destination object with all properties of the src object,
 * using defineProperty instead of simple assignment.
 * @param {Object} dest
 * @param {Object} src
 * @returns {Object} dest
 * @private
 */
exports.extendAll = function (dest, src) {
    for (var i in src) {
        Object.defineProperty(dest, i, Object.getOwnPropertyDescriptor(src, i));
    }
    return dest;
};

/**
 * Extend a parent's prototype with all properties in a properties
 * object.
 *
 * @param {Object} parent
 * @param {Object} props
 * @returns {Object}
 * @private
 */
exports.inherit = function (parent, props) {
    var parentProto = typeof parent === 'function' ? parent.prototype : parent,
        proto = Object.create(parentProto);
    exports.extendAll(proto, props);
    return proto;
};

/**
 * Given an object and a number of properties as strings, return version
 * of that object with only those properties.
 *
 * @param {Object} src the object
 * @param {Array<string>} properties an array of property names chosen
 * to appear on the resulting object.
 * @returns {Object} object with limited properties.
 * @example
 * var foo = { name: 'Charlie', age: 10 };
 * var justName = pick(foo, ['name']);
 * // justName = { name: 'Charlie' }
 * @private
 */
exports.pick = function (src, properties) {
    var result = {};
    for (var i = 0; i < properties.length; i++) {
        var k = properties[i];
        if (k in src) {
            result[k] = src[k];
        }
    }
    return result;
};

var id = 1;

/**
 * Return a unique numeric id, starting at 1 and incrementing with
 * each call.
 *
 * @returns {number} unique numeric id.
 * @private
 */
exports.uniqueId = function () {
    return id++;
};

/**
 * Create a version of `fn` that only fires once every `time` millseconds.
 *
 * @param {Function} fn the function to be throttled
 * @param {number} time millseconds required between function calls
 * @param {*} context the value of `this` with which the function is called
 * @returns {Function} debounced function
 * @private
 */
exports.throttle = function (fn, time, context) {
    var lock, args, wrapperFn, later;

    later = function () {
        // reset lock and call if queued
        lock = false;
        if (args) {
            wrapperFn.apply(context, args);
            args = false;
        }
    };

    wrapperFn = function () {
        if (lock) {
            // called too soon, queue to call later
            args = arguments;

        } else {
            // call and lock until later
            fn.apply(context, arguments);
            setTimeout(later, time);
            lock = true;
        }
    };

    return wrapperFn;
};

/**
 * Create a version of `fn` that is only called `time` milliseconds
 * after its last invocation
 *
 * @param {Function} fn the function to be debounced
 * @param {number} time millseconds after which the function will be invoked
 * @returns {Function} debounced function
 * @private
 */
exports.debounce = function(fn, time) {
    var timer, args;

    return function() {
        args = arguments;
        clearTimeout(timer);

        timer = setTimeout(function() {
            fn.apply(null, args);
        }, time);
    };
};

/**
 * Given an array of member function names as strings, replace all of them
 * with bound versions that will always refer to `context` as `this`. This
 * is useful for classes where otherwise event bindings would reassign
 * `this` to the evented object or some other value: this lets you ensure
 * the `this` value always.
 *
 * @param {Array<string>} fns list of member function names
 * @param {*} context the context value
 * @returns {undefined} changes functions in-place
 * @example
 * function MyClass() {
 *   bindAll(['ontimer'], this);
 *   this.name = 'Tom';
 * }
 * MyClass.prototype.ontimer = function() {
 *   alert(this.name);
 * };
 * var myClass = new MyClass();
 * setTimeout(myClass.ontimer, 100);
 * @private
 */
exports.bindAll = function(fns, context) {
    fns.forEach(function(fn) {
        context[fn] = context[fn].bind(context);
    });
};

/**
 * Given a class, bind all of the methods that look like handlers: that
 * begin with _on, and bind them to the class.
 *
 * @param {Object} context an object with methods
 * @private
 */
exports.bindHandlers = function(context) {
    for (var i in context) {
        if (typeof context[i] === 'function' && i.indexOf('_on') === 0) {
            context[i] = context[i].bind(context);
        }
    }
};

/**
 * Set the 'options' property on `obj` with properties
 * from the `options` argument. Properties in the `options`
 * object will override existing properties.
 *
 * @param {Object} obj destination object
 * @param {Object} options object of override options
 * @returns {Object} derived options object.
 * @private
 */
exports.setOptions = function(obj, options) {
    if (!obj.hasOwnProperty('options')) {
        obj.options = obj.options ? Object.create(obj.options) : {};
    }
    for (var i in options) {
        obj.options[i] = options[i];
    }
    return obj.options;
};

/**
 * Given a list of coordinates, get their center as a coordinate.
 * @param {Array<Coordinate>} coords
 * @returns {Coordinate} centerpoint
 * @private
 */
exports.getCoordinatesCenter = function(coords) {
    var minX = Infinity;
    var minY = Infinity;
    var maxX = -Infinity;
    var maxY = -Infinity;

    for (var i = 0; i < coords.length; i++) {
        minX = Math.min(minX, coords[i].column);
        minY = Math.min(minY, coords[i].row);
        maxX = Math.max(maxX, coords[i].column);
        maxY = Math.max(maxY, coords[i].row);
    }

    var dx = maxX - minX;
    var dy = maxY - minY;
    var dMax = Math.max(dx, dy);
    return new Coordinate((minX + maxX) / 2, (minY + maxY) / 2, 0)
        .zoomTo(Math.floor(-Math.log(dMax) / Math.LN2));
};

/**
 * Determine if a string ends with a particular substring
 * @param {string} string
 * @param {string} suffix
 * @returns {boolean}
 * @private
 */
exports.endsWith = function(string, suffix) {
    return string.indexOf(suffix, string.length - suffix.length) !== -1;
};

/**
 * Determine if a string starts with a particular substring
 * @param {string} string
 * @param {string} prefix
 * @returns {boolean}
 * @private
 */
exports.startsWith = function(string, prefix) {
    return string.indexOf(prefix) === 0;
};

/**
 * Create an object by mapping all the values of an existing object while
 * preserving their keys.
 * @param {Object} input
 * @param {Function} iterator
 * @returns {Object}
 * @private
 */
exports.mapObject = function(input, iterator, context) {
    var output = {};
    for (var key in input) {
        output[key] = iterator.call(context || this, input[key], key, input);
    }
    return output;
};

/**
 * Create an object by filtering out values of an existing object
 * @param {Object} input
 * @param {Function} iterator
 * @returns {Object}
 * @private
 */
exports.filterObject = function(input, iterator, context) {
    var output = {};
    for (var key in input) {
        if (iterator.call(context || this, input[key], key, input)) {
            output[key] = input[key];
        }
    }
    return output;
};

/**
 * Deeply compares two object literals.
 * @param {Object} obj1
 * @param {Object} obj2
 * @returns {boolean}
 * @private
 */
exports.deepEqual = function deepEqual(a, b) {
    if (Array.isArray(a)) {
        if (!Array.isArray(b) || a.length !== b.length) return false;
        for (var i = 0; i < a.length; i++) {
            if (!deepEqual(a[i], b[i])) return false;
        }
        return true;
    }
    if (typeof a === 'object') {
        if (!(typeof b === 'object')) return false;
        var keys = Object.keys(a);
        if (keys.length !== Object.keys(b).length) return false;
        for (var key in a) {
            if (!deepEqual(a[key], b[key])) return false;
        }
        return true;
    }
    return a === b;
};

/**
 * Check if two arrays have at least one common element.
 * @param {Array} a
 * @param {Array} b
 * @returns {boolean}
 * @private
 */
exports.arraysIntersect = function(a, b) {
    for (var l = 0; l < a.length; l++) {
        if (b.indexOf(a[l]) >= 0) return true;
    }
    return false;
};

},{"../geo/coordinate":9,"unitbezier":167}],105:[function(require,module,exports){
'use strict';

var VectorTileFeature = require('vector-tile').VectorTileFeature;

module.exports = Feature;

function Feature(vectorTileFeature, z, x, y) {
    this._vectorTileFeature = vectorTileFeature;
    vectorTileFeature._z = z;
    vectorTileFeature._x = x;
    vectorTileFeature._y = y;

    this.properties = vectorTileFeature.properties;

    if (vectorTileFeature._id) {
        this.id = vectorTileFeature._id;
    }
}

Feature.prototype = {
    type: "Feature",

    get geometry() {
        if (this._geometry === undefined) {
            var feature = this._vectorTileFeature;
            var coords = projectCoords(
                feature.loadGeometry(),
                feature.extent,
                feature._z, feature._x, feature._y);

            var type = VectorTileFeature.types[feature.type];

            if (type === 'Point' && coords.length === 1) {
                coords = coords[0][0];
            } else if (type === 'Point') {
                coords = coords[0];
                type = 'MultiPoint';
            } else if (type === 'LineString' && coords.length === 1) {
                coords = coords[0];
            } else if (type === 'LineString') {
                type = 'MultiLineString';
            }

            this._geometry = {
                type: type,
                coordinates: coords
            };

            this._vectorTileFeature = null;
        }
        return this._geometry;
    },

    set geometry(g) {
        this._geometry = g;
    },

    toJSON: function() {
        var json = {};
        for (var i in this) {
            if (i === '_geometry' || i === '_vectorTileFeature') continue;
            json[i] = this[i];
        }
        return json;
    }
};

function projectCoords(coords, extent, z, x, y) {
    var size = extent * Math.pow(2, z),
        x0 = extent * x,
        y0 = extent * y;
    for (var i = 0; i < coords.length; i++) {
        var line = coords[i];
        for (var j = 0; j < line.length; j++) {
            var p = line[j];
            var y2 = 180 - (p.y + y0) * 360 / size;
            line[j] = [
                (p.x + x0) * 360 / size - 180,
                360 / Math.PI * Math.atan(Math.exp(y2 * Math.PI / 180)) - 90
            ];
        }
    }
    return coords;
}

},{"vector-tile":168}],106:[function(require,module,exports){
// http://wiki.commonjs.org/wiki/Unit_Testing/1.0
//
// THIS IS NOT TESTED NOR LIKELY TO WORK OUTSIDE V8!
//
// Originally from narwhal.js (http://narwhaljs.org)
// Copyright (c) 2009 Thomas Robinson <280north.com>
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the 'Software'), to
// deal in the Software without restriction, including without limitation the
// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
// sell copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
// ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

// when used in node, this will actually load the util module we depend on
// versus loading the builtin util module as happens otherwise
// this is a bug in node module loading as far as I am concerned
var util = require('util/');

var pSlice = Array.prototype.slice;
var hasOwn = Object.prototype.hasOwnProperty;

// 1. The assert module provides functions that throw
// AssertionError's when particular conditions are not met. The
// assert module must conform to the following interface.

var assert = module.exports = ok;

// 2. The AssertionError is defined in assert.
// new assert.AssertionError({ message: message,
//                             actual: actual,
//                             expected: expected })

assert.AssertionError = function AssertionError(options) {
  this.name = 'AssertionError';
  this.actual = options.actual;
  this.expected = options.expected;
  this.operator = options.operator;
  if (options.message) {
    this.message = options.message;
    this.generatedMessage = false;
  } else {
    this.message = getMessage(this);
    this.generatedMessage = true;
  }
  var stackStartFunction = options.stackStartFunction || fail;

  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, stackStartFunction);
  }
  else {
    // non v8 browsers so we can have a stacktrace
    var err = new Error();
    if (err.stack) {
      var out = err.stack;

      // try to strip useless frames
      var fn_name = stackStartFunction.name;
      var idx = out.indexOf('\n' + fn_name);
      if (idx >= 0) {
        // once we have located the function frame
        // we need to strip out everything before it (and its line)
        var next_line = out.indexOf('\n', idx + 1);
        out = out.substring(next_line + 1);
      }

      this.stack = out;
    }
  }
};

// assert.AssertionError instanceof Error
util.inherits(assert.AssertionError, Error);

function replacer(key, value) {
  if (util.isUndefined(value)) {
    return '' + value;
  }
  if (util.isNumber(value) && !isFinite(value)) {
    return value.toString();
  }
  if (util.isFunction(value) || util.isRegExp(value)) {
    return value.toString();
  }
  return value;
}

function truncate(s, n) {
  if (util.isString(s)) {
    return s.length < n ? s : s.slice(0, n);
  } else {
    return s;
  }
}

function getMessage(self) {
  return truncate(JSON.stringify(self.actual, replacer), 128) + ' ' +
         self.operator + ' ' +
         truncate(JSON.stringify(self.expected, replacer), 128);
}

// At present only the three keys mentioned above are used and
// understood by the spec. Implementations or sub modules can pass
// other keys to the AssertionError's constructor - they will be
// ignored.

// 3. All of the following functions must throw an AssertionError
// when a corresponding condition is not met, with a message that
// may be undefined if not provided.  All assertion methods provide
// both the actual and expected values to the assertion error for
// display purposes.

function fail(actual, expected, message, operator, stackStartFunction) {
  throw new assert.AssertionError({
    message: message,
    actual: actual,
    expected: expected,
    operator: operator,
    stackStartFunction: stackStartFunction
  });
}

// EXTENSION! allows for well behaved errors defined elsewhere.
assert.fail = fail;

// 4. Pure assertion tests whether a value is truthy, as determined
// by !!guard.
// assert.ok(guard, message_opt);
// This statement is equivalent to assert.equal(true, !!guard,
// message_opt);. To test strictly for the value true, use
// assert.strictEqual(true, guard, message_opt);.

function ok(value, message) {
  if (!value) fail(value, true, message, '==', assert.ok);
}
assert.ok = ok;

// 5. The equality assertion tests shallow, coercive equality with
// ==.
// assert.equal(actual, expected, message_opt);

assert.equal = function equal(actual, expected, message) {
  if (actual != expected) fail(actual, expected, message, '==', assert.equal);
};

// 6. The non-equality assertion tests for whether two objects are not equal
// with != assert.notEqual(actual, expected, message_opt);

assert.notEqual = function notEqual(actual, expected, message) {
  if (actual == expected) {
    fail(actual, expected, message, '!=', assert.notEqual);
  }
};

// 7. The equivalence assertion tests a deep equality relation.
// assert.deepEqual(actual, expected, message_opt);

assert.deepEqual = function deepEqual(actual, expected, message) {
  if (!_deepEqual(actual, expected)) {
    fail(actual, expected, message, 'deepEqual', assert.deepEqual);
  }
};

function _deepEqual(actual, expected) {
  // 7.1. All identical values are equivalent, as determined by ===.
  if (actual === expected) {
    return true;

  } else if (util.isBuffer(actual) && util.isBuffer(expected)) {
    if (actual.length != expected.length) return false;

    for (var i = 0; i < actual.length; i++) {
      if (actual[i] !== expected[i]) return false;
    }

    return true;

  // 7.2. If the expected value is a Date object, the actual value is
  // equivalent if it is also a Date object that refers to the same time.
  } else if (util.isDate(actual) && util.isDate(expected)) {
    return actual.getTime() === expected.getTime();

  // 7.3 If the expected value is a RegExp object, the actual value is
  // equivalent if it is also a RegExp object with the same source and
  // properties (`global`, `multiline`, `lastIndex`, `ignoreCase`).
  } else if (util.isRegExp(actual) && util.isRegExp(expected)) {
    return actual.source === expected.source &&
           actual.global === expected.global &&
           actual.multiline === expected.multiline &&
           actual.lastIndex === expected.lastIndex &&
           actual.ignoreCase === expected.ignoreCase;

  // 7.4. Other pairs that do not both pass typeof value == 'object',
  // equivalence is determined by ==.
  } else if (!util.isObject(actual) && !util.isObject(expected)) {
    return actual == expected;

  // 7.5 For all other Object pairs, including Array objects, equivalence is
  // determined by having the same number of owned properties (as verified
  // with Object.prototype.hasOwnProperty.call), the same set of keys
  // (although not necessarily the same order), equivalent values for every
  // corresponding key, and an identical 'prototype' property. Note: this
  // accounts for both named and indexed properties on Arrays.
  } else {
    return objEquiv(actual, expected);
  }
}

function isArguments(object) {
  return Object.prototype.toString.call(object) == '[object Arguments]';
}

function objEquiv(a, b) {
  if (util.isNullOrUndefined(a) || util.isNullOrUndefined(b))
    return false;
  // an identical 'prototype' property.
  if (a.prototype !== b.prototype) return false;
  // if one is a primitive, the other must be same
  if (util.isPrimitive(a) || util.isPrimitive(b)) {
    return a === b;
  }
  var aIsArgs = isArguments(a),
      bIsArgs = isArguments(b);
  if ((aIsArgs && !bIsArgs) || (!aIsArgs && bIsArgs))
    return false;
  if (aIsArgs) {
    a = pSlice.call(a);
    b = pSlice.call(b);
    return _deepEqual(a, b);
  }
  var ka = objectKeys(a),
      kb = objectKeys(b),
      key, i;
  // having the same number of owned properties (keys incorporates
  // hasOwnProperty)
  if (ka.length != kb.length)
    return false;
  //the same set of keys (although not necessarily the same order),
  ka.sort();
  kb.sort();
  //~~~cheap key test
  for (i = ka.length - 1; i >= 0; i--) {
    if (ka[i] != kb[i])
      return false;
  }
  //equivalent values for every corresponding key, and
  //~~~possibly expensive deep test
  for (i = ka.length - 1; i >= 0; i--) {
    key = ka[i];
    if (!_deepEqual(a[key], b[key])) return false;
  }
  return true;
}

// 8. The non-equivalence assertion tests for any deep inequality.
// assert.notDeepEqual(actual, expected, message_opt);

assert.notDeepEqual = function notDeepEqual(actual, expected, message) {
  if (_deepEqual(actual, expected)) {
    fail(actual, expected, message, 'notDeepEqual', assert.notDeepEqual);
  }
};

// 9. The strict equality assertion tests strict equality, as determined by ===.
// assert.strictEqual(actual, expected, message_opt);

assert.strictEqual = function strictEqual(actual, expected, message) {
  if (actual !== expected) {
    fail(actual, expected, message, '===', assert.strictEqual);
  }
};

// 10. The strict non-equality assertion tests for strict inequality, as
// determined by !==.  assert.notStrictEqual(actual, expected, message_opt);

assert.notStrictEqual = function notStrictEqual(actual, expected, message) {
  if (actual === expected) {
    fail(actual, expected, message, '!==', assert.notStrictEqual);
  }
};

function expectedException(actual, expected) {
  if (!actual || !expected) {
    return false;
  }

  if (Object.prototype.toString.call(expected) == '[object RegExp]') {
    return expected.test(actual);
  } else if (actual instanceof expected) {
    return true;
  } else if (expected.call({}, actual) === true) {
    return true;
  }

  return false;
}

function _throws(shouldThrow, block, expected, message) {
  var actual;

  if (util.isString(expected)) {
    message = expected;
    expected = null;
  }

  try {
    block();
  } catch (e) {
    actual = e;
  }

  message = (expected && expected.name ? ' (' + expected.name + ').' : '.') +
            (message ? ' ' + message : '.');

  if (shouldThrow && !actual) {
    fail(actual, expected, 'Missing expected exception' + message);
  }

  if (!shouldThrow && expectedException(actual, expected)) {
    fail(actual, expected, 'Got unwanted exception' + message);
  }

  if ((shouldThrow && actual && expected &&
      !expectedException(actual, expected)) || (!shouldThrow && actual)) {
    throw actual;
  }
}

// 11. Expected to throw an error:
// assert.throws(block, Error_opt, message_opt);

assert.throws = function(block, /*optional*/error, /*optional*/message) {
  _throws.apply(this, [true].concat(pSlice.call(arguments)));
};

// EXTENSION! This is annoying to write outside this module.
assert.doesNotThrow = function(block, /*optional*/message) {
  _throws.apply(this, [false].concat(pSlice.call(arguments)));
};

assert.ifError = function(err) { if (err) {throw err;}};

var objectKeys = Object.keys || function (obj) {
  var keys = [];
  for (var key in obj) {
    if (hasOwn.call(obj, key)) keys.push(key);
  }
  return keys;
};

},{"util/":111}],107:[function(require,module,exports){
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    var TempCtor = function () {}
    TempCtor.prototype = superCtor.prototype
    ctor.prototype = new TempCtor()
    ctor.prototype.constructor = ctor
  }
}

},{}],108:[function(require,module,exports){
(function (process){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// resolves . and .. elements in a path array with directory names there
// must be no slashes, empty elements, or device names (c:\) in the array
// (so also no leading and trailing slashes - it does not distinguish
// relative and absolute paths)
function normalizeArray(parts, allowAboveRoot) {
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = parts.length - 1; i >= 0; i--) {
    var last = parts[i];
    if (last === '.') {
      parts.splice(i, 1);
    } else if (last === '..') {
      parts.splice(i, 1);
      up++;
    } else if (up) {
      parts.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (allowAboveRoot) {
    for (; up--; up) {
      parts.unshift('..');
    }
  }

  return parts;
}

// Split a filename into [root, dir, basename, ext], unix version
// 'root' is just a slash, or nothing.
var splitPathRe =
    /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
var splitPath = function(filename) {
  return splitPathRe.exec(filename).slice(1);
};

// path.resolve([from ...], to)
// posix version
exports.resolve = function() {
  var resolvedPath = '',
      resolvedAbsolute = false;

  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
    var path = (i >= 0) ? arguments[i] : process.cwd();

    // Skip empty and invalid entries
    if (typeof path !== 'string') {
      throw new TypeError('Arguments to path.resolve must be strings');
    } else if (!path) {
      continue;
    }

    resolvedPath = path + '/' + resolvedPath;
    resolvedAbsolute = path.charAt(0) === '/';
  }

  // At this point the path should be resolved to a full absolute path, but
  // handle relative paths to be safe (might happen when process.cwd() fails)

  // Normalize the path
  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {
    return !!p;
  }), !resolvedAbsolute).join('/');

  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
};

// path.normalize(path)
// posix version
exports.normalize = function(path) {
  var isAbsolute = exports.isAbsolute(path),
      trailingSlash = substr(path, -1) === '/';

  // Normalize the path
  path = normalizeArray(filter(path.split('/'), function(p) {
    return !!p;
  }), !isAbsolute).join('/');

  if (!path && !isAbsolute) {
    path = '.';
  }
  if (path && trailingSlash) {
    path += '/';
  }

  return (isAbsolute ? '/' : '') + path;
};

// posix version
exports.isAbsolute = function(path) {
  return path.charAt(0) === '/';
};

// posix version
exports.join = function() {
  var paths = Array.prototype.slice.call(arguments, 0);
  return exports.normalize(filter(paths, function(p, index) {
    if (typeof p !== 'string') {
      throw new TypeError('Arguments to path.join must be strings');
    }
    return p;
  }).join('/'));
};


// path.relative(from, to)
// posix version
exports.relative = function(from, to) {
  from = exports.resolve(from).substr(1);
  to = exports.resolve(to).substr(1);

  function trim(arr) {
    var start = 0;
    for (; start < arr.length; start++) {
      if (arr[start] !== '') break;
    }

    var end = arr.length - 1;
    for (; end >= 0; end--) {
      if (arr[end] !== '') break;
    }

    if (start > end) return [];
    return arr.slice(start, end - start + 1);
  }

  var fromParts = trim(from.split('/'));
  var toParts = trim(to.split('/'));

  var length = Math.min(fromParts.length, toParts.length);
  var samePartsLength = length;
  for (var i = 0; i < length; i++) {
    if (fromParts[i] !== toParts[i]) {
      samePartsLength = i;
      break;
    }
  }

  var outputParts = [];
  for (var i = samePartsLength; i < fromParts.length; i++) {
    outputParts.push('..');
  }

  outputParts = outputParts.concat(toParts.slice(samePartsLength));

  return outputParts.join('/');
};

exports.sep = '/';
exports.delimiter = ':';

exports.dirname = function(path) {
  var result = splitPath(path),
      root = result[0],
      dir = result[1];

  if (!root && !dir) {
    // No dirname whatsoever
    return '.';
  }

  if (dir) {
    // It has a dirname, strip trailing slash
    dir = dir.substr(0, dir.length - 1);
  }

  return root + dir;
};


exports.basename = function(path, ext) {
  var f = splitPath(path)[2];
  // TODO: make this comparison case-insensitive on windows?
  if (ext && f.substr(-1 * ext.length) === ext) {
    f = f.substr(0, f.length - ext.length);
  }
  return f;
};


exports.extname = function(path) {
  return splitPath(path)[3];
};

function filter (xs, f) {
    if (xs.filter) return xs.filter(f);
    var res = [];
    for (var i = 0; i < xs.length; i++) {
        if (f(xs[i], i, xs)) res.push(xs[i]);
    }
    return res;
}

// String.prototype.substr - negative index don't work in IE8
var substr = 'ab'.substr(-1) === 'b'
    ? function (str, start, len) { return str.substr(start, len) }
    : function (str, start, len) {
        if (start < 0) start = str.length + start;
        return str.substr(start, len);
    }
;

}).call(this,require('_process'))

},{"_process":109}],109:[function(require,module,exports){
// shim for using process in browser

var process = module.exports = {};
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = setTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    clearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        setTimeout(drainQueue, 0);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],110:[function(require,module,exports){
module.exports = function isBuffer(arg) {
  return arg && typeof arg === 'object'
    && typeof arg.copy === 'function'
    && typeof arg.fill === 'function'
    && typeof arg.readUInt8 === 'function';
}
},{}],111:[function(require,module,exports){
(function (process,global){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var formatRegExp = /%[sdj%]/g;
exports.format = function(f) {
  if (!isString(f)) {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(inspect(arguments[i]));
    }
    return objects.join(' ');
  }

  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function(x) {
    if (x === '%%') return '%';
    if (i >= len) return x;
    switch (x) {
      case '%s': return String(args[i++]);
      case '%d': return Number(args[i++]);
      case '%j':
        try {
          return JSON.stringify(args[i++]);
        } catch (_) {
          return '[Circular]';
        }
      default:
        return x;
    }
  });
  for (var x = args[i]; i < len; x = args[++i]) {
    if (isNull(x) || !isObject(x)) {
      str += ' ' + x;
    } else {
      str += ' ' + inspect(x);
    }
  }
  return str;
};


// Mark that a method should not be used.
// Returns a modified function which warns once by default.
// If --no-deprecation is set, then it is a no-op.
exports.deprecate = function(fn, msg) {
  // Allow for deprecating things in the process of starting up.
  if (isUndefined(global.process)) {
    return function() {
      return exports.deprecate(fn, msg).apply(this, arguments);
    };
  }

  if (process.noDeprecation === true) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (process.throwDeprecation) {
        throw new Error(msg);
      } else if (process.traceDeprecation) {
        console.trace(msg);
      } else {
        console.error(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
};


var debugs = {};
var debugEnviron;
exports.debuglog = function(set) {
  if (isUndefined(debugEnviron))
    debugEnviron = process.env.NODE_DEBUG || '';
  set = set.toUpperCase();
  if (!debugs[set]) {
    if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
      var pid = process.pid;
      debugs[set] = function() {
        var msg = exports.format.apply(exports, arguments);
        console.error('%s %d: %s', set, pid, msg);
      };
    } else {
      debugs[set] = function() {};
    }
  }
  return debugs[set];
};


/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */
/* legacy: obj, showHidden, depth, colors*/
function inspect(obj, opts) {
  // default options
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  // legacy...
  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];
  if (isBoolean(opts)) {
    // legacy...
    ctx.showHidden = opts;
  } else if (opts) {
    // got an "options" object
    exports._extend(ctx, opts);
  }
  // set default options
  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined(ctx.depth)) ctx.depth = 2;
  if (isUndefined(ctx.colors)) ctx.colors = false;
  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}
exports.inspect = inspect;


// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
inspect.colors = {
  'bold' : [1, 22],
  'italic' : [3, 23],
  'underline' : [4, 24],
  'inverse' : [7, 27],
  'white' : [37, 39],
  'grey' : [90, 39],
  'black' : [30, 39],
  'blue' : [34, 39],
  'cyan' : [36, 39],
  'green' : [32, 39],
  'magenta' : [35, 39],
  'red' : [31, 39],
  'yellow' : [33, 39]
};

// Don't use 'blue' not visible on cmd.exe
inspect.styles = {
  'special': 'cyan',
  'number': 'yellow',
  'boolean': 'yellow',
  'undefined': 'grey',
  'null': 'bold',
  'string': 'green',
  'date': 'magenta',
  // "name": intentionally not styling
  'regexp': 'red'
};


function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];

  if (style) {
    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
           '\u001b[' + inspect.colors[style][1] + 'm';
  } else {
    return str;
  }
}


function stylizeNoColor(str, styleType) {
  return str;
}


function arrayToHash(array) {
  var hash = {};

  array.forEach(function(val, idx) {
    hash[val] = true;
  });

  return hash;
}


function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (ctx.customInspect &&
      value &&
      isFunction(value.inspect) &&
      // Filter out the util module, it's inspect function is special
      value.inspect !== exports.inspect &&
      // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);
    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }

  // Primitive types cannot have properties
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }

  // Look up the keys of the object.
  var keys = Object.keys(value);
  var visibleKeys = arrayToHash(keys);

  if (ctx.showHidden) {
    keys = Object.getOwnPropertyNames(value);
  }

  // IE doesn't make error fields non-enumerable
  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
  if (isError(value)
      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
    return formatError(value);
  }

  // Some type of object without properties can be shortcutted.
  if (keys.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ': ' + value.name : '';
      return ctx.stylize('[Function' + name + ']', 'special');
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), 'date');
    }
    if (isError(value)) {
      return formatError(value);
    }
  }

  var base = '', array = false, braces = ['{', '}'];

  // Make Array say that they are Array
  if (isArray(value)) {
    array = true;
    braces = ['[', ']'];
  }

  // Make functions say that they are functions
  if (isFunction(value)) {
    var n = value.name ? ': ' + value.name : '';
    base = ' [Function' + n + ']';
  }

  // Make RegExps say that they are RegExps
  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  }

  // Make dates with properties first say the date
  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  }

  // Make error with message first say the error
  if (isError(value)) {
    base = ' ' + formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  ctx.seen.push(value);

  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function(key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();

  return reduceToSingleString(output, base, braces);
}


function formatPrimitive(ctx, value) {
  if (isUndefined(value))
    return ctx.stylize('undefined', 'undefined');
  if (isString(value)) {
    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                             .replace(/'/g, "\\'")
                                             .replace(/\\"/g, '"') + '\'';
    return ctx.stylize(simple, 'string');
  }
  if (isNumber(value))
    return ctx.stylize('' + value, 'number');
  if (isBoolean(value))
    return ctx.stylize('' + value, 'boolean');
  // For some reason typeof null is "object", so special case here.
  if (isNull(value))
    return ctx.stylize('null', 'null');
}


function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}


function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          String(i), true));
    } else {
      output.push('');
    }
  }
  keys.forEach(function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          key, true));
    }
  });
  return output;
}


function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize('[Getter/Setter]', 'special');
    } else {
      str = ctx.stylize('[Getter]', 'special');
    }
  } else {
    if (desc.set) {
      str = ctx.stylize('[Setter]', 'special');
    }
  }
  if (!hasOwnProperty(visibleKeys, key)) {
    name = '[' + key + ']';
  }
  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function(line) {
            return '  ' + line;
          }).join('\n').substr(2);
        } else {
          str = '\n' + str.split('\n').map(function(line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }
  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify('' + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'")
                 .replace(/\\"/g, '"')
                 .replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
}


function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = output.reduce(function(prev, cur) {
    numLinesEst++;
    if (cur.indexOf('\n') >= 0) numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
  }, 0);

  if (length > 60) {
    return braces[0] +
           (base === '' ? '' : base + '\n ') +
           ' ' +
           output.join(',\n  ') +
           ' ' +
           braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
}


// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
function isArray(ar) {
  return Array.isArray(ar);
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return isObject(e) &&
      (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = require('./support/isBuffer');

function objectToString(o) {
  return Object.prototype.toString.call(o);
}


function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}


var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
              'Oct', 'Nov', 'Dec'];

// 26 Feb 16:19:34
function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()),
              pad(d.getMinutes()),
              pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
}


// log is just a thin wrapper to console.log that prepends a timestamp
exports.log = function() {
  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
};


/**
 * Inherit the prototype methods from one constructor into another.
 *
 * The Function.prototype.inherits from lang.js rewritten as a standalone
 * function (not on Function.prototype). NOTE: If this file is to be loaded
 * during bootstrapping this function needs to be rewritten using some native
 * functions as prototype setup using normal JavaScript does not work as
 * expected during bootstrapping (see mirror.js in r114903).
 *
 * @param {function} ctor Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor Constructor function to inherit prototype from.
 */
exports.inherits = require('inherits');

exports._extend = function(origin, add) {
  // Don't do anything if add isn't an object
  if (!add || !isObject(add)) return origin;

  var keys = Object.keys(add);
  var i = keys.length;
  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }
  return origin;
};

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./support/isBuffer":110,"_process":109,"inherits":107}],112:[function(require,module,exports){
// (c) Dean McNamee <dean@gmail.com>, 2012.
//
// https://github.com/deanm/css-color-parser-js
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to
// deal in the Software without restriction, including without limitation the
// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
// sell copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
// IN THE SOFTWARE.

// http://www.w3.org/TR/css3-color/
var kCSSColorTable = {
  "transparent": [0,0,0,0], "aliceblue": [240,248,255,1],
  "antiquewhite": [250,235,215,1], "aqua": [0,255,255,1],
  "aquamarine": [127,255,212,1], "azure": [240,255,255,1],
  "beige": [245,245,220,1], "bisque": [255,228,196,1],
  "black": [0,0,0,1], "blanchedalmond": [255,235,205,1],
  "blue": [0,0,255,1], "blueviolet": [138,43,226,1],
  "brown": [165,42,42,1], "burlywood": [222,184,135,1],
  "cadetblue": [95,158,160,1], "chartreuse": [127,255,0,1],
  "chocolate": [210,105,30,1], "coral": [255,127,80,1],
  "cornflowerblue": [100,149,237,1], "cornsilk": [255,248,220,1],
  "crimson": [220,20,60,1], "cyan": [0,255,255,1],
  "darkblue": [0,0,139,1], "darkcyan": [0,139,139,1],
  "darkgoldenrod": [184,134,11,1], "darkgray": [169,169,169,1],
  "darkgreen": [0,100,0,1], "darkgrey": [169,169,169,1],
  "darkkhaki": [189,183,107,1], "darkmagenta": [139,0,139,1],
  "darkolivegreen": [85,107,47,1], "darkorange": [255,140,0,1],
  "darkorchid": [153,50,204,1], "darkred": [139,0,0,1],
  "darksalmon": [233,150,122,1], "darkseagreen": [143,188,143,1],
  "darkslateblue": [72,61,139,1], "darkslategray": [47,79,79,1],
  "darkslategrey": [47,79,79,1], "darkturquoise": [0,206,209,1],
  "darkviolet": [148,0,211,1], "deeppink": [255,20,147,1],
  "deepskyblue": [0,191,255,1], "dimgray": [105,105,105,1],
  "dimgrey": [105,105,105,1], "dodgerblue": [30,144,255,1],
  "firebrick": [178,34,34,1], "floralwhite": [255,250,240,1],
  "forestgreen": [34,139,34,1], "fuchsia": [255,0,255,1],
  "gainsboro": [220,220,220,1], "ghostwhite": [248,248,255,1],
  "gold": [255,215,0,1], "goldenrod": [218,165,32,1],
  "gray": [128,128,128,1], "green": [0,128,0,1],
  "greenyellow": [173,255,47,1], "grey": [128,128,128,1],
  "honeydew": [240,255,240,1], "hotpink": [255,105,180,1],
  "indianred": [205,92,92,1], "indigo": [75,0,130,1],
  "ivory": [255,255,240,1], "khaki": [240,230,140,1],
  "lavender": [230,230,250,1], "lavenderblush": [255,240,245,1],
  "lawngreen": [124,252,0,1], "lemonchiffon": [255,250,205,1],
  "lightblue": [173,216,230,1], "lightcoral": [240,128,128,1],
  "lightcyan": [224,255,255,1], "lightgoldenrodyellow": [250,250,210,1],
  "lightgray": [211,211,211,1], "lightgreen": [144,238,144,1],
  "lightgrey": [211,211,211,1], "lightpink": [255,182,193,1],
  "lightsalmon": [255,160,122,1], "lightseagreen": [32,178,170,1],
  "lightskyblue": [135,206,250,1], "lightslategray": [119,136,153,1],
  "lightslategrey": [119,136,153,1], "lightsteelblue": [176,196,222,1],
  "lightyellow": [255,255,224,1], "lime": [0,255,0,1],
  "limegreen": [50,205,50,1], "linen": [250,240,230,1],
  "magenta": [255,0,255,1], "maroon": [128,0,0,1],
  "mediumaquamarine": [102,205,170,1], "mediumblue": [0,0,205,1],
  "mediumorchid": [186,85,211,1], "mediumpurple": [147,112,219,1],
  "mediumseagreen": [60,179,113,1], "mediumslateblue": [123,104,238,1],
  "mediumspringgreen": [0,250,154,1], "mediumturquoise": [72,209,204,1],
  "mediumvioletred": [199,21,133,1], "midnightblue": [25,25,112,1],
  "mintcream": [245,255,250,1], "mistyrose": [255,228,225,1],
  "moccasin": [255,228,181,1], "navajowhite": [255,222,173,1],
  "navy": [0,0,128,1], "oldlace": [253,245,230,1],
  "olive": [128,128,0,1], "olivedrab": [107,142,35,1],
  "orange": [255,165,0,1], "orangered": [255,69,0,1],
  "orchid": [218,112,214,1], "palegoldenrod": [238,232,170,1],
  "palegreen": [152,251,152,1], "paleturquoise": [175,238,238,1],
  "palevioletred": [219,112,147,1], "papayawhip": [255,239,213,1],
  "peachpuff": [255,218,185,1], "peru": [205,133,63,1],
  "pink": [255,192,203,1], "plum": [221,160,221,1],
  "powderblue": [176,224,230,1], "purple": [128,0,128,1],
  "red": [255,0,0,1], "rosybrown": [188,143,143,1],
  "royalblue": [65,105,225,1], "saddlebrown": [139,69,19,1],
  "salmon": [250,128,114,1], "sandybrown": [244,164,96,1],
  "seagreen": [46,139,87,1], "seashell": [255,245,238,1],
  "sienna": [160,82,45,1], "silver": [192,192,192,1],
  "skyblue": [135,206,235,1], "slateblue": [106,90,205,1],
  "slategray": [112,128,144,1], "slategrey": [112,128,144,1],
  "snow": [255,250,250,1], "springgreen": [0,255,127,1],
  "steelblue": [70,130,180,1], "tan": [210,180,140,1],
  "teal": [0,128,128,1], "thistle": [216,191,216,1],
  "tomato": [255,99,71,1], "turquoise": [64,224,208,1],
  "violet": [238,130,238,1], "wheat": [245,222,179,1],
  "white": [255,255,255,1], "whitesmoke": [245,245,245,1],
  "yellow": [255,255,0,1], "yellowgreen": [154,205,50,1]}

function clamp_css_byte(i) {  // Clamp to integer 0 .. 255.
  i = Math.round(i);  // Seems to be what Chrome does (vs truncation).
  return i < 0 ? 0 : i > 255 ? 255 : i;
}

function clamp_css_float(f) {  // Clamp to float 0.0 .. 1.0.
  return f < 0 ? 0 : f > 1 ? 1 : f;
}

function parse_css_int(str) {  // int or percentage.
  if (str[str.length - 1] === '%')
    return clamp_css_byte(parseFloat(str) / 100 * 255);
  return clamp_css_byte(parseInt(str));
}

function parse_css_float(str) {  // float or percentage.
  if (str[str.length - 1] === '%')
    return clamp_css_float(parseFloat(str) / 100);
  return clamp_css_float(parseFloat(str));
}

function css_hue_to_rgb(m1, m2, h) {
  if (h < 0) h += 1;
  else if (h > 1) h -= 1;

  if (h * 6 < 1) return m1 + (m2 - m1) * h * 6;
  if (h * 2 < 1) return m2;
  if (h * 3 < 2) return m1 + (m2 - m1) * (2/3 - h) * 6;
  return m1;
}

function parseCSSColor(css_str) {
  // Remove all whitespace, not compliant, but should just be more accepting.
  var str = css_str.replace(/ /g, '').toLowerCase();

  // Color keywords (and transparent) lookup.
  if (str in kCSSColorTable) return kCSSColorTable[str].slice();  // dup.

  // #abc and #abc123 syntax.
  if (str[0] === '#') {
    if (str.length === 4) {
      var iv = parseInt(str.substr(1), 16);  // TODO(deanm): Stricter parsing.
      if (!(iv >= 0 && iv <= 0xfff)) return null;  // Covers NaN.
      return [((iv & 0xf00) >> 4) | ((iv & 0xf00) >> 8),
              (iv & 0xf0) | ((iv & 0xf0) >> 4),
              (iv & 0xf) | ((iv & 0xf) << 4),
              1];
    } else if (str.length === 7) {
      var iv = parseInt(str.substr(1), 16);  // TODO(deanm): Stricter parsing.
      if (!(iv >= 0 && iv <= 0xffffff)) return null;  // Covers NaN.
      return [(iv & 0xff0000) >> 16,
              (iv & 0xff00) >> 8,
              iv & 0xff,
              1];
    }

    return null;
  }

  var op = str.indexOf('('), ep = str.indexOf(')');
  if (op !== -1 && ep + 1 === str.length) {
    var fname = str.substr(0, op);
    var params = str.substr(op+1, ep-(op+1)).split(',');
    var alpha = 1;  // To allow case fallthrough.
    switch (fname) {
      case 'rgba':
        if (params.length !== 4) return null;
        alpha = parse_css_float(params.pop());
        // Fall through.
      case 'rgb':
        if (params.length !== 3) return null;
        return [parse_css_int(params[0]),
                parse_css_int(params[1]),
                parse_css_int(params[2]),
                alpha];
      case 'hsla':
        if (params.length !== 4) return null;
        alpha = parse_css_float(params.pop());
        // Fall through.
      case 'hsl':
        if (params.length !== 3) return null;
        var h = (((parseFloat(params[0]) % 360) + 360) % 360) / 360;  // 0 .. 1
        // NOTE(deanm): According to the CSS spec s/l should only be
        // percentages, but we don't bother and let float or percentage.
        var s = parse_css_float(params[1]);
        var l = parse_css_float(params[2]);
        var m2 = l <= 0.5 ? l * (s + 1) : l + s - l * s;
        var m1 = l * 2 - m2;
        return [clamp_css_byte(css_hue_to_rgb(m1, m2, h+1/3) * 255),
                clamp_css_byte(css_hue_to_rgb(m1, m2, h) * 255),
                clamp_css_byte(css_hue_to_rgb(m1, m2, h-1/3) * 255),
                alpha];
      default:
        return null;
    }
  }

  return null;
}

try { exports.parseCSSColor = parseCSSColor } catch(e) { }

},{}],113:[function(require,module,exports){
'use strict';

module.exports = createFilter;

var types = ['Unknown', 'Point', 'LineString', 'Polygon'];

/**
 * Given a filter expressed as nested arrays, return a new function
 * that evaluates whether a given feature (with a .properties or .tags property)
 * passes its test.
 *
 * @param {Array} filter mapbox gl filter
 * @returns {Function} filter-evaluating function
 */
function createFilter(filter) {
    return new Function('f', 'return ' + compile(filter));
}

function compile(filter) {
    if (!filter) return 'true';
    var op = filter[0];
    if (filter.length <= 1) return op === 'any' ? 'false' : 'true';
    var str =
        op === '==' ? compare(filter[1], filter[2], '===', false) :
        op === '!=' ? compare(filter[1], filter[2], '!==', false) :
        op === '<' ||
        op === '>' ||
        op === '<=' ||
        op === '>=' ? compare(filter[1], filter[2], op, true) :
        op === 'any' ? filter.slice(1).map(compile).join('||') :
        op === 'all' ? filter.slice(1).map(compile).join('&&') :
        op === 'none' ? '!(' + filter.slice(1).map(compile).join('||') + ')' :
        op === 'in' ? compileIn(filter[1], filter.slice(2)) :
        op === '!in' ? '!(' + compileIn(filter[1], filter.slice(2)) + ')' :
        'true';
    return '(' + str + ')';
}

function valueExpr(key) {
    return key === '$type' ? 'f.type' : '(f.properties || {})[' + JSON.stringify(key) + ']';
}
function compare(key, val, op, checkType) {
    var left = valueExpr(key);
    var right = key === '$type' ? types.indexOf(val) : JSON.stringify(val);
    return (checkType ? 'typeof ' + left + '=== typeof ' + right + '&&' : '') + left + op + right;
}
function compileIn(key, values) {
    if (key === '$type') values = values.map(function(value) { return types.indexOf(value); });
    var left = JSON.stringify(values.sort(compareFn));
    var right = valueExpr(key);

    if (values.length <= 200) return left + '.indexOf(' + right + ') !== -1';

    return 'function(v, a, i, j) {' +
        'while (i <= j) { var m = (i + j) >> 1;' +
        '    if (a[m] === v) return true; if (a[m] > v) j = m - 1; else i = m + 1;' +
        '}' +
    'return false; }(' + right + ', ' + left + ',0,' + (values.length - 1) + ')';
}

function compareFn(a, b) {
    return a < b ? -1 : a > b ? 1 : 0;
}

},{}],114:[function(require,module,exports){
var geojsonArea = require('geojson-area');

module.exports = rewind;

function rewind(gj, outer) {
    switch ((gj && gj.type) || null) {
        case 'FeatureCollection':
            gj.features = gj.features.map(curryOuter(rewind, outer));
            return gj;
        case 'Feature':
            gj.geometry = rewind(gj.geometry, outer);
            return gj;
        case 'Polygon':
        case 'MultiPolygon':
            return correct(gj, outer);
        default:
            return gj;
    }
}

function curryOuter(a, b) {
    return function(_) { return a(_, b); };
}

function correct(_, outer) {
    if (_.type === 'Polygon') {
        _.coordinates = correctRings(_.coordinates, outer);
    } else if (_.type === 'MultiPolygon') {
        _.coordinates = _.coordinates.map(curryOuter(correctRings, outer));
    }
    return _;
}

function correctRings(_, outer) {
    outer = !!outer;
    _[0] = wind(_[0], !outer);
    for (var i = 1; i < _.length; i++) {
        _[i] = wind(_[i], outer);
    }
    return _;
}

function wind(_, dir) {
    return cw(_) === dir ? _ : _.reverse();
}

function cw(_) {
    return geojsonArea.ring(_) >= 0;
}

},{"geojson-area":115}],115:[function(require,module,exports){
var wgs84 = require('wgs84');

module.exports.geometry = geometry;
module.exports.ring = ringArea;

function geometry(_) {
    if (_.type === 'Polygon') return polygonArea(_.coordinates);
    else if (_.type === 'MultiPolygon') {
        var area = 0;
        for (var i = 0; i < _.coordinates.length; i++) {
            area += polygonArea(_.coordinates[i]);
        }
        return area;
    } else {
        return null;
    }
}

function polygonArea(coords) {
    var area = 0;
    if (coords && coords.length > 0) {
        area += Math.abs(ringArea(coords[0]));
        for (var i = 1; i < coords.length; i++) {
            area -= Math.abs(ringArea(coords[i]));
        }
    }
    return area;
}

/**
 * Calculate the approximate area of the polygon were it projected onto
 *     the earth.  Note that this area will be positive if ring is oriented
 *     clockwise, otherwise it will be negative.
 *
 * Reference:
 * Robert. G. Chamberlain and William H. Duquette, "Some Algorithms for
 *     Polygons on a Sphere", JPL Publication 07-03, Jet Propulsion
 *     Laboratory, Pasadena, CA, June 2007 http://trs-new.jpl.nasa.gov/dspace/handle/2014/40409
 *
 * Returns:
 * {float} The approximate signed geodesic area of the polygon in square
 *     meters.
 */

function ringArea(coords) {
    var area = 0;

    if (coords.length > 2) {
        var p1, p2;
        for (var i = 0; i < coords.length - 1; i++) {
            p1 = coords[i];
            p2 = coords[i + 1];
            area += rad(p2[0] - p1[0]) * (2 + Math.sin(rad(p1[1])) + Math.sin(rad(p2[1])));
        }

        area = area * wgs84.RADIUS * wgs84.RADIUS / 2;
    }

    return area;
}

function rad(_) {
    return _ * Math.PI / 180;
}

},{"wgs84":116}],116:[function(require,module,exports){
module.exports.RADIUS = 6378137;
module.exports.FLATTENING = 1/298.257223563;
module.exports.POLAR_RADIUS = 6356752.3142;

},{}],117:[function(require,module,exports){
'use strict';

module.exports = clip;

/* clip features between two axis-parallel lines:
 *     |        |
 *  ___|___     |     /
 * /   |   \____|____/
 *     |        |
 */

function clip(features, scale, k1, k2, axis, intersect, minAll, maxAll) {

    k1 /= scale;
    k2 /= scale;

    if (minAll >= k1 && maxAll <= k2) return features; // trivial accept
    else if (minAll > k2 || maxAll < k1) return null; // trivial reject

    var clipped = [];

    for (var i = 0; i < features.length; i++) {

        var feature = features[i],
            geometry = feature.geometry,
            type = feature.type,
            min, max;

        min = feature.min[axis];
        max = feature.max[axis];

        if (min >= k1 && max <= k2) { // trivial accept
            clipped.push(feature);
            continue;
        } else if (min > k2 || max < k1) continue; // trivial reject

        var slices = type === 1 ?
                clipPoints(geometry, k1, k2, axis) :
                clipGeometry(geometry, k1, k2, axis, intersect, type === 3);

        if (slices.length) {
            // if a feature got clipped, it will likely get clipped on the next zoom level as well,
            // so there's no need to recalculate bboxes
            clipped.push({
                geometry: slices,
                type: type,
                tags: features[i].tags || null,
                min: feature.min,
                max: feature.max
            });
        }
    }

    return clipped.length ? clipped : null;
}

function clipPoints(geometry, k1, k2, axis) {
    var slice = [];

    for (var i = 0; i < geometry.length; i++) {
        var a = geometry[i],
            ak = a[axis];

        if (ak >= k1 && ak <= k2) slice.push(a);
    }
    return slice;
}

function clipGeometry(geometry, k1, k2, axis, intersect, closed) {

    var slices = [];

    for (var i = 0; i < geometry.length; i++) {

        var ak = 0,
            bk = 0,
            b = null,
            points = geometry[i],
            area = points.area,
            dist = points.dist,
            len = points.length,
            a, j, last;

        var slice = [];

        for (j = 0; j < len - 1; j++) {
            a = b || points[j];
            b = points[j + 1];
            ak = bk || a[axis];
            bk = b[axis];

            if (ak < k1) {

                if ((bk > k2)) { // ---|-----|-->
                    slice.push(intersect(a, b, k1), intersect(a, b, k2));
                    if (!closed) slice = newSlice(slices, slice, area, dist);

                } else if (bk >= k1) slice.push(intersect(a, b, k1)); // ---|-->  |

            } else if (ak > k2) {

                if ((bk < k1)) { // <--|-----|---
                    slice.push(intersect(a, b, k2), intersect(a, b, k1));
                    if (!closed) slice = newSlice(slices, slice, area, dist);

                } else if (bk <= k2) slice.push(intersect(a, b, k2)); // |  <--|---

            } else {

                slice.push(a);

                if (bk < k1) { // <--|---  |
                    slice.push(intersect(a, b, k1));
                    if (!closed) slice = newSlice(slices, slice, area, dist);

                } else if (bk > k2) { // |  ---|-->
                    slice.push(intersect(a, b, k2));
                    if (!closed) slice = newSlice(slices, slice, area, dist);
                }
                // | --> |
            }
        }

        // add the last point
        a = points[len - 1];
        ak = a[axis];
        if (ak >= k1 && ak <= k2) slice.push(a);

        // close the polygon if its endpoints are not the same after clipping

        last = slice[slice.length - 1];
        if (closed && last && (slice[0][0] !== last[0] || slice[0][1] !== last[1])) slice.push(slice[0]);

        // add the final slice
        newSlice(slices, slice, area, dist);
    }

    return slices;
}

function newSlice(slices, slice, area, dist) {
    if (slice.length) {
        // we don't recalculate the area/length of the unclipped geometry because the case where it goes
        // below the visibility threshold as a result of clipping is rare, so we avoid doing unnecessary work
        slice.area = area;
        slice.dist = dist;

        slices.push(slice);
    }
    return [];
}

},{}],118:[function(require,module,exports){
'use strict';

module.exports = convert;

var simplify = require('./simplify');

// converts GeoJSON feature into an intermediate projected JSON vector format with simplification data

function convert(data, tolerance) {
    var features = [];

    if (data.type === 'FeatureCollection') {
        for (var i = 0; i < data.features.length; i++) {
            convertFeature(features, data.features[i], tolerance);
        }
    } else if (data.type === 'Feature') {
        convertFeature(features, data, tolerance);

    } else {
        // single geometry or a geometry collection
        convertFeature(features, {geometry: data}, tolerance);
    }
    return features;
}

function convertFeature(features, feature, tolerance) {
    var geom = feature.geometry,
        type = geom.type,
        coords = geom.coordinates,
        tags = feature.properties,
        i, j, rings;

    if (type === 'Point') {
        features.push(create(tags, 1, [projectPoint(coords)]));

    } else if (type === 'MultiPoint') {
        features.push(create(tags, 1, project(coords)));

    } else if (type === 'LineString') {
        features.push(create(tags, 2, [project(coords, tolerance)]));

    } else if (type === 'MultiLineString' || type === 'Polygon') {
        rings = [];
        for (i = 0; i < coords.length; i++) {
            rings.push(project(coords[i], tolerance));
        }
        features.push(create(tags, type === 'Polygon' ? 3 : 2, rings));

    } else if (type === 'MultiPolygon') {
        rings = [];
        for (i = 0; i < coords.length; i++) {
            for (j = 0; j < coords[i].length; j++) {
                rings.push(project(coords[i][j], tolerance));
            }
        }
        features.push(create(tags, 3, rings));

    } else if (type === 'GeometryCollection') {
        for (i = 0; i < geom.geometries.length; i++) {
            convertFeature(features, {
                geometry: geom.geometries[i],
                properties: tags
            }, tolerance);
        }

    } else {
        throw new Error('Input data is not a valid GeoJSON object.');
    }
}

function create(tags, type, geometry) {
    var feature = {
        geometry: geometry,
        type: type,
        tags: tags || null,
        min: [2, 1], // initial bbox values;
        max: [-1, 0]  // note that coords are usually in [0..1] range
    };
    calcBBox(feature);
    return feature;
}

function project(lonlats, tolerance) {
    var projected = [];
    for (var i = 0; i < lonlats.length; i++) {
        projected.push(projectPoint(lonlats[i]));
    }
    if (tolerance) {
        simplify(projected, tolerance);
        calcSize(projected);
    }
    return projected;
}

function projectPoint(p) {
    var sin = Math.sin(p[1] * Math.PI / 180),
        x = (p[0] / 360 + 0.5),
        y = (0.5 - 0.25 * Math.log((1 + sin) / (1 - sin)) / Math.PI);

    y = y < -1 ? -1 :
        y > 1 ? 1 : y;

    return [x, y, 0];
}

// calculate area and length of the poly
function calcSize(points) {
    var area = 0,
        dist = 0;

    for (var i = 0, a, b; i < points.length - 1; i++) {
        a = b || points[i];
        b = points[i + 1];

        area += a[0] * b[1] - b[0] * a[1];

        // use Manhattan distance instead of Euclidian one to avoid expensive square root computation
        dist += Math.abs(b[0] - a[0]) + Math.abs(b[1] - a[1]);
    }
    points.area = Math.abs(area / 2);
    points.dist = dist;
}

// calculate the feature bounding box for faster clipping later
function calcBBox(feature) {
    var geometry = feature.geometry,
        min = feature.min,
        max = feature.max;

    if (feature.type === 1) calcRingBBox(min, max, geometry);
    else for (var i = 0; i < geometry.length; i++) calcRingBBox(min, max, geometry[i]);

    return feature;
}

function calcRingBBox(min, max, points) {
    for (var i = 0, p; i < points.length; i++) {
        p = points[i];
        min[0] = Math.min(p[0], min[0]);
        max[0] = Math.max(p[0], max[0]);
        min[1] = Math.min(p[1], min[1]);
        max[1] = Math.max(p[1], max[1]);
    }
}

},{"./simplify":120}],119:[function(require,module,exports){
'use strict';

module.exports = geojsonvt;

var convert = require('./convert'),     // GeoJSON conversion and preprocessing
    transform = require('./transform'), // coordinate transformation
    clip = require('./clip'),           // stripe clipping algorithm
    wrap = require('./wrap'),           // date line processing
    createTile = require('./tile');     // final simplified tile generation


function geojsonvt(data, options) {
    return new GeoJSONVT(data, options);
}

function GeoJSONVT(data, options) {
    options = this.options = extend(Object.create(this.options), options);

    var debug = options.debug;

    if (debug) console.time('preprocess data');

    var z2 = 1 << options.maxZoom, // 2^z
        features = convert(data, options.tolerance / (z2 * options.extent));

    this.tiles = {};
    this.tileCoords = [];

    if (debug) {
        console.timeEnd('preprocess data');
        console.log('index: maxZoom: %d, maxPoints: %d', options.indexMaxZoom, options.indexMaxPoints);
        console.time('generate tiles');
        this.stats = {};
        this.total = 0;
    }

    features = wrap(features, options.buffer / options.extent, intersectX);

    // start slicing from the top tile down
    if (features.length) this.splitTile(features, 0, 0, 0);

    if (debug) {
        if (features.length) console.log('features: %d, points: %d', this.tiles[0].numFeatures, this.tiles[0].numPoints);
        console.timeEnd('generate tiles');
        console.log('tiles generated:', this.total, JSON.stringify(this.stats));
    }
}

GeoJSONVT.prototype.options = {
    maxZoom: 14,            // max zoom to preserve detail on
    indexMaxZoom: 5,        // max zoom in the tile index
    indexMaxPoints: 100000, // max number of points per tile in the tile index
    solidChildren: false,   // whether to tile solid square tiles further
    tolerance: 3,           // simplification tolerance (higher means simpler)
    extent: 4096,           // tile extent
    buffer: 64,             // tile buffer on each side
    debug: 0                // logging level (0, 1 or 2)
};

GeoJSONVT.prototype.splitTile = function (features, z, x, y, cz, cx, cy) {

    var stack = [features, z, x, y],
        options = this.options,
        debug = options.debug,
        solid = null;

    // avoid recursion by using a processing queue
    while (stack.length) {
        y = stack.pop();
        x = stack.pop();
        z = stack.pop();
        features = stack.pop();

        var z2 = 1 << z,
            id = toID(z, x, y),
            tile = this.tiles[id],
            tileTolerance = z === options.maxZoom ? 0 : options.tolerance / (z2 * options.extent);

        if (!tile) {
            if (debug > 1) console.time('creation');

            tile = this.tiles[id] = createTile(features, z2, x, y, tileTolerance, z === options.maxZoom);
            this.tileCoords.push({z: z, x: x, y: y});

            if (debug) {
                if (debug > 1) {
                    console.log('tile z%d-%d-%d (features: %d, points: %d, simplified: %d)',
                        z, x, y, tile.numFeatures, tile.numPoints, tile.numSimplified);
                    console.timeEnd('creation');
                }
                var key = 'z' + z;
                this.stats[key] = (this.stats[key] || 0) + 1;
                this.total++;
            }
        }

        // save reference to original geometry in tile so that we can drill down later if we stop now
        tile.source = features;

        // if it's the first-pass tiling
        if (!cz) {
            // stop tiling if we reached max zoom, or if the tile is too simple
            if (z === options.indexMaxZoom || tile.numPoints <= options.indexMaxPoints) continue;

        // if a drilldown to a specific tile
        } else {
            // stop tiling if we reached base zoom or our target tile zoom
            if (z === options.maxZoom || z === cz) continue;

            // stop tiling if it's not an ancestor of the target tile
            var m = 1 << (cz - z);
            if (x !== Math.floor(cx / m) || y !== Math.floor(cy / m)) continue;
        }

        // stop tiling if the tile is solid clipped square
        if (!options.solidChildren && isClippedSquare(tile, options.extent, options.buffer)) {
            if (cz) solid = z; // and remember the zoom if we're drilling down
            continue;
        }

        // if we slice further down, no need to keep source geometry
        tile.source = null;

        if (debug > 1) console.time('clipping');

        // values we'll use for clipping
        var k1 = 0.5 * options.buffer / options.extent,
            k2 = 0.5 - k1,
            k3 = 0.5 + k1,
            k4 = 1 + k1,
            tl, bl, tr, br, left, right;

        tl = bl = tr = br = null;

        left  = clip(features, z2, x - k1, x + k3, 0, intersectX, tile.min[0], tile.max[0]);
        right = clip(features, z2, x + k2, x + k4, 0, intersectX, tile.min[0], tile.max[0]);

        if (left) {
            tl = clip(left, z2, y - k1, y + k3, 1, intersectY, tile.min[1], tile.max[1]);
            bl = clip(left, z2, y + k2, y + k4, 1, intersectY, tile.min[1], tile.max[1]);
        }

        if (right) {
            tr = clip(right, z2, y - k1, y + k3, 1, intersectY, tile.min[1], tile.max[1]);
            br = clip(right, z2, y + k2, y + k4, 1, intersectY, tile.min[1], tile.max[1]);
        }

        if (debug > 1) console.timeEnd('clipping');

        if (tl) stack.push(tl, z + 1, x * 2,     y * 2);
        if (bl) stack.push(bl, z + 1, x * 2,     y * 2 + 1);
        if (tr) stack.push(tr, z + 1, x * 2 + 1, y * 2);
        if (br) stack.push(br, z + 1, x * 2 + 1, y * 2 + 1);
    }

    return solid;
};

GeoJSONVT.prototype.getTile = function (z, x, y) {
    var options = this.options,
        extent = options.extent,
        debug = options.debug;

    var z2 = 1 << z;
    x = ((x % z2) + z2) % z2; // wrap tile x coordinate

    var id = toID(z, x, y);
    if (this.tiles[id]) return transform.tile(this.tiles[id], extent);

    if (debug > 1) console.log('drilling down to z%d-%d-%d', z, x, y);

    var z0 = z,
        x0 = x,
        y0 = y,
        parent;

    while (!parent && z0 > 0) {
        z0--;
        x0 = Math.floor(x0 / 2);
        y0 = Math.floor(y0 / 2);
        parent = this.tiles[toID(z0, x0, y0)];
    }

    if (!parent || !parent.source) return null;

    // if we found a parent tile containing the original geometry, we can drill down from it
    if (debug > 1) console.log('found parent tile z%d-%d-%d', z0, x0, y0);

    // it parent tile is a solid clipped square, return it instead since it's identical
    if (isClippedSquare(parent, extent, options.buffer)) return transform.tile(parent, extent);

    if (debug > 1) console.time('drilling down');
    var solid = this.splitTile(parent.source, z0, x0, y0, z, x, y);
    if (debug > 1) console.timeEnd('drilling down');

    // one of the parent tiles was a solid clipped square
    if (solid !== null) {
        var m = 1 << (z - solid);
        id = toID(solid, Math.floor(x / m), Math.floor(y / m));
    }

    return this.tiles[id] ? transform.tile(this.tiles[id], extent) : null;
};

function toID(z, x, y) {
    return (((1 << z) * y + x) * 32) + z;
}

function intersectX(a, b, x) {
    return [x, (x - a[0]) * (b[1] - a[1]) / (b[0] - a[0]) + a[1], 1];
}
function intersectY(a, b, y) {
    return [(y - a[1]) * (b[0] - a[0]) / (b[1] - a[1]) + a[0], y, 1];
}

function extend(dest, src) {
    for (var i in src) dest[i] = src[i];
    return dest;
}

// checks whether a tile is a whole-area fill after clipping; if it is, there's no sense slicing it further
function isClippedSquare(tile, extent, buffer) {

    var features = tile.source;
    if (features.length !== 1) return false;

    var feature = features[0];
    if (feature.type !== 3 || feature.geometry.length > 1) return false;

    var len = feature.geometry[0].length;
    if (len !== 5) return false;

    for (var i = 0; i < len; i++) {
        var p = transform.point(feature.geometry[0][i], extent, tile.z2, tile.x, tile.y);
        if ((p[0] !== -buffer && p[0] !== extent + buffer) ||
            (p[1] !== -buffer && p[1] !== extent + buffer)) return false;
    }

    return true;
}

},{"./clip":117,"./convert":118,"./tile":121,"./transform":122,"./wrap":123}],120:[function(require,module,exports){
'use strict';

module.exports = simplify;

// calculate simplification data using optimized Douglas-Peucker algorithm

function simplify(points, tolerance) {

    var sqTolerance = tolerance * tolerance,
        len = points.length,
        first = 0,
        last = len - 1,
        stack = [],
        i, maxSqDist, sqDist, index;

    // always retain the endpoints (1 is the max value)
    points[first][2] = 1;
    points[last][2] = 1;

    // avoid recursion by using a stack
    while (last) {

        maxSqDist = 0;

        for (i = first + 1; i < last; i++) {
            sqDist = getSqSegDist(points[i], points[first], points[last]);

            if (sqDist > maxSqDist) {
                index = i;
                maxSqDist = sqDist;
            }
        }

        if (maxSqDist > sqTolerance) {
            points[index][2] = maxSqDist; // save the point importance in squared pixels as a z coordinate
            stack.push(first);
            stack.push(index);
            first = index;

        } else {
            last = stack.pop();
            first = stack.pop();
        }
    }
}

// square distance from a point to a segment
function getSqSegDist(p, a, b) {

    var x = a[0], y = a[1],
        bx = b[0], by = b[1],
        px = p[0], py = p[1],
        dx = bx - x,
        dy = by - y;

    if (dx !== 0 || dy !== 0) {

        var t = ((px - x) * dx + (py - y) * dy) / (dx * dx + dy * dy);

        if (t > 1) {
            x = bx;
            y = by;

        } else if (t > 0) {
            x += dx * t;
            y += dy * t;
        }
    }

    dx = px - x;
    dy = py - y;

    return dx * dx + dy * dy;
}

},{}],121:[function(require,module,exports){
'use strict';

module.exports = createTile;

function createTile(features, z2, tx, ty, tolerance, noSimplify) {
    var tile = {
        features: [],
        numPoints: 0,
        numSimplified: 0,
        numFeatures: 0,
        source: null,
        x: tx,
        y: ty,
        z2: z2,
        transformed: false,
        min: [2, 1],
        max: [-1, 0]
    };
    for (var i = 0; i < features.length; i++) {
        tile.numFeatures++;
        addFeature(tile, features[i], tolerance, noSimplify);

        var min = features[i].min,
            max = features[i].max;

        if (min[0] < tile.min[0]) tile.min[0] = min[0];
        if (min[1] < tile.min[1]) tile.min[1] = min[1];
        if (max[0] > tile.max[0]) tile.max[0] = max[0];
        if (max[1] > tile.max[1]) tile.max[1] = max[1];
    }
    return tile;
}

function addFeature(tile, feature, tolerance, noSimplify) {

    var geom = feature.geometry,
        type = feature.type,
        simplified = [],
        sqTolerance = tolerance * tolerance,
        i, j, ring, p;

    if (type === 1) {
        for (i = 0; i < geom.length; i++) {
            simplified.push(geom[i]);
            tile.numPoints++;
            tile.numSimplified++;
        }

    } else {

        // simplify and transform projected coordinates for tile geometry
        for (i = 0; i < geom.length; i++) {
            ring = geom[i];

            // filter out tiny polylines & polygons
            if (!noSimplify && ((type === 2 && ring.dist < tolerance) ||
                                (type === 3 && ring.area < sqTolerance))) {
                tile.numPoints += ring.length;
                continue;
            }

            var simplifiedRing = [];

            for (j = 0; j < ring.length; j++) {
                p = ring[j];
                // keep points with importance > tolerance
                if (noSimplify || p[2] > sqTolerance) {
                    simplifiedRing.push(p);
                    tile.numSimplified++;
                }
                tile.numPoints++;
            }

            simplified.push(simplifiedRing);
        }
    }

    if (simplified.length) {
        tile.features.push({
            geometry: simplified,
            type: type,
            tags: feature.tags || null
        });
    }
}

},{}],122:[function(require,module,exports){
'use strict';

exports.tile = transformTile;
exports.point = transformPoint;

// Transforms the coordinates of each feature in the given tile from
// mercator-projected space into (extent x extent) tile space.
function transformTile(tile, extent) {
    if (tile.transformed) return tile;

    var z2 = tile.z2,
        tx = tile.x,
        ty = tile.y,
        i, j, k;

    for (i = 0; i < tile.features.length; i++) {
        var feature = tile.features[i],
            geom = feature.geometry,
            type = feature.type;

        if (type === 1) {
            for (j = 0; j < geom.length; j++) geom[j] = transformPoint(geom[j], extent, z2, tx, ty);

        } else {
            for (j = 0; j < geom.length; j++) {
                var ring = geom[j];
                for (k = 0; k < ring.length; k++) ring[k] = transformPoint(ring[k], extent, z2, tx, ty);
            }
        }
    }

    tile.transformed = true;

    return tile;
}

function transformPoint(p, extent, z2, tx, ty) {
    var x = Math.round(extent * (p[0] * z2 - tx)),
        y = Math.round(extent * (p[1] * z2 - ty));
    return [x, y];
}

},{}],123:[function(require,module,exports){
'use strict';

var clip = require('./clip');

module.exports = wrap;

function wrap(features, buffer, intersectX) {
    var merged = features,
        left  = clip(features, 1, -1 - buffer, buffer,     0, intersectX, -1, 2), // left world copy
        right = clip(features, 1,  1 - buffer, 2 + buffer, 0, intersectX, -1, 2); // right world copy

    if (left || right) {
        merged = clip(features, 1, -buffer, 1 + buffer, 0, intersectX, -1, 2); // center world copy

        if (left) merged = shiftFeatureCoords(left, 1).concat(merged); // merge left into center
        if (right) merged = merged.concat(shiftFeatureCoords(right, -1)); // merge right into center
    }

    return merged;
}

function shiftFeatureCoords(features, offset) {
    var newFeatures = [];

    for (var i = 0; i < features.length; i++) {
        var feature = features[i],
            type = feature.type;

        var newGeometry;

        if (type === 1) {
            newGeometry = shiftCoords(feature.geometry, offset);
        } else {
            newGeometry = [];
            for (var j = 0; j < feature.geometry.length; j++) {
                newGeometry.push(shiftCoords(feature.geometry[j], offset));
            }
        }

        newFeatures.push({
            geometry: newGeometry,
            type: type,
            tags: feature.tags,
            min: [feature.min[0] + offset, feature.min[1]],
            max: [feature.max[0] + offset, feature.max[1]]
        });
    }

    return newFeatures;
}

function shiftCoords(points, offset) {
    var newPoints = [];
    newPoints.area = points.area;
    newPoints.dist = points.dist;

    for (var i = 0; i < points.length; i++) {
        newPoints.push([points[i][0] + offset, points[i][1], points[i][2]]);
    }
    return newPoints;
}

},{"./clip":117}],124:[function(require,module,exports){
/**
 * @fileoverview gl-matrix - High performance matrix and vector operations
 * @author Brandon Jones
 * @author Colin MacKenzie IV
 * @version 2.3.2
 */

/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE. */
// END HEADER

exports.glMatrix = require("./gl-matrix/common.js");
exports.mat2 = require("./gl-matrix/mat2.js");
exports.mat2d = require("./gl-matrix/mat2d.js");
exports.mat3 = require("./gl-matrix/mat3.js");
exports.mat4 = require("./gl-matrix/mat4.js");
exports.quat = require("./gl-matrix/quat.js");
exports.vec2 = require("./gl-matrix/vec2.js");
exports.vec3 = require("./gl-matrix/vec3.js");
exports.vec4 = require("./gl-matrix/vec4.js");
},{"./gl-matrix/common.js":125,"./gl-matrix/mat2.js":126,"./gl-matrix/mat2d.js":127,"./gl-matrix/mat3.js":128,"./gl-matrix/mat4.js":129,"./gl-matrix/quat.js":130,"./gl-matrix/vec2.js":131,"./gl-matrix/vec3.js":132,"./gl-matrix/vec4.js":133}],125:[function(require,module,exports){
/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE. */

/**
 * @class Common utilities
 * @name glMatrix
 */
var glMatrix = {};

// Configuration Constants
glMatrix.EPSILON = 0.000001;
glMatrix.ARRAY_TYPE = (typeof Float32Array !== 'undefined') ? Float32Array : Array;
glMatrix.RANDOM = Math.random;
glMatrix.ENABLE_SIMD = false;

// Capability detection
glMatrix.SIMD_AVAILABLE = (glMatrix.ARRAY_TYPE === Float32Array) && ('SIMD' in this);
glMatrix.USE_SIMD = glMatrix.ENABLE_SIMD && glMatrix.SIMD_AVAILABLE;

/**
 * Sets the type of array used when creating new vectors and matrices
 *
 * @param {Type} type Array type, such as Float32Array or Array
 */
glMatrix.setMatrixArrayType = function(type) {
    glMatrix.ARRAY_TYPE = type;
}

var degree = Math.PI / 180;

/**
* Convert Degree To Radian
*
* @param {Number} Angle in Degrees
*/
glMatrix.toRadian = function(a){
     return a * degree;
}

/**
 * Tests whether or not the arguments have approximately the same value, within an absolute
 * or relative tolerance of glMatrix.EPSILON (an absolute tolerance is used for values less 
 * than or equal to 1.0, and a relative tolerance is used for larger values)
 * 
 * @param {Number} a The first number to test.
 * @param {Number} b The second number to test.
 * @returns {Boolean} True if the numbers are approximately equal, false otherwise.
 */
glMatrix.equals = function(a, b) {
	return Math.abs(a - b) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a), Math.abs(b));
}

module.exports = glMatrix;

},{}],126:[function(require,module,exports){
/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE. */

var glMatrix = require("./common.js");

/**
 * @class 2x2 Matrix
 * @name mat2
 */
var mat2 = {};

/**
 * Creates a new identity mat2
 *
 * @returns {mat2} a new 2x2 matrix
 */
mat2.create = function() {
    var out = new glMatrix.ARRAY_TYPE(4);
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 1;
    return out;
};

/**
 * Creates a new mat2 initialized with values from an existing matrix
 *
 * @param {mat2} a matrix to clone
 * @returns {mat2} a new 2x2 matrix
 */
mat2.clone = function(a) {
    var out = new glMatrix.ARRAY_TYPE(4);
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    return out;
};

/**
 * Copy the values from one mat2 to another
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the source matrix
 * @returns {mat2} out
 */
mat2.copy = function(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    return out;
};

/**
 * Set a mat2 to the identity matrix
 *
 * @param {mat2} out the receiving matrix
 * @returns {mat2} out
 */
mat2.identity = function(out) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 1;
    return out;
};

/**
 * Create a new mat2 with the given values
 *
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m10 Component in column 1, row 0 position (index 2)
 * @param {Number} m11 Component in column 1, row 1 position (index 3)
 * @returns {mat2} out A new 2x2 matrix
 */
mat2.fromValues = function(m00, m01, m10, m11) {
    var out = new glMatrix.ARRAY_TYPE(4);
    out[0] = m00;
    out[1] = m01;
    out[2] = m10;
    out[3] = m11;
    return out;
};

/**
 * Set the components of a mat2 to the given values
 *
 * @param {mat2} out the receiving matrix
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m10 Component in column 1, row 0 position (index 2)
 * @param {Number} m11 Component in column 1, row 1 position (index 3)
 * @returns {mat2} out
 */
mat2.set = function(out, m00, m01, m10, m11) {
    out[0] = m00;
    out[1] = m01;
    out[2] = m10;
    out[3] = m11;
    return out;
};


/**
 * Transpose the values of a mat2
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the source matrix
 * @returns {mat2} out
 */
mat2.transpose = function(out, a) {
    // If we are transposing ourselves we can skip a few steps but have to cache some values
    if (out === a) {
        var a1 = a[1];
        out[1] = a[2];
        out[2] = a1;
    } else {
        out[0] = a[0];
        out[1] = a[2];
        out[2] = a[1];
        out[3] = a[3];
    }
    
    return out;
};

/**
 * Inverts a mat2
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the source matrix
 * @returns {mat2} out
 */
mat2.invert = function(out, a) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3],

        // Calculate the determinant
        det = a0 * a3 - a2 * a1;

    if (!det) {
        return null;
    }
    det = 1.0 / det;
    
    out[0] =  a3 * det;
    out[1] = -a1 * det;
    out[2] = -a2 * det;
    out[3] =  a0 * det;

    return out;
};

/**
 * Calculates the adjugate of a mat2
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the source matrix
 * @returns {mat2} out
 */
mat2.adjoint = function(out, a) {
    // Caching this value is nessecary if out == a
    var a0 = a[0];
    out[0] =  a[3];
    out[1] = -a[1];
    out[2] = -a[2];
    out[3] =  a0;

    return out;
};

/**
 * Calculates the determinant of a mat2
 *
 * @param {mat2} a the source matrix
 * @returns {Number} determinant of a
 */
mat2.determinant = function (a) {
    return a[0] * a[3] - a[2] * a[1];
};

/**
 * Multiplies two mat2's
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the first operand
 * @param {mat2} b the second operand
 * @returns {mat2} out
 */
mat2.multiply = function (out, a, b) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3];
    var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
    out[0] = a0 * b0 + a2 * b1;
    out[1] = a1 * b0 + a3 * b1;
    out[2] = a0 * b2 + a2 * b3;
    out[3] = a1 * b2 + a3 * b3;
    return out;
};

/**
 * Alias for {@link mat2.multiply}
 * @function
 */
mat2.mul = mat2.multiply;

/**
 * Rotates a mat2 by the given angle
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat2} out
 */
mat2.rotate = function (out, a, rad) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3],
        s = Math.sin(rad),
        c = Math.cos(rad);
    out[0] = a0 *  c + a2 * s;
    out[1] = a1 *  c + a3 * s;
    out[2] = a0 * -s + a2 * c;
    out[3] = a1 * -s + a3 * c;
    return out;
};

/**
 * Scales the mat2 by the dimensions in the given vec2
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the matrix to rotate
 * @param {vec2} v the vec2 to scale the matrix by
 * @returns {mat2} out
 **/
mat2.scale = function(out, a, v) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3],
        v0 = v[0], v1 = v[1];
    out[0] = a0 * v0;
    out[1] = a1 * v0;
    out[2] = a2 * v1;
    out[3] = a3 * v1;
    return out;
};

/**
 * Creates a matrix from a given angle
 * This is equivalent to (but much faster than):
 *
 *     mat2.identity(dest);
 *     mat2.rotate(dest, dest, rad);
 *
 * @param {mat2} out mat2 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat2} out
 */
mat2.fromRotation = function(out, rad) {
    var s = Math.sin(rad),
        c = Math.cos(rad);
    out[0] = c;
    out[1] = s;
    out[2] = -s;
    out[3] = c;
    return out;
}

/**
 * Creates a matrix from a vector scaling
 * This is equivalent to (but much faster than):
 *
 *     mat2.identity(dest);
 *     mat2.scale(dest, dest, vec);
 *
 * @param {mat2} out mat2 receiving operation result
 * @param {vec2} v Scaling vector
 * @returns {mat2} out
 */
mat2.fromScaling = function(out, v) {
    out[0] = v[0];
    out[1] = 0;
    out[2] = 0;
    out[3] = v[1];
    return out;
}

/**
 * Returns a string representation of a mat2
 *
 * @param {mat2} mat matrix to represent as a string
 * @returns {String} string representation of the matrix
 */
mat2.str = function (a) {
    return 'mat2(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ')';
};

/**
 * Returns Frobenius norm of a mat2
 *
 * @param {mat2} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */
mat2.frob = function (a) {
    return(Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2)))
};

/**
 * Returns L, D and U matrices (Lower triangular, Diagonal and Upper triangular) by factorizing the input matrix
 * @param {mat2} L the lower triangular matrix 
 * @param {mat2} D the diagonal matrix 
 * @param {mat2} U the upper triangular matrix 
 * @param {mat2} a the input matrix to factorize
 */

mat2.LDU = function (L, D, U, a) { 
    L[2] = a[2]/a[0]; 
    U[0] = a[0]; 
    U[1] = a[1]; 
    U[3] = a[3] - L[2] * U[1]; 
    return [L, D, U];       
}; 

/**
 * Adds two mat2's
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the first operand
 * @param {mat2} b the second operand
 * @returns {mat2} out
 */
mat2.add = function(out, a, b) {
    out[0] = a[0] + b[0];
    out[1] = a[1] + b[1];
    out[2] = a[2] + b[2];
    out[3] = a[3] + b[3];
    return out;
};

/**
 * Subtracts matrix b from matrix a
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the first operand
 * @param {mat2} b the second operand
 * @returns {mat2} out
 */
mat2.subtract = function(out, a, b) {
    out[0] = a[0] - b[0];
    out[1] = a[1] - b[1];
    out[2] = a[2] - b[2];
    out[3] = a[3] - b[3];
    return out;
};

/**
 * Alias for {@link mat2.subtract}
 * @function
 */
mat2.sub = mat2.subtract;

/**
 * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
 *
 * @param {mat2} a The first matrix.
 * @param {mat2} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */
mat2.exactEquals = function (a, b) {
    return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3];
};

/**
 * Returns whether or not the matrices have approximately the same elements in the same position.
 *
 * @param {mat2} a The first matrix.
 * @param {mat2} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */
mat2.equals = function (a, b) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3];
    var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
    return (Math.abs(a0 - b0) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a0), Math.abs(b0)) &&
            Math.abs(a1 - b1) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a1), Math.abs(b1)) &&
            Math.abs(a2 - b2) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a2), Math.abs(b2)) &&
            Math.abs(a3 - b3) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a3), Math.abs(b3)));
};

/**
 * Multiply each element of the matrix by a scalar.
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the matrix to scale
 * @param {Number} b amount to scale the matrix's elements by
 * @returns {mat2} out
 */
mat2.multiplyScalar = function(out, a, b) {
    out[0] = a[0] * b;
    out[1] = a[1] * b;
    out[2] = a[2] * b;
    out[3] = a[3] * b;
    return out;
};

/**
 * Adds two mat2's after multiplying each element of the second operand by a scalar value.
 *
 * @param {mat2} out the receiving vector
 * @param {mat2} a the first operand
 * @param {mat2} b the second operand
 * @param {Number} scale the amount to scale b's elements by before adding
 * @returns {mat2} out
 */
mat2.multiplyScalarAndAdd = function(out, a, b, scale) {
    out[0] = a[0] + (b[0] * scale);
    out[1] = a[1] + (b[1] * scale);
    out[2] = a[2] + (b[2] * scale);
    out[3] = a[3] + (b[3] * scale);
    return out;
};

module.exports = mat2;

},{"./common.js":125}],127:[function(require,module,exports){
/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE. */

var glMatrix = require("./common.js");

/**
 * @class 2x3 Matrix
 * @name mat2d
 * 
 * @description 
 * A mat2d contains six elements defined as:
 * <pre>
 * [a, c, tx,
 *  b, d, ty]
 * </pre>
 * This is a short form for the 3x3 matrix:
 * <pre>
 * [a, c, tx,
 *  b, d, ty,
 *  0, 0, 1]
 * </pre>
 * The last row is ignored so the array is shorter and operations are faster.
 */
var mat2d = {};

/**
 * Creates a new identity mat2d
 *
 * @returns {mat2d} a new 2x3 matrix
 */
mat2d.create = function() {
    var out = new glMatrix.ARRAY_TYPE(6);
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 1;
    out[4] = 0;
    out[5] = 0;
    return out;
};

/**
 * Creates a new mat2d initialized with values from an existing matrix
 *
 * @param {mat2d} a matrix to clone
 * @returns {mat2d} a new 2x3 matrix
 */
mat2d.clone = function(a) {
    var out = new glMatrix.ARRAY_TYPE(6);
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    return out;
};

/**
 * Copy the values from one mat2d to another
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the source matrix
 * @returns {mat2d} out
 */
mat2d.copy = function(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    return out;
};

/**
 * Set a mat2d to the identity matrix
 *
 * @param {mat2d} out the receiving matrix
 * @returns {mat2d} out
 */
mat2d.identity = function(out) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 1;
    out[4] = 0;
    out[5] = 0;
    return out;
};

/**
 * Create a new mat2d with the given values
 *
 * @param {Number} a Component A (index 0)
 * @param {Number} b Component B (index 1)
 * @param {Number} c Component C (index 2)
 * @param {Number} d Component D (index 3)
 * @param {Number} tx Component TX (index 4)
 * @param {Number} ty Component TY (index 5)
 * @returns {mat2d} A new mat2d
 */
mat2d.fromValues = function(a, b, c, d, tx, ty) {
    var out = new glMatrix.ARRAY_TYPE(6);
    out[0] = a;
    out[1] = b;
    out[2] = c;
    out[3] = d;
    out[4] = tx;
    out[5] = ty;
    return out;
};

/**
 * Set the components of a mat2d to the given values
 *
 * @param {mat2d} out the receiving matrix
 * @param {Number} a Component A (index 0)
 * @param {Number} b Component B (index 1)
 * @param {Number} c Component C (index 2)
 * @param {Number} d Component D (index 3)
 * @param {Number} tx Component TX (index 4)
 * @param {Number} ty Component TY (index 5)
 * @returns {mat2d} out
 */
mat2d.set = function(out, a, b, c, d, tx, ty) {
    out[0] = a;
    out[1] = b;
    out[2] = c;
    out[3] = d;
    out[4] = tx;
    out[5] = ty;
    return out;
};

/**
 * Inverts a mat2d
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the source matrix
 * @returns {mat2d} out
 */
mat2d.invert = function(out, a) {
    var aa = a[0], ab = a[1], ac = a[2], ad = a[3],
        atx = a[4], aty = a[5];

    var det = aa * ad - ab * ac;
    if(!det){
        return null;
    }
    det = 1.0 / det;

    out[0] = ad * det;
    out[1] = -ab * det;
    out[2] = -ac * det;
    out[3] = aa * det;
    out[4] = (ac * aty - ad * atx) * det;
    out[5] = (ab * atx - aa * aty) * det;
    return out;
};

/**
 * Calculates the determinant of a mat2d
 *
 * @param {mat2d} a the source matrix
 * @returns {Number} determinant of a
 */
mat2d.determinant = function (a) {
    return a[0] * a[3] - a[1] * a[2];
};

/**
 * Multiplies two mat2d's
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the first operand
 * @param {mat2d} b the second operand
 * @returns {mat2d} out
 */
mat2d.multiply = function (out, a, b) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5],
        b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3], b4 = b[4], b5 = b[5];
    out[0] = a0 * b0 + a2 * b1;
    out[1] = a1 * b0 + a3 * b1;
    out[2] = a0 * b2 + a2 * b3;
    out[3] = a1 * b2 + a3 * b3;
    out[4] = a0 * b4 + a2 * b5 + a4;
    out[5] = a1 * b4 + a3 * b5 + a5;
    return out;
};

/**
 * Alias for {@link mat2d.multiply}
 * @function
 */
mat2d.mul = mat2d.multiply;

/**
 * Rotates a mat2d by the given angle
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat2d} out
 */
mat2d.rotate = function (out, a, rad) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5],
        s = Math.sin(rad),
        c = Math.cos(rad);
    out[0] = a0 *  c + a2 * s;
    out[1] = a1 *  c + a3 * s;
    out[2] = a0 * -s + a2 * c;
    out[3] = a1 * -s + a3 * c;
    out[4] = a4;
    out[5] = a5;
    return out;
};

/**
 * Scales the mat2d by the dimensions in the given vec2
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the matrix to translate
 * @param {vec2} v the vec2 to scale the matrix by
 * @returns {mat2d} out
 **/
mat2d.scale = function(out, a, v) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5],
        v0 = v[0], v1 = v[1];
    out[0] = a0 * v0;
    out[1] = a1 * v0;
    out[2] = a2 * v1;
    out[3] = a3 * v1;
    out[4] = a4;
    out[5] = a5;
    return out;
};

/**
 * Translates the mat2d by the dimensions in the given vec2
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the matrix to translate
 * @param {vec2} v the vec2 to translate the matrix by
 * @returns {mat2d} out
 **/
mat2d.translate = function(out, a, v) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5],
        v0 = v[0], v1 = v[1];
    out[0] = a0;
    out[1] = a1;
    out[2] = a2;
    out[3] = a3;
    out[4] = a0 * v0 + a2 * v1 + a4;
    out[5] = a1 * v0 + a3 * v1 + a5;
    return out;
};

/**
 * Creates a matrix from a given angle
 * This is equivalent to (but much faster than):
 *
 *     mat2d.identity(dest);
 *     mat2d.rotate(dest, dest, rad);
 *
 * @param {mat2d} out mat2d receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat2d} out
 */
mat2d.fromRotation = function(out, rad) {
    var s = Math.sin(rad), c = Math.cos(rad);
    out[0] = c;
    out[1] = s;
    out[2] = -s;
    out[3] = c;
    out[4] = 0;
    out[5] = 0;
    return out;
}

/**
 * Creates a matrix from a vector scaling
 * This is equivalent to (but much faster than):
 *
 *     mat2d.identity(dest);
 *     mat2d.scale(dest, dest, vec);
 *
 * @param {mat2d} out mat2d receiving operation result
 * @param {vec2} v Scaling vector
 * @returns {mat2d} out
 */
mat2d.fromScaling = function(out, v) {
    out[0] = v[0];
    out[1] = 0;
    out[2] = 0;
    out[3] = v[1];
    out[4] = 0;
    out[5] = 0;
    return out;
}

/**
 * Creates a matrix from a vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat2d.identity(dest);
 *     mat2d.translate(dest, dest, vec);
 *
 * @param {mat2d} out mat2d receiving operation result
 * @param {vec2} v Translation vector
 * @returns {mat2d} out
 */
mat2d.fromTranslation = function(out, v) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 1;
    out[4] = v[0];
    out[5] = v[1];
    return out;
}

/**
 * Returns a string representation of a mat2d
 *
 * @param {mat2d} a matrix to represent as a string
 * @returns {String} string representation of the matrix
 */
mat2d.str = function (a) {
    return 'mat2d(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + 
                    a[3] + ', ' + a[4] + ', ' + a[5] + ')';
};

/**
 * Returns Frobenius norm of a mat2d
 *
 * @param {mat2d} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */
mat2d.frob = function (a) { 
    return(Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2) + Math.pow(a[4], 2) + Math.pow(a[5], 2) + 1))
}; 

/**
 * Adds two mat2d's
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the first operand
 * @param {mat2d} b the second operand
 * @returns {mat2d} out
 */
mat2d.add = function(out, a, b) {
    out[0] = a[0] + b[0];
    out[1] = a[1] + b[1];
    out[2] = a[2] + b[2];
    out[3] = a[3] + b[3];
    out[4] = a[4] + b[4];
    out[5] = a[5] + b[5];
    return out;
};

/**
 * Subtracts matrix b from matrix a
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the first operand
 * @param {mat2d} b the second operand
 * @returns {mat2d} out
 */
mat2d.subtract = function(out, a, b) {
    out[0] = a[0] - b[0];
    out[1] = a[1] - b[1];
    out[2] = a[2] - b[2];
    out[3] = a[3] - b[3];
    out[4] = a[4] - b[4];
    out[5] = a[5] - b[5];
    return out;
};

/**
 * Alias for {@link mat2d.subtract}
 * @function
 */
mat2d.sub = mat2d.subtract;

/**
 * Multiply each element of the matrix by a scalar.
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the matrix to scale
 * @param {Number} b amount to scale the matrix's elements by
 * @returns {mat2d} out
 */
mat2d.multiplyScalar = function(out, a, b) {
    out[0] = a[0] * b;
    out[1] = a[1] * b;
    out[2] = a[2] * b;
    out[3] = a[3] * b;
    out[4] = a[4] * b;
    out[5] = a[5] * b;
    return out;
};

/**
 * Adds two mat2d's after multiplying each element of the second operand by a scalar value.
 *
 * @param {mat2d} out the receiving vector
 * @param {mat2d} a the first operand
 * @param {mat2d} b the second operand
 * @param {Number} scale the amount to scale b's elements by before adding
 * @returns {mat2d} out
 */
mat2d.multiplyScalarAndAdd = function(out, a, b, scale) {
    out[0] = a[0] + (b[0] * scale);
    out[1] = a[1] + (b[1] * scale);
    out[2] = a[2] + (b[2] * scale);
    out[3] = a[3] + (b[3] * scale);
    out[4] = a[4] + (b[4] * scale);
    out[5] = a[5] + (b[5] * scale);
    return out;
};

/**
 * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
 *
 * @param {mat2d} a The first matrix.
 * @param {mat2d} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */
mat2d.exactEquals = function (a, b) {
    return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5];
};

/**
 * Returns whether or not the matrices have approximately the same elements in the same position.
 *
 * @param {mat2d} a The first matrix.
 * @param {mat2d} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */
mat2d.equals = function (a, b) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5];
    var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3], b4 = b[4], b5 = b[5];
    return (Math.abs(a0 - b0) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a0), Math.abs(b0)) &&
            Math.abs(a1 - b1) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a1), Math.abs(b1)) &&
            Math.abs(a2 - b2) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a2), Math.abs(b2)) &&
            Math.abs(a3 - b3) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a3), Math.abs(b3)) &&
            Math.abs(a4 - b4) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a4), Math.abs(b4)) &&
            Math.abs(a5 - b5) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a5), Math.abs(b5)));
};

module.exports = mat2d;

},{"./common.js":125}],128:[function(require,module,exports){
/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE. */

var glMatrix = require("./common.js");

/**
 * @class 3x3 Matrix
 * @name mat3
 */
var mat3 = {};

/**
 * Creates a new identity mat3
 *
 * @returns {mat3} a new 3x3 matrix
 */
mat3.create = function() {
    var out = new glMatrix.ARRAY_TYPE(9);
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 1;
    out[5] = 0;
    out[6] = 0;
    out[7] = 0;
    out[8] = 1;
    return out;
};

/**
 * Copies the upper-left 3x3 values into the given mat3.
 *
 * @param {mat3} out the receiving 3x3 matrix
 * @param {mat4} a   the source 4x4 matrix
 * @returns {mat3} out
 */
mat3.fromMat4 = function(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[4];
    out[4] = a[5];
    out[5] = a[6];
    out[6] = a[8];
    out[7] = a[9];
    out[8] = a[10];
    return out;
};

/**
 * Creates a new mat3 initialized with values from an existing matrix
 *
 * @param {mat3} a matrix to clone
 * @returns {mat3} a new 3x3 matrix
 */
mat3.clone = function(a) {
    var out = new glMatrix.ARRAY_TYPE(9);
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[8] = a[8];
    return out;
};

/**
 * Copy the values from one mat3 to another
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the source matrix
 * @returns {mat3} out
 */
mat3.copy = function(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[8] = a[8];
    return out;
};

/**
 * Create a new mat3 with the given values
 *
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m02 Component in column 0, row 2 position (index 2)
 * @param {Number} m10 Component in column 1, row 0 position (index 3)
 * @param {Number} m11 Component in column 1, row 1 position (index 4)
 * @param {Number} m12 Component in column 1, row 2 position (index 5)
 * @param {Number} m20 Component in column 2, row 0 position (index 6)
 * @param {Number} m21 Component in column 2, row 1 position (index 7)
 * @param {Number} m22 Component in column 2, row 2 position (index 8)
 * @returns {mat3} A new mat3
 */
mat3.fromValues = function(m00, m01, m02, m10, m11, m12, m20, m21, m22) {
    var out = new glMatrix.ARRAY_TYPE(9);
    out[0] = m00;
    out[1] = m01;
    out[2] = m02;
    out[3] = m10;
    out[4] = m11;
    out[5] = m12;
    out[6] = m20;
    out[7] = m21;
    out[8] = m22;
    return out;
};

/**
 * Set the components of a mat3 to the given values
 *
 * @param {mat3} out the receiving matrix
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m02 Component in column 0, row 2 position (index 2)
 * @param {Number} m10 Component in column 1, row 0 position (index 3)
 * @param {Number} m11 Component in column 1, row 1 position (index 4)
 * @param {Number} m12 Component in column 1, row 2 position (index 5)
 * @param {Number} m20 Component in column 2, row 0 position (index 6)
 * @param {Number} m21 Component in column 2, row 1 position (index 7)
 * @param {Number} m22 Component in column 2, row 2 position (index 8)
 * @returns {mat3} out
 */
mat3.set = function(out, m00, m01, m02, m10, m11, m12, m20, m21, m22) {
    out[0] = m00;
    out[1] = m01;
    out[2] = m02;
    out[3] = m10;
    out[4] = m11;
    out[5] = m12;
    out[6] = m20;
    out[7] = m21;
    out[8] = m22;
    return out;
};

/**
 * Set a mat3 to the identity matrix
 *
 * @param {mat3} out the receiving matrix
 * @returns {mat3} out
 */
mat3.identity = function(out) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 1;
    out[5] = 0;
    out[6] = 0;
    out[7] = 0;
    out[8] = 1;
    return out;
};

/**
 * Transpose the values of a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the source matrix
 * @returns {mat3} out
 */
mat3.transpose = function(out, a) {
    // If we are transposing ourselves we can skip a few steps but have to cache some values
    if (out === a) {
        var a01 = a[1], a02 = a[2], a12 = a[5];
        out[1] = a[3];
        out[2] = a[6];
        out[3] = a01;
        out[5] = a[7];
        out[6] = a02;
        out[7] = a12;
    } else {
        out[0] = a[0];
        out[1] = a[3];
        out[2] = a[6];
        out[3] = a[1];
        out[4] = a[4];
        out[5] = a[7];
        out[6] = a[2];
        out[7] = a[5];
        out[8] = a[8];
    }
    
    return out;
};

/**
 * Inverts a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the source matrix
 * @returns {mat3} out
 */
mat3.invert = function(out, a) {
    var a00 = a[0], a01 = a[1], a02 = a[2],
        a10 = a[3], a11 = a[4], a12 = a[5],
        a20 = a[6], a21 = a[7], a22 = a[8],

        b01 = a22 * a11 - a12 * a21,
        b11 = -a22 * a10 + a12 * a20,
        b21 = a21 * a10 - a11 * a20,

        // Calculate the determinant
        det = a00 * b01 + a01 * b11 + a02 * b21;

    if (!det) { 
        return null; 
    }
    det = 1.0 / det;

    out[0] = b01 * det;
    out[1] = (-a22 * a01 + a02 * a21) * det;
    out[2] = (a12 * a01 - a02 * a11) * det;
    out[3] = b11 * det;
    out[4] = (a22 * a00 - a02 * a20) * det;
    out[5] = (-a12 * a00 + a02 * a10) * det;
    out[6] = b21 * det;
    out[7] = (-a21 * a00 + a01 * a20) * det;
    out[8] = (a11 * a00 - a01 * a10) * det;
    return out;
};

/**
 * Calculates the adjugate of a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the source matrix
 * @returns {mat3} out
 */
mat3.adjoint = function(out, a) {
    var a00 = a[0], a01 = a[1], a02 = a[2],
        a10 = a[3], a11 = a[4], a12 = a[5],
        a20 = a[6], a21 = a[7], a22 = a[8];

    out[0] = (a11 * a22 - a12 * a21);
    out[1] = (a02 * a21 - a01 * a22);
    out[2] = (a01 * a12 - a02 * a11);
    out[3] = (a12 * a20 - a10 * a22);
    out[4] = (a00 * a22 - a02 * a20);
    out[5] = (a02 * a10 - a00 * a12);
    out[6] = (a10 * a21 - a11 * a20);
    out[7] = (a01 * a20 - a00 * a21);
    out[8] = (a00 * a11 - a01 * a10);
    return out;
};

/**
 * Calculates the determinant of a mat3
 *
 * @param {mat3} a the source matrix
 * @returns {Number} determinant of a
 */
mat3.determinant = function (a) {
    var a00 = a[0], a01 = a[1], a02 = a[2],
        a10 = a[3], a11 = a[4], a12 = a[5],
        a20 = a[6], a21 = a[7], a22 = a[8];

    return a00 * (a22 * a11 - a12 * a21) + a01 * (-a22 * a10 + a12 * a20) + a02 * (a21 * a10 - a11 * a20);
};

/**
 * Multiplies two mat3's
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the first operand
 * @param {mat3} b the second operand
 * @returns {mat3} out
 */
mat3.multiply = function (out, a, b) {
    var a00 = a[0], a01 = a[1], a02 = a[2],
        a10 = a[3], a11 = a[4], a12 = a[5],
        a20 = a[6], a21 = a[7], a22 = a[8],

        b00 = b[0], b01 = b[1], b02 = b[2],
        b10 = b[3], b11 = b[4], b12 = b[5],
        b20 = b[6], b21 = b[7], b22 = b[8];

    out[0] = b00 * a00 + b01 * a10 + b02 * a20;
    out[1] = b00 * a01 + b01 * a11 + b02 * a21;
    out[2] = b00 * a02 + b01 * a12 + b02 * a22;

    out[3] = b10 * a00 + b11 * a10 + b12 * a20;
    out[4] = b10 * a01 + b11 * a11 + b12 * a21;
    out[5] = b10 * a02 + b11 * a12 + b12 * a22;

    out[6] = b20 * a00 + b21 * a10 + b22 * a20;
    out[7] = b20 * a01 + b21 * a11 + b22 * a21;
    out[8] = b20 * a02 + b21 * a12 + b22 * a22;
    return out;
};

/**
 * Alias for {@link mat3.multiply}
 * @function
 */
mat3.mul = mat3.multiply;

/**
 * Translate a mat3 by the given vector
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the matrix to translate
 * @param {vec2} v vector to translate by
 * @returns {mat3} out
 */
mat3.translate = function(out, a, v) {
    var a00 = a[0], a01 = a[1], a02 = a[2],
        a10 = a[3], a11 = a[4], a12 = a[5],
        a20 = a[6], a21 = a[7], a22 = a[8],
        x = v[0], y = v[1];

    out[0] = a00;
    out[1] = a01;
    out[2] = a02;

    out[3] = a10;
    out[4] = a11;
    out[5] = a12;

    out[6] = x * a00 + y * a10 + a20;
    out[7] = x * a01 + y * a11 + a21;
    out[8] = x * a02 + y * a12 + a22;
    return out;
};

/**
 * Rotates a mat3 by the given angle
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat3} out
 */
mat3.rotate = function (out, a, rad) {
    var a00 = a[0], a01 = a[1], a02 = a[2],
        a10 = a[3], a11 = a[4], a12 = a[5],
        a20 = a[6], a21 = a[7], a22 = a[8],

        s = Math.sin(rad),
        c = Math.cos(rad);

    out[0] = c * a00 + s * a10;
    out[1] = c * a01 + s * a11;
    out[2] = c * a02 + s * a12;

    out[3] = c * a10 - s * a00;
    out[4] = c * a11 - s * a01;
    out[5] = c * a12 - s * a02;

    out[6] = a20;
    out[7] = a21;
    out[8] = a22;
    return out;
};

/**
 * Scales the mat3 by the dimensions in the given vec2
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the matrix to rotate
 * @param {vec2} v the vec2 to scale the matrix by
 * @returns {mat3} out
 **/
mat3.scale = function(out, a, v) {
    var x = v[0], y = v[1];

    out[0] = x * a[0];
    out[1] = x * a[1];
    out[2] = x * a[2];

    out[3] = y * a[3];
    out[4] = y * a[4];
    out[5] = y * a[5];

    out[6] = a[6];
    out[7] = a[7];
    out[8] = a[8];
    return out;
};

/**
 * Creates a matrix from a vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat3.identity(dest);
 *     mat3.translate(dest, dest, vec);
 *
 * @param {mat3} out mat3 receiving operation result
 * @param {vec2} v Translation vector
 * @returns {mat3} out
 */
mat3.fromTranslation = function(out, v) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 1;
    out[5] = 0;
    out[6] = v[0];
    out[7] = v[1];
    out[8] = 1;
    return out;
}

/**
 * Creates a matrix from a given angle
 * This is equivalent to (but much faster than):
 *
 *     mat3.identity(dest);
 *     mat3.rotate(dest, dest, rad);
 *
 * @param {mat3} out mat3 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat3} out
 */
mat3.fromRotation = function(out, rad) {
    var s = Math.sin(rad), c = Math.cos(rad);

    out[0] = c;
    out[1] = s;
    out[2] = 0;

    out[3] = -s;
    out[4] = c;
    out[5] = 0;

    out[6] = 0;
    out[7] = 0;
    out[8] = 1;
    return out;
}

/**
 * Creates a matrix from a vector scaling
 * This is equivalent to (but much faster than):
 *
 *     mat3.identity(dest);
 *     mat3.scale(dest, dest, vec);
 *
 * @param {mat3} out mat3 receiving operation result
 * @param {vec2} v Scaling vector
 * @returns {mat3} out
 */
mat3.fromScaling = function(out, v) {
    out[0] = v[0];
    out[1] = 0;
    out[2] = 0;

    out[3] = 0;
    out[4] = v[1];
    out[5] = 0;

    out[6] = 0;
    out[7] = 0;
    out[8] = 1;
    return out;
}

/**
 * Copies the values from a mat2d into a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {mat2d} a the matrix to copy
 * @returns {mat3} out
 **/
mat3.fromMat2d = function(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = 0;

    out[3] = a[2];
    out[4] = a[3];
    out[5] = 0;

    out[6] = a[4];
    out[7] = a[5];
    out[8] = 1;
    return out;
};

/**
* Calculates a 3x3 matrix from the given quaternion
*
* @param {mat3} out mat3 receiving operation result
* @param {quat} q Quaternion to create matrix from
*
* @returns {mat3} out
*/
mat3.fromQuat = function (out, q) {
    var x = q[0], y = q[1], z = q[2], w = q[3],
        x2 = x + x,
        y2 = y + y,
        z2 = z + z,

        xx = x * x2,
        yx = y * x2,
        yy = y * y2,
        zx = z * x2,
        zy = z * y2,
        zz = z * z2,
        wx = w * x2,
        wy = w * y2,
        wz = w * z2;

    out[0] = 1 - yy - zz;
    out[3] = yx - wz;
    out[6] = zx + wy;

    out[1] = yx + wz;
    out[4] = 1 - xx - zz;
    out[7] = zy - wx;

    out[2] = zx - wy;
    out[5] = zy + wx;
    out[8] = 1 - xx - yy;

    return out;
};

/**
* Calculates a 3x3 normal matrix (transpose inverse) from the 4x4 matrix
*
* @param {mat3} out mat3 receiving operation result
* @param {mat4} a Mat4 to derive the normal matrix from
*
* @returns {mat3} out
*/
mat3.normalFromMat4 = function (out, a) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15],

        b00 = a00 * a11 - a01 * a10,
        b01 = a00 * a12 - a02 * a10,
        b02 = a00 * a13 - a03 * a10,
        b03 = a01 * a12 - a02 * a11,
        b04 = a01 * a13 - a03 * a11,
        b05 = a02 * a13 - a03 * a12,
        b06 = a20 * a31 - a21 * a30,
        b07 = a20 * a32 - a22 * a30,
        b08 = a20 * a33 - a23 * a30,
        b09 = a21 * a32 - a22 * a31,
        b10 = a21 * a33 - a23 * a31,
        b11 = a22 * a33 - a23 * a32,

        // Calculate the determinant
        det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

    if (!det) { 
        return null; 
    }
    det = 1.0 / det;

    out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
    out[1] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
    out[2] = (a10 * b10 - a11 * b08 + a13 * b06) * det;

    out[3] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
    out[4] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
    out[5] = (a01 * b08 - a00 * b10 - a03 * b06) * det;

    out[6] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
    out[7] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
    out[8] = (a30 * b04 - a31 * b02 + a33 * b00) * det;

    return out;
};

/**
 * Returns a string representation of a mat3
 *
 * @param {mat3} mat matrix to represent as a string
 * @returns {String} string representation of the matrix
 */
mat3.str = function (a) {
    return 'mat3(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + 
                    a[3] + ', ' + a[4] + ', ' + a[5] + ', ' + 
                    a[6] + ', ' + a[7] + ', ' + a[8] + ')';
};

/**
 * Returns Frobenius norm of a mat3
 *
 * @param {mat3} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */
mat3.frob = function (a) {
    return(Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2) + Math.pow(a[4], 2) + Math.pow(a[5], 2) + Math.pow(a[6], 2) + Math.pow(a[7], 2) + Math.pow(a[8], 2)))
};

/**
 * Adds two mat3's
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the first operand
 * @param {mat3} b the second operand
 * @returns {mat3} out
 */
mat3.add = function(out, a, b) {
    out[0] = a[0] + b[0];
    out[1] = a[1] + b[1];
    out[2] = a[2] + b[2];
    out[3] = a[3] + b[3];
    out[4] = a[4] + b[4];
    out[5] = a[5] + b[5];
    out[6] = a[6] + b[6];
    out[7] = a[7] + b[7];
    out[8] = a[8] + b[8];
    return out;
};

/**
 * Subtracts matrix b from matrix a
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the first operand
 * @param {mat3} b the second operand
 * @returns {mat3} out
 */
mat3.subtract = function(out, a, b) {
    out[0] = a[0] - b[0];
    out[1] = a[1] - b[1];
    out[2] = a[2] - b[2];
    out[3] = a[3] - b[3];
    out[4] = a[4] - b[4];
    out[5] = a[5] - b[5];
    out[6] = a[6] - b[6];
    out[7] = a[7] - b[7];
    out[8] = a[8] - b[8];
    return out;
};

/**
 * Alias for {@link mat3.subtract}
 * @function
 */
mat3.sub = mat3.subtract;

/**
 * Multiply each element of the matrix by a scalar.
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the matrix to scale
 * @param {Number} b amount to scale the matrix's elements by
 * @returns {mat3} out
 */
mat3.multiplyScalar = function(out, a, b) {
    out[0] = a[0] * b;
    out[1] = a[1] * b;
    out[2] = a[2] * b;
    out[3] = a[3] * b;
    out[4] = a[4] * b;
    out[5] = a[5] * b;
    out[6] = a[6] * b;
    out[7] = a[7] * b;
    out[8] = a[8] * b;
    return out;
};

/**
 * Adds two mat3's after multiplying each element of the second operand by a scalar value.
 *
 * @param {mat3} out the receiving vector
 * @param {mat3} a the first operand
 * @param {mat3} b the second operand
 * @param {Number} scale the amount to scale b's elements by before adding
 * @returns {mat3} out
 */
mat3.multiplyScalarAndAdd = function(out, a, b, scale) {
    out[0] = a[0] + (b[0] * scale);
    out[1] = a[1] + (b[1] * scale);
    out[2] = a[2] + (b[2] * scale);
    out[3] = a[3] + (b[3] * scale);
    out[4] = a[4] + (b[4] * scale);
    out[5] = a[5] + (b[5] * scale);
    out[6] = a[6] + (b[6] * scale);
    out[7] = a[7] + (b[7] * scale);
    out[8] = a[8] + (b[8] * scale);
    return out;
};

/*
 * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
 *
 * @param {mat3} a The first matrix.
 * @param {mat3} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */
mat3.exactEquals = function (a, b) {
    return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && 
           a[3] === b[3] && a[4] === b[4] && a[5] === b[5] &&
           a[6] === b[6] && a[7] === b[7] && a[8] === b[8];
};

/**
 * Returns whether or not the matrices have approximately the same elements in the same position.
 *
 * @param {mat3} a The first matrix.
 * @param {mat3} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */
mat3.equals = function (a, b) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5], a6 = a[6], a7 = a[7], a8 = a[8];
    var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3], b4 = b[4], b5 = b[5], b6 = a[6], b7 = b[7], b8 = b[8];
    return (Math.abs(a0 - b0) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a0), Math.abs(b0)) &&
            Math.abs(a1 - b1) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a1), Math.abs(b1)) &&
            Math.abs(a2 - b2) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a2), Math.abs(b2)) &&
            Math.abs(a3 - b3) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a3), Math.abs(b3)) &&
            Math.abs(a4 - b4) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a4), Math.abs(b4)) &&
            Math.abs(a5 - b5) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a5), Math.abs(b5)) &&
            Math.abs(a6 - b6) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a6), Math.abs(b6)) &&
            Math.abs(a7 - b7) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a7), Math.abs(b7)) &&
            Math.abs(a8 - b8) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a8), Math.abs(b8)));
};


module.exports = mat3;

},{"./common.js":125}],129:[function(require,module,exports){
/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE. */

var glMatrix = require("./common.js");

/**
 * @class 4x4 Matrix
 * @name mat4
 */
var mat4 = {
  scalar: {},
  SIMD: {},
};

/**
 * Creates a new identity mat4
 *
 * @returns {mat4} a new 4x4 matrix
 */
mat4.create = function() {
    var out = new glMatrix.ARRAY_TYPE(16);
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = 1;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 1;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
};

/**
 * Creates a new mat4 initialized with values from an existing matrix
 *
 * @param {mat4} a matrix to clone
 * @returns {mat4} a new 4x4 matrix
 */
mat4.clone = function(a) {
    var out = new glMatrix.ARRAY_TYPE(16);
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[8] = a[8];
    out[9] = a[9];
    out[10] = a[10];
    out[11] = a[11];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
    return out;
};

/**
 * Copy the values from one mat4 to another
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
mat4.copy = function(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[8] = a[8];
    out[9] = a[9];
    out[10] = a[10];
    out[11] = a[11];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
    return out;
};

/**
 * Create a new mat4 with the given values
 *
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m02 Component in column 0, row 2 position (index 2)
 * @param {Number} m03 Component in column 0, row 3 position (index 3)
 * @param {Number} m10 Component in column 1, row 0 position (index 4)
 * @param {Number} m11 Component in column 1, row 1 position (index 5)
 * @param {Number} m12 Component in column 1, row 2 position (index 6)
 * @param {Number} m13 Component in column 1, row 3 position (index 7)
 * @param {Number} m20 Component in column 2, row 0 position (index 8)
 * @param {Number} m21 Component in column 2, row 1 position (index 9)
 * @param {Number} m22 Component in column 2, row 2 position (index 10)
 * @param {Number} m23 Component in column 2, row 3 position (index 11)
 * @param {Number} m30 Component in column 3, row 0 position (index 12)
 * @param {Number} m31 Component in column 3, row 1 position (index 13)
 * @param {Number} m32 Component in column 3, row 2 position (index 14)
 * @param {Number} m33 Component in column 3, row 3 position (index 15)
 * @returns {mat4} A new mat4
 */
mat4.fromValues = function(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
    var out = new glMatrix.ARRAY_TYPE(16);
    out[0] = m00;
    out[1] = m01;
    out[2] = m02;
    out[3] = m03;
    out[4] = m10;
    out[5] = m11;
    out[6] = m12;
    out[7] = m13;
    out[8] = m20;
    out[9] = m21;
    out[10] = m22;
    out[11] = m23;
    out[12] = m30;
    out[13] = m31;
    out[14] = m32;
    out[15] = m33;
    return out;
};

/**
 * Set the components of a mat4 to the given values
 *
 * @param {mat4} out the receiving matrix
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m02 Component in column 0, row 2 position (index 2)
 * @param {Number} m03 Component in column 0, row 3 position (index 3)
 * @param {Number} m10 Component in column 1, row 0 position (index 4)
 * @param {Number} m11 Component in column 1, row 1 position (index 5)
 * @param {Number} m12 Component in column 1, row 2 position (index 6)
 * @param {Number} m13 Component in column 1, row 3 position (index 7)
 * @param {Number} m20 Component in column 2, row 0 position (index 8)
 * @param {Number} m21 Component in column 2, row 1 position (index 9)
 * @param {Number} m22 Component in column 2, row 2 position (index 10)
 * @param {Number} m23 Component in column 2, row 3 position (index 11)
 * @param {Number} m30 Component in column 3, row 0 position (index 12)
 * @param {Number} m31 Component in column 3, row 1 position (index 13)
 * @param {Number} m32 Component in column 3, row 2 position (index 14)
 * @param {Number} m33 Component in column 3, row 3 position (index 15)
 * @returns {mat4} out
 */
mat4.set = function(out, m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
    out[0] = m00;
    out[1] = m01;
    out[2] = m02;
    out[3] = m03;
    out[4] = m10;
    out[5] = m11;
    out[6] = m12;
    out[7] = m13;
    out[8] = m20;
    out[9] = m21;
    out[10] = m22;
    out[11] = m23;
    out[12] = m30;
    out[13] = m31;
    out[14] = m32;
    out[15] = m33;
    return out;
};


/**
 * Set a mat4 to the identity matrix
 *
 * @param {mat4} out the receiving matrix
 * @returns {mat4} out
 */
mat4.identity = function(out) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = 1;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 1;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
};

/**
 * Transpose the values of a mat4 not using SIMD
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
mat4.scalar.transpose = function(out, a) {
    // If we are transposing ourselves we can skip a few steps but have to cache some values
    if (out === a) {
        var a01 = a[1], a02 = a[2], a03 = a[3],
            a12 = a[6], a13 = a[7],
            a23 = a[11];

        out[1] = a[4];
        out[2] = a[8];
        out[3] = a[12];
        out[4] = a01;
        out[6] = a[9];
        out[7] = a[13];
        out[8] = a02;
        out[9] = a12;
        out[11] = a[14];
        out[12] = a03;
        out[13] = a13;
        out[14] = a23;
    } else {
        out[0] = a[0];
        out[1] = a[4];
        out[2] = a[8];
        out[3] = a[12];
        out[4] = a[1];
        out[5] = a[5];
        out[6] = a[9];
        out[7] = a[13];
        out[8] = a[2];
        out[9] = a[6];
        out[10] = a[10];
        out[11] = a[14];
        out[12] = a[3];
        out[13] = a[7];
        out[14] = a[11];
        out[15] = a[15];
    }

    return out;
};

/**
 * Transpose the values of a mat4 using SIMD
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
mat4.SIMD.transpose = function(out, a) {
    var a0, a1, a2, a3,
        tmp01, tmp23,
        out0, out1, out2, out3;

    a0 = SIMD.Float32x4.load(a, 0);
    a1 = SIMD.Float32x4.load(a, 4);
    a2 = SIMD.Float32x4.load(a, 8);
    a3 = SIMD.Float32x4.load(a, 12);

    tmp01 = SIMD.Float32x4.shuffle(a0, a1, 0, 1, 4, 5);
    tmp23 = SIMD.Float32x4.shuffle(a2, a3, 0, 1, 4, 5);
    out0  = SIMD.Float32x4.shuffle(tmp01, tmp23, 0, 2, 4, 6);
    out1  = SIMD.Float32x4.shuffle(tmp01, tmp23, 1, 3, 5, 7);
    SIMD.Float32x4.store(out, 0,  out0);
    SIMD.Float32x4.store(out, 4,  out1);

    tmp01 = SIMD.Float32x4.shuffle(a0, a1, 2, 3, 6, 7);
    tmp23 = SIMD.Float32x4.shuffle(a2, a3, 2, 3, 6, 7);
    out2  = SIMD.Float32x4.shuffle(tmp01, tmp23, 0, 2, 4, 6);
    out3  = SIMD.Float32x4.shuffle(tmp01, tmp23, 1, 3, 5, 7);
    SIMD.Float32x4.store(out, 8,  out2);
    SIMD.Float32x4.store(out, 12, out3);

    return out;
};

/**
 * Transpse a mat4 using SIMD if available and enabled
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
mat4.transpose = glMatrix.USE_SIMD ? mat4.SIMD.transpose : mat4.scalar.transpose;

/**
 * Inverts a mat4 not using SIMD
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
mat4.scalar.invert = function(out, a) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15],

        b00 = a00 * a11 - a01 * a10,
        b01 = a00 * a12 - a02 * a10,
        b02 = a00 * a13 - a03 * a10,
        b03 = a01 * a12 - a02 * a11,
        b04 = a01 * a13 - a03 * a11,
        b05 = a02 * a13 - a03 * a12,
        b06 = a20 * a31 - a21 * a30,
        b07 = a20 * a32 - a22 * a30,
        b08 = a20 * a33 - a23 * a30,
        b09 = a21 * a32 - a22 * a31,
        b10 = a21 * a33 - a23 * a31,
        b11 = a22 * a33 - a23 * a32,

        // Calculate the determinant
        det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

    if (!det) {
        return null;
    }
    det = 1.0 / det;

    out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
    out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
    out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
    out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
    out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
    out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
    out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
    out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
    out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
    out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
    out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
    out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
    out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
    out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
    out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
    out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;

    return out;
};

/**
 * Inverts a mat4 using SIMD
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
mat4.SIMD.invert = function(out, a) {
  var row0, row1, row2, row3,
      tmp1,
      minor0, minor1, minor2, minor3,
      det,
      a0 = SIMD.Float32x4.load(a, 0),
      a1 = SIMD.Float32x4.load(a, 4),
      a2 = SIMD.Float32x4.load(a, 8),
      a3 = SIMD.Float32x4.load(a, 12);

  // Compute matrix adjugate
  tmp1 = SIMD.Float32x4.shuffle(a0, a1, 0, 1, 4, 5);
  row1 = SIMD.Float32x4.shuffle(a2, a3, 0, 1, 4, 5);
  row0 = SIMD.Float32x4.shuffle(tmp1, row1, 0, 2, 4, 6);
  row1 = SIMD.Float32x4.shuffle(row1, tmp1, 1, 3, 5, 7);
  tmp1 = SIMD.Float32x4.shuffle(a0, a1, 2, 3, 6, 7);
  row3 = SIMD.Float32x4.shuffle(a2, a3, 2, 3, 6, 7);
  row2 = SIMD.Float32x4.shuffle(tmp1, row3, 0, 2, 4, 6);
  row3 = SIMD.Float32x4.shuffle(row3, tmp1, 1, 3, 5, 7);

  tmp1   = SIMD.Float32x4.mul(row2, row3);
  tmp1   = SIMD.Float32x4.swizzle(tmp1, 1, 0, 3, 2);
  minor0 = SIMD.Float32x4.mul(row1, tmp1);
  minor1 = SIMD.Float32x4.mul(row0, tmp1);
  tmp1   = SIMD.Float32x4.swizzle(tmp1, 2, 3, 0, 1);
  minor0 = SIMD.Float32x4.sub(SIMD.Float32x4.mul(row1, tmp1), minor0);
  minor1 = SIMD.Float32x4.sub(SIMD.Float32x4.mul(row0, tmp1), minor1);
  minor1 = SIMD.Float32x4.swizzle(minor1, 2, 3, 0, 1);

  tmp1   = SIMD.Float32x4.mul(row1, row2);
  tmp1   = SIMD.Float32x4.swizzle(tmp1, 1, 0, 3, 2);
  minor0 = SIMD.Float32x4.add(SIMD.Float32x4.mul(row3, tmp1), minor0);
  minor3 = SIMD.Float32x4.mul(row0, tmp1);
  tmp1   = SIMD.Float32x4.swizzle(tmp1, 2, 3, 0, 1);
  minor0 = SIMD.Float32x4.sub(minor0, SIMD.Float32x4.mul(row3, tmp1));
  minor3 = SIMD.Float32x4.sub(SIMD.Float32x4.mul(row0, tmp1), minor3);
  minor3 = SIMD.Float32x4.swizzle(minor3, 2, 3, 0, 1);

  tmp1   = SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(row1, 2, 3, 0, 1), row3);
  tmp1   = SIMD.Float32x4.swizzle(tmp1, 1, 0, 3, 2);
  row2   = SIMD.Float32x4.swizzle(row2, 2, 3, 0, 1);
  minor0 = SIMD.Float32x4.add(SIMD.Float32x4.mul(row2, tmp1), minor0);
  minor2 = SIMD.Float32x4.mul(row0, tmp1);
  tmp1   = SIMD.Float32x4.swizzle(tmp1, 2, 3, 0, 1);
  minor0 = SIMD.Float32x4.sub(minor0, SIMD.Float32x4.mul(row2, tmp1));
  minor2 = SIMD.Float32x4.sub(SIMD.Float32x4.mul(row0, tmp1), minor2);
  minor2 = SIMD.Float32x4.swizzle(minor2, 2, 3, 0, 1);

  tmp1   = SIMD.Float32x4.mul(row0, row1);
  tmp1   = SIMD.Float32x4.swizzle(tmp1, 1, 0, 3, 2);
  minor2 = SIMD.Float32x4.add(SIMD.Float32x4.mul(row3, tmp1), minor2);
  minor3 = SIMD.Float32x4.sub(SIMD.Float32x4.mul(row2, tmp1), minor3);
  tmp1   = SIMD.Float32x4.swizzle(tmp1, 2, 3, 0, 1);
  minor2 = SIMD.Float32x4.sub(SIMD.Float32x4.mul(row3, tmp1), minor2);
  minor3 = SIMD.Float32x4.sub(minor3, SIMD.Float32x4.mul(row2, tmp1));

  tmp1   = SIMD.Float32x4.mul(row0, row3);
  tmp1   = SIMD.Float32x4.swizzle(tmp1, 1, 0, 3, 2);
  minor1 = SIMD.Float32x4.sub(minor1, SIMD.Float32x4.mul(row2, tmp1));
  minor2 = SIMD.Float32x4.add(SIMD.Float32x4.mul(row1, tmp1), minor2);
  tmp1   = SIMD.Float32x4.swizzle(tmp1, 2, 3, 0, 1);
  minor1 = SIMD.Float32x4.add(SIMD.Float32x4.mul(row2, tmp1), minor1);
  minor2 = SIMD.Float32x4.sub(minor2, SIMD.Float32x4.mul(row1, tmp1));

  tmp1   = SIMD.Float32x4.mul(row0, row2);
  tmp1   = SIMD.Float32x4.swizzle(tmp1, 1, 0, 3, 2);
  minor1 = SIMD.Float32x4.add(SIMD.Float32x4.mul(row3, tmp1), minor1);
  minor3 = SIMD.Float32x4.sub(minor3, SIMD.Float32x4.mul(row1, tmp1));
  tmp1   = SIMD.Float32x4.swizzle(tmp1, 2, 3, 0, 1);
  minor1 = SIMD.Float32x4.sub(minor1, SIMD.Float32x4.mul(row3, tmp1));
  minor3 = SIMD.Float32x4.add(SIMD.Float32x4.mul(row1, tmp1), minor3);

  // Compute matrix determinant
  det   = SIMD.Float32x4.mul(row0, minor0);
  det   = SIMD.Float32x4.add(SIMD.Float32x4.swizzle(det, 2, 3, 0, 1), det);
  det   = SIMD.Float32x4.add(SIMD.Float32x4.swizzle(det, 1, 0, 3, 2), det);
  tmp1  = SIMD.Float32x4.reciprocalApproximation(det);
  det   = SIMD.Float32x4.sub(
               SIMD.Float32x4.add(tmp1, tmp1),
               SIMD.Float32x4.mul(det, SIMD.Float32x4.mul(tmp1, tmp1)));
  det   = SIMD.Float32x4.swizzle(det, 0, 0, 0, 0);
  if (!det) {
      return null;
  }

  // Compute matrix inverse
  SIMD.Float32x4.store(out, 0,  SIMD.Float32x4.mul(det, minor0));
  SIMD.Float32x4.store(out, 4,  SIMD.Float32x4.mul(det, minor1));
  SIMD.Float32x4.store(out, 8,  SIMD.Float32x4.mul(det, minor2));
  SIMD.Float32x4.store(out, 12, SIMD.Float32x4.mul(det, minor3));
  return out;
}

/**
 * Inverts a mat4 using SIMD if available and enabled
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
mat4.invert = glMatrix.USE_SIMD ? mat4.SIMD.invert : mat4.scalar.invert;

/**
 * Calculates the adjugate of a mat4 not using SIMD
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
mat4.scalar.adjoint = function(out, a) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];

    out[0]  =  (a11 * (a22 * a33 - a23 * a32) - a21 * (a12 * a33 - a13 * a32) + a31 * (a12 * a23 - a13 * a22));
    out[1]  = -(a01 * (a22 * a33 - a23 * a32) - a21 * (a02 * a33 - a03 * a32) + a31 * (a02 * a23 - a03 * a22));
    out[2]  =  (a01 * (a12 * a33 - a13 * a32) - a11 * (a02 * a33 - a03 * a32) + a31 * (a02 * a13 - a03 * a12));
    out[3]  = -(a01 * (a12 * a23 - a13 * a22) - a11 * (a02 * a23 - a03 * a22) + a21 * (a02 * a13 - a03 * a12));
    out[4]  = -(a10 * (a22 * a33 - a23 * a32) - a20 * (a12 * a33 - a13 * a32) + a30 * (a12 * a23 - a13 * a22));
    out[5]  =  (a00 * (a22 * a33 - a23 * a32) - a20 * (a02 * a33 - a03 * a32) + a30 * (a02 * a23 - a03 * a22));
    out[6]  = -(a00 * (a12 * a33 - a13 * a32) - a10 * (a02 * a33 - a03 * a32) + a30 * (a02 * a13 - a03 * a12));
    out[7]  =  (a00 * (a12 * a23 - a13 * a22) - a10 * (a02 * a23 - a03 * a22) + a20 * (a02 * a13 - a03 * a12));
    out[8]  =  (a10 * (a21 * a33 - a23 * a31) - a20 * (a11 * a33 - a13 * a31) + a30 * (a11 * a23 - a13 * a21));
    out[9]  = -(a00 * (a21 * a33 - a23 * a31) - a20 * (a01 * a33 - a03 * a31) + a30 * (a01 * a23 - a03 * a21));
    out[10] =  (a00 * (a11 * a33 - a13 * a31) - a10 * (a01 * a33 - a03 * a31) + a30 * (a01 * a13 - a03 * a11));
    out[11] = -(a00 * (a11 * a23 - a13 * a21) - a10 * (a01 * a23 - a03 * a21) + a20 * (a01 * a13 - a03 * a11));
    out[12] = -(a10 * (a21 * a32 - a22 * a31) - a20 * (a11 * a32 - a12 * a31) + a30 * (a11 * a22 - a12 * a21));
    out[13] =  (a00 * (a21 * a32 - a22 * a31) - a20 * (a01 * a32 - a02 * a31) + a30 * (a01 * a22 - a02 * a21));
    out[14] = -(a00 * (a11 * a32 - a12 * a31) - a10 * (a01 * a32 - a02 * a31) + a30 * (a01 * a12 - a02 * a11));
    out[15] =  (a00 * (a11 * a22 - a12 * a21) - a10 * (a01 * a22 - a02 * a21) + a20 * (a01 * a12 - a02 * a11));
    return out;
};

/**
 * Calculates the adjugate of a mat4 using SIMD
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
mat4.SIMD.adjoint = function(out, a) {
  var a0, a1, a2, a3;
  var row0, row1, row2, row3;
  var tmp1;
  var minor0, minor1, minor2, minor3;

  var a0 = SIMD.Float32x4.load(a, 0);
  var a1 = SIMD.Float32x4.load(a, 4);
  var a2 = SIMD.Float32x4.load(a, 8);
  var a3 = SIMD.Float32x4.load(a, 12);

  // Transpose the source matrix.  Sort of.  Not a true transpose operation
  tmp1 = SIMD.Float32x4.shuffle(a0, a1, 0, 1, 4, 5);
  row1 = SIMD.Float32x4.shuffle(a2, a3, 0, 1, 4, 5);
  row0 = SIMD.Float32x4.shuffle(tmp1, row1, 0, 2, 4, 6);
  row1 = SIMD.Float32x4.shuffle(row1, tmp1, 1, 3, 5, 7);

  tmp1 = SIMD.Float32x4.shuffle(a0, a1, 2, 3, 6, 7);
  row3 = SIMD.Float32x4.shuffle(a2, a3, 2, 3, 6, 7);
  row2 = SIMD.Float32x4.shuffle(tmp1, row3, 0, 2, 4, 6);
  row3 = SIMD.Float32x4.shuffle(row3, tmp1, 1, 3, 5, 7);

  tmp1   = SIMD.Float32x4.mul(row2, row3);
  tmp1   = SIMD.Float32x4.swizzle(tmp1, 1, 0, 3, 2);
  minor0 = SIMD.Float32x4.mul(row1, tmp1);
  minor1 = SIMD.Float32x4.mul(row0, tmp1);
  tmp1   = SIMD.Float32x4.swizzle(tmp1, 2, 3, 0, 1);
  minor0 = SIMD.Float32x4.sub(SIMD.Float32x4.mul(row1, tmp1), minor0);
  minor1 = SIMD.Float32x4.sub(SIMD.Float32x4.mul(row0, tmp1), minor1);
  minor1 = SIMD.Float32x4.swizzle(minor1, 2, 3, 0, 1);

  tmp1   = SIMD.Float32x4.mul(row1, row2);
  tmp1   = SIMD.Float32x4.swizzle(tmp1, 1, 0, 3, 2);
  minor0 = SIMD.Float32x4.add(SIMD.Float32x4.mul(row3, tmp1), minor0);
  minor3 = SIMD.Float32x4.mul(row0, tmp1);
  tmp1   = SIMD.Float32x4.swizzle(tmp1, 2, 3, 0, 1);
  minor0 = SIMD.Float32x4.sub(minor0, SIMD.Float32x4.mul(row3, tmp1));
  minor3 = SIMD.Float32x4.sub(SIMD.Float32x4.mul(row0, tmp1), minor3);
  minor3 = SIMD.Float32x4.swizzle(minor3, 2, 3, 0, 1);

  tmp1   = SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(row1, 2, 3, 0, 1), row3);
  tmp1   = SIMD.Float32x4.swizzle(tmp1, 1, 0, 3, 2);
  row2   = SIMD.Float32x4.swizzle(row2, 2, 3, 0, 1);
  minor0 = SIMD.Float32x4.add(SIMD.Float32x4.mul(row2, tmp1), minor0);
  minor2 = SIMD.Float32x4.mul(row0, tmp1);
  tmp1   = SIMD.Float32x4.swizzle(tmp1, 2, 3, 0, 1);
  minor0 = SIMD.Float32x4.sub(minor0, SIMD.Float32x4.mul(row2, tmp1));
  minor2 = SIMD.Float32x4.sub(SIMD.Float32x4.mul(row0, tmp1), minor2);
  minor2 = SIMD.Float32x4.swizzle(minor2, 2, 3, 0, 1);

  tmp1   = SIMD.Float32x4.mul(row0, row1);
  tmp1   = SIMD.Float32x4.swizzle(tmp1, 1, 0, 3, 2);
  minor2 = SIMD.Float32x4.add(SIMD.Float32x4.mul(row3, tmp1), minor2);
  minor3 = SIMD.Float32x4.sub(SIMD.Float32x4.mul(row2, tmp1), minor3);
  tmp1   = SIMD.Float32x4.swizzle(tmp1, 2, 3, 0, 1);
  minor2 = SIMD.Float32x4.sub(SIMD.Float32x4.mul(row3, tmp1), minor2);
  minor3 = SIMD.Float32x4.sub(minor3, SIMD.Float32x4.mul(row2, tmp1));

  tmp1   = SIMD.Float32x4.mul(row0, row3);
  tmp1   = SIMD.Float32x4.swizzle(tmp1, 1, 0, 3, 2);
  minor1 = SIMD.Float32x4.sub(minor1, SIMD.Float32x4.mul(row2, tmp1));
  minor2 = SIMD.Float32x4.add(SIMD.Float32x4.mul(row1, tmp1), minor2);
  tmp1   = SIMD.Float32x4.swizzle(tmp1, 2, 3, 0, 1);
  minor1 = SIMD.Float32x4.add(SIMD.Float32x4.mul(row2, tmp1), minor1);
  minor2 = SIMD.Float32x4.sub(minor2, SIMD.Float32x4.mul(row1, tmp1));

  tmp1   = SIMD.Float32x4.mul(row0, row2);
  tmp1   = SIMD.Float32x4.swizzle(tmp1, 1, 0, 3, 2);
  minor1 = SIMD.Float32x4.add(SIMD.Float32x4.mul(row3, tmp1), minor1);
  minor3 = SIMD.Float32x4.sub(minor3, SIMD.Float32x4.mul(row1, tmp1));
  tmp1   = SIMD.Float32x4.swizzle(tmp1, 2, 3, 0, 1);
  minor1 = SIMD.Float32x4.sub(minor1, SIMD.Float32x4.mul(row3, tmp1));
  minor3 = SIMD.Float32x4.add(SIMD.Float32x4.mul(row1, tmp1), minor3);

  SIMD.Float32x4.store(out, 0,  minor0);
  SIMD.Float32x4.store(out, 4,  minor1);
  SIMD.Float32x4.store(out, 8,  minor2);
  SIMD.Float32x4.store(out, 12, minor3);
  return out;
};

/**
 * Calculates the adjugate of a mat4 using SIMD if available and enabled
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
 mat4.adjoint = glMatrix.USE_SIMD ? mat4.SIMD.adjoint : mat4.scalar.adjoint;

/**
 * Calculates the determinant of a mat4
 *
 * @param {mat4} a the source matrix
 * @returns {Number} determinant of a
 */
mat4.determinant = function (a) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15],

        b00 = a00 * a11 - a01 * a10,
        b01 = a00 * a12 - a02 * a10,
        b02 = a00 * a13 - a03 * a10,
        b03 = a01 * a12 - a02 * a11,
        b04 = a01 * a13 - a03 * a11,
        b05 = a02 * a13 - a03 * a12,
        b06 = a20 * a31 - a21 * a30,
        b07 = a20 * a32 - a22 * a30,
        b08 = a20 * a33 - a23 * a30,
        b09 = a21 * a32 - a22 * a31,
        b10 = a21 * a33 - a23 * a31,
        b11 = a22 * a33 - a23 * a32;

    // Calculate the determinant
    return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
};

/**
 * Multiplies two mat4's explicitly using SIMD
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the first operand, must be a Float32Array
 * @param {mat4} b the second operand, must be a Float32Array
 * @returns {mat4} out
 */
mat4.SIMD.multiply = function (out, a, b) {
    var a0 = SIMD.Float32x4.load(a, 0);
    var a1 = SIMD.Float32x4.load(a, 4);
    var a2 = SIMD.Float32x4.load(a, 8);
    var a3 = SIMD.Float32x4.load(a, 12);

    var b0 = SIMD.Float32x4.load(b, 0);
    var out0 = SIMD.Float32x4.add(
                   SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b0, 0, 0, 0, 0), a0),
                   SIMD.Float32x4.add(
                       SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b0, 1, 1, 1, 1), a1),
                       SIMD.Float32x4.add(
                           SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b0, 2, 2, 2, 2), a2),
                           SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b0, 3, 3, 3, 3), a3))));
    SIMD.Float32x4.store(out, 0, out0);

    var b1 = SIMD.Float32x4.load(b, 4);
    var out1 = SIMD.Float32x4.add(
                   SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b1, 0, 0, 0, 0), a0),
                   SIMD.Float32x4.add(
                       SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b1, 1, 1, 1, 1), a1),
                       SIMD.Float32x4.add(
                           SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b1, 2, 2, 2, 2), a2),
                           SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b1, 3, 3, 3, 3), a3))));
    SIMD.Float32x4.store(out, 4, out1);

    var b2 = SIMD.Float32x4.load(b, 8);
    var out2 = SIMD.Float32x4.add(
                   SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b2, 0, 0, 0, 0), a0),
                   SIMD.Float32x4.add(
                       SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b2, 1, 1, 1, 1), a1),
                       SIMD.Float32x4.add(
                               SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b2, 2, 2, 2, 2), a2),
                               SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b2, 3, 3, 3, 3), a3))));
    SIMD.Float32x4.store(out, 8, out2);

    var b3 = SIMD.Float32x4.load(b, 12);
    var out3 = SIMD.Float32x4.add(
                   SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b3, 0, 0, 0, 0), a0),
                   SIMD.Float32x4.add(
                        SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b3, 1, 1, 1, 1), a1),
                        SIMD.Float32x4.add(
                            SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b3, 2, 2, 2, 2), a2),
                            SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b3, 3, 3, 3, 3), a3))));
    SIMD.Float32x4.store(out, 12, out3);

    return out;
};

/**
 * Multiplies two mat4's explicitly not using SIMD
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the first operand
 * @param {mat4} b the second operand
 * @returns {mat4} out
 */
mat4.scalar.multiply = function (out, a, b) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];

    // Cache only the current line of the second matrix
    var b0  = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
    out[0] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
    out[1] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
    out[2] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
    out[3] = b0*a03 + b1*a13 + b2*a23 + b3*a33;

    b0 = b[4]; b1 = b[5]; b2 = b[6]; b3 = b[7];
    out[4] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
    out[5] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
    out[6] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
    out[7] = b0*a03 + b1*a13 + b2*a23 + b3*a33;

    b0 = b[8]; b1 = b[9]; b2 = b[10]; b3 = b[11];
    out[8] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
    out[9] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
    out[10] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
    out[11] = b0*a03 + b1*a13 + b2*a23 + b3*a33;

    b0 = b[12]; b1 = b[13]; b2 = b[14]; b3 = b[15];
    out[12] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
    out[13] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
    out[14] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
    out[15] = b0*a03 + b1*a13 + b2*a23 + b3*a33;
    return out;
};

/**
 * Multiplies two mat4's using SIMD if available and enabled
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the first operand
 * @param {mat4} b the second operand
 * @returns {mat4} out
 */
mat4.multiply = glMatrix.USE_SIMD ? mat4.SIMD.multiply : mat4.scalar.multiply;

/**
 * Alias for {@link mat4.multiply}
 * @function
 */
mat4.mul = mat4.multiply;

/**
 * Translate a mat4 by the given vector not using SIMD
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to translate
 * @param {vec3} v vector to translate by
 * @returns {mat4} out
 */
mat4.scalar.translate = function (out, a, v) {
    var x = v[0], y = v[1], z = v[2],
        a00, a01, a02, a03,
        a10, a11, a12, a13,
        a20, a21, a22, a23;

    if (a === out) {
        out[12] = a[0] * x + a[4] * y + a[8] * z + a[12];
        out[13] = a[1] * x + a[5] * y + a[9] * z + a[13];
        out[14] = a[2] * x + a[6] * y + a[10] * z + a[14];
        out[15] = a[3] * x + a[7] * y + a[11] * z + a[15];
    } else {
        a00 = a[0]; a01 = a[1]; a02 = a[2]; a03 = a[3];
        a10 = a[4]; a11 = a[5]; a12 = a[6]; a13 = a[7];
        a20 = a[8]; a21 = a[9]; a22 = a[10]; a23 = a[11];

        out[0] = a00; out[1] = a01; out[2] = a02; out[3] = a03;
        out[4] = a10; out[5] = a11; out[6] = a12; out[7] = a13;
        out[8] = a20; out[9] = a21; out[10] = a22; out[11] = a23;

        out[12] = a00 * x + a10 * y + a20 * z + a[12];
        out[13] = a01 * x + a11 * y + a21 * z + a[13];
        out[14] = a02 * x + a12 * y + a22 * z + a[14];
        out[15] = a03 * x + a13 * y + a23 * z + a[15];
    }

    return out;
};

/**
 * Translates a mat4 by the given vector using SIMD
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to translate
 * @param {vec3} v vector to translate by
 * @returns {mat4} out
 */
mat4.SIMD.translate = function (out, a, v) {
    var a0 = SIMD.Float32x4.load(a, 0),
        a1 = SIMD.Float32x4.load(a, 4),
        a2 = SIMD.Float32x4.load(a, 8),
        a3 = SIMD.Float32x4.load(a, 12),
        vec = SIMD.Float32x4(v[0], v[1], v[2] , 0);

    if (a !== out) {
        out[0] = a[0]; out[1] = a[1]; out[2] = a[2]; out[3] = a[3];
        out[4] = a[4]; out[5] = a[5]; out[6] = a[6]; out[7] = a[7];
        out[8] = a[8]; out[9] = a[9]; out[10] = a[10]; out[11] = a[11];
    }

    a0 = SIMD.Float32x4.mul(a0, SIMD.Float32x4.swizzle(vec, 0, 0, 0, 0));
    a1 = SIMD.Float32x4.mul(a1, SIMD.Float32x4.swizzle(vec, 1, 1, 1, 1));
    a2 = SIMD.Float32x4.mul(a2, SIMD.Float32x4.swizzle(vec, 2, 2, 2, 2));

    var t0 = SIMD.Float32x4.add(a0, SIMD.Float32x4.add(a1, SIMD.Float32x4.add(a2, a3)));
    SIMD.Float32x4.store(out, 12, t0);

    return out;
};

/**
 * Translates a mat4 by the given vector using SIMD if available and enabled
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to translate
 * @param {vec3} v vector to translate by
 * @returns {mat4} out
 */
mat4.translate = glMatrix.USE_SIMD ? mat4.SIMD.translate : mat4.scalar.translate;

/**
 * Scales the mat4 by the dimensions in the given vec3 not using vectorization
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to scale
 * @param {vec3} v the vec3 to scale the matrix by
 * @returns {mat4} out
 **/
mat4.scalar.scale = function(out, a, v) {
    var x = v[0], y = v[1], z = v[2];

    out[0] = a[0] * x;
    out[1] = a[1] * x;
    out[2] = a[2] * x;
    out[3] = a[3] * x;
    out[4] = a[4] * y;
    out[5] = a[5] * y;
    out[6] = a[6] * y;
    out[7] = a[7] * y;
    out[8] = a[8] * z;
    out[9] = a[9] * z;
    out[10] = a[10] * z;
    out[11] = a[11] * z;
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
    return out;
};

/**
 * Scales the mat4 by the dimensions in the given vec3 using vectorization
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to scale
 * @param {vec3} v the vec3 to scale the matrix by
 * @returns {mat4} out
 **/
mat4.SIMD.scale = function(out, a, v) {
    var a0, a1, a2;
    var vec = SIMD.Float32x4(v[0], v[1], v[2], 0);

    a0 = SIMD.Float32x4.load(a, 0);
    SIMD.Float32x4.store(
        out, 0, SIMD.Float32x4.mul(a0, SIMD.Float32x4.swizzle(vec, 0, 0, 0, 0)));

    a1 = SIMD.Float32x4.load(a, 4);
    SIMD.Float32x4.store(
        out, 4, SIMD.Float32x4.mul(a1, SIMD.Float32x4.swizzle(vec, 1, 1, 1, 1)));

    a2 = SIMD.Float32x4.load(a, 8);
    SIMD.Float32x4.store(
        out, 8, SIMD.Float32x4.mul(a2, SIMD.Float32x4.swizzle(vec, 2, 2, 2, 2)));

    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
    return out;
};

/**
 * Scales the mat4 by the dimensions in the given vec3 using SIMD if available and enabled
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to scale
 * @param {vec3} v the vec3 to scale the matrix by
 * @returns {mat4} out
 */
mat4.scale = glMatrix.USE_SIMD ? mat4.SIMD.scale : mat4.scalar.scale;

/**
 * Rotates a mat4 by the given angle around the given axis
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @param {vec3} axis the axis to rotate around
 * @returns {mat4} out
 */
mat4.rotate = function (out, a, rad, axis) {
    var x = axis[0], y = axis[1], z = axis[2],
        len = Math.sqrt(x * x + y * y + z * z),
        s, c, t,
        a00, a01, a02, a03,
        a10, a11, a12, a13,
        a20, a21, a22, a23,
        b00, b01, b02,
        b10, b11, b12,
        b20, b21, b22;

    if (Math.abs(len) < glMatrix.EPSILON) { return null; }

    len = 1 / len;
    x *= len;
    y *= len;
    z *= len;

    s = Math.sin(rad);
    c = Math.cos(rad);
    t = 1 - c;

    a00 = a[0]; a01 = a[1]; a02 = a[2]; a03 = a[3];
    a10 = a[4]; a11 = a[5]; a12 = a[6]; a13 = a[7];
    a20 = a[8]; a21 = a[9]; a22 = a[10]; a23 = a[11];

    // Construct the elements of the rotation matrix
    b00 = x * x * t + c; b01 = y * x * t + z * s; b02 = z * x * t - y * s;
    b10 = x * y * t - z * s; b11 = y * y * t + c; b12 = z * y * t + x * s;
    b20 = x * z * t + y * s; b21 = y * z * t - x * s; b22 = z * z * t + c;

    // Perform rotation-specific matrix multiplication
    out[0] = a00 * b00 + a10 * b01 + a20 * b02;
    out[1] = a01 * b00 + a11 * b01 + a21 * b02;
    out[2] = a02 * b00 + a12 * b01 + a22 * b02;
    out[3] = a03 * b00 + a13 * b01 + a23 * b02;
    out[4] = a00 * b10 + a10 * b11 + a20 * b12;
    out[5] = a01 * b10 + a11 * b11 + a21 * b12;
    out[6] = a02 * b10 + a12 * b11 + a22 * b12;
    out[7] = a03 * b10 + a13 * b11 + a23 * b12;
    out[8] = a00 * b20 + a10 * b21 + a20 * b22;
    out[9] = a01 * b20 + a11 * b21 + a21 * b22;
    out[10] = a02 * b20 + a12 * b21 + a22 * b22;
    out[11] = a03 * b20 + a13 * b21 + a23 * b22;

    if (a !== out) { // If the source and destination differ, copy the unchanged last row
        out[12] = a[12];
        out[13] = a[13];
        out[14] = a[14];
        out[15] = a[15];
    }
    return out;
};

/**
 * Rotates a matrix by the given angle around the X axis not using SIMD
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
mat4.scalar.rotateX = function (out, a, rad) {
    var s = Math.sin(rad),
        c = Math.cos(rad),
        a10 = a[4],
        a11 = a[5],
        a12 = a[6],
        a13 = a[7],
        a20 = a[8],
        a21 = a[9],
        a22 = a[10],
        a23 = a[11];

    if (a !== out) { // If the source and destination differ, copy the unchanged rows
        out[0]  = a[0];
        out[1]  = a[1];
        out[2]  = a[2];
        out[3]  = a[3];
        out[12] = a[12];
        out[13] = a[13];
        out[14] = a[14];
        out[15] = a[15];
    }

    // Perform axis-specific matrix multiplication
    out[4] = a10 * c + a20 * s;
    out[5] = a11 * c + a21 * s;
    out[6] = a12 * c + a22 * s;
    out[7] = a13 * c + a23 * s;
    out[8] = a20 * c - a10 * s;
    out[9] = a21 * c - a11 * s;
    out[10] = a22 * c - a12 * s;
    out[11] = a23 * c - a13 * s;
    return out;
};

/**
 * Rotates a matrix by the given angle around the X axis using SIMD
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
mat4.SIMD.rotateX = function (out, a, rad) {
    var s = SIMD.Float32x4.splat(Math.sin(rad)),
        c = SIMD.Float32x4.splat(Math.cos(rad));

    if (a !== out) { // If the source and destination differ, copy the unchanged rows
      out[0]  = a[0];
      out[1]  = a[1];
      out[2]  = a[2];
      out[3]  = a[3];
      out[12] = a[12];
      out[13] = a[13];
      out[14] = a[14];
      out[15] = a[15];
    }

    // Perform axis-specific matrix multiplication
    var a_1 = SIMD.Float32x4.load(a, 4);
    var a_2 = SIMD.Float32x4.load(a, 8);
    SIMD.Float32x4.store(out, 4,
                         SIMD.Float32x4.add(SIMD.Float32x4.mul(a_1, c), SIMD.Float32x4.mul(a_2, s)));
    SIMD.Float32x4.store(out, 8,
                         SIMD.Float32x4.sub(SIMD.Float32x4.mul(a_2, c), SIMD.Float32x4.mul(a_1, s)));
    return out;
};

/**
 * Rotates a matrix by the given angle around the X axis using SIMD if availabe and enabled
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
mat4.rotateX = glMatrix.USE_SIMD ? mat4.SIMD.rotateX : mat4.scalar.rotateX;

/**
 * Rotates a matrix by the given angle around the Y axis not using SIMD
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
mat4.scalar.rotateY = function (out, a, rad) {
    var s = Math.sin(rad),
        c = Math.cos(rad),
        a00 = a[0],
        a01 = a[1],
        a02 = a[2],
        a03 = a[3],
        a20 = a[8],
        a21 = a[9],
        a22 = a[10],
        a23 = a[11];

    if (a !== out) { // If the source and destination differ, copy the unchanged rows
        out[4]  = a[4];
        out[5]  = a[5];
        out[6]  = a[6];
        out[7]  = a[7];
        out[12] = a[12];
        out[13] = a[13];
        out[14] = a[14];
        out[15] = a[15];
    }

    // Perform axis-specific matrix multiplication
    out[0] = a00 * c - a20 * s;
    out[1] = a01 * c - a21 * s;
    out[2] = a02 * c - a22 * s;
    out[3] = a03 * c - a23 * s;
    out[8] = a00 * s + a20 * c;
    out[9] = a01 * s + a21 * c;
    out[10] = a02 * s + a22 * c;
    out[11] = a03 * s + a23 * c;
    return out;
};

/**
 * Rotates a matrix by the given angle around the Y axis using SIMD
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
mat4.SIMD.rotateY = function (out, a, rad) {
    var s = SIMD.Float32x4.splat(Math.sin(rad)),
        c = SIMD.Float32x4.splat(Math.cos(rad));

    if (a !== out) { // If the source and destination differ, copy the unchanged rows
        out[4]  = a[4];
        out[5]  = a[5];
        out[6]  = a[6];
        out[7]  = a[7];
        out[12] = a[12];
        out[13] = a[13];
        out[14] = a[14];
        out[15] = a[15];
    }

    // Perform axis-specific matrix multiplication
    var a_0 = SIMD.Float32x4.load(a, 0);
    var a_2 = SIMD.Float32x4.load(a, 8);
    SIMD.Float32x4.store(out, 0,
                         SIMD.Float32x4.sub(SIMD.Float32x4.mul(a_0, c), SIMD.Float32x4.mul(a_2, s)));
    SIMD.Float32x4.store(out, 8,
                         SIMD.Float32x4.add(SIMD.Float32x4.mul(a_0, s), SIMD.Float32x4.mul(a_2, c)));
    return out;
};

/**
 * Rotates a matrix by the given angle around the Y axis if SIMD available and enabled
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
 mat4.rotateY = glMatrix.USE_SIMD ? mat4.SIMD.rotateY : mat4.scalar.rotateY;

/**
 * Rotates a matrix by the given angle around the Z axis not using SIMD
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
mat4.scalar.rotateZ = function (out, a, rad) {
    var s = Math.sin(rad),
        c = Math.cos(rad),
        a00 = a[0],
        a01 = a[1],
        a02 = a[2],
        a03 = a[3],
        a10 = a[4],
        a11 = a[5],
        a12 = a[6],
        a13 = a[7];

    if (a !== out) { // If the source and destination differ, copy the unchanged last row
        out[8]  = a[8];
        out[9]  = a[9];
        out[10] = a[10];
        out[11] = a[11];
        out[12] = a[12];
        out[13] = a[13];
        out[14] = a[14];
        out[15] = a[15];
    }

    // Perform axis-specific matrix multiplication
    out[0] = a00 * c + a10 * s;
    out[1] = a01 * c + a11 * s;
    out[2] = a02 * c + a12 * s;
    out[3] = a03 * c + a13 * s;
    out[4] = a10 * c - a00 * s;
    out[5] = a11 * c - a01 * s;
    out[6] = a12 * c - a02 * s;
    out[7] = a13 * c - a03 * s;
    return out;
};

/**
 * Rotates a matrix by the given angle around the Z axis using SIMD
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
mat4.SIMD.rotateZ = function (out, a, rad) {
    var s = SIMD.Float32x4.splat(Math.sin(rad)),
        c = SIMD.Float32x4.splat(Math.cos(rad));

    if (a !== out) { // If the source and destination differ, copy the unchanged last row
        out[8]  = a[8];
        out[9]  = a[9];
        out[10] = a[10];
        out[11] = a[11];
        out[12] = a[12];
        out[13] = a[13];
        out[14] = a[14];
        out[15] = a[15];
    }

    // Perform axis-specific matrix multiplication
    var a_0 = SIMD.Float32x4.load(a, 0);
    var a_1 = SIMD.Float32x4.load(a, 4);
    SIMD.Float32x4.store(out, 0,
                         SIMD.Float32x4.add(SIMD.Float32x4.mul(a_0, c), SIMD.Float32x4.mul(a_1, s)));
    SIMD.Float32x4.store(out, 4,
                         SIMD.Float32x4.sub(SIMD.Float32x4.mul(a_1, c), SIMD.Float32x4.mul(a_0, s)));
    return out;
};

/**
 * Rotates a matrix by the given angle around the Z axis if SIMD available and enabled
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
 mat4.rotateZ = glMatrix.USE_SIMD ? mat4.SIMD.rotateZ : mat4.scalar.rotateZ;

/**
 * Creates a matrix from a vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, dest, vec);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {vec3} v Translation vector
 * @returns {mat4} out
 */
mat4.fromTranslation = function(out, v) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = 1;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 1;
    out[11] = 0;
    out[12] = v[0];
    out[13] = v[1];
    out[14] = v[2];
    out[15] = 1;
    return out;
}

/**
 * Creates a matrix from a vector scaling
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.scale(dest, dest, vec);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {vec3} v Scaling vector
 * @returns {mat4} out
 */
mat4.fromScaling = function(out, v) {
    out[0] = v[0];
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = v[1];
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = v[2];
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
}

/**
 * Creates a matrix from a given angle around a given axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotate(dest, dest, rad, axis);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @param {vec3} axis the axis to rotate around
 * @returns {mat4} out
 */
mat4.fromRotation = function(out, rad, axis) {
    var x = axis[0], y = axis[1], z = axis[2],
        len = Math.sqrt(x * x + y * y + z * z),
        s, c, t;

    if (Math.abs(len) < glMatrix.EPSILON) { return null; }

    len = 1 / len;
    x *= len;
    y *= len;
    z *= len;

    s = Math.sin(rad);
    c = Math.cos(rad);
    t = 1 - c;

    // Perform rotation-specific matrix multiplication
    out[0] = x * x * t + c;
    out[1] = y * x * t + z * s;
    out[2] = z * x * t - y * s;
    out[3] = 0;
    out[4] = x * y * t - z * s;
    out[5] = y * y * t + c;
    out[6] = z * y * t + x * s;
    out[7] = 0;
    out[8] = x * z * t + y * s;
    out[9] = y * z * t - x * s;
    out[10] = z * z * t + c;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
}

/**
 * Creates a matrix from the given angle around the X axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotateX(dest, dest, rad);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
mat4.fromXRotation = function(out, rad) {
    var s = Math.sin(rad),
        c = Math.cos(rad);

    // Perform axis-specific matrix multiplication
    out[0]  = 1;
    out[1]  = 0;
    out[2]  = 0;
    out[3]  = 0;
    out[4] = 0;
    out[5] = c;
    out[6] = s;
    out[7] = 0;
    out[8] = 0;
    out[9] = -s;
    out[10] = c;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
}

/**
 * Creates a matrix from the given angle around the Y axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotateY(dest, dest, rad);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
mat4.fromYRotation = function(out, rad) {
    var s = Math.sin(rad),
        c = Math.cos(rad);

    // Perform axis-specific matrix multiplication
    out[0]  = c;
    out[1]  = 0;
    out[2]  = -s;
    out[3]  = 0;
    out[4] = 0;
    out[5] = 1;
    out[6] = 0;
    out[7] = 0;
    out[8] = s;
    out[9] = 0;
    out[10] = c;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
}

/**
 * Creates a matrix from the given angle around the Z axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotateZ(dest, dest, rad);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
mat4.fromZRotation = function(out, rad) {
    var s = Math.sin(rad),
        c = Math.cos(rad);

    // Perform axis-specific matrix multiplication
    out[0]  = c;
    out[1]  = s;
    out[2]  = 0;
    out[3]  = 0;
    out[4] = -s;
    out[5] = c;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 1;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
}

/**
 * Creates a matrix from a quaternion rotation and vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, vec);
 *     var quatMat = mat4.create();
 *     quat4.toMat4(quat, quatMat);
 *     mat4.multiply(dest, quatMat);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat4} q Rotation quaternion
 * @param {vec3} v Translation vector
 * @returns {mat4} out
 */
mat4.fromRotationTranslation = function (out, q, v) {
    // Quaternion math
    var x = q[0], y = q[1], z = q[2], w = q[3],
        x2 = x + x,
        y2 = y + y,
        z2 = z + z,

        xx = x * x2,
        xy = x * y2,
        xz = x * z2,
        yy = y * y2,
        yz = y * z2,
        zz = z * z2,
        wx = w * x2,
        wy = w * y2,
        wz = w * z2;

    out[0] = 1 - (yy + zz);
    out[1] = xy + wz;
    out[2] = xz - wy;
    out[3] = 0;
    out[4] = xy - wz;
    out[5] = 1 - (xx + zz);
    out[6] = yz + wx;
    out[7] = 0;
    out[8] = xz + wy;
    out[9] = yz - wx;
    out[10] = 1 - (xx + yy);
    out[11] = 0;
    out[12] = v[0];
    out[13] = v[1];
    out[14] = v[2];
    out[15] = 1;

    return out;
};

/**
 * Returns the translation vector component of a transformation
 *  matrix. If a matrix is built with fromRotationTranslation,
 *  the returned vector will be the same as the translation vector
 *  originally supplied.
 * @param  {vec3} out Vector to receive translation component
 * @param  {mat4} mat Matrix to be decomposed (input)
 * @return {vec3} out
 */
mat4.getTranslation = function (out, mat) {
  out[0] = mat[12];
  out[1] = mat[13];
  out[2] = mat[14];

  return out;
};

/**
 * Returns a quaternion representing the rotational component
 *  of a transformation matrix. If a matrix is built with
 *  fromRotationTranslation, the returned quaternion will be the
 *  same as the quaternion originally supplied.
 * @param {quat} out Quaternion to receive the rotation component
 * @param {mat4} mat Matrix to be decomposed (input)
 * @return {quat} out
 */
mat4.getRotation = function (out, mat) {
  // Algorithm taken from http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm
  var trace = mat[0] + mat[5] + mat[10];
  var S = 0;

  if (trace > 0) { 
    S = Math.sqrt(trace + 1.0) * 2;
    out[3] = 0.25 * S;
    out[0] = (mat[6] - mat[9]) / S;
    out[1] = (mat[8] - mat[2]) / S; 
    out[2] = (mat[1] - mat[4]) / S; 
  } else if ((mat[0] > mat[5])&(mat[0] > mat[10])) { 
    S = Math.sqrt(1.0 + mat[0] - mat[5] - mat[10]) * 2;
    out[3] = (mat[6] - mat[9]) / S;
    out[0] = 0.25 * S;
    out[1] = (mat[1] + mat[4]) / S; 
    out[2] = (mat[8] + mat[2]) / S; 
  } else if (mat[5] > mat[10]) { 
    S = Math.sqrt(1.0 + mat[5] - mat[0] - mat[10]) * 2;
    out[3] = (mat[8] - mat[2]) / S;
    out[0] = (mat[1] + mat[4]) / S; 
    out[1] = 0.25 * S;
    out[2] = (mat[6] + mat[9]) / S; 
  } else { 
    S = Math.sqrt(1.0 + mat[10] - mat[0] - mat[5]) * 2;
    out[3] = (mat[1] - mat[4]) / S;
    out[0] = (mat[8] + mat[2]) / S;
    out[1] = (mat[6] + mat[9]) / S;
    out[2] = 0.25 * S;
  }

  return out;
};

/**
 * Creates a matrix from a quaternion rotation, vector translation and vector scale
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, vec);
 *     var quatMat = mat4.create();
 *     quat4.toMat4(quat, quatMat);
 *     mat4.multiply(dest, quatMat);
 *     mat4.scale(dest, scale)
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat4} q Rotation quaternion
 * @param {vec3} v Translation vector
 * @param {vec3} s Scaling vector
 * @returns {mat4} out
 */
mat4.fromRotationTranslationScale = function (out, q, v, s) {
    // Quaternion math
    var x = q[0], y = q[1], z = q[2], w = q[3],
        x2 = x + x,
        y2 = y + y,
        z2 = z + z,

        xx = x * x2,
        xy = x * y2,
        xz = x * z2,
        yy = y * y2,
        yz = y * z2,
        zz = z * z2,
        wx = w * x2,
        wy = w * y2,
        wz = w * z2,
        sx = s[0],
        sy = s[1],
        sz = s[2];

    out[0] = (1 - (yy + zz)) * sx;
    out[1] = (xy + wz) * sx;
    out[2] = (xz - wy) * sx;
    out[3] = 0;
    out[4] = (xy - wz) * sy;
    out[5] = (1 - (xx + zz)) * sy;
    out[6] = (yz + wx) * sy;
    out[7] = 0;
    out[8] = (xz + wy) * sz;
    out[9] = (yz - wx) * sz;
    out[10] = (1 - (xx + yy)) * sz;
    out[11] = 0;
    out[12] = v[0];
    out[13] = v[1];
    out[14] = v[2];
    out[15] = 1;

    return out;
};

/**
 * Creates a matrix from a quaternion rotation, vector translation and vector scale, rotating and scaling around the given origin
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, vec);
 *     mat4.translate(dest, origin);
 *     var quatMat = mat4.create();
 *     quat4.toMat4(quat, quatMat);
 *     mat4.multiply(dest, quatMat);
 *     mat4.scale(dest, scale)
 *     mat4.translate(dest, negativeOrigin);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat4} q Rotation quaternion
 * @param {vec3} v Translation vector
 * @param {vec3} s Scaling vector
 * @param {vec3} o The origin vector around which to scale and rotate
 * @returns {mat4} out
 */
mat4.fromRotationTranslationScaleOrigin = function (out, q, v, s, o) {
  // Quaternion math
  var x = q[0], y = q[1], z = q[2], w = q[3],
      x2 = x + x,
      y2 = y + y,
      z2 = z + z,

      xx = x * x2,
      xy = x * y2,
      xz = x * z2,
      yy = y * y2,
      yz = y * z2,
      zz = z * z2,
      wx = w * x2,
      wy = w * y2,
      wz = w * z2,

      sx = s[0],
      sy = s[1],
      sz = s[2],

      ox = o[0],
      oy = o[1],
      oz = o[2];

  out[0] = (1 - (yy + zz)) * sx;
  out[1] = (xy + wz) * sx;
  out[2] = (xz - wy) * sx;
  out[3] = 0;
  out[4] = (xy - wz) * sy;
  out[5] = (1 - (xx + zz)) * sy;
  out[6] = (yz + wx) * sy;
  out[7] = 0;
  out[8] = (xz + wy) * sz;
  out[9] = (yz - wx) * sz;
  out[10] = (1 - (xx + yy)) * sz;
  out[11] = 0;
  out[12] = v[0] + ox - (out[0] * ox + out[4] * oy + out[8] * oz);
  out[13] = v[1] + oy - (out[1] * ox + out[5] * oy + out[9] * oz);
  out[14] = v[2] + oz - (out[2] * ox + out[6] * oy + out[10] * oz);
  out[15] = 1;

  return out;
};

/**
 * Calculates a 4x4 matrix from the given quaternion
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat} q Quaternion to create matrix from
 *
 * @returns {mat4} out
 */
mat4.fromQuat = function (out, q) {
    var x = q[0], y = q[1], z = q[2], w = q[3],
        x2 = x + x,
        y2 = y + y,
        z2 = z + z,

        xx = x * x2,
        yx = y * x2,
        yy = y * y2,
        zx = z * x2,
        zy = z * y2,
        zz = z * z2,
        wx = w * x2,
        wy = w * y2,
        wz = w * z2;

    out[0] = 1 - yy - zz;
    out[1] = yx + wz;
    out[2] = zx - wy;
    out[3] = 0;

    out[4] = yx - wz;
    out[5] = 1 - xx - zz;
    out[6] = zy + wx;
    out[7] = 0;

    out[8] = zx + wy;
    out[9] = zy - wx;
    out[10] = 1 - xx - yy;
    out[11] = 0;

    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;

    return out;
};

/**
 * Generates a frustum matrix with the given bounds
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {Number} left Left bound of the frustum
 * @param {Number} right Right bound of the frustum
 * @param {Number} bottom Bottom bound of the frustum
 * @param {Number} top Top bound of the frustum
 * @param {Number} near Near bound of the frustum
 * @param {Number} far Far bound of the frustum
 * @returns {mat4} out
 */
mat4.frustum = function (out, left, right, bottom, top, near, far) {
    var rl = 1 / (right - left),
        tb = 1 / (top - bottom),
        nf = 1 / (near - far);
    out[0] = (near * 2) * rl;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = (near * 2) * tb;
    out[6] = 0;
    out[7] = 0;
    out[8] = (right + left) * rl;
    out[9] = (top + bottom) * tb;
    out[10] = (far + near) * nf;
    out[11] = -1;
    out[12] = 0;
    out[13] = 0;
    out[14] = (far * near * 2) * nf;
    out[15] = 0;
    return out;
};

/**
 * Generates a perspective projection matrix with the given bounds
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {number} fovy Vertical field of view in radians
 * @param {number} aspect Aspect ratio. typically viewport width/height
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum
 * @returns {mat4} out
 */
mat4.perspective = function (out, fovy, aspect, near, far) {
    var f = 1.0 / Math.tan(fovy / 2),
        nf = 1 / (near - far);
    out[0] = f / aspect;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = f;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = (far + near) * nf;
    out[11] = -1;
    out[12] = 0;
    out[13] = 0;
    out[14] = (2 * far * near) * nf;
    out[15] = 0;
    return out;
};

/**
 * Generates a perspective projection matrix with the given field of view.
 * This is primarily useful for generating projection matrices to be used
 * with the still experiemental WebVR API.
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {Object} fov Object containing the following values: upDegrees, downDegrees, leftDegrees, rightDegrees
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum
 * @returns {mat4} out
 */
mat4.perspectiveFromFieldOfView = function (out, fov, near, far) {
    var upTan = Math.tan(fov.upDegrees * Math.PI/180.0),
        downTan = Math.tan(fov.downDegrees * Math.PI/180.0),
        leftTan = Math.tan(fov.leftDegrees * Math.PI/180.0),
        rightTan = Math.tan(fov.rightDegrees * Math.PI/180.0),
        xScale = 2.0 / (leftTan + rightTan),
        yScale = 2.0 / (upTan + downTan);

    out[0] = xScale;
    out[1] = 0.0;
    out[2] = 0.0;
    out[3] = 0.0;
    out[4] = 0.0;
    out[5] = yScale;
    out[6] = 0.0;
    out[7] = 0.0;
    out[8] = -((leftTan - rightTan) * xScale * 0.5);
    out[9] = ((upTan - downTan) * yScale * 0.5);
    out[10] = far / (near - far);
    out[11] = -1.0;
    out[12] = 0.0;
    out[13] = 0.0;
    out[14] = (far * near) / (near - far);
    out[15] = 0.0;
    return out;
}

/**
 * Generates a orthogonal projection matrix with the given bounds
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {number} left Left bound of the frustum
 * @param {number} right Right bound of the frustum
 * @param {number} bottom Bottom bound of the frustum
 * @param {number} top Top bound of the frustum
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum
 * @returns {mat4} out
 */
mat4.ortho = function (out, left, right, bottom, top, near, far) {
    var lr = 1 / (left - right),
        bt = 1 / (bottom - top),
        nf = 1 / (near - far);
    out[0] = -2 * lr;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = -2 * bt;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 2 * nf;
    out[11] = 0;
    out[12] = (left + right) * lr;
    out[13] = (top + bottom) * bt;
    out[14] = (far + near) * nf;
    out[15] = 1;
    return out;
};

/**
 * Generates a look-at matrix with the given eye position, focal point, and up axis
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {vec3} eye Position of the viewer
 * @param {vec3} center Point the viewer is looking at
 * @param {vec3} up vec3 pointing up
 * @returns {mat4} out
 */
mat4.lookAt = function (out, eye, center, up) {
    var x0, x1, x2, y0, y1, y2, z0, z1, z2, len,
        eyex = eye[0],
        eyey = eye[1],
        eyez = eye[2],
        upx = up[0],
        upy = up[1],
        upz = up[2],
        centerx = center[0],
        centery = center[1],
        centerz = center[2];

    if (Math.abs(eyex - centerx) < glMatrix.EPSILON &&
        Math.abs(eyey - centery) < glMatrix.EPSILON &&
        Math.abs(eyez - centerz) < glMatrix.EPSILON) {
        return mat4.identity(out);
    }

    z0 = eyex - centerx;
    z1 = eyey - centery;
    z2 = eyez - centerz;

    len = 1 / Math.sqrt(z0 * z0 + z1 * z1 + z2 * z2);
    z0 *= len;
    z1 *= len;
    z2 *= len;

    x0 = upy * z2 - upz * z1;
    x1 = upz * z0 - upx * z2;
    x2 = upx * z1 - upy * z0;
    len = Math.sqrt(x0 * x0 + x1 * x1 + x2 * x2);
    if (!len) {
        x0 = 0;
        x1 = 0;
        x2 = 0;
    } else {
        len = 1 / len;
        x0 *= len;
        x1 *= len;
        x2 *= len;
    }

    y0 = z1 * x2 - z2 * x1;
    y1 = z2 * x0 - z0 * x2;
    y2 = z0 * x1 - z1 * x0;

    len = Math.sqrt(y0 * y0 + y1 * y1 + y2 * y2);
    if (!len) {
        y0 = 0;
        y1 = 0;
        y2 = 0;
    } else {
        len = 1 / len;
        y0 *= len;
        y1 *= len;
        y2 *= len;
    }

    out[0] = x0;
    out[1] = y0;
    out[2] = z0;
    out[3] = 0;
    out[4] = x1;
    out[5] = y1;
    out[6] = z1;
    out[7] = 0;
    out[8] = x2;
    out[9] = y2;
    out[10] = z2;
    out[11] = 0;
    out[12] = -(x0 * eyex + x1 * eyey + x2 * eyez);
    out[13] = -(y0 * eyex + y1 * eyey + y2 * eyez);
    out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);
    out[15] = 1;

    return out;
};

/**
 * Returns a string representation of a mat4
 *
 * @param {mat4} mat matrix to represent as a string
 * @returns {String} string representation of the matrix
 */
mat4.str = function (a) {
    return 'mat4(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ', ' +
                    a[4] + ', ' + a[5] + ', ' + a[6] + ', ' + a[7] + ', ' +
                    a[8] + ', ' + a[9] + ', ' + a[10] + ', ' + a[11] + ', ' +
                    a[12] + ', ' + a[13] + ', ' + a[14] + ', ' + a[15] + ')';
};

/**
 * Returns Frobenius norm of a mat4
 *
 * @param {mat4} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */
mat4.frob = function (a) {
    return(Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2) + Math.pow(a[4], 2) + Math.pow(a[5], 2) + Math.pow(a[6], 2) + Math.pow(a[7], 2) + Math.pow(a[8], 2) + Math.pow(a[9], 2) + Math.pow(a[10], 2) + Math.pow(a[11], 2) + Math.pow(a[12], 2) + Math.pow(a[13], 2) + Math.pow(a[14], 2) + Math.pow(a[15], 2) ))
};

/**
 * Adds two mat4's
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the first operand
 * @param {mat4} b the second operand
 * @returns {mat4} out
 */
mat4.add = function(out, a, b) {
    out[0] = a[0] + b[0];
    out[1] = a[1] + b[1];
    out[2] = a[2] + b[2];
    out[3] = a[3] + b[3];
    out[4] = a[4] + b[4];
    out[5] = a[5] + b[5];
    out[6] = a[6] + b[6];
    out[7] = a[7] + b[7];
    out[8] = a[8] + b[8];
    out[9] = a[9] + b[9];
    out[10] = a[10] + b[10];
    out[11] = a[11] + b[11];
    out[12] = a[12] + b[12];
    out[13] = a[13] + b[13];
    out[14] = a[14] + b[14];
    out[15] = a[15] + b[15];
    return out;
};

/**
 * Subtracts matrix b from matrix a
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the first operand
 * @param {mat4} b the second operand
 * @returns {mat4} out
 */
mat4.subtract = function(out, a, b) {
    out[0] = a[0] - b[0];
    out[1] = a[1] - b[1];
    out[2] = a[2] - b[2];
    out[3] = a[3] - b[3];
    out[4] = a[4] - b[4];
    out[5] = a[5] - b[5];
    out[6] = a[6] - b[6];
    out[7] = a[7] - b[7];
    out[8] = a[8] - b[8];
    out[9] = a[9] - b[9];
    out[10] = a[10] - b[10];
    out[11] = a[11] - b[11];
    out[12] = a[12] - b[12];
    out[13] = a[13] - b[13];
    out[14] = a[14] - b[14];
    out[15] = a[15] - b[15];
    return out;
};

/**
 * Alias for {@link mat4.subtract}
 * @function
 */
mat4.sub = mat4.subtract;

/**
 * Multiply each element of the matrix by a scalar.
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to scale
 * @param {Number} b amount to scale the matrix's elements by
 * @returns {mat4} out
 */
mat4.multiplyScalar = function(out, a, b) {
    out[0] = a[0] * b;
    out[1] = a[1] * b;
    out[2] = a[2] * b;
    out[3] = a[3] * b;
    out[4] = a[4] * b;
    out[5] = a[5] * b;
    out[6] = a[6] * b;
    out[7] = a[7] * b;
    out[8] = a[8] * b;
    out[9] = a[9] * b;
    out[10] = a[10] * b;
    out[11] = a[11] * b;
    out[12] = a[12] * b;
    out[13] = a[13] * b;
    out[14] = a[14] * b;
    out[15] = a[15] * b;
    return out;
};

/**
 * Adds two mat4's after multiplying each element of the second operand by a scalar value.
 *
 * @param {mat4} out the receiving vector
 * @param {mat4} a the first operand
 * @param {mat4} b the second operand
 * @param {Number} scale the amount to scale b's elements by before adding
 * @returns {mat4} out
 */
mat4.multiplyScalarAndAdd = function(out, a, b, scale) {
    out[0] = a[0] + (b[0] * scale);
    out[1] = a[1] + (b[1] * scale);
    out[2] = a[2] + (b[2] * scale);
    out[3] = a[3] + (b[3] * scale);
    out[4] = a[4] + (b[4] * scale);
    out[5] = a[5] + (b[5] * scale);
    out[6] = a[6] + (b[6] * scale);
    out[7] = a[7] + (b[7] * scale);
    out[8] = a[8] + (b[8] * scale);
    out[9] = a[9] + (b[9] * scale);
    out[10] = a[10] + (b[10] * scale);
    out[11] = a[11] + (b[11] * scale);
    out[12] = a[12] + (b[12] * scale);
    out[13] = a[13] + (b[13] * scale);
    out[14] = a[14] + (b[14] * scale);
    out[15] = a[15] + (b[15] * scale);
    return out;
};

/**
 * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
 *
 * @param {mat4} a The first matrix.
 * @param {mat4} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */
mat4.exactEquals = function (a, b) {
    return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && 
           a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7] && 
           a[8] === b[8] && a[9] === b[9] && a[10] === b[10] && a[11] === b[11] &&
           a[12] === b[12] && a[13] === b[13] && a[14] === b[14] && a[15] === b[15];
};

/**
 * Returns whether or not the matrices have approximately the same elements in the same position.
 *
 * @param {mat4} a The first matrix.
 * @param {mat4} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */
mat4.equals = function (a, b) {
    var a0  = a[0],  a1  = a[1],  a2  = a[2],  a3  = a[3],
        a4  = a[4],  a5  = a[5],  a6  = a[6],  a7  = a[7], 
        a8  = a[8],  a9  = a[9],  a10 = a[10], a11 = a[11], 
        a12 = a[12], a13 = a[13], a14 = a[14], a15 = a[15];

    var b0  = b[0],  b1  = b[1],  b2  = b[2],  b3  = b[3],
        b4  = b[4],  b5  = b[5],  b6  = b[6],  b7  = b[7], 
        b8  = b[8],  b9  = b[9],  b10 = b[10], b11 = b[11], 
        b12 = b[12], b13 = b[13], b14 = b[14], b15 = b[15];

    return (Math.abs(a0 - b0) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a0), Math.abs(b0)) &&
            Math.abs(a1 - b1) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a1), Math.abs(b1)) &&
            Math.abs(a2 - b2) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a2), Math.abs(b2)) &&
            Math.abs(a3 - b3) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a3), Math.abs(b3)) &&
            Math.abs(a4 - b4) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a4), Math.abs(b4)) &&
            Math.abs(a5 - b5) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a5), Math.abs(b5)) &&
            Math.abs(a6 - b6) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a6), Math.abs(b6)) &&
            Math.abs(a7 - b7) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a7), Math.abs(b7)) &&
            Math.abs(a8 - b8) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a8), Math.abs(b8)) &&
            Math.abs(a9 - b9) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a9), Math.abs(b9)) &&
            Math.abs(a10 - b10) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a10), Math.abs(b10)) &&
            Math.abs(a11 - b11) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a11), Math.abs(b11)) &&
            Math.abs(a12 - b12) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a12), Math.abs(b12)) &&
            Math.abs(a13 - b13) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a13), Math.abs(b13)) &&
            Math.abs(a14 - b14) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a14), Math.abs(b14)) &&
            Math.abs(a15 - b15) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a15), Math.abs(b15)));
};



module.exports = mat4;

},{"./common.js":125}],130:[function(require,module,exports){
/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE. */

var glMatrix = require("./common.js");
var mat3 = require("./mat3.js");
var vec3 = require("./vec3.js");
var vec4 = require("./vec4.js");

/**
 * @class Quaternion
 * @name quat
 */
var quat = {};

/**
 * Creates a new identity quat
 *
 * @returns {quat} a new quaternion
 */
quat.create = function() {
    var out = new glMatrix.ARRAY_TYPE(4);
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    out[3] = 1;
    return out;
};

/**
 * Sets a quaternion to represent the shortest rotation from one
 * vector to another.
 *
 * Both vectors are assumed to be unit length.
 *
 * @param {quat} out the receiving quaternion.
 * @param {vec3} a the initial vector
 * @param {vec3} b the destination vector
 * @returns {quat} out
 */
quat.rotationTo = (function() {
    var tmpvec3 = vec3.create();
    var xUnitVec3 = vec3.fromValues(1,0,0);
    var yUnitVec3 = vec3.fromValues(0,1,0);

    return function(out, a, b) {
        var dot = vec3.dot(a, b);
        if (dot < -0.999999) {
            vec3.cross(tmpvec3, xUnitVec3, a);
            if (vec3.length(tmpvec3) < 0.000001)
                vec3.cross(tmpvec3, yUnitVec3, a);
            vec3.normalize(tmpvec3, tmpvec3);
            quat.setAxisAngle(out, tmpvec3, Math.PI);
            return out;
        } else if (dot > 0.999999) {
            out[0] = 0;
            out[1] = 0;
            out[2] = 0;
            out[3] = 1;
            return out;
        } else {
            vec3.cross(tmpvec3, a, b);
            out[0] = tmpvec3[0];
            out[1] = tmpvec3[1];
            out[2] = tmpvec3[2];
            out[3] = 1 + dot;
            return quat.normalize(out, out);
        }
    };
})();

/**
 * Sets the specified quaternion with values corresponding to the given
 * axes. Each axis is a vec3 and is expected to be unit length and
 * perpendicular to all other specified axes.
 *
 * @param {vec3} view  the vector representing the viewing direction
 * @param {vec3} right the vector representing the local "right" direction
 * @param {vec3} up    the vector representing the local "up" direction
 * @returns {quat} out
 */
quat.setAxes = (function() {
    var matr = mat3.create();

    return function(out, view, right, up) {
        matr[0] = right[0];
        matr[3] = right[1];
        matr[6] = right[2];

        matr[1] = up[0];
        matr[4] = up[1];
        matr[7] = up[2];

        matr[2] = -view[0];
        matr[5] = -view[1];
        matr[8] = -view[2];

        return quat.normalize(out, quat.fromMat3(out, matr));
    };
})();

/**
 * Creates a new quat initialized with values from an existing quaternion
 *
 * @param {quat} a quaternion to clone
 * @returns {quat} a new quaternion
 * @function
 */
quat.clone = vec4.clone;

/**
 * Creates a new quat initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {quat} a new quaternion
 * @function
 */
quat.fromValues = vec4.fromValues;

/**
 * Copy the values from one quat to another
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the source quaternion
 * @returns {quat} out
 * @function
 */
quat.copy = vec4.copy;

/**
 * Set the components of a quat to the given values
 *
 * @param {quat} out the receiving quaternion
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {quat} out
 * @function
 */
quat.set = vec4.set;

/**
 * Set a quat to the identity quaternion
 *
 * @param {quat} out the receiving quaternion
 * @returns {quat} out
 */
quat.identity = function(out) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    out[3] = 1;
    return out;
};

/**
 * Sets a quat from the given angle and rotation axis,
 * then returns it.
 *
 * @param {quat} out the receiving quaternion
 * @param {vec3} axis the axis around which to rotate
 * @param {Number} rad the angle in radians
 * @returns {quat} out
 **/
quat.setAxisAngle = function(out, axis, rad) {
    rad = rad * 0.5;
    var s = Math.sin(rad);
    out[0] = s * axis[0];
    out[1] = s * axis[1];
    out[2] = s * axis[2];
    out[3] = Math.cos(rad);
    return out;
};

/**
 * Gets the rotation axis and angle for a given
 *  quaternion. If a quaternion is created with
 *  setAxisAngle, this method will return the same
 *  values as providied in the original parameter list
 *  OR functionally equivalent values.
 * Example: The quaternion formed by axis [0, 0, 1] and
 *  angle -90 is the same as the quaternion formed by
 *  [0, 0, 1] and 270. This method favors the latter.
 * @param  {vec3} out_axis  Vector receiving the axis of rotation
 * @param  {quat} q     Quaternion to be decomposed
 * @return {Number}     Angle, in radians, of the rotation
 */
quat.getAxisAngle = function(out_axis, q) {
    var rad = Math.acos(q[3]) * 2.0;
    var s = Math.sin(rad / 2.0);
    if (s != 0.0) {
        out_axis[0] = q[0] / s;
        out_axis[1] = q[1] / s;
        out_axis[2] = q[2] / s;
    } else {
        // If s is zero, return any axis (no rotation - axis does not matter)
        out_axis[0] = 1;
        out_axis[1] = 0;
        out_axis[2] = 0;
    }
    return rad;
};

/**
 * Adds two quat's
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @returns {quat} out
 * @function
 */
quat.add = vec4.add;

/**
 * Multiplies two quat's
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @returns {quat} out
 */
quat.multiply = function(out, a, b) {
    var ax = a[0], ay = a[1], az = a[2], aw = a[3],
        bx = b[0], by = b[1], bz = b[2], bw = b[3];

    out[0] = ax * bw + aw * bx + ay * bz - az * by;
    out[1] = ay * bw + aw * by + az * bx - ax * bz;
    out[2] = az * bw + aw * bz + ax * by - ay * bx;
    out[3] = aw * bw - ax * bx - ay * by - az * bz;
    return out;
};

/**
 * Alias for {@link quat.multiply}
 * @function
 */
quat.mul = quat.multiply;

/**
 * Scales a quat by a scalar number
 *
 * @param {quat} out the receiving vector
 * @param {quat} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {quat} out
 * @function
 */
quat.scale = vec4.scale;

/**
 * Rotates a quaternion by the given angle about the X axis
 *
 * @param {quat} out quat receiving operation result
 * @param {quat} a quat to rotate
 * @param {number} rad angle (in radians) to rotate
 * @returns {quat} out
 */
quat.rotateX = function (out, a, rad) {
    rad *= 0.5; 

    var ax = a[0], ay = a[1], az = a[2], aw = a[3],
        bx = Math.sin(rad), bw = Math.cos(rad);

    out[0] = ax * bw + aw * bx;
    out[1] = ay * bw + az * bx;
    out[2] = az * bw - ay * bx;
    out[3] = aw * bw - ax * bx;
    return out;
};

/**
 * Rotates a quaternion by the given angle about the Y axis
 *
 * @param {quat} out quat receiving operation result
 * @param {quat} a quat to rotate
 * @param {number} rad angle (in radians) to rotate
 * @returns {quat} out
 */
quat.rotateY = function (out, a, rad) {
    rad *= 0.5; 

    var ax = a[0], ay = a[1], az = a[2], aw = a[3],
        by = Math.sin(rad), bw = Math.cos(rad);

    out[0] = ax * bw - az * by;
    out[1] = ay * bw + aw * by;
    out[2] = az * bw + ax * by;
    out[3] = aw * bw - ay * by;
    return out;
};

/**
 * Rotates a quaternion by the given angle about the Z axis
 *
 * @param {quat} out quat receiving operation result
 * @param {quat} a quat to rotate
 * @param {number} rad angle (in radians) to rotate
 * @returns {quat} out
 */
quat.rotateZ = function (out, a, rad) {
    rad *= 0.5; 

    var ax = a[0], ay = a[1], az = a[2], aw = a[3],
        bz = Math.sin(rad), bw = Math.cos(rad);

    out[0] = ax * bw + ay * bz;
    out[1] = ay * bw - ax * bz;
    out[2] = az * bw + aw * bz;
    out[3] = aw * bw - az * bz;
    return out;
};

/**
 * Calculates the W component of a quat from the X, Y, and Z components.
 * Assumes that quaternion is 1 unit in length.
 * Any existing W component will be ignored.
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a quat to calculate W component of
 * @returns {quat} out
 */
quat.calculateW = function (out, a) {
    var x = a[0], y = a[1], z = a[2];

    out[0] = x;
    out[1] = y;
    out[2] = z;
    out[3] = Math.sqrt(Math.abs(1.0 - x * x - y * y - z * z));
    return out;
};

/**
 * Calculates the dot product of two quat's
 *
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @returns {Number} dot product of a and b
 * @function
 */
quat.dot = vec4.dot;

/**
 * Performs a linear interpolation between two quat's
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {quat} out
 * @function
 */
quat.lerp = vec4.lerp;

/**
 * Performs a spherical linear interpolation between two quat
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {quat} out
 */
quat.slerp = function (out, a, b, t) {
    // benchmarks:
    //    http://jsperf.com/quaternion-slerp-implementations

    var ax = a[0], ay = a[1], az = a[2], aw = a[3],
        bx = b[0], by = b[1], bz = b[2], bw = b[3];

    var        omega, cosom, sinom, scale0, scale1;

    // calc cosine
    cosom = ax * bx + ay * by + az * bz + aw * bw;
    // adjust signs (if necessary)
    if ( cosom < 0.0 ) {
        cosom = -cosom;
        bx = - bx;
        by = - by;
        bz = - bz;
        bw = - bw;
    }
    // calculate coefficients
    if ( (1.0 - cosom) > 0.000001 ) {
        // standard case (slerp)
        omega  = Math.acos(cosom);
        sinom  = Math.sin(omega);
        scale0 = Math.sin((1.0 - t) * omega) / sinom;
        scale1 = Math.sin(t * omega) / sinom;
    } else {        
        // "from" and "to" quaternions are very close 
        //  ... so we can do a linear interpolation
        scale0 = 1.0 - t;
        scale1 = t;
    }
    // calculate final values
    out[0] = scale0 * ax + scale1 * bx;
    out[1] = scale0 * ay + scale1 * by;
    out[2] = scale0 * az + scale1 * bz;
    out[3] = scale0 * aw + scale1 * bw;
    
    return out;
};

/**
 * Performs a spherical linear interpolation with two control points
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @param {quat} c the third operand
 * @param {quat} d the fourth operand
 * @param {Number} t interpolation amount
 * @returns {quat} out
 */
quat.sqlerp = (function () {
  var temp1 = quat.create();
  var temp2 = quat.create();
  
  return function (out, a, b, c, d, t) {
    quat.slerp(temp1, a, d, t);
    quat.slerp(temp2, b, c, t);
    quat.slerp(out, temp1, temp2, 2 * t * (1 - t));
    
    return out;
  };
}());

/**
 * Calculates the inverse of a quat
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a quat to calculate inverse of
 * @returns {quat} out
 */
quat.invert = function(out, a) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3],
        dot = a0*a0 + a1*a1 + a2*a2 + a3*a3,
        invDot = dot ? 1.0/dot : 0;
    
    // TODO: Would be faster to return [0,0,0,0] immediately if dot == 0

    out[0] = -a0*invDot;
    out[1] = -a1*invDot;
    out[2] = -a2*invDot;
    out[3] = a3*invDot;
    return out;
};

/**
 * Calculates the conjugate of a quat
 * If the quaternion is normalized, this function is faster than quat.inverse and produces the same result.
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a quat to calculate conjugate of
 * @returns {quat} out
 */
quat.conjugate = function (out, a) {
    out[0] = -a[0];
    out[1] = -a[1];
    out[2] = -a[2];
    out[3] = a[3];
    return out;
};

/**
 * Calculates the length of a quat
 *
 * @param {quat} a vector to calculate length of
 * @returns {Number} length of a
 * @function
 */
quat.length = vec4.length;

/**
 * Alias for {@link quat.length}
 * @function
 */
quat.len = quat.length;

/**
 * Calculates the squared length of a quat
 *
 * @param {quat} a vector to calculate squared length of
 * @returns {Number} squared length of a
 * @function
 */
quat.squaredLength = vec4.squaredLength;

/**
 * Alias for {@link quat.squaredLength}
 * @function
 */
quat.sqrLen = quat.squaredLength;

/**
 * Normalize a quat
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a quaternion to normalize
 * @returns {quat} out
 * @function
 */
quat.normalize = vec4.normalize;

/**
 * Creates a quaternion from the given 3x3 rotation matrix.
 *
 * NOTE: The resultant quaternion is not normalized, so you should be sure
 * to renormalize the quaternion yourself where necessary.
 *
 * @param {quat} out the receiving quaternion
 * @param {mat3} m rotation matrix
 * @returns {quat} out
 * @function
 */
quat.fromMat3 = function(out, m) {
    // Algorithm in Ken Shoemake's article in 1987 SIGGRAPH course notes
    // article "Quaternion Calculus and Fast Animation".
    var fTrace = m[0] + m[4] + m[8];
    var fRoot;

    if ( fTrace > 0.0 ) {
        // |w| > 1/2, may as well choose w > 1/2
        fRoot = Math.sqrt(fTrace + 1.0);  // 2w
        out[3] = 0.5 * fRoot;
        fRoot = 0.5/fRoot;  // 1/(4w)
        out[0] = (m[5]-m[7])*fRoot;
        out[1] = (m[6]-m[2])*fRoot;
        out[2] = (m[1]-m[3])*fRoot;
    } else {
        // |w| <= 1/2
        var i = 0;
        if ( m[4] > m[0] )
          i = 1;
        if ( m[8] > m[i*3+i] )
          i = 2;
        var j = (i+1)%3;
        var k = (i+2)%3;
        
        fRoot = Math.sqrt(m[i*3+i]-m[j*3+j]-m[k*3+k] + 1.0);
        out[i] = 0.5 * fRoot;
        fRoot = 0.5 / fRoot;
        out[3] = (m[j*3+k] - m[k*3+j]) * fRoot;
        out[j] = (m[j*3+i] + m[i*3+j]) * fRoot;
        out[k] = (m[k*3+i] + m[i*3+k]) * fRoot;
    }
    
    return out;
};

/**
 * Returns a string representation of a quatenion
 *
 * @param {quat} vec vector to represent as a string
 * @returns {String} string representation of the vector
 */
quat.str = function (a) {
    return 'quat(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ')';
};

/**
 * Returns whether or not the quaternions have exactly the same elements in the same position (when compared with ===)
 *
 * @param {quat} a The first quaternion.
 * @param {quat} b The second quaternion.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */
quat.exactEquals = vec4.exactEquals;

/**
 * Returns whether or not the quaternions have approximately the same elements in the same position.
 *
 * @param {quat} a The first vector.
 * @param {quat} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */
quat.equals = vec4.equals;

module.exports = quat;

},{"./common.js":125,"./mat3.js":128,"./vec3.js":132,"./vec4.js":133}],131:[function(require,module,exports){
/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE. */

var glMatrix = require("./common.js");

/**
 * @class 2 Dimensional Vector
 * @name vec2
 */
var vec2 = {};

/**
 * Creates a new, empty vec2
 *
 * @returns {vec2} a new 2D vector
 */
vec2.create = function() {
    var out = new glMatrix.ARRAY_TYPE(2);
    out[0] = 0;
    out[1] = 0;
    return out;
};

/**
 * Creates a new vec2 initialized with values from an existing vector
 *
 * @param {vec2} a vector to clone
 * @returns {vec2} a new 2D vector
 */
vec2.clone = function(a) {
    var out = new glMatrix.ARRAY_TYPE(2);
    out[0] = a[0];
    out[1] = a[1];
    return out;
};

/**
 * Creates a new vec2 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @returns {vec2} a new 2D vector
 */
vec2.fromValues = function(x, y) {
    var out = new glMatrix.ARRAY_TYPE(2);
    out[0] = x;
    out[1] = y;
    return out;
};

/**
 * Copy the values from one vec2 to another
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the source vector
 * @returns {vec2} out
 */
vec2.copy = function(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    return out;
};

/**
 * Set the components of a vec2 to the given values
 *
 * @param {vec2} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @returns {vec2} out
 */
vec2.set = function(out, x, y) {
    out[0] = x;
    out[1] = y;
    return out;
};

/**
 * Adds two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */
vec2.add = function(out, a, b) {
    out[0] = a[0] + b[0];
    out[1] = a[1] + b[1];
    return out;
};

/**
 * Subtracts vector b from vector a
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */
vec2.subtract = function(out, a, b) {
    out[0] = a[0] - b[0];
    out[1] = a[1] - b[1];
    return out;
};

/**
 * Alias for {@link vec2.subtract}
 * @function
 */
vec2.sub = vec2.subtract;

/**
 * Multiplies two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */
vec2.multiply = function(out, a, b) {
    out[0] = a[0] * b[0];
    out[1] = a[1] * b[1];
    return out;
};

/**
 * Alias for {@link vec2.multiply}
 * @function
 */
vec2.mul = vec2.multiply;

/**
 * Divides two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */
vec2.divide = function(out, a, b) {
    out[0] = a[0] / b[0];
    out[1] = a[1] / b[1];
    return out;
};

/**
 * Alias for {@link vec2.divide}
 * @function
 */
vec2.div = vec2.divide;

/**
 * Math.ceil the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to ceil
 * @returns {vec2} out
 */
vec2.ceil = function (out, a) {
    out[0] = Math.ceil(a[0]);
    out[1] = Math.ceil(a[1]);
    return out;
};

/**
 * Math.floor the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to floor
 * @returns {vec2} out
 */
vec2.floor = function (out, a) {
    out[0] = Math.floor(a[0]);
    out[1] = Math.floor(a[1]);
    return out;
};

/**
 * Returns the minimum of two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */
vec2.min = function(out, a, b) {
    out[0] = Math.min(a[0], b[0]);
    out[1] = Math.min(a[1], b[1]);
    return out;
};

/**
 * Returns the maximum of two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */
vec2.max = function(out, a, b) {
    out[0] = Math.max(a[0], b[0]);
    out[1] = Math.max(a[1], b[1]);
    return out;
};

/**
 * Math.round the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to round
 * @returns {vec2} out
 */
vec2.round = function (out, a) {
    out[0] = Math.round(a[0]);
    out[1] = Math.round(a[1]);
    return out;
};

/**
 * Scales a vec2 by a scalar number
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec2} out
 */
vec2.scale = function(out, a, b) {
    out[0] = a[0] * b;
    out[1] = a[1] * b;
    return out;
};

/**
 * Adds two vec2's after scaling the second operand by a scalar value
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec2} out
 */
vec2.scaleAndAdd = function(out, a, b, scale) {
    out[0] = a[0] + (b[0] * scale);
    out[1] = a[1] + (b[1] * scale);
    return out;
};

/**
 * Calculates the euclidian distance between two vec2's
 *
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {Number} distance between a and b
 */
vec2.distance = function(a, b) {
    var x = b[0] - a[0],
        y = b[1] - a[1];
    return Math.sqrt(x*x + y*y);
};

/**
 * Alias for {@link vec2.distance}
 * @function
 */
vec2.dist = vec2.distance;

/**
 * Calculates the squared euclidian distance between two vec2's
 *
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {Number} squared distance between a and b
 */
vec2.squaredDistance = function(a, b) {
    var x = b[0] - a[0],
        y = b[1] - a[1];
    return x*x + y*y;
};

/**
 * Alias for {@link vec2.squaredDistance}
 * @function
 */
vec2.sqrDist = vec2.squaredDistance;

/**
 * Calculates the length of a vec2
 *
 * @param {vec2} a vector to calculate length of
 * @returns {Number} length of a
 */
vec2.length = function (a) {
    var x = a[0],
        y = a[1];
    return Math.sqrt(x*x + y*y);
};

/**
 * Alias for {@link vec2.length}
 * @function
 */
vec2.len = vec2.length;

/**
 * Calculates the squared length of a vec2
 *
 * @param {vec2} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */
vec2.squaredLength = function (a) {
    var x = a[0],
        y = a[1];
    return x*x + y*y;
};

/**
 * Alias for {@link vec2.squaredLength}
 * @function
 */
vec2.sqrLen = vec2.squaredLength;

/**
 * Negates the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to negate
 * @returns {vec2} out
 */
vec2.negate = function(out, a) {
    out[0] = -a[0];
    out[1] = -a[1];
    return out;
};

/**
 * Returns the inverse of the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to invert
 * @returns {vec2} out
 */
vec2.inverse = function(out, a) {
  out[0] = 1.0 / a[0];
  out[1] = 1.0 / a[1];
  return out;
};

/**
 * Normalize a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to normalize
 * @returns {vec2} out
 */
vec2.normalize = function(out, a) {
    var x = a[0],
        y = a[1];
    var len = x*x + y*y;
    if (len > 0) {
        //TODO: evaluate use of glm_invsqrt here?
        len = 1 / Math.sqrt(len);
        out[0] = a[0] * len;
        out[1] = a[1] * len;
    }
    return out;
};

/**
 * Calculates the dot product of two vec2's
 *
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {Number} dot product of a and b
 */
vec2.dot = function (a, b) {
    return a[0] * b[0] + a[1] * b[1];
};

/**
 * Computes the cross product of two vec2's
 * Note that the cross product must by definition produce a 3D vector
 *
 * @param {vec3} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec3} out
 */
vec2.cross = function(out, a, b) {
    var z = a[0] * b[1] - a[1] * b[0];
    out[0] = out[1] = 0;
    out[2] = z;
    return out;
};

/**
 * Performs a linear interpolation between two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {vec2} out
 */
vec2.lerp = function (out, a, b, t) {
    var ax = a[0],
        ay = a[1];
    out[0] = ax + t * (b[0] - ax);
    out[1] = ay + t * (b[1] - ay);
    return out;
};

/**
 * Generates a random vector with the given scale
 *
 * @param {vec2} out the receiving vector
 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
 * @returns {vec2} out
 */
vec2.random = function (out, scale) {
    scale = scale || 1.0;
    var r = glMatrix.RANDOM() * 2.0 * Math.PI;
    out[0] = Math.cos(r) * scale;
    out[1] = Math.sin(r) * scale;
    return out;
};

/**
 * Transforms the vec2 with a mat2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to transform
 * @param {mat2} m matrix to transform with
 * @returns {vec2} out
 */
vec2.transformMat2 = function(out, a, m) {
    var x = a[0],
        y = a[1];
    out[0] = m[0] * x + m[2] * y;
    out[1] = m[1] * x + m[3] * y;
    return out;
};

/**
 * Transforms the vec2 with a mat2d
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to transform
 * @param {mat2d} m matrix to transform with
 * @returns {vec2} out
 */
vec2.transformMat2d = function(out, a, m) {
    var x = a[0],
        y = a[1];
    out[0] = m[0] * x + m[2] * y + m[4];
    out[1] = m[1] * x + m[3] * y + m[5];
    return out;
};

/**
 * Transforms the vec2 with a mat3
 * 3rd vector component is implicitly '1'
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to transform
 * @param {mat3} m matrix to transform with
 * @returns {vec2} out
 */
vec2.transformMat3 = function(out, a, m) {
    var x = a[0],
        y = a[1];
    out[0] = m[0] * x + m[3] * y + m[6];
    out[1] = m[1] * x + m[4] * y + m[7];
    return out;
};

/**
 * Transforms the vec2 with a mat4
 * 3rd vector component is implicitly '0'
 * 4th vector component is implicitly '1'
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to transform
 * @param {mat4} m matrix to transform with
 * @returns {vec2} out
 */
vec2.transformMat4 = function(out, a, m) {
    var x = a[0], 
        y = a[1];
    out[0] = m[0] * x + m[4] * y + m[12];
    out[1] = m[1] * x + m[5] * y + m[13];
    return out;
};

/**
 * Perform some operation over an array of vec2s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec2. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec2s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 * @function
 */
vec2.forEach = (function() {
    var vec = vec2.create();

    return function(a, stride, offset, count, fn, arg) {
        var i, l;
        if(!stride) {
            stride = 2;
        }

        if(!offset) {
            offset = 0;
        }
        
        if(count) {
            l = Math.min((count * stride) + offset, a.length);
        } else {
            l = a.length;
        }

        for(i = offset; i < l; i += stride) {
            vec[0] = a[i]; vec[1] = a[i+1];
            fn(vec, vec, arg);
            a[i] = vec[0]; a[i+1] = vec[1];
        }
        
        return a;
    };
})();

/**
 * Returns a string representation of a vector
 *
 * @param {vec2} vec vector to represent as a string
 * @returns {String} string representation of the vector
 */
vec2.str = function (a) {
    return 'vec2(' + a[0] + ', ' + a[1] + ')';
};

/**
 * Returns whether or not the vectors exactly have the same elements in the same position (when compared with ===)
 *
 * @param {vec2} a The first vector.
 * @param {vec2} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */
vec2.exactEquals = function (a, b) {
    return a[0] === b[0] && a[1] === b[1];
};

/**
 * Returns whether or not the vectors have approximately the same elements in the same position.
 *
 * @param {vec2} a The first vector.
 * @param {vec2} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */
vec2.equals = function (a, b) {
    var a0 = a[0], a1 = a[1];
    var b0 = b[0], b1 = b[1];
    return (Math.abs(a0 - b0) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a0), Math.abs(b0)) &&
            Math.abs(a1 - b1) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a1), Math.abs(b1)));
};

module.exports = vec2;

},{"./common.js":125}],132:[function(require,module,exports){
/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE. */

var glMatrix = require("./common.js");

/**
 * @class 3 Dimensional Vector
 * @name vec3
 */
var vec3 = {};

/**
 * Creates a new, empty vec3
 *
 * @returns {vec3} a new 3D vector
 */
vec3.create = function() {
    var out = new glMatrix.ARRAY_TYPE(3);
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    return out;
};

/**
 * Creates a new vec3 initialized with values from an existing vector
 *
 * @param {vec3} a vector to clone
 * @returns {vec3} a new 3D vector
 */
vec3.clone = function(a) {
    var out = new glMatrix.ARRAY_TYPE(3);
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    return out;
};

/**
 * Creates a new vec3 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @returns {vec3} a new 3D vector
 */
vec3.fromValues = function(x, y, z) {
    var out = new glMatrix.ARRAY_TYPE(3);
    out[0] = x;
    out[1] = y;
    out[2] = z;
    return out;
};

/**
 * Copy the values from one vec3 to another
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the source vector
 * @returns {vec3} out
 */
vec3.copy = function(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    return out;
};

/**
 * Set the components of a vec3 to the given values
 *
 * @param {vec3} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @returns {vec3} out
 */
vec3.set = function(out, x, y, z) {
    out[0] = x;
    out[1] = y;
    out[2] = z;
    return out;
};

/**
 * Adds two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
vec3.add = function(out, a, b) {
    out[0] = a[0] + b[0];
    out[1] = a[1] + b[1];
    out[2] = a[2] + b[2];
    return out;
};

/**
 * Subtracts vector b from vector a
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
vec3.subtract = function(out, a, b) {
    out[0] = a[0] - b[0];
    out[1] = a[1] - b[1];
    out[2] = a[2] - b[2];
    return out;
};

/**
 * Alias for {@link vec3.subtract}
 * @function
 */
vec3.sub = vec3.subtract;

/**
 * Multiplies two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
vec3.multiply = function(out, a, b) {
    out[0] = a[0] * b[0];
    out[1] = a[1] * b[1];
    out[2] = a[2] * b[2];
    return out;
};

/**
 * Alias for {@link vec3.multiply}
 * @function
 */
vec3.mul = vec3.multiply;

/**
 * Divides two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
vec3.divide = function(out, a, b) {
    out[0] = a[0] / b[0];
    out[1] = a[1] / b[1];
    out[2] = a[2] / b[2];
    return out;
};

/**
 * Alias for {@link vec3.divide}
 * @function
 */
vec3.div = vec3.divide;

/**
 * Math.ceil the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to ceil
 * @returns {vec3} out
 */
vec3.ceil = function (out, a) {
    out[0] = Math.ceil(a[0]);
    out[1] = Math.ceil(a[1]);
    out[2] = Math.ceil(a[2]);
    return out;
};

/**
 * Math.floor the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to floor
 * @returns {vec3} out
 */
vec3.floor = function (out, a) {
    out[0] = Math.floor(a[0]);
    out[1] = Math.floor(a[1]);
    out[2] = Math.floor(a[2]);
    return out;
};

/**
 * Returns the minimum of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
vec3.min = function(out, a, b) {
    out[0] = Math.min(a[0], b[0]);
    out[1] = Math.min(a[1], b[1]);
    out[2] = Math.min(a[2], b[2]);
    return out;
};

/**
 * Returns the maximum of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
vec3.max = function(out, a, b) {
    out[0] = Math.max(a[0], b[0]);
    out[1] = Math.max(a[1], b[1]);
    out[2] = Math.max(a[2], b[2]);
    return out;
};

/**
 * Math.round the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to round
 * @returns {vec3} out
 */
vec3.round = function (out, a) {
    out[0] = Math.round(a[0]);
    out[1] = Math.round(a[1]);
    out[2] = Math.round(a[2]);
    return out;
};

/**
 * Scales a vec3 by a scalar number
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec3} out
 */
vec3.scale = function(out, a, b) {
    out[0] = a[0] * b;
    out[1] = a[1] * b;
    out[2] = a[2] * b;
    return out;
};

/**
 * Adds two vec3's after scaling the second operand by a scalar value
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec3} out
 */
vec3.scaleAndAdd = function(out, a, b, scale) {
    out[0] = a[0] + (b[0] * scale);
    out[1] = a[1] + (b[1] * scale);
    out[2] = a[2] + (b[2] * scale);
    return out;
};

/**
 * Calculates the euclidian distance between two vec3's
 *
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {Number} distance between a and b
 */
vec3.distance = function(a, b) {
    var x = b[0] - a[0],
        y = b[1] - a[1],
        z = b[2] - a[2];
    return Math.sqrt(x*x + y*y + z*z);
};

/**
 * Alias for {@link vec3.distance}
 * @function
 */
vec3.dist = vec3.distance;

/**
 * Calculates the squared euclidian distance between two vec3's
 *
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {Number} squared distance between a and b
 */
vec3.squaredDistance = function(a, b) {
    var x = b[0] - a[0],
        y = b[1] - a[1],
        z = b[2] - a[2];
    return x*x + y*y + z*z;
};

/**
 * Alias for {@link vec3.squaredDistance}
 * @function
 */
vec3.sqrDist = vec3.squaredDistance;

/**
 * Calculates the length of a vec3
 *
 * @param {vec3} a vector to calculate length of
 * @returns {Number} length of a
 */
vec3.length = function (a) {
    var x = a[0],
        y = a[1],
        z = a[2];
    return Math.sqrt(x*x + y*y + z*z);
};

/**
 * Alias for {@link vec3.length}
 * @function
 */
vec3.len = vec3.length;

/**
 * Calculates the squared length of a vec3
 *
 * @param {vec3} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */
vec3.squaredLength = function (a) {
    var x = a[0],
        y = a[1],
        z = a[2];
    return x*x + y*y + z*z;
};

/**
 * Alias for {@link vec3.squaredLength}
 * @function
 */
vec3.sqrLen = vec3.squaredLength;

/**
 * Negates the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to negate
 * @returns {vec3} out
 */
vec3.negate = function(out, a) {
    out[0] = -a[0];
    out[1] = -a[1];
    out[2] = -a[2];
    return out;
};

/**
 * Returns the inverse of the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to invert
 * @returns {vec3} out
 */
vec3.inverse = function(out, a) {
  out[0] = 1.0 / a[0];
  out[1] = 1.0 / a[1];
  out[2] = 1.0 / a[2];
  return out;
};

/**
 * Normalize a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to normalize
 * @returns {vec3} out
 */
vec3.normalize = function(out, a) {
    var x = a[0],
        y = a[1],
        z = a[2];
    var len = x*x + y*y + z*z;
    if (len > 0) {
        //TODO: evaluate use of glm_invsqrt here?
        len = 1 / Math.sqrt(len);
        out[0] = a[0] * len;
        out[1] = a[1] * len;
        out[2] = a[2] * len;
    }
    return out;
};

/**
 * Calculates the dot product of two vec3's
 *
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {Number} dot product of a and b
 */
vec3.dot = function (a, b) {
    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
};

/**
 * Computes the cross product of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
vec3.cross = function(out, a, b) {
    var ax = a[0], ay = a[1], az = a[2],
        bx = b[0], by = b[1], bz = b[2];

    out[0] = ay * bz - az * by;
    out[1] = az * bx - ax * bz;
    out[2] = ax * by - ay * bx;
    return out;
};

/**
 * Performs a linear interpolation between two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {vec3} out
 */
vec3.lerp = function (out, a, b, t) {
    var ax = a[0],
        ay = a[1],
        az = a[2];
    out[0] = ax + t * (b[0] - ax);
    out[1] = ay + t * (b[1] - ay);
    out[2] = az + t * (b[2] - az);
    return out;
};

/**
 * Performs a hermite interpolation with two control points
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @param {vec3} c the third operand
 * @param {vec3} d the fourth operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {vec3} out
 */
vec3.hermite = function (out, a, b, c, d, t) {
  var factorTimes2 = t * t,
      factor1 = factorTimes2 * (2 * t - 3) + 1,
      factor2 = factorTimes2 * (t - 2) + t,
      factor3 = factorTimes2 * (t - 1),
      factor4 = factorTimes2 * (3 - 2 * t);
  
  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;
  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;
  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;
  
  return out;
};

/**
 * Performs a bezier interpolation with two control points
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @param {vec3} c the third operand
 * @param {vec3} d the fourth operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {vec3} out
 */
vec3.bezier = function (out, a, b, c, d, t) {
  var inverseFactor = 1 - t,
      inverseFactorTimesTwo = inverseFactor * inverseFactor,
      factorTimes2 = t * t,
      factor1 = inverseFactorTimesTwo * inverseFactor,
      factor2 = 3 * t * inverseFactorTimesTwo,
      factor3 = 3 * factorTimes2 * inverseFactor,
      factor4 = factorTimes2 * t;
  
  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;
  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;
  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;
  
  return out;
};

/**
 * Generates a random vector with the given scale
 *
 * @param {vec3} out the receiving vector
 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
 * @returns {vec3} out
 */
vec3.random = function (out, scale) {
    scale = scale || 1.0;

    var r = glMatrix.RANDOM() * 2.0 * Math.PI;
    var z = (glMatrix.RANDOM() * 2.0) - 1.0;
    var zScale = Math.sqrt(1.0-z*z) * scale;

    out[0] = Math.cos(r) * zScale;
    out[1] = Math.sin(r) * zScale;
    out[2] = z * scale;
    return out;
};

/**
 * Transforms the vec3 with a mat4.
 * 4th vector component is implicitly '1'
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to transform
 * @param {mat4} m matrix to transform with
 * @returns {vec3} out
 */
vec3.transformMat4 = function(out, a, m) {
    var x = a[0], y = a[1], z = a[2],
        w = m[3] * x + m[7] * y + m[11] * z + m[15];
    w = w || 1.0;
    out[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w;
    out[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w;
    out[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w;
    return out;
};

/**
 * Transforms the vec3 with a mat3.
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to transform
 * @param {mat4} m the 3x3 matrix to transform with
 * @returns {vec3} out
 */
vec3.transformMat3 = function(out, a, m) {
    var x = a[0], y = a[1], z = a[2];
    out[0] = x * m[0] + y * m[3] + z * m[6];
    out[1] = x * m[1] + y * m[4] + z * m[7];
    out[2] = x * m[2] + y * m[5] + z * m[8];
    return out;
};

/**
 * Transforms the vec3 with a quat
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to transform
 * @param {quat} q quaternion to transform with
 * @returns {vec3} out
 */
vec3.transformQuat = function(out, a, q) {
    // benchmarks: http://jsperf.com/quaternion-transform-vec3-implementations

    var x = a[0], y = a[1], z = a[2],
        qx = q[0], qy = q[1], qz = q[2], qw = q[3],

        // calculate quat * vec
        ix = qw * x + qy * z - qz * y,
        iy = qw * y + qz * x - qx * z,
        iz = qw * z + qx * y - qy * x,
        iw = -qx * x - qy * y - qz * z;

    // calculate result * inverse quat
    out[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;
    out[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;
    out[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;
    return out;
};

/**
 * Rotate a 3D vector around the x-axis
 * @param {vec3} out The receiving vec3
 * @param {vec3} a The vec3 point to rotate
 * @param {vec3} b The origin of the rotation
 * @param {Number} c The angle of rotation
 * @returns {vec3} out
 */
vec3.rotateX = function(out, a, b, c){
   var p = [], r=[];
	  //Translate point to the origin
	  p[0] = a[0] - b[0];
	  p[1] = a[1] - b[1];
  	p[2] = a[2] - b[2];

	  //perform rotation
	  r[0] = p[0];
	  r[1] = p[1]*Math.cos(c) - p[2]*Math.sin(c);
	  r[2] = p[1]*Math.sin(c) + p[2]*Math.cos(c);

	  //translate to correct position
	  out[0] = r[0] + b[0];
	  out[1] = r[1] + b[1];
	  out[2] = r[2] + b[2];

  	return out;
};

/**
 * Rotate a 3D vector around the y-axis
 * @param {vec3} out The receiving vec3
 * @param {vec3} a The vec3 point to rotate
 * @param {vec3} b The origin of the rotation
 * @param {Number} c The angle of rotation
 * @returns {vec3} out
 */
vec3.rotateY = function(out, a, b, c){
  	var p = [], r=[];
  	//Translate point to the origin
  	p[0] = a[0] - b[0];
  	p[1] = a[1] - b[1];
  	p[2] = a[2] - b[2];
  
  	//perform rotation
  	r[0] = p[2]*Math.sin(c) + p[0]*Math.cos(c);
  	r[1] = p[1];
  	r[2] = p[2]*Math.cos(c) - p[0]*Math.sin(c);
  
  	//translate to correct position
  	out[0] = r[0] + b[0];
  	out[1] = r[1] + b[1];
  	out[2] = r[2] + b[2];
  
  	return out;
};

/**
 * Rotate a 3D vector around the z-axis
 * @param {vec3} out The receiving vec3
 * @param {vec3} a The vec3 point to rotate
 * @param {vec3} b The origin of the rotation
 * @param {Number} c The angle of rotation
 * @returns {vec3} out
 */
vec3.rotateZ = function(out, a, b, c){
  	var p = [], r=[];
  	//Translate point to the origin
  	p[0] = a[0] - b[0];
  	p[1] = a[1] - b[1];
  	p[2] = a[2] - b[2];
  
  	//perform rotation
  	r[0] = p[0]*Math.cos(c) - p[1]*Math.sin(c);
  	r[1] = p[0]*Math.sin(c) + p[1]*Math.cos(c);
  	r[2] = p[2];
  
  	//translate to correct position
  	out[0] = r[0] + b[0];
  	out[1] = r[1] + b[1];
  	out[2] = r[2] + b[2];
  
  	return out;
};

/**
 * Perform some operation over an array of vec3s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec3. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec3s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 * @function
 */
vec3.forEach = (function() {
    var vec = vec3.create();

    return function(a, stride, offset, count, fn, arg) {
        var i, l;
        if(!stride) {
            stride = 3;
        }

        if(!offset) {
            offset = 0;
        }
        
        if(count) {
            l = Math.min((count * stride) + offset, a.length);
        } else {
            l = a.length;
        }

        for(i = offset; i < l; i += stride) {
            vec[0] = a[i]; vec[1] = a[i+1]; vec[2] = a[i+2];
            fn(vec, vec, arg);
            a[i] = vec[0]; a[i+1] = vec[1]; a[i+2] = vec[2];
        }
        
        return a;
    };
})();

/**
 * Get the angle between two 3D vectors
 * @param {vec3} a The first operand
 * @param {vec3} b The second operand
 * @returns {Number} The angle in radians
 */
vec3.angle = function(a, b) {
   
    var tempA = vec3.fromValues(a[0], a[1], a[2]);
    var tempB = vec3.fromValues(b[0], b[1], b[2]);
 
    vec3.normalize(tempA, tempA);
    vec3.normalize(tempB, tempB);
 
    var cosine = vec3.dot(tempA, tempB);

    if(cosine > 1.0){
        return 0;
    } else {
        return Math.acos(cosine);
    }     
};

/**
 * Returns a string representation of a vector
 *
 * @param {vec3} vec vector to represent as a string
 * @returns {String} string representation of the vector
 */
vec3.str = function (a) {
    return 'vec3(' + a[0] + ', ' + a[1] + ', ' + a[2] + ')';
};

/**
 * Returns whether or not the vectors have exactly the same elements in the same position (when compared with ===)
 *
 * @param {vec3} a The first vector.
 * @param {vec3} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */
vec3.exactEquals = function (a, b) {
    return a[0] === b[0] && a[1] === b[1] && a[2] === b[2];
};

/**
 * Returns whether or not the vectors have approximately the same elements in the same position.
 *
 * @param {vec3} a The first vector.
 * @param {vec3} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */
vec3.equals = function (a, b) {
    var a0 = a[0], a1 = a[1], a2 = a[2];
    var b0 = b[0], b1 = b[1], b2 = b[2];
    return (Math.abs(a0 - b0) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a0), Math.abs(b0)) &&
            Math.abs(a1 - b1) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a1), Math.abs(b1)) &&
            Math.abs(a2 - b2) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a2), Math.abs(b2)));
};

module.exports = vec3;

},{"./common.js":125}],133:[function(require,module,exports){
/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE. */

var glMatrix = require("./common.js");

/**
 * @class 4 Dimensional Vector
 * @name vec4
 */
var vec4 = {};

/**
 * Creates a new, empty vec4
 *
 * @returns {vec4} a new 4D vector
 */
vec4.create = function() {
    var out = new glMatrix.ARRAY_TYPE(4);
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    return out;
};

/**
 * Creates a new vec4 initialized with values from an existing vector
 *
 * @param {vec4} a vector to clone
 * @returns {vec4} a new 4D vector
 */
vec4.clone = function(a) {
    var out = new glMatrix.ARRAY_TYPE(4);
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    return out;
};

/**
 * Creates a new vec4 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {vec4} a new 4D vector
 */
vec4.fromValues = function(x, y, z, w) {
    var out = new glMatrix.ARRAY_TYPE(4);
    out[0] = x;
    out[1] = y;
    out[2] = z;
    out[3] = w;
    return out;
};

/**
 * Copy the values from one vec4 to another
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the source vector
 * @returns {vec4} out
 */
vec4.copy = function(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    return out;
};

/**
 * Set the components of a vec4 to the given values
 *
 * @param {vec4} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {vec4} out
 */
vec4.set = function(out, x, y, z, w) {
    out[0] = x;
    out[1] = y;
    out[2] = z;
    out[3] = w;
    return out;
};

/**
 * Adds two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */
vec4.add = function(out, a, b) {
    out[0] = a[0] + b[0];
    out[1] = a[1] + b[1];
    out[2] = a[2] + b[2];
    out[3] = a[3] + b[3];
    return out;
};

/**
 * Subtracts vector b from vector a
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */
vec4.subtract = function(out, a, b) {
    out[0] = a[0] - b[0];
    out[1] = a[1] - b[1];
    out[2] = a[2] - b[2];
    out[3] = a[3] - b[3];
    return out;
};

/**
 * Alias for {@link vec4.subtract}
 * @function
 */
vec4.sub = vec4.subtract;

/**
 * Multiplies two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */
vec4.multiply = function(out, a, b) {
    out[0] = a[0] * b[0];
    out[1] = a[1] * b[1];
    out[2] = a[2] * b[2];
    out[3] = a[3] * b[3];
    return out;
};

/**
 * Alias for {@link vec4.multiply}
 * @function
 */
vec4.mul = vec4.multiply;

/**
 * Divides two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */
vec4.divide = function(out, a, b) {
    out[0] = a[0] / b[0];
    out[1] = a[1] / b[1];
    out[2] = a[2] / b[2];
    out[3] = a[3] / b[3];
    return out;
};

/**
 * Alias for {@link vec4.divide}
 * @function
 */
vec4.div = vec4.divide;

/**
 * Math.ceil the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to ceil
 * @returns {vec4} out
 */
vec4.ceil = function (out, a) {
    out[0] = Math.ceil(a[0]);
    out[1] = Math.ceil(a[1]);
    out[2] = Math.ceil(a[2]);
    out[3] = Math.ceil(a[3]);
    return out;
};

/**
 * Math.floor the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to floor
 * @returns {vec4} out
 */
vec4.floor = function (out, a) {
    out[0] = Math.floor(a[0]);
    out[1] = Math.floor(a[1]);
    out[2] = Math.floor(a[2]);
    out[3] = Math.floor(a[3]);
    return out;
};

/**
 * Returns the minimum of two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */
vec4.min = function(out, a, b) {
    out[0] = Math.min(a[0], b[0]);
    out[1] = Math.min(a[1], b[1]);
    out[2] = Math.min(a[2], b[2]);
    out[3] = Math.min(a[3], b[3]);
    return out;
};

/**
 * Returns the maximum of two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */
vec4.max = function(out, a, b) {
    out[0] = Math.max(a[0], b[0]);
    out[1] = Math.max(a[1], b[1]);
    out[2] = Math.max(a[2], b[2]);
    out[3] = Math.max(a[3], b[3]);
    return out;
};

/**
 * Math.round the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to round
 * @returns {vec4} out
 */
vec4.round = function (out, a) {
    out[0] = Math.round(a[0]);
    out[1] = Math.round(a[1]);
    out[2] = Math.round(a[2]);
    out[3] = Math.round(a[3]);
    return out;
};

/**
 * Scales a vec4 by a scalar number
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec4} out
 */
vec4.scale = function(out, a, b) {
    out[0] = a[0] * b;
    out[1] = a[1] * b;
    out[2] = a[2] * b;
    out[3] = a[3] * b;
    return out;
};

/**
 * Adds two vec4's after scaling the second operand by a scalar value
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec4} out
 */
vec4.scaleAndAdd = function(out, a, b, scale) {
    out[0] = a[0] + (b[0] * scale);
    out[1] = a[1] + (b[1] * scale);
    out[2] = a[2] + (b[2] * scale);
    out[3] = a[3] + (b[3] * scale);
    return out;
};

/**
 * Calculates the euclidian distance between two vec4's
 *
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {Number} distance between a and b
 */
vec4.distance = function(a, b) {
    var x = b[0] - a[0],
        y = b[1] - a[1],
        z = b[2] - a[2],
        w = b[3] - a[3];
    return Math.sqrt(x*x + y*y + z*z + w*w);
};

/**
 * Alias for {@link vec4.distance}
 * @function
 */
vec4.dist = vec4.distance;

/**
 * Calculates the squared euclidian distance between two vec4's
 *
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {Number} squared distance between a and b
 */
vec4.squaredDistance = function(a, b) {
    var x = b[0] - a[0],
        y = b[1] - a[1],
        z = b[2] - a[2],
        w = b[3] - a[3];
    return x*x + y*y + z*z + w*w;
};

/**
 * Alias for {@link vec4.squaredDistance}
 * @function
 */
vec4.sqrDist = vec4.squaredDistance;

/**
 * Calculates the length of a vec4
 *
 * @param {vec4} a vector to calculate length of
 * @returns {Number} length of a
 */
vec4.length = function (a) {
    var x = a[0],
        y = a[1],
        z = a[2],
        w = a[3];
    return Math.sqrt(x*x + y*y + z*z + w*w);
};

/**
 * Alias for {@link vec4.length}
 * @function
 */
vec4.len = vec4.length;

/**
 * Calculates the squared length of a vec4
 *
 * @param {vec4} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */
vec4.squaredLength = function (a) {
    var x = a[0],
        y = a[1],
        z = a[2],
        w = a[3];
    return x*x + y*y + z*z + w*w;
};

/**
 * Alias for {@link vec4.squaredLength}
 * @function
 */
vec4.sqrLen = vec4.squaredLength;

/**
 * Negates the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to negate
 * @returns {vec4} out
 */
vec4.negate = function(out, a) {
    out[0] = -a[0];
    out[1] = -a[1];
    out[2] = -a[2];
    out[3] = -a[3];
    return out;
};

/**
 * Returns the inverse of the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to invert
 * @returns {vec4} out
 */
vec4.inverse = function(out, a) {
  out[0] = 1.0 / a[0];
  out[1] = 1.0 / a[1];
  out[2] = 1.0 / a[2];
  out[3] = 1.0 / a[3];
  return out;
};

/**
 * Normalize a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to normalize
 * @returns {vec4} out
 */
vec4.normalize = function(out, a) {
    var x = a[0],
        y = a[1],
        z = a[2],
        w = a[3];
    var len = x*x + y*y + z*z + w*w;
    if (len > 0) {
        len = 1 / Math.sqrt(len);
        out[0] = x * len;
        out[1] = y * len;
        out[2] = z * len;
        out[3] = w * len;
    }
    return out;
};

/**
 * Calculates the dot product of two vec4's
 *
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {Number} dot product of a and b
 */
vec4.dot = function (a, b) {
    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];
};

/**
 * Performs a linear interpolation between two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {vec4} out
 */
vec4.lerp = function (out, a, b, t) {
    var ax = a[0],
        ay = a[1],
        az = a[2],
        aw = a[3];
    out[0] = ax + t * (b[0] - ax);
    out[1] = ay + t * (b[1] - ay);
    out[2] = az + t * (b[2] - az);
    out[3] = aw + t * (b[3] - aw);
    return out;
};

/**
 * Generates a random vector with the given scale
 *
 * @param {vec4} out the receiving vector
 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
 * @returns {vec4} out
 */
vec4.random = function (out, scale) {
    scale = scale || 1.0;

    //TODO: This is a pretty awful way of doing this. Find something better.
    out[0] = glMatrix.RANDOM();
    out[1] = glMatrix.RANDOM();
    out[2] = glMatrix.RANDOM();
    out[3] = glMatrix.RANDOM();
    vec4.normalize(out, out);
    vec4.scale(out, out, scale);
    return out;
};

/**
 * Transforms the vec4 with a mat4.
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the vector to transform
 * @param {mat4} m matrix to transform with
 * @returns {vec4} out
 */
vec4.transformMat4 = function(out, a, m) {
    var x = a[0], y = a[1], z = a[2], w = a[3];
    out[0] = m[0] * x + m[4] * y + m[8] * z + m[12] * w;
    out[1] = m[1] * x + m[5] * y + m[9] * z + m[13] * w;
    out[2] = m[2] * x + m[6] * y + m[10] * z + m[14] * w;
    out[3] = m[3] * x + m[7] * y + m[11] * z + m[15] * w;
    return out;
};

/**
 * Transforms the vec4 with a quat
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the vector to transform
 * @param {quat} q quaternion to transform with
 * @returns {vec4} out
 */
vec4.transformQuat = function(out, a, q) {
    var x = a[0], y = a[1], z = a[2],
        qx = q[0], qy = q[1], qz = q[2], qw = q[3],

        // calculate quat * vec
        ix = qw * x + qy * z - qz * y,
        iy = qw * y + qz * x - qx * z,
        iz = qw * z + qx * y - qy * x,
        iw = -qx * x - qy * y - qz * z;

    // calculate result * inverse quat
    out[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;
    out[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;
    out[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;
    out[3] = a[3];
    return out;
};

/**
 * Perform some operation over an array of vec4s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec4. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec4s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 * @function
 */
vec4.forEach = (function() {
    var vec = vec4.create();

    return function(a, stride, offset, count, fn, arg) {
        var i, l;
        if(!stride) {
            stride = 4;
        }

        if(!offset) {
            offset = 0;
        }
        
        if(count) {
            l = Math.min((count * stride) + offset, a.length);
        } else {
            l = a.length;
        }

        for(i = offset; i < l; i += stride) {
            vec[0] = a[i]; vec[1] = a[i+1]; vec[2] = a[i+2]; vec[3] = a[i+3];
            fn(vec, vec, arg);
            a[i] = vec[0]; a[i+1] = vec[1]; a[i+2] = vec[2]; a[i+3] = vec[3];
        }
        
        return a;
    };
})();

/**
 * Returns a string representation of a vector
 *
 * @param {vec4} vec vector to represent as a string
 * @returns {String} string representation of the vector
 */
vec4.str = function (a) {
    return 'vec4(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ')';
};

/**
 * Returns whether or not the vectors have exactly the same elements in the same position (when compared with ===)
 *
 * @param {vec4} a The first vector.
 * @param {vec4} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */
vec4.exactEquals = function (a, b) {
    return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3];
};

/**
 * Returns whether or not the vectors have approximately the same elements in the same position.
 *
 * @param {vec4} a The first vector.
 * @param {vec4} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */
vec4.equals = function (a, b) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3];
    var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
    return (Math.abs(a0 - b0) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a0), Math.abs(b0)) &&
            Math.abs(a1 - b1) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a1), Math.abs(b1)) &&
            Math.abs(a2 - b2) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a2), Math.abs(b2)) &&
            Math.abs(a3 - b3) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a3), Math.abs(b3)));
};

module.exports = vec4;

},{"./common.js":125}],134:[function(require,module,exports){
'use strict';

function constant(value) {
    return function() {
        return value;
    }
}

function interpolateNumber(a, b, t) {
    return (a * (1 - t)) + (b * t);
}

function interpolateArray(a, b, t) {
    var result = [];
    for (var i = 0; i < a.length; i++) {
        result[i] = interpolateNumber(a[i], b[i], t);
    }
    return result;
}

exports['interpolated'] = function(f) {
    if (!f.stops) {
        return constant(f);
    }

    var stops = f.stops,
        base = f.base || 1,
        interpolate = Array.isArray(stops[0][1]) ? interpolateArray : interpolateNumber;

    return function(z) {
        // find the two stops which the current z is between
        var low, high;

        for (var i = 0; i < stops.length; i++) {
            var stop = stops[i];

            if (stop[0] <= z) {
                low = stop;
            }

            if (stop[0] > z) {
                high = stop;
                break;
            }
        }

        if (low && high) {
            var zoomDiff = high[0] - low[0],
                zoomProgress = z - low[0],

                t = base === 1 ?
                zoomProgress / zoomDiff :
                (Math.pow(base, zoomProgress) - 1) / (Math.pow(base, zoomDiff) - 1);

            return interpolate(low[1], high[1], t);

        } else if (low) {
            return low[1];

        } else if (high) {
            return high[1];
        }
    };
};

exports['piecewise-constant'] = function(f) {
    if (!f.stops) {
        return constant(f);
    }

    var stops = f.stops;

    return function(z) {
        for (var i = 0; i < stops.length; i++) {
            if (stops[i][0] > z) {
                return stops[i === 0 ? 0 : i - 1][1];
            }
        }

        return stops[stops.length - 1][1];
    }
};

},{}],135:[function(require,module,exports){
'use strict';

var format = require('util').format;

function ValidationError(key, value /*, message, ...*/) {
    this.message = (
        (key ? key + ': ' : '') +
        format.apply(format, Array.prototype.slice.call(arguments, 2))
    );

    if (value !== null && value !== undefined && value.__line__) {
        this.line = value.__line__;
    }
}

module.exports = ValidationError;

},{"util":111}],136:[function(require,module,exports){
'use strict';

module.exports = function (output) {
    for (var i = 1; i < arguments.length; i++) {
        var input = arguments[i];
        for (var k in input) {
            output[k] = input[k];
        }
    }
    return output;
};

},{}],137:[function(require,module,exports){
'use strict';

module.exports = function getType(val) {
    if (val instanceof Number) {
        return 'number';
    } else if (val instanceof String) {
        return 'string';
    } else if (val instanceof Boolean) {
        return 'boolean';
    } else if (Array.isArray(val)) {
        return 'array';
    } else if (val === null) {
        return 'null';
    } else {
        return typeof val;
    }
};

},{}],138:[function(require,module,exports){
'use strict';

/**
 * Turn jsonlint-lines-primitives objects into primitive objects
 * @param value a potentially-bundled value
 * @returns an unbundled value
 */
module.exports = function unbundle(value) {
    if (value instanceof Number || value instanceof String || value instanceof Boolean) {
        return value.valueOf();
    } else {
        return value;
    }
};

},{}],139:[function(require,module,exports){
'use strict';

var ValidationError = require('../error/validation_error');
var getType = require('../util/get_type');
var extend = require('../util/extend');

// Main recursive validation function. Tracks:
//
// - key: string representing location of validation in style tree. Used only
//   for more informative error reporting.
// - value: current value from style being evaluated. May be anything from a
//   high level object that needs to be descended into deeper or a simple
//   scalar value.
// - valueSpec: current spec being evaluated. Tracks value.

module.exports = function validate(options) {

    var validateFunction = require('./validate_function');
    var validateObject = require('./validate_object');
    var VALIDATORS = {
        '*': function() {
            return [];
        },
        'array': require('./validate_array'),
        'boolean': require('./validate_boolean'),
        'number': require('./validate_number'),
        'color': require('./validate_color'),
        'constants': require('./validate_constants'),
        'enum': require('./validate_enum'),
        'filter': require('./validate_filter'),
        'function': require('./validate_function'),
        'layer': require('./validate_layer'),
        'object': require('./validate_object'),
        'source': require('./validate_source'),
        'string': require('./validate_string')
    };

    var value = options.value;
    var valueSpec = options.valueSpec;
    var key = options.key;
    var styleSpec = options.styleSpec;
    var style = options.style;

    if (getType(value) === 'string' && value[0] === '@') {
        if (styleSpec.$version > 7) {
            return [new ValidationError(key, value, 'constants have been deprecated as of v8')];
        }
        if (!(value in style.constants)) {
            return [new ValidationError(key, value, 'constant "%s" not found', value)];
        }
        options = extend({}, options, { value: style.constants[value] });
    }

    if (valueSpec.function && getType(value) === 'object') {
        return validateFunction(options);

    } else if (valueSpec.type && VALIDATORS[valueSpec.type]) {
        return VALIDATORS[valueSpec.type](options);

    } else {
        return validateObject(extend({}, options, {
            valueSpec: valueSpec.type ? styleSpec[valueSpec.type] : valueSpec
        }));
    }
};

},{"../error/validation_error":135,"../util/extend":136,"../util/get_type":137,"./validate_array":140,"./validate_boolean":141,"./validate_color":142,"./validate_constants":143,"./validate_enum":144,"./validate_filter":145,"./validate_function":146,"./validate_layer":147,"./validate_number":149,"./validate_object":150,"./validate_source":152,"./validate_string":153}],140:[function(require,module,exports){
'use strict';

var getType = require('../util/get_type');
var validate = require('./validate');
var ValidationError = require('../error/validation_error');

module.exports = function validateArray(options) {
    var array = options.value;
    var arraySpec = options.valueSpec;
    var style = options.style;
    var styleSpec = options.styleSpec;
    var key = options.key;
    var validateArrayElement = options.arrayElementValidator || validate;

    if (getType(array) !== 'array') {
        return [new ValidationError(key, array, 'array expected, %s found', getType(array))];
    }

    if (arraySpec.length && array.length !== arraySpec.length) {
        return [new ValidationError(key, array, 'array length %d expected, length %d found', arraySpec.length, array.length)];
    }

    if (arraySpec['min-length'] && array.length < arraySpec['min-length']) {
        return [new ValidationError(key, array, 'array length at least %d expected, length %d found', arraySpec['min-length'], array.length)];
    }

    var arrayElementSpec = {
        "type": arraySpec.value
    };

    if (styleSpec.$version < 7) {
        arrayElementSpec.function = arraySpec.function;
    }

    if (getType(arraySpec.value) === 'object') {
        arrayElementSpec = arraySpec.value;
    }

    var errors = [];
    for (var i = 0; i < array.length; i++) {
        errors = errors.concat(validateArrayElement({
            array: array,
            arrayIndex: i,
            value: array[i],
            valueSpec: arrayElementSpec,
            style: style,
            styleSpec: styleSpec,
            key: key + '[' + i + ']'
        }));
    }
    return errors;
};

},{"../error/validation_error":135,"../util/get_type":137,"./validate":139}],141:[function(require,module,exports){
'use strict';

var getType = require('../util/get_type');
var ValidationError = require('../error/validation_error');

module.exports = function validateBoolean(options) {
    var value = options.value;
    var key = options.key;
    var type = getType(value);

    if (type !== 'boolean') {
        return [new ValidationError(key, value, 'boolean expected, %s found', type)];
    }

    return [];
};

},{"../error/validation_error":135,"../util/get_type":137}],142:[function(require,module,exports){
'use strict';

var ValidationError = require('../error/validation_error');
var getType = require('../util/get_type');
var parseCSSColor = require('csscolorparser').parseCSSColor;

module.exports = function validateColor(options) {
    var key = options.key;
    var value = options.value;
    var type = getType(value);

    if (type !== 'string') {
        return [new ValidationError(key, value, 'color expected, %s found', type)];
    }

    if (parseCSSColor(value) === null) {
        return [new ValidationError(key, value, 'color expected, "%s" found', value)];
    }

    return [];
};

},{"../error/validation_error":135,"../util/get_type":137,"csscolorparser":112}],143:[function(require,module,exports){
'use strict';

var ValidationError = require('../error/validation_error');
var getType = require('../util/get_type');

module.exports = function validateConstants(options) {
    var key = options.key;
    var constants = options.value;
    var styleSpec = options.styleSpec;

    if (styleSpec.$version > 7) {
        if (constants) {
            return [new ValidationError(key, constants, 'constants have been deprecated as of v8')];
        } else {
            return [];
        }
    } else {
        var type = getType(constants);
        if (type !== 'object') {
            return [new ValidationError(key, constants, 'object expected, %s found', type)];
        }

        var errors = [];
        for (var constantName in constants) {
            if (constantName[0] !== '@') {
                errors.push(new ValidationError(key + '.' + constantName, constants[constantName], 'constants must start with "@"'));
            }
        }
        return errors;
    }

};

},{"../error/validation_error":135,"../util/get_type":137}],144:[function(require,module,exports){
'use strict';

var ValidationError = require('../error/validation_error');
var unbundle = require('../util/unbundle_jsonlint');

module.exports = function validateEnum(options) {
    var key = options.key;
    var value = options.value;
    var valueSpec = options.valueSpec;
    var errors = [];

    if (valueSpec.values.indexOf(unbundle(value)) === -1) {
        errors.push(new ValidationError(key, value, 'expected one of [%s], %s found', valueSpec.values.join(', '), value));
    }
    return errors;
};

},{"../error/validation_error":135,"../util/unbundle_jsonlint":138}],145:[function(require,module,exports){
'use strict';

var ValidationError = require('../error/validation_error');
var validateEnum = require('./validate_enum');
var getType = require('../util/get_type');
var unbundle = require('../util/unbundle_jsonlint');

module.exports = function validateFilter(options) {
    var value = options.value;
    var key = options.key;
    var styleSpec = options.styleSpec;
    var type;

    var errors = [];

    if (getType(value) !== 'array') {
        return [new ValidationError(key, value, 'array expected, %s found', getType(value))];
    }

    if (value.length < 1) {
        return [new ValidationError(key, value, 'filter array must have at least 1 element')];
    }

    errors = errors.concat(validateEnum({
        key: key + '[0]',
        value: value[0],
        valueSpec: styleSpec.filter_operator,
        style: options.style,
        styleSpec: options.styleSpec
    }));

    switch (unbundle(value[0])) {
        case '<':
        case '<=':
        case '>':
        case '>=':
            if (value.length >= 2 && value[1] == '$type') {
                errors.push(new ValidationError(key, value, '"$type" cannot be use with operator "%s"', value[0]));
            }
        /* falls through */
        case '==':
        case '!=':
            if (value.length != 3) {
                errors.push(new ValidationError(key, value, 'filter array for operator "%s" must have 3 elements', value[0]));
            }
        /* falls through */
        case 'in':
        case '!in':
            if (value.length >= 2) {
                type = getType(value[1]);
                if (type !== 'string') {
                    errors.push(new ValidationError(key + '[1]', value[1], 'string expected, %s found', type));
                } else if (value[1][0] === '@') {
                    errors.push(new ValidationError(key + '[1]', value[1], 'filter key cannot be a constant'));
                }
            }
            for (var i = 2; i < value.length; i++) {
                type = getType(value[i]);
                if (value[1] == '$type') {
                    errors = errors.concat(validateEnum({
                        key: key + '[' + i + ']',
                        value: value[i],
                        valueSpec: styleSpec.geometry_type,
                        style: options.style,
                        styleSpec: options.styleSpec
                    }));
                } else if (type === 'string' && value[i][0] === '@') {
                    errors.push(new ValidationError(key + '[' + i + ']', value[i], 'filter value cannot be a constant'));
                } else if (type !== 'string' && type !== 'number' && type !== 'boolean') {
                    errors.push(new ValidationError(key + '[' + i + ']', value[i], 'string, number, or boolean expected, %s found', type));
                }
            }
            break;

        case 'any':
        case 'all':
        case 'none':
            for (i = 1; i < value.length; i++) {
                errors = errors.concat(validateFilter({
                    key: key + '[' + i + ']',
                    value: value[i],
                    style: options.style,
                    styleSpec: options.styleSpec
                }));
            }
            break;
    }

    return errors;
};

},{"../error/validation_error":135,"../util/get_type":137,"../util/unbundle_jsonlint":138,"./validate_enum":144}],146:[function(require,module,exports){
'use strict';

var ValidationError = require('../error/validation_error');
var getType = require('../util/get_type');
var validate = require('./validate');
var validateObject = require('./validate_object');
var validateArray = require('./validate_array');

module.exports = function validateFunction(options) {
    var originalValueSpec = options.valueSpec;

    return validateObject({
        key: options.key,
        value: options.value,
        valueSpec: options.styleSpec.function,
        style: options.style,
        styleSpec: options.styleSpec,
        objectElementValidators: { stops: validateFunctionStops }
    });

    function validateFunctionStops(options) {
        var errors = [];
        var value = options.value;

        errors = errors.concat(validateArray({
            key: options.key,
            value: value,
            valueSpec: options.valueSpec,
            style: options.style,
            styleSpec: options.styleSpec,
            arrayElementValidator: validateFunctionStop
        }));

        if (getType(value) === 'array' && value.length === 0) {
            errors.push(new ValidationError(options.key, value, 'array must have at least one stop'));
        }

        return errors;
    }

    function validateFunctionStop(options) {
        var errors = [];
        var value = options.value;
        var key = options.key;

        if (getType(value) !== 'array') {
            return [new ValidationError(key, value, 'array expected, %s found', getType(value))];
        }

        if (value.length !== 2) {
            return [new ValidationError(key, value, 'array length %d expected, length %d found', 2, value.length)];
        }

        errors = errors.concat(validate({
            key: key + '[0]',
            value: value[0],
            valueSpec: {type: 'number'},
            style: options.style,
            styleSpec: options.styleSpec
        }));

        errors = errors.concat(validate({
            key: key + '[1]',
            value: value[1],
            valueSpec: originalValueSpec,
            style: options.style,
            styleSpec: options.styleSpec
        }));

        if (getType(value[0]) === 'number') {
            if (originalValueSpec.function === 'piecewise-constant' && value[0] % 1 !== 0) {
                errors.push(new ValidationError(key + '[0]', value[0], 'zoom level for piecewise-constant functions must be an integer'));
            }

            if (options.arrayIndex !== 0) {
                if (value[0] < options.array[options.arrayIndex - 1][0]) {
                    errors.push(new ValidationError(key + '[0]', value[0], 'array stops must appear in ascending order'));
                }
            }
        }

        return errors;
    }

};

},{"../error/validation_error":135,"../util/get_type":137,"./validate":139,"./validate_array":140,"./validate_object":150}],147:[function(require,module,exports){
'use strict';

var ValidationError = require('../error/validation_error');
var unbundle = require('../util/unbundle_jsonlint');
var validateObject = require('./validate_object');
var validateFilter = require('./validate_filter');
var validatePaintProperty = require('./validate_paint_property');
var validateLayoutProperty = require('./validate_layout_property');
var extend = require('../util/extend');

module.exports = function validateLayer(options) {
    var errors = [];

    var layer = options.value;
    var key = options.key;
    var style = options.style;
    var styleSpec = options.styleSpec;

    if (!layer.type && !layer.ref) {
        errors.push(new ValidationError(key, layer, 'either "type" or "ref" is required'));
    }
    var type = unbundle(layer.type);
    var ref = unbundle(layer.ref);

    if (layer.id) {
        for (var i = 0; i < options.arrayIndex; i++) {
            var otherLayer = style.layers[i];
            if (unbundle(otherLayer.id) === unbundle(layer.id)) {
                errors.push(new ValidationError(key, layer.id, 'duplicate layer id "%s", previously used at line %d', layer.id, otherLayer.id.__line__));
            }
        }
    }

    if ('ref' in layer) {
        ['type', 'source', 'source-layer', 'filter', 'layout'].forEach(function (p) {
            if (p in layer) {
                errors.push(new ValidationError(key, layer[p], '"%s" is prohibited for ref layers', p));
            }
        });

        var parent;

        style.layers.forEach(function(layer) {
            if (layer.id == ref) parent = layer;
        });

        if (!parent) {
            errors.push(new ValidationError(key, layer.ref, 'ref layer "%s" not found', ref));
        } else if (parent.ref) {
            errors.push(new ValidationError(key, layer.ref, 'ref cannot reference another ref layer'));
        } else {
            type = unbundle(parent.type);
        }
    } else if (type !== 'background') {
        if (!layer.source) {
            errors.push(new ValidationError(key, layer, 'missing required property "source"'));
        } else {
            var source = style.sources[layer.source];
            if (!source) {
                errors.push(new ValidationError(key, layer.source, 'source "%s" not found', layer.source));
            } else if (source.type == 'vector' && type == 'raster') {
                errors.push(new ValidationError(key, layer.source, 'layer "%s" requires a raster source', layer.id));
            } else if (source.type == 'raster' && type != 'raster') {
                errors.push(new ValidationError(key, layer.source, 'layer "%s" requires a vector source', layer.id));
            } else if (source.type == 'vector' && !layer['source-layer']) {
                errors.push(new ValidationError(key, layer, 'layer "%s" must specify a "source-layer"', layer.id));
            }
        }
    }

    errors = errors.concat(validateObject({
        key: key,
        value: layer,
        valueSpec: styleSpec.layer,
        style: options.style,
        styleSpec: options.styleSpec,
        objectElementValidators: {
            filter: validateFilter,
            layout: function(options) {
                return validateObject({
                    layer: layer,
                    key: options.key,
                    value: options.value,
                    style: options.style,
                    styleSpec: options.styleSpec,
                    objectElementValidators: {
                        '*': function(options) {
                            return validateLayoutProperty(extend({layerType: type}, options));
                        }
                    }
                });
            },
            paint: function(options) {
                return validateObject({
                    layer: layer,
                    key: options.key,
                    value: options.value,
                    style: options.style,
                    styleSpec: options.styleSpec,
                    objectElementValidators: {
                        '*': function(options) {
                            return validatePaintProperty(extend({layerType: type}, options));
                        }
                    }
                });
            }
        }
    }));

    return errors;
};

},{"../error/validation_error":135,"../util/extend":136,"../util/unbundle_jsonlint":138,"./validate_filter":145,"./validate_layout_property":148,"./validate_object":150,"./validate_paint_property":151}],148:[function(require,module,exports){
'use strict';

var validate = require('./validate');
var ValidationError = require('../error/validation_error');

/**
 * @param options
 * @param {string} [options.key]
 * @param options.value
 * @param [options.valueSpec]
 * @param [options.style]
 * @param [options.styleSpec]
 * @param [options.layer]
 * @param options.objectKey
 */
module.exports = function validateLayoutProperty(options) {
    var key = options.key;
    var style = options.style;
    var styleSpec = options.styleSpec;
    var value = options.value;
    var propertyKey = options.objectKey;
    var layerSpec = styleSpec['layout_' + options.layerType];

    if (options.valueSpec || layerSpec[propertyKey]) {
        return validate({
            key: options.key,
            value: value,
            valueSpec: options.valueSpec || layerSpec[propertyKey],
            style: style,
            styleSpec: styleSpec
        });

    } else {
        return [new ValidationError(key, value, 'unknown property "%s"', propertyKey)];
    }

};

},{"../error/validation_error":135,"./validate":139}],149:[function(require,module,exports){
'use strict';

var getType = require('../util/get_type');
var ValidationError = require('../error/validation_error');

module.exports = function validateNumber(options) {
    var key = options.key;
    var value = options.value;
    var valueSpec = options.valueSpec;
    var type = getType(value);

    if (type !== 'number') {
        return [new ValidationError(key, value, 'number expected, %s found', type)];
    }

    if ('minimum' in valueSpec && value < valueSpec.minimum) {
        return [new ValidationError(key, value, '%s is less than the minimum value %s', value, valueSpec.minimum)];
    }

    if ('maximum' in valueSpec && value > valueSpec.maximum) {
        return [new ValidationError(key, value, '%s is greater than the maximum value %s', value, valueSpec.maximum)];
    }

    return [];
};

},{"../error/validation_error":135,"../util/get_type":137}],150:[function(require,module,exports){
'use strict';

var ValidationError = require('../error/validation_error');
var getType = require('../util/get_type');
var validate = require('./validate');

module.exports = function validateObject(options) {
    var key = options.key;
    var object = options.value;
    var valueSpec = options.valueSpec;
    var objectElementValidators = options.objectElementValidators || {};
    var style = options.style;
    var styleSpec = options.styleSpec;
    var errors = [];

    var type = getType(object);
    if (type !== 'object') {
        return [new ValidationError(key, object, 'object expected, %s found', type)];
    }

    for (var objectKey in object) {
        var valueSpecKey = objectKey.split('.')[0]; // treat 'paint.*' as 'paint'
        var objectElementSpec = valueSpec && (valueSpec[valueSpecKey] || valueSpec['*']);
        var objectElementValidator = objectElementValidators[valueSpecKey] || objectElementValidators['*'];

        if (objectElementSpec || objectElementValidator) {
            errors = errors.concat((objectElementValidator || validate)({
                key: (key ? key + '.' : key) + objectKey,
                value: object[objectKey],
                valueSpec: objectElementSpec,
                style: style,
                styleSpec: styleSpec,
                object: object,
                objectKey: objectKey
            }));

        // tolerate root-level extra keys & arbitrary layer properties
        // TODO remove this layer-specific logic
        } else if (key !== '' && key.split('.').length !== 1) {
            errors.push(new ValidationError(key, object[objectKey], 'unknown property "%s"', objectKey));
        }
    }

    for (valueSpecKey in valueSpec) {
        if (valueSpec[valueSpecKey].required && valueSpec[valueSpecKey]['default'] === undefined && object[valueSpecKey] === undefined) {
            errors.push(new ValidationError(key, object, 'missing required property "%s"', valueSpecKey));
        }
    }

    return errors;
};

},{"../error/validation_error":135,"../util/get_type":137,"./validate":139}],151:[function(require,module,exports){
'use strict';

var validate = require('./validate');
var ValidationError = require('../error/validation_error');

/**
 * @param options
 * @param {string} [options.key]
 * @param options.value
 * @param [options.valueSpec]
 * @param [options.style]
 * @param [options.styleSpec]
 * @param [options.layer]
 * @param options.objectKey
 */
module.exports = function validatePaintProperty(options) {
    var key = options.key;
    var style = options.style;
    var styleSpec = options.styleSpec;
    var value = options.value;
    var propertyKey = options.objectKey;
    var layerSpec = styleSpec['paint_' + options.layerType];

    var transitionMatch = propertyKey.match(/^(.*)-transition$/);

    if (transitionMatch && layerSpec[transitionMatch[1]] && layerSpec[transitionMatch[1]].transition) {
        return validate({
            key: key,
            value: value,
            valueSpec: styleSpec.transition,
            style: style,
            styleSpec: styleSpec
        });

    } else if (options.valueSpec || layerSpec[propertyKey]) {
        return validate({
            key: options.key,
            value: value,
            valueSpec: options.valueSpec || layerSpec[propertyKey],
            style: style,
            styleSpec: styleSpec
        });

    } else {
        return [new ValidationError(key, value, 'unknown property "%s"', propertyKey)];
    }

};

},{"../error/validation_error":135,"./validate":139}],152:[function(require,module,exports){
'use strict';

var ValidationError = require('../error/validation_error');
var unbundle = require('../util/unbundle_jsonlint');
var validateObject = require('./validate_object');
var validateEnum = require('./validate_enum');

module.exports = function validateSource(options) {
    var value = options.value;
    var key = options.key;
    var styleSpec = options.styleSpec;
    var style = options.style;

    if (!value.type) {
        return [new ValidationError(key, value, '"type" is required')];
    }

    var type = unbundle(value.type);
    switch (type) {
        case 'vector':
        case 'raster':
            var errors = [];
            errors = errors.concat(validateObject({
                key: key,
                value: value,
                valueSpec: styleSpec.source_tile,
                style: options.style,
                styleSpec: styleSpec
            }));
            if ('url' in value) {
                for (var prop in value) {
                    if (['type', 'url', 'tileSize'].indexOf(prop) < 0) {
                        errors.push(new ValidationError(key + '.' + prop, value[prop], 'a source with a "url" property may not include a "%s" property', prop));
                    }
                }
            }
            return errors;

        case 'geojson':
            return validateObject({
                key: key,
                value: value,
                valueSpec: styleSpec.source_geojson,
                style: style,
                styleSpec: styleSpec
            });

        case 'video':
            return validateObject({
                key: key,
                value: value,
                valueSpec: styleSpec.source_video,
                style: style,
                styleSpec: styleSpec
            });

        case 'image':
            return validateObject({
                key: key,
                value: value,
                valueSpec: styleSpec.source_image,
                style: style,
                styleSpec: styleSpec
            });

        default:
            return validateEnum({
                key: key + '.type',
                value: value.type,
                valueSpec: {values: ['vector', 'raster', 'geojson', 'video', 'image']},
                style: style,
                styleSpec: styleSpec
            });
    }
};

},{"../error/validation_error":135,"../util/unbundle_jsonlint":138,"./validate_enum":144,"./validate_object":150}],153:[function(require,module,exports){
'use strict';

var getType = require('../util/get_type');
var ValidationError = require('../error/validation_error');

module.exports = function validateString(options) {
    var value = options.value;
    var key = options.key;
    var type = getType(value);

    if (type !== 'string') {
        return [new ValidationError(key, value, 'string expected, %s found', type)];
    }

    return [];
};

},{"../error/validation_error":135,"../util/get_type":137}],154:[function(require,module,exports){
'use strict';

var validateConstants = require('./validate/validate_constants');
var validate = require('./validate/validate');
var latestStyleSpec = require('../reference/latest.min');

/**
 * Validate a Mapbox GL style against the style specification. This entrypoint,
 * `mapbox-gl-style-spec/lib/validate_style.min`, is designed to produce as
 * small a browserify bundle as possible by omitting unnecessary functionality
 * and legacy style specifications.
 *
 * @param {Object} style The style to be validated.
 * @param {Object} [styleSpec] The style specification to validate against.
 *     If omitted, the latest style spec is used.
 * @returns {Array<ValidationError>}
 * @example
 *   var validate = require('mapbox-gl-style-spec/lib/validate_style.min');
 *   var errors = validate(style);
 */
function validateStyleMin(style, styleSpec) {
    styleSpec = styleSpec || latestStyleSpec;

    var errors = [];

    errors = errors.concat(validate({
        key: '',
        value: style,
        valueSpec: styleSpec.$root,
        styleSpec: styleSpec,
        style: style
    }));

    if (styleSpec.$version > 7 && style.constants) {
        errors = errors.concat(validateConstants({
            key: 'constants',
            value: style.constants,
            style: style,
            styleSpec: styleSpec
        }));
    }

    return sortErrors(errors);
}

validateStyleMin.source = wrapCleanErrors(require('./validate/validate_source'));
validateStyleMin.layer = wrapCleanErrors(require('./validate/validate_layer'));
validateStyleMin.filter = wrapCleanErrors(require('./validate/validate_filter'));
validateStyleMin.paintProperty = wrapCleanErrors(require('./validate/validate_paint_property'));
validateStyleMin.layoutProperty = wrapCleanErrors(require('./validate/validate_layout_property'));

function sortErrors(errors) {
    return [].concat(errors).sort(function (a, b) {
        return a.line - b.line;
    });
}

function wrapCleanErrors(inner) {
    return function() {
        return sortErrors(inner.apply(this, arguments));
    };
}

module.exports = validateStyleMin;

},{"../reference/latest.min":156,"./validate/validate":139,"./validate/validate_constants":143,"./validate/validate_filter":145,"./validate/validate_layer":147,"./validate/validate_layout_property":148,"./validate/validate_paint_property":151,"./validate/validate_source":152}],155:[function(require,module,exports){
module.exports = require('./v8.json');

},{"./v8.json":157}],156:[function(require,module,exports){
module.exports = require('./v8.min.json');

},{"./v8.min.json":158}],157:[function(require,module,exports){
module.exports={
  "$version": 8,
  "$root": {
    "version": {
      "required": true,
      "type": "enum",
      "values": [8],
      "doc": "Stylesheet version number. Must be 8.",
      "example": 8
    },
    "name": {
      "type": "string",
      "doc": "A human-readable name for the style.",
      "example": "Bright"
    },
    "metadata": {
      "type": "*",
      "doc": "Arbitrary properties useful to track with the stylesheet, but do not influence rendering. Properties should be prefixed to avoid collisions, like 'mapbox:'."
    },
    "center": {
      "type": "array",
      "value": "number",
      "doc": "Default map center in longitude and latitude.  The style center will be used only if the map has not been positioned by other means (e.g. map options or user interaction).",
      "example": [-73.9749, 40.7736]
    },
    "zoom": {
      "type": "number",
      "doc": "Default zoom level.  The style zoom will be used only if the map has not been positioned by other means (e.g. map options or user interaction).",
      "example": 12.5
    },
    "bearing": {
      "type": "number",
      "default": 0,
      "period": 360,
      "units": "degrees",
      "doc": "Default bearing, in degrees.  The style bearing will be used only if the map has not been positioned by other means (e.g. map options or user interaction).",
      "example": 29
    },
    "pitch": {
      "type": "number",
      "default": 0,
      "units": "degrees",
      "doc": "Default pitch, in degrees. Zero is perpendicular to the surface.  The style pitch will be used only if the map has not been positioned by other means (e.g. map options or user interaction).",
      "example": 50
    },
    "sources": {
      "required": true,
      "type": "sources",
      "doc": "Data source specifications.",
      "example": {
        "mapbox-streets": {
          "type": "vector",
          "url": "mapbox://mapbox.mapbox-streets-v6"
        }
      }
    },
    "sprite": {
      "type": "string",
      "doc": "A base URL for retrieving the sprite image and metadata. The extensions `.png`, `.json` and scale factor `@2x.png` will be automatically appended.",
      "example": "mapbox://sprites/mapbox/bright-v8"
    },
    "glyphs": {
      "type": "string",
      "doc": "A URL template for loading signed-distance-field glyph sets in PBF format. Valid tokens are {fontstack} and {range}.",
      "example": "mapbox://fonts/mapbox/{fontstack}/{range}.pbf"
    },
    "transition": {
      "type": "transition",
      "doc": "A global transition definition to use as a default across properties.",
      "example": {
        "duration": 300,
        "delay": 0
      }
    },
    "layers": {
      "required": true,
      "type": "array",
      "value": "layer",
      "doc": "Layers will be drawn in the order of this array.",
      "example": [
        {
          "id": "water",
          "source": "mapbox-streets",
          "source-layer": "water",
          "type": "fill",
          "paint": {
            "fill-color": "#00ffff"
          }
        }
      ]
    }
  },
  "sources": {
    "*": {
      "type": "source",
      "doc": "Specification of a data source. For vector and raster sources, either TileJSON or a URL to a TileJSON must be provided. For GeoJSON and video sources, a URL must be provided."
    }
  },
  "source": [
    "source_tile",
    "source_geojson",
    "source_video",
    "source_image"
  ],
  "source_tile": {
    "type": {
      "required": true,
      "type": "enum",
      "values": [
        "vector",
        "raster"
      ],
      "doc": "The data type of the tile source."
    },
    "url": {
      "type": "string",
      "doc": "A URL to a TileJSON resource. Supported protocols are `http:`, `https:`, and `mapbox://<mapid>`."
    },
    "tiles": {
      "type": "array",
      "value": "string",
      "doc": "An array of one or more tile source URLs, as in the TileJSON spec."
    },
    "minzoom": {
      "type": "number",
      "default": 0,
      "doc": "Minimum zoom level for which tiles are available, as in the TileJSON spec."
    },
    "maxzoom": {
      "type": "number",
      "default": 22,
      "doc": "Maximum zoom level for which tiles are available, as in the TileJSON spec. Data from tiles at the maxzoom are used when displaying the map at higher zoom levels."
    },
    "tileSize": {
      "type": "number",
      "default": 512,
      "units": "pixels",
      "doc": "The minimum visual size to display tiles for this layer. Only configurable for raster layers."
    },
    "*": {
      "type": "*",
      "doc": "Other keys to configure the data source."
    }
  },
  "source_geojson": {
    "type": {
      "required": true,
      "type": "enum",
      "values": [
        "geojson"
      ],
      "doc": "The data type of the GeoJSON source."
    },
    "data": {
      "type": "*",
      "doc": "A URL to a GeoJSON file, or inline GeoJSON."
    },
    "maxzoom": {
      "type": "number",
      "default": 14,
      "doc": "Maximum zoom level at which to create vector tiles (higher means greater detail at high zoom levels)."
    },
    "buffer": {
      "type": "number",
      "default": 64,
      "doc": "Tile buffer size on each side (higher means fewer rendering artifacts near tile edges but slower performance)."
    },
    "tolerance": {
      "type": "number",
      "default": 3,
      "doc": "Douglas-Peucker simplification tolerance (higher means simpler geometries and faster performance)."
    },
    "cluster": {
      "type": "boolean",
      "default": false,
      "doc": "If the data is a collection of point features, setting this to true clusters the points by radius into groups."
    },
    "clusterRadius": {
      "type": "number",
      "default": 400,
      "doc": "Radius of each cluster when clustering points, relative to 4096 tile."
    },
    "clusterMaxZoom": {
      "type": "number",
      "doc": "Max zoom to cluster points on. Defaults to one zoom less than maxzoom (so that last zoom features are not clustered)."
    }
  },
  "source_video": {
    "type": {
      "required": true,
      "type": "enum",
      "values": [
        "video"
      ],
      "doc": "The data type of the video source."
    },
    "urls": {
      "required": true,
      "type": "array",
      "value": "string",
      "doc": "URLs to video content in order of preferred format."
    },
    "coordinates": {
      "required": true,
      "doc": "Corners of video specified in longitude, latitude pairs.",
      "type": "array",
      "length": 4,
      "value": {
        "type": "array",
        "length": 2,
        "value": "number",
        "doc": "A single longitude, latitude pair."
      }
    }
  },
  "source_image": {
    "type": {
      "required": true,
      "type": "enum",
      "values": [
        "image"
      ],
      "doc": "The data type of the image source."
    },
    "url": {
      "required": true,
      "type": "string",
      "doc": "URL that points to an image"
    },
    "coordinates": {
      "required": true,
      "doc": "Corners of image specified in longitude, latitude pairs.",
      "type": "array",
      "length": 4,
      "value": {
        "type": "array",
        "length": 2,
        "value": "number",
        "doc": "A single longitude, latitude pair."
      }
    }
  },
  "layer": {
    "id": {
      "type": "string",
      "doc": "Unique layer name.",
      "required": true
    },
    "type": {
      "type": "enum",
      "values": [
        "fill",
        "line",
        "symbol",
        "circle",
        "raster",
        "background"
      ],
      "doc": "Rendering type of this layer."
    },
    "metadata": {
      "type": "*",
      "doc": "Arbitrary properties useful to track with the layer, but do not influence rendering. Properties should be prefixed to avoid collisions, like 'mapbox:'."
    },
    "ref": {
      "type": "string",
      "doc": "References another layer to copy `type`, `source`, `source-layer`, `minzoom`, `maxzoom`, `filter`, and `layout` properties from. This allows the layers to share processing and be more efficient."
    },
    "source": {
      "type": "string",
      "doc": "Name of a source description to be used for this layer."
    },
    "source-layer": {
      "type": "string",
      "doc": "Layer to use from a vector tile source. Required if the source supports multiple layers."
    },
    "minzoom": {
      "type": "number",
      "minimum": 0,
      "maximum": 22,
      "doc": "The minimum zoom level on which the layer gets parsed and appears on."
    },
    "maxzoom": {
      "type": "number",
      "minimum": 0,
      "maximum": 22,
      "doc": "The maximum zoom level on which the layer gets parsed and appears on."
    },
    "interactive": {
      "type": "boolean",
      "doc": "Enable querying of feature data from this layer for interactivity.",
      "default": false
    },
    "filter": {
      "type": "filter",
      "doc": "A expression specifying conditions on source features. Only features that match the filter are displayed."
    },
    "layout": {
      "type": "layout",
      "doc": "Layout properties for the layer."
    },
    "paint": {
      "type": "paint",
      "doc": "Default paint properties for this layer."
    },
    "paint.*": {
      "type": "paint",
      "doc": "Class-specific paint properties for this layer. The class name is the part after the first dot."
    }
  },
  "layout": [
    "layout_fill",
    "layout_line",
    "layout_circle",
    "layout_symbol",
    "layout_raster",
    "layout_background"
  ],
  "layout_background": {
    "visibility": {
      "type": "enum",
      "function": "piecewise-constant",
      "values": [
        "visible",
        "none"
      ],
      "default": "visible",
      "doc": "The display of this layer. `none` hides this layer."
    }
  },
  "layout_fill": {
    "visibility": {
      "type": "enum",
      "function": "piecewise-constant",
      "values": [
        "visible",
        "none"
      ],
      "default": "visible",
      "doc": "The display of this layer. `none` hides this layer."
    }
  },
  "layout_circle": {
    "visibility": {
      "type": "enum",
      "function": "piecewise-constant",
      "values": [
        "visible",
        "none"
      ],
      "default": "visible",
      "doc": "The display of this layer. `none` hides this layer."
    }
  },
  "layout_line": {
    "line-cap": {
      "type": "enum",
      "function": "piecewise-constant",
      "values": [
        "butt",
        "round",
        "square"
      ],
      "default": "butt",
      "doc": "The display of line endings."
    },
    "line-join": {
      "type": "enum",
      "function": "piecewise-constant",
      "values": [
        "bevel",
        "round",
        "miter"
      ],
      "default": "miter",
      "doc": "The display of lines when joining."
    },
    "line-miter-limit": {
      "type": "number",
      "default": 2,
      "function": "interpolated",
      "doc": "Used to automatically convert miter joins to bevel joins for sharp angles.",
      "requires": [
        {
          "line-join": "miter"
        }
      ]
    },
    "line-round-limit": {
      "type": "number",
      "default": 1.05,
      "function": "interpolated",
      "doc": "Used to automatically convert round joins to miter joins for shallow angles.",
      "requires": [
        {
          "line-join": "round"
        }
      ]
    },
    "visibility": {
      "type": "enum",
      "function": "piecewise-constant",
      "values": [
        "visible",
        "none"
      ],
      "default": "visible",
      "doc": "The display of this layer. `none` hides this layer."
    }
  },
  "layout_symbol": {
    "symbol-placement": {
      "type": "enum",
      "function": "piecewise-constant",
      "values": [
          "point",
          "line"
      ],
      "default": "point",
      "doc": "Label placement relative to its geometry. `line` can only be used on LineStrings and Polygons."
    },
    "symbol-spacing": {
      "type": "number",
      "default": 250,
      "minimum": 1,
      "function": "interpolated",
      "units": "pixels",
      "doc": "Distance between two symbol anchors.",
      "requires": [
        {
          "symbol-placement": "line"
        }
      ]
    },
    "symbol-avoid-edges": {
      "type": "boolean",
      "function": "piecewise-constant",
      "default": false,
      "doc": "If true, the symbols will not cross tile edges to avoid mutual collisions. Recommended in layers that don't have enough padding in the vector tile to prevent collisions, or if it is a point symbol layer placed after a line symbol layer."
    },
    "icon-allow-overlap": {
      "type": "boolean",
      "function": "piecewise-constant",
      "default": false,
      "doc": "If true, the icon will be visible even if it collides with other previously drawn symbols.",
      "requires": [
        "icon-image"
      ]
    },
    "icon-ignore-placement": {
      "type": "boolean",
      "function": "piecewise-constant",
      "default": false,
      "doc": "If true, other symbols can be visible even if they collide with the icon.",
      "requires": [
        "icon-image"
      ]
    },
    "icon-optional": {
      "type": "boolean",
      "function": "piecewise-constant",
      "default": false,
      "doc": "If true, text will display without their corresponding icons when the icon collides with other symbols and the text does not.",
      "requires": [
        "icon-image",
        "text-field"
      ]
    },
    "icon-rotation-alignment": {
      "type": "enum",
      "function": "piecewise-constant",
      "values": [
        "map",
        "viewport"
      ],
      "default": "viewport",
      "doc": "Orientation of icon when map is rotated.",
      "requires": [
        "icon-image"
      ]
    },
    "icon-size": {
      "type": "number",
      "default": 1,
      "minimum": 0,
      "function": "interpolated",
      "doc": "Scale factor for icon. 1 is original size, 3 triples the size.",
      "requires": [
        "icon-image"
      ]
    },
    "icon-image": {
      "type": "string",
      "function": "piecewise-constant",
      "doc": "A string with {tokens} replaced, referencing the data property to pull from.",
      "tokens": true
    },
    "icon-rotate": {
      "type": "number",
      "default": 0,
      "period": 360,
      "function": "interpolated",
      "units": "degrees",
      "doc": "Rotates the icon clockwise.",
      "requires": [
        "icon-image"
      ]
    },
    "icon-padding": {
      "type": "number",
      "default": 2,
      "minimum": 0,
      "function": "interpolated",
      "units": "pixels",
      "doc": "Size of the additional area around the icon bounding box used for detecting symbol collisions.",
      "requires": [
        "icon-image"
      ]
    },
    "icon-keep-upright": {
      "type": "boolean",
      "function": "piecewise-constant",
      "default": false,
      "doc": "If true, the icon may be flipped to prevent it from being rendered upside-down.",
      "requires": [
        "icon-image",
        {
          "icon-rotation-alignment": "map"
        },
        {
          "symbol-placement": "line"
        }
      ]
    },
    "icon-offset": {
      "type": "array",
      "value": "number",
      "length": 2,
      "default": [
        0,
        0
      ],
      "function": "interpolated",
      "doc": "Offset distance of icon from its anchor. Positive values indicate right and down, while negative values indicate left and up.",
      "requires": [
        "icon-image"
      ]
    },
    "text-rotation-alignment": {
      "type": "enum",
      "function": "piecewise-constant",
      "values": [
        "map",
        "viewport"
      ],
      "default": "viewport",
      "doc": "Orientation of text when map is rotated.",
      "requires": [
        "text-field"
      ]
    },
    "text-field": {
      "type": "string",
      "function": "piecewise-constant",
      "default": "",
      "tokens": true,
      "doc": "Value to use for a text label. Feature properties are specified using tokens like {field_name}."
    },
    "text-font": {
      "type": "array",
      "value": "string",
      "function": "piecewise-constant",
      "default": ["Open Sans Regular", "Arial Unicode MS Regular"],
      "doc": "Font stack to use for displaying text.",
      "requires": [
        "text-field"
      ]
    },
    "text-size": {
      "type": "number",
      "default": 16,
      "minimum": 0,
      "units": "pixels",
      "function": "interpolated",
      "doc": "Font size.",
      "requires": [
        "text-field"
      ]
    },
    "text-max-width": {
      "type": "number",
      "default": 10,
      "minimum": 0,
      "units": "em",
      "function": "interpolated",
      "doc": "The maximum line width for text wrapping.",
      "requires": [
        "text-field"
      ]
    },
    "text-line-height": {
      "type": "number",
      "default": 1.2,
      "units": "em",
      "function": "interpolated",
      "doc": "Text leading value for multi-line text.",
      "requires": [
        "text-field"
      ]
    },
    "text-letter-spacing": {
      "type": "number",
      "default": 0,
      "units": "em",
      "function": "interpolated",
      "doc": "Text tracking amount.",
      "requires": [
        "text-field"
      ]
    },
    "text-justify": {
      "type": "enum",
      "function": "piecewise-constant",
      "values": [
        "left",
        "center",
        "right"
      ],
      "default": "center",
      "doc": "Text justification options.",
      "requires": [
        "text-field"
      ]
    },
    "text-anchor": {
      "type": "enum",
      "function": "piecewise-constant",
      "values": [
        "center",
        "left",
        "right",
        "top",
        "bottom",
        "top-left",
        "top-right",
        "bottom-left",
        "bottom-right"
      ],
      "default": "center",
      "doc": "Part of the text placed closest to the anchor.",
      "requires": [
        "text-field"
      ]
    },
    "text-max-angle": {
      "type": "number",
      "default": 45,
      "units": "degrees",
      "function": "interpolated",
      "doc": "Maximum angle change between adjacent characters.",
      "requires": [
        "text-field",
        {
          "symbol-placement": "line"
        }
      ]
    },
    "text-rotate": {
      "type": "number",
      "default": 0,
      "period": 360,
      "units": "degrees",
      "function": "interpolated",
      "doc": "Rotates the text clockwise.",
      "requires": [
        "text-field"
      ]
    },
    "text-padding": {
      "type": "number",
      "default": 2,
      "minimum": 0,
      "units": "pixels",
      "function": "interpolated",
      "doc": "Size of the additional area around the text bounding box used for detecting symbol collisions.",
      "requires": [
        "text-field"
      ]
    },
    "text-keep-upright": {
      "type": "boolean",
      "function": "piecewise-constant",
      "default": true,
      "doc": "If true, the text may be flipped vertically to prevent it from being rendered upside-down.",
      "requires": [
        "text-field",
        {
          "text-rotation-alignment": "map"
        },
        {
          "symbol-placement": "line"
        }
      ]
    },
    "text-transform": {
      "type": "enum",
      "function": "piecewise-constant",
      "values": [
        "none",
        "uppercase",
        "lowercase"
      ],
      "default": "none",
      "doc": "Specifies how to capitalize text, similar to the CSS `text-transform` property.",
      "requires": [
        "text-field"
      ]
    },
    "text-offset": {
      "type": "array",
      "doc": "Offset distance of text from its anchor. Positive values indicate right and down, while negative values indicate left and up.",
      "value": "number",
      "units": "ems",
      "function": "interpolated",
      "length": 2,
      "default": [
        0,
        0
      ],
      "requires": [
        "text-field"
      ]
    },
    "text-allow-overlap": {
      "type": "boolean",
      "function": "piecewise-constant",
      "default": false,
      "doc": "If true, the text will be visible even if it collides with other previously drawn symbols.",
      "requires": [
        "text-field"
      ]
    },
    "text-ignore-placement": {
      "type": "boolean",
      "function": "piecewise-constant",
      "default": false,
      "doc": "If true, other symbols can be visible even if they collide with the text.",
      "requires": [
        "text-field"
      ]
    },
    "text-optional": {
      "type": "boolean",
      "function": "piecewise-constant",
      "default": false,
      "doc": "If true, icons will display without their corresponding text when the text collides with other symbols and the icon does not.",
      "requires": [
        "text-field",
        "icon-image"
      ]
    },
    "visibility": {
      "type": "enum",
      "function": "piecewise-constant",
      "values": [
        "visible",
        "none"
      ],
      "default": "visible",
      "doc": "The display of this layer. `none` hides this layer."
    }
  },
  "layout_raster": {
    "visibility": {
      "type": "enum",
      "function": "piecewise-constant",
      "values": [
        "visible",
        "none"
      ],
      "default": "visible",
      "doc": "The display of this layer. `none` hides this layer."
    }
  },
  "filter": {
    "type": "array",
    "value": "*",
    "doc": "A filter selects specific features from a layer."
  },
  "filter_operator": {
    "type": "enum",
    "values": [
      "==",
      "!=",
      ">",
      ">=",
      "<",
      "<=",
      "in",
      "!in",
      "all",
      "any",
      "none"
    ],
    "doc": "The filter operator."
  },
  "geometry_type": {
    "type": "enum",
    "values": [
      "Point",
      "LineString",
      "Polygon"
    ],
    "doc": "The geometry type for the filter to select."
  },
  "color_operation": {
    "type": "enum",
    "values": [
      "lighten",
      "saturate",
      "spin",
      "fade",
      "mix"
    ],
    "doc": "A color operation to apply."
  },
  "function": {
    "stops": {
      "type": "array",
      "required": true,
      "doc": "An array of stops.",
      "value": "function_stop"
    },
    "base": {
      "type": "number",
      "default": 1,
      "minimum": 0,
      "doc": "The exponential base of the interpolation curve. It controls the rate at which the result increases. Higher values make the result increase more towards the high end of the range. With `1` the stops are interpolated linearly."
    }
  },
  "function_stop": {
    "type": "array",
    "minimum": 0,
    "maximum": 22,
    "value": [
      "number",
      "color"
    ],
    "length": 2,
    "doc": "Zoom level and value pair."
  },
  "paint": [
    "paint_fill",
    "paint_line",
    "paint_circle",
    "paint_symbol",
    "paint_raster",
    "paint_background"
  ],
  "paint_fill": {
    "fill-antialias": {
      "type": "boolean",
      "function": "piecewise-constant",
      "default": true,
      "doc": "Whether or not the fill should be antialiased."
    },
    "fill-opacity": {
      "type": "number",
      "function": "interpolated",
      "default": 1,
      "minimum": 0,
      "maximum": 1,
      "doc": "The opacity given to the fill color.",
      "transition": true
    },
    "fill-color": {
      "type": "color",
      "default": "#000000",
      "doc": "The color of the fill.",
      "function": "interpolated",
      "transition": true,
      "requires": [
        {
          "!": "fill-pattern"
        }
      ]
    },
    "fill-outline-color": {
      "type": "color",
      "doc": "The outline color of the fill. Matches the value of `fill-color` if unspecified.",
      "function": "interpolated",
      "transition": true,
      "requires": [
        {
          "!": "fill-pattern"
        },
        {
          "fill-antialias": true
        }
      ]
    },
    "fill-translate": {
      "type": "array",
      "value": "number",
      "length": 2,
      "default": [
        0,
        0
      ],
      "function": "interpolated",
      "transition": true,
      "units": "pixels",
      "doc": "The geometry's offset. Values are [x, y] where negatives indicate left and up, respectively."
    },
    "fill-translate-anchor": {
      "type": "enum",
      "function": "piecewise-constant",
      "values": [
        "map",
        "viewport"
      ],
      "doc": "Control whether the translation is relative to the map (north) or viewport (screen)",
      "default": "map",
      "requires": [
        "fill-translate"
      ]
    },
    "fill-pattern": {
      "type": "string",
      "function": "piecewise-constant",
      "transition": true,
      "doc": "Name of image in sprite to use for drawing image fills. For seamless patterns, image width and height must be a factor of two (2, 4, 8, ..., 512)."
    }
  },
  "paint_line": {
    "line-opacity": {
      "type": "number",
      "doc": "The opacity at which the line will be drawn.",
      "function": "interpolated",
      "default": 1,
      "minimum": 0,
      "maximum": 1,
      "transition": true
    },
    "line-color": {
      "type": "color",
      "doc": "The color with which the line will be drawn.",
      "default": "#000000",
      "function": "interpolated",
      "transition": true,
      "requires": [
        {
          "!": "line-pattern"
        }
      ]
    },
    "line-translate": {
      "type": "array",
      "value": "number",
      "length": 2,
      "default": [
        0,
        0
      ],
      "function": "interpolated",
      "transition": true,
      "units": "pixels",
      "doc": "The geometry's offset. Values are [x, y] where negatives indicate left and up, respectively."
    },
    "line-translate-anchor": {
      "type": "enum",
      "function": "piecewise-constant",
      "values": [
        "map",
        "viewport"
      ],
      "doc": "Control whether the translation is relative to the map (north) or viewport (screen)",
      "default": "map",
      "requires": [
        "line-translate"
      ]
    },
    "line-width": {
      "type": "number",
      "default": 1,
      "minimum": 0,
      "function": "interpolated",
      "transition": true,
      "units": "pixels",
      "doc": "Stroke thickness."
    },
    "line-gap-width": {
      "type": "number",
      "default": 0,
      "minimum": 0,
      "doc": "Draws a line casing outside of a line's actual path. Value indicates the width of the inner gap.",
      "function": "interpolated",
      "transition": true,
      "units": "pixels"
    },
    "line-offset": {
      "type": "number",
      "default": 0,
      "doc": "The line's offset perpendicular to its direction. Values may be positive or negative, where positive indicates \"rightwards\" (if you were moving in the direction of the line) and negative indicates \"leftwards.\"",
      "function": "interpolated",
      "transition": true,
      "units": "pixels"
    },
    "line-blur": {
      "type": "number",
      "default": 0,
      "minimum": 0,
      "function": "interpolated",
      "transition": true,
      "units": "pixels",
      "doc": "Blur applied to the line, in pixels."
    },
    "line-dasharray": {
      "type": "array",
      "value": "number",
      "function": "piecewise-constant",
      "doc": "Specifies the lengths of the alternating dashes and gaps that form the dash pattern. The lengths are later scaled by the line width. To convert a dash length to pixels, multiply the length by the current line width.",
      "minimum": 0,
      "transition": true,
      "units": "line widths",
      "requires": [
        {
          "!": "line-pattern"
        }
      ]
    },
    "line-pattern": {
      "type": "string",
      "function": "piecewise-constant",
      "transition": true,
      "doc": "Name of image in sprite to use for drawing image lines. For seamless patterns, image width must be a factor of two (2, 4, 8, ..., 512)."
    }
  },
  "paint_circle": {
    "circle-radius": {
      "type": "number",
      "default": 5,
      "minimum": 0,
      "function": "interpolated",
      "transition": true,
      "units": "pixels",
      "doc": "Circle radius."
    },
    "circle-color": {
      "type": "color",
      "default": "#000000",
      "doc": "The color of the circle.",
      "function": "interpolated",
      "transition": true
    },
    "circle-blur": {
      "type": "number",
      "default": 0,
      "doc": "Amount to blur the circle. 1 blurs the circle such that only the centerpoint is full opacity.",
      "function": "interpolated",
      "transition": true
    },
    "circle-opacity": {
      "type": "number",
      "doc": "The opacity at which the circle will be drawn.",
      "default": 1,
      "minimum": 0,
      "maximum": 1,
      "function": "interpolated",
      "transition": true
    },
    "circle-translate": {
      "type": "array",
      "value": "number",
      "length": 2,
      "default": [0, 0],
      "function": "interpolated",
      "transition": true,
      "units": "pixels",
      "doc": "The geometry's offset. Values are [x, y] where negatives indicate left and up, respectively."
    },
    "circle-translate-anchor": {
      "type": "enum",
      "function": "piecewise-constant",
      "values": [
        "map",
        "viewport"
      ],
      "doc": "Control whether the translation is relative to the map (north) or viewport (screen)",
      "default": "map",
      "requires": [
        "circle-translate"
      ]
    }
  },
  "paint_symbol": {
    "icon-opacity": {
      "doc": "The opacity at which the icon will be drawn.",
      "type": "number",
      "default": 1,
      "minimum": 0,
      "maximum": 1,
      "function": "interpolated",
      "transition": true,
      "requires": [
        "icon-image"
      ]
    },
    "icon-color": {
      "type": "color",
      "default": "#000000",
      "function": "interpolated",
      "transition": true,
      "doc": "The color of the icon. This can only be used with sdf icons.",
      "requires": [
        "icon-image"
      ]
    },
    "icon-halo-color": {
      "type": "color",
      "default": "rgba(0, 0, 0, 0)",
      "function": "interpolated",
      "transition": true,
      "doc": "The color of the icon's halo. Icon halos can only be used with sdf icons.",
      "requires": [
        "icon-image"
      ]
    },
    "icon-halo-width": {
      "type": "number",
      "default": 0,
      "minimum": 0,
      "function": "interpolated",
      "transition": true,
      "units": "pixels",
      "doc": "Distance of halo to the icon outline.",
      "requires": [
        "icon-image"
      ]
    },
    "icon-halo-blur": {
      "type": "number",
      "default": 0,
      "minimum": 0,
      "function": "interpolated",
      "transition": true,
      "units": "pixels",
      "doc": "Fade out the halo towards the outside.",
      "requires": [
        "icon-image"
      ]
    },
    "icon-translate": {
      "type": "array",
      "value": "number",
      "length": 2,
      "default": [
        0,
        0
      ],
      "function": "interpolated",
      "transition": true,
      "units": "pixels",
      "doc": "Distance that the icon's anchor is moved from its original placement. Positive values indicate right and down, while negative values indicate left and up.",
      "requires": [
        "icon-image"
      ]
    },
    "icon-translate-anchor": {
      "type": "enum",
      "function": "piecewise-constant",
      "values": [
        "map",
        "viewport"
      ],
      "doc": "Control whether the translation is relative to the map (north) or viewport (screen).",
      "default": "map",
      "requires": [
        "icon-image",
        "icon-translate"
      ]
    },
    "text-opacity": {
      "type": "number",
      "doc": "The opacity at which the text will be drawn.",
      "default": 1,
      "minimum": 0,
      "maximum": 1,
      "function": "interpolated",
      "transition": true,
      "requires": [
        "text-field"
      ]
    },
    "text-color": {
      "type": "color",
      "doc": "The color with which the text will be drawn.",
      "default": "#000000",
      "function": "interpolated",
      "transition": true,
      "requires": [
        "text-field"
      ]
    },
    "text-halo-color": {
      "type": "color",
      "default": "rgba(0, 0, 0, 0)",
      "function": "interpolated",
      "transition": true,
      "doc": "The color of the text's halo, which helps it stand out from backgrounds.",
      "requires": [
        "text-field"
      ]
    },
    "text-halo-width": {
      "type": "number",
      "default": 0,
      "minimum": 0,
      "function": "interpolated",
      "transition": true,
      "units": "pixels",
      "doc": "Distance of halo to the font outline. Max text halo width is 1/4 of the font-size.",
      "requires": [
        "text-field"
      ]
    },
    "text-halo-blur": {
      "type": "number",
      "default": 0,
      "minimum": 0,
      "function": "interpolated",
      "transition": true,
      "units": "pixels",
      "doc": "The halo's fadeout distance towards the outside.",
      "requires": [
        "text-field"
      ]
    },
    "text-translate": {
      "type": "array",
      "value": "number",
      "length": 2,
      "default": [
        0,
        0
      ],
      "function": "interpolated",
      "transition": true,
      "units": "pixels",
      "doc": "Distance that the text's anchor is moved from its original placement. Positive values indicate right and down, while negative values indicate left and up.",
      "requires": [
        "text-field"
      ]
    },
    "text-translate-anchor": {
      "type": "enum",
      "function": "piecewise-constant",
      "values": [
        "map",
        "viewport"
      ],
      "doc": "Control whether the translation is relative to the map (north) or viewport (screen).",
      "default": "map",
      "requires": [
        "text-field",
        "text-translate"
      ]
    }
  },
  "paint_raster": {
    "raster-opacity": {
      "type": "number",
      "doc": "The opacity at which the image will be drawn.",
      "default": 1,
      "minimum": 0,
      "maximum": 1,
      "function": "interpolated",
      "transition": true
    },
    "raster-hue-rotate": {
      "type": "number",
      "default": 0,
      "period": 360,
      "function": "interpolated",
      "transition": true,
      "units": "degrees",
      "doc": "Rotates hues around the color wheel."
    },
    "raster-brightness-min": {
      "type": "number",
      "function": "interpolated",
      "doc": "Increase or reduce the brightness of the image. The value is the minimum brightness.",
      "default": 0,
      "minimum": 0,
      "maximum": 1,
      "transition": true
    },
    "raster-brightness-max": {
      "type": "number",
      "function": "interpolated",
      "doc": "Increase or reduce the brightness of the image. The value is the maximum brightness.",
      "default": 1,
      "minimum": 0,
      "maximum": 1,
      "transition": true
    },
    "raster-saturation": {
      "type": "number",
      "doc": "Increase or reduce the saturation of the image.",
      "default": 0,
      "minimum": -1,
      "maximum": 1,
      "function": "interpolated",
      "transition": true
    },
    "raster-contrast": {
      "type": "number",
      "doc": "Increase or reduce the contrast of the image.",
      "default": 0,
      "minimum": -1,
      "maximum": 1,
      "function": "interpolated",
      "transition": true
    },
    "raster-fade-duration": {
      "type": "number",
      "default": 300,
      "minimum": 0,
      "function": "interpolated",
      "transition": true,
      "units": "milliseconds",
      "doc": "Fade duration when a new tile is added."
    }
  },
  "paint_background": {
    "background-color": {
      "type": "color",
      "default": "#000000",
      "doc": "The color with which the background will be drawn.",
      "function": "interpolated",
      "transition": true,
      "requires": [
        {
          "!": "background-pattern"
        }
      ]
    },
    "background-pattern": {
      "type": "string",
      "function": "piecewise-constant",
      "transition": true,
      "doc": "Name of image in sprite to use for drawing an image background. For seamless patterns, image width and height must be a factor of two (2, 4, 8, ..., 512)."
    },
    "background-opacity": {
      "type": "number",
      "default": 1,
      "minimum": 0,
      "maximum": 1,
      "doc": "The opacity at which the background will be drawn.",
      "function": "interpolated",
      "transition": true
    }
  },
  "transition": {
    "duration": {
      "type": "number",
      "default": 300,
      "minimum": 0,
      "units": "milliseconds",
      "doc": "Time allotted for transitions to complete."
    },
    "delay": {
      "type": "number",
      "default": 0,
      "minimum": 0,
      "units": "milliseconds",
      "doc": "Length of time before a transition begins."
    }
  }
}

},{}],158:[function(require,module,exports){
module.exports={"$version":8,"$root":{"version":{"required":true,"type":"enum","values":[8]},"name":{"type":"string"},"metadata":{"type":"*"},"center":{"type":"array","value":"number"},"zoom":{"type":"number"},"bearing":{"type":"number","default":0,"period":360,"units":"degrees"},"pitch":{"type":"number","default":0,"units":"degrees"},"sources":{"required":true,"type":"sources"},"sprite":{"type":"string"},"glyphs":{"type":"string"},"transition":{"type":"transition"},"layers":{"required":true,"type":"array","value":"layer"}},"sources":{"*":{"type":"source"}},"source":["source_tile","source_geojson","source_video","source_image"],"source_tile":{"type":{"required":true,"type":"enum","values":["vector","raster"]},"url":{"type":"string"},"tiles":{"type":"array","value":"string"},"minzoom":{"type":"number","default":0},"maxzoom":{"type":"number","default":22},"tileSize":{"type":"number","default":512,"units":"pixels"},"*":{"type":"*"}},"source_geojson":{"type":{"required":true,"type":"enum","values":["geojson"]},"data":{"type":"*"},"maxzoom":{"type":"number","default":14},"buffer":{"type":"number","default":64},"tolerance":{"type":"number","default":3},"cluster":{"type":"boolean","default":false},"clusterRadius":{"type":"number","default":400},"clusterMaxZoom":{"type":"number"}},"source_video":{"type":{"required":true,"type":"enum","values":["video"]},"urls":{"required":true,"type":"array","value":"string"},"coordinates":{"required":true,"type":"array","length":4,"value":{"type":"array","length":2,"value":"number"}}},"source_image":{"type":{"required":true,"type":"enum","values":["image"]},"url":{"required":true,"type":"string"},"coordinates":{"required":true,"type":"array","length":4,"value":{"type":"array","length":2,"value":"number"}}},"layer":{"id":{"type":"string","required":true},"type":{"type":"enum","values":["fill","line","symbol","circle","raster","background"]},"metadata":{"type":"*"},"ref":{"type":"string"},"source":{"type":"string"},"source-layer":{"type":"string"},"minzoom":{"type":"number","minimum":0,"maximum":22},"maxzoom":{"type":"number","minimum":0,"maximum":22},"interactive":{"type":"boolean","default":false},"filter":{"type":"filter"},"layout":{"type":"layout"},"paint":{"type":"paint"},"paint.*":{"type":"paint"}},"layout":["layout_fill","layout_line","layout_circle","layout_symbol","layout_raster","layout_background"],"layout_background":{"visibility":{"type":"enum","function":"piecewise-constant","values":["visible","none"],"default":"visible"}},"layout_fill":{"visibility":{"type":"enum","function":"piecewise-constant","values":["visible","none"],"default":"visible"}},"layout_circle":{"visibility":{"type":"enum","function":"piecewise-constant","values":["visible","none"],"default":"visible"}},"layout_line":{"line-cap":{"type":"enum","function":"piecewise-constant","values":["butt","round","square"],"default":"butt"},"line-join":{"type":"enum","function":"piecewise-constant","values":["bevel","round","miter"],"default":"miter"},"line-miter-limit":{"type":"number","default":2,"function":"interpolated","requires":[{"line-join":"miter"}]},"line-round-limit":{"type":"number","default":1.05,"function":"interpolated","requires":[{"line-join":"round"}]},"visibility":{"type":"enum","function":"piecewise-constant","values":["visible","none"],"default":"visible"}},"layout_symbol":{"symbol-placement":{"type":"enum","function":"piecewise-constant","values":["point","line"],"default":"point"},"symbol-spacing":{"type":"number","default":250,"minimum":1,"function":"interpolated","units":"pixels","requires":[{"symbol-placement":"line"}]},"symbol-avoid-edges":{"type":"boolean","function":"piecewise-constant","default":false},"icon-allow-overlap":{"type":"boolean","function":"piecewise-constant","default":false,"requires":["icon-image"]},"icon-ignore-placement":{"type":"boolean","function":"piecewise-constant","default":false,"requires":["icon-image"]},"icon-optional":{"type":"boolean","function":"piecewise-constant","default":false,"requires":["icon-image","text-field"]},"icon-rotation-alignment":{"type":"enum","function":"piecewise-constant","values":["map","viewport"],"default":"viewport","requires":["icon-image"]},"icon-size":{"type":"number","default":1,"minimum":0,"function":"interpolated","requires":["icon-image"]},"icon-image":{"type":"string","function":"piecewise-constant","tokens":true},"icon-rotate":{"type":"number","default":0,"period":360,"function":"interpolated","units":"degrees","requires":["icon-image"]},"icon-padding":{"type":"number","default":2,"minimum":0,"function":"interpolated","units":"pixels","requires":["icon-image"]},"icon-keep-upright":{"type":"boolean","function":"piecewise-constant","default":false,"requires":["icon-image",{"icon-rotation-alignment":"map"},{"symbol-placement":"line"}]},"icon-offset":{"type":"array","value":"number","length":2,"default":[0,0],"function":"interpolated","requires":["icon-image"]},"text-rotation-alignment":{"type":"enum","function":"piecewise-constant","values":["map","viewport"],"default":"viewport","requires":["text-field"]},"text-field":{"type":"string","function":"piecewise-constant","default":"","tokens":true},"text-font":{"type":"array","value":"string","function":"piecewise-constant","default":["Open Sans Regular","Arial Unicode MS Regular"],"requires":["text-field"]},"text-size":{"type":"number","default":16,"minimum":0,"units":"pixels","function":"interpolated","requires":["text-field"]},"text-max-width":{"type":"number","default":10,"minimum":0,"units":"em","function":"interpolated","requires":["text-field"]},"text-line-height":{"type":"number","default":1.2,"units":"em","function":"interpolated","requires":["text-field"]},"text-letter-spacing":{"type":"number","default":0,"units":"em","function":"interpolated","requires":["text-field"]},"text-justify":{"type":"enum","function":"piecewise-constant","values":["left","center","right"],"default":"center","requires":["text-field"]},"text-anchor":{"type":"enum","function":"piecewise-constant","values":["center","left","right","top","bottom","top-left","top-right","bottom-left","bottom-right"],"default":"center","requires":["text-field"]},"text-max-angle":{"type":"number","default":45,"units":"degrees","function":"interpolated","requires":["text-field",{"symbol-placement":"line"}]},"text-rotate":{"type":"number","default":0,"period":360,"units":"degrees","function":"interpolated","requires":["text-field"]},"text-padding":{"type":"number","default":2,"minimum":0,"units":"pixels","function":"interpolated","requires":["text-field"]},"text-keep-upright":{"type":"boolean","function":"piecewise-constant","default":true,"requires":["text-field",{"text-rotation-alignment":"map"},{"symbol-placement":"line"}]},"text-transform":{"type":"enum","function":"piecewise-constant","values":["none","uppercase","lowercase"],"default":"none","requires":["text-field"]},"text-offset":{"type":"array","value":"number","units":"ems","function":"interpolated","length":2,"default":[0,0],"requires":["text-field"]},"text-allow-overlap":{"type":"boolean","function":"piecewise-constant","default":false,"requires":["text-field"]},"text-ignore-placement":{"type":"boolean","function":"piecewise-constant","default":false,"requires":["text-field"]},"text-optional":{"type":"boolean","function":"piecewise-constant","default":false,"requires":["text-field","icon-image"]},"visibility":{"type":"enum","function":"piecewise-constant","values":["visible","none"],"default":"visible"}},"layout_raster":{"visibility":{"type":"enum","function":"piecewise-constant","values":["visible","none"],"default":"visible"}},"filter":{"type":"array","value":"*"},"filter_operator":{"type":"enum","values":["==","!=",">",">=","<","<=","in","!in","all","any","none"]},"geometry_type":{"type":"enum","values":["Point","LineString","Polygon"]},"color_operation":{"type":"enum","values":["lighten","saturate","spin","fade","mix"]},"function":{"stops":{"type":"array","required":true,"value":"function_stop"},"base":{"type":"number","default":1,"minimum":0}},"function_stop":{"type":"array","minimum":0,"maximum":22,"value":["number","color"],"length":2},"paint":["paint_fill","paint_line","paint_circle","paint_symbol","paint_raster","paint_background"],"paint_fill":{"fill-antialias":{"type":"boolean","function":"piecewise-constant","default":true},"fill-opacity":{"type":"number","function":"interpolated","default":1,"minimum":0,"maximum":1,"transition":true},"fill-color":{"type":"color","default":"#000000","function":"interpolated","transition":true,"requires":[{"!":"fill-pattern"}]},"fill-outline-color":{"type":"color","function":"interpolated","transition":true,"requires":[{"!":"fill-pattern"},{"fill-antialias":true}]},"fill-translate":{"type":"array","value":"number","length":2,"default":[0,0],"function":"interpolated","transition":true,"units":"pixels"},"fill-translate-anchor":{"type":"enum","function":"piecewise-constant","values":["map","viewport"],"default":"map","requires":["fill-translate"]},"fill-pattern":{"type":"string","function":"piecewise-constant","transition":true}},"paint_line":{"line-opacity":{"type":"number","function":"interpolated","default":1,"minimum":0,"maximum":1,"transition":true},"line-color":{"type":"color","default":"#000000","function":"interpolated","transition":true,"requires":[{"!":"line-pattern"}]},"line-translate":{"type":"array","value":"number","length":2,"default":[0,0],"function":"interpolated","transition":true,"units":"pixels"},"line-translate-anchor":{"type":"enum","function":"piecewise-constant","values":["map","viewport"],"default":"map","requires":["line-translate"]},"line-width":{"type":"number","default":1,"minimum":0,"function":"interpolated","transition":true,"units":"pixels"},"line-gap-width":{"type":"number","default":0,"minimum":0,"function":"interpolated","transition":true,"units":"pixels"},"line-offset":{"type":"number","default":0,"function":"interpolated","transition":true,"units":"pixels"},"line-blur":{"type":"number","default":0,"minimum":0,"function":"interpolated","transition":true,"units":"pixels"},"line-dasharray":{"type":"array","value":"number","function":"piecewise-constant","minimum":0,"transition":true,"units":"line widths","requires":[{"!":"line-pattern"}]},"line-pattern":{"type":"string","function":"piecewise-constant","transition":true}},"paint_circle":{"circle-radius":{"type":"number","default":5,"minimum":0,"function":"interpolated","transition":true,"units":"pixels"},"circle-color":{"type":"color","default":"#000000","function":"interpolated","transition":true},"circle-blur":{"type":"number","default":0,"function":"interpolated","transition":true},"circle-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"function":"interpolated","transition":true},"circle-translate":{"type":"array","value":"number","length":2,"default":[0,0],"function":"interpolated","transition":true,"units":"pixels"},"circle-translate-anchor":{"type":"enum","function":"piecewise-constant","values":["map","viewport"],"default":"map","requires":["circle-translate"]}},"paint_symbol":{"icon-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"function":"interpolated","transition":true,"requires":["icon-image"]},"icon-color":{"type":"color","default":"#000000","function":"interpolated","transition":true,"requires":["icon-image"]},"icon-halo-color":{"type":"color","default":"rgba(0, 0, 0, 0)","function":"interpolated","transition":true,"requires":["icon-image"]},"icon-halo-width":{"type":"number","default":0,"minimum":0,"function":"interpolated","transition":true,"units":"pixels","requires":["icon-image"]},"icon-halo-blur":{"type":"number","default":0,"minimum":0,"function":"interpolated","transition":true,"units":"pixels","requires":["icon-image"]},"icon-translate":{"type":"array","value":"number","length":2,"default":[0,0],"function":"interpolated","transition":true,"units":"pixels","requires":["icon-image"]},"icon-translate-anchor":{"type":"enum","function":"piecewise-constant","values":["map","viewport"],"default":"map","requires":["icon-image","icon-translate"]},"text-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"function":"interpolated","transition":true,"requires":["text-field"]},"text-color":{"type":"color","default":"#000000","function":"interpolated","transition":true,"requires":["text-field"]},"text-halo-color":{"type":"color","default":"rgba(0, 0, 0, 0)","function":"interpolated","transition":true,"requires":["text-field"]},"text-halo-width":{"type":"number","default":0,"minimum":0,"function":"interpolated","transition":true,"units":"pixels","requires":["text-field"]},"text-halo-blur":{"type":"number","default":0,"minimum":0,"function":"interpolated","transition":true,"units":"pixels","requires":["text-field"]},"text-translate":{"type":"array","value":"number","length":2,"default":[0,0],"function":"interpolated","transition":true,"units":"pixels","requires":["text-field"]},"text-translate-anchor":{"type":"enum","function":"piecewise-constant","values":["map","viewport"],"default":"map","requires":["text-field","text-translate"]}},"paint_raster":{"raster-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"function":"interpolated","transition":true},"raster-hue-rotate":{"type":"number","default":0,"period":360,"function":"interpolated","transition":true,"units":"degrees"},"raster-brightness-min":{"type":"number","function":"interpolated","default":0,"minimum":0,"maximum":1,"transition":true},"raster-brightness-max":{"type":"number","function":"interpolated","default":1,"minimum":0,"maximum":1,"transition":true},"raster-saturation":{"type":"number","default":0,"minimum":-1,"maximum":1,"function":"interpolated","transition":true},"raster-contrast":{"type":"number","default":0,"minimum":-1,"maximum":1,"function":"interpolated","transition":true},"raster-fade-duration":{"type":"number","default":300,"minimum":0,"function":"interpolated","transition":true,"units":"milliseconds"}},"paint_background":{"background-color":{"type":"color","default":"#000000","function":"interpolated","transition":true,"requires":[{"!":"background-pattern"}]},"background-pattern":{"type":"string","function":"piecewise-constant","transition":true},"background-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"function":"interpolated","transition":true}},"transition":{"duration":{"type":"number","default":300,"minimum":0,"units":"milliseconds"},"delay":{"type":"number","default":0,"minimum":0,"units":"milliseconds"}}}
},{}],159:[function(require,module,exports){
'use strict';

// lightweight Buffer shim for pbf browser build
// based on code from github.com/feross/buffer (MIT-licensed)

module.exports = Buffer;

var ieee754 = require('ieee754');

var BufferMethods;

function Buffer(length) {
    var arr;
    if (length && length.length) {
        arr = length;
        length = arr.length;
    }
    var buf = new Uint8Array(length || 0);
    if (arr) buf.set(arr);

    buf.readUInt32LE = BufferMethods.readUInt32LE;
    buf.writeUInt32LE = BufferMethods.writeUInt32LE;
    buf.readInt32LE = BufferMethods.readInt32LE;
    buf.writeInt32LE = BufferMethods.writeInt32LE;
    buf.readFloatLE = BufferMethods.readFloatLE;
    buf.writeFloatLE = BufferMethods.writeFloatLE;
    buf.readDoubleLE = BufferMethods.readDoubleLE;
    buf.writeDoubleLE = BufferMethods.writeDoubleLE;
    buf.toString = BufferMethods.toString;
    buf.write = BufferMethods.write;
    buf.slice = BufferMethods.slice;
    buf.copy = BufferMethods.copy;

    buf._isBuffer = true;
    return buf;
}

var lastStr, lastStrEncoded;

BufferMethods = {
    readUInt32LE: function(pos) {
        return ((this[pos]) |
            (this[pos + 1] << 8) |
            (this[pos + 2] << 16)) +
            (this[pos + 3] * 0x1000000);
    },

    writeUInt32LE: function(val, pos) {
        this[pos] = val;
        this[pos + 1] = (val >>> 8);
        this[pos + 2] = (val >>> 16);
        this[pos + 3] = (val >>> 24);
    },

    readInt32LE: function(pos) {
        return ((this[pos]) |
            (this[pos + 1] << 8) |
            (this[pos + 2] << 16)) +
            (this[pos + 3] << 24);
    },

    readFloatLE:  function(pos) { return ieee754.read(this, pos, true, 23, 4); },
    readDoubleLE: function(pos) { return ieee754.read(this, pos, true, 52, 8); },

    writeFloatLE:  function(val, pos) { return ieee754.write(this, val, pos, true, 23, 4); },
    writeDoubleLE: function(val, pos) { return ieee754.write(this, val, pos, true, 52, 8); },

    toString: function(encoding, start, end) {
        var str = '',
            tmp = '';

        start = start || 0;
        end = Math.min(this.length, end || this.length);

        for (var i = start; i < end; i++) {
            var ch = this[i];
            if (ch <= 0x7F) {
                str += decodeURIComponent(tmp) + String.fromCharCode(ch);
                tmp = '';
            } else {
                tmp += '%' + ch.toString(16);
            }
        }

        str += decodeURIComponent(tmp);

        return str;
    },

    write: function(str, pos) {
        var bytes = str === lastStr ? lastStrEncoded : encodeString(str);
        for (var i = 0; i < bytes.length; i++) {
            this[pos + i] = bytes[i];
        }
    },

    slice: function(start, end) {
        return this.subarray(start, end);
    },

    copy: function(buf, pos) {
        pos = pos || 0;
        for (var i = 0; i < this.length; i++) {
            buf[pos + i] = this[i];
        }
    }
};

BufferMethods.writeInt32LE = BufferMethods.writeUInt32LE;

Buffer.byteLength = function(str) {
    lastStr = str;
    lastStrEncoded = encodeString(str);
    return lastStrEncoded.length;
};

Buffer.isBuffer = function(buf) {
    return !!(buf && buf._isBuffer);
};

function encodeString(str) {
    var length = str.length,
        bytes = [];

    for (var i = 0, c, lead; i < length; i++) {
        c = str.charCodeAt(i); // code point

        if (c > 0xD7FF && c < 0xE000) {

            if (lead) {
                if (c < 0xDC00) {
                    bytes.push(0xEF, 0xBF, 0xBD);
                    lead = c;
                    continue;

                } else {
                    c = lead - 0xD800 << 10 | c - 0xDC00 | 0x10000;
                    lead = null;
                }

            } else {
                if (c > 0xDBFF || (i + 1 === length)) bytes.push(0xEF, 0xBF, 0xBD);
                else lead = c;

                continue;
            }

        } else if (lead) {
            bytes.push(0xEF, 0xBF, 0xBD);
            lead = null;
        }

        if (c < 0x80) bytes.push(c);
        else if (c < 0x800) bytes.push(c >> 0x6 | 0xC0, c & 0x3F | 0x80);
        else if (c < 0x10000) bytes.push(c >> 0xC | 0xE0, c >> 0x6 & 0x3F | 0x80, c & 0x3F | 0x80);
        else bytes.push(c >> 0x12 | 0xF0, c >> 0xC & 0x3F | 0x80, c >> 0x6 & 0x3F | 0x80, c & 0x3F | 0x80);
    }
    return bytes;
}

},{"ieee754":161}],160:[function(require,module,exports){
(function (global){
'use strict';

module.exports = Pbf;

var Buffer = global.Buffer || require('./buffer');

function Pbf(buf) {
    this.buf = !Buffer.isBuffer(buf) ? new Buffer(buf || 0) : buf;
    this.pos = 0;
    this.length = this.buf.length;
}

Pbf.Varint  = 0; // varint: int32, int64, uint32, uint64, sint32, sint64, bool, enum
Pbf.Fixed64 = 1; // 64-bit: double, fixed64, sfixed64
Pbf.Bytes   = 2; // length-delimited: string, bytes, embedded messages, packed repeated fields
Pbf.Fixed32 = 5; // 32-bit: float, fixed32, sfixed32

var SHIFT_LEFT_32 = (1 << 16) * (1 << 16),
    SHIFT_RIGHT_32 = 1 / SHIFT_LEFT_32,
    POW_2_63 = Math.pow(2, 63);

Pbf.prototype = {

    destroy: function() {
        this.buf = null;
    },

    // === READING =================================================================

    readFields: function(readField, result, end) {
        end = end || this.length;

        while (this.pos < end) {
            var val = this.readVarint(),
                tag = val >> 3,
                startPos = this.pos;

            readField(tag, result, this);

            if (this.pos === startPos) this.skip(val);
        }
        return result;
    },

    readMessage: function(readField, result) {
        return this.readFields(readField, result, this.readVarint() + this.pos);
    },

    readFixed32: function() {
        var val = this.buf.readUInt32LE(this.pos);
        this.pos += 4;
        return val;
    },

    readSFixed32: function() {
        var val = this.buf.readInt32LE(this.pos);
        this.pos += 4;
        return val;
    },

    // 64-bit int handling is based on github.com/dpw/node-buffer-more-ints (MIT-licensed)

    readFixed64: function() {
        var val = this.buf.readUInt32LE(this.pos) + this.buf.readUInt32LE(this.pos + 4) * SHIFT_LEFT_32;
        this.pos += 8;
        return val;
    },

    readSFixed64: function() {
        var val = this.buf.readUInt32LE(this.pos) + this.buf.readInt32LE(this.pos + 4) * SHIFT_LEFT_32;
        this.pos += 8;
        return val;
    },

    readFloat: function() {
        var val = this.buf.readFloatLE(this.pos);
        this.pos += 4;
        return val;
    },

    readDouble: function() {
        var val = this.buf.readDoubleLE(this.pos);
        this.pos += 8;
        return val;
    },

    readVarint: function() {
        var buf = this.buf,
            val, b, b0, b1, b2, b3;

        b0 = buf[this.pos++]; if (b0 < 0x80) return b0;                 b0 = b0 & 0x7f;
        b1 = buf[this.pos++]; if (b1 < 0x80) return b0 | b1 << 7;       b1 = (b1 & 0x7f) << 7;
        b2 = buf[this.pos++]; if (b2 < 0x80) return b0 | b1 | b2 << 14; b2 = (b2 & 0x7f) << 14;
        b3 = buf[this.pos++]; if (b3 < 0x80) return b0 | b1 | b2 | b3 << 21;

        val = b0 | b1 | b2 | (b3 & 0x7f) << 21;

        b = buf[this.pos++]; val += (b & 0x7f) * 0x10000000;         if (b < 0x80) return val;
        b = buf[this.pos++]; val += (b & 0x7f) * 0x800000000;        if (b < 0x80) return val;
        b = buf[this.pos++]; val += (b & 0x7f) * 0x40000000000;      if (b < 0x80) return val;
        b = buf[this.pos++]; val += (b & 0x7f) * 0x2000000000000;    if (b < 0x80) return val;
        b = buf[this.pos++]; val += (b & 0x7f) * 0x100000000000000;  if (b < 0x80) return val;
        b = buf[this.pos++]; val += (b & 0x7f) * 0x8000000000000000; if (b < 0x80) return val;

        throw new Error('Expected varint not more than 10 bytes');
    },

    readVarint64: function() {
        var startPos = this.pos,
            val = this.readVarint();

        if (val < POW_2_63) return val;

        var pos = this.pos - 2;
        while (this.buf[pos] === 0xff) pos--;
        if (pos < startPos) pos = startPos;

        val = 0;
        for (var i = 0; i < pos - startPos + 1; i++) {
            var b = ~this.buf[startPos + i] & 0x7f;
            val += i < 4 ? b << i * 7 : b * Math.pow(2, i * 7);
        }

        return -val - 1;
    },

    readSVarint: function() {
        var num = this.readVarint();
        return num % 2 === 1 ? (num + 1) / -2 : num / 2; // zigzag encoding
    },

    readBoolean: function() {
        return Boolean(this.readVarint());
    },

    readString: function() {
        var end = this.readVarint() + this.pos,
            str = this.buf.toString('utf8', this.pos, end);
        this.pos = end;
        return str;
    },

    readBytes: function() {
        var end = this.readVarint() + this.pos,
            buffer = this.buf.slice(this.pos, end);
        this.pos = end;
        return buffer;
    },

    // verbose for performance reasons; doesn't affect gzipped size

    readPackedVarint: function() {
        var end = this.readVarint() + this.pos, arr = [];
        while (this.pos < end) arr.push(this.readVarint());
        return arr;
    },
    readPackedSVarint: function() {
        var end = this.readVarint() + this.pos, arr = [];
        while (this.pos < end) arr.push(this.readSVarint());
        return arr;
    },
    readPackedBoolean: function() {
        var end = this.readVarint() + this.pos, arr = [];
        while (this.pos < end) arr.push(this.readBoolean());
        return arr;
    },
    readPackedFloat: function() {
        var end = this.readVarint() + this.pos, arr = [];
        while (this.pos < end) arr.push(this.readFloat());
        return arr;
    },
    readPackedDouble: function() {
        var end = this.readVarint() + this.pos, arr = [];
        while (this.pos < end) arr.push(this.readDouble());
        return arr;
    },
    readPackedFixed32: function() {
        var end = this.readVarint() + this.pos, arr = [];
        while (this.pos < end) arr.push(this.readFixed32());
        return arr;
    },
    readPackedSFixed32: function() {
        var end = this.readVarint() + this.pos, arr = [];
        while (this.pos < end) arr.push(this.readSFixed32());
        return arr;
    },
    readPackedFixed64: function() {
        var end = this.readVarint() + this.pos, arr = [];
        while (this.pos < end) arr.push(this.readFixed64());
        return arr;
    },
    readPackedSFixed64: function() {
        var end = this.readVarint() + this.pos, arr = [];
        while (this.pos < end) arr.push(this.readSFixed64());
        return arr;
    },

    skip: function(val) {
        var type = val & 0x7;
        if (type === Pbf.Varint) while (this.buf[this.pos++] > 0x7f) {}
        else if (type === Pbf.Bytes) this.pos = this.readVarint() + this.pos;
        else if (type === Pbf.Fixed32) this.pos += 4;
        else if (type === Pbf.Fixed64) this.pos += 8;
        else throw new Error('Unimplemented type: ' + type);
    },

    // === WRITING =================================================================

    writeTag: function(tag, type) {
        this.writeVarint((tag << 3) | type);
    },

    realloc: function(min) {
        var length = this.length || 16;

        while (length < this.pos + min) length *= 2;

        if (length !== this.length) {
            var buf = new Buffer(length);
            this.buf.copy(buf);
            this.buf = buf;
            this.length = length;
        }
    },

    finish: function() {
        this.length = this.pos;
        this.pos = 0;
        return this.buf.slice(0, this.length);
    },

    writeFixed32: function(val) {
        this.realloc(4);
        this.buf.writeUInt32LE(val, this.pos);
        this.pos += 4;
    },

    writeSFixed32: function(val) {
        this.realloc(4);
        this.buf.writeInt32LE(val, this.pos);
        this.pos += 4;
    },

    writeFixed64: function(val) {
        this.realloc(8);
        this.buf.writeInt32LE(val & -1, this.pos);
        this.buf.writeUInt32LE(Math.floor(val * SHIFT_RIGHT_32), this.pos + 4);
        this.pos += 8;
    },

    writeSFixed64: function(val) {
        this.realloc(8);
        this.buf.writeInt32LE(val & -1, this.pos);
        this.buf.writeInt32LE(Math.floor(val * SHIFT_RIGHT_32), this.pos + 4);
        this.pos += 8;
    },

    writeVarint: function(val) {
        val = +val;

        if (val <= 0x7f) {
            this.realloc(1);
            this.buf[this.pos++] = val;

        } else if (val <= 0x3fff) {
            this.realloc(2);
            this.buf[this.pos++] = ((val >>> 0) & 0x7f) | 0x80;
            this.buf[this.pos++] = ((val >>> 7) & 0x7f);

        } else if (val <= 0x1fffff) {
            this.realloc(3);
            this.buf[this.pos++] = ((val >>> 0) & 0x7f) | 0x80;
            this.buf[this.pos++] = ((val >>> 7) & 0x7f) | 0x80;
            this.buf[this.pos++] = ((val >>> 14) & 0x7f);

        } else if (val <= 0xfffffff) {
            this.realloc(4);
            this.buf[this.pos++] = ((val >>> 0) & 0x7f) | 0x80;
            this.buf[this.pos++] = ((val >>> 7) & 0x7f) | 0x80;
            this.buf[this.pos++] = ((val >>> 14) & 0x7f) | 0x80;
            this.buf[this.pos++] = ((val >>> 21) & 0x7f);

        } else {
            var pos = this.pos;
            while (val >= 0x80) {
                this.realloc(1);
                this.buf[this.pos++] = (val & 0xff) | 0x80;
                val /= 0x80;
            }
            this.realloc(1);
            this.buf[this.pos++] = val | 0;
            if (this.pos - pos > 10) throw new Error('Given varint doesn\'t fit into 10 bytes');
        }
    },

    writeSVarint: function(val) {
        this.writeVarint(val < 0 ? -val * 2 - 1 : val * 2);
    },

    writeBoolean: function(val) {
        this.writeVarint(Boolean(val));
    },

    writeString: function(str) {
        str = String(str);
        var bytes = Buffer.byteLength(str);
        this.writeVarint(bytes);
        this.realloc(bytes);
        this.buf.write(str, this.pos);
        this.pos += bytes;
    },

    writeFloat: function(val) {
        this.realloc(4);
        this.buf.writeFloatLE(val, this.pos);
        this.pos += 4;
    },

    writeDouble: function(val) {
        this.realloc(8);
        this.buf.writeDoubleLE(val, this.pos);
        this.pos += 8;
    },

    writeBytes: function(buffer) {
        var len = buffer.length;
        this.writeVarint(len);
        this.realloc(len);
        for (var i = 0; i < len; i++) this.buf[this.pos++] = buffer[i];
    },

    writeRawMessage: function(fn, obj) {
        this.pos++; // reserve 1 byte for short message length

        // write the message directly to the buffer and see how much was written
        var startPos = this.pos;
        fn(obj, this);
        var len = this.pos - startPos;

        var varintLen =
            len <= 0x7f ? 1 :
            len <= 0x3fff ? 2 :
            len <= 0x1fffff ? 3 :
            len <= 0xfffffff ? 4 : Math.ceil(Math.log(len) / (Math.LN2 * 7));

        // if 1 byte isn't enough for encoding message length, shift the data to the right
        if (varintLen > 1) {
            this.realloc(varintLen - 1);
            for (var i = this.pos - 1; i >= startPos; i--) this.buf[i + varintLen - 1] = this.buf[i];
        }

        // finally, write the message length in the reserved place and restore the position
        this.pos = startPos - 1;
        this.writeVarint(len);
        this.pos += len;
    },

    writeMessage: function(tag, fn, obj) {
        this.writeTag(tag, Pbf.Bytes);
        this.writeRawMessage(fn, obj);
    },

    writePackedVarint:   function(tag, arr) { this.writeMessage(tag, writePackedVarint, arr);   },
    writePackedSVarint:  function(tag, arr) { this.writeMessage(tag, writePackedSVarint, arr);  },
    writePackedBoolean:  function(tag, arr) { this.writeMessage(tag, writePackedBoolean, arr);  },
    writePackedFloat:    function(tag, arr) { this.writeMessage(tag, writePackedFloat, arr);    },
    writePackedDouble:   function(tag, arr) { this.writeMessage(tag, writePackedDouble, arr);   },
    writePackedFixed32:  function(tag, arr) { this.writeMessage(tag, writePackedFixed32, arr);  },
    writePackedSFixed32: function(tag, arr) { this.writeMessage(tag, writePackedSFixed32, arr); },
    writePackedFixed64:  function(tag, arr) { this.writeMessage(tag, writePackedFixed64, arr);  },
    writePackedSFixed64: function(tag, arr) { this.writeMessage(tag, writePackedSFixed64, arr); },

    writeBytesField: function(tag, buffer) {
        this.writeTag(tag, Pbf.Bytes);
        this.writeBytes(buffer);
    },
    writeFixed32Field: function(tag, val) {
        this.writeTag(tag, Pbf.Fixed32);
        this.writeFixed32(val);
    },
    writeSFixed32Field: function(tag, val) {
        this.writeTag(tag, Pbf.Fixed32);
        this.writeSFixed32(val);
    },
    writeFixed64Field: function(tag, val) {
        this.writeTag(tag, Pbf.Fixed64);
        this.writeFixed64(val);
    },
    writeSFixed64Field: function(tag, val) {
        this.writeTag(tag, Pbf.Fixed64);
        this.writeSFixed64(val);
    },
    writeVarintField: function(tag, val) {
        this.writeTag(tag, Pbf.Varint);
        this.writeVarint(val);
    },
    writeSVarintField: function(tag, val) {
        this.writeTag(tag, Pbf.Varint);
        this.writeSVarint(val);
    },
    writeStringField: function(tag, str) {
        this.writeTag(tag, Pbf.Bytes);
        this.writeString(str);
    },
    writeFloatField: function(tag, val) {
        this.writeTag(tag, Pbf.Fixed32);
        this.writeFloat(val);
    },
    writeDoubleField: function(tag, val) {
        this.writeTag(tag, Pbf.Fixed64);
        this.writeDouble(val);
    },
    writeBooleanField: function(tag, val) {
        this.writeVarintField(tag, Boolean(val));
    }
};

function writePackedVarint(arr, pbf)   { for (var i = 0; i < arr.length; i++) pbf.writeVarint(arr[i]);   }
function writePackedSVarint(arr, pbf)  { for (var i = 0; i < arr.length; i++) pbf.writeSVarint(arr[i]);  }
function writePackedFloat(arr, pbf)    { for (var i = 0; i < arr.length; i++) pbf.writeFloat(arr[i]);    }
function writePackedDouble(arr, pbf)   { for (var i = 0; i < arr.length; i++) pbf.writeDouble(arr[i]);   }
function writePackedBoolean(arr, pbf)  { for (var i = 0; i < arr.length; i++) pbf.writeBoolean(arr[i]);  }
function writePackedFixed32(arr, pbf)  { for (var i = 0; i < arr.length; i++) pbf.writeFixed32(arr[i]);  }
function writePackedSFixed32(arr, pbf) { for (var i = 0; i < arr.length; i++) pbf.writeSFixed32(arr[i]); }
function writePackedFixed64(arr, pbf)  { for (var i = 0; i < arr.length; i++) pbf.writeFixed64(arr[i]);  }
function writePackedSFixed64(arr, pbf) { for (var i = 0; i < arr.length; i++) pbf.writeSFixed64(arr[i]); }

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./buffer":159}],161:[function(require,module,exports){
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = nBytes * 8 - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = nBytes * 8 - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}

},{}],162:[function(require,module,exports){
'use strict';

module.exports = Point;

function Point(x, y) {
    this.x = x;
    this.y = y;
}

Point.prototype = {
    clone: function() { return new Point(this.x, this.y); },

    add:     function(p) { return this.clone()._add(p);     },
    sub:     function(p) { return this.clone()._sub(p);     },
    mult:    function(k) { return this.clone()._mult(k);    },
    div:     function(k) { return this.clone()._div(k);     },
    rotate:  function(a) { return this.clone()._rotate(a);  },
    matMult: function(m) { return this.clone()._matMult(m); },
    unit:    function() { return this.clone()._unit(); },
    perp:    function() { return this.clone()._perp(); },
    round:   function() { return this.clone()._round(); },

    mag: function() {
        return Math.sqrt(this.x * this.x + this.y * this.y);
    },

    equals: function(p) {
        return this.x === p.x &&
               this.y === p.y;
    },

    dist: function(p) {
        return Math.sqrt(this.distSqr(p));
    },

    distSqr: function(p) {
        var dx = p.x - this.x,
            dy = p.y - this.y;
        return dx * dx + dy * dy;
    },

    angle: function() {
        return Math.atan2(this.y, this.x);
    },

    angleTo: function(b) {
        return Math.atan2(this.y - b.y, this.x - b.x);
    },

    angleWith: function(b) {
        return this.angleWithSep(b.x, b.y);
    },

    // Find the angle of the two vectors, solving the formula for the cross product a x b = |a||b|sin(θ) for θ.
    angleWithSep: function(x, y) {
        return Math.atan2(
            this.x * y - this.y * x,
            this.x * x + this.y * y);
    },

    _matMult: function(m) {
        var x = m[0] * this.x + m[1] * this.y,
            y = m[2] * this.x + m[3] * this.y;
        this.x = x;
        this.y = y;
        return this;
    },

    _add: function(p) {
        this.x += p.x;
        this.y += p.y;
        return this;
    },

    _sub: function(p) {
        this.x -= p.x;
        this.y -= p.y;
        return this;
    },

    _mult: function(k) {
        this.x *= k;
        this.y *= k;
        return this;
    },

    _div: function(k) {
        this.x /= k;
        this.y /= k;
        return this;
    },

    _unit: function() {
        this._div(this.mag());
        return this;
    },

    _perp: function() {
        var y = this.y;
        this.y = this.x;
        this.x = -y;
        return this;
    },

    _rotate: function(angle) {
        var cos = Math.cos(angle),
            sin = Math.sin(angle),
            x = cos * this.x - sin * this.y,
            y = sin * this.x + cos * this.y;
        this.x = x;
        this.y = y;
        return this;
    },

    _round: function() {
        this.x = Math.round(this.x);
        this.y = Math.round(this.y);
        return this;
    }
};

// constructs Point from an array if necessary
Point.convert = function (a) {
    if (a instanceof Point) {
        return a;
    }
    if (Array.isArray(a)) {
        return new Point(a[0], a[1]);
    }
    return a;
};

},{}],163:[function(require,module,exports){
/*
 (c) 2015, Vladimir Agafonkin
 RBush, a JavaScript library for high-performance 2D spatial indexing of points and rectangles.
 https://github.com/mourner/rbush
*/

(function () {
'use strict';

function rbush(maxEntries, format) {

    // jshint newcap: false, validthis: true
    if (!(this instanceof rbush)) return new rbush(maxEntries, format);

    // max entries in a node is 9 by default; min node fill is 40% for best performance
    this._maxEntries = Math.max(4, maxEntries || 9);
    this._minEntries = Math.max(2, Math.ceil(this._maxEntries * 0.4));

    if (format) {
        this._initFormat(format);
    }

    this.clear();
}

rbush.prototype = {

    all: function () {
        return this._all(this.data, []);
    },

    search: function (bbox) {

        var node = this.data,
            result = [],
            toBBox = this.toBBox;

        if (!intersects(bbox, node.bbox)) return result;

        var nodesToSearch = [],
            i, len, child, childBBox;

        while (node) {
            for (i = 0, len = node.children.length; i < len; i++) {

                child = node.children[i];
                childBBox = node.leaf ? toBBox(child) : child.bbox;

                if (intersects(bbox, childBBox)) {
                    if (node.leaf) result.push(child);
                    else if (contains(bbox, childBBox)) this._all(child, result);
                    else nodesToSearch.push(child);
                }
            }
            node = nodesToSearch.pop();
        }

        return result;
    },

    collides: function (bbox) {

        var node = this.data,
            toBBox = this.toBBox;

        if (!intersects(bbox, node.bbox)) return false;

        var nodesToSearch = [],
            i, len, child, childBBox;

        while (node) {
            for (i = 0, len = node.children.length; i < len; i++) {

                child = node.children[i];
                childBBox = node.leaf ? toBBox(child) : child.bbox;

                if (intersects(bbox, childBBox)) {
                    if (node.leaf || contains(bbox, childBBox)) return true;
                    nodesToSearch.push(child);
                }
            }
            node = nodesToSearch.pop();
        }

        return false;
    },

    load: function (data) {
        if (!(data && data.length)) return this;

        if (data.length < this._minEntries) {
            for (var i = 0, len = data.length; i < len; i++) {
                this.insert(data[i]);
            }
            return this;
        }

        // recursively build the tree with the given data from stratch using OMT algorithm
        var node = this._build(data.slice(), 0, data.length - 1, 0);

        if (!this.data.children.length) {
            // save as is if tree is empty
            this.data = node;

        } else if (this.data.height === node.height) {
            // split root if trees have the same height
            this._splitRoot(this.data, node);

        } else {
            if (this.data.height < node.height) {
                // swap trees if inserted one is bigger
                var tmpNode = this.data;
                this.data = node;
                node = tmpNode;
            }

            // insert the small tree into the large tree at appropriate level
            this._insert(node, this.data.height - node.height - 1, true);
        }

        return this;
    },

    insert: function (item) {
        if (item) this._insert(item, this.data.height - 1);
        return this;
    },

    clear: function () {
        this.data = {
            children: [],
            height: 1,
            bbox: empty(),
            leaf: true
        };
        return this;
    },

    remove: function (item) {
        if (!item) return this;

        var node = this.data,
            bbox = this.toBBox(item),
            path = [],
            indexes = [],
            i, parent, index, goingUp;

        // depth-first iterative tree traversal
        while (node || path.length) {

            if (!node) { // go up
                node = path.pop();
                parent = path[path.length - 1];
                i = indexes.pop();
                goingUp = true;
            }

            if (node.leaf) { // check current node
                index = node.children.indexOf(item);

                if (index !== -1) {
                    // item found, remove the item and condense tree upwards
                    node.children.splice(index, 1);
                    path.push(node);
                    this._condense(path);
                    return this;
                }
            }

            if (!goingUp && !node.leaf && contains(node.bbox, bbox)) { // go down
                path.push(node);
                indexes.push(i);
                i = 0;
                parent = node;
                node = node.children[0];

            } else if (parent) { // go right
                i++;
                node = parent.children[i];
                goingUp = false;

            } else node = null; // nothing found
        }

        return this;
    },

    toBBox: function (item) { return item; },

    compareMinX: function (a, b) { return a[0] - b[0]; },
    compareMinY: function (a, b) { return a[1] - b[1]; },

    toJSON: function () { return this.data; },

    fromJSON: function (data) {
        this.data = data;
        return this;
    },

    _all: function (node, result) {
        var nodesToSearch = [];
        while (node) {
            if (node.leaf) result.push.apply(result, node.children);
            else nodesToSearch.push.apply(nodesToSearch, node.children);

            node = nodesToSearch.pop();
        }
        return result;
    },

    _build: function (items, left, right, height) {

        var N = right - left + 1,
            M = this._maxEntries,
            node;

        if (N <= M) {
            // reached leaf level; return leaf
            node = {
                children: items.slice(left, right + 1),
                height: 1,
                bbox: null,
                leaf: true
            };
            calcBBox(node, this.toBBox);
            return node;
        }

        if (!height) {
            // target height of the bulk-loaded tree
            height = Math.ceil(Math.log(N) / Math.log(M));

            // target number of root entries to maximize storage utilization
            M = Math.ceil(N / Math.pow(M, height - 1));
        }

        node = {
            children: [],
            height: height,
            bbox: null,
            leaf: false
        };

        // split the items into M mostly square tiles

        var N2 = Math.ceil(N / M),
            N1 = N2 * Math.ceil(Math.sqrt(M)),
            i, j, right2, right3;

        multiSelect(items, left, right, N1, this.compareMinX);

        for (i = left; i <= right; i += N1) {

            right2 = Math.min(i + N1 - 1, right);

            multiSelect(items, i, right2, N2, this.compareMinY);

            for (j = i; j <= right2; j += N2) {

                right3 = Math.min(j + N2 - 1, right2);

                // pack each entry recursively
                node.children.push(this._build(items, j, right3, height - 1));
            }
        }

        calcBBox(node, this.toBBox);

        return node;
    },

    _chooseSubtree: function (bbox, node, level, path) {

        var i, len, child, targetNode, area, enlargement, minArea, minEnlargement;

        while (true) {
            path.push(node);

            if (node.leaf || path.length - 1 === level) break;

            minArea = minEnlargement = Infinity;

            for (i = 0, len = node.children.length; i < len; i++) {
                child = node.children[i];
                area = bboxArea(child.bbox);
                enlargement = enlargedArea(bbox, child.bbox) - area;

                // choose entry with the least area enlargement
                if (enlargement < minEnlargement) {
                    minEnlargement = enlargement;
                    minArea = area < minArea ? area : minArea;
                    targetNode = child;

                } else if (enlargement === minEnlargement) {
                    // otherwise choose one with the smallest area
                    if (area < minArea) {
                        minArea = area;
                        targetNode = child;
                    }
                }
            }

            node = targetNode;
        }

        return node;
    },

    _insert: function (item, level, isNode) {

        var toBBox = this.toBBox,
            bbox = isNode ? item.bbox : toBBox(item),
            insertPath = [];

        // find the best node for accommodating the item, saving all nodes along the path too
        var node = this._chooseSubtree(bbox, this.data, level, insertPath);

        // put the item into the node
        node.children.push(item);
        extend(node.bbox, bbox);

        // split on node overflow; propagate upwards if necessary
        while (level >= 0) {
            if (insertPath[level].children.length > this._maxEntries) {
                this._split(insertPath, level);
                level--;
            } else break;
        }

        // adjust bboxes along the insertion path
        this._adjustParentBBoxes(bbox, insertPath, level);
    },

    // split overflowed node into two
    _split: function (insertPath, level) {

        var node = insertPath[level],
            M = node.children.length,
            m = this._minEntries;

        this._chooseSplitAxis(node, m, M);

        var splitIndex = this._chooseSplitIndex(node, m, M);

        var newNode = {
            children: node.children.splice(splitIndex, node.children.length - splitIndex),
            height: node.height,
            bbox: null,
            leaf: false
        };

        if (node.leaf) newNode.leaf = true;

        calcBBox(node, this.toBBox);
        calcBBox(newNode, this.toBBox);

        if (level) insertPath[level - 1].children.push(newNode);
        else this._splitRoot(node, newNode);
    },

    _splitRoot: function (node, newNode) {
        // split root node
        this.data = {
            children: [node, newNode],
            height: node.height + 1,
            bbox: null,
            leaf: false
        };
        calcBBox(this.data, this.toBBox);
    },

    _chooseSplitIndex: function (node, m, M) {

        var i, bbox1, bbox2, overlap, area, minOverlap, minArea, index;

        minOverlap = minArea = Infinity;

        for (i = m; i <= M - m; i++) {
            bbox1 = distBBox(node, 0, i, this.toBBox);
            bbox2 = distBBox(node, i, M, this.toBBox);

            overlap = intersectionArea(bbox1, bbox2);
            area = bboxArea(bbox1) + bboxArea(bbox2);

            // choose distribution with minimum overlap
            if (overlap < minOverlap) {
                minOverlap = overlap;
                index = i;

                minArea = area < minArea ? area : minArea;

            } else if (overlap === minOverlap) {
                // otherwise choose distribution with minimum area
                if (area < minArea) {
                    minArea = area;
                    index = i;
                }
            }
        }

        return index;
    },

    // sorts node children by the best axis for split
    _chooseSplitAxis: function (node, m, M) {

        var compareMinX = node.leaf ? this.compareMinX : compareNodeMinX,
            compareMinY = node.leaf ? this.compareMinY : compareNodeMinY,
            xMargin = this._allDistMargin(node, m, M, compareMinX),
            yMargin = this._allDistMargin(node, m, M, compareMinY);

        // if total distributions margin value is minimal for x, sort by minX,
        // otherwise it's already sorted by minY
        if (xMargin < yMargin) node.children.sort(compareMinX);
    },

    // total margin of all possible split distributions where each node is at least m full
    _allDistMargin: function (node, m, M, compare) {

        node.children.sort(compare);

        var toBBox = this.toBBox,
            leftBBox = distBBox(node, 0, m, toBBox),
            rightBBox = distBBox(node, M - m, M, toBBox),
            margin = bboxMargin(leftBBox) + bboxMargin(rightBBox),
            i, child;

        for (i = m; i < M - m; i++) {
            child = node.children[i];
            extend(leftBBox, node.leaf ? toBBox(child) : child.bbox);
            margin += bboxMargin(leftBBox);
        }

        for (i = M - m - 1; i >= m; i--) {
            child = node.children[i];
            extend(rightBBox, node.leaf ? toBBox(child) : child.bbox);
            margin += bboxMargin(rightBBox);
        }

        return margin;
    },

    _adjustParentBBoxes: function (bbox, path, level) {
        // adjust bboxes along the given tree path
        for (var i = level; i >= 0; i--) {
            extend(path[i].bbox, bbox);
        }
    },

    _condense: function (path) {
        // go through the path, removing empty nodes and updating bboxes
        for (var i = path.length - 1, siblings; i >= 0; i--) {
            if (path[i].children.length === 0) {
                if (i > 0) {
                    siblings = path[i - 1].children;
                    siblings.splice(siblings.indexOf(path[i]), 1);

                } else this.clear();

            } else calcBBox(path[i], this.toBBox);
        }
    },

    _initFormat: function (format) {
        // data format (minX, minY, maxX, maxY accessors)

        // uses eval-type function compilation instead of just accepting a toBBox function
        // because the algorithms are very sensitive to sorting functions performance,
        // so they should be dead simple and without inner calls

        // jshint evil: true

        var compareArr = ['return a', ' - b', ';'];

        this.compareMinX = new Function('a', 'b', compareArr.join(format[0]));
        this.compareMinY = new Function('a', 'b', compareArr.join(format[1]));

        this.toBBox = new Function('a', 'return [a' + format.join(', a') + '];');
    }
};


// calculate node's bbox from bboxes of its children
function calcBBox(node, toBBox) {
    node.bbox = distBBox(node, 0, node.children.length, toBBox);
}

// min bounding rectangle of node children from k to p-1
function distBBox(node, k, p, toBBox) {
    var bbox = empty();

    for (var i = k, child; i < p; i++) {
        child = node.children[i];
        extend(bbox, node.leaf ? toBBox(child) : child.bbox);
    }

    return bbox;
}

function empty() { return [Infinity, Infinity, -Infinity, -Infinity]; }

function extend(a, b) {
    a[0] = Math.min(a[0], b[0]);
    a[1] = Math.min(a[1], b[1]);
    a[2] = Math.max(a[2], b[2]);
    a[3] = Math.max(a[3], b[3]);
    return a;
}

function compareNodeMinX(a, b) { return a.bbox[0] - b.bbox[0]; }
function compareNodeMinY(a, b) { return a.bbox[1] - b.bbox[1]; }

function bboxArea(a)   { return (a[2] - a[0]) * (a[3] - a[1]); }
function bboxMargin(a) { return (a[2] - a[0]) + (a[3] - a[1]); }

function enlargedArea(a, b) {
    return (Math.max(b[2], a[2]) - Math.min(b[0], a[0])) *
           (Math.max(b[3], a[3]) - Math.min(b[1], a[1]));
}

function intersectionArea(a, b) {
    var minX = Math.max(a[0], b[0]),
        minY = Math.max(a[1], b[1]),
        maxX = Math.min(a[2], b[2]),
        maxY = Math.min(a[3], b[3]);

    return Math.max(0, maxX - minX) *
           Math.max(0, maxY - minY);
}

function contains(a, b) {
    return a[0] <= b[0] &&
           a[1] <= b[1] &&
           b[2] <= a[2] &&
           b[3] <= a[3];
}

function intersects(a, b) {
    return b[0] <= a[2] &&
           b[1] <= a[3] &&
           b[2] >= a[0] &&
           b[3] >= a[1];
}

// sort an array so that items come in groups of n unsorted items, with groups sorted between each other;
// combines selection algorithm with binary divide & conquer approach

function multiSelect(arr, left, right, n, compare) {
    var stack = [left, right],
        mid;

    while (stack.length) {
        right = stack.pop();
        left = stack.pop();

        if (right - left <= n) continue;

        mid = left + Math.ceil((right - left) / n / 2) * n;
        select(arr, left, right, mid, compare);

        stack.push(left, mid, mid, right);
    }
}

// Floyd-Rivest selection algorithm:
// sort an array between left and right (inclusive) so that the smallest k elements come first (unordered)
function select(arr, left, right, k, compare) {
    var n, i, z, s, sd, newLeft, newRight, t, j;

    while (right > left) {
        if (right - left > 600) {
            n = right - left + 1;
            i = k - left + 1;
            z = Math.log(n);
            s = 0.5 * Math.exp(2 * z / 3);
            sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (i - n / 2 < 0 ? -1 : 1);
            newLeft = Math.max(left, Math.floor(k - i * s / n + sd));
            newRight = Math.min(right, Math.floor(k + (n - i) * s / n + sd));
            select(arr, newLeft, newRight, k, compare);
        }

        t = arr[k];
        i = left;
        j = right;

        swap(arr, left, k);
        if (compare(arr[right], t) > 0) swap(arr, left, right);

        while (i < j) {
            swap(arr, i, j);
            i++;
            j--;
            while (compare(arr[i], t) < 0) i++;
            while (compare(arr[j], t) > 0) j--;
        }

        if (compare(arr[left], t) === 0) swap(arr, left, j);
        else {
            j++;
            swap(arr, j, right);
        }

        if (j <= k) left = j + 1;
        if (k <= j) right = j - 1;
    }
}

function swap(arr, i, j) {
    var tmp = arr[i];
    arr[i] = arr[j];
    arr[j] = tmp;
}


// export as AMD/CommonJS module or global variable
if (typeof define === 'function' && define.amd) define('rbush', function () { return rbush; });
else if (typeof module !== 'undefined') module.exports = rbush;
else if (typeof self !== 'undefined') self.rbush = rbush;
else window.rbush = rbush;

})();

},{}],164:[function(require,module,exports){
// Copyright 2014 Simon Lydell
// X11 (“MIT”) Licensed. (See LICENSE.)

void (function(root, factory) {
  if (typeof define === "function" && define.amd) {
    define(factory)
  } else if (typeof exports === "object") {
    module.exports = factory()
  } else {
    root.resolveUrl = factory()
  }
}(this, function() {

  function resolveUrl(/* ...urls */) {
    var numUrls = arguments.length

    if (numUrls === 0) {
      throw new Error("resolveUrl requires at least one argument; got none.")
    }

    var base = document.createElement("base")
    base.href = arguments[0]

    if (numUrls === 1) {
      return base.href
    }

    var head = document.getElementsByTagName("head")[0]
    head.insertBefore(base, head.firstChild)

    var a = document.createElement("a")
    var resolved

    for (var index = 1; index < numUrls; index++) {
      a.href = arguments[index]
      resolved = a.href
      base.href = resolved
    }

    head.removeChild(base)

    return resolved
  }

  return resolveUrl

}));

},{}],165:[function(require,module,exports){
'use strict';

module.exports = ShelfPack;

/**
 * Uses the Shelf Best Height Fit algorithm from
 * http://clb.demon.fi/files/RectangleBinPack.pdf
 * @private
 */
function ShelfPack(width, height) {
    this.width = width;
    this.height = height;
    this.shelves = [];
    this.stats = {};
    this.count = function(h) {
        this.stats[h] = (this.stats[h] | 0) + 1;
    };
}

ShelfPack.prototype.allocate = function(reqWidth, reqHeight) {
    var y = 0,
        best = { shelf: -1, waste: Infinity },
        shelf, waste;

    // find shelf
    for (var i = 0; i < this.shelves.length; i++) {
        shelf = this.shelves[i];
        y += shelf.height;

        // exactly the right height with width to spare, pack it..
        if (reqHeight === shelf.height && reqWidth <= shelf.free) {
            this.count(reqHeight);
            return shelf.alloc(reqWidth, reqHeight);
        }
        // not enough height or width, skip it..
        if (reqHeight > shelf.height || reqWidth > shelf.free) {
            continue;
        }
        // maybe enough height or width, minimize waste..
        if (reqHeight < shelf.height && reqWidth <= shelf.free) {
            waste = shelf.height - reqHeight;
            if (waste < best.waste) {
                best.waste = waste;
                best.shelf = i;
            }
        }
    }

    if (best.shelf !== -1) {
        shelf = this.shelves[best.shelf];
        this.count(reqHeight);
        return shelf.alloc(reqWidth, reqHeight);
    }

    // add shelf
    if (reqHeight <= (this.height - y) && reqWidth <= this.width) {
        shelf = new Shelf(y, this.width, reqHeight);
        this.shelves.push(shelf);
        this.count(reqHeight);
        return shelf.alloc(reqWidth, reqHeight);
    }

    // no more space
    return {x: -1, y: -1};
};


ShelfPack.prototype.resize = function(reqWidth, reqHeight) {
    if (reqWidth < this.width || reqHeight < this.height) { return false; }
    this.height = reqHeight;
    this.width = reqWidth;
    for (var i = 0; i < this.shelves.length; i++) {
        this.shelves[i].resize(reqWidth);
    }
    return true;
};


function Shelf(y, width, height) {
    this.y = y;
    this.x = 0;
    this.width = this.free = width;
    this.height = height;
}

Shelf.prototype = {
    alloc: function(reqWidth, reqHeight) {
        if (reqWidth > this.free || reqHeight > this.height) {
            return {x: -1, y: -1};
        }
        var x = this.x;
        this.x += reqWidth;
        this.free -= reqWidth;
        return {x: x, y: this.y, w: reqWidth, h: reqHeight};
    },

    resize: function(reqWidth) {
        if (reqWidth < this.width) { return false; }
        this.free += (reqWidth - this.width);
        this.width = reqWidth;
        return true;
    }
};


},{}],166:[function(require,module,exports){
'use strict';

var rbush = require('rbush');

module.exports = supercluster;

function supercluster(options) {
    return new SuperCluster(options);
}

function SuperCluster(options) {
    this.options = extend(Object.create(this.options), options);
    this._initTrees();
}

SuperCluster.prototype = {
    options: {
        minZoom: 0,   // min zoom to generate clusters on
        maxZoom: 16,  // max zoom level to cluster the points on
        radius: 40,   // cluster radius in pixels
        extent: 512,  // tile extent (radius is calculated relative to it)
        nodeSize: 16, // size of the R-tree leaf node, affects performance
        log: false    // whether to log timing info
    },

    load: function (points) {
        var log = this.options.log;

        if (log) console.time('total time');

        var timerId = 'prepare ' + points.length + ' points';
        if (log) console.time(timerId);

        // generate a cluster object for each point
        var clusters = points.map(createPointCluster);
        if (log) console.timeEnd(timerId);

        // cluster points on max zoom, then cluster the results on previous zoom, etc.;
        // results in a cluster hierarchy across zoom levels
        for (var z = this.options.maxZoom; z >= this.options.minZoom; z--) {
            var now = +Date.now();

            this.trees[z + 1].load(clusters); // index input points into an R-tree
            clusters = this._cluster(clusters, z); // create a new set of clusters for the zoom

            if (log) console.log('z%d: %d clusters in %dms', z, clusters.length, +Date.now() - now);
        }
        this.trees[this.options.minZoom].load(clusters); // index top-level clusters

        if (log) console.timeEnd('total time');

        return this;
    },

    getClusters: function (bbox, zoom) {
        var projBBox = [lngX(bbox[0]), latY(bbox[3]), lngX(bbox[2]), latY(bbox[1])];
        var z = Math.max(this.options.minZoom, Math.min(zoom, this.options.maxZoom + 1));
        var clusters = this.trees[z].search(projBBox);
        return clusters.map(getClusterJSON);
    },

    getTile: function (z, x, y) {
        var z2 = Math.pow(2, z);
        var extent = this.options.extent;
        var p = this.options.radius / extent;
        var clusters = this.trees[z].search([
            (x - p) / z2,
            (y - p) / z2,
            (x + 1 + p) / z2,
            (y + 1 + p) / z2
        ]);
        if (!clusters.length) return null;
        var tile = {
            features: []
        };
        for (var i = 0; i < clusters.length; i++) {
            var c = clusters[i];
            var feature = {
                type: 1,
                geometry: [[
                    Math.round(extent * (c.wx * z2 - x)),
                    Math.round(extent * (c.wy * z2 - y))
                ]],
                tags: c.point ? c.point.properties : getClusterProperties(c)
            };
            tile.features.push(feature);
        }
        return tile;
    },

    _initTrees: function () {
        this.trees = [];
        // make an R-Tree index for each zoom level
        for (var z = 0; z <= this.options.maxZoom + 1; z++) {
            this.trees[z] = rbush(this.options.nodeSize);
            this.trees[z].toBBox = toBBox;
            this.trees[z].compareMinX = compareMinX;
            this.trees[z].compareMinY = compareMinY;
        }
    },

    _cluster: function (points, zoom) {
        var clusters = [];
        var r = this.options.radius / (this.options.extent * Math.pow(2, zoom));
        var bbox = [0, 0, 0, 0];

        // loop through each point
        for (var i = 0; i < points.length; i++) {
            var p = points[i];
            // if we've already visited the point at this zoom level, skip it
            if (p.zoom <= zoom) continue;
            p.zoom = zoom;

            // find all nearby points with a bbox search
            bbox[0] = p.wx - r;
            bbox[1] = p.wy - r;
            bbox[2] = p.wx + r;
            bbox[3] = p.wy + r;
            var bboxNeighbors = this.trees[zoom + 1].search(bbox);

            var foundNeighbors = false;
            var numPoints = p.numPoints;
            var wx = p.wx * numPoints;
            var wy = p.wy * numPoints;

            for (var j = 0; j < bboxNeighbors.length; j++) {
                var b = bboxNeighbors[j];
                // filter out neighbors that are too far or already processed
                if (zoom < b.zoom && distSq(p, b) <= r * r) {
                    foundNeighbors = true;
                    b.zoom = zoom; // save the zoom (so it doesn't get processed twice)
                    wx += b.wx * b.numPoints; // accumulate coordinates for calculating weighted center
                    wy += b.wy * b.numPoints;
                    numPoints += b.numPoints;
                }
            }

            if (!foundNeighbors) {
                clusters.push(p); // no neighbors, add a single point as cluster
                continue;
            }

            // form a cluster with neighbors
            var cluster = createCluster(p.x, p.y);
            cluster.numPoints = numPoints;

            // save weighted cluster center for display
            cluster.wx = wx / numPoints;
            cluster.wy = wy / numPoints;

            clusters.push(cluster);
        }

        return clusters;
    }
};

function toBBox(p) {
    return [p.x, p.y, p.x, p.y];
}
function compareMinX(a, b) {
    return a.x - b.x;
}
function compareMinY(a, b) {
    return a.y - b.y;
}

function createCluster(x, y) {
    return {
        x: x, // cluster center
        y: y,
        wx: x, // weighted cluster center
        wy: y,
        zoom: Infinity, // the last zoom the cluster was processed at
        point: null,
        numPoints: 1
    };
}

function createPointCluster(p) {
    var coords = p.geometry.coordinates;
    var cluster = createCluster(lngX(coords[0]), latY(coords[1]));
    cluster.point = p;
    return cluster;
}

function getClusterJSON(cluster) {
    return cluster.point ? cluster.point : {
        type: 'Feature',
        properties: getClusterProperties(cluster),
        geometry: {
            type: 'Point',
            coordinates: [xLng(cluster.wx), yLat(cluster.wy)]
        }
    };
}

function getClusterProperties(cluster) {
    var count = cluster.numPoints;
    var abbrev = count >= 10000 ? Math.round(count / 1000) + 'k' :
                 count >= 1000 ? (Math.round(count / 100) / 10) + 'k' : count;
    return {
        cluster: true,
        point_count: count,
        point_count_abbreviated: abbrev
    };
}

// longitude/latitude to spherical mercator in [0..1] range
function lngX(lng) {
    return lng / 360 + 0.5;
}
function latY(lat) {
    var sin = Math.sin(lat * Math.PI / 180),
        y = (0.5 - 0.25 * Math.log((1 + sin) / (1 - sin)) / Math.PI);
    return y < 0 ? 0 :
           y > 1 ? 1 : y;
}

// spherical mercator to longitude/latitude
function xLng(x) {
    return (x - 0.5) * 360;
}
function yLat(y) {
    var y2 = (180 - y * 360) * Math.PI / 180;
    return 360 * Math.atan(Math.exp(y2)) / Math.PI - 90;
}

// squared distance between two points
function distSq(a, b) {
    var dx = a.wx - b.wx;
    var dy = a.wy - b.wy;
    return dx * dx + dy * dy;
}

function extend(dest, src) {
    for (var id in src) dest[id] = src[id];
    return dest;
}

},{"rbush":163}],167:[function(require,module,exports){
/*
 * Copyright (C) 2008 Apple Inc. All Rights Reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS'' AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * Ported from Webkit
 * http://svn.webkit.org/repository/webkit/trunk/Source/WebCore/platform/graphics/UnitBezier.h
 */

module.exports = UnitBezier;

function UnitBezier(p1x, p1y, p2x, p2y) {
    // Calculate the polynomial coefficients, implicit first and last control points are (0,0) and (1,1).
    this.cx = 3.0 * p1x;
    this.bx = 3.0 * (p2x - p1x) - this.cx;
    this.ax = 1.0 - this.cx - this.bx;

    this.cy = 3.0 * p1y;
    this.by = 3.0 * (p2y - p1y) - this.cy;
    this.ay = 1.0 - this.cy - this.by;

    this.p1x = p1x;
    this.p1y = p2y;
    this.p2x = p2x;
    this.p2y = p2y;
}

UnitBezier.prototype.sampleCurveX = function(t) {
    // `ax t^3 + bx t^2 + cx t' expanded using Horner's rule.
    return ((this.ax * t + this.bx) * t + this.cx) * t;
};

UnitBezier.prototype.sampleCurveY = function(t) {
    return ((this.ay * t + this.by) * t + this.cy) * t;
};

UnitBezier.prototype.sampleCurveDerivativeX = function(t) {
    return (3.0 * this.ax * t + 2.0 * this.bx) * t + this.cx;
};

UnitBezier.prototype.solveCurveX = function(x, epsilon) {
    if (typeof epsilon === 'undefined') epsilon = 1e-6;

    var t0, t1, t2, x2, i;

    // First try a few iterations of Newton's method -- normally very fast.
    for (t2 = x, i = 0; i < 8; i++) {

        x2 = this.sampleCurveX(t2) - x;
        if (Math.abs(x2) < epsilon) return t2;

        var d2 = this.sampleCurveDerivativeX(t2);
        if (Math.abs(d2) < 1e-6) break;

        t2 = t2 - x2 / d2;
    }

    // Fall back to the bisection method for reliability.
    t0 = 0.0;
    t1 = 1.0;
    t2 = x;

    if (t2 < t0) return t0;
    if (t2 > t1) return t1;

    while (t0 < t1) {

        x2 = this.sampleCurveX(t2);
        if (Math.abs(x2 - x) < epsilon) return t2;

        if (x > x2) {
            t0 = t2;
        } else {
            t1 = t2;
        }

        t2 = (t1 - t0) * 0.5 + t0;
    }

    // Failure.
    return t2;
};

UnitBezier.prototype.solve = function(x, epsilon) {
    return this.sampleCurveY(this.solveCurveX(x, epsilon));
};

},{}],168:[function(require,module,exports){
module.exports.VectorTile = require('./lib/vectortile.js');
module.exports.VectorTileFeature = require('./lib/vectortilefeature.js');
module.exports.VectorTileLayer = require('./lib/vectortilelayer.js');

},{"./lib/vectortile.js":169,"./lib/vectortilefeature.js":170,"./lib/vectortilelayer.js":171}],169:[function(require,module,exports){
'use strict';

var VectorTileLayer = require('./vectortilelayer');

module.exports = VectorTile;

function VectorTile(pbf, end) {
    this.layers = pbf.readFields(readTile, {}, end);
}

function readTile(tag, layers, pbf) {
    if (tag === 3) {
        var layer = new VectorTileLayer(pbf, pbf.readVarint() + pbf.pos);
        if (layer.length) layers[layer.name] = layer;
    }
}


},{"./vectortilelayer":171}],170:[function(require,module,exports){
'use strict';

var Point = require('point-geometry');

module.exports = VectorTileFeature;

function VectorTileFeature(pbf, end, extent, keys, values) {
    // Public
    this.properties = {};
    this.extent = extent;
    this.type = 0;

    // Private
    this._pbf = pbf;
    this._geometry = -1;
    this._keys = keys;
    this._values = values;

    pbf.readFields(readFeature, this, end);
}

function readFeature(tag, feature, pbf) {
    if (tag == 1) feature._id = pbf.readVarint();
    else if (tag == 2) readTag(pbf, feature);
    else if (tag == 3) feature.type = pbf.readVarint();
    else if (tag == 4) feature._geometry = pbf.pos;
}

function readTag(pbf, feature) {
    var end = pbf.readVarint() + pbf.pos;

    while (pbf.pos < end) {
        var key = feature._keys[pbf.readVarint()],
            value = feature._values[pbf.readVarint()];
        feature.properties[key] = value;
    }
}

VectorTileFeature.types = ['Unknown', 'Point', 'LineString', 'Polygon'];

VectorTileFeature.prototype.loadGeometry = function() {
    var pbf = this._pbf;
    pbf.pos = this._geometry;

    var end = pbf.readVarint() + pbf.pos,
        cmd = 1,
        length = 0,
        x = 0,
        y = 0,
        lines = [],
        line;

    while (pbf.pos < end) {
        if (!length) {
            var cmdLen = pbf.readVarint();
            cmd = cmdLen & 0x7;
            length = cmdLen >> 3;
        }

        length--;

        if (cmd === 1 || cmd === 2) {
            x += pbf.readSVarint();
            y += pbf.readSVarint();

            if (cmd === 1) { // moveTo
                if (line) lines.push(line);
                line = [];
            }

            line.push(new Point(x, y));

        } else if (cmd === 7) {

            // Workaround for https://github.com/mapbox/mapnik-vector-tile/issues/90
            if (line) {
                line.push(line[0].clone()); // closePolygon
            }

        } else {
            throw new Error('unknown command ' + cmd);
        }
    }

    if (line) lines.push(line);

    return lines;
};

VectorTileFeature.prototype.bbox = function() {
    var pbf = this._pbf;
    pbf.pos = this._geometry;

    var end = pbf.readVarint() + pbf.pos,
        cmd = 1,
        length = 0,
        x = 0,
        y = 0,
        x1 = Infinity,
        x2 = -Infinity,
        y1 = Infinity,
        y2 = -Infinity;

    while (pbf.pos < end) {
        if (!length) {
            var cmdLen = pbf.readVarint();
            cmd = cmdLen & 0x7;
            length = cmdLen >> 3;
        }

        length--;

        if (cmd === 1 || cmd === 2) {
            x += pbf.readSVarint();
            y += pbf.readSVarint();
            if (x < x1) x1 = x;
            if (x > x2) x2 = x;
            if (y < y1) y1 = y;
            if (y > y2) y2 = y;

        } else if (cmd !== 7) {
            throw new Error('unknown command ' + cmd);
        }
    }

    return [x1, y1, x2, y2];
};

VectorTileFeature.prototype.toGeoJSON = function(x, y, z) {
    var size = this.extent * Math.pow(2, z),
        x0 = this.extent * x,
        y0 = this.extent * y,
        coords = this.loadGeometry(),
        type = VectorTileFeature.types[this.type];

    for (var i = 0; i < coords.length; i++) {
        var line = coords[i];
        for (var j = 0; j < line.length; j++) {
            var p = line[j], y2 = 180 - (p.y + y0) * 360 / size;
            line[j] = [
                (p.x + x0) * 360 / size - 180,
                360 / Math.PI * Math.atan(Math.exp(y2 * Math.PI / 180)) - 90
            ];
        }
    }

    if (type === 'Point' && coords.length === 1) {
        coords = coords[0][0];
    } else if (type === 'Point') {
        coords = coords[0];
        type = 'MultiPoint';
    } else if (type === 'LineString' && coords.length === 1) {
        coords = coords[0];
    } else if (type === 'LineString') {
        type = 'MultiLineString';
    }

    var result = {
        type: "Feature",
        geometry: {
            type: type,
            coordinates: coords
        },
        properties: this.properties
    };

    if ('_id' in this) {
        result.id = this._id;
    }

    return result;
};

},{"point-geometry":162}],171:[function(require,module,exports){
'use strict';

var VectorTileFeature = require('./vectortilefeature.js');

module.exports = VectorTileLayer;

function VectorTileLayer(pbf, end) {
    // Public
    this.version = 1;
    this.name = null;
    this.extent = 4096;
    this.length = 0;

    // Private
    this._pbf = pbf;
    this._keys = [];
    this._values = [];
    this._features = [];

    pbf.readFields(readLayer, this, end);

    this.length = this._features.length;
}

function readLayer(tag, layer, pbf) {
    if (tag === 15) layer.version = pbf.readVarint();
    else if (tag === 1) layer.name = pbf.readString();
    else if (tag === 5) layer.extent = pbf.readVarint();
    else if (tag === 2) layer._features.push(pbf.pos);
    else if (tag === 3) layer._keys.push(pbf.readString());
    else if (tag === 4) layer._values.push(readValueMessage(pbf));
}

function readValueMessage(pbf) {
    var value = null,
        end = pbf.readVarint() + pbf.pos;

    while (pbf.pos < end) {
        var tag = pbf.readVarint() >> 3;

        value = tag === 1 ? pbf.readString() :
            tag === 2 ? pbf.readFloat() :
            tag === 3 ? pbf.readDouble() :
            tag === 4 ? pbf.readVarint64() :
            tag === 5 ? pbf.readVarint() :
            tag === 6 ? pbf.readSVarint() :
            tag === 7 ? pbf.readBoolean() : null;
    }

    return value;
}

// return feature `i` from this layer as a `VectorTileFeature`
VectorTileLayer.prototype.feature = function(i) {
    if (i < 0 || i >= this._features.length) throw new Error('feature index out of bounds');

    this._pbf.pos = this._features[i];

    var end = this._pbf.readVarint() + this._pbf.pos;
    return new VectorTileFeature(this._pbf, end, this.extent, this._keys, this._values);
};

},{"./vectortilefeature.js":170}],172:[function(require,module,exports){
var Pbf = require('pbf')
var vtpb = require('./vector-tile-pb')
var GeoJSONWrapper = require('./lib/geojson_wrapper')

module.exports = fromVectorTileJs
module.exports.fromVectorTileJs = fromVectorTileJs
module.exports.fromGeojsonVt = fromGeojsonVt
module.exports.GeoJSONWrapper = GeoJSONWrapper

/**
 * Serialize a vector-tile-js-created tile to pbf
 *
 * @param {Object} tile
 * @return {Buffer} uncompressed, pbf-serialized tile data
 */
function fromVectorTileJs (tile) {
  var layers = []
  for (var l in tile.layers) {
    layers.push(prepareLayer(tile.layers[l]))
  }

  var out = new Pbf()
  vtpb.tile.write({ layers: layers }, out)
  return out.finish()
}

/**
 * Serialized a geojson-vt-created tile to pbf.
 *
 * @param {Object} layers - An object mapping layer names to geojson-vt-created vector tile objects
 * @return {Buffer} uncompressed, pbf-serialized tile data
 */
function fromGeojsonVt (layers) {
  var l = {}
  for (var k in layers) {
    l[k] = new GeoJSONWrapper(layers[k].features)
    l[k].name = k
  }
  return fromVectorTileJs({layers: l})
}

/**
 * Prepare the given layer to be serialized by the auto-generated pbf
 * serializer by encoding the feature geometry and properties.
 */
function prepareLayer (layer) {
  var preparedLayer = {
    name: layer.name || '',
    version: layer.version || 1,
    extent: layer.extent || 4096,
    keys: [],
    values: [],
    features: []
  }

  var keycache = {}
  var valuecache = {}

  for (var i = 0; i < layer.length; i++) {
    var feature = layer.feature(i)
    feature.geometry = encodeGeometry(feature.loadGeometry())

    var tags = []
    for (var key in feature.properties) {
      var keyIndex = keycache[key]
      if (typeof keyIndex === 'undefined') {
        preparedLayer.keys.push(key)
        keyIndex = preparedLayer.keys.length - 1
        keycache[key] = keyIndex
      }
      var value = wrapValue(feature.properties[key])
      var valueIndex = valuecache[value.key]
      if (typeof valueIndex === 'undefined') {
        preparedLayer.values.push(value)
        valueIndex = preparedLayer.values.length - 1
        valuecache[value.key] = valueIndex
      }
      tags.push(keyIndex)
      tags.push(valueIndex)
    }

    feature.tags = tags
    preparedLayer.features.push(feature)
  }

  return preparedLayer
}

function command (cmd, length) {
  return (length << 3) + (cmd & 0x7)
}

function zigzag (num) {
  return (num << 1) ^ (num >> 31)
}

/**
 * Encode a polygon's geometry into an array ready to be serialized
 * to mapbox vector tile specified geometry data.
 *
 * @param {Array} Rings, each being an array of [x, y] tile-space coordinates
 * @return {Array} encoded geometry
 */
function encodeGeometry (geometry) {
  var encoded = []
  var x = 0
  var y = 0
  var rings = geometry.length
  for (var r = 0; r < rings; r++) {
    var ring = geometry[r]
    encoded.push(command(1, 1)) // moveto
    for (var i = 0; i < ring.length; i++) {
      if (i === 1) {
        encoded.push(command(2, ring.length - 1)) // lineto
      }
      var dx = ring[i].x - x
      var dy = ring[i].y - y
      encoded.push(zigzag(dx), zigzag(dy))
      x += dx
      y += dy
    }
  }

  return encoded
}

/**
 * Wrap a property value according to its type. The returned object
 * is of the form { xxxx_value: primitiveValue }, which is what the generated
 * protobuf serializer expects.
 */
function wrapValue (value) {
  var result
  var type = typeof value
  if (type === 'string') {
    result = { string_value: value }
  } else if (type === 'boolean') {
    result = { bool_value: value }
  } else if (type === 'number') {
    if (value !== (value | 0)) {
      result = { float_value: value }
    } else if (value < 0) {
      result = { sint_value: value }
    } else {
      result = { uint_value: value }
    }
  } else {
    result = { string_value: '' + value }
  }

  result.key = type + ':' + value
  return result
}

},{"./lib/geojson_wrapper":173,"./vector-tile-pb":174,"pbf":160}],173:[function(require,module,exports){
'use strict'

var Point = require('point-geometry')
var VectorTileFeature = require('vector-tile').VectorTileFeature

module.exports = GeoJSONWrapper

// conform to vectortile api
function GeoJSONWrapper (features) {
  this.features = features
  this.length = features.length
}

GeoJSONWrapper.prototype.feature = function (i) {
  return new FeatureWrapper(this.features[i])
}

function FeatureWrapper (feature) {
  this.type = feature.type
  this.rawGeometry = feature.type === 1 ? [feature.geometry] : feature.geometry
  this.properties = feature.tags
  this.extent = 4096
}

FeatureWrapper.prototype.loadGeometry = function () {
  var rings = this.rawGeometry
  this.geometry = []

  for (var i = 0; i < rings.length; i++) {
    var ring = rings[i]
    var newRing = []
    for (var j = 0; j < ring.length; j++) {
      newRing.push(new Point(ring[j][0], ring[j][1]))
    }
    this.geometry.push(newRing)
  }
  return this.geometry
}

FeatureWrapper.prototype.bbox = function () {
  if (!this.geometry) this.loadGeometry()

  var rings = this.geometry
  var x1 = Infinity
  var x2 = -Infinity
  var y1 = Infinity
  var y2 = -Infinity

  for (var i = 0; i < rings.length; i++) {
    var ring = rings[i]

    for (var j = 0; j < ring.length; j++) {
      var coord = ring[j]

      x1 = Math.min(x1, coord.x)
      x2 = Math.max(x2, coord.x)
      y1 = Math.min(y1, coord.y)
      y2 = Math.max(y2, coord.y)
    }
  }

  return [x1, y1, x2, y2]
}

FeatureWrapper.prototype.toGeoJSON = VectorTileFeature.prototype.toGeoJSON

},{"point-geometry":162,"vector-tile":168}],174:[function(require,module,exports){
'use strict';

// tile ========================================

var tile = exports.tile = {read: readTile, write: writeTile};

tile.GeomType = {
    "Unknown": 0,
    "Point": 1,
    "LineString": 2,
    "Polygon": 3
};

function readTile(pbf, end) {
    return pbf.readFields(readTileField, {"layers": []}, end);
}

function readTileField(tag, tile, pbf) {
    if (tag === 3) tile.layers.push(readLayer(pbf, pbf.readVarint() + pbf.pos));
}

function writeTile(tile, pbf) {
    var i;
    if (tile.layers !== undefined) for (i = 0; i < tile.layers.length; i++) pbf.writeMessage(3, writeLayer, tile.layers[i]);
}

// value ========================================

tile.value = {read: readValue, write: writeValue};

function readValue(pbf, end) {
    return pbf.readFields(readValueField, {}, end);
}

function readValueField(tag, value, pbf) {
    if (tag === 1) value.string_value = pbf.readString();
    else if (tag === 2) value.float_value = pbf.readFloat();
    else if (tag === 3) value.double_value = pbf.readDouble();
    else if (tag === 4) value.int_value = pbf.readVarint();
    else if (tag === 5) value.uint_value = pbf.readVarint();
    else if (tag === 6) value.sint_value = pbf.readSVarint();
    else if (tag === 7) value.bool_value = pbf.readBoolean();
}

function writeValue(value, pbf) {
    if (value.string_value !== undefined) pbf.writeStringField(1, value.string_value);
    if (value.float_value !== undefined) pbf.writeFloatField(2, value.float_value);
    if (value.double_value !== undefined) pbf.writeDoubleField(3, value.double_value);
    if (value.int_value !== undefined) pbf.writeVarintField(4, value.int_value);
    if (value.uint_value !== undefined) pbf.writeVarintField(5, value.uint_value);
    if (value.sint_value !== undefined) pbf.writeSVarintField(6, value.sint_value);
    if (value.bool_value !== undefined) pbf.writeBooleanField(7, value.bool_value);
}

// feature ========================================

tile.feature = {read: readFeature, write: writeFeature};

function readFeature(pbf, end) {
    var feature = pbf.readFields(readFeatureField, {}, end);
    if (feature.type === undefined) feature.type = "Unknown";
    return feature;
}

function readFeatureField(tag, feature, pbf) {
    if (tag === 1) feature.id = pbf.readVarint();
    else if (tag === 2) feature.tags = pbf.readPackedVarint();
    else if (tag === 3) feature.type = pbf.readVarint();
    else if (tag === 4) feature.geometry = pbf.readPackedVarint();
}

function writeFeature(feature, pbf) {
    if (feature.id !== undefined) pbf.writeVarintField(1, feature.id);
    if (feature.tags !== undefined) pbf.writePackedVarint(2, feature.tags);
    if (feature.type !== undefined) pbf.writeVarintField(3, feature.type);
    if (feature.geometry !== undefined) pbf.writePackedVarint(4, feature.geometry);
}

// layer ========================================

tile.layer = {read: readLayer, write: writeLayer};

function readLayer(pbf, end) {
    return pbf.readFields(readLayerField, {"features": [], "keys": [], "values": []}, end);
}

function readLayerField(tag, layer, pbf) {
    if (tag === 15) layer.version = pbf.readVarint();
    else if (tag === 1) layer.name = pbf.readString();
    else if (tag === 2) layer.features.push(readFeature(pbf, pbf.readVarint() + pbf.pos));
    else if (tag === 3) layer.keys.push(pbf.readString());
    else if (tag === 4) layer.values.push(readValue(pbf, pbf.readVarint() + pbf.pos));
    else if (tag === 5) layer.extent = pbf.readVarint();
}

function writeLayer(layer, pbf) {
    if (layer.version !== undefined) pbf.writeVarintField(15, layer.version);
    if (layer.name !== undefined) pbf.writeStringField(1, layer.name);
    var i;
    if (layer.features !== undefined) for (i = 0; i < layer.features.length; i++) pbf.writeMessage(2, writeFeature, layer.features[i]);
    if (layer.keys !== undefined) for (i = 0; i < layer.keys.length; i++) pbf.writeStringField(3, layer.keys[i]);
    if (layer.values !== undefined) for (i = 0; i < layer.values.length; i++) pbf.writeMessage(4, writeValue, layer.values[i]);
    if (layer.extent !== undefined) pbf.writeVarintField(5, layer.extent);
}

},{}],175:[function(require,module,exports){
var bundleFn = arguments[3];
var sources = arguments[4];
var cache = arguments[5];

var stringify = JSON.stringify;

module.exports = function (fn) {
    var keys = [];
    var wkey;
    var cacheKeys = Object.keys(cache);

    for (var i = 0, l = cacheKeys.length; i < l; i++) {
        var key = cacheKeys[i];
        var exp = cache[key].exports;
        // Using babel as a transpiler to use esmodule, the export will always
        // be an object with the default export as a property of it. To ensure
        // the existing api and babel esmodule exports are both supported we
        // check for both
        if (exp === fn || exp.default === fn) {
            wkey = key;
            break;
        }
    }

    if (!wkey) {
        wkey = Math.floor(Math.pow(16, 8) * Math.random()).toString(16);
        var wcache = {};
        for (var i = 0, l = cacheKeys.length; i < l; i++) {
            var key = cacheKeys[i];
            wcache[key] = key;
        }
        sources[wkey] = [
            Function(['require','module','exports'], '(' + fn + ')(self)'),
            wcache
        ];
    }
    var skey = Math.floor(Math.pow(16, 8) * Math.random()).toString(16);

    var scache = {}; scache[wkey] = wkey;
    sources[skey] = [
        Function(['require'], (
            // try to call default if defined to also support babel esmodule
            // exports
            'var f = require(' + stringify(wkey) + ');' +
            '(f.default ? f.default : f)(self);'
        )),
        scache
    ];

    var src = '(' + bundleFn + ')({'
        + Object.keys(sources).map(function (key) {
            return stringify(key) + ':['
                + sources[key][0]
                + ',' + stringify(sources[key][1]) + ']'
            ;
        }).join(',')
        + '},{},[' + stringify(skey) + '])'
    ;

    var URL = window.URL || window.webkitURL || window.mozURL || window.msURL;

    return new Worker(URL.createObjectURL(
        new Blob([src], { type: 'text/javascript' })
    ));
};

},{}]},{},[14])(14)
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJqcy9kYXRhL2J1Y2tldC5qcyIsImpzL2RhdGEvYnVja2V0L2NpcmNsZV9idWNrZXQuanMiLCJqcy9kYXRhL2J1Y2tldC9maWxsX2J1Y2tldC5qcyIsImpzL2RhdGEvYnVja2V0L2xpbmVfYnVja2V0LmpzIiwianMvZGF0YS9idWNrZXQvc3ltYm9sX2J1Y2tldC5qcyIsImpzL2RhdGEvYnVmZmVyLmpzIiwianMvZGF0YS9mZWF0dXJlX2luZGV4LmpzIiwianMvZGF0YS9sb2FkX2dlb21ldHJ5LmpzIiwianMvZ2VvL2Nvb3JkaW5hdGUuanMiLCJqcy9nZW8vbG5nX2xhdC5qcyIsImpzL2dlby9sbmdfbGF0X2JvdW5kcy5qcyIsImpzL2dlby90cmFuc2Zvcm0uanMiLCJqcy9saWIvZGVidWd0ZXh0LmpzIiwianMvbWFwYm94LWdsLmpzIiwianMvcmVuZGVyL2RyYXdfYmFja2dyb3VuZC5qcyIsImpzL3JlbmRlci9kcmF3X2NpcmNsZS5qcyIsImpzL3JlbmRlci9kcmF3X2NvbGxpc2lvbl9kZWJ1Zy5qcyIsImpzL3JlbmRlci9kcmF3X2RlYnVnLmpzIiwianMvcmVuZGVyL2RyYXdfZmlsbC5qcyIsImpzL3JlbmRlci9kcmF3X2xpbmUuanMiLCJqcy9yZW5kZXIvZHJhd19yYXN0ZXIuanMiLCJqcy9yZW5kZXIvZHJhd19zeW1ib2wuanMiLCJqcy9yZW5kZXIvZnJhbWVfaGlzdG9yeS5qcyIsImpzL3JlbmRlci9nbF91dGlsLmpzIiwianMvcmVuZGVyL2xpbmVfYXRsYXMuanMiLCJqcy9yZW5kZXIvcGFpbnRlci5qcyIsImpzL3JlbmRlci9zaGFkZXJzLmpzIiwianMvc291cmNlL2dlb2pzb25fc291cmNlLmpzIiwianMvc291cmNlL2dlb2pzb25fd3JhcHBlci5qcyIsImpzL3NvdXJjZS9pbWFnZV9zb3VyY2UuanMiLCJqcy9zb3VyY2UvcGl4ZWxzX3RvX3RpbGVfdW5pdHMuanMiLCJqcy9zb3VyY2UvcmFzdGVyX3RpbGVfc291cmNlLmpzIiwianMvc291cmNlL3NvdXJjZS5qcyIsImpzL3NvdXJjZS90aWxlLmpzIiwianMvc291cmNlL3RpbGVfY29vcmQuanMiLCJqcy9zb3VyY2UvdGlsZV9weXJhbWlkLmpzIiwianMvc291cmNlL3ZlY3Rvcl90aWxlX3NvdXJjZS5qcyIsImpzL3NvdXJjZS92aWRlb19zb3VyY2UuanMiLCJqcy9zb3VyY2Uvd29ya2VyLmpzIiwianMvc291cmNlL3dvcmtlcl90aWxlLmpzIiwianMvc3R5bGUvYW5pbWF0aW9uX2xvb3AuanMiLCJqcy9zdHlsZS9pbWFnZV9zcHJpdGUuanMiLCJqcy9zdHlsZS9wYXJzZV9jb2xvci5qcyIsImpzL3N0eWxlL3N0eWxlLmpzIiwianMvc3R5bGUvc3R5bGVfYmF0Y2guanMiLCJqcy9zdHlsZS9zdHlsZV9kZWNsYXJhdGlvbi5qcyIsImpzL3N0eWxlL3N0eWxlX2xheWVyLmpzIiwianMvc3R5bGUvc3R5bGVfbGF5ZXIvYmFja2dyb3VuZF9zdHlsZV9sYXllci5qcyIsImpzL3N0eWxlL3N0eWxlX2xheWVyL2NpcmNsZV9zdHlsZV9sYXllci5qcyIsImpzL3N0eWxlL3N0eWxlX2xheWVyL2ZpbGxfc3R5bGVfbGF5ZXIuanMiLCJqcy9zdHlsZS9zdHlsZV9sYXllci9saW5lX3N0eWxlX2xheWVyLmpzIiwianMvc3R5bGUvc3R5bGVfbGF5ZXIvcmFzdGVyX3N0eWxlX2xheWVyLmpzIiwianMvc3R5bGUvc3R5bGVfbGF5ZXIvc3ltYm9sX3N0eWxlX2xheWVyLmpzIiwianMvc3R5bGUvc3R5bGVfc3BlYy5qcyIsImpzL3N0eWxlL3N0eWxlX3RyYW5zaXRpb24uanMiLCJqcy9zdHlsZS92YWxpZGF0ZV9zdHlsZS5qcyIsImpzL3N5bWJvbC9hbmNob3IuanMiLCJqcy9zeW1ib2wvY2hlY2tfbWF4X2FuZ2xlLmpzIiwianMvc3ltYm9sL2NsaXBfbGluZS5qcyIsImpzL3N5bWJvbC9jb2xsaXNpb25fYm94LmpzIiwianMvc3ltYm9sL2NvbGxpc2lvbl9mZWF0dXJlLmpzIiwianMvc3ltYm9sL2NvbGxpc2lvbl90aWxlLmpzIiwianMvc3ltYm9sL2dldF9hbmNob3JzLmpzIiwianMvc3ltYm9sL2dseXBoX2F0bGFzLmpzIiwianMvc3ltYm9sL2dseXBoX3NvdXJjZS5qcyIsImpzL3N5bWJvbC9tZXJnZWxpbmVzLmpzIiwianMvc3ltYm9sL3F1YWRzLmpzIiwianMvc3ltYm9sL3Jlc29sdmVfdGV4dC5qcyIsImpzL3N5bWJvbC9zaGFwaW5nLmpzIiwianMvc3ltYm9sL3Nwcml0ZV9hdGxhcy5qcyIsImpzL3VpL2NhbWVyYS5qcyIsImpzL3VpL2NvbnRyb2wvYXR0cmlidXRpb24uanMiLCJqcy91aS9jb250cm9sL2NvbnRyb2wuanMiLCJqcy91aS9jb250cm9sL2dlb2xvY2F0ZS5qcyIsImpzL3VpL2NvbnRyb2wvbmF2aWdhdGlvbi5qcyIsImpzL3VpL2hhbmRsZXIvYm94X3pvb20uanMiLCJqcy91aS9oYW5kbGVyL2RibGNsaWNrX3pvb20uanMiLCJqcy91aS9oYW5kbGVyL2RyYWdfcGFuLmpzIiwianMvdWkvaGFuZGxlci9kcmFnX3JvdGF0ZS5qcyIsImpzL3VpL2hhbmRsZXIva2V5Ym9hcmQuanMiLCJqcy91aS9oYW5kbGVyL3Njcm9sbF96b29tLmpzIiwianMvdWkvaGFuZGxlci90b3VjaF96b29tX3JvdGF0ZS5qcyIsImpzL3VpL2hhc2guanMiLCJqcy91aS9pbnRlcmFjdGlvbi5qcyIsImpzL3VpL21hcC5qcyIsImpzL3VpL3BvcHVwLmpzIiwianMvdXRpbC9hY3Rvci5qcyIsImpzL3V0aWwvYnJvd3Nlci9hamF4LmpzIiwianMvdXRpbC9icm93c2VyL2Jyb3dzZXIuanMiLCJqcy91dGlsL2Jyb3dzZXIvY2FudmFzLmpzIiwianMvdXRpbC9icm93c2VyL2Rpc3BhdGNoZXIuanMiLCJqcy91dGlsL2Jyb3dzZXIvZG9tLmpzIiwianMvdXRpbC9jb25maWcuanMiLCJqcy91dGlsL2RpY3Rpb25hcnlfY29kZXIuanMiLCJqcy91dGlsL2V2ZW50ZWQuanMiLCJqcy91dGlsL2dseXBocy5qcyIsImpzL3V0aWwvZ3JpZC5qcyIsImpzL3V0aWwvaW50ZXJwb2xhdGUuanMiLCJqcy91dGlsL2ludGVyc2VjdGlvbl90ZXN0cy5qcyIsImpzL3V0aWwvbHJ1X2NhY2hlLmpzIiwianMvdXRpbC9tYXBib3guanMiLCJqcy91dGlsL3N0cnVjdF9hcnJheS5qcyIsImpzL3V0aWwvdG9rZW4uanMiLCJqcy91dGlsL3V0aWwuanMiLCJqcy91dGlsL3ZlY3RvcnRpbGVfdG9fZ2VvanNvbi5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9hc3NlcnQvYXNzZXJ0LmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2luaGVyaXRzL2luaGVyaXRzX2Jyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvcGF0aC1icm93c2VyaWZ5L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy91dGlsL3N1cHBvcnQvaXNCdWZmZXJCcm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3V0aWwvdXRpbC5qcyIsIm5vZGVfbW9kdWxlcy9jc3Njb2xvcnBhcnNlci9jc3Njb2xvcnBhcnNlci5qcyIsIm5vZGVfbW9kdWxlcy9mZWF0dXJlLWZpbHRlci9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9nZW9qc29uLXJld2luZC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9nZW9qc29uLXJld2luZC9ub2RlX21vZHVsZXMvZ2VvanNvbi1hcmVhL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2dlb2pzb24tcmV3aW5kL25vZGVfbW9kdWxlcy9nZW9qc29uLWFyZWEvbm9kZV9tb2R1bGVzL3dnczg0L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2dlb2pzb24tdnQvc3JjL2NsaXAuanMiLCJub2RlX21vZHVsZXMvZ2VvanNvbi12dC9zcmMvY29udmVydC5qcyIsIm5vZGVfbW9kdWxlcy9nZW9qc29uLXZ0L3NyYy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9nZW9qc29uLXZ0L3NyYy9zaW1wbGlmeS5qcyIsIm5vZGVfbW9kdWxlcy9nZW9qc29uLXZ0L3NyYy90aWxlLmpzIiwibm9kZV9tb2R1bGVzL2dlb2pzb24tdnQvc3JjL3RyYW5zZm9ybS5qcyIsIm5vZGVfbW9kdWxlcy9nZW9qc29uLXZ0L3NyYy93cmFwLmpzIiwibm9kZV9tb2R1bGVzL2dsLW1hdHJpeC9zcmMvZ2wtbWF0cml4LmpzIiwibm9kZV9tb2R1bGVzL2dsLW1hdHJpeC9zcmMvZ2wtbWF0cml4L2NvbW1vbi5qcyIsIm5vZGVfbW9kdWxlcy9nbC1tYXRyaXgvc3JjL2dsLW1hdHJpeC9tYXQyLmpzIiwibm9kZV9tb2R1bGVzL2dsLW1hdHJpeC9zcmMvZ2wtbWF0cml4L21hdDJkLmpzIiwibm9kZV9tb2R1bGVzL2dsLW1hdHJpeC9zcmMvZ2wtbWF0cml4L21hdDMuanMiLCJub2RlX21vZHVsZXMvZ2wtbWF0cml4L3NyYy9nbC1tYXRyaXgvbWF0NC5qcyIsIm5vZGVfbW9kdWxlcy9nbC1tYXRyaXgvc3JjL2dsLW1hdHJpeC9xdWF0LmpzIiwibm9kZV9tb2R1bGVzL2dsLW1hdHJpeC9zcmMvZ2wtbWF0cml4L3ZlYzIuanMiLCJub2RlX21vZHVsZXMvZ2wtbWF0cml4L3NyYy9nbC1tYXRyaXgvdmVjMy5qcyIsIm5vZGVfbW9kdWxlcy9nbC1tYXRyaXgvc3JjL2dsLW1hdHJpeC92ZWM0LmpzIiwibm9kZV9tb2R1bGVzL21hcGJveC1nbC1mdW5jdGlvbi9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9tYXBib3gtZ2wtc3R5bGUtc3BlYy9saWIvZXJyb3IvdmFsaWRhdGlvbl9lcnJvci5qcyIsIm5vZGVfbW9kdWxlcy9tYXBib3gtZ2wtc3R5bGUtc3BlYy9saWIvdXRpbC9leHRlbmQuanMiLCJub2RlX21vZHVsZXMvbWFwYm94LWdsLXN0eWxlLXNwZWMvbGliL3V0aWwvZ2V0X3R5cGUuanMiLCJub2RlX21vZHVsZXMvbWFwYm94LWdsLXN0eWxlLXNwZWMvbGliL3V0aWwvdW5idW5kbGVfanNvbmxpbnQuanMiLCJub2RlX21vZHVsZXMvbWFwYm94LWdsLXN0eWxlLXNwZWMvbGliL3ZhbGlkYXRlL3ZhbGlkYXRlLmpzIiwibm9kZV9tb2R1bGVzL21hcGJveC1nbC1zdHlsZS1zcGVjL2xpYi92YWxpZGF0ZS92YWxpZGF0ZV9hcnJheS5qcyIsIm5vZGVfbW9kdWxlcy9tYXBib3gtZ2wtc3R5bGUtc3BlYy9saWIvdmFsaWRhdGUvdmFsaWRhdGVfYm9vbGVhbi5qcyIsIm5vZGVfbW9kdWxlcy9tYXBib3gtZ2wtc3R5bGUtc3BlYy9saWIvdmFsaWRhdGUvdmFsaWRhdGVfY29sb3IuanMiLCJub2RlX21vZHVsZXMvbWFwYm94LWdsLXN0eWxlLXNwZWMvbGliL3ZhbGlkYXRlL3ZhbGlkYXRlX2NvbnN0YW50cy5qcyIsIm5vZGVfbW9kdWxlcy9tYXBib3gtZ2wtc3R5bGUtc3BlYy9saWIvdmFsaWRhdGUvdmFsaWRhdGVfZW51bS5qcyIsIm5vZGVfbW9kdWxlcy9tYXBib3gtZ2wtc3R5bGUtc3BlYy9saWIvdmFsaWRhdGUvdmFsaWRhdGVfZmlsdGVyLmpzIiwibm9kZV9tb2R1bGVzL21hcGJveC1nbC1zdHlsZS1zcGVjL2xpYi92YWxpZGF0ZS92YWxpZGF0ZV9mdW5jdGlvbi5qcyIsIm5vZGVfbW9kdWxlcy9tYXBib3gtZ2wtc3R5bGUtc3BlYy9saWIvdmFsaWRhdGUvdmFsaWRhdGVfbGF5ZXIuanMiLCJub2RlX21vZHVsZXMvbWFwYm94LWdsLXN0eWxlLXNwZWMvbGliL3ZhbGlkYXRlL3ZhbGlkYXRlX2xheW91dF9wcm9wZXJ0eS5qcyIsIm5vZGVfbW9kdWxlcy9tYXBib3gtZ2wtc3R5bGUtc3BlYy9saWIvdmFsaWRhdGUvdmFsaWRhdGVfbnVtYmVyLmpzIiwibm9kZV9tb2R1bGVzL21hcGJveC1nbC1zdHlsZS1zcGVjL2xpYi92YWxpZGF0ZS92YWxpZGF0ZV9vYmplY3QuanMiLCJub2RlX21vZHVsZXMvbWFwYm94LWdsLXN0eWxlLXNwZWMvbGliL3ZhbGlkYXRlL3ZhbGlkYXRlX3BhaW50X3Byb3BlcnR5LmpzIiwibm9kZV9tb2R1bGVzL21hcGJveC1nbC1zdHlsZS1zcGVjL2xpYi92YWxpZGF0ZS92YWxpZGF0ZV9zb3VyY2UuanMiLCJub2RlX21vZHVsZXMvbWFwYm94LWdsLXN0eWxlLXNwZWMvbGliL3ZhbGlkYXRlL3ZhbGlkYXRlX3N0cmluZy5qcyIsIm5vZGVfbW9kdWxlcy9tYXBib3gtZ2wtc3R5bGUtc3BlYy9saWIvdmFsaWRhdGVfc3R5bGUubWluLmpzIiwibm9kZV9tb2R1bGVzL21hcGJveC1nbC1zdHlsZS1zcGVjL3JlZmVyZW5jZS9sYXRlc3QuanMiLCJub2RlX21vZHVsZXMvbWFwYm94LWdsLXN0eWxlLXNwZWMvcmVmZXJlbmNlL2xhdGVzdC5taW4uanMiLCJub2RlX21vZHVsZXMvbWFwYm94LWdsLXN0eWxlLXNwZWMvcmVmZXJlbmNlL3Y4Lmpzb24iLCJub2RlX21vZHVsZXMvbWFwYm94LWdsLXN0eWxlLXNwZWMvcmVmZXJlbmNlL3Y4Lm1pbi5qc29uIiwibm9kZV9tb2R1bGVzL3BiZi9idWZmZXIuanMiLCJub2RlX21vZHVsZXMvcGJmL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3BiZi9ub2RlX21vZHVsZXMvaWVlZTc1NC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9wb2ludC1nZW9tZXRyeS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9yYnVzaC9yYnVzaC5qcyIsIm5vZGVfbW9kdWxlcy9yZXNvbHZlLXVybC9yZXNvbHZlLXVybC5qcyIsIm5vZGVfbW9kdWxlcy9zaGVsZi1wYWNrL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3N1cGVyY2x1c3Rlci9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy91bml0YmV6aWVyL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3ZlY3Rvci10aWxlL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3ZlY3Rvci10aWxlL2xpYi92ZWN0b3J0aWxlLmpzIiwibm9kZV9tb2R1bGVzL3ZlY3Rvci10aWxlL2xpYi92ZWN0b3J0aWxlZmVhdHVyZS5qcyIsIm5vZGVfbW9kdWxlcy92ZWN0b3ItdGlsZS9saWIvdmVjdG9ydGlsZWxheWVyLmpzIiwibm9kZV9tb2R1bGVzL3Z0LXBiZi9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy92dC1wYmYvbGliL2dlb2pzb25fd3JhcHBlci5qcyIsIm5vZGVfbW9kdWxlcy92dC1wYmYvdmVjdG9yLXRpbGUtcGIuanMiLCJub2RlX21vZHVsZXMvd2Vid29ya2lmeS9pbmRleC5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDalNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDamJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM1NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1S0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1WkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25JQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaE1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdk5BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hhQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeE9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4S0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL2NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3TEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5UUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0Z0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25QQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdENBO0FBQ0E7QUFDQTtBQUNBOztBQ0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9FQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0S0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkxBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeE9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbFBBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyVUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1Z0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5TUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9FQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9UQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3plQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZXQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3ZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNoT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDMWtCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeE1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9EQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hFQTtBQUNBO0FBQ0E7QUFDQTs7QUNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaFBBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzF1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeGxFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4bEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMza0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3p3QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDam1CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0dBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25EQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEVBO0FBQ0E7O0FDREE7QUFDQTs7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwMkNBOztBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUMvSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUMxYUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN21CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9PQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6R0E7QUFDQTtBQUNBO0FBQ0E7O0FDSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6SkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIGUodCxuLHIpe2Z1bmN0aW9uIHMobyx1KXtpZighbltvXSl7aWYoIXRbb10pe3ZhciBhPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7aWYoIXUmJmEpcmV0dXJuIGEobywhMCk7aWYoaSlyZXR1cm4gaShvLCEwKTt2YXIgZj1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK28rXCInXCIpO3Rocm93IGYuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixmfXZhciBsPW5bb109e2V4cG9ydHM6e319O3Rbb11bMF0uY2FsbChsLmV4cG9ydHMsZnVuY3Rpb24oZSl7dmFyIG49dFtvXVsxXVtlXTtyZXR1cm4gcyhuP246ZSl9LGwsbC5leHBvcnRzLGUsdCxuLHIpfXJldHVybiBuW29dLmV4cG9ydHN9dmFyIGk9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtmb3IodmFyIG89MDtvPHIubGVuZ3RoO28rKylzKHJbb10pO3JldHVybiBzfSkiLCIndXNlIHN0cmljdCc7XG5cbnZhciBmZWF0dXJlRmlsdGVyID0gcmVxdWlyZSgnZmVhdHVyZS1maWx0ZXInKTtcbnZhciBCdWZmZXIgPSByZXF1aXJlKCcuL2J1ZmZlcicpO1xudmFyIFN0eWxlTGF5ZXIgPSByZXF1aXJlKCcuLi9zdHlsZS9zdHlsZV9sYXllcicpO1xudmFyIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsL3V0aWwnKTtcbnZhciBTdHJ1Y3RBcnJheVR5cGUgPSByZXF1aXJlKCcuLi91dGlsL3N0cnVjdF9hcnJheScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEJ1Y2tldDtcblxuLyoqXG4gKiBJbnN0YW50aWF0ZSB0aGUgYXBwcm9wcmlhdGUgc3ViY2xhc3Mgb2YgYEJ1Y2tldGAgZm9yIGBvcHRpb25zYC5cbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0gb3B0aW9ucyBTZWUgYEJ1Y2tldGAgY29uc3RydWN0b3Igb3B0aW9uc1xuICogQHJldHVybnMge0J1Y2tldH1cbiAqL1xuQnVja2V0LmNyZWF0ZSA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICB2YXIgQ2xhc3NlcyA9IHtcbiAgICAgICAgZmlsbDogcmVxdWlyZSgnLi9idWNrZXQvZmlsbF9idWNrZXQnKSxcbiAgICAgICAgbGluZTogcmVxdWlyZSgnLi9idWNrZXQvbGluZV9idWNrZXQnKSxcbiAgICAgICAgY2lyY2xlOiByZXF1aXJlKCcuL2J1Y2tldC9jaXJjbGVfYnVja2V0JyksXG4gICAgICAgIHN5bWJvbDogcmVxdWlyZSgnLi9idWNrZXQvc3ltYm9sX2J1Y2tldCcpXG4gICAgfTtcbiAgICByZXR1cm4gbmV3IENsYXNzZXNbb3B0aW9ucy5sYXllci50eXBlXShvcHRpb25zKTtcbn07XG5cblxuLyoqXG4gKiBUaGUgbWF4aW11bSBleHRlbnQgb2YgYSBmZWF0dXJlIHRoYXQgY2FuIGJlIHNhZmVseSBzdG9yZWQgaW4gdGhlIGJ1ZmZlci5cbiAqIEluIHByYWN0aWNlLCBhbGwgZmVhdHVyZXMgYXJlIGNvbnZlcnRlZCB0byB0aGlzIGV4dGVudCBiZWZvcmUgYmVpbmcgYWRkZWQuXG4gKlxuICogUG9zaXRpb25zIGFyZSBzdG9yZWQgYXMgc2lnbmVkIDE2Yml0IGludGVnZXJzLlxuICogT25lIGJpdCBpcyBsb3N0IGZvciBzaWduZWRuZXNzIHRvIHN1cHBvcnQgZmVhdHVlcnMgZXh0ZW5kaW5nIHBhc3QgdGhlIGxlZnQgZWRnZSBvZiB0aGUgdGlsZS5cbiAqIE9uZSBiaXQgaXMgbG9zdCBiZWNhdXNlIHRoZSBsaW5lIHZlcnRleCBidWZmZXIgcGFja3MgMSBiaXQgb2Ygb3RoZXIgZGF0YSBpbnRvIHRoZSBpbnQuXG4gKiBPbmUgYml0IGlzIGxvc3QgdG8gc3VwcG9ydCBmZWF0dXJlcyBleHRlbmRpbmcgcGFzdCB0aGUgZXh0ZW50IG9uIHRoZSByaWdodCBlZGdlIG9mIHRoZSB0aWxlLlxuICogVGhpcyBsZWF2ZXMgdXMgd2l0aCAyXjEzID0gODE5MlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcmVhZG9ubHlcbiAqL1xuQnVja2V0LkVYVEVOVCA9IDgxOTI7XG5cbi8qKlxuICogVGhlIGBCdWNrZXRgIGNsYXNzIGlzIHRoZSBzaW5nbGUgcG9pbnQgb2Yga25vd2xlZGdlIGFib3V0IHR1cm5pbmcgdmVjdG9yXG4gKiB0aWxlcyBpbnRvIFdlYkdMIGJ1ZmZlcnMuXG4gKlxuICogYEJ1Y2tldGAgaXMgYW4gYWJzdHJhY3QgY2xhc3MuIEEgc3ViY2xhc3MgZXhpc3RzIGZvciBlYWNoIE1hcGJveCBHTFxuICogc3R5bGUgc3BlYyBsYXllciB0eXBlLiBCZWNhdXNlIGBCdWNrZXRgIGlzIGFuIGFic3RyYWN0IGNsYXNzLFxuICogaW5zdGFuY2VzIHNob3VsZCBiZSBjcmVhdGVkIHZpYSB0aGUgYEJ1Y2tldC5jcmVhdGVgIG1ldGhvZC5cbiAqXG4gKiBGb3IgcGVyZm9ybWFuY2UgcmVhc29ucywgYEJ1Y2tldGAgY3JlYXRlcyBpdHMgXCJhZGRcInMgbWV0aG9kcyBhdFxuICogcnVudGltZSB1c2luZyBgbmV3IEZ1bmN0aW9uKC4uLilgLlxuICpcbiAqIEBjbGFzcyBCdWNrZXRcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0gb3B0aW9uc1xuICogQHBhcmFtIHtudW1iZXJ9IG9wdGlvbnMuem9vbSBab29tIGxldmVsIG9mIHRoZSBidWZmZXJzIGJlaW5nIGJ1aWx0LiBNYXkgYmVcbiAqICAgICBhIGZyYWN0aW9uYWwgem9vbSBsZXZlbC5cbiAqIEBwYXJhbSBvcHRpb25zLmxheWVyIEEgTWFwYm94IEdMIHN0eWxlIGxheWVyIG9iamVjdFxuICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywgQnVmZmVyPn0gb3B0aW9ucy5idWZmZXJzIFRoZSBzZXQgb2YgYEJ1ZmZlcmBzIGJlaW5nXG4gKiAgICAgYnVpbHQgZm9yIHRoaXMgdGlsZS4gVGhpcyBvYmplY3QgZmFjaWxpdGF0ZXMgc2hhcmluZyBvZiBgQnVmZmVyYHMgYmVcbiAgICAgICBiZXR3ZWVuIGBCdWNrZXRgcy5cbiAqL1xuZnVuY3Rpb24gQnVja2V0KG9wdGlvbnMpIHtcbiAgICB0aGlzLnpvb20gPSBvcHRpb25zLnpvb207XG4gICAgdGhpcy5vdmVyc2NhbGluZyA9IG9wdGlvbnMub3ZlcnNjYWxpbmc7XG4gICAgdGhpcy5sYXllciA9IG9wdGlvbnMubGF5ZXI7XG5cbiAgICB0aGlzLmxheWVySURzID0gW3RoaXMubGF5ZXIuaWRdO1xuICAgIHRoaXMudHlwZSA9IHRoaXMubGF5ZXIudHlwZTtcbiAgICB0aGlzLmZlYXR1cmVzID0gW107XG4gICAgdGhpcy5pZCA9IHRoaXMubGF5ZXIuaWQ7XG4gICAgdGhpcy5pbmRleCA9IG9wdGlvbnMuaW5kZXg7XG4gICAgdGhpcy5zb3VyY2VMYXllciA9IHRoaXMubGF5ZXIuc291cmNlTGF5ZXI7XG4gICAgdGhpcy5zb3VyY2VMYXllckluZGV4ID0gb3B0aW9ucy5zb3VyY2VMYXllckluZGV4O1xuICAgIHRoaXMubWluWm9vbSA9IHRoaXMubGF5ZXIubWluem9vbTtcbiAgICB0aGlzLm1heFpvb20gPSB0aGlzLmxheWVyLm1heHpvb207XG5cbiAgICBpZiAob3B0aW9ucy5lbGVtZW50R3JvdXBzKSB7XG4gICAgICAgIHRoaXMuZWxlbWVudEdyb3VwcyA9IG9wdGlvbnMuZWxlbWVudEdyb3VwcztcbiAgICAgICAgdGhpcy5idWZmZXJzID0gdXRpbC5tYXBPYmplY3Qob3B0aW9ucy5hcnJheXMsIGZ1bmN0aW9uKGFycmF5LCBidWZmZXJOYW1lKSB7XG4gICAgICAgICAgICB2YXIgYXJyYXlUeXBlID0gb3B0aW9ucy5hcnJheVR5cGVzW2J1ZmZlck5hbWVdO1xuICAgICAgICAgICAgdmFyIHR5cGUgPSAoYXJyYXlUeXBlLm1lbWJlcnNbMF0ubmFtZSA9PT0gJ3ZlcnRpY2VzJyA/IEJ1ZmZlci5CdWZmZXJUeXBlLkVMRU1FTlQgOiBCdWZmZXIuQnVmZmVyVHlwZS5WRVJURVgpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBCdWZmZXIoYXJyYXksIGFycmF5VHlwZSwgdHlwZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cblxuLyoqXG4gKiBCdWlsZCB0aGUgYnVmZmVycyEgRmVhdHVyZXMgYXJlIHNldCBkaXJlY3RseSB0byB0aGUgYGZlYXR1cmVzYCBwcm9wZXJ0eS5cbiAqIEBwcml2YXRlXG4gKi9cbkJ1Y2tldC5wcm90b3R5cGUucG9wdWxhdGVCdWZmZXJzID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5jcmVhdGVTdHlsZUxheWVyKCk7XG4gICAgdGhpcy5jcmVhdGVBcnJheXMoKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5mZWF0dXJlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzLmFkZEZlYXR1cmUodGhpcy5mZWF0dXJlc1tpXSk7XG4gICAgfVxuXG4gICAgdGhpcy50cmltQXJyYXlzKCk7XG59O1xuXG4vKipcbiAqIENoZWNrIGlmIHRoZXJlIGlzIGVub3VnaCBzcGFjZSBhdmFpbGFibGUgaW4gdGhlIGN1cnJlbnQgZWxlbWVudCBncm91cCBmb3JcbiAqIGB2ZXJ0ZXhMZW5ndGhgIHZlcnRpY2VzLiBJZiBub3QsIGFwcGVuZCBhIG5ldyBlbGVtZW50R3JvdXAuIFNob3VsZCBiZSBjYWxsZWRcbiAqIGJ5IGBwb3B1bGF0ZUJ1ZmZlcnNgIGFuZCBpdHMgY2FsbGVlcy5cbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gc2hhZGVyTmFtZSB0aGUgbmFtZSBvZiB0aGUgc2hhZGVyIGFzc29jaWF0ZWQgd2l0aCB0aGUgYnVmZmVyIHRoYXQgd2lsbCByZWNlaXZlIHRoZSB2ZXJ0aWNlc1xuICogQHBhcmFtIHtudW1iZXJ9IHZlcnRleExlbmd0aCBUaGUgbnVtYmVyIG9mIHZlcnRpY2VzIHRoYXQgd2lsbCBiZSBpbnNlcnRlZCB0byB0aGUgYnVmZmVyLlxuICovXG5CdWNrZXQucHJvdG90eXBlLm1ha2VSb29tRm9yID0gZnVuY3Rpb24oc2hhZGVyTmFtZSwgbnVtVmVydGljZXMpIHtcbiAgICB2YXIgZ3JvdXBzID0gdGhpcy5lbGVtZW50R3JvdXBzW3NoYWRlck5hbWVdO1xuICAgIHZhciBjdXJyZW50R3JvdXAgPSBncm91cHMubGVuZ3RoICYmIGdyb3Vwc1tncm91cHMubGVuZ3RoIC0gMV07XG5cbiAgICBpZiAoIWN1cnJlbnRHcm91cCB8fCBjdXJyZW50R3JvdXAudmVydGV4TGVuZ3RoICsgbnVtVmVydGljZXMgPiA2NTUzNSkge1xuICAgICAgICB2YXIgdmVydGV4QXJyYXkgPSB0aGlzLmFycmF5c1t0aGlzLmdldEJ1ZmZlck5hbWUoc2hhZGVyTmFtZSwgJ3ZlcnRleCcpXTtcbiAgICAgICAgdmFyIGVsZW1lbnRBcnJheSA9IHRoaXMuYXJyYXlzW3RoaXMuZ2V0QnVmZmVyTmFtZShzaGFkZXJOYW1lLCAnZWxlbWVudCcpXTtcbiAgICAgICAgdmFyIHNlY29uZEVsZW1lbnRBcnJheSA9IHRoaXMuYXJyYXlzW3RoaXMuZ2V0QnVmZmVyTmFtZShzaGFkZXJOYW1lLCAnc2Vjb25kRWxlbWVudCcpXTtcblxuICAgICAgICBjdXJyZW50R3JvdXAgPSBuZXcgRWxlbWVudEdyb3VwKFxuICAgICAgICAgICAgdmVydGV4QXJyYXkubGVuZ3RoLFxuICAgICAgICAgICAgZWxlbWVudEFycmF5ICYmIGVsZW1lbnRBcnJheS5sZW5ndGgsXG4gICAgICAgICAgICBzZWNvbmRFbGVtZW50QXJyYXkgJiYgc2Vjb25kRWxlbWVudEFycmF5Lmxlbmd0aFxuICAgICAgICApO1xuICAgICAgICBncm91cHMucHVzaChjdXJyZW50R3JvdXApO1xuICAgIH1cblxuICAgIHJldHVybiBjdXJyZW50R3JvdXA7XG59O1xuXG4vKipcbiAqIFN0YXJ0IHVzaW5nIGEgbmV3IHNoYXJlZCBgYnVmZmVyc2Agb2JqZWN0IGFuZCByZWNyZWF0ZSBpbnN0YW5jZXMgb2YgYEJ1ZmZlcmBcbiAqIGFzIG5lY2Vzc2FyeS5cbiAqIEBwcml2YXRlXG4gKi9cbkJ1Y2tldC5wcm90b3R5cGUuY3JlYXRlQXJyYXlzID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGVsZW1lbnRHcm91cHMgPSB0aGlzLmVsZW1lbnRHcm91cHMgPSB7fTtcbiAgICB2YXIgYXJyYXlzID0gdGhpcy5hcnJheXMgPSB7fTtcbiAgICB2YXIgYXJyYXlUeXBlcyA9IHRoaXMuYXJyYXlUeXBlcyA9IHt9O1xuXG4gICAgZm9yICh2YXIgc2hhZGVyTmFtZSBpbiB0aGlzLnNoYWRlckludGVyZmFjZXMpIHtcbiAgICAgICAgdmFyIHNoYWRlckludGVyZmFjZSA9IHRoaXMuc2hhZGVySW50ZXJmYWNlc1tzaGFkZXJOYW1lXTtcblxuICAgICAgICBpZiAoc2hhZGVySW50ZXJmYWNlLnZlcnRleEJ1ZmZlcikge1xuICAgICAgICAgICAgdmFyIHZlcnRleEJ1ZmZlck5hbWUgPSB0aGlzLmdldEJ1ZmZlck5hbWUoc2hhZGVyTmFtZSwgJ3ZlcnRleCcpO1xuICAgICAgICAgICAgdmFyIHZlcnRleEFkZE1ldGhvZE5hbWUgPSB0aGlzLmdldEFkZE1ldGhvZE5hbWUoc2hhZGVyTmFtZSwgJ3ZlcnRleCcpO1xuXG4gICAgICAgICAgICB2YXIgVmVydGV4QXJyYXlUeXBlID0gbmV3IFN0cnVjdEFycmF5VHlwZSh7XG4gICAgICAgICAgICAgICAgbWVtYmVyczogc2hhZGVySW50ZXJmYWNlLmF0dHJpYnV0ZXMsXG4gICAgICAgICAgICAgICAgYWxpZ25tZW50OiBCdWZmZXIuVkVSVEVYX0FUVFJJQlVURV9BTElHTk1FTlRcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBhcnJheXNbdmVydGV4QnVmZmVyTmFtZV0gPSBuZXcgVmVydGV4QXJyYXlUeXBlKCk7XG4gICAgICAgICAgICBhcnJheVR5cGVzW3ZlcnRleEJ1ZmZlck5hbWVdID0gVmVydGV4QXJyYXlUeXBlLnNlcmlhbGl6ZSgpO1xuXG4gICAgICAgICAgICB0aGlzW3ZlcnRleEFkZE1ldGhvZE5hbWVdID0gdGhpc1t2ZXJ0ZXhBZGRNZXRob2ROYW1lXSB8fCBjcmVhdGVWZXJ0ZXhBZGRNZXRob2QoXG4gICAgICAgICAgICAgICAgc2hhZGVyTmFtZSxcbiAgICAgICAgICAgICAgICBzaGFkZXJJbnRlcmZhY2UsXG4gICAgICAgICAgICAgICAgdGhpcy5nZXRCdWZmZXJOYW1lKHNoYWRlck5hbWUsICd2ZXJ0ZXgnKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgaWYgKHNoYWRlckludGVyZmFjZS5lbGVtZW50QnVmZmVyKSB7XG4gICAgICAgICAgICB2YXIgZWxlbWVudEJ1ZmZlck5hbWUgPSB0aGlzLmdldEJ1ZmZlck5hbWUoc2hhZGVyTmFtZSwgJ2VsZW1lbnQnKTtcbiAgICAgICAgICAgIHZhciBFbGVtZW50QXJyYXlUeXBlID0gY3JlYXRlRWxlbWVudEJ1ZmZlclR5cGUoc2hhZGVySW50ZXJmYWNlLmVsZW1lbnRCdWZmZXJDb21wb25lbnRzKTtcbiAgICAgICAgICAgIGFycmF5c1tlbGVtZW50QnVmZmVyTmFtZV0gPSBuZXcgRWxlbWVudEFycmF5VHlwZSgpO1xuICAgICAgICAgICAgYXJyYXlUeXBlc1tlbGVtZW50QnVmZmVyTmFtZV0gPSBFbGVtZW50QXJyYXlUeXBlLnNlcmlhbGl6ZSgpO1xuICAgICAgICAgICAgdGhpc1t0aGlzLmdldEFkZE1ldGhvZE5hbWUoc2hhZGVyTmFtZSwgJ2VsZW1lbnQnKV0gPSBjcmVhdGVFbGVtZW50QWRkTWV0aG9kKHRoaXMuYXJyYXlzW2VsZW1lbnRCdWZmZXJOYW1lXSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc2hhZGVySW50ZXJmYWNlLnNlY29uZEVsZW1lbnRCdWZmZXIpIHtcbiAgICAgICAgICAgIHZhciBzZWNvbmRFbGVtZW50QnVmZmVyTmFtZSA9IHRoaXMuZ2V0QnVmZmVyTmFtZShzaGFkZXJOYW1lLCAnc2Vjb25kRWxlbWVudCcpO1xuICAgICAgICAgICAgdmFyIFNlY29uZEVsZW1lbnRBcnJheVR5cGUgPSBjcmVhdGVFbGVtZW50QnVmZmVyVHlwZShzaGFkZXJJbnRlcmZhY2Uuc2Vjb25kRWxlbWVudEJ1ZmZlckNvbXBvbmVudHMpO1xuICAgICAgICAgICAgYXJyYXlzW3NlY29uZEVsZW1lbnRCdWZmZXJOYW1lXSA9IG5ldyBTZWNvbmRFbGVtZW50QXJyYXlUeXBlKCk7XG4gICAgICAgICAgICBhcnJheVR5cGVzW3NlY29uZEVsZW1lbnRCdWZmZXJOYW1lXSA9IFNlY29uZEVsZW1lbnRBcnJheVR5cGUuc2VyaWFsaXplKCk7XG4gICAgICAgICAgICB0aGlzW3RoaXMuZ2V0QWRkTWV0aG9kTmFtZShzaGFkZXJOYW1lLCAnc2Vjb25kRWxlbWVudCcpXSA9IGNyZWF0ZUVsZW1lbnRBZGRNZXRob2QodGhpcy5hcnJheXNbc2Vjb25kRWxlbWVudEJ1ZmZlck5hbWVdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGVsZW1lbnRHcm91cHNbc2hhZGVyTmFtZV0gPSBbXTtcbiAgICB9XG59O1xuXG5CdWNrZXQucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbihnbCkge1xuICAgIGZvciAodmFyIGsgaW4gdGhpcy5idWZmZXJzKSB7XG4gICAgICAgIHRoaXMuYnVmZmVyc1trXS5kZXN0cm95KGdsKTtcbiAgICB9XG59O1xuXG5CdWNrZXQucHJvdG90eXBlLnRyaW1BcnJheXMgPSBmdW5jdGlvbigpIHtcbiAgICBmb3IgKHZhciBidWZmZXJOYW1lIGluIHRoaXMuYXJyYXlzKSB7XG4gICAgICAgIHRoaXMuYXJyYXlzW2J1ZmZlck5hbWVdLnRyaW0oKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIEdldCB0aGUgbmFtZSBvZiB0aGUgbWV0aG9kIHVzZWQgdG8gYWRkIGFuIGl0ZW0gdG8gYSBidWZmZXIuXG4gKiBAcGFyYW0ge3N0cmluZ30gc2hhZGVyTmFtZSBUaGUgbmFtZSBvZiB0aGUgc2hhZGVyIHRoYXQgd2lsbCB1c2UgdGhlIGJ1ZmZlclxuICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgT25lIG9mIFwidmVydGV4XCIsIFwiZWxlbWVudFwiLCBvciBcInNlY29uZEVsZW1lbnRcIlxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuQnVja2V0LnByb3RvdHlwZS5nZXRBZGRNZXRob2ROYW1lID0gZnVuY3Rpb24oc2hhZGVyTmFtZSwgdHlwZSkge1xuICAgIHJldHVybiAnYWRkJyArIGNhcGl0YWxpemUoc2hhZGVyTmFtZSkgKyBjYXBpdGFsaXplKHR5cGUpO1xufTtcblxuLyoqXG4gKiBHZXQgdGhlIG5hbWUgb2YgYSBidWZmZXIuXG4gKiBAcGFyYW0ge3N0cmluZ30gc2hhZGVyTmFtZSBUaGUgbmFtZSBvZiB0aGUgc2hhZGVyIHRoYXQgd2lsbCB1c2UgdGhlIGJ1ZmZlclxuICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgT25lIG9mIFwidmVydGV4XCIsIFwiZWxlbWVudFwiLCBvciBcInNlY29uZEVsZW1lbnRcIlxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuQnVja2V0LnByb3RvdHlwZS5nZXRCdWZmZXJOYW1lID0gZnVuY3Rpb24oc2hhZGVyTmFtZSwgdHlwZSkge1xuICAgIHJldHVybiBzaGFkZXJOYW1lICsgY2FwaXRhbGl6ZSh0eXBlKTtcbn07XG5cbkJ1Y2tldC5wcm90b3R5cGUuc2VyaWFsaXplID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbGF5ZXI6IHtcbiAgICAgICAgICAgIGlkOiB0aGlzLmxheWVyLmlkLFxuICAgICAgICAgICAgdHlwZTogdGhpcy5sYXllci50eXBlXG4gICAgICAgIH0sXG4gICAgICAgIHpvb206IHRoaXMuem9vbSxcbiAgICAgICAgZWxlbWVudEdyb3VwczogdGhpcy5lbGVtZW50R3JvdXBzLFxuICAgICAgICBhcnJheXM6IHV0aWwubWFwT2JqZWN0KHRoaXMuYXJyYXlzLCBmdW5jdGlvbihhcnJheSkge1xuICAgICAgICAgICAgcmV0dXJuIGFycmF5LnNlcmlhbGl6ZSgpO1xuICAgICAgICB9KSxcbiAgICAgICAgYXJyYXlUeXBlczogdGhpcy5hcnJheVR5cGVzXG4gICAgfTtcbn07XG5cbkJ1Y2tldC5wcm90b3R5cGUuY3JlYXRlU3R5bGVMYXllciA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICghKHRoaXMubGF5ZXIgaW5zdGFuY2VvZiBTdHlsZUxheWVyKSkge1xuICAgICAgICB0aGlzLmxheWVyID0gU3R5bGVMYXllci5jcmVhdGUodGhpcy5sYXllcik7XG4gICAgICAgIHRoaXMubGF5ZXIucmVjYWxjdWxhdGUodGhpcy56b29tLCB7IGxhc3RJbnRlZ2VyWm9vbTogSW5maW5pdHksIGxhc3RJbnRlZ2VyWm9vbVRpbWU6IDAsIGxhc3Rab29tOiAwIH0pO1xuICAgIH1cbn07XG5cbkJ1Y2tldC5wcm90b3R5cGUuY3JlYXRlRmlsdGVyID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKCF0aGlzLmZpbHRlcikge1xuICAgICAgICB0aGlzLmZpbHRlciA9IGZlYXR1cmVGaWx0ZXIodGhpcy5sYXllci5maWx0ZXIpO1xuICAgIH1cbn07XG5cblxudmFyIGNyZWF0ZVZlcnRleEFkZE1ldGhvZENhY2hlID0ge307XG5mdW5jdGlvbiBjcmVhdGVWZXJ0ZXhBZGRNZXRob2Qoc2hhZGVyTmFtZSwgc2hhZGVySW50ZXJmYWNlLCBidWZmZXJOYW1lKSB7XG4gICAgdmFyIHB1c2hBcmdzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaGFkZXJJbnRlcmZhY2UuYXR0cmlidXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBwdXNoQXJncyA9IHB1c2hBcmdzLmNvbmNhdChzaGFkZXJJbnRlcmZhY2UuYXR0cmlidXRlc1tpXS52YWx1ZSk7XG4gICAgfVxuXG4gICAgdmFyIGJvZHkgPSAncmV0dXJuIHRoaXMuYXJyYXlzLicgKyBidWZmZXJOYW1lICsgJy5lbXBsYWNlQmFjaygnICsgcHVzaEFyZ3Muam9pbignLCAnKSArICcpOyc7XG5cbiAgICBpZiAoIWNyZWF0ZVZlcnRleEFkZE1ldGhvZENhY2hlW2JvZHldKSB7XG4gICAgICAgIGNyZWF0ZVZlcnRleEFkZE1ldGhvZENhY2hlW2JvZHldID0gbmV3IEZ1bmN0aW9uKHNoYWRlckludGVyZmFjZS5hdHRyaWJ1dGVBcmdzLCBib2R5KTtcbiAgICB9XG5cbiAgICByZXR1cm4gY3JlYXRlVmVydGV4QWRkTWV0aG9kQ2FjaGVbYm9keV07XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnRBZGRNZXRob2QoYnVmZmVyKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKG9uZSwgdHdvLCB0aHJlZSkge1xuICAgICAgICByZXR1cm4gYnVmZmVyLmVtcGxhY2VCYWNrKG9uZSwgdHdvLCB0aHJlZSk7XG4gICAgfTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlRWxlbWVudEJ1ZmZlclR5cGUoY29tcG9uZW50cykge1xuICAgIHJldHVybiBuZXcgU3RydWN0QXJyYXlUeXBlKHtcbiAgICAgICAgbWVtYmVyczogW3tcbiAgICAgICAgICAgIHR5cGU6IEJ1ZmZlci5FTEVNRU5UX0FUVFJJQlVURV9UWVBFLFxuICAgICAgICAgICAgbmFtZTogJ3ZlcnRpY2VzJyxcbiAgICAgICAgICAgIGNvbXBvbmVudHM6IGNvbXBvbmVudHMgfHwgM1xuICAgICAgICB9XX0pO1xufVxuXG5mdW5jdGlvbiBjYXBpdGFsaXplKHN0cmluZykge1xuICAgIHJldHVybiBzdHJpbmcuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBzdHJpbmcuc2xpY2UoMSk7XG59XG5cbmZ1bmN0aW9uIEVsZW1lbnRHcm91cCh2ZXJ0ZXhTdGFydEluZGV4LCBlbGVtZW50U3RhcnRJbmRleCwgc2Vjb25kRWxlbWVudFN0YXJ0SW5kZXgpIHtcbiAgICAvLyB0aGUgb2Zmc2V0IGludG8gdGhlIHZlcnRleCBidWZmZXIgb2YgdGhlIGZpcnN0IHZlcnRleCBpbiB0aGlzIGdyb3VwXG4gICAgdGhpcy52ZXJ0ZXhTdGFydEluZGV4ID0gdmVydGV4U3RhcnRJbmRleDtcbiAgICB0aGlzLmVsZW1lbnRTdGFydEluZGV4ID0gZWxlbWVudFN0YXJ0SW5kZXg7XG4gICAgdGhpcy5zZWNvbmRFbGVtZW50U3RhcnRJbmRleCA9IHNlY29uZEVsZW1lbnRTdGFydEluZGV4O1xuICAgIHRoaXMuZWxlbWVudExlbmd0aCA9IDA7XG4gICAgdGhpcy52ZXJ0ZXhMZW5ndGggPSAwO1xuICAgIHRoaXMuc2Vjb25kRWxlbWVudExlbmd0aCA9IDA7XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBCdWNrZXQgPSByZXF1aXJlKCcuLi9idWNrZXQnKTtcbnZhciB1dGlsID0gcmVxdWlyZSgnLi4vLi4vdXRpbC91dGlsJyk7XG52YXIgbG9hZEdlb21ldHJ5ID0gcmVxdWlyZSgnLi4vbG9hZF9nZW9tZXRyeScpO1xudmFyIEVYVEVOVCA9IEJ1Y2tldC5FWFRFTlQ7XG5cbm1vZHVsZS5leHBvcnRzID0gQ2lyY2xlQnVja2V0O1xuXG4vKipcbiAqIENpcmNsZXMgYXJlIHJlcHJlc2VudGVkIGJ5IHR3byB0cmlhbmdsZXMuXG4gKlxuICogRWFjaCBjb3JuZXIgaGFzIGEgcG9zIHRoYXQgaXMgdGhlIGNlbnRlciBvZiB0aGUgY2lyY2xlIGFuZCBhbiBleHRydXNpb25cbiAqIHZlY3RvciB0aGF0IGlzIHdoZXJlIGl0IHBvaW50cy5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIENpcmNsZUJ1Y2tldCgpIHtcbiAgICBCdWNrZXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuQ2lyY2xlQnVja2V0LnByb3RvdHlwZSA9IHV0aWwuaW5oZXJpdChCdWNrZXQsIHt9KTtcblxuQ2lyY2xlQnVja2V0LnByb3RvdHlwZS5zaGFkZXJJbnRlcmZhY2VzID0ge1xuICAgIGNpcmNsZToge1xuICAgICAgICB2ZXJ0ZXhCdWZmZXI6IHRydWUsXG4gICAgICAgIGVsZW1lbnRCdWZmZXI6IHRydWUsXG5cbiAgICAgICAgYXR0cmlidXRlQXJnczogWyd4JywgJ3knLCAnZXh0cnVkZVgnLCAnZXh0cnVkZVknXSxcblxuICAgICAgICBhdHRyaWJ1dGVzOiBbe1xuICAgICAgICAgICAgbmFtZTogJ3BvcycsXG4gICAgICAgICAgICBjb21wb25lbnRzOiAyLFxuICAgICAgICAgICAgdHlwZTogJ0ludDE2JyxcbiAgICAgICAgICAgIHZhbHVlOiBbXG4gICAgICAgICAgICAgICAgJyh4ICogMikgKyAoKGV4dHJ1ZGVYICsgMSkgLyAyKScsXG4gICAgICAgICAgICAgICAgJyh5ICogMikgKyAoKGV4dHJ1ZGVZICsgMSkgLyAyKSdcbiAgICAgICAgICAgIF1cbiAgICAgICAgfV1cbiAgICB9XG59O1xuXG5DaXJjbGVCdWNrZXQucHJvdG90eXBlLmFkZEZlYXR1cmUgPSBmdW5jdGlvbihmZWF0dXJlKSB7XG5cbiAgICB2YXIgZ2VvbWV0cmllcyA9IGxvYWRHZW9tZXRyeShmZWF0dXJlKTtcbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IGdlb21ldHJpZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgdmFyIGdlb21ldHJ5ID0gZ2VvbWV0cmllc1tqXTtcblxuICAgICAgICBmb3IgKHZhciBrID0gMDsgayA8IGdlb21ldHJ5Lmxlbmd0aDsgaysrKSB7XG4gICAgICAgICAgICB2YXIgZ3JvdXAgPSB0aGlzLm1ha2VSb29tRm9yKCdjaXJjbGUnLCA0KTtcblxuICAgICAgICAgICAgdmFyIHggPSBnZW9tZXRyeVtrXS54O1xuICAgICAgICAgICAgdmFyIHkgPSBnZW9tZXRyeVtrXS55O1xuXG4gICAgICAgICAgICAvLyBEbyBub3QgaW5jbHVkZSBwb2ludHMgdGhhdCBhcmUgb3V0c2lkZSB0aGUgdGlsZSBib3VuZGFyaWVzLlxuICAgICAgICAgICAgaWYgKHggPCAwIHx8IHggPj0gRVhURU5UIHx8IHkgPCAwIHx8IHkgPj0gRVhURU5UKSBjb250aW51ZTtcblxuICAgICAgICAgICAgLy8gdGhpcyBnZW9tZXRyeSB3aWxsIGJlIG9mIHRoZSBQb2ludCB0eXBlLCBhbmQgd2UnbGwgZGVyaXZlXG4gICAgICAgICAgICAvLyB0d28gdHJpYW5nbGVzIGZyb20gaXQuXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8g4pSM4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSQXG4gICAgICAgICAgICAvLyDilIIgMyAgICAgMiDilIJcbiAgICAgICAgICAgIC8vIOKUgiAgICAgICAgIOKUglxuICAgICAgICAgICAgLy8g4pSCIDAgICAgIDEg4pSCXG4gICAgICAgICAgICAvLyDilJTilIDilIDilIDilIDilIDilIDilIDilIDilIDilJhcblxuICAgICAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5hZGRDaXJjbGVWZXJ0ZXgoeCwgeSwgLTEsIC0xKSAtIGdyb3VwLnZlcnRleFN0YXJ0SW5kZXg7XG4gICAgICAgICAgICB0aGlzLmFkZENpcmNsZVZlcnRleCh4LCB5LCAxLCAtMSk7XG4gICAgICAgICAgICB0aGlzLmFkZENpcmNsZVZlcnRleCh4LCB5LCAxLCAxKTtcbiAgICAgICAgICAgIHRoaXMuYWRkQ2lyY2xlVmVydGV4KHgsIHksIC0xLCAxKTtcbiAgICAgICAgICAgIGdyb3VwLnZlcnRleExlbmd0aCArPSA0O1xuXG4gICAgICAgICAgICB0aGlzLmFkZENpcmNsZUVsZW1lbnQoaW5kZXgsIGluZGV4ICsgMSwgaW5kZXggKyAyKTtcbiAgICAgICAgICAgIHRoaXMuYWRkQ2lyY2xlRWxlbWVudChpbmRleCwgaW5kZXggKyAzLCBpbmRleCArIDIpO1xuICAgICAgICAgICAgZ3JvdXAuZWxlbWVudExlbmd0aCArPSAyO1xuICAgICAgICB9XG4gICAgfVxuXG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgQnVja2V0ID0gcmVxdWlyZSgnLi4vYnVja2V0Jyk7XG52YXIgdXRpbCA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvdXRpbCcpO1xudmFyIGxvYWRHZW9tZXRyeSA9IHJlcXVpcmUoJy4uL2xvYWRfZ2VvbWV0cnknKTtcblxubW9kdWxlLmV4cG9ydHMgPSBGaWxsQnVja2V0O1xuXG5mdW5jdGlvbiBGaWxsQnVja2V0KCkge1xuICAgIEJ1Y2tldC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5GaWxsQnVja2V0LnByb3RvdHlwZSA9IHV0aWwuaW5oZXJpdChCdWNrZXQsIHt9KTtcblxuRmlsbEJ1Y2tldC5wcm90b3R5cGUuc2hhZGVySW50ZXJmYWNlcyA9IHtcbiAgICBmaWxsOiB7XG4gICAgICAgIHZlcnRleEJ1ZmZlcjogdHJ1ZSxcbiAgICAgICAgZWxlbWVudEJ1ZmZlcjogdHJ1ZSxcbiAgICAgICAgc2Vjb25kRWxlbWVudEJ1ZmZlcjogdHJ1ZSxcbiAgICAgICAgc2Vjb25kRWxlbWVudEJ1ZmZlckNvbXBvbmVudHM6IDIsXG5cbiAgICAgICAgYXR0cmlidXRlQXJnczogWyd4JywgJ3knXSxcblxuICAgICAgICBhdHRyaWJ1dGVzOiBbe1xuICAgICAgICAgICAgbmFtZTogJ3BvcycsXG4gICAgICAgICAgICBjb21wb25lbnRzOiAyLFxuICAgICAgICAgICAgdHlwZTogJ0ludDE2JyxcbiAgICAgICAgICAgIHZhbHVlOiBbJ3gnLCAneSddXG4gICAgICAgIH1dXG4gICAgfVxufTtcblxuRmlsbEJ1Y2tldC5wcm90b3R5cGUuYWRkRmVhdHVyZSA9IGZ1bmN0aW9uKGZlYXR1cmUpIHtcbiAgICB2YXIgbGluZXMgPSBsb2FkR2VvbWV0cnkoZmVhdHVyZSk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzLmFkZEZpbGwobGluZXNbaV0pO1xuICAgIH1cbn07XG5cbkZpbGxCdWNrZXQucHJvdG90eXBlLmFkZEZpbGwgPSBmdW5jdGlvbih2ZXJ0aWNlcykge1xuICAgIGlmICh2ZXJ0aWNlcy5sZW5ndGggPCAzKSB7XG4gICAgICAgIC8vY29uc29sZS53YXJuKCdhIGZpbGwgbXVzdCBoYXZlIGF0IGxlYXN0IHRocmVlIHZlcnRpY2VzJyk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBDYWxjdWxhdGUgdGhlIHRvdGFsIG51bWJlciBvZiB2ZXJ0aWNlcyB3ZSdyZSBnb2luZyB0byBwcm9kdWNlIHNvIHRoYXQgd2VcbiAgICAvLyBjYW4gcmVzaXplIHRoZSBidWZmZXIgYmVmb3JlaGFuZCwgb3IgZGV0ZWN0IHdoZXRoZXIgdGhlIGN1cnJlbnQgbGluZVxuICAgIC8vIHdvbid0IGZpdCBpbnRvIHRoZSBidWZmZXIgYW55bW9yZS5cbiAgICAvLyBJbiBvcmRlciB0byBiZSBhYmxlIHRvIHVzZSB0aGUgdmVydGV4IGJ1ZmZlciBmb3IgZHJhd2luZyB0aGUgYW50aWFsaWFzZWRcbiAgICAvLyBvdXRsaW5lcywgd2Ugc2VwYXJhdGUgYWxsIHBvbHlnb24gdmVydGljZXMgd2l0aCBhIGRlZ2VuZXJhdGUgKG91dC1vZi1cbiAgICAvLyB2aWV3cGxhbmUpIHZlcnRleC5cblxuICAgIHZhciBsZW4gPSB2ZXJ0aWNlcy5sZW5ndGg7XG5cbiAgICAvLyBFeHBhbmQgdGhpcyBnZW9tZXRyeSBidWZmZXIgdG8gaG9sZCBhbGwgdGhlIHJlcXVpcmVkIHZlcnRpY2VzLlxuICAgIHZhciBncm91cCA9IHRoaXMubWFrZVJvb21Gb3IoJ2ZpbGwnLCBsZW4gKyAxKTtcblxuICAgIC8vIFdlJ3JlIGdlbmVyYXRpbmcgdHJpYW5nbGUgZmFucywgc28gd2UgYWx3YXlzIHN0YXJ0IHdpdGggdGhlIGZpcnN0IGNvb3JkaW5hdGUgaW4gdGhpcyBwb2x5Z29uLlxuICAgIHZhciBmaXJzdEluZGV4LCBwcmV2SW5kZXg7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2ZXJ0aWNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgY3VycmVudFZlcnRleCA9IHZlcnRpY2VzW2ldO1xuXG4gICAgICAgIHZhciBjdXJyZW50SW5kZXggPSB0aGlzLmFkZEZpbGxWZXJ0ZXgoY3VycmVudFZlcnRleC54LCBjdXJyZW50VmVydGV4LnkpIC0gZ3JvdXAudmVydGV4U3RhcnRJbmRleDtcbiAgICAgICAgZ3JvdXAudmVydGV4TGVuZ3RoKys7XG4gICAgICAgIGlmIChpID09PSAwKSBmaXJzdEluZGV4ID0gY3VycmVudEluZGV4O1xuXG4gICAgICAgIC8vIE9ubHkgYWRkIHRyaWFuZ2xlcyB0aGF0IGhhdmUgZGlzdGluY3QgdmVydGljZXMuXG4gICAgICAgIGlmIChpID49IDIgJiYgKGN1cnJlbnRWZXJ0ZXgueCAhPT0gdmVydGljZXNbMF0ueCB8fCBjdXJyZW50VmVydGV4LnkgIT09IHZlcnRpY2VzWzBdLnkpKSB7XG4gICAgICAgICAgICB0aGlzLmFkZEZpbGxFbGVtZW50KGZpcnN0SW5kZXgsIHByZXZJbmRleCwgY3VycmVudEluZGV4KTtcbiAgICAgICAgICAgIGdyb3VwLmVsZW1lbnRMZW5ndGgrKztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpID49IDEpIHtcbiAgICAgICAgICAgIHRoaXMuYWRkRmlsbFNlY29uZEVsZW1lbnQocHJldkluZGV4LCBjdXJyZW50SW5kZXgpO1xuICAgICAgICAgICAgZ3JvdXAuc2Vjb25kRWxlbWVudExlbmd0aCsrO1xuICAgICAgICB9XG5cbiAgICAgICAgcHJldkluZGV4ID0gY3VycmVudEluZGV4O1xuICAgIH1cbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBCdWNrZXQgPSByZXF1aXJlKCcuLi9idWNrZXQnKTtcbnZhciB1dGlsID0gcmVxdWlyZSgnLi4vLi4vdXRpbC91dGlsJyk7XG52YXIgbG9hZEdlb21ldHJ5ID0gcmVxdWlyZSgnLi4vbG9hZF9nZW9tZXRyeScpO1xudmFyIEVYVEVOVCA9IEJ1Y2tldC5FWFRFTlQ7XG5cbi8vIE5PVEUgT04gRVhUUlVERSBTQ0FMRTpcbi8vIHNjYWxlIHRoZSBleHRydXNpb24gdmVjdG9yIHNvIHRoYXQgdGhlIG5vcm1hbCBsZW5ndGggaXMgdGhpcyB2YWx1ZS5cbi8vIGNvbnRhaW5zIHRoZSBcInRleHR1cmVcIiBub3JtYWxzICgtMS4uMSkuIHRoaXMgaXMgZGlzdGluY3QgZnJvbSB0aGUgZXh0cnVkZVxuLy8gbm9ybWFscyBmb3IgbGluZSBqb2lucywgYmVjYXVzZSB0aGUgeC12YWx1ZSByZW1haW5zIDAgZm9yIHRoZSB0ZXh0dXJlXG4vLyBub3JtYWwgYXJyYXksIHdoaWxlIHRoZSBleHRydWRlIG5vcm1hbCBhY3R1YWxseSBtb3ZlcyB0aGUgdmVydGV4IHRvIGNyZWF0ZVxuLy8gdGhlIGFjdXRlL2JldmVsbGVkIGxpbmUgam9pbi5cbnZhciBFWFRSVURFX1NDQUxFID0gNjM7XG5cbi8qXG4gKiBTaGFycCBjb3JuZXJzIGNhdXNlIGRhc2hlZCBsaW5lcyB0byB0aWx0IGJlY2F1c2UgdGhlIGRpc3RhbmNlIGFsb25nIHRoZSBsaW5lXG4gKiBpcyB0aGUgc2FtZSBhdCBib3RoIHRoZSBpbm5lciBhbmQgb3V0ZXIgY29ybmVycy4gVG8gaW1wcm92ZSB0aGUgYXBwZWFyYW5jZSBvZlxuICogZGFzaGVkIGxpbmVzIHdlIGFkZCBleHRyYSBwb2ludHMgbmVhciBzaGFycCBjb3JuZXJzIHNvIHRoYXQgYSBzbWFsbGVyIHBhcnRcbiAqIG9mIHRoZSBsaW5lIGlzIHRpbHRlZC5cbiAqXG4gKiBDT1NfSEFMRl9TSEFSUF9DT1JORVIgY29udHJvbHMgaG93IHNoYXJwIGEgY29ybmVyIGhhcyB0byBiZSBmb3IgdXMgdG8gYWRkIGFuXG4gKiBleHRyYSB2ZXJ0ZXguIFRoZSBkZWZhdWx0IGlzIDc1IGRlZ3JlZXMuXG4gKlxuICogVGhlIG5ld2x5IGNyZWF0ZWQgdmVydGljZXMgYXJlIHBsYWNlZCBTSEFSUF9DT1JORVJfT0ZGU0VUIHBpeGVscyBmcm9tIHRoZSBjb3JuZXIuXG4gKi9cbnZhciBDT1NfSEFMRl9TSEFSUF9DT1JORVIgPSBNYXRoLmNvcyg3NSAvIDIgKiAoTWF0aC5QSSAvIDE4MCkpO1xudmFyIFNIQVJQX0NPUk5FUl9PRkZTRVQgPSAxNTtcblxuLy8gVGhlIG51bWJlciBvZiBiaXRzIHRoYXQgaXMgdXNlZCB0byBzdG9yZSB0aGUgbGluZSBkaXN0YW5jZSBpbiB0aGUgYnVmZmVyLlxudmFyIExJTkVfRElTVEFOQ0VfQlVGRkVSX0JJVFMgPSAxNDtcblxuLy8gV2UgZG9uJ3QgaGF2ZSBlbm91Z2ggYml0cyBmb3IgdGhlIGxpbmUgZGlzdGFuY2UgYXMgd2UnZCBsaWtlIHRvIGhhdmUsIHNvXG4vLyB1c2UgdGhpcyB2YWx1ZSB0byBzY2FsZSB0aGUgbGluZSBkaXN0YW5jZSAoaW4gdGlsZSB1bml0cykgZG93biB0byBhIHNtYWxsZXJcbi8vIHZhbHVlLiBUaGlzIGxldHMgdXMgc3RvcmUgbG9uZ2VyIGRpc3RhbmNlcyB3aGlsZSBzYWNyaWZpY2luZyBwcmVjaXNpb24uXG52YXIgTElORV9ESVNUQU5DRV9TQ0FMRSA9IDEgLyAyO1xuXG4vLyBUaGUgbWF4aW11bSBsaW5lIGRpc3RhbmNlLCBpbiB0aWxlIHVuaXRzLCB0aGF0IGZpdHMgaW4gdGhlIGJ1ZmZlci5cbnZhciBNQVhfTElORV9ESVNUQU5DRSA9IE1hdGgucG93KDIsIExJTkVfRElTVEFOQ0VfQlVGRkVSX0JJVFMpIC8gTElORV9ESVNUQU5DRV9TQ0FMRTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IExpbmVCdWNrZXQ7XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gTGluZUJ1Y2tldCgpIHtcbiAgICBCdWNrZXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuTGluZUJ1Y2tldC5wcm90b3R5cGUgPSB1dGlsLmluaGVyaXQoQnVja2V0LCB7fSk7XG5cbkxpbmVCdWNrZXQucHJvdG90eXBlLnNoYWRlckludGVyZmFjZXMgPSB7XG4gICAgbGluZToge1xuICAgICAgICB2ZXJ0ZXhCdWZmZXI6IHRydWUsXG4gICAgICAgIGVsZW1lbnRCdWZmZXI6IHRydWUsXG5cbiAgICAgICAgYXR0cmlidXRlQXJnczogWydwb2ludCcsICdleHRydWRlJywgJ3R4JywgJ3R5JywgJ2RpcicsICdsaW5lc29mYXInXSxcblxuICAgICAgICBhdHRyaWJ1dGVzOiBbe1xuICAgICAgICAgICAgbmFtZTogJ3BvcycsXG4gICAgICAgICAgICBjb21wb25lbnRzOiAyLFxuICAgICAgICAgICAgdHlwZTogJ0ludDE2JyxcbiAgICAgICAgICAgIHZhbHVlOiBbXG4gICAgICAgICAgICAgICAgJyhwb2ludC54IDw8IDEpIHwgdHgnLFxuICAgICAgICAgICAgICAgICcocG9pbnQueSA8PCAxKSB8IHR5J1xuICAgICAgICAgICAgXVxuICAgICAgICB9LCB7XG4gICAgICAgICAgICBuYW1lOiAnZGF0YScsXG4gICAgICAgICAgICBjb21wb25lbnRzOiA0LFxuICAgICAgICAgICAgdHlwZTogJ1VpbnQ4JyxcbiAgICAgICAgICAgIHZhbHVlOiBbXG4gICAgICAgICAgICAgICAgLy8gYWRkIDEyOCB0byBzdG9yZSBhbiBieXRlIGluIGFuIHVuc2lnbmVkIGJ5dGVcbiAgICAgICAgICAgICAgICAnTWF0aC5yb3VuZCgnICsgRVhUUlVERV9TQ0FMRSArICcgKiBleHRydWRlLngpICsgMTI4JyxcbiAgICAgICAgICAgICAgICAnTWF0aC5yb3VuZCgnICsgRVhUUlVERV9TQ0FMRSArICcgKiBleHRydWRlLnkpICsgMTI4JyxcblxuICAgICAgICAgICAgICAgIC8vIEVuY29kZSB0aGUgLTEvMC8xIGRpcmVjdGlvbiB2YWx1ZSBpbnRvIHRoZSBmaXJzdCB0d28gYml0cyBvZiAueiBvZiBhX2RhdGEuXG4gICAgICAgICAgICAgICAgLy8gQ29tYmluZSBpdCB3aXRoIHRoZSBsb3dlciA2IGJpdHMgb2YgYGxpbmVzb2ZhcmAgKHNoaWZ0ZWQgYnkgMiBiaXRlcyB0byBtYWtlXG4gICAgICAgICAgICAgICAgLy8gcm9vbSBmb3IgdGhlIGRpcmVjdGlvbiB2YWx1ZSkuIFRoZSB1cHBlciA4IGJpdHMgb2YgYGxpbmVzb2ZhcmAgYXJlIHBsYWNlZCBpblxuICAgICAgICAgICAgICAgIC8vIHRoZSBgd2AgY29tcG9uZW50LiBgbGluZXNvZmFyYCBpcyBzY2FsZWQgZG93biBieSBgTElORV9ESVNUQU5DRV9TQ0FMRWAgc28gdGhhdFxuICAgICAgICAgICAgICAgIC8vIHdlIGNhbiBzdG9yZSBsb25nZXIgZGlzdGFuY2VzIHdoaWxlIHNhY3JpZmljaW5nIHByZWNpc2lvbi5cbiAgICAgICAgICAgICAgICAnKChkaXIgPT09IDAgPyAwIDogKGRpciA8IDAgPyAtMSA6IDEpKSArIDEpIHwgKCgobGluZXNvZmFyICogJyArIExJTkVfRElTVEFOQ0VfU0NBTEUgKyAnKSAmIDB4M0YpIDw8IDIpJyxcbiAgICAgICAgICAgICAgICAnKGxpbmVzb2ZhciAqICcgKyBMSU5FX0RJU1RBTkNFX1NDQUxFICsgJykgPj4gNidcbiAgICAgICAgICAgIF1cbiAgICAgICAgfV1cbiAgICB9XG59O1xuXG5MaW5lQnVja2V0LnByb3RvdHlwZS5hZGRGZWF0dXJlID0gZnVuY3Rpb24oZmVhdHVyZSkge1xuICAgIHZhciBsaW5lcyA9IGxvYWRHZW9tZXRyeShmZWF0dXJlKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpbmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMuYWRkTGluZShcbiAgICAgICAgICAgIGxpbmVzW2ldLFxuICAgICAgICAgICAgdGhpcy5sYXllci5sYXlvdXRbJ2xpbmUtam9pbiddLFxuICAgICAgICAgICAgdGhpcy5sYXllci5sYXlvdXRbJ2xpbmUtY2FwJ10sXG4gICAgICAgICAgICB0aGlzLmxheWVyLmxheW91dFsnbGluZS1taXRlci1saW1pdCddLFxuICAgICAgICAgICAgdGhpcy5sYXllci5sYXlvdXRbJ2xpbmUtcm91bmQtbGltaXQnXVxuICAgICAgICApO1xuICAgIH1cbn07XG5cbkxpbmVCdWNrZXQucHJvdG90eXBlLmFkZExpbmUgPSBmdW5jdGlvbih2ZXJ0aWNlcywgam9pbiwgY2FwLCBtaXRlckxpbWl0LCByb3VuZExpbWl0KSB7XG5cbiAgICB2YXIgbGVuID0gdmVydGljZXMubGVuZ3RoO1xuICAgIC8vIElmIHRoZSBsaW5lIGhhcyBkdXBsaWNhdGUgdmVydGljZXMgYXQgdGhlIGVuZCwgYWRqdXN0IGxlbmd0aCB0byByZW1vdmUgdGhlbS5cbiAgICB3aGlsZSAobGVuID4gMiAmJiB2ZXJ0aWNlc1tsZW4gLSAxXS5lcXVhbHModmVydGljZXNbbGVuIC0gMl0pKSB7XG4gICAgICAgIGxlbi0tO1xuICAgIH1cblxuICAgIGlmICh2ZXJ0aWNlcy5sZW5ndGggPCAyKSB7XG4gICAgICAgIC8vY29uc29sZS53YXJuKCdhIGxpbmUgbXVzdCBoYXZlIGF0IGxlYXN0IHR3byB2ZXJ0aWNlcycpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGpvaW4gPT09ICdiZXZlbCcpIG1pdGVyTGltaXQgPSAxLjA1O1xuXG4gICAgdmFyIHNoYXJwQ29ybmVyT2Zmc2V0ID0gU0hBUlBfQ09STkVSX09GRlNFVCAqIChFWFRFTlQgLyAoNTEyICogdGhpcy5vdmVyc2NhbGluZykpO1xuXG4gICAgdmFyIGZpcnN0VmVydGV4ID0gdmVydGljZXNbMF0sXG4gICAgICAgIGxhc3RWZXJ0ZXggPSB2ZXJ0aWNlc1tsZW4gLSAxXSxcbiAgICAgICAgY2xvc2VkID0gZmlyc3RWZXJ0ZXguZXF1YWxzKGxhc3RWZXJ0ZXgpO1xuXG4gICAgLy8gd2UgY291bGQgYmUgbW9yZSBwcmVjaXNlLCBidXQgaXQgd291bGQgb25seSBzYXZlIGEgbmVnbGlnaWJsZSBhbW91bnQgb2Ygc3BhY2VcbiAgICB0aGlzLm1ha2VSb29tRm9yKCdsaW5lJywgbGVuICogMTApO1xuXG4gICAgaWYgKGxlbiA9PT0gMiAmJiBjbG9zZWQpIHtcbiAgICAgICAgLy8gY29uc29sZS53YXJuKCdhIGxpbmUgbWF5IG5vdCBoYXZlIGNvaW5jaWRlbnQgcG9pbnRzJyk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLmRpc3RhbmNlID0gMDtcblxuICAgIHZhciBiZWdpbkNhcCA9IGNhcCxcbiAgICAgICAgZW5kQ2FwID0gY2xvc2VkID8gJ2J1dHQnIDogY2FwLFxuICAgICAgICBzdGFydE9mTGluZSA9IHRydWUsXG4gICAgICAgIGN1cnJlbnRWZXJ0ZXgsIHByZXZWZXJ0ZXgsIG5leHRWZXJ0ZXgsIHByZXZOb3JtYWwsIG5leHROb3JtYWwsIG9mZnNldEEsIG9mZnNldEI7XG5cbiAgICAvLyB0aGUgbGFzdCB0aHJlZSB2ZXJ0aWNlcyBhZGRlZFxuICAgIHRoaXMuZTEgPSB0aGlzLmUyID0gdGhpcy5lMyA9IC0xO1xuXG4gICAgaWYgKGNsb3NlZCkge1xuICAgICAgICBjdXJyZW50VmVydGV4ID0gdmVydGljZXNbbGVuIC0gMl07XG4gICAgICAgIG5leHROb3JtYWwgPSBmaXJzdFZlcnRleC5zdWIoY3VycmVudFZlcnRleCkuX3VuaXQoKS5fcGVycCgpO1xuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcblxuICAgICAgICBuZXh0VmVydGV4ID0gY2xvc2VkICYmIGkgPT09IGxlbiAtIDEgP1xuICAgICAgICAgICAgdmVydGljZXNbMV0gOiAvLyBpZiB0aGUgbGluZSBpcyBjbG9zZWQsIHdlIHRyZWF0IHRoZSBsYXN0IHZlcnRleCBsaWtlIHRoZSBmaXJzdFxuICAgICAgICAgICAgdmVydGljZXNbaSArIDFdOyAvLyBqdXN0IHRoZSBuZXh0IHZlcnRleFxuXG4gICAgICAgIC8vIGlmIHR3byBjb25zZWN1dGl2ZSB2ZXJ0aWNlcyBleGlzdCwgc2tpcCB0aGUgY3VycmVudCBvbmVcbiAgICAgICAgaWYgKG5leHRWZXJ0ZXggJiYgdmVydGljZXNbaV0uZXF1YWxzKG5leHRWZXJ0ZXgpKSBjb250aW51ZTtcblxuICAgICAgICBpZiAobmV4dE5vcm1hbCkgcHJldk5vcm1hbCA9IG5leHROb3JtYWw7XG4gICAgICAgIGlmIChjdXJyZW50VmVydGV4KSBwcmV2VmVydGV4ID0gY3VycmVudFZlcnRleDtcblxuICAgICAgICBjdXJyZW50VmVydGV4ID0gdmVydGljZXNbaV07XG5cbiAgICAgICAgLy8gQ2FsY3VsYXRlIHRoZSBub3JtYWwgdG93YXJkcyB0aGUgbmV4dCB2ZXJ0ZXggaW4gdGhpcyBsaW5lLiBJbiBjYXNlXG4gICAgICAgIC8vIHRoZXJlIGlzIG5vIG5leHQgdmVydGV4LCBwcmV0ZW5kIHRoYXQgdGhlIGxpbmUgaXMgY29udGludWluZyBzdHJhaWdodCxcbiAgICAgICAgLy8gbWVhbmluZyB0aGF0IHdlIGFyZSBqdXN0IHVzaW5nIHRoZSBwcmV2aW91cyBub3JtYWwuXG4gICAgICAgIG5leHROb3JtYWwgPSBuZXh0VmVydGV4ID8gbmV4dFZlcnRleC5zdWIoY3VycmVudFZlcnRleCkuX3VuaXQoKS5fcGVycCgpIDogcHJldk5vcm1hbDtcblxuICAgICAgICAvLyBJZiB3ZSBzdGlsbCBkb24ndCBoYXZlIGEgcHJldmlvdXMgbm9ybWFsLCB0aGlzIGlzIHRoZSBiZWdpbm5pbmcgb2YgYVxuICAgICAgICAvLyBub24tY2xvc2VkIGxpbmUsIHNvIHdlJ3JlIGRvaW5nIGEgc3RyYWlnaHQgXCJqb2luXCIuXG4gICAgICAgIHByZXZOb3JtYWwgPSBwcmV2Tm9ybWFsIHx8IG5leHROb3JtYWw7XG5cbiAgICAgICAgLy8gRGV0ZXJtaW5lIHRoZSBub3JtYWwgb2YgdGhlIGpvaW4gZXh0cnVzaW9uLiBJdCBpcyB0aGUgYW5nbGUgYmlzZWN0b3JcbiAgICAgICAgLy8gb2YgdGhlIHNlZ21lbnRzIGJldHdlZW4gdGhlIHByZXZpb3VzIGxpbmUgYW5kIHRoZSBuZXh0IGxpbmUuXG4gICAgICAgIHZhciBqb2luTm9ybWFsID0gcHJldk5vcm1hbC5hZGQobmV4dE5vcm1hbCkuX3VuaXQoKTtcblxuICAgICAgICAvKiAgam9pbk5vcm1hbCAgICAgcHJldk5vcm1hbFxuICAgICAgICAgKiAgICAgICAgICAgICDihpYgICAgICDihpFcbiAgICAgICAgICogICAgICAgICAgICAgICAgLl9fX19fX19fLiBwcmV2VmVydGV4XG4gICAgICAgICAqICAgICAgICAgICAgICAgIHxcbiAgICAgICAgICogbmV4dE5vcm1hbCAg4oaQICB8ICBjdXJyZW50VmVydGV4XG4gICAgICAgICAqICAgICAgICAgICAgICAgIHxcbiAgICAgICAgICogICAgIG5leHRWZXJ0ZXggIVxuICAgICAgICAgKlxuICAgICAgICAgKi9cblxuICAgICAgICAvLyBDYWxjdWxhdGUgdGhlIGxlbmd0aCBvZiB0aGUgbWl0ZXIgKHRoZSByYXRpbyBvZiB0aGUgbWl0ZXIgdG8gdGhlIHdpZHRoKS5cbiAgICAgICAgLy8gRmluZCB0aGUgY29zaW5lIG9mIHRoZSBhbmdsZSBiZXR3ZWVuIHRoZSBuZXh0IGFuZCBqb2luIG5vcm1hbHNcbiAgICAgICAgLy8gdXNpbmcgZG90IHByb2R1Y3QuIFRoZSBpbnZlcnNlIG9mIHRoYXQgaXMgdGhlIG1pdGVyIGxlbmd0aC5cbiAgICAgICAgdmFyIGNvc0hhbGZBbmdsZSA9IGpvaW5Ob3JtYWwueCAqIG5leHROb3JtYWwueCArIGpvaW5Ob3JtYWwueSAqIG5leHROb3JtYWwueTtcbiAgICAgICAgdmFyIG1pdGVyTGVuZ3RoID0gMSAvIGNvc0hhbGZBbmdsZTtcblxuICAgICAgICB2YXIgaXNTaGFycENvcm5lciA9IGNvc0hhbGZBbmdsZSA8IENPU19IQUxGX1NIQVJQX0NPUk5FUiAmJiBwcmV2VmVydGV4ICYmIG5leHRWZXJ0ZXg7XG5cbiAgICAgICAgaWYgKGlzU2hhcnBDb3JuZXIgJiYgaSA+IDApIHtcbiAgICAgICAgICAgIHZhciBwcmV2U2VnbWVudExlbmd0aCA9IGN1cnJlbnRWZXJ0ZXguZGlzdChwcmV2VmVydGV4KTtcbiAgICAgICAgICAgIGlmIChwcmV2U2VnbWVudExlbmd0aCA+IDIgKiBzaGFycENvcm5lck9mZnNldCkge1xuICAgICAgICAgICAgICAgIHZhciBuZXdQcmV2VmVydGV4ID0gY3VycmVudFZlcnRleC5zdWIoY3VycmVudFZlcnRleC5zdWIocHJldlZlcnRleCkuX211bHQoc2hhcnBDb3JuZXJPZmZzZXQgLyBwcmV2U2VnbWVudExlbmd0aCkuX3JvdW5kKCkpO1xuICAgICAgICAgICAgICAgIHRoaXMuZGlzdGFuY2UgKz0gbmV3UHJldlZlcnRleC5kaXN0KHByZXZWZXJ0ZXgpO1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkQ3VycmVudFZlcnRleChuZXdQcmV2VmVydGV4LCB0aGlzLmRpc3RhbmNlLCBwcmV2Tm9ybWFsLm11bHQoMSksIDAsIDAsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICBwcmV2VmVydGV4ID0gbmV3UHJldlZlcnRleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRoZSBqb2luIGlmIGEgbWlkZGxlIHZlcnRleCwgb3RoZXJ3aXNlIHRoZSBjYXAuXG4gICAgICAgIHZhciBtaWRkbGVWZXJ0ZXggPSBwcmV2VmVydGV4ICYmIG5leHRWZXJ0ZXg7XG4gICAgICAgIHZhciBjdXJyZW50Sm9pbiA9IG1pZGRsZVZlcnRleCA/IGpvaW4gOiBuZXh0VmVydGV4ID8gYmVnaW5DYXAgOiBlbmRDYXA7XG5cbiAgICAgICAgaWYgKG1pZGRsZVZlcnRleCAmJiBjdXJyZW50Sm9pbiA9PT0gJ3JvdW5kJykge1xuICAgICAgICAgICAgaWYgKG1pdGVyTGVuZ3RoIDwgcm91bmRMaW1pdCkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRKb2luID0gJ21pdGVyJztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobWl0ZXJMZW5ndGggPD0gMikge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRKb2luID0gJ2Zha2Vyb3VuZCc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY3VycmVudEpvaW4gPT09ICdtaXRlcicgJiYgbWl0ZXJMZW5ndGggPiBtaXRlckxpbWl0KSB7XG4gICAgICAgICAgICBjdXJyZW50Sm9pbiA9ICdiZXZlbCc7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY3VycmVudEpvaW4gPT09ICdiZXZlbCcpIHtcbiAgICAgICAgICAgIC8vIFRoZSBtYXhpbXVtIGV4dHJ1ZGUgbGVuZ3RoIGlzIDEyOCAvIDYzID0gMiB0aW1lcyB0aGUgd2lkdGggb2YgdGhlIGxpbmVcbiAgICAgICAgICAgIC8vIHNvIGlmIG1pdGVyTGVuZ3RoID49IDIgd2UgbmVlZCB0byBkcmF3IGEgZGlmZmVyZW50IHR5cGUgb2YgYmV2ZWwgd2hlcmUuXG4gICAgICAgICAgICBpZiAobWl0ZXJMZW5ndGggPiAyKSBjdXJyZW50Sm9pbiA9ICdmbGlwYmV2ZWwnO1xuXG4gICAgICAgICAgICAvLyBJZiB0aGUgbWl0ZXJMZW5ndGggaXMgcmVhbGx5IHNtYWxsIGFuZCB0aGUgbGluZSBiZXZlbCB3b3VsZG4ndCBiZSB2aXNpYmxlLFxuICAgICAgICAgICAgLy8ganVzdCBkcmF3IGEgbWl0ZXIgam9pbiB0byBzYXZlIGEgdHJpYW5nbGUuXG4gICAgICAgICAgICBpZiAobWl0ZXJMZW5ndGggPCBtaXRlckxpbWl0KSBjdXJyZW50Sm9pbiA9ICdtaXRlcic7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDYWxjdWxhdGUgaG93IGZhciBhbG9uZyB0aGUgbGluZSB0aGUgY3VycmVudFZlcnRleCBpc1xuICAgICAgICBpZiAocHJldlZlcnRleCkgdGhpcy5kaXN0YW5jZSArPSBjdXJyZW50VmVydGV4LmRpc3QocHJldlZlcnRleCk7XG5cbiAgICAgICAgaWYgKGN1cnJlbnRKb2luID09PSAnbWl0ZXInKSB7XG5cbiAgICAgICAgICAgIGpvaW5Ob3JtYWwuX211bHQobWl0ZXJMZW5ndGgpO1xuICAgICAgICAgICAgdGhpcy5hZGRDdXJyZW50VmVydGV4KGN1cnJlbnRWZXJ0ZXgsIHRoaXMuZGlzdGFuY2UsIGpvaW5Ob3JtYWwsIDAsIDAsIGZhbHNlKTtcblxuICAgICAgICB9IGVsc2UgaWYgKGN1cnJlbnRKb2luID09PSAnZmxpcGJldmVsJykge1xuICAgICAgICAgICAgLy8gbWl0ZXIgaXMgdG9vIGJpZywgZmxpcCB0aGUgZGlyZWN0aW9uIHRvIG1ha2UgYSBiZXZlbGVkIGpvaW5cblxuICAgICAgICAgICAgaWYgKG1pdGVyTGVuZ3RoID4gMTAwKSB7XG4gICAgICAgICAgICAgICAgLy8gQWxtb3N0IHBhcmFsbGVsIGxpbmVzXG4gICAgICAgICAgICAgICAgam9pbk5vcm1hbCA9IG5leHROb3JtYWwuY2xvbmUoKTtcblxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgZGlyZWN0aW9uID0gcHJldk5vcm1hbC54ICogbmV4dE5vcm1hbC55IC0gcHJldk5vcm1hbC55ICogbmV4dE5vcm1hbC54ID4gMCA/IC0xIDogMTtcbiAgICAgICAgICAgICAgICB2YXIgYmV2ZWxMZW5ndGggPSBtaXRlckxlbmd0aCAqIHByZXZOb3JtYWwuYWRkKG5leHROb3JtYWwpLm1hZygpIC8gcHJldk5vcm1hbC5zdWIobmV4dE5vcm1hbCkubWFnKCk7XG4gICAgICAgICAgICAgICAgam9pbk5vcm1hbC5fcGVycCgpLl9tdWx0KGJldmVsTGVuZ3RoICogZGlyZWN0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuYWRkQ3VycmVudFZlcnRleChjdXJyZW50VmVydGV4LCB0aGlzLmRpc3RhbmNlLCBqb2luTm9ybWFsLCAwLCAwLCBmYWxzZSk7XG4gICAgICAgICAgICB0aGlzLmFkZEN1cnJlbnRWZXJ0ZXgoY3VycmVudFZlcnRleCwgdGhpcy5kaXN0YW5jZSwgam9pbk5vcm1hbC5tdWx0KC0xKSwgMCwgMCwgZmFsc2UpO1xuXG4gICAgICAgIH0gZWxzZSBpZiAoY3VycmVudEpvaW4gPT09ICdiZXZlbCcgfHwgY3VycmVudEpvaW4gPT09ICdmYWtlcm91bmQnKSB7XG4gICAgICAgICAgICB2YXIgbGluZVR1cm5zTGVmdCA9IChwcmV2Tm9ybWFsLnggKiBuZXh0Tm9ybWFsLnkgLSBwcmV2Tm9ybWFsLnkgKiBuZXh0Tm9ybWFsLngpID4gMDtcbiAgICAgICAgICAgIHZhciBvZmZzZXQgPSAtTWF0aC5zcXJ0KG1pdGVyTGVuZ3RoICogbWl0ZXJMZW5ndGggLSAxKTtcbiAgICAgICAgICAgIGlmIChsaW5lVHVybnNMZWZ0KSB7XG4gICAgICAgICAgICAgICAgb2Zmc2V0QiA9IDA7XG4gICAgICAgICAgICAgICAgb2Zmc2V0QSA9IG9mZnNldDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgb2Zmc2V0QSA9IDA7XG4gICAgICAgICAgICAgICAgb2Zmc2V0QiA9IG9mZnNldDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQ2xvc2UgcHJldmlvdXMgc2VnbWVudCB3aXRoIGEgYmV2ZWxcbiAgICAgICAgICAgIGlmICghc3RhcnRPZkxpbmUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFkZEN1cnJlbnRWZXJ0ZXgoY3VycmVudFZlcnRleCwgdGhpcy5kaXN0YW5jZSwgcHJldk5vcm1hbCwgb2Zmc2V0QSwgb2Zmc2V0QiwgZmFsc2UpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoY3VycmVudEpvaW4gPT09ICdmYWtlcm91bmQnKSB7XG4gICAgICAgICAgICAgICAgLy8gVGhlIGpvaW4gYW5nbGUgaXMgc2hhcnAgZW5vdWdoIHRoYXQgYSByb3VuZCBqb2luIHdvdWxkIGJlIHZpc2libGUuXG4gICAgICAgICAgICAgICAgLy8gQmV2ZWwgam9pbnMgZmlsbCB0aGUgZ2FwIGJldHdlZW4gc2VnbWVudHMgd2l0aCBhIHNpbmdsZSBwaWUgc2xpY2UgdHJpYW5nbGUuXG4gICAgICAgICAgICAgICAgLy8gQ3JlYXRlIGEgcm91bmQgam9pbiBieSBhZGRpbmcgbXVsdGlwbGUgcGllIHNsaWNlcy4gVGhlIGpvaW4gaXNuJ3QgYWN0dWFsbHkgcm91bmQsIGJ1dFxuICAgICAgICAgICAgICAgIC8vIGl0IGxvb2tzIGxpa2UgaXQgaXMgYXQgdGhlIHNpemVzIHdlIHJlbmRlciBsaW5lcyBhdC5cblxuICAgICAgICAgICAgICAgIC8vIEFkZCBtb3JlIHRyaWFuZ2xlcyBmb3Igc2hhcnBlciBhbmdsZXMuXG4gICAgICAgICAgICAgICAgLy8gVGhpcyBtYXRoIGlzIGp1c3QgYSBnb29kIGVub3VnaCBhcHByb3hpbWF0aW9uLiBJdCBpc24ndCBcImNvcnJlY3RcIi5cbiAgICAgICAgICAgICAgICB2YXIgbiA9IE1hdGguZmxvb3IoKDAuNSAtIChjb3NIYWxmQW5nbGUgLSAwLjUpKSAqIDgpO1xuICAgICAgICAgICAgICAgIHZhciBhcHByb3hGcmFjdGlvbmFsSm9pbk5vcm1hbDtcblxuICAgICAgICAgICAgICAgIGZvciAodmFyIG0gPSAwOyBtIDwgbjsgbSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGFwcHJveEZyYWN0aW9uYWxKb2luTm9ybWFsID0gbmV4dE5vcm1hbC5tdWx0KChtICsgMSkgLyAobiArIDEpKS5fYWRkKHByZXZOb3JtYWwpLl91bml0KCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkUGllU2xpY2VWZXJ0ZXgoY3VycmVudFZlcnRleCwgdGhpcy5kaXN0YW5jZSwgYXBwcm94RnJhY3Rpb25hbEpvaW5Ob3JtYWwsIGxpbmVUdXJuc0xlZnQpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRoaXMuYWRkUGllU2xpY2VWZXJ0ZXgoY3VycmVudFZlcnRleCwgdGhpcy5kaXN0YW5jZSwgam9pbk5vcm1hbCwgbGluZVR1cm5zTGVmdCk7XG5cbiAgICAgICAgICAgICAgICBmb3IgKHZhciBrID0gbiAtIDE7IGsgPj0gMDsgay0tKSB7XG4gICAgICAgICAgICAgICAgICAgIGFwcHJveEZyYWN0aW9uYWxKb2luTm9ybWFsID0gcHJldk5vcm1hbC5tdWx0KChrICsgMSkgLyAobiArIDEpKS5fYWRkKG5leHROb3JtYWwpLl91bml0KCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkUGllU2xpY2VWZXJ0ZXgoY3VycmVudFZlcnRleCwgdGhpcy5kaXN0YW5jZSwgYXBwcm94RnJhY3Rpb25hbEpvaW5Ob3JtYWwsIGxpbmVUdXJuc0xlZnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gU3RhcnQgbmV4dCBzZWdtZW50XG4gICAgICAgICAgICBpZiAobmV4dFZlcnRleCkge1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkQ3VycmVudFZlcnRleChjdXJyZW50VmVydGV4LCB0aGlzLmRpc3RhbmNlLCBuZXh0Tm9ybWFsLCAtb2Zmc2V0QSwgLW9mZnNldEIsIGZhbHNlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9IGVsc2UgaWYgKGN1cnJlbnRKb2luID09PSAnYnV0dCcpIHtcbiAgICAgICAgICAgIGlmICghc3RhcnRPZkxpbmUpIHtcbiAgICAgICAgICAgICAgICAvLyBDbG9zZSBwcmV2aW91cyBzZWdtZW50IHdpdGggYSBidXR0XG4gICAgICAgICAgICAgICAgdGhpcy5hZGRDdXJyZW50VmVydGV4KGN1cnJlbnRWZXJ0ZXgsIHRoaXMuZGlzdGFuY2UsIHByZXZOb3JtYWwsIDAsIDAsIGZhbHNlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gU3RhcnQgbmV4dCBzZWdtZW50IHdpdGggYSBidXR0XG4gICAgICAgICAgICBpZiAobmV4dFZlcnRleCkge1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkQ3VycmVudFZlcnRleChjdXJyZW50VmVydGV4LCB0aGlzLmRpc3RhbmNlLCBuZXh0Tm9ybWFsLCAwLCAwLCBmYWxzZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfSBlbHNlIGlmIChjdXJyZW50Sm9pbiA9PT0gJ3NxdWFyZScpIHtcblxuICAgICAgICAgICAgaWYgKCFzdGFydE9mTGluZSkge1xuICAgICAgICAgICAgICAgIC8vIENsb3NlIHByZXZpb3VzIHNlZ21lbnQgd2l0aCBhIHNxdWFyZSBjYXBcbiAgICAgICAgICAgICAgICB0aGlzLmFkZEN1cnJlbnRWZXJ0ZXgoY3VycmVudFZlcnRleCwgdGhpcy5kaXN0YW5jZSwgcHJldk5vcm1hbCwgMSwgMSwgZmFsc2UpO1xuXG4gICAgICAgICAgICAgICAgLy8gVGhlIHNlZ21lbnQgaXMgZG9uZS4gVW5zZXQgdmVydGljZXMgdG8gZGlzY29ubmVjdCBzZWdtZW50cy5cbiAgICAgICAgICAgICAgICB0aGlzLmUxID0gdGhpcy5lMiA9IC0xO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBTdGFydCBuZXh0IHNlZ21lbnRcbiAgICAgICAgICAgIGlmIChuZXh0VmVydGV4KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGRDdXJyZW50VmVydGV4KGN1cnJlbnRWZXJ0ZXgsIHRoaXMuZGlzdGFuY2UsIG5leHROb3JtYWwsIC0xLCAtMSwgZmFsc2UpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH0gZWxzZSBpZiAoY3VycmVudEpvaW4gPT09ICdyb3VuZCcpIHtcblxuICAgICAgICAgICAgaWYgKCFzdGFydE9mTGluZSkge1xuICAgICAgICAgICAgICAgIC8vIENsb3NlIHByZXZpb3VzIHNlZ21lbnQgd2l0aCBidXR0XG4gICAgICAgICAgICAgICAgdGhpcy5hZGRDdXJyZW50VmVydGV4KGN1cnJlbnRWZXJ0ZXgsIHRoaXMuZGlzdGFuY2UsIHByZXZOb3JtYWwsIDAsIDAsIGZhbHNlKTtcblxuICAgICAgICAgICAgICAgIC8vIEFkZCByb3VuZCBjYXAgb3IgbGluZWpvaW4gYXQgZW5kIG9mIHNlZ21lbnRcbiAgICAgICAgICAgICAgICB0aGlzLmFkZEN1cnJlbnRWZXJ0ZXgoY3VycmVudFZlcnRleCwgdGhpcy5kaXN0YW5jZSwgcHJldk5vcm1hbCwgMSwgMSwgdHJ1ZSk7XG5cbiAgICAgICAgICAgICAgICAvLyBUaGUgc2VnbWVudCBpcyBkb25lLiBVbnNldCB2ZXJ0aWNlcyB0byBkaXNjb25uZWN0IHNlZ21lbnRzLlxuICAgICAgICAgICAgICAgIHRoaXMuZTEgPSB0aGlzLmUyID0gLTE7XG4gICAgICAgICAgICB9XG5cblxuICAgICAgICAgICAgLy8gU3RhcnQgbmV4dCBzZWdtZW50IHdpdGggYSBidXR0XG4gICAgICAgICAgICBpZiAobmV4dFZlcnRleCkge1xuICAgICAgICAgICAgICAgIC8vIEFkZCByb3VuZCBjYXAgYmVmb3JlIGZpcnN0IHNlZ21lbnRcbiAgICAgICAgICAgICAgICB0aGlzLmFkZEN1cnJlbnRWZXJ0ZXgoY3VycmVudFZlcnRleCwgdGhpcy5kaXN0YW5jZSwgbmV4dE5vcm1hbCwgLTEsIC0xLCB0cnVlKTtcblxuICAgICAgICAgICAgICAgIHRoaXMuYWRkQ3VycmVudFZlcnRleChjdXJyZW50VmVydGV4LCB0aGlzLmRpc3RhbmNlLCBuZXh0Tm9ybWFsLCAwLCAwLCBmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNTaGFycENvcm5lciAmJiBpIDwgbGVuIC0gMSkge1xuICAgICAgICAgICAgdmFyIG5leHRTZWdtZW50TGVuZ3RoID0gY3VycmVudFZlcnRleC5kaXN0KG5leHRWZXJ0ZXgpO1xuICAgICAgICAgICAgaWYgKG5leHRTZWdtZW50TGVuZ3RoID4gMiAqIHNoYXJwQ29ybmVyT2Zmc2V0KSB7XG4gICAgICAgICAgICAgICAgdmFyIG5ld0N1cnJlbnRWZXJ0ZXggPSBjdXJyZW50VmVydGV4LmFkZChuZXh0VmVydGV4LnN1YihjdXJyZW50VmVydGV4KS5fbXVsdChzaGFycENvcm5lck9mZnNldCAvIG5leHRTZWdtZW50TGVuZ3RoKS5fcm91bmQoKSk7XG4gICAgICAgICAgICAgICAgdGhpcy5kaXN0YW5jZSArPSBuZXdDdXJyZW50VmVydGV4LmRpc3QoY3VycmVudFZlcnRleCk7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGRDdXJyZW50VmVydGV4KG5ld0N1cnJlbnRWZXJ0ZXgsIHRoaXMuZGlzdGFuY2UsIG5leHROb3JtYWwubXVsdCgxKSwgMCwgMCwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIGN1cnJlbnRWZXJ0ZXggPSBuZXdDdXJyZW50VmVydGV4O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgc3RhcnRPZkxpbmUgPSBmYWxzZTtcbiAgICB9XG5cbn07XG5cbi8qKlxuICogQWRkIHR3byB2ZXJ0aWNlcyB0byB0aGUgYnVmZmVycy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gY3VycmVudFZlcnRleCB0aGUgbGluZSB2ZXJ0ZXggdG8gYWRkIGJ1ZmZlciB2ZXJ0aWNlcyBmb3JcbiAqIEBwYXJhbSB7bnVtYmVyfSBkaXN0YW5jZSB0aGUgZGlzdGFuY2UgZnJvbSB0aGUgYmVnaW5uaW5nIG9mIHRoZSBsaW5lIHRvIHRoZSB2ZXJ0ZXhcbiAqIEBwYXJhbSB7bnVtYmVyfSBlbmRMZWZ0IGV4dHJ1ZGUgdG8gc2hpZnQgdGhlIGxlZnQgdmVydGV4IGFsb25nIHRoZSBsaW5lXG4gKiBAcGFyYW0ge251bWJlcn0gZW5kUmlnaHQgZXh0cnVkZSB0byBzaGlmdCB0aGUgbGVmdCB2ZXJ0ZXggYWxvbmcgdGhlIGxpbmVcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gcm91bmQgd2hldGhlciB0aGlzIGlzIGEgcm91bmQgY2FwXG4gKiBAcHJpdmF0ZVxuICovXG5MaW5lQnVja2V0LnByb3RvdHlwZS5hZGRDdXJyZW50VmVydGV4ID0gZnVuY3Rpb24oY3VycmVudFZlcnRleCwgZGlzdGFuY2UsIG5vcm1hbCwgZW5kTGVmdCwgZW5kUmlnaHQsIHJvdW5kKSB7XG4gICAgdmFyIHR4ID0gcm91bmQgPyAxIDogMDtcbiAgICB2YXIgZXh0cnVkZTtcbiAgICB2YXIgZ3JvdXAgPSB0aGlzLmVsZW1lbnRHcm91cHMubGluZVt0aGlzLmVsZW1lbnRHcm91cHMubGluZS5sZW5ndGggLSAxXTtcbiAgICBncm91cC52ZXJ0ZXhMZW5ndGggKz0gMjtcblxuICAgIGV4dHJ1ZGUgPSBub3JtYWwuY2xvbmUoKTtcbiAgICBpZiAoZW5kTGVmdCkgZXh0cnVkZS5fc3ViKG5vcm1hbC5wZXJwKCkuX211bHQoZW5kTGVmdCkpO1xuICAgIHRoaXMuZTMgPSB0aGlzLmFkZExpbmVWZXJ0ZXgoY3VycmVudFZlcnRleCwgZXh0cnVkZSwgdHgsIDAsIGVuZExlZnQsIGRpc3RhbmNlKSAtIGdyb3VwLnZlcnRleFN0YXJ0SW5kZXg7XG4gICAgaWYgKHRoaXMuZTEgPj0gMCAmJiB0aGlzLmUyID49IDApIHtcbiAgICAgICAgdGhpcy5hZGRMaW5lRWxlbWVudCh0aGlzLmUxLCB0aGlzLmUyLCB0aGlzLmUzKTtcbiAgICAgICAgZ3JvdXAuZWxlbWVudExlbmd0aCsrO1xuICAgIH1cbiAgICB0aGlzLmUxID0gdGhpcy5lMjtcbiAgICB0aGlzLmUyID0gdGhpcy5lMztcblxuICAgIGV4dHJ1ZGUgPSBub3JtYWwubXVsdCgtMSk7XG4gICAgaWYgKGVuZFJpZ2h0KSBleHRydWRlLl9zdWIobm9ybWFsLnBlcnAoKS5fbXVsdChlbmRSaWdodCkpO1xuICAgIHRoaXMuZTMgPSB0aGlzLmFkZExpbmVWZXJ0ZXgoY3VycmVudFZlcnRleCwgZXh0cnVkZSwgdHgsIDEsIC1lbmRSaWdodCwgZGlzdGFuY2UpIC0gZ3JvdXAudmVydGV4U3RhcnRJbmRleDtcbiAgICBpZiAodGhpcy5lMSA+PSAwICYmIHRoaXMuZTIgPj0gMCkge1xuICAgICAgICB0aGlzLmFkZExpbmVFbGVtZW50KHRoaXMuZTEsIHRoaXMuZTIsIHRoaXMuZTMpO1xuICAgICAgICBncm91cC5lbGVtZW50TGVuZ3RoKys7XG4gICAgfVxuICAgIHRoaXMuZTEgPSB0aGlzLmUyO1xuICAgIHRoaXMuZTIgPSB0aGlzLmUzO1xuXG4gICAgLy8gVGhlcmUgaXMgYSBtYXhpbXVtIFwiZGlzdGFuY2UgYWxvbmcgdGhlIGxpbmVcIiB0aGF0IHdlIGNhbiBzdG9yZSBpbiB0aGUgYnVmZmVycy5cbiAgICAvLyBXaGVuIHdlIGdldCBjbG9zZSB0byB0aGUgZGlzdGFuY2UsIHJlc2V0IGl0IHRvIHplcm8gYW5kIGFkZCB0aGUgdmVydGV4IGFnYWluIHdpdGhcbiAgICAvLyBhIGRpc3RhbmNlIG9mIHplcm8uIFRoZSBtYXggZGlzdGFuY2UgaXMgZGV0ZXJtaW5lZCBieSB0aGUgbnVtYmVyIG9mIGJpdHMgd2UgYWxsb2NhdGVcbiAgICAvLyB0byBgbGluZXNvZmFyYC5cbiAgICBpZiAoZGlzdGFuY2UgPiBNQVhfTElORV9ESVNUQU5DRSAvIDIpIHtcbiAgICAgICAgdGhpcy5kaXN0YW5jZSA9IDA7XG4gICAgICAgIHRoaXMuYWRkQ3VycmVudFZlcnRleChjdXJyZW50VmVydGV4LCB0aGlzLmRpc3RhbmNlLCBub3JtYWwsIGVuZExlZnQsIGVuZFJpZ2h0LCByb3VuZCk7XG4gICAgfVxufTtcblxuLyoqXG4gKiBBZGQgYSBzaW5nbGUgbmV3IHZlcnRleCBhbmQgYSB0cmlhbmdsZSB1c2luZyB0d28gcHJldmlvdXMgdmVydGljZXMuXG4gKiBUaGlzIGFkZHMgYSBwaWUgc2xpY2UgdHJpYW5nbGUgbmVhciBhIGpvaW4gdG8gc2ltdWxhdGUgcm91bmQgam9pbnNcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gY3VycmVudFZlcnRleCB0aGUgbGluZSB2ZXJ0ZXggdG8gYWRkIGJ1ZmZlciB2ZXJ0aWNlcyBmb3JcbiAqIEBwYXJhbSB7bnVtYmVyfSBkaXN0YW5jZSB0aGUgZGlzdGFuY2UgZnJvbSB0aGUgYmVnZ2luaW5nIG9mIHRoZSBsaW5lIHRvIHRoZSB2ZXJ0ZXhcbiAqIEBwYXJhbSB7T2JqZWN0fSBleHRydWRlIHRoZSBvZmZzZXQgb2YgdGhlIG5ldyB2ZXJ0ZXggZnJvbSB0aGUgY3VycmVudFZlcnRleFxuICogQHBhcmFtIHtib29sZWFufSB3aGV0aGVyIHRoZSBsaW5lIGlzIHR1cm5pbmcgbGVmdCBvciByaWdodCBhdCB0aGlzIGFuZ2xlXG4gKiBAcHJpdmF0ZVxuICovXG5MaW5lQnVja2V0LnByb3RvdHlwZS5hZGRQaWVTbGljZVZlcnRleCA9IGZ1bmN0aW9uKGN1cnJlbnRWZXJ0ZXgsIGRpc3RhbmNlLCBleHRydWRlLCBsaW5lVHVybnNMZWZ0KSB7XG4gICAgdmFyIHR5ID0gbGluZVR1cm5zTGVmdCA/IDEgOiAwO1xuICAgIGV4dHJ1ZGUgPSBleHRydWRlLm11bHQobGluZVR1cm5zTGVmdCA/IC0xIDogMSk7XG4gICAgdmFyIGdyb3VwID0gdGhpcy5lbGVtZW50R3JvdXBzLmxpbmVbdGhpcy5lbGVtZW50R3JvdXBzLmxpbmUubGVuZ3RoIC0gMV07XG5cbiAgICB0aGlzLmUzID0gdGhpcy5hZGRMaW5lVmVydGV4KGN1cnJlbnRWZXJ0ZXgsIGV4dHJ1ZGUsIDAsIHR5LCAwLCBkaXN0YW5jZSkgLSBncm91cC52ZXJ0ZXhTdGFydEluZGV4O1xuICAgIGdyb3VwLnZlcnRleExlbmd0aCsrO1xuXG4gICAgaWYgKHRoaXMuZTEgPj0gMCAmJiB0aGlzLmUyID49IDApIHtcbiAgICAgICAgdGhpcy5hZGRMaW5lRWxlbWVudCh0aGlzLmUxLCB0aGlzLmUyLCB0aGlzLmUzKTtcbiAgICAgICAgZ3JvdXAuZWxlbWVudExlbmd0aCsrO1xuICAgIH1cblxuICAgIGlmIChsaW5lVHVybnNMZWZ0KSB7XG4gICAgICAgIHRoaXMuZTIgPSB0aGlzLmUzO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZTEgPSB0aGlzLmUzO1xuICAgIH1cbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBQb2ludCA9IHJlcXVpcmUoJ3BvaW50LWdlb21ldHJ5Jyk7XG5cbnZhciBCdWNrZXQgPSByZXF1aXJlKCcuLi9idWNrZXQnKTtcbnZhciBBbmNob3IgPSByZXF1aXJlKCcuLi8uLi9zeW1ib2wvYW5jaG9yJyk7XG52YXIgZ2V0QW5jaG9ycyA9IHJlcXVpcmUoJy4uLy4uL3N5bWJvbC9nZXRfYW5jaG9ycycpO1xudmFyIHJlc29sdmVUb2tlbnMgPSByZXF1aXJlKCcuLi8uLi91dGlsL3Rva2VuJyk7XG52YXIgUXVhZHMgPSByZXF1aXJlKCcuLi8uLi9zeW1ib2wvcXVhZHMnKTtcbnZhciBTaGFwaW5nID0gcmVxdWlyZSgnLi4vLi4vc3ltYm9sL3NoYXBpbmcnKTtcbnZhciByZXNvbHZlVGV4dCA9IHJlcXVpcmUoJy4uLy4uL3N5bWJvbC9yZXNvbHZlX3RleHQnKTtcbnZhciBtZXJnZUxpbmVzID0gcmVxdWlyZSgnLi4vLi4vc3ltYm9sL21lcmdlbGluZXMnKTtcbnZhciBjbGlwTGluZSA9IHJlcXVpcmUoJy4uLy4uL3N5bWJvbC9jbGlwX2xpbmUnKTtcbnZhciB1dGlsID0gcmVxdWlyZSgnLi4vLi4vdXRpbC91dGlsJyk7XG52YXIgbG9hZEdlb21ldHJ5ID0gcmVxdWlyZSgnLi4vbG9hZF9nZW9tZXRyeScpO1xudmFyIENvbGxpc2lvbkZlYXR1cmUgPSByZXF1aXJlKCcuLi8uLi9zeW1ib2wvY29sbGlzaW9uX2ZlYXR1cmUnKTtcblxudmFyIHNoYXBlVGV4dCA9IFNoYXBpbmcuc2hhcGVUZXh0O1xudmFyIHNoYXBlSWNvbiA9IFNoYXBpbmcuc2hhcGVJY29uO1xudmFyIGdldEdseXBoUXVhZHMgPSBRdWFkcy5nZXRHbHlwaFF1YWRzO1xudmFyIGdldEljb25RdWFkcyA9IFF1YWRzLmdldEljb25RdWFkcztcblxudmFyIEVYVEVOVCA9IEJ1Y2tldC5FWFRFTlQ7XG5cbm1vZHVsZS5leHBvcnRzID0gU3ltYm9sQnVja2V0O1xuXG5mdW5jdGlvbiBTeW1ib2xCdWNrZXQob3B0aW9ucykge1xuICAgIEJ1Y2tldC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIHRoaXMuc2hvd0NvbGxpc2lvbkJveGVzID0gb3B0aW9ucy5zaG93Q29sbGlzaW9uQm94ZXM7XG4gICAgdGhpcy5vdmVyc2NhbGluZyA9IG9wdGlvbnMub3ZlcnNjYWxpbmc7XG4gICAgdGhpcy5jb2xsaXNpb25Cb3hBcnJheSA9IG9wdGlvbnMuY29sbGlzaW9uQm94QXJyYXk7XG59XG5cblN5bWJvbEJ1Y2tldC5wcm90b3R5cGUgPSB1dGlsLmluaGVyaXQoQnVja2V0LCB7fSk7XG5cbnZhciBzaGFkZXJBdHRyaWJ1dGVBcmdzID0gWyd4JywgJ3knLCAnb3gnLCAnb3knLCAndHgnLCAndHknLCAnbWluem9vbScsICdtYXh6b29tJywgJ2xhYmVsbWluem9vbSddO1xuXG52YXIgc2hhZGVyQXR0cmlidXRlcyA9IFt7XG4gICAgbmFtZTogJ3BvcycsXG4gICAgY29tcG9uZW50czogMixcbiAgICB0eXBlOiAnSW50MTYnLFxuICAgIHZhbHVlOiBbJ3gnLCAneSddXG59LCB7XG4gICAgbmFtZTogJ29mZnNldCcsXG4gICAgY29tcG9uZW50czogMixcbiAgICB0eXBlOiAnSW50MTYnLFxuICAgIHZhbHVlOiBbXG4gICAgICAgICdNYXRoLnJvdW5kKG94ICogNjQpJywgLy8gdXNlIDEvNjQgcGl4ZWxzIGZvciBwbGFjZW1lbnRcbiAgICAgICAgJ01hdGgucm91bmQob3kgKiA2NCknXG4gICAgXVxufSwge1xuICAgIG5hbWU6ICdkYXRhMScsXG4gICAgY29tcG9uZW50czogNCxcbiAgICB0eXBlOiAnVWludDgnLFxuICAgIHZhbHVlOiBbXG4gICAgICAgICd0eCAvIDQnLCAgICAgICAgICAgICAgICAgICAvLyB0ZXhcbiAgICAgICAgJ3R5IC8gNCcsICAgICAgICAgICAgICAgICAgIC8vIHRleFxuICAgICAgICAnKGxhYmVsbWluem9vbSB8fCAwKSAqIDEwJywgLy8gbGFiZWxtaW56b29tXG4gICAgICAgICcwJ1xuICAgIF1cbn0sIHtcbiAgICBuYW1lOiAnZGF0YTInLFxuICAgIGNvbXBvbmVudHM6IDIsXG4gICAgdHlwZTogJ1VpbnQ4JyxcbiAgICB2YWx1ZTogW1xuICAgICAgICAnKG1pbnpvb20gfHwgMCkgKiAxMCcsICAgICAgICAgICAgIC8vIG1pbnpvb21cbiAgICAgICAgJ01hdGgubWluKG1heHpvb20gfHwgMjUsIDI1KSAqIDEwJyAvLyBtaW56b29tXG4gICAgXVxufV07XG5cblN5bWJvbEJ1Y2tldC5wcm90b3R5cGUuc2hhZGVySW50ZXJmYWNlcyA9IHtcblxuICAgIGdseXBoOiB7XG4gICAgICAgIHZlcnRleEJ1ZmZlcjogdHJ1ZSxcbiAgICAgICAgZWxlbWVudEJ1ZmZlcjogdHJ1ZSxcbiAgICAgICAgYXR0cmlidXRlQXJnczogc2hhZGVyQXR0cmlidXRlQXJncyxcbiAgICAgICAgYXR0cmlidXRlczogc2hhZGVyQXR0cmlidXRlc1xuICAgIH0sXG5cbiAgICBpY29uOiB7XG4gICAgICAgIHZlcnRleEJ1ZmZlcjogdHJ1ZSxcbiAgICAgICAgZWxlbWVudEJ1ZmZlcjogdHJ1ZSxcbiAgICAgICAgYXR0cmlidXRlQXJnczogc2hhZGVyQXR0cmlidXRlQXJncyxcbiAgICAgICAgYXR0cmlidXRlczogc2hhZGVyQXR0cmlidXRlc1xuICAgIH0sXG5cbiAgICBjb2xsaXNpb25Cb3g6IHtcbiAgICAgICAgdmVydGV4QnVmZmVyOiB0cnVlLFxuXG4gICAgICAgIGF0dHJpYnV0ZUFyZ3M6IFsncG9pbnQnLCAnZXh0cnVkZScsICdtYXhab29tJywgJ3BsYWNlbWVudFpvb20nXSxcblxuICAgICAgICBhdHRyaWJ1dGVzOiBbe1xuICAgICAgICAgICAgbmFtZTogJ3BvcycsXG4gICAgICAgICAgICBjb21wb25lbnRzOiAyLFxuICAgICAgICAgICAgdHlwZTogJ0ludDE2JyxcbiAgICAgICAgICAgIHZhbHVlOiBbICdwb2ludC54JywgJ3BvaW50LnknIF1cbiAgICAgICAgfSwge1xuICAgICAgICAgICAgbmFtZTogJ2V4dHJ1ZGUnLFxuICAgICAgICAgICAgY29tcG9uZW50czogMixcbiAgICAgICAgICAgIHR5cGU6ICdJbnQxNicsXG4gICAgICAgICAgICB2YWx1ZTogW1xuICAgICAgICAgICAgICAgICdNYXRoLnJvdW5kKGV4dHJ1ZGUueCknLFxuICAgICAgICAgICAgICAgICdNYXRoLnJvdW5kKGV4dHJ1ZGUueSknXG4gICAgICAgICAgICBdXG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIG5hbWU6ICdkYXRhJyxcbiAgICAgICAgICAgIGNvbXBvbmVudHM6IDIsXG4gICAgICAgICAgICB0eXBlOiAnVWludDgnLFxuICAgICAgICAgICAgdmFsdWU6IFtcbiAgICAgICAgICAgICAgICAnbWF4Wm9vbSAqIDEwJyxcbiAgICAgICAgICAgICAgICAncGxhY2VtZW50Wm9vbSAqIDEwJ1xuICAgICAgICAgICAgXVxuICAgICAgICB9XVxuICAgIH1cbn07XG5cblN5bWJvbEJ1Y2tldC5wcm90b3R5cGUucG9wdWxhdGVCdWZmZXJzID0gZnVuY3Rpb24oY29sbGlzaW9uVGlsZSwgc3RhY2tzLCBpY29ucykge1xuICAgIHRoaXMuY3JlYXRlU3R5bGVMYXllcigpO1xuXG4gICAgLy8gVG8gcmVkdWNlIHRoZSBudW1iZXIgb2YgbGFiZWxzIHRoYXQganVtcCBhcm91bmQgd2hlbiB6b29taW5nIHdlIG5lZWRcbiAgICAvLyB0byB1c2UgYSB0ZXh0LXNpemUgdmFsdWUgdGhhdCBpcyB0aGUgc2FtZSBmb3IgYWxsIHpvb20gbGV2ZWxzLlxuICAgIC8vIFRoaXMgY2FsY3VsYXRlcyB0ZXh0LXNpemUgYXQgYSBoaWdoIHpvb20gbGV2ZWwgc28gdGhhdCBhbGwgdGlsZXMgY2FuXG4gICAgLy8gdXNlIHRoZSBzYW1lIHZhbHVlIHdoZW4gY2FsY3VsYXRpbmcgYW5jaG9yIHBvc2l0aW9ucy5cbiAgICB2YXIgem9vbUhpc3RvcnkgPSB7IGxhc3RJbnRlZ2VyWm9vbTogSW5maW5pdHksIGxhc3RJbnRlZ2VyWm9vbVRpbWU6IDAsIGxhc3Rab29tOiAwIH07XG4gICAgdGhpcy5hZGp1c3RlZFRleHRNYXhTaXplID0gdGhpcy5sYXllci5nZXRMYXlvdXRWYWx1ZSgndGV4dC1zaXplJywgMTgsIHpvb21IaXN0b3J5KTtcbiAgICB0aGlzLmFkanVzdGVkVGV4dFNpemUgPSB0aGlzLmxheWVyLmdldExheW91dFZhbHVlKCd0ZXh0LXNpemUnLCB0aGlzLnpvb20gKyAxLCB6b29tSGlzdG9yeSk7XG4gICAgdGhpcy5hZGp1c3RlZEljb25NYXhTaXplID0gdGhpcy5sYXllci5nZXRMYXlvdXRWYWx1ZSgnaWNvbi1zaXplJywgMTgsIHpvb21IaXN0b3J5KTtcbiAgICB0aGlzLmFkanVzdGVkSWNvblNpemUgPSB0aGlzLmxheWVyLmdldExheW91dFZhbHVlKCdpY29uLXNpemUnLCB0aGlzLnpvb20gKyAxLCB6b29tSGlzdG9yeSk7XG5cbiAgICB2YXIgdGlsZVNpemUgPSA1MTIgKiB0aGlzLm92ZXJzY2FsaW5nO1xuICAgIHRoaXMudGlsZVBpeGVsUmF0aW8gPSBFWFRFTlQgLyB0aWxlU2l6ZTtcbiAgICB0aGlzLmNvbXBhcmVUZXh0ID0ge307XG4gICAgdGhpcy5zeW1ib2xJbnN0YW5jZXMgPSBbXTtcbiAgICB0aGlzLmljb25zTmVlZExpbmVhciA9IGZhbHNlO1xuXG4gICAgdmFyIGxheW91dCA9IHRoaXMubGF5ZXIubGF5b3V0O1xuICAgIHZhciBmZWF0dXJlcyA9IHRoaXMuZmVhdHVyZXM7XG4gICAgdmFyIHRleHRGZWF0dXJlcyA9IHRoaXMudGV4dEZlYXR1cmVzO1xuXG4gICAgdmFyIGhvcml6b250YWxBbGlnbiA9IDAuNSxcbiAgICAgICAgdmVydGljYWxBbGlnbiA9IDAuNTtcblxuICAgIHN3aXRjaCAobGF5b3V0Wyd0ZXh0LWFuY2hvciddKSB7XG4gICAgY2FzZSAncmlnaHQnOlxuICAgIGNhc2UgJ3RvcC1yaWdodCc6XG4gICAgY2FzZSAnYm90dG9tLXJpZ2h0JzpcbiAgICAgICAgaG9yaXpvbnRhbEFsaWduID0gMTtcbiAgICAgICAgYnJlYWs7XG4gICAgY2FzZSAnbGVmdCc6XG4gICAgY2FzZSAndG9wLWxlZnQnOlxuICAgIGNhc2UgJ2JvdHRvbS1sZWZ0JzpcbiAgICAgICAgaG9yaXpvbnRhbEFsaWduID0gMDtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgc3dpdGNoIChsYXlvdXRbJ3RleHQtYW5jaG9yJ10pIHtcbiAgICBjYXNlICdib3R0b20nOlxuICAgIGNhc2UgJ2JvdHRvbS1yaWdodCc6XG4gICAgY2FzZSAnYm90dG9tLWxlZnQnOlxuICAgICAgICB2ZXJ0aWNhbEFsaWduID0gMTtcbiAgICAgICAgYnJlYWs7XG4gICAgY2FzZSAndG9wJzpcbiAgICBjYXNlICd0b3AtcmlnaHQnOlxuICAgIGNhc2UgJ3RvcC1sZWZ0JzpcbiAgICAgICAgdmVydGljYWxBbGlnbiA9IDA7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIHZhciBqdXN0aWZ5ID0gbGF5b3V0Wyd0ZXh0LWp1c3RpZnknXSA9PT0gJ3JpZ2h0JyA/IDEgOlxuICAgICAgICBsYXlvdXRbJ3RleHQtanVzdGlmeSddID09PSAnbGVmdCcgPyAwIDpcbiAgICAgICAgMC41O1xuXG4gICAgdmFyIG9uZUVtID0gMjQ7XG4gICAgdmFyIGxpbmVIZWlnaHQgPSBsYXlvdXRbJ3RleHQtbGluZS1oZWlnaHQnXSAqIG9uZUVtO1xuICAgIHZhciBtYXhXaWR0aCA9IGxheW91dFsnc3ltYm9sLXBsYWNlbWVudCddICE9PSAnbGluZScgPyBsYXlvdXRbJ3RleHQtbWF4LXdpZHRoJ10gKiBvbmVFbSA6IDA7XG4gICAgdmFyIHNwYWNpbmcgPSBsYXlvdXRbJ3RleHQtbGV0dGVyLXNwYWNpbmcnXSAqIG9uZUVtO1xuICAgIHZhciB0ZXh0T2Zmc2V0ID0gW2xheW91dFsndGV4dC1vZmZzZXQnXVswXSAqIG9uZUVtLCBsYXlvdXRbJ3RleHQtb2Zmc2V0J11bMV0gKiBvbmVFbV07XG4gICAgdmFyIGZvbnRzdGFjayA9IGxheW91dFsndGV4dC1mb250J10uam9pbignLCcpO1xuXG4gICAgdmFyIGdlb21ldHJpZXMgPSBbXTtcbiAgICBmb3IgKHZhciBnID0gMDsgZyA8IGZlYXR1cmVzLmxlbmd0aDsgZysrKSB7XG4gICAgICAgIGdlb21ldHJpZXMucHVzaChsb2FkR2VvbWV0cnkoZmVhdHVyZXNbZ10pKTtcbiAgICB9XG5cbiAgICBpZiAobGF5b3V0WydzeW1ib2wtcGxhY2VtZW50J10gPT09ICdsaW5lJykge1xuICAgICAgICAvLyBNZXJnZSBhZGphY2VudCBsaW5lcyB3aXRoIHRoZSBzYW1lIHRleHQgdG8gaW1wcm92ZSBsYWJlbGxpbmcuXG4gICAgICAgIC8vIEl0J3MgYmV0dGVyIHRvIHBsYWNlIGxhYmVscyBvbiBvbmUgbG9uZyBsaW5lIHRoYW4gb24gbWFueSBzaG9ydCBzZWdtZW50cy5cbiAgICAgICAgdmFyIG1lcmdlZCA9IG1lcmdlTGluZXMoZmVhdHVyZXMsIHRleHRGZWF0dXJlcywgZ2VvbWV0cmllcyk7XG5cbiAgICAgICAgZ2VvbWV0cmllcyA9IG1lcmdlZC5nZW9tZXRyaWVzO1xuICAgICAgICBmZWF0dXJlcyA9IG1lcmdlZC5mZWF0dXJlcztcbiAgICAgICAgdGV4dEZlYXR1cmVzID0gbWVyZ2VkLnRleHRGZWF0dXJlcztcbiAgICB9XG5cbiAgICB2YXIgc2hhcGVkVGV4dCwgc2hhcGVkSWNvbjtcblxuICAgIGZvciAodmFyIGsgPSAwOyBrIDwgZmVhdHVyZXMubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgaWYgKCFnZW9tZXRyaWVzW2tdKSBjb250aW51ZTtcblxuICAgICAgICBpZiAodGV4dEZlYXR1cmVzW2tdKSB7XG4gICAgICAgICAgICBzaGFwZWRUZXh0ID0gc2hhcGVUZXh0KHRleHRGZWF0dXJlc1trXSwgc3RhY2tzW2ZvbnRzdGFja10sIG1heFdpZHRoLFxuICAgICAgICAgICAgICAgICAgICBsaW5lSGVpZ2h0LCBob3Jpem9udGFsQWxpZ24sIHZlcnRpY2FsQWxpZ24sIGp1c3RpZnksIHNwYWNpbmcsIHRleHRPZmZzZXQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2hhcGVkVGV4dCA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobGF5b3V0WydpY29uLWltYWdlJ10pIHtcbiAgICAgICAgICAgIHZhciBpY29uTmFtZSA9IHJlc29sdmVUb2tlbnMoZmVhdHVyZXNba10ucHJvcGVydGllcywgbGF5b3V0WydpY29uLWltYWdlJ10pO1xuICAgICAgICAgICAgdmFyIGltYWdlID0gaWNvbnNbaWNvbk5hbWVdO1xuICAgICAgICAgICAgc2hhcGVkSWNvbiA9IHNoYXBlSWNvbihpbWFnZSwgbGF5b3V0KTtcblxuICAgICAgICAgICAgaWYgKGltYWdlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc2RmSWNvbnMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNkZkljb25zID0gaW1hZ2Uuc2RmO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5zZGZJY29ucyAhPT0gaW1hZ2Uuc2RmKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignU3R5bGUgc2hlZXQgd2FybmluZzogQ2Fubm90IG1peCBTREYgYW5kIG5vbi1TREYgaWNvbnMgaW4gb25lIGJ1ZmZlcicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaW1hZ2UucGl4ZWxSYXRpbyAhPT0gMSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmljb25zTmVlZExpbmVhciA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2hhcGVkSWNvbiA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc2hhcGVkVGV4dCB8fCBzaGFwZWRJY29uKSB7XG4gICAgICAgICAgICB0aGlzLmFkZEZlYXR1cmUoZ2VvbWV0cmllc1trXSwgc2hhcGVkVGV4dCwgc2hhcGVkSWNvbiwgZmVhdHVyZXNba10uaW5kZXgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5wbGFjZUZlYXR1cmVzKGNvbGxpc2lvblRpbGUsIHRoaXMuc2hvd0NvbGxpc2lvbkJveGVzKTtcblxuICAgIHRoaXMudHJpbUFycmF5cygpO1xufTtcblxuU3ltYm9sQnVja2V0LnByb3RvdHlwZS5hZGRGZWF0dXJlID0gZnVuY3Rpb24obGluZXMsIHNoYXBlZFRleHQsIHNoYXBlZEljb24sIGZlYXR1cmVJbmRleCkge1xuICAgIHZhciBsYXlvdXQgPSB0aGlzLmxheWVyLmxheW91dDtcblxuICAgIHZhciBnbHlwaFNpemUgPSAyNDtcblxuICAgIHZhciBmb250U2NhbGUgPSB0aGlzLmFkanVzdGVkVGV4dFNpemUgLyBnbHlwaFNpemUsXG4gICAgICAgIHRleHRNYXhTaXplID0gdGhpcy5hZGp1c3RlZFRleHRNYXhTaXplICE9PSB1bmRlZmluZWQgPyB0aGlzLmFkanVzdGVkVGV4dE1heFNpemUgOiB0aGlzLmFkanVzdGVkVGV4dFNpemUsXG4gICAgICAgIHRleHRCb3hTY2FsZSA9IHRoaXMudGlsZVBpeGVsUmF0aW8gKiBmb250U2NhbGUsXG4gICAgICAgIHRleHRNYXhCb3hTY2FsZSA9IHRoaXMudGlsZVBpeGVsUmF0aW8gKiB0ZXh0TWF4U2l6ZSAvIGdseXBoU2l6ZSxcbiAgICAgICAgaWNvbkJveFNjYWxlID0gdGhpcy50aWxlUGl4ZWxSYXRpbyAqIHRoaXMuYWRqdXN0ZWRJY29uU2l6ZSxcbiAgICAgICAgc3ltYm9sTWluRGlzdGFuY2UgPSB0aGlzLnRpbGVQaXhlbFJhdGlvICogbGF5b3V0WydzeW1ib2wtc3BhY2luZyddLFxuICAgICAgICBhdm9pZEVkZ2VzID0gbGF5b3V0WydzeW1ib2wtYXZvaWQtZWRnZXMnXSxcbiAgICAgICAgdGV4dFBhZGRpbmcgPSBsYXlvdXRbJ3RleHQtcGFkZGluZyddICogdGhpcy50aWxlUGl4ZWxSYXRpbyxcbiAgICAgICAgaWNvblBhZGRpbmcgPSBsYXlvdXRbJ2ljb24tcGFkZGluZyddICogdGhpcy50aWxlUGl4ZWxSYXRpbyxcbiAgICAgICAgdGV4dE1heEFuZ2xlID0gbGF5b3V0Wyd0ZXh0LW1heC1hbmdsZSddIC8gMTgwICogTWF0aC5QSSxcbiAgICAgICAgdGV4dEFsb25nTGluZSA9IGxheW91dFsndGV4dC1yb3RhdGlvbi1hbGlnbm1lbnQnXSA9PT0gJ21hcCcgJiYgbGF5b3V0WydzeW1ib2wtcGxhY2VtZW50J10gPT09ICdsaW5lJyxcbiAgICAgICAgaWNvbkFsb25nTGluZSA9IGxheW91dFsnaWNvbi1yb3RhdGlvbi1hbGlnbm1lbnQnXSA9PT0gJ21hcCcgJiYgbGF5b3V0WydzeW1ib2wtcGxhY2VtZW50J10gPT09ICdsaW5lJyxcbiAgICAgICAgbWF5T3ZlcmxhcCA9IGxheW91dFsndGV4dC1hbGxvdy1vdmVybGFwJ10gfHwgbGF5b3V0WydpY29uLWFsbG93LW92ZXJsYXAnXSB8fFxuICAgICAgICAgICAgbGF5b3V0Wyd0ZXh0LWlnbm9yZS1wbGFjZW1lbnQnXSB8fCBsYXlvdXRbJ2ljb24taWdub3JlLXBsYWNlbWVudCddLFxuICAgICAgICBpc0xpbmUgPSBsYXlvdXRbJ3N5bWJvbC1wbGFjZW1lbnQnXSA9PT0gJ2xpbmUnLFxuICAgICAgICB0ZXh0UmVwZWF0RGlzdGFuY2UgPSBzeW1ib2xNaW5EaXN0YW5jZSAvIDI7XG5cbiAgICBpZiAoaXNMaW5lKSB7XG4gICAgICAgIGxpbmVzID0gY2xpcExpbmUobGluZXMsIDAsIDAsIEVYVEVOVCwgRVhURU5UKTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpbmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBsaW5lID0gbGluZXNbaV07XG5cbiAgICAgICAgLy8gQ2FsY3VsYXRlIHRoZSBhbmNob3IgcG9pbnRzIGFyb3VuZCB3aGljaCB5b3Ugd2FudCB0byBwbGFjZSBsYWJlbHNcbiAgICAgICAgdmFyIGFuY2hvcnM7XG4gICAgICAgIGlmIChpc0xpbmUpIHtcbiAgICAgICAgICAgIGFuY2hvcnMgPSBnZXRBbmNob3JzKFxuICAgICAgICAgICAgICAgIGxpbmUsXG4gICAgICAgICAgICAgICAgc3ltYm9sTWluRGlzdGFuY2UsXG4gICAgICAgICAgICAgICAgdGV4dE1heEFuZ2xlLFxuICAgICAgICAgICAgICAgIHNoYXBlZFRleHQsXG4gICAgICAgICAgICAgICAgc2hhcGVkSWNvbixcbiAgICAgICAgICAgICAgICBnbHlwaFNpemUsXG4gICAgICAgICAgICAgICAgdGV4dE1heEJveFNjYWxlLFxuICAgICAgICAgICAgICAgIHRoaXMub3ZlcnNjYWxpbmcsXG4gICAgICAgICAgICAgICAgRVhURU5UXG4gICAgICAgICAgICApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYW5jaG9ycyA9IFsgbmV3IEFuY2hvcihsaW5lWzBdLngsIGxpbmVbMF0ueSwgMCkgXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEZvciBlYWNoIHBvdGVudGlhbCBsYWJlbCwgY3JlYXRlIHRoZSBwbGFjZW1lbnQgZmVhdHVyZXMgdXNlZCB0byBjaGVjayBmb3IgY29sbGlzaW9ucywgYW5kIHRoZSBxdWFkcyB1c2UgZm9yIHJlbmRlcmluZy5cbiAgICAgICAgZm9yICh2YXIgaiA9IDAsIGxlbiA9IGFuY2hvcnMubGVuZ3RoOyBqIDwgbGVuOyBqKyspIHtcbiAgICAgICAgICAgIHZhciBhbmNob3IgPSBhbmNob3JzW2pdO1xuXG4gICAgICAgICAgICBpZiAoc2hhcGVkVGV4dCAmJiBpc0xpbmUpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5hbmNob3JJc1Rvb0Nsb3NlKHNoYXBlZFRleHQudGV4dCwgdGV4dFJlcGVhdERpc3RhbmNlLCBhbmNob3IpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGluc2lkZSA9ICEoYW5jaG9yLnggPCAwIHx8IGFuY2hvci54ID4gRVhURU5UIHx8IGFuY2hvci55IDwgMCB8fCBhbmNob3IueSA+IEVYVEVOVCk7XG5cbiAgICAgICAgICAgIGlmIChhdm9pZEVkZ2VzICYmICFpbnNpZGUpIGNvbnRpbnVlO1xuXG4gICAgICAgICAgICAvLyBOb3JtYWxseSBzeW1ib2wgbGF5ZXJzIGFyZSBkcmF3biBhY3Jvc3MgdGlsZSBib3VuZGFyaWVzLiBPbmx5IHN5bWJvbHNcbiAgICAgICAgICAgIC8vIHdpdGggdGhlaXIgYW5jaG9ycyB3aXRoaW4gdGhlIHRpbGUgYm91bmRhcmllcyBhcmUgYWRkZWQgdG8gdGhlIGJ1ZmZlcnNcbiAgICAgICAgICAgIC8vIHRvIHByZXZlbnQgc3ltYm9scyBmcm9tIGJlaW5nIGRyYXduIHR3aWNlLlxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIFN5bWJvbHMgaW4gbGF5ZXJzIHdpdGggb3ZlcmxhcCBhcmUgc29ydGVkIGluIHRoZSB5IGRpcmVjdGlvbiBzbyB0aGF0XG4gICAgICAgICAgICAvLyBzeW1ib2xzIGxvd2VyIG9uIHRoZSBjYW52YXMgYXJlIGRyYXduIG9uIHRvcCBvZiBzeW1ib2xzIG5lYXIgdGhlIHRvcC5cbiAgICAgICAgICAgIC8vIFRvIHByZXNlcnZlIHRoaXMgb3JkZXIgYWNyb3NzIHRpbGUgYm91bmRhcmllcyB0aGVzZSBzeW1ib2xzIGNhbid0XG4gICAgICAgICAgICAvLyBiZSBkcmF3biBhY3Jvc3MgdGlsZSBib3VuZGFyaWVzLiBJbnN0ZWFkIHRoZXkgbmVlZCB0byBiZSBpbmNsdWRlZCBpblxuICAgICAgICAgICAgLy8gdGhlIGJ1ZmZlcnMgZm9yIGJvdGggdGlsZXMgYW5kIGNsaXBwZWQgdG8gdGlsZSBib3VuZGFyaWVzIGF0IGRyYXcgdGltZS5cbiAgICAgICAgICAgIHZhciBhZGRUb0J1ZmZlcnMgPSBpbnNpZGUgfHwgbWF5T3ZlcmxhcDtcblxuICAgICAgICAgICAgdGhpcy5zeW1ib2xJbnN0YW5jZXMucHVzaChuZXcgU3ltYm9sSW5zdGFuY2UoYW5jaG9yLCBsaW5lLCBzaGFwZWRUZXh0LCBzaGFwZWRJY29uLCBsYXlvdXQsXG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRUb0J1ZmZlcnMsIHRoaXMuc3ltYm9sSW5zdGFuY2VzLmxlbmd0aCwgdGhpcy5jb2xsaXNpb25Cb3hBcnJheSwgZmVhdHVyZUluZGV4LCB0aGlzLnNvdXJjZUxheWVySW5kZXgsIHRoaXMuaW5kZXgsXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0Qm94U2NhbGUsIHRleHRQYWRkaW5nLCB0ZXh0QWxvbmdMaW5lLFxuICAgICAgICAgICAgICAgICAgICAgICAgaWNvbkJveFNjYWxlLCBpY29uUGFkZGluZywgaWNvbkFsb25nTGluZSkpO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuU3ltYm9sQnVja2V0LnByb3RvdHlwZS5hbmNob3JJc1Rvb0Nsb3NlID0gZnVuY3Rpb24odGV4dCwgcmVwZWF0RGlzdGFuY2UsIGFuY2hvcikge1xuICAgIHZhciBjb21wYXJlVGV4dCA9IHRoaXMuY29tcGFyZVRleHQ7XG4gICAgaWYgKCEodGV4dCBpbiBjb21wYXJlVGV4dCkpIHtcbiAgICAgICAgY29tcGFyZVRleHRbdGV4dF0gPSBbXTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgb3RoZXJBbmNob3JzID0gY29tcGFyZVRleHRbdGV4dF07XG4gICAgICAgIGZvciAodmFyIGsgPSBvdGhlckFuY2hvcnMubGVuZ3RoIC0gMTsgayA+PSAwOyBrLS0pIHtcbiAgICAgICAgICAgIGlmIChhbmNob3IuZGlzdChvdGhlckFuY2hvcnNba10pIDwgcmVwZWF0RGlzdGFuY2UpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiBpdCdzIHdpdGhpbiByZXBlYXREaXN0YW5jZSBvZiBvbmUgYW5jaG9yLCBzdG9wIGxvb2tpbmdcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBJZiBhbmNob3IgaXMgbm90IHdpdGhpbiByZXBlYXREaXN0YW5jZSBvZiBhbnkgb3RoZXIgYW5jaG9yLCBhZGQgdG8gYXJyYXlcbiAgICBjb21wYXJlVGV4dFt0ZXh0XS5wdXNoKGFuY2hvcik7XG4gICAgcmV0dXJuIGZhbHNlO1xufTtcblxuU3ltYm9sQnVja2V0LnByb3RvdHlwZS5wbGFjZUZlYXR1cmVzID0gZnVuY3Rpb24oY29sbGlzaW9uVGlsZSwgc2hvd0NvbGxpc2lvbkJveGVzKSB7XG4gICAgLy8gQ2FsY3VsYXRlIHdoaWNoIGxhYmVscyBjYW4gYmUgc2hvd24gYW5kIHdoZW4gdGhleSBjYW4gYmUgc2hvd24gYW5kXG4gICAgLy8gY3JlYXRlIHRoZSBidWZlcnMgdXNlZCBmb3IgcmVuZGVyaW5nLlxuXG4gICAgdGhpcy5jcmVhdGVBcnJheXMoKTtcblxuICAgIHZhciBlbGVtZW50R3JvdXBzID0gdGhpcy5lbGVtZW50R3JvdXBzID0ge1xuICAgICAgICBnbHlwaDogW10sXG4gICAgICAgIGljb246IFtdLFxuICAgICAgICBzZGZJY29uczogdGhpcy5zZGZJY29ucyxcbiAgICAgICAgaWNvbnNOZWVkTGluZWFyOiB0aGlzLmljb25zTmVlZExpbmVhclxuICAgIH07XG5cbiAgICB2YXIgbGF5b3V0ID0gdGhpcy5sYXllci5sYXlvdXQ7XG4gICAgdmFyIG1heFNjYWxlID0gY29sbGlzaW9uVGlsZS5tYXhTY2FsZTtcblxuICAgIGVsZW1lbnRHcm91cHMuZ2x5cGguYWRqdXN0ZWRTaXplID0gdGhpcy5hZGp1c3RlZFRleHRTaXplO1xuICAgIGVsZW1lbnRHcm91cHMuaWNvbi5hZGp1c3RlZFNpemUgPSB0aGlzLmFkanVzdGVkSWNvblNpemU7XG5cbiAgICAvLyBUcmFuc2ZlciB0aGUgbmFtZSBvZiB0aGUgZm9uc3RhY2sgYmFjayB0byB0aGUgbWFpbiB0aHJlYWQgYWxvbmcgd2l0aCB0aGUgYnVmZmVycy5cbiAgICAvLyBUaGUgZHJhdyBmdW5jdGlvbiBuZWVkcyB0byBrbm93IHdoaWNoIGZvbnN0YWNrJ3MgZ2x5cGggYXRsYXMgdG8gYmluZCB3aGVuIHJlbmRlcmluZy5cbiAgICBlbGVtZW50R3JvdXBzLmdseXBoLmZvbnRzdGFjayA9IGxheW91dFsndGV4dC1mb250J10uam9pbignLCcpO1xuXG4gICAgdmFyIHRleHRBbG9uZ0xpbmUgPSBsYXlvdXRbJ3RleHQtcm90YXRpb24tYWxpZ25tZW50J10gPT09ICdtYXAnICYmIGxheW91dFsnc3ltYm9sLXBsYWNlbWVudCddID09PSAnbGluZSc7XG4gICAgdmFyIGljb25BbG9uZ0xpbmUgPSBsYXlvdXRbJ2ljb24tcm90YXRpb24tYWxpZ25tZW50J10gPT09ICdtYXAnICYmIGxheW91dFsnc3ltYm9sLXBsYWNlbWVudCddID09PSAnbGluZSc7XG5cbiAgICB2YXIgbWF5T3ZlcmxhcCA9IGxheW91dFsndGV4dC1hbGxvdy1vdmVybGFwJ10gfHwgbGF5b3V0WydpY29uLWFsbG93LW92ZXJsYXAnXSB8fFxuICAgICAgICBsYXlvdXRbJ3RleHQtaWdub3JlLXBsYWNlbWVudCddIHx8IGxheW91dFsnaWNvbi1pZ25vcmUtcGxhY2VtZW50J107XG5cbiAgICAvLyBTb3J0IHN5bWJvbHMgYnkgdGhlaXIgeSBwb3NpdGlvbiBvbiB0aGUgY2FudmFzIHNvIHRoYXQgdGhleSBsb3dlciBzeW1ib2xzXG4gICAgLy8gYXJlIGRyYXduIG9uIHRvcCBvZiBoaWdoZXIgc3ltYm9scy5cbiAgICAvLyBEb24ndCBzb3J0IHN5bWJvbHMgdGhhdCB3b24ndCBvdmVybGFwIGJlY2F1c2UgaXQgaXNuJ3QgbmVjZXNzYXJ5IGFuZFxuICAgIC8vIGJlY2F1c2UgaXQgY2F1c2VzIG1vcmUgbGFiZWxzIHRvIHBvcCBpbiBhbmQgb3V0IHdoZW4gcm90YXRpbmcuXG4gICAgaWYgKG1heU92ZXJsYXApIHtcbiAgICAgICAgdmFyIGFuZ2xlID0gY29sbGlzaW9uVGlsZS5hbmdsZTtcbiAgICAgICAgdmFyIHNpbiA9IE1hdGguc2luKGFuZ2xlKSxcbiAgICAgICAgICAgIGNvcyA9IE1hdGguY29zKGFuZ2xlKTtcblxuICAgICAgICB0aGlzLnN5bWJvbEluc3RhbmNlcy5zb3J0KGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgICAgICAgIHZhciBhUm90YXRlZCA9IChzaW4gKiBhLnggKyBjb3MgKiBhLnkpIHwgMDtcbiAgICAgICAgICAgIHZhciBiUm90YXRlZCA9IChzaW4gKiBiLnggKyBjb3MgKiBiLnkpIHwgMDtcbiAgICAgICAgICAgIHJldHVybiAoYVJvdGF0ZWQgLSBiUm90YXRlZCkgfHwgKGIuaW5kZXggLSBhLmluZGV4KTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgcCA9IDA7IHAgPCB0aGlzLnN5bWJvbEluc3RhbmNlcy5sZW5ndGg7IHArKykge1xuICAgICAgICB2YXIgc3ltYm9sSW5zdGFuY2UgPSB0aGlzLnN5bWJvbEluc3RhbmNlc1twXTtcbiAgICAgICAgdmFyIGhhc1RleHQgPSBzeW1ib2xJbnN0YW5jZS5oYXNUZXh0O1xuICAgICAgICB2YXIgaGFzSWNvbiA9IHN5bWJvbEluc3RhbmNlLmhhc0ljb247XG5cbiAgICAgICAgdmFyIGljb25XaXRob3V0VGV4dCA9IGxheW91dFsndGV4dC1vcHRpb25hbCddIHx8ICFoYXNUZXh0LFxuICAgICAgICAgICAgdGV4dFdpdGhvdXRJY29uID0gbGF5b3V0WydpY29uLW9wdGlvbmFsJ10gfHwgIWhhc0ljb247XG5cblxuICAgICAgICAvLyBDYWxjdWxhdGUgdGhlIHNjYWxlcyBhdCB3aGljaCB0aGUgdGV4dCBhbmQgaWNvbiBjYW4gYmUgcGxhY2VkIHdpdGhvdXQgY29sbGlzaW9uLlxuXG4gICAgICAgIHZhciBnbHlwaFNjYWxlID0gaGFzVGV4dCA/XG4gICAgICAgICAgICBjb2xsaXNpb25UaWxlLnBsYWNlQ29sbGlzaW9uRmVhdHVyZShzeW1ib2xJbnN0YW5jZS50ZXh0Q29sbGlzaW9uRmVhdHVyZSxcbiAgICAgICAgICAgICAgICAgICAgbGF5b3V0Wyd0ZXh0LWFsbG93LW92ZXJsYXAnXSwgbGF5b3V0WydzeW1ib2wtYXZvaWQtZWRnZXMnXSkgOlxuICAgICAgICAgICAgY29sbGlzaW9uVGlsZS5taW5TY2FsZTtcblxuICAgICAgICB2YXIgaWNvblNjYWxlID0gaGFzSWNvbiA/XG4gICAgICAgICAgICBjb2xsaXNpb25UaWxlLnBsYWNlQ29sbGlzaW9uRmVhdHVyZShzeW1ib2xJbnN0YW5jZS5pY29uQ29sbGlzaW9uRmVhdHVyZSxcbiAgICAgICAgICAgICAgICAgICAgbGF5b3V0WydpY29uLWFsbG93LW92ZXJsYXAnXSwgbGF5b3V0WydzeW1ib2wtYXZvaWQtZWRnZXMnXSkgOlxuICAgICAgICAgICAgY29sbGlzaW9uVGlsZS5taW5TY2FsZTtcblxuXG4gICAgICAgIC8vIENvbWJpbmUgdGhlIHNjYWxlcyBmb3IgaWNvbnMgYW5kIHRleHQuXG5cbiAgICAgICAgaWYgKCFpY29uV2l0aG91dFRleHQgJiYgIXRleHRXaXRob3V0SWNvbikge1xuICAgICAgICAgICAgaWNvblNjYWxlID0gZ2x5cGhTY2FsZSA9IE1hdGgubWF4KGljb25TY2FsZSwgZ2x5cGhTY2FsZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoIXRleHRXaXRob3V0SWNvbiAmJiBnbHlwaFNjYWxlKSB7XG4gICAgICAgICAgICBnbHlwaFNjYWxlID0gTWF0aC5tYXgoaWNvblNjYWxlLCBnbHlwaFNjYWxlKTtcbiAgICAgICAgfSBlbHNlIGlmICghaWNvbldpdGhvdXRUZXh0ICYmIGljb25TY2FsZSkge1xuICAgICAgICAgICAgaWNvblNjYWxlID0gTWF0aC5tYXgoaWNvblNjYWxlLCBnbHlwaFNjYWxlKTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgLy8gSW5zZXJ0IGZpbmFsIHBsYWNlbWVudCBpbnRvIGNvbGxpc2lvbiB0cmVlIGFuZCBhZGQgZ2x5cGhzL2ljb25zIHRvIGJ1ZmZlcnNcblxuICAgICAgICBpZiAoaGFzVGV4dCkge1xuICAgICAgICAgICAgY29sbGlzaW9uVGlsZS5pbnNlcnRDb2xsaXNpb25GZWF0dXJlKHN5bWJvbEluc3RhbmNlLnRleHRDb2xsaXNpb25GZWF0dXJlLCBnbHlwaFNjYWxlLCBsYXlvdXRbJ3RleHQtaWdub3JlLXBsYWNlbWVudCddKTtcbiAgICAgICAgICAgIGlmIChnbHlwaFNjYWxlIDw9IG1heFNjYWxlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGRTeW1ib2xzKCdnbHlwaCcsIHN5bWJvbEluc3RhbmNlLmdseXBoUXVhZHMsIGdseXBoU2NhbGUsIGxheW91dFsndGV4dC1rZWVwLXVwcmlnaHQnXSwgdGV4dEFsb25nTGluZSwgY29sbGlzaW9uVGlsZS5hbmdsZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaGFzSWNvbikge1xuICAgICAgICAgICAgY29sbGlzaW9uVGlsZS5pbnNlcnRDb2xsaXNpb25GZWF0dXJlKHN5bWJvbEluc3RhbmNlLmljb25Db2xsaXNpb25GZWF0dXJlLCBpY29uU2NhbGUsIGxheW91dFsnaWNvbi1pZ25vcmUtcGxhY2VtZW50J10pO1xuICAgICAgICAgICAgaWYgKGljb25TY2FsZSA8PSBtYXhTY2FsZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkU3ltYm9scygnaWNvbicsIHN5bWJvbEluc3RhbmNlLmljb25RdWFkcywgaWNvblNjYWxlLCBsYXlvdXRbJ2ljb24ta2VlcC11cHJpZ2h0J10sIGljb25BbG9uZ0xpbmUsIGNvbGxpc2lvblRpbGUuYW5nbGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICB9XG5cbiAgICBpZiAoc2hvd0NvbGxpc2lvbkJveGVzKSB0aGlzLmFkZFRvRGVidWdCdWZmZXJzKGNvbGxpc2lvblRpbGUpO1xufTtcblxuU3ltYm9sQnVja2V0LnByb3RvdHlwZS5hZGRTeW1ib2xzID0gZnVuY3Rpb24oc2hhZGVyTmFtZSwgcXVhZHMsIHNjYWxlLCBrZWVwVXByaWdodCwgYWxvbmdMaW5lLCBwbGFjZW1lbnRBbmdsZSkge1xuXG4gICAgdmFyIGdyb3VwID0gdGhpcy5tYWtlUm9vbUZvcihzaGFkZXJOYW1lLCA0ICogcXVhZHMubGVuZ3RoKTtcblxuICAgIC8vIFRPRE8gbWFudWFsIGN1cnJ5XG4gICAgdmFyIGFkZEVsZW1lbnQgPSB0aGlzW3RoaXMuZ2V0QWRkTWV0aG9kTmFtZShzaGFkZXJOYW1lLCAnZWxlbWVudCcpXS5iaW5kKHRoaXMpO1xuICAgIHZhciBhZGRWZXJ0ZXggPSB0aGlzW3RoaXMuZ2V0QWRkTWV0aG9kTmFtZShzaGFkZXJOYW1lLCAndmVydGV4JyldLmJpbmQodGhpcyk7XG5cbiAgICB2YXIgem9vbSA9IHRoaXMuem9vbTtcbiAgICB2YXIgcGxhY2VtZW50Wm9vbSA9IE1hdGgubWF4KE1hdGgubG9nKHNjYWxlKSAvIE1hdGguTE4yICsgem9vbSwgMCk7XG5cbiAgICBmb3IgKHZhciBrID0gMDsgayA8IHF1YWRzLmxlbmd0aDsgaysrKSB7XG5cbiAgICAgICAgdmFyIHN5bWJvbCA9IHF1YWRzW2tdLFxuICAgICAgICAgICAgYW5nbGUgPSBzeW1ib2wuYW5nbGU7XG5cbiAgICAgICAgLy8gZHJvcCB1cHNpZGUgZG93biB2ZXJzaW9ucyBvZiBnbHlwaHNcbiAgICAgICAgdmFyIGEgPSAoYW5nbGUgKyBwbGFjZW1lbnRBbmdsZSArIE1hdGguUEkpICUgKE1hdGguUEkgKiAyKTtcbiAgICAgICAgaWYgKGtlZXBVcHJpZ2h0ICYmIGFsb25nTGluZSAmJiAoYSA8PSBNYXRoLlBJIC8gMiB8fCBhID4gTWF0aC5QSSAqIDMgLyAyKSkgY29udGludWU7XG5cbiAgICAgICAgdmFyIHRsID0gc3ltYm9sLnRsLFxuICAgICAgICAgICAgdHIgPSBzeW1ib2wudHIsXG4gICAgICAgICAgICBibCA9IHN5bWJvbC5ibCxcbiAgICAgICAgICAgIGJyID0gc3ltYm9sLmJyLFxuICAgICAgICAgICAgdGV4ID0gc3ltYm9sLnRleCxcbiAgICAgICAgICAgIGFuY2hvclBvaW50ID0gc3ltYm9sLmFuY2hvclBvaW50LFxuXG4gICAgICAgICAgICBtaW5ab29tID0gTWF0aC5tYXgoem9vbSArIE1hdGgubG9nKHN5bWJvbC5taW5TY2FsZSkgLyBNYXRoLkxOMiwgcGxhY2VtZW50Wm9vbSksXG4gICAgICAgICAgICBtYXhab29tID0gTWF0aC5taW4oem9vbSArIE1hdGgubG9nKHN5bWJvbC5tYXhTY2FsZSkgLyBNYXRoLkxOMiwgMjUpO1xuXG4gICAgICAgIGlmIChtYXhab29tIDw9IG1pblpvb20pIGNvbnRpbnVlO1xuXG4gICAgICAgIC8vIExvd2VyIG1pbiB6b29tIHNvIHRoYXQgd2hpbGUgZmFkaW5nIG91dCB0aGUgbGFiZWwgaXQgY2FuIGJlIHNob3duIG91dHNpZGUgb2YgY29sbGlzaW9uLWZyZWUgem9vbSBsZXZlbHNcbiAgICAgICAgaWYgKG1pblpvb20gPT09IHBsYWNlbWVudFpvb20pIG1pblpvb20gPSAwO1xuXG4gICAgICAgIHZhciBpbmRleCA9IGFkZFZlcnRleChhbmNob3JQb2ludC54LCBhbmNob3JQb2ludC55LCB0bC54LCB0bC55LCB0ZXgueCwgdGV4LnksIG1pblpvb20sIG1heFpvb20sIHBsYWNlbWVudFpvb20pIC0gZ3JvdXAudmVydGV4U3RhcnRJbmRleDtcbiAgICAgICAgYWRkVmVydGV4KGFuY2hvclBvaW50LngsIGFuY2hvclBvaW50LnksIHRyLngsIHRyLnksIHRleC54ICsgdGV4LncsIHRleC55LCBtaW5ab29tLCBtYXhab29tLCBwbGFjZW1lbnRab29tKTtcbiAgICAgICAgYWRkVmVydGV4KGFuY2hvclBvaW50LngsIGFuY2hvclBvaW50LnksIGJsLngsIGJsLnksIHRleC54LCB0ZXgueSArIHRleC5oLCBtaW5ab29tLCBtYXhab29tLCBwbGFjZW1lbnRab29tKTtcbiAgICAgICAgYWRkVmVydGV4KGFuY2hvclBvaW50LngsIGFuY2hvclBvaW50LnksIGJyLngsIGJyLnksIHRleC54ICsgdGV4LncsIHRleC55ICsgdGV4LmgsIG1pblpvb20sIG1heFpvb20sIHBsYWNlbWVudFpvb20pO1xuICAgICAgICBncm91cC52ZXJ0ZXhMZW5ndGggKz0gNDtcblxuICAgICAgICBhZGRFbGVtZW50KGluZGV4LCBpbmRleCArIDEsIGluZGV4ICsgMik7XG4gICAgICAgIGFkZEVsZW1lbnQoaW5kZXggKyAxLCBpbmRleCArIDIsIGluZGV4ICsgMyk7XG4gICAgICAgIGdyb3VwLmVsZW1lbnRMZW5ndGggKz0gMjtcbiAgICB9XG5cbn07XG5cblN5bWJvbEJ1Y2tldC5wcm90b3R5cGUudXBkYXRlSWNvbnMgPSBmdW5jdGlvbihpY29ucykge1xuICAgIHRoaXMuY3JlYXRlU3R5bGVMYXllcigpO1xuXG4gICAgdmFyIGljb25WYWx1ZSA9IHRoaXMubGF5ZXIubGF5b3V0WydpY29uLWltYWdlJ107XG4gICAgaWYgKCFpY29uVmFsdWUpIHJldHVybjtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5mZWF0dXJlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgaWNvbk5hbWUgPSByZXNvbHZlVG9rZW5zKHRoaXMuZmVhdHVyZXNbaV0ucHJvcGVydGllcywgaWNvblZhbHVlKTtcbiAgICAgICAgaWYgKGljb25OYW1lKVxuICAgICAgICAgICAgaWNvbnNbaWNvbk5hbWVdID0gdHJ1ZTtcbiAgICB9XG59O1xuXG5TeW1ib2xCdWNrZXQucHJvdG90eXBlLnVwZGF0ZUZvbnQgPSBmdW5jdGlvbihzdGFja3MpIHtcbiAgICB0aGlzLmNyZWF0ZVN0eWxlTGF5ZXIoKTtcblxuICAgIHZhciBmb250TmFtZSA9IHRoaXMubGF5ZXIubGF5b3V0Wyd0ZXh0LWZvbnQnXSxcbiAgICAgICAgc3RhY2sgPSBzdGFja3NbZm9udE5hbWVdID0gc3RhY2tzW2ZvbnROYW1lXSB8fCB7fTtcblxuICAgIHRoaXMudGV4dEZlYXR1cmVzID0gcmVzb2x2ZVRleHQodGhpcy5mZWF0dXJlcywgdGhpcy5sYXllci5sYXlvdXQsIHN0YWNrKTtcbn07XG5cblN5bWJvbEJ1Y2tldC5wcm90b3R5cGUuYWRkVG9EZWJ1Z0J1ZmZlcnMgPSBmdW5jdGlvbihjb2xsaXNpb25UaWxlKSB7XG4gICAgdGhpcy5lbGVtZW50R3JvdXBzLmNvbGxpc2lvbkJveCA9IFtdO1xuICAgIHZhciBncm91cCA9IHRoaXMubWFrZVJvb21Gb3IoJ2NvbGxpc2lvbkJveCcsIDApO1xuICAgIHZhciBhbmdsZSA9IC1jb2xsaXNpb25UaWxlLmFuZ2xlO1xuICAgIHZhciB5U3RyZXRjaCA9IGNvbGxpc2lvblRpbGUueVN0cmV0Y2g7XG5cbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IHRoaXMuc3ltYm9sSW5zdGFuY2VzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMjsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgZmVhdHVyZSA9IHRoaXMuc3ltYm9sSW5zdGFuY2VzW2pdW2kgPT09IDAgPyAndGV4dENvbGxpc2lvbkZlYXR1cmUnIDogJ2ljb25Db2xsaXNpb25GZWF0dXJlJ107XG4gICAgICAgICAgICBpZiAoIWZlYXR1cmUpIGNvbnRpbnVlO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBiID0gZmVhdHVyZS5ib3hTdGFydEluZGV4OyBiIDwgZmVhdHVyZS5ib3hFbmRJbmRleDsgYisrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGJveCA9IHRoaXMuY29sbGlzaW9uQm94QXJyYXkuZ2V0KGIpO1xuICAgICAgICAgICAgICAgIHZhciBhbmNob3JQb2ludCA9IGJveC5hbmNob3JQb2ludDtcblxuICAgICAgICAgICAgICAgIHZhciB0bCA9IG5ldyBQb2ludChib3gueDEsIGJveC55MSAqIHlTdHJldGNoKS5fcm90YXRlKGFuZ2xlKTtcbiAgICAgICAgICAgICAgICB2YXIgdHIgPSBuZXcgUG9pbnQoYm94LngyLCBib3gueTEgKiB5U3RyZXRjaCkuX3JvdGF0ZShhbmdsZSk7XG4gICAgICAgICAgICAgICAgdmFyIGJsID0gbmV3IFBvaW50KGJveC54MSwgYm94LnkyICogeVN0cmV0Y2gpLl9yb3RhdGUoYW5nbGUpO1xuICAgICAgICAgICAgICAgIHZhciBiciA9IG5ldyBQb2ludChib3gueDIsIGJveC55MiAqIHlTdHJldGNoKS5fcm90YXRlKGFuZ2xlKTtcblxuICAgICAgICAgICAgICAgIHZhciBtYXhab29tID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oMjUsIHRoaXMuem9vbSArIE1hdGgubG9nKGJveC5tYXhTY2FsZSkgLyBNYXRoLkxOMikpO1xuICAgICAgICAgICAgICAgIHZhciBwbGFjZW1lbnRab29tID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oMjUsIHRoaXMuem9vbSArIE1hdGgubG9nKGJveC5wbGFjZW1lbnRTY2FsZSkgLyBNYXRoLkxOMikpO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5hZGRDb2xsaXNpb25Cb3hWZXJ0ZXgoYW5jaG9yUG9pbnQsIHRsLCBtYXhab29tLCBwbGFjZW1lbnRab29tKTtcbiAgICAgICAgICAgICAgICB0aGlzLmFkZENvbGxpc2lvbkJveFZlcnRleChhbmNob3JQb2ludCwgdHIsIG1heFpvb20sIHBsYWNlbWVudFpvb20pO1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkQ29sbGlzaW9uQm94VmVydGV4KGFuY2hvclBvaW50LCB0ciwgbWF4Wm9vbSwgcGxhY2VtZW50Wm9vbSk7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGRDb2xsaXNpb25Cb3hWZXJ0ZXgoYW5jaG9yUG9pbnQsIGJyLCBtYXhab29tLCBwbGFjZW1lbnRab29tKTtcbiAgICAgICAgICAgICAgICB0aGlzLmFkZENvbGxpc2lvbkJveFZlcnRleChhbmNob3JQb2ludCwgYnIsIG1heFpvb20sIHBsYWNlbWVudFpvb20pO1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkQ29sbGlzaW9uQm94VmVydGV4KGFuY2hvclBvaW50LCBibCwgbWF4Wm9vbSwgcGxhY2VtZW50Wm9vbSk7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGRDb2xsaXNpb25Cb3hWZXJ0ZXgoYW5jaG9yUG9pbnQsIGJsLCBtYXhab29tLCBwbGFjZW1lbnRab29tKTtcbiAgICAgICAgICAgICAgICB0aGlzLmFkZENvbGxpc2lvbkJveFZlcnRleChhbmNob3JQb2ludCwgdGwsIG1heFpvb20sIHBsYWNlbWVudFpvb20pO1xuICAgICAgICAgICAgICAgIGdyb3VwLnZlcnRleExlbmd0aCArPSA4O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufTtcblxuZnVuY3Rpb24gU3ltYm9sSW5zdGFuY2UoYW5jaG9yLCBsaW5lLCBzaGFwZWRUZXh0LCBzaGFwZWRJY29uLCBsYXlvdXQsIGFkZFRvQnVmZmVycywgaW5kZXgsIGNvbGxpc2lvbkJveEFycmF5LCBmZWF0dXJlSW5kZXgsIHNvdXJjZUxheWVySW5kZXgsIGJ1Y2tldEluZGV4LFxuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dEJveFNjYWxlLCB0ZXh0UGFkZGluZywgdGV4dEFsb25nTGluZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGljb25Cb3hTY2FsZSwgaWNvblBhZGRpbmcsIGljb25BbG9uZ0xpbmUpIHtcblxuICAgIHRoaXMueCA9IGFuY2hvci54O1xuICAgIHRoaXMueSA9IGFuY2hvci55O1xuICAgIHRoaXMuaW5kZXggPSBpbmRleDtcbiAgICB0aGlzLmhhc1RleHQgPSAhIXNoYXBlZFRleHQ7XG4gICAgdGhpcy5oYXNJY29uID0gISFzaGFwZWRJY29uO1xuXG4gICAgaWYgKHRoaXMuaGFzVGV4dCkge1xuICAgICAgICB0aGlzLmdseXBoUXVhZHMgPSBhZGRUb0J1ZmZlcnMgPyBnZXRHbHlwaFF1YWRzKGFuY2hvciwgc2hhcGVkVGV4dCwgdGV4dEJveFNjYWxlLCBsaW5lLCBsYXlvdXQsIHRleHRBbG9uZ0xpbmUpIDogW107XG4gICAgICAgIHRoaXMudGV4dENvbGxpc2lvbkZlYXR1cmUgPSBuZXcgQ29sbGlzaW9uRmVhdHVyZShjb2xsaXNpb25Cb3hBcnJheSwgbGluZSwgYW5jaG9yLCBmZWF0dXJlSW5kZXgsIHNvdXJjZUxheWVySW5kZXgsIGJ1Y2tldEluZGV4LFxuICAgICAgICAgICAgICAgIHNoYXBlZFRleHQsIHRleHRCb3hTY2FsZSwgdGV4dFBhZGRpbmcsIHRleHRBbG9uZ0xpbmUsIGZhbHNlKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5oYXNJY29uKSB7XG4gICAgICAgIHRoaXMuaWNvblF1YWRzID0gYWRkVG9CdWZmZXJzID8gZ2V0SWNvblF1YWRzKGFuY2hvciwgc2hhcGVkSWNvbiwgaWNvbkJveFNjYWxlLCBsaW5lLCBsYXlvdXQsIGljb25BbG9uZ0xpbmUpIDogW107XG4gICAgICAgIHRoaXMuaWNvbkNvbGxpc2lvbkZlYXR1cmUgPSBuZXcgQ29sbGlzaW9uRmVhdHVyZShjb2xsaXNpb25Cb3hBcnJheSwgbGluZSwgYW5jaG9yLCBmZWF0dXJlSW5kZXgsIHNvdXJjZUxheWVySW5kZXgsIGJ1Y2tldEluZGV4LFxuICAgICAgICAgICAgICAgIHNoYXBlZEljb24sIGljb25Cb3hTY2FsZSwgaWNvblBhZGRpbmcsIGljb25BbG9uZ0xpbmUsIHRydWUpO1xuICAgIH1cbn1cbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBCdWZmZXI7XG5cbi8qKlxuICogVGhlIGBCdWZmZXJgIGNsYXNzIHR1cm5zIGEgYFN0cnVjdEFycmF5YCBpbnRvIGEgV2ViR0wgYnVmZmVyLiBFYWNoIG1lbWJlciBvZiB0aGUgU3RydWN0QXJyYXknc1xuICogU3RydWN0IHR5cGUgaXMgY29udmVydGVkIHRvIGEgV2ViR0wgYXRyaWJ1dGUuXG4gKlxuICogQGNsYXNzIEJ1ZmZlclxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7b2JqZWN0fSBhcnJheSBBIHNlcmlhbGl6ZWQgU3RydWN0QXJyYXkuXG4gKiBAcGFyYW0ge29iamVjdH0gYXJyYXlUeXBlIEEgc2VyaWFsaXplZCBTdHJ1Y3RBcnJheVR5cGUuXG4gKiBAcGFyYW0ge0J1ZmZlclR5cGV9IHR5cGVcbiAqL1xuZnVuY3Rpb24gQnVmZmVyKGFycmF5LCBhcnJheVR5cGUsIHR5cGUpIHtcbiAgICB0aGlzLmFycmF5QnVmZmVyID0gYXJyYXkuYXJyYXlCdWZmZXI7XG4gICAgdGhpcy5sZW5ndGggPSBhcnJheS5sZW5ndGg7XG4gICAgdGhpcy5hdHRyaWJ1dGVzID0gYXJyYXlUeXBlLm1lbWJlcnM7XG4gICAgdGhpcy5pdGVtU2l6ZSA9IGFycmF5VHlwZS5ieXRlc1BlckVsZW1lbnQ7XG4gICAgdGhpcy50eXBlID0gdHlwZTtcbn1cblxuLyoqXG4gKiBCaW5kIHRoaXMgYnVmZmVyIHRvIGEgV2ViR0wgY29udGV4dC5cbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0gZ2wgVGhlIFdlYkdMIGNvbnRleHRcbiAqL1xuQnVmZmVyLnByb3RvdHlwZS5iaW5kID0gZnVuY3Rpb24oZ2wpIHtcbiAgICB2YXIgdHlwZSA9IGdsW3RoaXMudHlwZV07XG5cbiAgICBpZiAoIXRoaXMuYnVmZmVyKSB7XG4gICAgICAgIHRoaXMuYnVmZmVyID0gZ2wuY3JlYXRlQnVmZmVyKCk7XG4gICAgICAgIGdsLmJpbmRCdWZmZXIodHlwZSwgdGhpcy5idWZmZXIpO1xuICAgICAgICBnbC5idWZmZXJEYXRhKHR5cGUsIHRoaXMuYXJyYXlCdWZmZXIsIGdsLlNUQVRJQ19EUkFXKTtcblxuICAgICAgICAvLyBkdW1wIGFycmF5IGJ1ZmZlciBvbmNlIGl0J3MgYm91bmQgdG8gZ2xcbiAgICAgICAgdGhpcy5hcnJheUJ1ZmZlciA9IG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZ2wuYmluZEJ1ZmZlcih0eXBlLCB0aGlzLmJ1ZmZlcik7XG4gICAgfVxufTtcblxuLyoqXG4gKiBEZXN0cm95IHRoZSBHTCBidWZmZXIgYm91bmQgdG8gdGhlIGdpdmVuIFdlYkdMIGNvbnRleHRcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0gZ2wgVGhlIFdlYkdMIGNvbnRleHRcbiAqL1xuQnVmZmVyLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24oZ2wpIHtcbiAgICBpZiAodGhpcy5idWZmZXIpIHtcbiAgICAgICAgZ2wuZGVsZXRlQnVmZmVyKHRoaXMuYnVmZmVyKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIEBlbnVtIHtzdHJpbmd9IEJ1ZmZlckF0dHJpYnV0ZVR5cGVcbiAqIEBwcml2YXRlXG4gKiBAcmVhZG9ubHlcbiAqL1xudmFyIEF0dHJpYnV0ZVR5cGUgPSB7XG4gICAgSW50ODogICAnQllURScsXG4gICAgVWludDg6ICAnVU5TSUdORURfQllURScsXG4gICAgSW50MTY6ICAnU0hPUlQnLFxuICAgIFVpbnQxNjogJ1VOU0lHTkVEX1NIT1JUJ1xufTtcblxuLyoqXG4gKiBTZXQgdGhlIGF0dHJpYnV0ZSBwb2ludGVycyBpbiBhIFdlYkdMIGNvbnRleHQgYWNjb3JkaW5nIHRvIHRoZSBidWZmZXIncyBhdHRyaWJ1dGUgbGF5b3V0XG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIGdsIFRoZSBXZWJHTCBjb250ZXh0XG4gKiBAcGFyYW0gc2hhZGVyIFRoZSBhY3RpdmUgV2ViR0wgc2hhZGVyXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IFRoZSBvZmZzZXQgb2YgdGhlIGF0dHJpYnV0ZSBkYXRhIGluIHRoZSBjdXJyZW50bHkgYm91bmQgR0wgYnVmZmVyLlxuICovXG5CdWZmZXIucHJvdG90eXBlLnNldEF0dHJpYlBvaW50ZXJzID0gZnVuY3Rpb24oZ2wsIHNoYWRlciwgb2Zmc2V0KSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmF0dHJpYnV0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGF0dHJpYiA9IHRoaXMuYXR0cmlidXRlc1tpXTtcblxuICAgICAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKFxuICAgICAgICAgICAgc2hhZGVyWydhXycgKyBhdHRyaWIubmFtZV0sIGF0dHJpYi5jb21wb25lbnRzLCBnbFtBdHRyaWJ1dGVUeXBlW2F0dHJpYi50eXBlXV0sXG4gICAgICAgICAgICBmYWxzZSwgdGhpcy5pdGVtU2l6ZSwgb2Zmc2V0ICsgYXR0cmliLm9mZnNldCk7XG4gICAgfVxufTtcblxuLyoqXG4gKiBAZW51bSB7c3RyaW5nfSBCdWZmZXJUeXBlXG4gKiBAcHJpdmF0ZVxuICogQHJlYWRvbmx5XG4gKi9cbkJ1ZmZlci5CdWZmZXJUeXBlID0ge1xuICAgIFZFUlRFWDogJ0FSUkFZX0JVRkZFUicsXG4gICAgRUxFTUVOVDogJ0VMRU1FTlRfQVJSQVlfQlVGRkVSJ1xufTtcblxuLyoqXG4gKiBBbiBgQnVmZmVyVHlwZS5FTEVNRU5UYCBidWZmZXIgaG9sZHMgaW5kaWNpZXMgb2YgYSBjb3JyZXNwb25kaW5nIGBCdWZmZXJUeXBlLlZFUlRFWGAgYnVmZmVyLlxuICogVGhlc2UgaW5kaWNpZXMgYXJlIHN0b3JlZCBpbiB0aGUgYEJ1ZmZlclR5cGUuRUxFTUVOVGAgYnVmZmVyIGFzIGBVTlNJR05FRF9TSE9SVGBzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcmVhZG9ubHlcbiAqL1xuQnVmZmVyLkVMRU1FTlRfQVRUUklCVVRFX1RZUEUgPSAnVWludDE2JztcblxuLyoqXG4gKiBXZWJHTCBwZXJmb3JtcyBiZXN0IGlmIHZlcnRleCBhdHRyaWJ1dGUgb2Zmc2V0cyBhcmUgYWxpZ25lZCB0byA0IGJ5dGUgYm91bmRhcmllcy5cbiAqIEBwcml2YXRlXG4gKiBAcmVhZG9ubHlcbiAqL1xuQnVmZmVyLlZFUlRFWF9BVFRSSUJVVEVfQUxJR05NRU5UID0gNDtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIFBvaW50ID0gcmVxdWlyZSgncG9pbnQtZ2VvbWV0cnknKTtcbnZhciBsb2FkR2VvbWV0cnkgPSByZXF1aXJlKCcuL2xvYWRfZ2VvbWV0cnknKTtcbnZhciBFWFRFTlQgPSByZXF1aXJlKCcuL2J1Y2tldCcpLkVYVEVOVDtcbnZhciBmZWF0dXJlRmlsdGVyID0gcmVxdWlyZSgnZmVhdHVyZS1maWx0ZXInKTtcbnZhciBTdHJ1Y3RBcnJheVR5cGUgPSByZXF1aXJlKCcuLi91dGlsL3N0cnVjdF9hcnJheScpO1xudmFyIEdyaWQgPSByZXF1aXJlKCcuLi91dGlsL2dyaWQnKTtcbnZhciBEaWN0aW9uYXJ5Q29kZXIgPSByZXF1aXJlKCcuLi91dGlsL2RpY3Rpb25hcnlfY29kZXInKTtcbnZhciB2dCA9IHJlcXVpcmUoJ3ZlY3Rvci10aWxlJyk7XG52YXIgUHJvdG9idWYgPSByZXF1aXJlKCdwYmYnKTtcbnZhciBHZW9KU09ORmVhdHVyZSA9IHJlcXVpcmUoJy4uL3V0aWwvdmVjdG9ydGlsZV90b19nZW9qc29uJyk7XG52YXIgYXJyYXlzSW50ZXJzZWN0ID0gcmVxdWlyZSgnLi4vdXRpbC91dGlsJykuYXJyYXlzSW50ZXJzZWN0O1xuXG52YXIgaW50ZXJzZWN0aW9uID0gcmVxdWlyZSgnLi4vdXRpbC9pbnRlcnNlY3Rpb25fdGVzdHMnKTtcbnZhciBtdWx0aVBvbHlnb25JbnRlcnNlY3RzQnVmZmVyZWRNdWx0aVBvaW50ID0gaW50ZXJzZWN0aW9uLm11bHRpUG9seWdvbkludGVyc2VjdHNCdWZmZXJlZE11bHRpUG9pbnQ7XG52YXIgbXVsdGlQb2x5Z29uSW50ZXJzZWN0c011bHRpUG9seWdvbiA9IGludGVyc2VjdGlvbi5tdWx0aVBvbHlnb25JbnRlcnNlY3RzTXVsdGlQb2x5Z29uO1xudmFyIG11bHRpUG9seWdvbkludGVyc2VjdHNCdWZmZXJlZE11bHRpTGluZSA9IGludGVyc2VjdGlvbi5tdWx0aVBvbHlnb25JbnRlcnNlY3RzQnVmZmVyZWRNdWx0aUxpbmU7XG5cblxudmFyIEZlYXR1cmVJbmRleEFycmF5ID0gbmV3IFN0cnVjdEFycmF5VHlwZSh7XG4gICAgbWVtYmVyczogW1xuICAgICAgICAvLyB0aGUgaW5kZXggb2YgdGhlIGZlYXR1cmUgaW4gdGhlIG9yaWdpbmFsIHZlY3RvcnRpbGVcbiAgICAgICAgeyB0eXBlOiAnVWludDMyJywgbmFtZTogJ2ZlYXR1cmVJbmRleCcgfSxcbiAgICAgICAgLy8gdGhlIHNvdXJjZSBsYXllciB0aGUgZmVhdHVyZSBhcHBlYXJzIGluXG4gICAgICAgIHsgdHlwZTogJ1VpbnQxNicsIG5hbWU6ICdzb3VyY2VMYXllckluZGV4JyB9LFxuICAgICAgICAvLyB0aGUgYnVja2V0IHRoZSBmZWF0dXJlIGFwcGVhcnMgaW5cbiAgICAgICAgeyB0eXBlOiAnVWludDE2JywgbmFtZTogJ2J1Y2tldEluZGV4JyB9XG4gICAgXX0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEZlYXR1cmVJbmRleDtcblxuZnVuY3Rpb24gRmVhdHVyZUluZGV4KGNvb3JkLCBvdmVyc2NhbGluZywgY29sbGlzaW9uVGlsZSkge1xuICAgIGlmIChjb29yZC5ncmlkKSB7XG4gICAgICAgIHZhciBzZXJpYWxpemVkID0gY29vcmQ7XG4gICAgICAgIHZhciByYXdUaWxlRGF0YSA9IG92ZXJzY2FsaW5nO1xuICAgICAgICBjb29yZCA9IHNlcmlhbGl6ZWQuY29vcmQ7XG4gICAgICAgIG92ZXJzY2FsaW5nID0gc2VyaWFsaXplZC5vdmVyc2NhbGluZztcbiAgICAgICAgdGhpcy5ncmlkID0gbmV3IEdyaWQoc2VyaWFsaXplZC5ncmlkKTtcbiAgICAgICAgdGhpcy5mZWF0dXJlSW5kZXhBcnJheSA9IG5ldyBGZWF0dXJlSW5kZXhBcnJheShzZXJpYWxpemVkLmZlYXR1cmVJbmRleEFycmF5KTtcbiAgICAgICAgdGhpcy5yYXdUaWxlRGF0YSA9IHJhd1RpbGVEYXRhO1xuICAgICAgICB0aGlzLmJ1Y2tldExheWVySURzID0gc2VyaWFsaXplZC5idWNrZXRMYXllcklEcztcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmdyaWQgPSBuZXcgR3JpZCgxNiwgRVhURU5ULCAwKTtcbiAgICAgICAgdGhpcy5mZWF0dXJlSW5kZXhBcnJheSA9IG5ldyBGZWF0dXJlSW5kZXhBcnJheSgpO1xuICAgIH1cbiAgICB0aGlzLmNvb3JkID0gY29vcmQ7XG4gICAgdGhpcy5vdmVyc2NhbGluZyA9IG92ZXJzY2FsaW5nO1xuICAgIHRoaXMueCA9IGNvb3JkLng7XG4gICAgdGhpcy55ID0gY29vcmQueTtcbiAgICB0aGlzLnogPSBjb29yZC56IC0gTWF0aC5sb2cob3ZlcnNjYWxpbmcpIC8gTWF0aC5MTjI7XG4gICAgdGhpcy5zZXRDb2xsaXNpb25UaWxlKGNvbGxpc2lvblRpbGUpO1xufVxuXG5GZWF0dXJlSW5kZXgucHJvdG90eXBlLmluc2VydCA9IGZ1bmN0aW9uKGZlYXR1cmUsIGZlYXR1cmVJbmRleCwgc291cmNlTGF5ZXJJbmRleCwgYnVja2V0SW5kZXgpIHtcbiAgICB2YXIga2V5ID0gdGhpcy5mZWF0dXJlSW5kZXhBcnJheS5sZW5ndGg7XG4gICAgdGhpcy5mZWF0dXJlSW5kZXhBcnJheS5lbXBsYWNlQmFjayhmZWF0dXJlSW5kZXgsIHNvdXJjZUxheWVySW5kZXgsIGJ1Y2tldEluZGV4KTtcbiAgICB2YXIgZ2VvbWV0cnkgPSBsb2FkR2VvbWV0cnkoZmVhdHVyZSk7XG5cbiAgICBmb3IgKHZhciByID0gMDsgciA8IGdlb21ldHJ5Lmxlbmd0aDsgcisrKSB7XG4gICAgICAgIHZhciByaW5nID0gZ2VvbWV0cnlbcl07XG5cbiAgICAgICAgLy8gVE9ETzogc2tpcCBob2xlcyB3aGVuIHdlIHN0YXJ0IHVzaW5nIHZlY3RvciB0aWxlIHNwZWMgMi4wXG5cbiAgICAgICAgdmFyIGJib3ggPSBbSW5maW5pdHksIEluZmluaXR5LCAtSW5maW5pdHksIC1JbmZpbml0eV07XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmluZy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIHAgPSByaW5nW2ldO1xuICAgICAgICAgICAgYmJveFswXSA9IE1hdGgubWluKGJib3hbMF0sIHAueCk7XG4gICAgICAgICAgICBiYm94WzFdID0gTWF0aC5taW4oYmJveFsxXSwgcC55KTtcbiAgICAgICAgICAgIGJib3hbMl0gPSBNYXRoLm1heChiYm94WzJdLCBwLngpO1xuICAgICAgICAgICAgYmJveFszXSA9IE1hdGgubWF4KGJib3hbM10sIHAueSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmdyaWQuaW5zZXJ0KGtleSwgYmJveFswXSwgYmJveFsxXSwgYmJveFsyXSwgYmJveFszXSk7XG4gICAgfVxufTtcblxuRmVhdHVyZUluZGV4LnByb3RvdHlwZS5zZXRDb2xsaXNpb25UaWxlID0gZnVuY3Rpb24oY29sbGlzaW9uVGlsZSkge1xuICAgIHRoaXMuY29sbGlzaW9uVGlsZSA9IGNvbGxpc2lvblRpbGU7XG59O1xuXG5GZWF0dXJlSW5kZXgucHJvdG90eXBlLnNlcmlhbGl6ZSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBkYXRhID0ge1xuICAgICAgICBjb29yZDogdGhpcy5jb29yZCxcbiAgICAgICAgb3ZlcnNjYWxpbmc6IHRoaXMub3ZlcnNjYWxpbmcsXG4gICAgICAgIGdyaWQ6IHRoaXMuZ3JpZC50b0FycmF5QnVmZmVyKCksXG4gICAgICAgIGZlYXR1cmVJbmRleEFycmF5OiB0aGlzLmZlYXR1cmVJbmRleEFycmF5LnNlcmlhbGl6ZSgpLFxuICAgICAgICBidWNrZXRMYXllcklEczogdGhpcy5idWNrZXRMYXllcklEc1xuICAgIH07XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZGF0YTogZGF0YSxcbiAgICAgICAgdHJhbnNmZXJhYmxlczogW2RhdGEuZ3JpZCwgZGF0YS5mZWF0dXJlSW5kZXhBcnJheS5hcnJheUJ1ZmZlcl1cbiAgICB9O1xufTtcblxuZnVuY3Rpb24gdHJhbnNsYXRlRGlzdGFuY2UodHJhbnNsYXRlKSB7XG4gICAgcmV0dXJuIE1hdGguc3FydCh0cmFuc2xhdGVbMF0gKiB0cmFuc2xhdGVbMF0gKyB0cmFuc2xhdGVbMV0gKiB0cmFuc2xhdGVbMV0pO1xufVxuXG4vLyBGaW5kcyBmZWF0dXJlcyBpbiB0aGlzIHRpbGUgYXQgYSBwYXJ0aWN1bGFyIHBvc2l0aW9uLlxuRmVhdHVyZUluZGV4LnByb3RvdHlwZS5xdWVyeSA9IGZ1bmN0aW9uKGFyZ3MsIHN0eWxlTGF5ZXJzKSB7XG4gICAgaWYgKCF0aGlzLnZ0TGF5ZXJzKSB7XG4gICAgICAgIHRoaXMudnRMYXllcnMgPSBuZXcgdnQuVmVjdG9yVGlsZShuZXcgUHJvdG9idWYobmV3IFVpbnQ4QXJyYXkodGhpcy5yYXdUaWxlRGF0YSkpKS5sYXllcnM7XG4gICAgICAgIHRoaXMuc291cmNlTGF5ZXJDb2RlciA9IG5ldyBEaWN0aW9uYXJ5Q29kZXIodGhpcy52dExheWVycyA/IE9iamVjdC5rZXlzKHRoaXMudnRMYXllcnMpLnNvcnQoKSA6IFsnX2dlb2pzb25UaWxlTGF5ZXInXSk7XG4gICAgfVxuXG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuXG4gICAgdmFyIHBhcmFtcyA9IGFyZ3MucGFyYW1zIHx8IHt9LFxuICAgICAgICBwaXhlbHNUb1RpbGVVbml0cyA9IEVYVEVOVCAvIGFyZ3MudGlsZVNpemUgLyBhcmdzLnNjYWxlLFxuICAgICAgICBmaWx0ZXIgPSBmZWF0dXJlRmlsdGVyKHBhcmFtcy5maWx0ZXIpO1xuXG4gICAgLy8gRmVhdHVyZXMgYXJlIGluZGV4ZWQgdGhlaXIgb3JpZ2luYWwgZ2VvbWV0cmllcy4gVGhlIHJlbmRlcmVkIGdlb21ldHJpZXMgbWF5XG4gICAgLy8gYmUgYnVmZmVyZWQsIHRyYW5zbGF0ZWQgb3Igb2Zmc2V0LiBGaWd1cmUgb3V0IGhvdyBtdWNoIHRoZSBzZWFyY2ggcmFkaXVzIG5lZWRzIHRvIGJlXG4gICAgLy8gZXhwYW5kZWQgYnkgdG8gaW5jbHVkZSB0aGVzZSBmZWF0dXJlcy5cbiAgICB2YXIgYWRkaXRpb25hbFJhZGl1cyA9IDA7XG4gICAgZm9yICh2YXIgaWQgaW4gc3R5bGVMYXllcnMpIHtcbiAgICAgICAgdmFyIHN0eWxlTGF5ZXIgPSBzdHlsZUxheWVyc1tpZF07XG4gICAgICAgIHZhciBwYWludCA9IHN0eWxlTGF5ZXIucGFpbnQ7XG5cbiAgICAgICAgdmFyIHN0eWxlTGF5ZXJEaXN0YW5jZSA9IDA7XG4gICAgICAgIGlmIChzdHlsZUxheWVyLnR5cGUgPT09ICdsaW5lJykge1xuICAgICAgICAgICAgc3R5bGVMYXllckRpc3RhbmNlID0gZ2V0TGluZVdpZHRoKHBhaW50KSAvIDIgKyBNYXRoLmFicyhwYWludFsnbGluZS1vZmZzZXQnXSkgKyB0cmFuc2xhdGVEaXN0YW5jZShwYWludFsnbGluZS10cmFuc2xhdGUnXSk7XG4gICAgICAgIH0gZWxzZSBpZiAoc3R5bGVMYXllci50eXBlID09PSAnZmlsbCcpIHtcbiAgICAgICAgICAgIHN0eWxlTGF5ZXJEaXN0YW5jZSA9IHRyYW5zbGF0ZURpc3RhbmNlKHBhaW50WydmaWxsLXRyYW5zbGF0ZSddKTtcbiAgICAgICAgfSBlbHNlIGlmIChzdHlsZUxheWVyLnR5cGUgPT09ICdjaXJjbGUnKSB7XG4gICAgICAgICAgICBzdHlsZUxheWVyRGlzdGFuY2UgPSBwYWludFsnY2lyY2xlLXJhZGl1cyddICsgdHJhbnNsYXRlRGlzdGFuY2UocGFpbnRbJ2NpcmNsZS10cmFuc2xhdGUnXSk7XG4gICAgICAgIH1cbiAgICAgICAgYWRkaXRpb25hbFJhZGl1cyA9IE1hdGgubWF4KGFkZGl0aW9uYWxSYWRpdXMsIHN0eWxlTGF5ZXJEaXN0YW5jZSAqIHBpeGVsc1RvVGlsZVVuaXRzKTtcbiAgICB9XG5cbiAgICB2YXIgcXVlcnlHZW9tZXRyeSA9IGFyZ3MucXVlcnlHZW9tZXRyeS5tYXAoZnVuY3Rpb24ocSkge1xuICAgICAgICByZXR1cm4gcS5tYXAoZnVuY3Rpb24ocCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQb2ludChwLngsIHAueSk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgdmFyIG1pblggPSBJbmZpbml0eTtcbiAgICB2YXIgbWluWSA9IEluZmluaXR5O1xuICAgIHZhciBtYXhYID0gLUluZmluaXR5O1xuICAgIHZhciBtYXhZID0gLUluZmluaXR5O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcXVlcnlHZW9tZXRyeS5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgcmluZyA9IHF1ZXJ5R2VvbWV0cnlbaV07XG4gICAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgcmluZy5sZW5ndGg7IGsrKykge1xuICAgICAgICAgICAgdmFyIHAgPSByaW5nW2tdO1xuICAgICAgICAgICAgbWluWCA9IE1hdGgubWluKG1pblgsIHAueCk7XG4gICAgICAgICAgICBtaW5ZID0gTWF0aC5taW4obWluWSwgcC55KTtcbiAgICAgICAgICAgIG1heFggPSBNYXRoLm1heChtYXhYLCBwLngpO1xuICAgICAgICAgICAgbWF4WSA9IE1hdGgubWF4KG1heFksIHAueSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgbWF0Y2hpbmcgPSB0aGlzLmdyaWQucXVlcnkobWluWCAtIGFkZGl0aW9uYWxSYWRpdXMsIG1pblkgLSBhZGRpdGlvbmFsUmFkaXVzLCBtYXhYICsgYWRkaXRpb25hbFJhZGl1cywgbWF4WSArIGFkZGl0aW9uYWxSYWRpdXMpO1xuICAgIG1hdGNoaW5nLnNvcnQodG9wRG93bkZlYXR1cmVDb21wYXJhdG9yKTtcbiAgICB0aGlzLmZpbHRlck1hdGNoaW5nKHJlc3VsdCwgbWF0Y2hpbmcsIHRoaXMuZmVhdHVyZUluZGV4QXJyYXksIHF1ZXJ5R2VvbWV0cnksIGZpbHRlciwgcGFyYW1zLmxheWVycywgc3R5bGVMYXllcnMsIGFyZ3MuYmVhcmluZywgcGl4ZWxzVG9UaWxlVW5pdHMpO1xuXG4gICAgdmFyIG1hdGNoaW5nU3ltYm9scyA9IHRoaXMuY29sbGlzaW9uVGlsZS5xdWVyeVJlbmRlcmVkU3ltYm9scyhtaW5YLCBtaW5ZLCBtYXhYLCBtYXhZLCBhcmdzLnNjYWxlKTtcbiAgICBtYXRjaGluZ1N5bWJvbHMuc29ydCgpO1xuICAgIHRoaXMuZmlsdGVyTWF0Y2hpbmcocmVzdWx0LCBtYXRjaGluZ1N5bWJvbHMsIHRoaXMuY29sbGlzaW9uVGlsZS5jb2xsaXNpb25Cb3hBcnJheSwgcXVlcnlHZW9tZXRyeSwgZmlsdGVyLCBwYXJhbXMubGF5ZXJzLCBzdHlsZUxheWVycywgYXJncy5iZWFyaW5nLCBwaXhlbHNUb1RpbGVVbml0cyk7XG5cbiAgICByZXR1cm4gcmVzdWx0O1xufTtcblxuZnVuY3Rpb24gdG9wRG93bkZlYXR1cmVDb21wYXJhdG9yKGEsIGIpIHtcbiAgICByZXR1cm4gYiAtIGE7XG59XG5cbmZ1bmN0aW9uIGdldExpbmVXaWR0aChwYWludCkge1xuICAgIGlmIChwYWludFsnbGluZS1nYXAtd2lkdGgnXSA+IDApIHtcbiAgICAgICAgcmV0dXJuIHBhaW50WydsaW5lLWdhcC13aWR0aCddICsgMiAqIHBhaW50WydsaW5lLXdpZHRoJ107XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHBhaW50WydsaW5lLXdpZHRoJ107XG4gICAgfVxufVxuXG5GZWF0dXJlSW5kZXgucHJvdG90eXBlLmZpbHRlck1hdGNoaW5nID0gZnVuY3Rpb24ocmVzdWx0LCBtYXRjaGluZywgYXJyYXksIHF1ZXJ5R2VvbWV0cnksIGZpbHRlciwgZmlsdGVyTGF5ZXJJRHMsIHN0eWxlTGF5ZXJzLCBiZWFyaW5nLCBwaXhlbHNUb1RpbGVVbml0cykge1xuICAgIHZhciBwcmV2aW91c0luZGV4O1xuICAgIGZvciAodmFyIGsgPSAwOyBrIDwgbWF0Y2hpbmcubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgdmFyIGluZGV4ID0gbWF0Y2hpbmdba107XG5cbiAgICAgICAgLy8gZG9uJ3QgY2hlY2sgdGhlIHNhbWUgZmVhdHVyZSBtb3JlIHRoYW4gb25jZVxuICAgICAgICBpZiAoaW5kZXggPT09IHByZXZpb3VzSW5kZXgpIGNvbnRpbnVlO1xuICAgICAgICBwcmV2aW91c0luZGV4ID0gaW5kZXg7XG5cbiAgICAgICAgdmFyIG1hdGNoID0gYXJyYXkuZ2V0KGluZGV4KTtcblxuICAgICAgICB2YXIgbGF5ZXJJRHMgPSB0aGlzLmJ1Y2tldExheWVySURzW21hdGNoLmJ1Y2tldEluZGV4XTtcbiAgICAgICAgaWYgKGZpbHRlckxheWVySURzICYmICFhcnJheXNJbnRlcnNlY3QoZmlsdGVyTGF5ZXJJRHMsIGxheWVySURzKSkgY29udGludWU7XG5cbiAgICAgICAgdmFyIHNvdXJjZUxheWVyTmFtZSA9IHRoaXMuc291cmNlTGF5ZXJDb2Rlci5kZWNvZGUobWF0Y2guc291cmNlTGF5ZXJJbmRleCk7XG4gICAgICAgIHZhciBzb3VyY2VMYXllciA9IHRoaXMudnRMYXllcnNbc291cmNlTGF5ZXJOYW1lXTtcbiAgICAgICAgdmFyIGZlYXR1cmUgPSBzb3VyY2VMYXllci5mZWF0dXJlKG1hdGNoLmZlYXR1cmVJbmRleCk7XG5cbiAgICAgICAgaWYgKCFmaWx0ZXIoZmVhdHVyZSkpIGNvbnRpbnVlO1xuXG4gICAgICAgIHZhciBnZW9tZXRyeSA9IG51bGw7XG5cbiAgICAgICAgZm9yICh2YXIgbCA9IDA7IGwgPCBsYXllcklEcy5sZW5ndGg7IGwrKykge1xuICAgICAgICAgICAgdmFyIGxheWVySUQgPSBsYXllcklEc1tsXTtcblxuICAgICAgICAgICAgaWYgKGZpbHRlckxheWVySURzICYmIGZpbHRlckxheWVySURzLmluZGV4T2YobGF5ZXJJRCkgPCAwKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBzdHlsZUxheWVyID0gc3R5bGVMYXllcnNbbGF5ZXJJRF07XG4gICAgICAgICAgICBpZiAoIXN0eWxlTGF5ZXIpIGNvbnRpbnVlO1xuXG4gICAgICAgICAgICB2YXIgdHJhbnNsYXRlZFBvbHlnb247XG4gICAgICAgICAgICBpZiAoc3R5bGVMYXllci50eXBlICE9PSAnc3ltYm9sJykge1xuICAgICAgICAgICAgICAgIC8vIGFsbCBzeW1ib2xzIGFscmVhZHkgbWF0Y2ggdGhlIHN0eWxlXG5cbiAgICAgICAgICAgICAgICBpZiAoIWdlb21ldHJ5KSBnZW9tZXRyeSA9IGxvYWRHZW9tZXRyeShmZWF0dXJlKTtcblxuICAgICAgICAgICAgICAgIHZhciBwYWludCA9IHN0eWxlTGF5ZXIucGFpbnQ7XG5cbiAgICAgICAgICAgICAgICBpZiAoc3R5bGVMYXllci50eXBlID09PSAnbGluZScpIHtcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNsYXRlZFBvbHlnb24gPSB0cmFuc2xhdGUocXVlcnlHZW9tZXRyeSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYWludFsnbGluZS10cmFuc2xhdGUnXSwgcGFpbnRbJ2xpbmUtdHJhbnNsYXRlLWFuY2hvciddLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJlYXJpbmcsIHBpeGVsc1RvVGlsZVVuaXRzKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGhhbGZXaWR0aCA9IGdldExpbmVXaWR0aChwYWludCkgLyAyICogcGl4ZWxzVG9UaWxlVW5pdHM7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwYWludFsnbGluZS1vZmZzZXQnXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZ2VvbWV0cnkgPSBvZmZzZXRMaW5lKGdlb21ldHJ5LCBwYWludFsnbGluZS1vZmZzZXQnXSAqIHBpeGVsc1RvVGlsZVVuaXRzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoIW11bHRpUG9seWdvbkludGVyc2VjdHNCdWZmZXJlZE11bHRpTGluZSh0cmFuc2xhdGVkUG9seWdvbiwgZ2VvbWV0cnksIGhhbGZXaWR0aCkpIGNvbnRpbnVlO1xuXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChzdHlsZUxheWVyLnR5cGUgPT09ICdmaWxsJykge1xuICAgICAgICAgICAgICAgICAgICB0cmFuc2xhdGVkUG9seWdvbiA9IHRyYW5zbGF0ZShxdWVyeUdlb21ldHJ5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhaW50WydmaWxsLXRyYW5zbGF0ZSddLCBwYWludFsnZmlsbC10cmFuc2xhdGUtYW5jaG9yJ10sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYmVhcmluZywgcGl4ZWxzVG9UaWxlVW5pdHMpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIW11bHRpUG9seWdvbkludGVyc2VjdHNNdWx0aVBvbHlnb24odHJhbnNsYXRlZFBvbHlnb24sIGdlb21ldHJ5KSkgY29udGludWU7XG5cbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHN0eWxlTGF5ZXIudHlwZSA9PT0gJ2NpcmNsZScpIHtcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNsYXRlZFBvbHlnb24gPSB0cmFuc2xhdGUocXVlcnlHZW9tZXRyeSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYWludFsnY2lyY2xlLXRyYW5zbGF0ZSddLCBwYWludFsnY2lyY2xlLXRyYW5zbGF0ZS1hbmNob3InXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiZWFyaW5nLCBwaXhlbHNUb1RpbGVVbml0cyk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjaXJjbGVSYWRpdXMgPSBwYWludFsnY2lyY2xlLXJhZGl1cyddICogcGl4ZWxzVG9UaWxlVW5pdHM7XG4gICAgICAgICAgICAgICAgICAgIGlmICghbXVsdGlQb2x5Z29uSW50ZXJzZWN0c0J1ZmZlcmVkTXVsdGlQb2ludCh0cmFuc2xhdGVkUG9seWdvbiwgZ2VvbWV0cnksIGNpcmNsZVJhZGl1cykpIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGdlb2pzb25GZWF0dXJlID0gbmV3IEdlb0pTT05GZWF0dXJlKGZlYXR1cmUsIHRoaXMueiwgdGhpcy54LCB0aGlzLnkpO1xuICAgICAgICAgICAgZ2VvanNvbkZlYXR1cmUubGF5ZXIgPSBzdHlsZUxheWVyLnNlcmlhbGl6ZSh7XG4gICAgICAgICAgICAgICAgaW5jbHVkZVJlZlByb3BlcnRpZXM6IHRydWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdmFyIGxheWVyUmVzdWx0ID0gcmVzdWx0W2xheWVySURdO1xuICAgICAgICAgICAgaWYgKGxheWVyUmVzdWx0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBsYXllclJlc3VsdCA9IHJlc3VsdFtsYXllcklEXSA9IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGF5ZXJSZXN1bHQucHVzaChnZW9qc29uRmVhdHVyZSk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5mdW5jdGlvbiB0cmFuc2xhdGUocXVlcnlHZW9tZXRyeSwgdHJhbnNsYXRlLCB0cmFuc2xhdGVBbmNob3IsIGJlYXJpbmcsIHBpeGVsc1RvVGlsZVVuaXRzKSB7XG4gICAgaWYgKCF0cmFuc2xhdGVbMF0gJiYgIXRyYW5zbGF0ZVsxXSkge1xuICAgICAgICByZXR1cm4gcXVlcnlHZW9tZXRyeTtcbiAgICB9XG5cbiAgICB0cmFuc2xhdGUgPSBQb2ludC5jb252ZXJ0KHRyYW5zbGF0ZSk7XG5cbiAgICBpZiAodHJhbnNsYXRlQW5jaG9yID09PSBcInZpZXdwb3J0XCIpIHtcbiAgICAgICAgdHJhbnNsYXRlLl9yb3RhdGUoLWJlYXJpbmcpO1xuICAgIH1cblxuICAgIHZhciB0cmFuc2xhdGVkID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBxdWVyeUdlb21ldHJ5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciByaW5nID0gcXVlcnlHZW9tZXRyeVtpXTtcbiAgICAgICAgdmFyIHRyYW5zbGF0ZWRSaW5nID0gW107XG4gICAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgcmluZy5sZW5ndGg7IGsrKykge1xuICAgICAgICAgICAgdHJhbnNsYXRlZFJpbmcucHVzaChyaW5nW2tdLnN1Yih0cmFuc2xhdGUuX211bHQocGl4ZWxzVG9UaWxlVW5pdHMpKSk7XG4gICAgICAgIH1cbiAgICAgICAgdHJhbnNsYXRlZC5wdXNoKHRyYW5zbGF0ZWRSaW5nKTtcbiAgICB9XG4gICAgcmV0dXJuIHRyYW5zbGF0ZWQ7XG59XG5cbmZ1bmN0aW9uIG9mZnNldExpbmUocmluZ3MsIG9mZnNldCkge1xuICAgIHZhciBuZXdSaW5ncyA9IFtdO1xuICAgIHZhciB6ZXJvID0gbmV3IFBvaW50KDAsIDApO1xuICAgIGZvciAodmFyIGsgPSAwOyBrIDwgcmluZ3MubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgdmFyIHJpbmcgPSByaW5nc1trXTtcbiAgICAgICAgdmFyIG5ld1JpbmcgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByaW5nLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgYSA9IHJpbmdbaSAtIDFdO1xuICAgICAgICAgICAgdmFyIGIgPSByaW5nW2ldO1xuICAgICAgICAgICAgdmFyIGMgPSByaW5nW2kgKyAxXTtcbiAgICAgICAgICAgIHZhciBhVG9CID0gaSA9PT0gMCA/IHplcm8gOiBiLnN1YihhKS5fdW5pdCgpLl9wZXJwKCk7XG4gICAgICAgICAgICB2YXIgYlRvQyA9IGkgPT09IHJpbmcubGVuZ3RoIC0gMSA/IHplcm8gOiBjLnN1YihiKS5fdW5pdCgpLl9wZXJwKCk7XG4gICAgICAgICAgICB2YXIgZXh0cnVkZSA9IGFUb0IuX2FkZChiVG9DKS5fdW5pdCgpO1xuXG4gICAgICAgICAgICB2YXIgY29zSGFsZkFuZ2xlID0gZXh0cnVkZS54ICogYlRvQy54ICsgZXh0cnVkZS55ICogYlRvQy55O1xuICAgICAgICAgICAgZXh0cnVkZS5fbXVsdCgxIC8gY29zSGFsZkFuZ2xlKTtcblxuICAgICAgICAgICAgbmV3UmluZy5wdXNoKGV4dHJ1ZGUuX211bHQob2Zmc2V0KS5fYWRkKGIpKTtcbiAgICAgICAgfVxuICAgICAgICBuZXdSaW5ncy5wdXNoKG5ld1JpbmcpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3UmluZ3M7XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBFWFRFTlQgPSByZXF1aXJlKCcuL2J1Y2tldCcpLkVYVEVOVDtcblxuLyoqXG4gKiBMb2FkcyBhIGdlb21ldHJ5IGZyb20gYSBWZWN0b3JUaWxlRmVhdHVyZSBhbmQgc2NhbGVzIGl0IHRvIHRoZSBjb21tb24gZXh0ZW50XG4gKiB1c2VkIGludGVybmFsbHkuXG4gKiBAcHJpdmF0ZVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGxvYWRHZW9tZXRyeShmZWF0dXJlKSB7XG4gICAgdmFyIHNjYWxlID0gRVhURU5UIC8gZmVhdHVyZS5leHRlbnQ7XG4gICAgdmFyIGdlb21ldHJ5ID0gZmVhdHVyZS5sb2FkR2VvbWV0cnkoKTtcbiAgICBmb3IgKHZhciByID0gMDsgciA8IGdlb21ldHJ5Lmxlbmd0aDsgcisrKSB7XG4gICAgICAgIHZhciByaW5nID0gZ2VvbWV0cnlbcl07XG4gICAgICAgIGZvciAodmFyIHAgPSAwOyBwIDwgcmluZy5sZW5ndGg7IHArKykge1xuICAgICAgICAgICAgdmFyIHBvaW50ID0gcmluZ1twXTtcbiAgICAgICAgICAgIC8vIHJvdW5kIGhlcmUgYmVjYXVzZSBtYXBib3gtZ2wtbmF0aXZlIHVzZXMgaW50ZWdlcnMgdG8gcmVwcmVzZW50XG4gICAgICAgICAgICAvLyBwb2ludHMgYW5kIHdlIG5lZWQgdG8gZG8gdGhlIHNhbWUgdG8gYXZvaWQgcmVuZXJpbmcgZGlmZmVyZW5jZXMuXG4gICAgICAgICAgICBwb2ludC54ID0gTWF0aC5yb3VuZChwb2ludC54ICogc2NhbGUpO1xuICAgICAgICAgICAgcG9pbnQueSA9IE1hdGgucm91bmQocG9pbnQueSAqIHNjYWxlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZ2VvbWV0cnk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IENvb3JkaW5hdGU7XG5cbi8qKlxuICogQSBjb29yZGluYXRlIGlzIGEgY29sdW1uLCByb3csIHpvb20gY29tYmluYXRpb24sIG9mdGVuIHVzZWRcbiAqIGFzIHRoZSBkYXRhIGNvbXBvbmVudCBvZiBhIHRpbGUuXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IGNvbHVtblxuICogQHBhcmFtIHtudW1iZXJ9IHJvd1xuICogQHBhcmFtIHtudW1iZXJ9IHpvb21cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIENvb3JkaW5hdGUoY29sdW1uLCByb3csIHpvb20pIHtcbiAgICB0aGlzLmNvbHVtbiA9IGNvbHVtbjtcbiAgICB0aGlzLnJvdyA9IHJvdztcbiAgICB0aGlzLnpvb20gPSB6b29tO1xufVxuXG5Db29yZGluYXRlLnByb3RvdHlwZSA9IHtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIGNsb25lIG9mIHRoaXMgY29vcmRpbmF0ZSB0aGF0IGNhbiBiZSBtdXRhdGVkIHdpdGhvdXRcbiAgICAgKiBjaGFuZ2luZyB0aGUgb3JpZ2luYWwgY29vcmRpbmF0ZVxuICAgICAqXG4gICAgICogQHJldHVybnMge0Nvb3JkaW5hdGV9IGNsb25lXG4gICAgICogQHByaXZhdGVcbiAgICAgKiB2YXIgY29vcmQgPSBuZXcgQ29vcmRpbmF0ZSgwLCAwLCAwKTtcbiAgICAgKiB2YXIgYzIgPSBjb29yZC5jbG9uZSgpO1xuICAgICAqIC8vIHNpbmNlIGNvb3JkIGlzIGNsb25lZCwgbW9kaWZ5aW5nIGEgcHJvcGVydHkgb2YgYzIgZG9lc1xuICAgICAqIC8vIG5vdCBtb2RpZnkgaXQuXG4gICAgICogYzIuem9vbSA9IDI7XG4gICAgICovXG4gICAgY2xvbmU6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gbmV3IENvb3JkaW5hdGUodGhpcy5jb2x1bW4sIHRoaXMucm93LCB0aGlzLnpvb20pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBab29tIHRoaXMgY29vcmRpbmF0ZSB0byBhIGdpdmVuIHpvb20gbGV2ZWwuIFRoaXMgcmV0dXJucyBhIG5ld1xuICAgICAqIGNvb3JkaW5hdGUgb2JqZWN0LCBub3QgbXV0YXRpbmcgdGhlIG9sZCBvbmUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gem9vbVxuICAgICAqIEByZXR1cm5zIHtDb29yZGluYXRlfSB6b29tZWQgY29vcmRpbmF0ZVxuICAgICAqIEBwcml2YXRlXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiB2YXIgY29vcmQgPSBuZXcgQ29vcmRpbmF0ZSgwLCAwLCAwKTtcbiAgICAgKiB2YXIgYzIgPSBjb29yZC56b29tVG8oMSk7XG4gICAgICogYzIgLy8gZXF1YWxzIG5ldyBDb29yZGluYXRlKDAsIDAsIDEpO1xuICAgICAqL1xuICAgIHpvb21UbzogZnVuY3Rpb24oem9vbSkgeyByZXR1cm4gdGhpcy5jbG9uZSgpLl96b29tVG8oem9vbSk7IH0sXG5cbiAgICAvKipcbiAgICAgKiBTdWJ0cmFjdCB0aGUgY29sdW1uIGFuZCByb3cgdmFsdWVzIG9mIHRoaXMgY29vcmRpbmF0ZSBmcm9tIHRob3NlXG4gICAgICogb2YgYW5vdGhlciBjb29yZGluYXRlLiBUaGUgb3RoZXIgY29vcmRpbmF0IHdpbGwgYmUgem9vbWVkIHRvIHRoZVxuICAgICAqIHNhbWUgbGV2ZWwgYXMgYHRoaXNgIGJlZm9yZSB0aGUgc3VidHJhY3Rpb24gb2NjdXJzXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0Nvb3JkaW5hdGV9IGMgb3RoZXIgY29vcmRpbmF0ZVxuICAgICAqIEByZXR1cm5zIHtDb29yZGluYXRlfSByZXN1bHRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHN1YjogZnVuY3Rpb24oYykgeyByZXR1cm4gdGhpcy5jbG9uZSgpLl9zdWIoYyk7IH0sXG5cbiAgICBfem9vbVRvOiBmdW5jdGlvbih6b29tKSB7XG4gICAgICAgIHZhciBzY2FsZSA9IE1hdGgucG93KDIsIHpvb20gLSB0aGlzLnpvb20pO1xuICAgICAgICB0aGlzLmNvbHVtbiAqPSBzY2FsZTtcbiAgICAgICAgdGhpcy5yb3cgKj0gc2NhbGU7XG4gICAgICAgIHRoaXMuem9vbSA9IHpvb207XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBfc3ViOiBmdW5jdGlvbihjKSB7XG4gICAgICAgIGMgPSBjLnpvb21Ubyh0aGlzLnpvb20pO1xuICAgICAgICB0aGlzLmNvbHVtbiAtPSBjLmNvbHVtbjtcbiAgICAgICAgdGhpcy5yb3cgLT0gYy5yb3c7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gTG5nTGF0O1xuXG52YXIgd3JhcCA9IHJlcXVpcmUoJy4uL3V0aWwvdXRpbCcpLndyYXA7XG5cbi8qKlxuICogQ3JlYXRlIGEgbG9uZ2l0dWRlLCBsYXRpdHVkZSBvYmplY3QgZnJvbSBhIGdpdmVuIGxvbmdpdHVkZSBhbmQgbGF0aXR1ZGUgcGFpciBpbiBkZWdyZWVzLlxuICogTWFwYm94IEdMIHVzZXMgTG9uZ2l0dWRlLCBMYXRpdHVkZSBjb29yZGluYXRlIG9yZGVyIHRvIG1hdGNoIEdlb0pTT04uXG4gKlxuICogTm90ZSB0aGF0IGFueSBNYXBib3ggR0wgbWV0aG9kIHRoYXQgYWNjZXB0cyBhIGBMbmdMYXRgIG9iamVjdCBjYW4gYWxzbyBhY2NlcHQgYW5cbiAqIGBBcnJheWAgYW5kIHdpbGwgcGVyZm9ybSBhbiBpbXBsaWNpdCBjb252ZXJzaW9uLiAgVGhlIGZvbGxvd2luZyBsaW5lcyBhcmUgZXF1aXZhbGVudDpcbiBgYGBcbiBtYXAuc2V0Q2VudGVyKFstNzMuOTc0OSwgNDAuNzczNl0pO1xuIG1hcC5zZXRDZW50ZXIoIG5ldyBtYXBib3hnbC5MbmdMYXQoLTczLjk3NDksIDQwLjc3MzYpICk7XG4gYGBgXG4gKlxuICogQGNsYXNzIExuZ0xhdFxuICogQGNsYXNzZGVzYyBBIHJlcHJlc2VudGF0aW9uIG9mIGEgbG9uZ2l0dWRlLCBsYXRpdHVkZSBwb2ludCwgaW4gZGVncmVlcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBsbmcgbG9uZ2l0dWRlXG4gKiBAcGFyYW0ge251bWJlcn0gbGF0IGxhdGl0dWRlXG4gKiBAZXhhbXBsZVxuICogdmFyIGxsID0gbmV3IG1hcGJveGdsLkxuZ0xhdCgtNzMuOTc0OSwgNDAuNzczNik7XG4gKi9cbmZ1bmN0aW9uIExuZ0xhdChsbmcsIGxhdCkge1xuICAgIGlmIChpc05hTihsbmcpIHx8IGlzTmFOKGxhdCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIExuZ0xhdCBvYmplY3Q6ICgnICsgbG5nICsgJywgJyArIGxhdCArICcpJyk7XG4gICAgfVxuICAgIHRoaXMubG5nID0gK2xuZztcbiAgICB0aGlzLmxhdCA9ICtsYXQ7XG4gICAgaWYgKHRoaXMubGF0ID4gOTAgfHwgdGhpcy5sYXQgPCAtOTApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIExuZ0xhdCBsYXRpdHVkZSB2YWx1ZTogbXVzdCBiZSBiZXR3ZWVuIC05MCBhbmQgOTAnKTtcbiAgICB9XG59XG5cbi8qKlxuICogUmV0dXJuIGEgbmV3IGBMbmdMYXRgIG9iamVjdCB3aG9zZSBsb25naXR1ZGUgaXMgd3JhcHBlZCB0byB0aGUgcmFuZ2UgKC0xODAsIDE4MCkuXG4gKlxuICogQHJldHVybnMge0xuZ0xhdH0gd3JhcHBlZCBMbmdMYXQgb2JqZWN0XG4gKiBAZXhhbXBsZVxuICogdmFyIGxsID0gbmV3IG1hcGJveGdsLkxuZ0xhdCgyODYuMDI1MSwgNDAuNzczNik7XG4gKiB2YXIgd3JhcHBlZCA9IGxsLndyYXAoKTtcbiAqIHdyYXBwZWQubG5nOyAvLyA9IC03My45NzQ5XG4gKi9cbkxuZ0xhdC5wcm90b3R5cGUud3JhcCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gbmV3IExuZ0xhdCh3cmFwKHRoaXMubG5nLCAtMTgwLCAxODApLCB0aGlzLmxhdCk7XG59O1xuXG4vKipcbiAqIFJldHVybiBhIGBMbmdMYXRgIGFzIGFuIGFycmF5XG4gKlxuICogQHJldHVybnMge2FycmF5fSBbbG5nLCBsYXRdXG4gKiBAZXhhbXBsZVxuICogdmFyIGxsID0gbmV3IG1hcGJveGdsLkxuZ0xhdCgtNzMuOTc0OSwgNDAuNzczNik7XG4gKiBsbC50b0FycmF5KCk7IC8vID0gWy03My45NzQ5LCA0MC43NzM2XVxuICovXG5MbmdMYXQucHJvdG90eXBlLnRvQXJyYXkgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIFt0aGlzLmxuZywgdGhpcy5sYXRdO1xufTtcblxuLyoqXG4gKiBSZXR1cm4gYSBgTG5nTGF0YCBhcyBhIHN0cmluZ1xuICpcbiAqIEByZXR1cm5zIHtzdHJpbmd9IFwiTG5nTGF0KGxuZywgbGF0KVwiXG4gKiBAZXhhbXBsZVxuICogdmFyIGxsID0gbmV3IG1hcGJveGdsLkxuZ0xhdCgtNzMuOTc0OSwgNDAuNzczNik7XG4gKiBsbC50b1N0cmluZygpOyAvLyA9IFwiTG5nTGF0KC03My45NzQ5LCA0MC43NzM2KVwiXG4gKi9cbkxuZ0xhdC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuICdMbmdMYXQoJyArIHRoaXMubG5nICsgJywgJyArIHRoaXMubGF0ICsgJyknO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0IGFuIGFycmF5IHRvIGEgYExuZ0xhdGAgb2JqZWN0LCBvciByZXR1cm4gYW4gZXhpc3RpbmcgYExuZ0xhdGAgb2JqZWN0XG4gKiB1bmNoYW5nZWQuXG4gKlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fExuZ0xhdH0gaW5wdXQgYGlucHV0YCB0byBjb252ZXJ0XG4gKiBAcmV0dXJucyB7TG5nTGF0fSBMbmdMYXQgb2JqZWN0IG9yIG9yaWdpbmFsIGlucHV0XG4gKiBAZXhhbXBsZVxuICogdmFyIGFyciA9IFstNzMuOTc0OSwgNDAuNzczNl07XG4gKiB2YXIgbGwgPSBtYXBib3hnbC5MbmdMYXQuY29udmVydChhcnIpO1xuICogbGw7ICAgLy8gPSBMbmdMYXQge2xuZzogLTczLjk3NDksIGxhdDogNDAuNzczNn1cbiAqL1xuTG5nTGF0LmNvbnZlcnQgPSBmdW5jdGlvbiAoaW5wdXQpIHtcbiAgICBpZiAoaW5wdXQgaW5zdGFuY2VvZiBMbmdMYXQpIHtcbiAgICAgICAgcmV0dXJuIGlucHV0O1xuICAgIH1cbiAgICBpZiAoQXJyYXkuaXNBcnJheShpbnB1dCkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBMbmdMYXQoaW5wdXRbMF0sIGlucHV0WzFdKTtcbiAgICB9XG4gICAgcmV0dXJuIGlucHV0O1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBMbmdMYXRCb3VuZHM7XG5cbnZhciBMbmdMYXQgPSByZXF1aXJlKCcuL2xuZ19sYXQnKTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgYm91bmRpbmcgYm94IGZyb20gdGhlIGdpdmVuIHBhaXIgb2YgcG9pbnRzLiBJZiBwYXJhbWV0ZXJlcyBhcmUgb21pdHRlZCwgYSBgbnVsbGAgYm91bmRpbmcgYm94IGlzIGNyZWF0ZWQuXG4gKlxuICogQGNsYXNzIExuZ0xhdEJvdW5kc1xuICogQGNsYXNzZGVzYyBBIHJlcHJlc2VudGF0aW9uIG9mIHJlY3Rhbmd1bGFyIGJveCBvbiB0aGUgZWFydGgsIGRlZmluZWQgYnkgaXRzIHNvdXRod2VzdCBhbmQgbm9ydGhlYXN0IHBvaW50cyBpbiBsb25naXR1ZGUgYW5kIGxhdGl0dWRlLlxuICogQHBhcmFtIHtMbmdMYXR9IHN3IHNvdXRod2VzdFxuICogQHBhcmFtIHtMbmdMYXR9IG5lIG5vcnRoZWFzdFxuICogQGV4YW1wbGVcbiAqIHZhciBzdyA9IG5ldyBtYXBib3hnbC5MbmdMYXQoLTczLjk4NzYsIDQwLjc2NjEpO1xuICogdmFyIG5lID0gbmV3IG1hcGJveGdsLkxuZ0xhdCgtNzMuOTM5NywgNDAuODAwMik7XG4gKiB2YXIgbGxiID0gbmV3IG1hcGJveGdsLkxuZ0xhdEJvdW5kcyhzdywgbmUpO1xuICovXG5mdW5jdGlvbiBMbmdMYXRCb3VuZHMoc3csIG5lKSB7XG4gICAgaWYgKCFzdykge1xuICAgICAgICByZXR1cm47XG4gICAgfSBlbHNlIGlmIChuZSkge1xuICAgICAgICB0aGlzLmV4dGVuZChzdykuZXh0ZW5kKG5lKTtcbiAgICB9IGVsc2UgaWYgKHN3Lmxlbmd0aCA9PT0gNCkge1xuICAgICAgICB0aGlzLmV4dGVuZChbc3dbMF0sIHN3WzFdXSkuZXh0ZW5kKFtzd1syXSwgc3dbM11dKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmV4dGVuZChzd1swXSkuZXh0ZW5kKHN3WzFdKTtcbiAgICB9XG59XG5cbkxuZ0xhdEJvdW5kcy5wcm90b3R5cGUgPSB7XG5cbiAgICAvKipcbiAgICAgKiBFeHRlbmQgdGhlIGJvdW5kcyB0byBpbmNsdWRlIGEgZ2l2ZW4gTG5nTGF0IG9yIExuZ0xhdEJvdW5kcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7TG5nTGF0fExuZ0xhdEJvdW5kc30gb2JqIG9iamVjdCB0byBleHRlbmQgdG9cbiAgICAgKiBAcmV0dXJucyB7TG5nTGF0Qm91bmRzfSBgdGhpc2BcbiAgICAgKi9cbiAgICBleHRlbmQ6IGZ1bmN0aW9uKG9iaikge1xuICAgICAgICB2YXIgc3cgPSB0aGlzLl9zdyxcbiAgICAgICAgICAgIG5lID0gdGhpcy5fbmUsXG4gICAgICAgICAgICBzdzIsIG5lMjtcblxuICAgICAgICBpZiAob2JqIGluc3RhbmNlb2YgTG5nTGF0KSB7XG4gICAgICAgICAgICBzdzIgPSBvYmo7XG4gICAgICAgICAgICBuZTIgPSBvYmo7XG5cbiAgICAgICAgfSBlbHNlIGlmIChvYmogaW5zdGFuY2VvZiBMbmdMYXRCb3VuZHMpIHtcbiAgICAgICAgICAgIHN3MiA9IG9iai5fc3c7XG4gICAgICAgICAgICBuZTIgPSBvYmouX25lO1xuXG4gICAgICAgICAgICBpZiAoIXN3MiB8fCAhbmUyKSByZXR1cm4gdGhpcztcblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG9iaiA/IHRoaXMuZXh0ZW5kKExuZ0xhdC5jb252ZXJ0KG9iaikgfHwgTG5nTGF0Qm91bmRzLmNvbnZlcnQob2JqKSkgOiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFzdyAmJiAhbmUpIHtcbiAgICAgICAgICAgIHRoaXMuX3N3ID0gbmV3IExuZ0xhdChzdzIubG5nLCBzdzIubGF0KTtcbiAgICAgICAgICAgIHRoaXMuX25lID0gbmV3IExuZ0xhdChuZTIubG5nLCBuZTIubGF0KTtcblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3cubG5nID0gTWF0aC5taW4oc3cyLmxuZywgc3cubG5nKTtcbiAgICAgICAgICAgIHN3LmxhdCA9IE1hdGgubWluKHN3Mi5sYXQsIHN3LmxhdCk7XG4gICAgICAgICAgICBuZS5sbmcgPSBNYXRoLm1heChuZTIubG5nLCBuZS5sbmcpO1xuICAgICAgICAgICAgbmUubGF0ID0gTWF0aC5tYXgobmUyLmxhdCwgbmUubGF0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIHBvaW50IGVxdWlkaXN0YW50IGZyb20gdGhpcyBib3gncyBjb3JuZXJzXG4gICAgICogQHJldHVybnMge0xuZ0xhdH0gY2VudGVycG9pbnRcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIHZhciBsbGIgPSBuZXcgbWFwYm94Z2wuTG5nTGF0Qm91bmRzKFstNzMuOTg3NiwgNDAuNzY2MV0sIFstNzMuOTM5NywgNDAuODAwMl0pO1xuICAgICAqIGxsYi5nZXRDZW50ZXIoKTsgLy8gPSBMbmdMYXQge2xuZzogLTczLjk2MzY1LCBsYXQ6IDQwLjc4MzE1fVxuICAgICAqL1xuICAgIGdldENlbnRlcjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBuZXcgTG5nTGF0KCh0aGlzLl9zdy5sbmcgKyB0aGlzLl9uZS5sbmcpIC8gMiwgKHRoaXMuX3N3LmxhdCArIHRoaXMuX25lLmxhdCkgLyAyKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0IHNvdXRod2VzdCBjb3JuZXJcbiAgICAgKiBAcmV0dXJucyB7TG5nTGF0fSBzb3V0aHdlc3RcbiAgICAgKi9cbiAgICBnZXRTb3V0aFdlc3Q6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5fc3c7IH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgbm9ydGhlYXN0IGNvcm5lclxuICAgICAqIEByZXR1cm5zIHtMbmdMYXR9IG5vcnRoZWFzdFxuICAgICAqL1xuICAgIGdldE5vcnRoRWFzdDogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLl9uZTsgfSxcblxuICAgIC8qKlxuICAgICAqIEdldCBub3J0aHdlc3QgY29ybmVyXG4gICAgICogQHJldHVybnMge0xuZ0xhdH0gbm9ydGh3ZXN0XG4gICAgICovXG4gICAgZ2V0Tm9ydGhXZXN0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG5ldyBMbmdMYXQodGhpcy5nZXRXZXN0KCksIHRoaXMuZ2V0Tm9ydGgoKSk7IH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgc291dGhlYXN0IGNvcm5lclxuICAgICAqIEByZXR1cm5zIHtMbmdMYXR9IHNvdXRoZWFzdFxuICAgICAqL1xuICAgIGdldFNvdXRoRWFzdDogZnVuY3Rpb24oKSB7IHJldHVybiBuZXcgTG5nTGF0KHRoaXMuZ2V0RWFzdCgpLCB0aGlzLmdldFNvdXRoKCkpOyB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0IHdlc3QgZWRnZSBsb25naXR1ZGVcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSB3ZXN0XG4gICAgICovXG4gICAgZ2V0V2VzdDogIGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5fc3cubG5nOyB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0IHNvdXRoIGVkZ2UgbGF0aXR1ZGVcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBzb3V0aFxuICAgICAqL1xuICAgIGdldFNvdXRoOiBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMuX3N3LmxhdDsgfSxcblxuICAgIC8qKlxuICAgICAqIEdldCBlYXN0IGVkZ2UgbG9uZ2l0dWRlXG4gICAgICogQHJldHVybnMge251bWJlcn0gZWFzdFxuICAgICAqL1xuICAgIGdldEVhc3Q6ICBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMuX25lLmxuZzsgfSxcblxuICAgIC8qKlxuICAgICAqIEdldCBub3J0aCBlZGdlIGxhdGl0dWRlXG4gICAgICogQHJldHVybnMge251bWJlcn0gbm9ydGhcbiAgICAgKi9cbiAgICBnZXROb3J0aDogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLl9uZS5sYXQ7IH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gYSBgTG5nTGF0Qm91bmRzYCBhcyBhbiBhcnJheVxuICAgICAqXG4gICAgICogQHJldHVybnMge2FycmF5fSBbbG5nLCBsYXRdXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiB2YXIgbGxiID0gbmV3IG1hcGJveGdsLkxuZ0xhdEJvdW5kcyhbLTczLjk4NzYsIDQwLjc2NjFdLCBbLTczLjkzOTcsIDQwLjgwMDJdKTtcbiAgICAgKiBsbGIudG9BcnJheSgpOyAvLyA9IFtbLTczLjk4NzYsIDQwLjc2NjFdLCBbLTczLjkzOTcsIDQwLjgwMDJdXVxuICAgICAqL1xuICAgIHRvQXJyYXk6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFt0aGlzLl9zdy50b0FycmF5KCksIHRoaXMuX25lLnRvQXJyYXkoKV07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybiBhIGBMbmdMYXRCb3VuZHNgIGFzIGEgc3RyaW5nXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBcIkxuZ0xhdEJvdW5kcyhMbmdMYXQobG5nLCBsYXQpLCBMbmdMYXQobG5nLCBsYXQpKVwiXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiB2YXIgbGxiID0gbmV3IG1hcGJveGdsLkxuZ0xhdEJvdW5kcyhbLTczLjk4NzYsIDQwLjc2NjFdLCBbLTczLjkzOTcsIDQwLjgwMDJdKTtcbiAgICAgKiBsbGIudG9TdHJpbmcoKTsgLy8gPSBcIkxuZ0xhdEJvdW5kcyhMbmdMYXQoLTczLjk4NzYsIDQwLjc2NjEpLCBMbmdMYXQoLTczLjkzOTcsIDQwLjgwMDIpKVwiXG4gICAgICovXG4gICAgdG9TdHJpbmc6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICdMbmdMYXRCb3VuZHMoJyArIHRoaXMuX3N3LnRvU3RyaW5nKCkgKyAnLCAnICsgdGhpcy5fbmUudG9TdHJpbmcoKSArICcpJztcbiAgICB9XG59O1xuXG4vKipcbiAqIENvbnZlcnQgYW4gYXJyYXkgdG8gYSBgTG5nTGF0Qm91bmRzYCBvYmplY3QsIG9yIHJldHVybiBhbiBleGlzdGluZ1xuICogYExuZ0xhdEJvdW5kc2Agb2JqZWN0IHVuY2hhbmdlZC5cbiAqXG4gKiBDYWxscyBgTG5nTGF0I2NvbnZlcnRgIGludGVybmFsbHkgdG8gY29udmVydCBhcnJheXMgYXMgYExuZ0xhdGAgdmFsdWVzLlxuICpcbiAqIEBwYXJhbSB7TG5nTGF0Qm91bmRzfEFycmF5PG51bWJlcj58QXJyYXk8QXJyYXk8bnVtYmVyPj59IGlucHV0IGlucHV0IHRvIGNvbnZlcnQgdG8gYSBMbmdMYXRCb3VuZHNcbiAqIEByZXR1cm5zIHtMbmdMYXRCb3VuZHN9IExuZ0xhdEJvdW5kcyBvYmplY3Qgb3Igb3JpZ2luYWwgaW5wdXRcbiAqIEBleGFtcGxlXG4gKiB2YXIgYXJyID0gW1stNzMuOTg3NiwgNDAuNzY2MV0sIFstNzMuOTM5NywgNDAuODAwMl1dO1xuICogdmFyIGxsYiA9IG1hcGJveGdsLkxuZ0xhdEJvdW5kcy5jb252ZXJ0KGFycik7XG4gKiBsbGI7ICAgLy8gPSBMbmdMYXRCb3VuZHMge19zdzogTG5nTGF0IHtsbmc6IC03My45ODc2LCBsYXQ6IDQwLjc2NjF9LCBfbmU6IExuZ0xhdCB7bG5nOiAtNzMuOTM5NywgbGF0OiA0MC44MDAyfX1cbiAqL1xuTG5nTGF0Qm91bmRzLmNvbnZlcnQgPSBmdW5jdGlvbiAoaW5wdXQpIHtcbiAgICBpZiAoIWlucHV0IHx8IGlucHV0IGluc3RhbmNlb2YgTG5nTGF0Qm91bmRzKSByZXR1cm4gaW5wdXQ7XG4gICAgcmV0dXJuIG5ldyBMbmdMYXRCb3VuZHMoaW5wdXQpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIExuZ0xhdCA9IHJlcXVpcmUoJy4vbG5nX2xhdCcpLFxuICAgIFBvaW50ID0gcmVxdWlyZSgncG9pbnQtZ2VvbWV0cnknKSxcbiAgICBDb29yZGluYXRlID0gcmVxdWlyZSgnLi9jb29yZGluYXRlJyksXG4gICAgd3JhcCA9IHJlcXVpcmUoJy4uL3V0aWwvdXRpbCcpLndyYXAsXG4gICAgaW50ZXJwID0gcmVxdWlyZSgnLi4vdXRpbC9pbnRlcnBvbGF0ZScpLFxuICAgIGdsbWF0cml4ID0gcmVxdWlyZSgnZ2wtbWF0cml4Jyk7XG5cbnZhciB2ZWM0ID0gZ2xtYXRyaXgudmVjNCxcbiAgICBtYXQ0ID0gZ2xtYXRyaXgubWF0NCxcbiAgICBtYXQyID0gZ2xtYXRyaXgubWF0MjtcblxubW9kdWxlLmV4cG9ydHMgPSBUcmFuc2Zvcm07XG5cbi8qKlxuICogQSBzaW5nbGUgdHJhbnNmb3JtLCBnZW5lcmFsbHkgdXNlZCBmb3IgYSBzaW5nbGUgdGlsZSB0byBiZVxuICogc2NhbGVkLCByb3RhdGVkLCBhbmQgem9vbWVkLlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBtaW5ab29tXG4gKiBAcGFyYW0ge251bWJlcn0gbWF4Wm9vbVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gVHJhbnNmb3JtKG1pblpvb20sIG1heFpvb20pIHtcbiAgICB0aGlzLnRpbGVTaXplID0gNTEyOyAvLyBjb25zdGFudFxuXG4gICAgdGhpcy5fbWluWm9vbSA9IG1pblpvb20gfHwgMDtcbiAgICB0aGlzLl9tYXhab29tID0gbWF4Wm9vbSB8fCAyMjtcblxuICAgIHRoaXMubGF0UmFuZ2UgPSBbLTg1LjA1MTEzLCA4NS4wNTExM107XG5cbiAgICB0aGlzLndpZHRoID0gMDtcbiAgICB0aGlzLmhlaWdodCA9IDA7XG4gICAgdGhpcy5fY2VudGVyID0gbmV3IExuZ0xhdCgwLCAwKTtcbiAgICB0aGlzLnpvb20gPSAwO1xuICAgIHRoaXMuYW5nbGUgPSAwO1xuICAgIHRoaXMuX2FsdGl0dWRlID0gMS41O1xuICAgIHRoaXMuX3BpdGNoID0gMDtcbiAgICB0aGlzLl91bm1vZGlmaWVkID0gdHJ1ZTtcbn1cblxuVHJhbnNmb3JtLnByb3RvdHlwZSA9IHtcbiAgICBnZXQgbWluWm9vbSgpIHsgcmV0dXJuIHRoaXMuX21pblpvb207IH0sXG4gICAgc2V0IG1pblpvb20oem9vbSkge1xuICAgICAgICBpZiAodGhpcy5fbWluWm9vbSA9PT0gem9vbSkgcmV0dXJuO1xuICAgICAgICB0aGlzLl9taW5ab29tID0gem9vbTtcbiAgICAgICAgdGhpcy56b29tID0gTWF0aC5tYXgodGhpcy56b29tLCB6b29tKTtcbiAgICB9LFxuXG4gICAgZ2V0IG1heFpvb20oKSB7IHJldHVybiB0aGlzLl9tYXhab29tOyB9LFxuICAgIHNldCBtYXhab29tKHpvb20pIHtcbiAgICAgICAgaWYgKHRoaXMuX21heFpvb20gPT09IHpvb20pIHJldHVybjtcbiAgICAgICAgdGhpcy5fbWF4Wm9vbSA9IHpvb207XG4gICAgICAgIHRoaXMuem9vbSA9IE1hdGgubWluKHRoaXMuem9vbSwgem9vbSk7XG4gICAgfSxcblxuICAgIGdldCB3b3JsZFNpemUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRpbGVTaXplICogdGhpcy5zY2FsZTtcbiAgICB9LFxuXG4gICAgZ2V0IGNlbnRlclBvaW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zaXplLl9kaXYoMik7XG4gICAgfSxcblxuICAgIGdldCBzaXplKCkge1xuICAgICAgICByZXR1cm4gbmV3IFBvaW50KHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcbiAgICB9LFxuXG4gICAgZ2V0IGJlYXJpbmcoKSB7XG4gICAgICAgIHJldHVybiAtdGhpcy5hbmdsZSAvIE1hdGguUEkgKiAxODA7XG4gICAgfSxcbiAgICBzZXQgYmVhcmluZyhiZWFyaW5nKSB7XG4gICAgICAgIHZhciBiID0gLXdyYXAoYmVhcmluZywgLTE4MCwgMTgwKSAqIE1hdGguUEkgLyAxODA7XG4gICAgICAgIGlmICh0aGlzLmFuZ2xlID09PSBiKSByZXR1cm47XG4gICAgICAgIHRoaXMuX3VubW9kaWZpZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5hbmdsZSA9IGI7XG4gICAgICAgIHRoaXMuX2NhbGNQcm9qTWF0cml4KCk7XG5cbiAgICAgICAgLy8gMngyIG1hdHJpeCBmb3Igcm90YXRpbmcgcG9pbnRzXG4gICAgICAgIHRoaXMucm90YXRpb25NYXRyaXggPSBtYXQyLmNyZWF0ZSgpO1xuICAgICAgICBtYXQyLnJvdGF0ZSh0aGlzLnJvdGF0aW9uTWF0cml4LCB0aGlzLnJvdGF0aW9uTWF0cml4LCB0aGlzLmFuZ2xlKTtcbiAgICB9LFxuXG4gICAgZ2V0IHBpdGNoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcGl0Y2ggLyBNYXRoLlBJICogMTgwO1xuICAgIH0sXG4gICAgc2V0IHBpdGNoKHBpdGNoKSB7XG4gICAgICAgIHZhciBwID0gTWF0aC5taW4oNjAsIHBpdGNoKSAvIDE4MCAqIE1hdGguUEk7XG4gICAgICAgIGlmICh0aGlzLl9waXRjaCA9PT0gcCkgcmV0dXJuO1xuICAgICAgICB0aGlzLl91bm1vZGlmaWVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX3BpdGNoID0gcDtcbiAgICAgICAgdGhpcy5fY2FsY1Byb2pNYXRyaXgoKTtcbiAgICB9LFxuXG4gICAgZ2V0IGFsdGl0dWRlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWx0aXR1ZGU7XG4gICAgfSxcbiAgICBzZXQgYWx0aXR1ZGUoYWx0aXR1ZGUpIHtcbiAgICAgICAgdmFyIGEgPSBNYXRoLm1heCgwLjc1LCBhbHRpdHVkZSk7XG4gICAgICAgIGlmICh0aGlzLl9hbHRpdHVkZSA9PT0gYSkgcmV0dXJuO1xuICAgICAgICB0aGlzLl91bm1vZGlmaWVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2FsdGl0dWRlID0gYTtcbiAgICAgICAgdGhpcy5fY2FsY1Byb2pNYXRyaXgoKTtcbiAgICB9LFxuXG4gICAgZ2V0IHpvb20oKSB7IHJldHVybiB0aGlzLl96b29tOyB9LFxuICAgIHNldCB6b29tKHpvb20pIHtcbiAgICAgICAgdmFyIHogPSBNYXRoLm1pbihNYXRoLm1heCh6b29tLCB0aGlzLm1pblpvb20pLCB0aGlzLm1heFpvb20pO1xuICAgICAgICBpZiAodGhpcy5fem9vbSA9PT0geikgcmV0dXJuO1xuICAgICAgICB0aGlzLl91bm1vZGlmaWVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX3pvb20gPSB6O1xuICAgICAgICB0aGlzLnNjYWxlID0gdGhpcy56b29tU2NhbGUoeik7XG4gICAgICAgIHRoaXMudGlsZVpvb20gPSBNYXRoLmZsb29yKHopO1xuICAgICAgICB0aGlzLnpvb21GcmFjdGlvbiA9IHogLSB0aGlzLnRpbGVab29tO1xuICAgICAgICB0aGlzLl9jYWxjUHJvak1hdHJpeCgpO1xuICAgICAgICB0aGlzLl9jb25zdHJhaW4oKTtcbiAgICB9LFxuXG4gICAgZ2V0IGNlbnRlcigpIHsgcmV0dXJuIHRoaXMuX2NlbnRlcjsgfSxcbiAgICBzZXQgY2VudGVyKGNlbnRlcikge1xuICAgICAgICBpZiAoY2VudGVyLmxhdCA9PT0gdGhpcy5fY2VudGVyLmxhdCAmJiBjZW50ZXIubG5nID09PSB0aGlzLl9jZW50ZXIubG5nKSByZXR1cm47XG4gICAgICAgIHRoaXMuX3VubW9kaWZpZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fY2VudGVyID0gY2VudGVyO1xuICAgICAgICB0aGlzLl9jYWxjUHJvak1hdHJpeCgpO1xuICAgICAgICB0aGlzLl9jb25zdHJhaW4oKTtcbiAgICB9LFxuXG4gICAgcmVzaXplOiBmdW5jdGlvbih3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgIHRoaXMud2lkdGggPSB3aWR0aDtcbiAgICAgICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG5cbiAgICAgICAgLy8gVGhlIGV4dHJ1c2lvbiBtYXRyaXhcbiAgICAgICAgdGhpcy5leE1hdHJpeCA9IG1hdDQuY3JlYXRlKCk7XG4gICAgICAgIG1hdDQub3J0aG8odGhpcy5leE1hdHJpeCwgMCwgd2lkdGgsIGhlaWdodCwgMCwgMCwgLTEpO1xuXG4gICAgICAgIHRoaXMuX2NhbGNQcm9qTWF0cml4KCk7XG4gICAgICAgIHRoaXMuX2NvbnN0cmFpbigpO1xuICAgIH0sXG5cbiAgICBnZXQgdW5tb2RpZmllZCgpIHsgcmV0dXJuIHRoaXMuX3VubW9kaWZpZWQ7IH0sXG5cbiAgICB6b29tU2NhbGU6IGZ1bmN0aW9uKHpvb20pIHsgcmV0dXJuIE1hdGgucG93KDIsIHpvb20pOyB9LFxuICAgIHNjYWxlWm9vbTogZnVuY3Rpb24oc2NhbGUpIHsgcmV0dXJuIE1hdGgubG9nKHNjYWxlKSAvIE1hdGguTE4yOyB9LFxuXG4gICAgcHJvamVjdDogZnVuY3Rpb24obG5nbGF0LCB3b3JsZFNpemUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQb2ludChcbiAgICAgICAgICAgIHRoaXMubG5nWChsbmdsYXQubG5nLCB3b3JsZFNpemUpLFxuICAgICAgICAgICAgdGhpcy5sYXRZKGxuZ2xhdC5sYXQsIHdvcmxkU2l6ZSkpO1xuICAgIH0sXG5cbiAgICB1bnByb2plY3Q6IGZ1bmN0aW9uKHBvaW50LCB3b3JsZFNpemUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBMbmdMYXQoXG4gICAgICAgICAgICB0aGlzLnhMbmcocG9pbnQueCwgd29ybGRTaXplKSxcbiAgICAgICAgICAgIHRoaXMueUxhdChwb2ludC55LCB3b3JsZFNpemUpKTtcbiAgICB9LFxuXG4gICAgZ2V0IHgoKSB7IHJldHVybiB0aGlzLmxuZ1godGhpcy5jZW50ZXIubG5nKTsgfSxcbiAgICBnZXQgeSgpIHsgcmV0dXJuIHRoaXMubGF0WSh0aGlzLmNlbnRlci5sYXQpOyB9LFxuXG4gICAgZ2V0IHBvaW50KCkgeyByZXR1cm4gbmV3IFBvaW50KHRoaXMueCwgdGhpcy55KTsgfSxcblxuICAgIC8qKlxuICAgICAqIGxhdGl0dWRlIHRvIGFic29sdXRlIHggY29vcmRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbG9uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFt3b3JsZFNpemU9dGhpcy53b3JsZFNpemVdXG4gICAgICogQHJldHVybnMge251bWJlcn0gcGl4ZWwgY29vcmRpbmF0ZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgbG5nWDogZnVuY3Rpb24obG5nLCB3b3JsZFNpemUpIHtcbiAgICAgICAgcmV0dXJuICgxODAgKyBsbmcpICogKHdvcmxkU2l6ZSB8fCB0aGlzLndvcmxkU2l6ZSkgLyAzNjA7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBsYXRpdHVkZSB0byBhYnNvbHV0ZSB5IGNvb3JkXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGxhdFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbd29ybGRTaXplPXRoaXMud29ybGRTaXplXVxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IHBpeGVsIGNvb3JkaW5hdGVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGxhdFk6IGZ1bmN0aW9uKGxhdCwgd29ybGRTaXplKSB7XG4gICAgICAgIHZhciB5ID0gMTgwIC8gTWF0aC5QSSAqIE1hdGgubG9nKE1hdGgudGFuKE1hdGguUEkgLyA0ICsgbGF0ICogTWF0aC5QSSAvIDM2MCkpO1xuICAgICAgICByZXR1cm4gKDE4MCAtIHkpICogKHdvcmxkU2l6ZSB8fCB0aGlzLndvcmxkU2l6ZSkgLyAzNjA7XG4gICAgfSxcblxuICAgIHhMbmc6IGZ1bmN0aW9uKHgsIHdvcmxkU2l6ZSkge1xuICAgICAgICByZXR1cm4geCAqIDM2MCAvICh3b3JsZFNpemUgfHwgdGhpcy53b3JsZFNpemUpIC0gMTgwO1xuICAgIH0sXG4gICAgeUxhdDogZnVuY3Rpb24oeSwgd29ybGRTaXplKSB7XG4gICAgICAgIHZhciB5MiA9IDE4MCAtIHkgKiAzNjAgLyAod29ybGRTaXplIHx8IHRoaXMud29ybGRTaXplKTtcbiAgICAgICAgcmV0dXJuIDM2MCAvIE1hdGguUEkgKiBNYXRoLmF0YW4oTWF0aC5leHAoeTIgKiBNYXRoLlBJIC8gMTgwKSkgLSA5MDtcbiAgICB9LFxuXG4gICAgcGFuQnk6IGZ1bmN0aW9uKG9mZnNldCkge1xuICAgICAgICB2YXIgcG9pbnQgPSB0aGlzLmNlbnRlclBvaW50Ll9hZGQob2Zmc2V0KTtcbiAgICAgICAgdGhpcy5jZW50ZXIgPSB0aGlzLnBvaW50TG9jYXRpb24ocG9pbnQpO1xuICAgIH0sXG5cbiAgICBzZXRMb2NhdGlvbkF0UG9pbnQ6IGZ1bmN0aW9uKGxuZ2xhdCwgcG9pbnQpIHtcbiAgICAgICAgdmFyIGMgPSB0aGlzLmxvY2F0aW9uQ29vcmRpbmF0ZShsbmdsYXQpO1xuICAgICAgICB2YXIgY29vcmRBdFBvaW50ID0gdGhpcy5wb2ludENvb3JkaW5hdGUocG9pbnQpO1xuICAgICAgICB2YXIgY29vcmRDZW50ZXIgPSB0aGlzLnBvaW50Q29vcmRpbmF0ZSh0aGlzLmNlbnRlclBvaW50KTtcbiAgICAgICAgdmFyIHRyYW5zbGF0ZSA9IGNvb3JkQXRQb2ludC5fc3ViKGMpO1xuICAgICAgICB0aGlzLl91bm1vZGlmaWVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuY2VudGVyID0gdGhpcy5jb29yZGluYXRlTG9jYXRpb24oY29vcmRDZW50ZXIuX3N1Yih0cmFuc2xhdGUpKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2l2ZW4gYSBsb2NhdGlvbiwgcmV0dXJuIHRoZSBzY3JlZW4gcG9pbnQgdGhhdCBjb3JyZXNwb25kcyB0byBpdFxuICAgICAqIEBwYXJhbSB7TG5nTGF0fSBsbmdsYXQgbG9jYXRpb25cbiAgICAgKiBAcmV0dXJucyB7UG9pbnR9IHNjcmVlbiBwb2ludFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgbG9jYXRpb25Qb2ludDogZnVuY3Rpb24obG5nbGF0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvb3JkaW5hdGVQb2ludCh0aGlzLmxvY2F0aW9uQ29vcmRpbmF0ZShsbmdsYXQpKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2l2ZW4gYSBwb2ludCBvbiBzY3JlZW4sIHJldHVybiBpdHMgbG5nbGF0XG4gICAgICogQHBhcmFtIHtQb2ludH0gcCBzY3JlZW4gcG9pbnRcbiAgICAgKiBAcmV0dXJucyB7TG5nTGF0fSBsbmdsYXQgbG9jYXRpb25cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHBvaW50TG9jYXRpb246IGZ1bmN0aW9uKHApIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29vcmRpbmF0ZUxvY2F0aW9uKHRoaXMucG9pbnRDb29yZGluYXRlKHApKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2l2ZW4gYSBnZW9ncmFwaGljYWwgbG5nbGF0LCByZXR1cm4gYW4gdW5yb3VuZGVkXG4gICAgICogY29vcmRpbmF0ZSB0aGF0IHJlcHJlc2VudHMgaXQgYXQgdGhpcyB0cmFuc2Zvcm0ncyB6b29tIGxldmVsIGFuZFxuICAgICAqIHdvcmxkc2l6ZS5cbiAgICAgKiBAcGFyYW0ge0xuZ0xhdH0gbG5nbGF0XG4gICAgICogQHJldHVybnMge0Nvb3JkaW5hdGV9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBsb2NhdGlvbkNvb3JkaW5hdGU6IGZ1bmN0aW9uKGxuZ2xhdCkge1xuICAgICAgICB2YXIgayA9IHRoaXMuem9vbVNjYWxlKHRoaXMudGlsZVpvb20pIC8gdGhpcy53b3JsZFNpemUsXG4gICAgICAgICAgICBsbCA9IExuZ0xhdC5jb252ZXJ0KGxuZ2xhdCk7XG5cbiAgICAgICAgcmV0dXJuIG5ldyBDb29yZGluYXRlKFxuICAgICAgICAgICAgdGhpcy5sbmdYKGxsLmxuZykgKiBrLFxuICAgICAgICAgICAgdGhpcy5sYXRZKGxsLmxhdCkgKiBrLFxuICAgICAgICAgICAgdGhpcy50aWxlWm9vbSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdpdmVuIGEgQ29vcmRpbmF0ZSwgcmV0dXJuIGl0cyBnZW9ncmFwaGljYWwgcG9zaXRpb24uXG4gICAgICogQHBhcmFtIHtDb29yZGluYXRlfSBjb29yZFxuICAgICAqIEByZXR1cm5zIHtMbmdMYXR9IGxuZ2xhdFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgY29vcmRpbmF0ZUxvY2F0aW9uOiBmdW5jdGlvbihjb29yZCkge1xuICAgICAgICB2YXIgd29ybGRTaXplID0gdGhpcy56b29tU2NhbGUoY29vcmQuem9vbSk7XG4gICAgICAgIHJldHVybiBuZXcgTG5nTGF0KFxuICAgICAgICAgICAgdGhpcy54TG5nKGNvb3JkLmNvbHVtbiwgd29ybGRTaXplKSxcbiAgICAgICAgICAgIHRoaXMueUxhdChjb29yZC5yb3csIHdvcmxkU2l6ZSkpO1xuICAgIH0sXG5cbiAgICBwb2ludENvb3JkaW5hdGU6IGZ1bmN0aW9uKHApIHtcblxuICAgICAgICB2YXIgdGFyZ2V0WiA9IDA7XG5cbiAgICAgICAgdmFyIG1hdHJpeCA9IHRoaXMuY29vcmRpbmF0ZVBvaW50TWF0cml4KHRoaXMudGlsZVpvb20pO1xuICAgICAgICBtYXQ0LmludmVydChtYXRyaXgsIG1hdHJpeCk7XG5cbiAgICAgICAgaWYgKCFtYXRyaXgpIHRocm93IG5ldyBFcnJvcihcImZhaWxlZCB0byBpbnZlcnQgbWF0cml4XCIpO1xuXG4gICAgICAgIC8vIHNpbmNlIHdlIGRvbid0IGtub3cgdGhlIGNvcnJlY3QgcHJvamVjdGVkIHogdmFsdWUgZm9yIHRoZSBwb2ludCxcbiAgICAgICAgLy8gdW5wcm9qZWN0IHR3byBwb2ludHMgdG8gZ2V0IGEgbGluZSBhbmQgdGhlbiBmaW5kIHRoZSBwb2ludCBvbiB0aGF0XG4gICAgICAgIC8vIGxpbmUgd2l0aCB6PTBcblxuICAgICAgICB2YXIgY29vcmQwID0gW3AueCwgcC55LCAwLCAxXTtcbiAgICAgICAgdmFyIGNvb3JkMSA9IFtwLngsIHAueSwgMSwgMV07XG5cbiAgICAgICAgdmVjNC50cmFuc2Zvcm1NYXQ0KGNvb3JkMCwgY29vcmQwLCBtYXRyaXgpO1xuICAgICAgICB2ZWM0LnRyYW5zZm9ybU1hdDQoY29vcmQxLCBjb29yZDEsIG1hdHJpeCk7XG5cbiAgICAgICAgdmFyIHcwID0gY29vcmQwWzNdO1xuICAgICAgICB2YXIgdzEgPSBjb29yZDFbM107XG4gICAgICAgIHZhciB4MCA9IGNvb3JkMFswXSAvIHcwO1xuICAgICAgICB2YXIgeDEgPSBjb29yZDFbMF0gLyB3MTtcbiAgICAgICAgdmFyIHkwID0gY29vcmQwWzFdIC8gdzA7XG4gICAgICAgIHZhciB5MSA9IGNvb3JkMVsxXSAvIHcxO1xuICAgICAgICB2YXIgejAgPSBjb29yZDBbMl0gLyB3MDtcbiAgICAgICAgdmFyIHoxID0gY29vcmQxWzJdIC8gdzE7XG5cblxuICAgICAgICB2YXIgdCA9IHowID09PSB6MSA/IDAgOiAodGFyZ2V0WiAtIHowKSAvICh6MSAtIHowKTtcblxuICAgICAgICByZXR1cm4gbmV3IENvb3JkaW5hdGUoXG4gICAgICAgICAgICBpbnRlcnAoeDAsIHgxLCB0KSxcbiAgICAgICAgICAgIGludGVycCh5MCwgeTEsIHQpLFxuICAgICAgICAgICAgdGhpcy50aWxlWm9vbSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdpdmVuIGEgY29vcmRpbmF0ZSwgcmV0dXJuIHRoZSBzY3JlZW4gcG9pbnQgdGhhdCBjb3JyZXNwb25kcyB0byBpdFxuICAgICAqIEBwYXJhbSB7Q29vcmRpbmF0ZX0gY29vcmRcbiAgICAgKiBAcmV0dXJucyB7UG9pbnR9IHNjcmVlbiBwb2ludFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgY29vcmRpbmF0ZVBvaW50OiBmdW5jdGlvbihjb29yZCkge1xuICAgICAgICB2YXIgbWF0cml4ID0gdGhpcy5jb29yZGluYXRlUG9pbnRNYXRyaXgoY29vcmQuem9vbSk7XG4gICAgICAgIHZhciBwID0gW2Nvb3JkLmNvbHVtbiwgY29vcmQucm93LCAwLCAxXTtcbiAgICAgICAgdmVjNC50cmFuc2Zvcm1NYXQ0KHAsIHAsIG1hdHJpeCk7XG4gICAgICAgIHJldHVybiBuZXcgUG9pbnQocFswXSAvIHBbM10sIHBbMV0gLyBwWzNdKTtcbiAgICB9LFxuXG4gICAgY29vcmRpbmF0ZVBvaW50TWF0cml4OiBmdW5jdGlvbih6KSB7XG4gICAgICAgIHZhciBwcm9qID0gbWF0NC5jb3B5KG5ldyBGbG9hdDY0QXJyYXkoMTYpLCB0aGlzLnByb2pNYXRyaXgpO1xuICAgICAgICB2YXIgc2NhbGUgPSB0aGlzLndvcmxkU2l6ZSAvIHRoaXMuem9vbVNjYWxlKHopO1xuICAgICAgICBtYXQ0LnNjYWxlKHByb2osIHByb2osIFtzY2FsZSwgc2NhbGUsIDFdKTtcbiAgICAgICAgbWF0NC5tdWx0aXBseShwcm9qLCB0aGlzLmdldFBpeGVsTWF0cml4KCksIHByb2opO1xuICAgICAgICByZXR1cm4gcHJvajtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogY29udmVydHMgZ2wgY29vcmRpbmF0ZXMgLTEuLjEgdG8gcGl4ZWxzIDAuLndpZHRoXG4gICAgICogQHJldHVybnMge09iamVjdH0gbWF0cml4XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBnZXRQaXhlbE1hdHJpeDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBtID0gbWF0NC5jcmVhdGUoKTtcbiAgICAgICAgbWF0NC5zY2FsZShtLCBtLCBbdGhpcy53aWR0aCAvIDIsIC10aGlzLmhlaWdodCAvIDIsIDFdKTtcbiAgICAgICAgbWF0NC50cmFuc2xhdGUobSwgbSwgWzEsIC0xLCAwXSk7XG4gICAgICAgIHJldHVybiBtO1xuICAgIH0sXG5cbiAgICBfY29uc3RyYWluOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKCF0aGlzLmNlbnRlciB8fCAhdGhpcy53aWR0aCB8fCAhdGhpcy5oZWlnaHQgfHwgdGhpcy5fY29uc3RyYWluaW5nKSByZXR1cm47XG5cbiAgICAgICAgdGhpcy5fY29uc3RyYWluaW5nID0gdHJ1ZTtcblxuICAgICAgICB2YXIgbWluWSwgbWF4WSwgbWluWCwgbWF4WCwgc3ksIHN4LCB4MiwgeTIsXG4gICAgICAgICAgICBzaXplID0gdGhpcy5zaXplLFxuICAgICAgICAgICAgdW5tb2RpZmllZCA9IHRoaXMuX3VubW9kaWZpZWQ7XG5cbiAgICAgICAgaWYgKHRoaXMubGF0UmFuZ2UpIHtcbiAgICAgICAgICAgIG1pblkgPSB0aGlzLmxhdFkodGhpcy5sYXRSYW5nZVsxXSk7XG4gICAgICAgICAgICBtYXhZID0gdGhpcy5sYXRZKHRoaXMubGF0UmFuZ2VbMF0pO1xuICAgICAgICAgICAgc3kgPSBtYXhZIC0gbWluWSA8IHNpemUueSA/IHNpemUueSAvIChtYXhZIC0gbWluWSkgOiAwO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMubG5nUmFuZ2UpIHtcbiAgICAgICAgICAgIG1pblggPSB0aGlzLmxuZ1godGhpcy5sbmdSYW5nZVswXSk7XG4gICAgICAgICAgICBtYXhYID0gdGhpcy5sbmdYKHRoaXMubG5nUmFuZ2VbMV0pO1xuICAgICAgICAgICAgc3ggPSBtYXhYIC0gbWluWCA8IHNpemUueCA/IHNpemUueCAvIChtYXhYIC0gbWluWCkgOiAwO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gaG93IG11Y2ggdGhlIG1hcCBzaG91bGQgc2NhbGUgdG8gZml0IHRoZSBzY3JlZW4gaW50byBnaXZlbiBsYXRpdHVkZS9sb25naXR1ZGUgcmFuZ2VzXG4gICAgICAgIHZhciBzID0gTWF0aC5tYXgoc3ggfHwgMCwgc3kgfHwgMCk7XG5cbiAgICAgICAgaWYgKHMpIHtcbiAgICAgICAgICAgIHRoaXMuY2VudGVyID0gdGhpcy51bnByb2plY3QobmV3IFBvaW50KFxuICAgICAgICAgICAgICAgIHN4ID8gKG1heFggKyBtaW5YKSAvIDIgOiB0aGlzLngsXG4gICAgICAgICAgICAgICAgc3kgPyAobWF4WSArIG1pblkpIC8gMiA6IHRoaXMueSkpO1xuICAgICAgICAgICAgdGhpcy56b29tICs9IHRoaXMuc2NhbGVab29tKHMpO1xuICAgICAgICAgICAgdGhpcy5fdW5tb2RpZmllZCA9IHVubW9kaWZpZWQ7XG4gICAgICAgICAgICB0aGlzLl9jb25zdHJhaW5pbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmxhdFJhbmdlKSB7XG4gICAgICAgICAgICB2YXIgeSA9IHRoaXMueSxcbiAgICAgICAgICAgICAgICBoMiA9IHNpemUueSAvIDI7XG5cbiAgICAgICAgICAgIGlmICh5IC0gaDIgPCBtaW5ZKSB5MiA9IG1pblkgKyBoMjtcbiAgICAgICAgICAgIGlmICh5ICsgaDIgPiBtYXhZKSB5MiA9IG1heFkgLSBoMjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmxuZ1JhbmdlKSB7XG4gICAgICAgICAgICB2YXIgeCA9IHRoaXMueCxcbiAgICAgICAgICAgICAgICB3MiA9IHNpemUueCAvIDI7XG5cbiAgICAgICAgICAgIGlmICh4IC0gdzIgPCBtaW5YKSB4MiA9IG1pblggKyB3MjtcbiAgICAgICAgICAgIGlmICh4ICsgdzIgPiBtYXhYKSB4MiA9IG1heFggLSB3MjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHBhbiB0aGUgbWFwIGlmIHRoZSBzY3JlZW4gZ29lcyBvZmYgdGhlIHJhbmdlXG4gICAgICAgIGlmICh4MiAhPT0gdW5kZWZpbmVkIHx8IHkyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuY2VudGVyID0gdGhpcy51bnByb2plY3QobmV3IFBvaW50KFxuICAgICAgICAgICAgICAgIHgyICE9PSB1bmRlZmluZWQgPyB4MiA6IHRoaXMueCxcbiAgICAgICAgICAgICAgICB5MiAhPT0gdW5kZWZpbmVkID8geTIgOiB0aGlzLnkpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3VubW9kaWZpZWQgPSB1bm1vZGlmaWVkO1xuICAgICAgICB0aGlzLl9jb25zdHJhaW5pbmcgPSBmYWxzZTtcbiAgICB9LFxuXG4gICAgX2NhbGNQcm9qTWF0cml4OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIG0gPSBuZXcgRmxvYXQ2NEFycmF5KDE2KTtcblxuICAgICAgICAvLyBGaW5kIHRoZSBkaXN0YW5jZSBmcm9tIHRoZSBjZW50ZXIgcG9pbnQgdG8gdGhlIGNlbnRlciB0b3AgaW4gYWx0aXR1ZGUgdW5pdHMgdXNpbmcgbGF3IG9mIHNpbmVzLlxuICAgICAgICB2YXIgaGFsZkZvdiA9IE1hdGguYXRhbigwLjUgLyB0aGlzLmFsdGl0dWRlKTtcbiAgICAgICAgdmFyIHRvcEhhbGZTdXJmYWNlRGlzdGFuY2UgPSBNYXRoLnNpbihoYWxmRm92KSAqIHRoaXMuYWx0aXR1ZGUgLyBNYXRoLnNpbihNYXRoLlBJIC8gMiAtIHRoaXMuX3BpdGNoIC0gaGFsZkZvdik7XG5cbiAgICAgICAgLy8gQ2FsY3VsYXRlIHogdmFsdWUgb2YgdGhlIGZhcnRoZXN0IGZyYWdtZW50IHRoYXQgc2hvdWxkIGJlIHJlbmRlcmVkLlxuICAgICAgICB2YXIgZmFyWiA9IE1hdGguY29zKE1hdGguUEkgLyAyIC0gdGhpcy5fcGl0Y2gpICogdG9wSGFsZlN1cmZhY2VEaXN0YW5jZSArIHRoaXMuYWx0aXR1ZGU7XG5cbiAgICAgICAgbWF0NC5wZXJzcGVjdGl2ZShtLCAyICogTWF0aC5hdGFuKCh0aGlzLmhlaWdodCAvIDIpIC8gdGhpcy5hbHRpdHVkZSksIHRoaXMud2lkdGggLyB0aGlzLmhlaWdodCwgMC4xLCBmYXJaKTtcblxuICAgICAgICBtYXQ0LnRyYW5zbGF0ZShtLCBtLCBbMCwgMCwgLXRoaXMuYWx0aXR1ZGVdKTtcblxuICAgICAgICAvLyBBZnRlciB0aGUgcm90YXRlWCwgeiB2YWx1ZXMgYXJlIGluIHBpeGVsIHVuaXRzLiBDb252ZXJ0IHRoZW0gdG9cbiAgICAgICAgLy8gYWx0aXR1ZGUgdW5pdHMuIDEgYWx0aXR1ZGUgdW5pdCA9IHRoZSBzY3JlZW4gaGVpZ2h0LlxuICAgICAgICBtYXQ0LnNjYWxlKG0sIG0sIFsxLCAtMSwgMSAvIHRoaXMuaGVpZ2h0XSk7XG5cbiAgICAgICAgbWF0NC5yb3RhdGVYKG0sIG0sIHRoaXMuX3BpdGNoKTtcbiAgICAgICAgbWF0NC5yb3RhdGVaKG0sIG0sIHRoaXMuYW5nbGUpO1xuICAgICAgICBtYXQ0LnRyYW5zbGF0ZShtLCBtLCBbLXRoaXMueCwgLXRoaXMueSwgMF0pO1xuXG4gICAgICAgIHRoaXMucHJvak1hdHJpeCA9IG07XG4gICAgfVxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLy8gRm9udCBkYXRhIEZyb20gSGVyc2hleSBTaW1wbGV4IEZvbnRcbi8vIGh0dHA6Ly9wYXVsYm91cmtlLm5ldC9kYXRhZm9ybWF0cy9oZXJzaGV5L1xudmFyIHNpbXBsZXhGb250ID0ge1xuICAgIFwiIFwiOiBbMTYsIFtdXSxcbiAgICBcIiFcIjogWzEwLCBbNSwgMjEsIDUsIDcsIC0xLCAtMSwgNSwgMiwgNCwgMSwgNSwgMCwgNiwgMSwgNSwgMl1dLFxuICAgIFwiXFxcIlwiOiBbMTYsIFs0LCAyMSwgNCwgMTQsIC0xLCAtMSwgMTIsIDIxLCAxMiwgMTRdXSxcbiAgICBcIiNcIjogWzIxLCBbMTEsIDI1LCA0LCAtNywgLTEsIC0xLCAxNywgMjUsIDEwLCAtNywgLTEsIC0xLCA0LCAxMiwgMTgsIDEyLCAtMSwgLTEsIDMsIDYsIDE3LCA2XV0sXG4gICAgXCIkXCI6IFsyMCwgWzgsIDI1LCA4LCAtNCwgLTEsIC0xLCAxMiwgMjUsIDEyLCAtNCwgLTEsIC0xLCAxNywgMTgsIDE1LCAyMCwgMTIsIDIxLCA4LCAyMSwgNSwgMjAsIDMsIDE4LCAzLCAxNiwgNCwgMTQsIDUsIDEzLCA3LCAxMiwgMTMsIDEwLCAxNSwgOSwgMTYsIDgsIDE3LCA2LCAxNywgMywgMTUsIDEsIDEyLCAwLCA4LCAwLCA1LCAxLCAzLCAzXV0sXG4gICAgXCIlXCI6IFsyNCwgWzIxLCAyMSwgMywgMCwgLTEsIC0xLCA4LCAyMSwgMTAsIDE5LCAxMCwgMTcsIDksIDE1LCA3LCAxNCwgNSwgMTQsIDMsIDE2LCAzLCAxOCwgNCwgMjAsIDYsIDIxLCA4LCAyMSwgMTAsIDIwLCAxMywgMTksIDE2LCAxOSwgMTksIDIwLCAyMSwgMjEsIC0xLCAtMSwgMTcsIDcsIDE1LCA2LCAxNCwgNCwgMTQsIDIsIDE2LCAwLCAxOCwgMCwgMjAsIDEsIDIxLCAzLCAyMSwgNSwgMTksIDcsIDE3LCA3XV0sXG4gICAgXCImXCI6IFsyNiwgWzIzLCAxMiwgMjMsIDEzLCAyMiwgMTQsIDIxLCAxNCwgMjAsIDEzLCAxOSwgMTEsIDE3LCA2LCAxNSwgMywgMTMsIDEsIDExLCAwLCA3LCAwLCA1LCAxLCA0LCAyLCAzLCA0LCAzLCA2LCA0LCA4LCA1LCA5LCAxMiwgMTMsIDEzLCAxNCwgMTQsIDE2LCAxNCwgMTgsIDEzLCAyMCwgMTEsIDIxLCA5LCAyMCwgOCwgMTgsIDgsIDE2LCA5LCAxMywgMTEsIDEwLCAxNiwgMywgMTgsIDEsIDIwLCAwLCAyMiwgMCwgMjMsIDEsIDIzLCAyXV0sXG4gICAgXCInXCI6IFsxMCwgWzUsIDE5LCA0LCAyMCwgNSwgMjEsIDYsIDIwLCA2LCAxOCwgNSwgMTYsIDQsIDE1XV0sXG4gICAgXCIoXCI6IFsxNCwgWzExLCAyNSwgOSwgMjMsIDcsIDIwLCA1LCAxNiwgNCwgMTEsIDQsIDcsIDUsIDIsIDcsIC0yLCA5LCAtNSwgMTEsIC03XV0sXG4gICAgXCIpXCI6IFsxNCwgWzMsIDI1LCA1LCAyMywgNywgMjAsIDksIDE2LCAxMCwgMTEsIDEwLCA3LCA5LCAyLCA3LCAtMiwgNSwgLTUsIDMsIC03XV0sXG4gICAgXCIqXCI6IFsxNiwgWzgsIDIxLCA4LCA5LCAtMSwgLTEsIDMsIDE4LCAxMywgMTIsIC0xLCAtMSwgMTMsIDE4LCAzLCAxMl1dLFxuICAgIFwiK1wiOiBbMjYsIFsxMywgMTgsIDEzLCAwLCAtMSwgLTEsIDQsIDksIDIyLCA5XV0sXG4gICAgXCIsXCI6IFsxMCwgWzYsIDEsIDUsIDAsIDQsIDEsIDUsIDIsIDYsIDEsIDYsIC0xLCA1LCAtMywgNCwgLTRdXSxcbiAgICBcIi1cIjogWzI2LCBbNCwgOSwgMjIsIDldXSxcbiAgICBcIi5cIjogWzEwLCBbNSwgMiwgNCwgMSwgNSwgMCwgNiwgMSwgNSwgMl1dLFxuICAgIFwiL1wiOiBbMjIsIFsyMCwgMjUsIDIsIC03XV0sXG4gICAgXCIwXCI6IFsyMCwgWzksIDIxLCA2LCAyMCwgNCwgMTcsIDMsIDEyLCAzLCA5LCA0LCA0LCA2LCAxLCA5LCAwLCAxMSwgMCwgMTQsIDEsIDE2LCA0LCAxNywgOSwgMTcsIDEyLCAxNiwgMTcsIDE0LCAyMCwgMTEsIDIxLCA5LCAyMV1dLFxuICAgIFwiMVwiOiBbMjAsIFs2LCAxNywgOCwgMTgsIDExLCAyMSwgMTEsIDBdXSxcbiAgICBcIjJcIjogWzIwLCBbNCwgMTYsIDQsIDE3LCA1LCAxOSwgNiwgMjAsIDgsIDIxLCAxMiwgMjEsIDE0LCAyMCwgMTUsIDE5LCAxNiwgMTcsIDE2LCAxNSwgMTUsIDEzLCAxMywgMTAsIDMsIDAsIDE3LCAwXV0sXG4gICAgXCIzXCI6IFsyMCwgWzUsIDIxLCAxNiwgMjEsIDEwLCAxMywgMTMsIDEzLCAxNSwgMTIsIDE2LCAxMSwgMTcsIDgsIDE3LCA2LCAxNiwgMywgMTQsIDEsIDExLCAwLCA4LCAwLCA1LCAxLCA0LCAyLCAzLCA0XV0sXG4gICAgXCI0XCI6IFsyMCwgWzEzLCAyMSwgMywgNywgMTgsIDcsIC0xLCAtMSwgMTMsIDIxLCAxMywgMF1dLFxuICAgIFwiNVwiOiBbMjAsIFsxNSwgMjEsIDUsIDIxLCA0LCAxMiwgNSwgMTMsIDgsIDE0LCAxMSwgMTQsIDE0LCAxMywgMTYsIDExLCAxNywgOCwgMTcsIDYsIDE2LCAzLCAxNCwgMSwgMTEsIDAsIDgsIDAsIDUsIDEsIDQsIDIsIDMsIDRdXSxcbiAgICBcIjZcIjogWzIwLCBbMTYsIDE4LCAxNSwgMjAsIDEyLCAyMSwgMTAsIDIxLCA3LCAyMCwgNSwgMTcsIDQsIDEyLCA0LCA3LCA1LCAzLCA3LCAxLCAxMCwgMCwgMTEsIDAsIDE0LCAxLCAxNiwgMywgMTcsIDYsIDE3LCA3LCAxNiwgMTAsIDE0LCAxMiwgMTEsIDEzLCAxMCwgMTMsIDcsIDEyLCA1LCAxMCwgNCwgN11dLFxuICAgIFwiN1wiOiBbMjAsIFsxNywgMjEsIDcsIDAsIC0xLCAtMSwgMywgMjEsIDE3LCAyMV1dLFxuICAgIFwiOFwiOiBbMjAsIFs4LCAyMSwgNSwgMjAsIDQsIDE4LCA0LCAxNiwgNSwgMTQsIDcsIDEzLCAxMSwgMTIsIDE0LCAxMSwgMTYsIDksIDE3LCA3LCAxNywgNCwgMTYsIDIsIDE1LCAxLCAxMiwgMCwgOCwgMCwgNSwgMSwgNCwgMiwgMywgNCwgMywgNywgNCwgOSwgNiwgMTEsIDksIDEyLCAxMywgMTMsIDE1LCAxNCwgMTYsIDE2LCAxNiwgMTgsIDE1LCAyMCwgMTIsIDIxLCA4LCAyMV1dLFxuICAgIFwiOVwiOiBbMjAsIFsxNiwgMTQsIDE1LCAxMSwgMTMsIDksIDEwLCA4LCA5LCA4LCA2LCA5LCA0LCAxMSwgMywgMTQsIDMsIDE1LCA0LCAxOCwgNiwgMjAsIDksIDIxLCAxMCwgMjEsIDEzLCAyMCwgMTUsIDE4LCAxNiwgMTQsIDE2LCA5LCAxNSwgNCwgMTMsIDEsIDEwLCAwLCA4LCAwLCA1LCAxLCA0LCAzXV0sXG4gICAgXCI6XCI6IFsxMCwgWzUsIDE0LCA0LCAxMywgNSwgMTIsIDYsIDEzLCA1LCAxNCwgLTEsIC0xLCA1LCAyLCA0LCAxLCA1LCAwLCA2LCAxLCA1LCAyXV0sXG4gICAgXCI7XCI6IFsxMCwgWzUsIDE0LCA0LCAxMywgNSwgMTIsIDYsIDEzLCA1LCAxNCwgLTEsIC0xLCA2LCAxLCA1LCAwLCA0LCAxLCA1LCAyLCA2LCAxLCA2LCAtMSwgNSwgLTMsIDQsIC00XV0sXG4gICAgXCI8XCI6IFsyNCwgWzIwLCAxOCwgNCwgOSwgMjAsIDBdXSxcbiAgICBcIj1cIjogWzI2LCBbNCwgMTIsIDIyLCAxMiwgLTEsIC0xLCA0LCA2LCAyMiwgNl1dLFxuICAgIFwiPlwiOiBbMjQsIFs0LCAxOCwgMjAsIDksIDQsIDBdXSxcbiAgICBcIj9cIjogWzE4LCBbMywgMTYsIDMsIDE3LCA0LCAxOSwgNSwgMjAsIDcsIDIxLCAxMSwgMjEsIDEzLCAyMCwgMTQsIDE5LCAxNSwgMTcsIDE1LCAxNSwgMTQsIDEzLCAxMywgMTIsIDksIDEwLCA5LCA3LCAtMSwgLTEsIDksIDIsIDgsIDEsIDksIDAsIDEwLCAxLCA5LCAyXV0sXG4gICAgXCJAXCI6IFsyNywgWzE4LCAxMywgMTcsIDE1LCAxNSwgMTYsIDEyLCAxNiwgMTAsIDE1LCA5LCAxNCwgOCwgMTEsIDgsIDgsIDksIDYsIDExLCA1LCAxNCwgNSwgMTYsIDYsIDE3LCA4LCAtMSwgLTEsIDEyLCAxNiwgMTAsIDE0LCA5LCAxMSwgOSwgOCwgMTAsIDYsIDExLCA1LCAtMSwgLTEsIDE4LCAxNiwgMTcsIDgsIDE3LCA2LCAxOSwgNSwgMjEsIDUsIDIzLCA3LCAyNCwgMTAsIDI0LCAxMiwgMjMsIDE1LCAyMiwgMTcsIDIwLCAxOSwgMTgsIDIwLCAxNSwgMjEsIDEyLCAyMSwgOSwgMjAsIDcsIDE5LCA1LCAxNywgNCwgMTUsIDMsIDEyLCAzLCA5LCA0LCA2LCA1LCA0LCA3LCAyLCA5LCAxLCAxMiwgMCwgMTUsIDAsIDE4LCAxLCAyMCwgMiwgMjEsIDMsIC0xLCAtMSwgMTksIDE2LCAxOCwgOCwgMTgsIDYsIDE5LCA1XV0sXG4gICAgXCJBXCI6IFsxOCwgWzksIDIxLCAxLCAwLCAtMSwgLTEsIDksIDIxLCAxNywgMCwgLTEsIC0xLCA0LCA3LCAxNCwgN11dLFxuICAgIFwiQlwiOiBbMjEsIFs0LCAyMSwgNCwgMCwgLTEsIC0xLCA0LCAyMSwgMTMsIDIxLCAxNiwgMjAsIDE3LCAxOSwgMTgsIDE3LCAxOCwgMTUsIDE3LCAxMywgMTYsIDEyLCAxMywgMTEsIC0xLCAtMSwgNCwgMTEsIDEzLCAxMSwgMTYsIDEwLCAxNywgOSwgMTgsIDcsIDE4LCA0LCAxNywgMiwgMTYsIDEsIDEzLCAwLCA0LCAwXV0sXG4gICAgXCJDXCI6IFsyMSwgWzE4LCAxNiwgMTcsIDE4LCAxNSwgMjAsIDEzLCAyMSwgOSwgMjEsIDcsIDIwLCA1LCAxOCwgNCwgMTYsIDMsIDEzLCAzLCA4LCA0LCA1LCA1LCAzLCA3LCAxLCA5LCAwLCAxMywgMCwgMTUsIDEsIDE3LCAzLCAxOCwgNV1dLFxuICAgIFwiRFwiOiBbMjEsIFs0LCAyMSwgNCwgMCwgLTEsIC0xLCA0LCAyMSwgMTEsIDIxLCAxNCwgMjAsIDE2LCAxOCwgMTcsIDE2LCAxOCwgMTMsIDE4LCA4LCAxNywgNSwgMTYsIDMsIDE0LCAxLCAxMSwgMCwgNCwgMF1dLFxuICAgIFwiRVwiOiBbMTksIFs0LCAyMSwgNCwgMCwgLTEsIC0xLCA0LCAyMSwgMTcsIDIxLCAtMSwgLTEsIDQsIDExLCAxMiwgMTEsIC0xLCAtMSwgNCwgMCwgMTcsIDBdXSxcbiAgICBcIkZcIjogWzE4LCBbNCwgMjEsIDQsIDAsIC0xLCAtMSwgNCwgMjEsIDE3LCAyMSwgLTEsIC0xLCA0LCAxMSwgMTIsIDExXV0sXG4gICAgXCJHXCI6IFsyMSwgWzE4LCAxNiwgMTcsIDE4LCAxNSwgMjAsIDEzLCAyMSwgOSwgMjEsIDcsIDIwLCA1LCAxOCwgNCwgMTYsIDMsIDEzLCAzLCA4LCA0LCA1LCA1LCAzLCA3LCAxLCA5LCAwLCAxMywgMCwgMTUsIDEsIDE3LCAzLCAxOCwgNSwgMTgsIDgsIC0xLCAtMSwgMTMsIDgsIDE4LCA4XV0sXG4gICAgXCJIXCI6IFsyMiwgWzQsIDIxLCA0LCAwLCAtMSwgLTEsIDE4LCAyMSwgMTgsIDAsIC0xLCAtMSwgNCwgMTEsIDE4LCAxMV1dLFxuICAgIFwiSVwiOiBbOCwgWzQsIDIxLCA0LCAwXV0sXG4gICAgXCJKXCI6IFsxNiwgWzEyLCAyMSwgMTIsIDUsIDExLCAyLCAxMCwgMSwgOCwgMCwgNiwgMCwgNCwgMSwgMywgMiwgMiwgNSwgMiwgN11dLFxuICAgIFwiS1wiOiBbMjEsIFs0LCAyMSwgNCwgMCwgLTEsIC0xLCAxOCwgMjEsIDQsIDcsIC0xLCAtMSwgOSwgMTIsIDE4LCAwXV0sXG4gICAgXCJMXCI6IFsxNywgWzQsIDIxLCA0LCAwLCAtMSwgLTEsIDQsIDAsIDE2LCAwXV0sXG4gICAgXCJNXCI6IFsyNCwgWzQsIDIxLCA0LCAwLCAtMSwgLTEsIDQsIDIxLCAxMiwgMCwgLTEsIC0xLCAyMCwgMjEsIDEyLCAwLCAtMSwgLTEsIDIwLCAyMSwgMjAsIDBdXSxcbiAgICBcIk5cIjogWzIyLCBbNCwgMjEsIDQsIDAsIC0xLCAtMSwgNCwgMjEsIDE4LCAwLCAtMSwgLTEsIDE4LCAyMSwgMTgsIDBdXSxcbiAgICBcIk9cIjogWzIyLCBbOSwgMjEsIDcsIDIwLCA1LCAxOCwgNCwgMTYsIDMsIDEzLCAzLCA4LCA0LCA1LCA1LCAzLCA3LCAxLCA5LCAwLCAxMywgMCwgMTUsIDEsIDE3LCAzLCAxOCwgNSwgMTksIDgsIDE5LCAxMywgMTgsIDE2LCAxNywgMTgsIDE1LCAyMCwgMTMsIDIxLCA5LCAyMV1dLFxuICAgIFwiUFwiOiBbMjEsIFs0LCAyMSwgNCwgMCwgLTEsIC0xLCA0LCAyMSwgMTMsIDIxLCAxNiwgMjAsIDE3LCAxOSwgMTgsIDE3LCAxOCwgMTQsIDE3LCAxMiwgMTYsIDExLCAxMywgMTAsIDQsIDEwXV0sXG4gICAgXCJRXCI6IFsyMiwgWzksIDIxLCA3LCAyMCwgNSwgMTgsIDQsIDE2LCAzLCAxMywgMywgOCwgNCwgNSwgNSwgMywgNywgMSwgOSwgMCwgMTMsIDAsIDE1LCAxLCAxNywgMywgMTgsIDUsIDE5LCA4LCAxOSwgMTMsIDE4LCAxNiwgMTcsIDE4LCAxNSwgMjAsIDEzLCAyMSwgOSwgMjEsIC0xLCAtMSwgMTIsIDQsIDE4LCAtMl1dLFxuICAgIFwiUlwiOiBbMjEsIFs0LCAyMSwgNCwgMCwgLTEsIC0xLCA0LCAyMSwgMTMsIDIxLCAxNiwgMjAsIDE3LCAxOSwgMTgsIDE3LCAxOCwgMTUsIDE3LCAxMywgMTYsIDEyLCAxMywgMTEsIDQsIDExLCAtMSwgLTEsIDExLCAxMSwgMTgsIDBdXSxcbiAgICBcIlNcIjogWzIwLCBbMTcsIDE4LCAxNSwgMjAsIDEyLCAyMSwgOCwgMjEsIDUsIDIwLCAzLCAxOCwgMywgMTYsIDQsIDE0LCA1LCAxMywgNywgMTIsIDEzLCAxMCwgMTUsIDksIDE2LCA4LCAxNywgNiwgMTcsIDMsIDE1LCAxLCAxMiwgMCwgOCwgMCwgNSwgMSwgMywgM11dLFxuICAgIFwiVFwiOiBbMTYsIFs4LCAyMSwgOCwgMCwgLTEsIC0xLCAxLCAyMSwgMTUsIDIxXV0sXG4gICAgXCJVXCI6IFsyMiwgWzQsIDIxLCA0LCA2LCA1LCAzLCA3LCAxLCAxMCwgMCwgMTIsIDAsIDE1LCAxLCAxNywgMywgMTgsIDYsIDE4LCAyMV1dLFxuICAgIFwiVlwiOiBbMTgsIFsxLCAyMSwgOSwgMCwgLTEsIC0xLCAxNywgMjEsIDksIDBdXSxcbiAgICBcIldcIjogWzI0LCBbMiwgMjEsIDcsIDAsIC0xLCAtMSwgMTIsIDIxLCA3LCAwLCAtMSwgLTEsIDEyLCAyMSwgMTcsIDAsIC0xLCAtMSwgMjIsIDIxLCAxNywgMF1dLFxuICAgIFwiWFwiOiBbMjAsIFszLCAyMSwgMTcsIDAsIC0xLCAtMSwgMTcsIDIxLCAzLCAwXV0sXG4gICAgXCJZXCI6IFsxOCwgWzEsIDIxLCA5LCAxMSwgOSwgMCwgLTEsIC0xLCAxNywgMjEsIDksIDExXV0sXG4gICAgXCJaXCI6IFsyMCwgWzE3LCAyMSwgMywgMCwgLTEsIC0xLCAzLCAyMSwgMTcsIDIxLCAtMSwgLTEsIDMsIDAsIDE3LCAwXV0sXG4gICAgXCJbXCI6IFsxNCwgWzQsIDI1LCA0LCAtNywgLTEsIC0xLCA1LCAyNSwgNSwgLTcsIC0xLCAtMSwgNCwgMjUsIDExLCAyNSwgLTEsIC0xLCA0LCAtNywgMTEsIC03XV0sXG4gICAgXCJcXFxcXCI6IFsxNCwgWzAsIDIxLCAxNCwgLTNdXSxcbiAgICBcIl1cIjogWzE0LCBbOSwgMjUsIDksIC03LCAtMSwgLTEsIDEwLCAyNSwgMTAsIC03LCAtMSwgLTEsIDMsIDI1LCAxMCwgMjUsIC0xLCAtMSwgMywgLTcsIDEwLCAtN11dLFxuICAgIFwiXlwiOiBbMTYsIFs2LCAxNSwgOCwgMTgsIDEwLCAxNSwgLTEsIC0xLCAzLCAxMiwgOCwgMTcsIDEzLCAxMiwgLTEsIC0xLCA4LCAxNywgOCwgMF1dLFxuICAgIFwiX1wiOiBbMTYsIFswLCAtMiwgMTYsIC0yXV0sXG4gICAgXCJgXCI6IFsxMCwgWzYsIDIxLCA1LCAyMCwgNCwgMTgsIDQsIDE2LCA1LCAxNSwgNiwgMTYsIDUsIDE3XV0sXG4gICAgXCJhXCI6IFsxOSwgWzE1LCAxNCwgMTUsIDAsIC0xLCAtMSwgMTUsIDExLCAxMywgMTMsIDExLCAxNCwgOCwgMTQsIDYsIDEzLCA0LCAxMSwgMywgOCwgMywgNiwgNCwgMywgNiwgMSwgOCwgMCwgMTEsIDAsIDEzLCAxLCAxNSwgM11dLFxuICAgIFwiYlwiOiBbMTksIFs0LCAyMSwgNCwgMCwgLTEsIC0xLCA0LCAxMSwgNiwgMTMsIDgsIDE0LCAxMSwgMTQsIDEzLCAxMywgMTUsIDExLCAxNiwgOCwgMTYsIDYsIDE1LCAzLCAxMywgMSwgMTEsIDAsIDgsIDAsIDYsIDEsIDQsIDNdXSxcbiAgICBcImNcIjogWzE4LCBbMTUsIDExLCAxMywgMTMsIDExLCAxNCwgOCwgMTQsIDYsIDEzLCA0LCAxMSwgMywgOCwgMywgNiwgNCwgMywgNiwgMSwgOCwgMCwgMTEsIDAsIDEzLCAxLCAxNSwgM11dLFxuICAgIFwiZFwiOiBbMTksIFsxNSwgMjEsIDE1LCAwLCAtMSwgLTEsIDE1LCAxMSwgMTMsIDEzLCAxMSwgMTQsIDgsIDE0LCA2LCAxMywgNCwgMTEsIDMsIDgsIDMsIDYsIDQsIDMsIDYsIDEsIDgsIDAsIDExLCAwLCAxMywgMSwgMTUsIDNdXSxcbiAgICBcImVcIjogWzE4LCBbMywgOCwgMTUsIDgsIDE1LCAxMCwgMTQsIDEyLCAxMywgMTMsIDExLCAxNCwgOCwgMTQsIDYsIDEzLCA0LCAxMSwgMywgOCwgMywgNiwgNCwgMywgNiwgMSwgOCwgMCwgMTEsIDAsIDEzLCAxLCAxNSwgM11dLFxuICAgIFwiZlwiOiBbMTIsIFsxMCwgMjEsIDgsIDIxLCA2LCAyMCwgNSwgMTcsIDUsIDAsIC0xLCAtMSwgMiwgMTQsIDksIDE0XV0sXG4gICAgXCJnXCI6IFsxOSwgWzE1LCAxNCwgMTUsIC0yLCAxNCwgLTUsIDEzLCAtNiwgMTEsIC03LCA4LCAtNywgNiwgLTYsIC0xLCAtMSwgMTUsIDExLCAxMywgMTMsIDExLCAxNCwgOCwgMTQsIDYsIDEzLCA0LCAxMSwgMywgOCwgMywgNiwgNCwgMywgNiwgMSwgOCwgMCwgMTEsIDAsIDEzLCAxLCAxNSwgM11dLFxuICAgIFwiaFwiOiBbMTksIFs0LCAyMSwgNCwgMCwgLTEsIC0xLCA0LCAxMCwgNywgMTMsIDksIDE0LCAxMiwgMTQsIDE0LCAxMywgMTUsIDEwLCAxNSwgMF1dLFxuICAgIFwiaVwiOiBbOCwgWzMsIDIxLCA0LCAyMCwgNSwgMjEsIDQsIDIyLCAzLCAyMSwgLTEsIC0xLCA0LCAxNCwgNCwgMF1dLFxuICAgIFwialwiOiBbMTAsIFs1LCAyMSwgNiwgMjAsIDcsIDIxLCA2LCAyMiwgNSwgMjEsIC0xLCAtMSwgNiwgMTQsIDYsIC0zLCA1LCAtNiwgMywgLTcsIDEsIC03XV0sXG4gICAgXCJrXCI6IFsxNywgWzQsIDIxLCA0LCAwLCAtMSwgLTEsIDE0LCAxNCwgNCwgNCwgLTEsIC0xLCA4LCA4LCAxNSwgMF1dLFxuICAgIFwibFwiOiBbOCwgWzQsIDIxLCA0LCAwXV0sXG4gICAgXCJtXCI6IFszMCwgWzQsIDE0LCA0LCAwLCAtMSwgLTEsIDQsIDEwLCA3LCAxMywgOSwgMTQsIDEyLCAxNCwgMTQsIDEzLCAxNSwgMTAsIDE1LCAwLCAtMSwgLTEsIDE1LCAxMCwgMTgsIDEzLCAyMCwgMTQsIDIzLCAxNCwgMjUsIDEzLCAyNiwgMTAsIDI2LCAwXV0sXG4gICAgXCJuXCI6IFsxOSwgWzQsIDE0LCA0LCAwLCAtMSwgLTEsIDQsIDEwLCA3LCAxMywgOSwgMTQsIDEyLCAxNCwgMTQsIDEzLCAxNSwgMTAsIDE1LCAwXV0sXG4gICAgXCJvXCI6IFsxOSwgWzgsIDE0LCA2LCAxMywgNCwgMTEsIDMsIDgsIDMsIDYsIDQsIDMsIDYsIDEsIDgsIDAsIDExLCAwLCAxMywgMSwgMTUsIDMsIDE2LCA2LCAxNiwgOCwgMTUsIDExLCAxMywgMTMsIDExLCAxNCwgOCwgMTRdXSxcbiAgICBcInBcIjogWzE5LCBbNCwgMTQsIDQsIC03LCAtMSwgLTEsIDQsIDExLCA2LCAxMywgOCwgMTQsIDExLCAxNCwgMTMsIDEzLCAxNSwgMTEsIDE2LCA4LCAxNiwgNiwgMTUsIDMsIDEzLCAxLCAxMSwgMCwgOCwgMCwgNiwgMSwgNCwgM11dLFxuICAgIFwicVwiOiBbMTksIFsxNSwgMTQsIDE1LCAtNywgLTEsIC0xLCAxNSwgMTEsIDEzLCAxMywgMTEsIDE0LCA4LCAxNCwgNiwgMTMsIDQsIDExLCAzLCA4LCAzLCA2LCA0LCAzLCA2LCAxLCA4LCAwLCAxMSwgMCwgMTMsIDEsIDE1LCAzXV0sXG4gICAgXCJyXCI6IFsxMywgWzQsIDE0LCA0LCAwLCAtMSwgLTEsIDQsIDgsIDUsIDExLCA3LCAxMywgOSwgMTQsIDEyLCAxNF1dLFxuICAgIFwic1wiOiBbMTcsIFsxNCwgMTEsIDEzLCAxMywgMTAsIDE0LCA3LCAxNCwgNCwgMTMsIDMsIDExLCA0LCA5LCA2LCA4LCAxMSwgNywgMTMsIDYsIDE0LCA0LCAxNCwgMywgMTMsIDEsIDEwLCAwLCA3LCAwLCA0LCAxLCAzLCAzXV0sXG4gICAgXCJ0XCI6IFsxMiwgWzUsIDIxLCA1LCA0LCA2LCAxLCA4LCAwLCAxMCwgMCwgLTEsIC0xLCAyLCAxNCwgOSwgMTRdXSxcbiAgICBcInVcIjogWzE5LCBbNCwgMTQsIDQsIDQsIDUsIDEsIDcsIDAsIDEwLCAwLCAxMiwgMSwgMTUsIDQsIC0xLCAtMSwgMTUsIDE0LCAxNSwgMF1dLFxuICAgIFwidlwiOiBbMTYsIFsyLCAxNCwgOCwgMCwgLTEsIC0xLCAxNCwgMTQsIDgsIDBdXSxcbiAgICBcIndcIjogWzIyLCBbMywgMTQsIDcsIDAsIC0xLCAtMSwgMTEsIDE0LCA3LCAwLCAtMSwgLTEsIDExLCAxNCwgMTUsIDAsIC0xLCAtMSwgMTksIDE0LCAxNSwgMF1dLFxuICAgIFwieFwiOiBbMTcsIFszLCAxNCwgMTQsIDAsIC0xLCAtMSwgMTQsIDE0LCAzLCAwXV0sXG4gICAgXCJ5XCI6IFsxNiwgWzIsIDE0LCA4LCAwLCAtMSwgLTEsIDE0LCAxNCwgOCwgMCwgNiwgLTQsIDQsIC02LCAyLCAtNywgMSwgLTddXSxcbiAgICBcInpcIjogWzE3LCBbMTQsIDE0LCAzLCAwLCAtMSwgLTEsIDMsIDE0LCAxNCwgMTQsIC0xLCAtMSwgMywgMCwgMTQsIDBdXSxcbiAgICBcIntcIjogWzE0LCBbOSwgMjUsIDcsIDI0LCA2LCAyMywgNSwgMjEsIDUsIDE5LCA2LCAxNywgNywgMTYsIDgsIDE0LCA4LCAxMiwgNiwgMTAsIC0xLCAtMSwgNywgMjQsIDYsIDIyLCA2LCAyMCwgNywgMTgsIDgsIDE3LCA5LCAxNSwgOSwgMTMsIDgsIDExLCA0LCA5LCA4LCA3LCA5LCA1LCA5LCAzLCA4LCAxLCA3LCAwLCA2LCAtMiwgNiwgLTQsIDcsIC02LCAtMSwgLTEsIDYsIDgsIDgsIDYsIDgsIDQsIDcsIDIsIDYsIDEsIDUsIC0xLCA1LCAtMywgNiwgLTUsIDcsIC02LCA5LCAtN11dLFxuICAgIFwifFwiOiBbOCwgWzQsIDI1LCA0LCAtN11dLFxuICAgIFwifVwiOiBbMTQsIFs1LCAyNSwgNywgMjQsIDgsIDIzLCA5LCAyMSwgOSwgMTksIDgsIDE3LCA3LCAxNiwgNiwgMTQsIDYsIDEyLCA4LCAxMCwgLTEsIC0xLCA3LCAyNCwgOCwgMjIsIDgsIDIwLCA3LCAxOCwgNiwgMTcsIDUsIDE1LCA1LCAxMywgNiwgMTEsIDEwLCA5LCA2LCA3LCA1LCA1LCA1LCAzLCA2LCAxLCA3LCAwLCA4LCAtMiwgOCwgLTQsIDcsIC02LCAtMSwgLTEsIDgsIDgsIDYsIDYsIDYsIDQsIDcsIDIsIDgsIDEsIDksIC0xLCA5LCAtMywgOCwgLTUsIDcsIC02LCA1LCAtN11dLFxuICAgIFwiflwiOiBbMjQsIFszLCA2LCAzLCA4LCA0LCAxMSwgNiwgMTIsIDgsIDEyLCAxMCwgMTEsIDE0LCA4LCAxNiwgNywgMTgsIDcsIDIwLCA4LCAyMSwgMTAsIC0xLCAtMSwgMywgOCwgNCwgMTAsIDYsIDExLCA4LCAxMSwgMTAsIDEwLCAxNCwgNywgMTYsIDYsIDE4LCA2LCAyMCwgNywgMjEsIDEwLCAyMSwgMTJdXVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiB0ZXh0VmVydGljZXModGV4dCwgbGVmdCwgYmFzZWxpbmUsIHNjYWxlKSB7XG4gICAgc2NhbGUgPSBzY2FsZSB8fCAxO1xuXG4gICAgdmFyIHN0cm9rZXMgPSBbXSxcbiAgICAgICAgaSwgbGVuLCBqLCBsZW4yLCBnbHlwaCwgeCwgeSwgcHJldjtcblxuICAgIGZvciAoaSA9IDAsIGxlbiA9IHRleHQubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgZ2x5cGggPSBzaW1wbGV4Rm9udFt0ZXh0W2ldXTtcbiAgICAgICAgaWYgKCFnbHlwaCkgY29udGludWU7XG4gICAgICAgIHByZXYgPSBudWxsO1xuXG4gICAgICAgIGZvciAoaiA9IDAsIGxlbjIgPSBnbHlwaFsxXS5sZW5ndGg7IGogPCBsZW4yOyBqICs9IDIpIHtcbiAgICAgICAgICAgIGlmIChnbHlwaFsxXVtqXSA9PT0gLTEgJiYgZ2x5cGhbMV1baiArIDFdID09PSAtMSkge1xuICAgICAgICAgICAgICAgIHByZXYgPSBudWxsO1xuXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHggPSBsZWZ0ICsgZ2x5cGhbMV1bal0gKiBzY2FsZTtcbiAgICAgICAgICAgICAgICB5ID0gYmFzZWxpbmUgLSBnbHlwaFsxXVtqICsgMV0gKiBzY2FsZTtcbiAgICAgICAgICAgICAgICBpZiAocHJldikge1xuICAgICAgICAgICAgICAgICAgICBzdHJva2VzLnB1c2gocHJldi54LCBwcmV2LnksIHgsIHkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwcmV2ID0ge3g6IHgsIHk6IHl9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxlZnQgKz0gZ2x5cGhbMF0gKiBzY2FsZTtcbiAgICB9XG5cbiAgICByZXR1cm4gc3Ryb2tlcztcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogbWFwYm94Z2wgaXMgYSBBIFdlYkdMIEphdmFTY3JpcHQgaW50ZXJhY3RpdmUgbWFwcyBsaWJyYXJ5IHRoYXQgY2FuIHJlbmRlclxuICogW01hcGJveCB2ZWN0b3IgdGlsZXNdKGh0dHBzOi8vd3d3Lm1hcGJveC5jb20vYmxvZy92ZWN0b3ItdGlsZXMvKS5cbiAqXG4gKiBAbW9kdWxlIG1hcGJveGdsXG4gKiBAc3VtbWFyeSBXZWJHTCBKYXZhU2NyaXB0IG1hcCBsaWJyYXJ5XG4gKi9cblxuLy8ganNoaW50IC1XMDc5XG52YXIgbWFwYm94Z2wgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG5tYXBib3hnbC5NYXAgPSByZXF1aXJlKCcuL3VpL21hcCcpO1xubWFwYm94Z2wuQ29udHJvbCA9IHJlcXVpcmUoJy4vdWkvY29udHJvbC9jb250cm9sJyk7XG5tYXBib3hnbC5OYXZpZ2F0aW9uID0gcmVxdWlyZSgnLi91aS9jb250cm9sL25hdmlnYXRpb24nKTtcbm1hcGJveGdsLkdlb2xvY2F0ZSA9IHJlcXVpcmUoJy4vdWkvY29udHJvbC9nZW9sb2NhdGUnKTtcbm1hcGJveGdsLkF0dHJpYnV0aW9uID0gcmVxdWlyZSgnLi91aS9jb250cm9sL2F0dHJpYnV0aW9uJyk7XG5tYXBib3hnbC5Qb3B1cCA9IHJlcXVpcmUoJy4vdWkvcG9wdXAnKTtcblxubWFwYm94Z2wuR2VvSlNPTlNvdXJjZSA9IHJlcXVpcmUoJy4vc291cmNlL2dlb2pzb25fc291cmNlJyk7XG5tYXBib3hnbC5WaWRlb1NvdXJjZSA9IHJlcXVpcmUoJy4vc291cmNlL3ZpZGVvX3NvdXJjZScpO1xubWFwYm94Z2wuSW1hZ2VTb3VyY2UgPSByZXF1aXJlKCcuL3NvdXJjZS9pbWFnZV9zb3VyY2UnKTtcblxubWFwYm94Z2wuU3R5bGUgPSByZXF1aXJlKCcuL3N0eWxlL3N0eWxlJyk7XG5cbm1hcGJveGdsLkxuZ0xhdCA9IHJlcXVpcmUoJy4vZ2VvL2xuZ19sYXQnKTtcbm1hcGJveGdsLkxuZ0xhdEJvdW5kcyA9IHJlcXVpcmUoJy4vZ2VvL2xuZ19sYXRfYm91bmRzJyk7XG5tYXBib3hnbC5Qb2ludCA9IHJlcXVpcmUoJ3BvaW50LWdlb21ldHJ5Jyk7XG5cbm1hcGJveGdsLkV2ZW50ZWQgPSByZXF1aXJlKCcuL3V0aWwvZXZlbnRlZCcpO1xubWFwYm94Z2wudXRpbCA9IHJlcXVpcmUoJy4vdXRpbC91dGlsJyk7XG5cbm1hcGJveGdsLnN1cHBvcnRlZCA9IHJlcXVpcmUoJy4vdXRpbC9icm93c2VyJykuc3VwcG9ydGVkO1xuXG52YXIgYWpheCA9IHJlcXVpcmUoJy4vdXRpbC9hamF4Jyk7XG5tYXBib3hnbC51dGlsLmdldEpTT04gPSBhamF4LmdldEpTT047XG5tYXBib3hnbC51dGlsLmdldEFycmF5QnVmZmVyID0gYWpheC5nZXRBcnJheUJ1ZmZlcjtcblxudmFyIGNvbmZpZyA9IHJlcXVpcmUoJy4vdXRpbC9jb25maWcnKTtcbm1hcGJveGdsLmNvbmZpZyA9IGNvbmZpZztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KG1hcGJveGdsLCAnYWNjZXNzVG9rZW4nLCB7XG4gICAgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIGNvbmZpZy5BQ0NFU1NfVE9LRU47IH0sXG4gICAgc2V0OiBmdW5jdGlvbih0b2tlbikgeyBjb25maWcuQUNDRVNTX1RPS0VOID0gdG9rZW47IH1cbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgVGlsZVB5cmFtaWQgPSByZXF1aXJlKCcuLi9zb3VyY2UvdGlsZV9weXJhbWlkJyk7XG52YXIgcHlyYW1pZCA9IG5ldyBUaWxlUHlyYW1pZCh7IHRpbGVTaXplOiA1MTIgfSk7XG52YXIgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwvdXRpbCcpO1xudmFyIHBpeGVsc1RvVGlsZVVuaXRzID0gcmVxdWlyZSgnLi4vc291cmNlL3BpeGVsc190b190aWxlX3VuaXRzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZHJhd0JhY2tncm91bmQ7XG5cbmZ1bmN0aW9uIGRyYXdCYWNrZ3JvdW5kKHBhaW50ZXIsIHNvdXJjZSwgbGF5ZXIpIHtcbiAgICB2YXIgZ2wgPSBwYWludGVyLmdsO1xuICAgIHZhciB0cmFuc2Zvcm0gPSBwYWludGVyLnRyYW5zZm9ybTtcbiAgICB2YXIgY29sb3IgPSB1dGlsLnByZW11bHRpcGx5KGxheWVyLnBhaW50WydiYWNrZ3JvdW5kLWNvbG9yJ10sIGxheWVyLnBhaW50WydiYWNrZ3JvdW5kLW9wYWNpdHknXSk7XG4gICAgdmFyIGltYWdlID0gbGF5ZXIucGFpbnRbJ2JhY2tncm91bmQtcGF0dGVybiddO1xuICAgIHZhciBvcGFjaXR5ID0gbGF5ZXIucGFpbnRbJ2JhY2tncm91bmQtb3BhY2l0eSddO1xuICAgIHZhciBzaGFkZXI7XG5cbiAgICB2YXIgaW1hZ2VQb3NBID0gaW1hZ2UgPyBwYWludGVyLnNwcml0ZUF0bGFzLmdldFBvc2l0aW9uKGltYWdlLmZyb20sIHRydWUpIDogbnVsbDtcbiAgICB2YXIgaW1hZ2VQb3NCID0gaW1hZ2UgPyBwYWludGVyLnNwcml0ZUF0bGFzLmdldFBvc2l0aW9uKGltYWdlLnRvLCB0cnVlKSA6IG51bGw7XG5cbiAgICBwYWludGVyLnNldERlcHRoU3VibGF5ZXIoMCk7XG4gICAgaWYgKGltYWdlUG9zQSAmJiBpbWFnZVBvc0IpIHtcblxuICAgICAgICBpZiAocGFpbnRlci5pc09wYXF1ZVBhc3MpIHJldHVybjtcblxuICAgICAgICAvLyBEcmF3IHRleHR1cmUgZmlsbFxuICAgICAgICBzaGFkZXIgPSBwYWludGVyLnBhdHRlcm5TaGFkZXI7XG4gICAgICAgIGdsLnN3aXRjaFNoYWRlcihzaGFkZXIpO1xuICAgICAgICBnbC51bmlmb3JtMWkoc2hhZGVyLnVfaW1hZ2UsIDApO1xuICAgICAgICBnbC51bmlmb3JtMmZ2KHNoYWRlci51X3BhdHRlcm5fdGxfYSwgaW1hZ2VQb3NBLnRsKTtcbiAgICAgICAgZ2wudW5pZm9ybTJmdihzaGFkZXIudV9wYXR0ZXJuX2JyX2EsIGltYWdlUG9zQS5icik7XG4gICAgICAgIGdsLnVuaWZvcm0yZnYoc2hhZGVyLnVfcGF0dGVybl90bF9iLCBpbWFnZVBvc0IudGwpO1xuICAgICAgICBnbC51bmlmb3JtMmZ2KHNoYWRlci51X3BhdHRlcm5fYnJfYiwgaW1hZ2VQb3NCLmJyKTtcbiAgICAgICAgZ2wudW5pZm9ybTFmKHNoYWRlci51X29wYWNpdHksIG9wYWNpdHkpO1xuXG4gICAgICAgIGdsLnVuaWZvcm0xZihzaGFkZXIudV9taXgsIGltYWdlLnQpO1xuXG4gICAgICAgIHBhaW50ZXIuc3ByaXRlQXRsYXMuYmluZChnbCwgdHJ1ZSk7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBEcmF3IGZpbGxpbmcgcmVjdGFuZ2xlLlxuICAgICAgICBpZiAocGFpbnRlci5pc09wYXF1ZVBhc3MgIT09IChjb2xvclszXSA9PT0gMSkpIHJldHVybjtcblxuICAgICAgICBzaGFkZXIgPSBwYWludGVyLmZpbGxTaGFkZXI7XG4gICAgICAgIGdsLnN3aXRjaFNoYWRlcihzaGFkZXIpO1xuICAgICAgICBnbC51bmlmb3JtNGZ2KHNoYWRlci51X2NvbG9yLCBjb2xvcik7XG4gICAgfVxuXG4gICAgZ2wuZGlzYWJsZShnbC5TVEVOQ0lMX1RFU1QpO1xuXG4gICAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIHBhaW50ZXIudGlsZUV4dGVudEJ1ZmZlcik7XG4gICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcihzaGFkZXIuYV9wb3MsIHBhaW50ZXIudGlsZUV4dGVudEJ1ZmZlci5pdGVtU2l6ZSwgZ2wuU0hPUlQsIGZhbHNlLCAwLCAwKTtcblxuICAgIC8vIFdlIG5lZWQgdG8gZHJhdyB0aGUgYmFja2dyb3VuZCBpbiB0aWxlcyBpbiBvcmRlciB0byB1c2UgY2FsY3VsYXRlUG9zTWF0cml4XG4gICAgLy8gd2hpY2ggYXBwbGllcyB0aGUgcHJvamVjdGlvbiBtYXRyaXggKHRyYW5zZm9ybS5wcm9qTWF0cml4KS4gT3RoZXJ3aXNlXG4gICAgLy8gdGhlIGRlcHRoIGFuZCBzdGVuY2lsIGJ1ZmZlcnMgZ2V0IGludG8gYSBiYWQgc3RhdGUuXG4gICAgLy8gVGhpcyBjYW4gYmUgcmVmYWN0b3JlZCBpbnRvIGEgc2luZ2xlIGRyYXcgY2FsbCBvbmNlIGVhcmN1dCBsYW5kcyBhbmRcbiAgICAvLyB3ZSBkb24ndCBoYXZlIHNvIG11Y2ggZ29pbmcgb24gaW4gdGhlIHN0ZW5jaWwgYnVmZmVyLlxuICAgIHZhciBjb29yZHMgPSBweXJhbWlkLmNvdmVyaW5nVGlsZXModHJhbnNmb3JtKTtcbiAgICBmb3IgKHZhciBjID0gMDsgYyA8IGNvb3Jkcy5sZW5ndGg7IGMrKykge1xuICAgICAgICB2YXIgY29vcmQgPSBjb29yZHNbY107XG4gICAgICAgIHZhciB0aWxlU2l6ZSA9IDUxMjtcbiAgICAgICAgLy8gdmFyIHBpeGVsc1RvVGlsZVVuaXRzQm91bmQgPSBwaXhlbHNUb1RpbGVVbml0cy5iaW5kKHtjb29yZDpjb29yZCwgdGlsZVNpemU6IHRpbGVTaXplfSk7XG4gICAgICAgIGlmIChpbWFnZVBvc0EgJiYgaW1hZ2VQb3NCKSB7XG4gICAgICAgICAgICB2YXIgaW1hZ2VTaXplU2NhbGVkQSA9IFtcbiAgICAgICAgICAgICAgICAoaW1hZ2VQb3NBLnNpemVbMF0gKiBpbWFnZS5mcm9tU2NhbGUpLFxuICAgICAgICAgICAgICAgIChpbWFnZVBvc0Euc2l6ZVsxXSAqIGltYWdlLmZyb21TY2FsZSlcbiAgICAgICAgICAgIF07XG4gICAgICAgICAgICB2YXIgaW1hZ2VTaXplU2NhbGVkQiA9IFtcbiAgICAgICAgICAgICAgICAoaW1hZ2VQb3NCLnNpemVbMF0gKiBpbWFnZS50b1NjYWxlKSxcbiAgICAgICAgICAgICAgICAoaW1hZ2VQb3NCLnNpemVbMV0gKiBpbWFnZS50b1NjYWxlKVxuICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIHZhciB0aWxlID0ge2Nvb3JkOmNvb3JkLCB0aWxlU2l6ZTogdGlsZVNpemV9O1xuXG4gICAgICAgICAgICBnbC51bmlmb3JtMmZ2KHNoYWRlci51X3BhdHRlcm5zY2FsZV9hLCBbXG4gICAgICAgICAgICAgICAgMSAvIHBpeGVsc1RvVGlsZVVuaXRzKHRpbGUsIGltYWdlU2l6ZVNjYWxlZEFbMF0sIHBhaW50ZXIudHJhbnNmb3JtLnRpbGVab29tKSxcbiAgICAgICAgICAgICAgICAxIC8gcGl4ZWxzVG9UaWxlVW5pdHModGlsZSwgaW1hZ2VTaXplU2NhbGVkQVsxXSwgcGFpbnRlci50cmFuc2Zvcm0udGlsZVpvb20pXG4gICAgICAgICAgICBdKTtcblxuICAgICAgICAgICAgZ2wudW5pZm9ybTJmdihzaGFkZXIudV9wYXR0ZXJuc2NhbGVfYiwgW1xuICAgICAgICAgICAgICAgIDEgLyBwaXhlbHNUb1RpbGVVbml0cyh0aWxlLCBpbWFnZVNpemVTY2FsZWRCWzBdLCBwYWludGVyLnRyYW5zZm9ybS50aWxlWm9vbSksXG4gICAgICAgICAgICAgICAgMSAvIHBpeGVsc1RvVGlsZVVuaXRzKHRpbGUsIGltYWdlU2l6ZVNjYWxlZEJbMV0sIHBhaW50ZXIudHJhbnNmb3JtLnRpbGVab29tKVxuICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICB2YXIgdGlsZVNpemVBdE5lYXJlc3Rab29tID0gdGlsZVNpemUgKiBNYXRoLnBvdygyLCBwYWludGVyLnRyYW5zZm9ybS50aWxlWm9vbSAtIGNvb3JkLnopO1xuXG4gICAgICAgICAgICB2YXIgb2Zmc2V0QXggPSAoKHRpbGVTaXplQXROZWFyZXN0Wm9vbSAvIGltYWdlU2l6ZVNjYWxlZEFbMF0pICUgMSkgKiAoY29vcmQueCArIGNvb3JkLncgKiBNYXRoLnBvdygyLCBjb29yZC56KSk7XG4gICAgICAgICAgICB2YXIgb2Zmc2V0QXkgPSAoKHRpbGVTaXplQXROZWFyZXN0Wm9vbSAvIGltYWdlU2l6ZVNjYWxlZEFbMV0pICUgMSkgKiBjb29yZC55O1xuXG4gICAgICAgICAgICB2YXIgb2Zmc2V0QnggPSAoKHRpbGVTaXplQXROZWFyZXN0Wm9vbSAvIGltYWdlU2l6ZVNjYWxlZEJbMF0pICUgMSkgKiAoY29vcmQueCArIGNvb3JkLncgKiBNYXRoLnBvdygyLCBjb29yZC56KSk7XG4gICAgICAgICAgICB2YXIgb2Zmc2V0QnkgPSAoKHRpbGVTaXplQXROZWFyZXN0Wm9vbSAvIGltYWdlU2l6ZVNjYWxlZEJbMV0pICUgMSkgKiBjb29yZC55O1xuXG4gICAgICAgICAgICBnbC51bmlmb3JtMmZ2KHNoYWRlci51X29mZnNldF9hLCBbb2Zmc2V0QXgsIG9mZnNldEF5XSk7XG4gICAgICAgICAgICBnbC51bmlmb3JtMmZ2KHNoYWRlci51X29mZnNldF9iLCBbb2Zmc2V0QngsIG9mZnNldEJ5XSk7XG4gICAgICAgIH1cblxuICAgICAgICBnbC5zZXRQb3NNYXRyaXgocGFpbnRlci5jYWxjdWxhdGVQb3NNYXRyaXgoY29vcmQpKTtcbiAgICAgICAgZ2wuZHJhd0FycmF5cyhnbC5UUklBTkdMRV9TVFJJUCwgMCwgcGFpbnRlci50aWxlRXh0ZW50QnVmZmVyLml0ZW1Db3VudCk7XG4gICAgfVxuXG4gICAgZ2wuc3RlbmNpbE1hc2soMHgwMCk7XG4gICAgZ2wuc3RlbmNpbEZ1bmMoZ2wuRVFVQUwsIDB4ODAsIDB4ODApO1xufVxuXG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBicm93c2VyID0gcmVxdWlyZSgnLi4vdXRpbC9icm93c2VyJyk7XG52YXIgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwvdXRpbCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGRyYXdDaXJjbGVzO1xuXG5mdW5jdGlvbiBkcmF3Q2lyY2xlcyhwYWludGVyLCBzb3VyY2UsIGxheWVyLCBjb29yZHMpIHtcbiAgICBpZiAocGFpbnRlci5pc09wYXF1ZVBhc3MpIHJldHVybjtcblxuICAgIHZhciBnbCA9IHBhaW50ZXIuZ2w7XG5cbiAgICB2YXIgc2hhZGVyID0gcGFpbnRlci5jaXJjbGVTaGFkZXI7XG4gICAgcGFpbnRlci5nbC5zd2l0Y2hTaGFkZXIoc2hhZGVyKTtcblxuICAgIHBhaW50ZXIuc2V0RGVwdGhTdWJsYXllcigwKTtcbiAgICBwYWludGVyLmRlcHRoTWFzayhmYWxzZSk7XG5cbiAgICAvLyBBbGxvdyBjaXJjbGVzIHRvIGJlIGRyYXduIGFjcm9zcyBib3VuZGFyaWVzLCBzbyB0aGF0XG4gICAgLy8gbGFyZ2UgY2lyY2xlcyBhcmUgbm90IGNsaXBwZWQgdG8gdGlsZXNcbiAgICBnbC5kaXNhYmxlKGdsLlNURU5DSUxfVEVTVCk7XG5cbiAgICAvLyBhbnRpYWxpYXNpbmcgZmFjdG9yOiB0aGlzIGlzIGEgbWluaW11bSBibHVyIGRpc3RhbmNlIHRoYXQgc2VydmVzIGFzXG4gICAgLy8gYSBmYXV4LWFudGlhbGlhc2luZyBmb3IgdGhlIGNpcmNsZS4gc2luY2UgYmx1ciBpcyBhIHJhdGlvIG9mIHRoZSBjaXJjbGUnc1xuICAgIC8vIHNpemUgYW5kIHRoZSBpbnRlbnQgaXMgdG8ga2VlcCB0aGUgYmx1ciBhdCByb3VnaGx5IDFweCwgdGhlIHR3b1xuICAgIC8vIGFyZSBpbnZlcnNlbHkgcmVsYXRlZC5cbiAgICB2YXIgYW50aWFsaWFzID0gMSAvIGJyb3dzZXIuZGV2aWNlUGl4ZWxSYXRpbyAvIGxheWVyLnBhaW50WydjaXJjbGUtcmFkaXVzJ107XG5cbiAgICB2YXIgY29sb3IgPSB1dGlsLnByZW11bHRpcGx5KGxheWVyLnBhaW50WydjaXJjbGUtY29sb3InXSwgbGF5ZXIucGFpbnRbJ2NpcmNsZS1vcGFjaXR5J10pO1xuICAgIGdsLnVuaWZvcm00ZnYoc2hhZGVyLnVfY29sb3IsIGNvbG9yKTtcbiAgICBnbC51bmlmb3JtMWYoc2hhZGVyLnVfYmx1ciwgTWF0aC5tYXgobGF5ZXIucGFpbnRbJ2NpcmNsZS1ibHVyJ10sIGFudGlhbGlhcykpO1xuICAgIGdsLnVuaWZvcm0xZihzaGFkZXIudV9zaXplLCBsYXllci5wYWludFsnY2lyY2xlLXJhZGl1cyddKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29vcmRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjb29yZCA9IGNvb3Jkc1tpXTtcblxuICAgICAgICB2YXIgdGlsZSA9IHNvdXJjZS5nZXRUaWxlKGNvb3JkKTtcbiAgICAgICAgdmFyIGJ1Y2tldCA9IHRpbGUuZ2V0QnVja2V0KGxheWVyKTtcbiAgICAgICAgaWYgKCFidWNrZXQpIGNvbnRpbnVlO1xuICAgICAgICB2YXIgZWxlbWVudEdyb3VwcyA9IGJ1Y2tldC5lbGVtZW50R3JvdXBzLmNpcmNsZTtcbiAgICAgICAgaWYgKCFlbGVtZW50R3JvdXBzKSBjb250aW51ZTtcblxuICAgICAgICB2YXIgdmVydGV4ID0gYnVja2V0LmJ1ZmZlcnMuY2lyY2xlVmVydGV4O1xuICAgICAgICB2YXIgZWxlbWVudHMgPSBidWNrZXQuYnVmZmVycy5jaXJjbGVFbGVtZW50O1xuXG4gICAgICAgIGdsLnNldFBvc01hdHJpeChwYWludGVyLnRyYW5zbGF0ZVBvc01hdHJpeChcbiAgICAgICAgICAgIHBhaW50ZXIuY2FsY3VsYXRlUG9zTWF0cml4KGNvb3JkLCBzb3VyY2UubWF4em9vbSksXG4gICAgICAgICAgICB0aWxlLFxuICAgICAgICAgICAgbGF5ZXIucGFpbnRbJ2NpcmNsZS10cmFuc2xhdGUnXSxcbiAgICAgICAgICAgIGxheWVyLnBhaW50WydjaXJjbGUtdHJhbnNsYXRlLWFuY2hvciddXG4gICAgICAgICkpO1xuICAgICAgICBnbC5zZXRFeE1hdHJpeChwYWludGVyLnRyYW5zZm9ybS5leE1hdHJpeCk7XG5cbiAgICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCBlbGVtZW50R3JvdXBzLmxlbmd0aDsgaysrKSB7XG4gICAgICAgICAgICB2YXIgZ3JvdXAgPSBlbGVtZW50R3JvdXBzW2tdO1xuICAgICAgICAgICAgdmFyIG9mZnNldCA9IGdyb3VwLnZlcnRleFN0YXJ0SW5kZXggKiB2ZXJ0ZXguaXRlbVNpemU7XG5cbiAgICAgICAgICAgIHZlcnRleC5iaW5kKGdsKTtcbiAgICAgICAgICAgIHZlcnRleC5zZXRBdHRyaWJQb2ludGVycyhnbCwgc2hhZGVyLCBvZmZzZXQpO1xuXG4gICAgICAgICAgICBlbGVtZW50cy5iaW5kKGdsKTtcblxuICAgICAgICAgICAgdmFyIGNvdW50ID0gZ3JvdXAuZWxlbWVudExlbmd0aCAqIDM7XG4gICAgICAgICAgICB2YXIgZWxlbWVudE9mZnNldCA9IGdyb3VwLmVsZW1lbnRTdGFydEluZGV4ICogZWxlbWVudHMuaXRlbVNpemU7XG4gICAgICAgICAgICBnbC5kcmF3RWxlbWVudHMoZ2wuVFJJQU5HTEVTLCBjb3VudCwgZ2wuVU5TSUdORURfU0hPUlQsIGVsZW1lbnRPZmZzZXQpO1xuICAgICAgICB9XG4gICAgfVxufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGRyYXdDb2xsaXNpb25EZWJ1ZztcblxuZnVuY3Rpb24gZHJhd0NvbGxpc2lvbkRlYnVnKHBhaW50ZXIsIHNvdXJjZSwgbGF5ZXIsIGNvb3Jkcykge1xuICAgIHZhciBnbCA9IHBhaW50ZXIuZ2w7XG4gICAgdmFyIHNoYWRlciA9IHBhaW50ZXIuY29sbGlzaW9uQm94U2hhZGVyO1xuICAgIGdsLmVuYWJsZShnbC5TVEVOQ0lMX1RFU1QpO1xuICAgIGdsLnN3aXRjaFNoYWRlcihzaGFkZXIpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb29yZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGNvb3JkID0gY29vcmRzW2ldO1xuICAgICAgICB2YXIgdGlsZSA9IHNvdXJjZS5nZXRUaWxlKGNvb3JkKTtcbiAgICAgICAgdmFyIGJ1Y2tldCA9IHRpbGUuZ2V0QnVja2V0KGxheWVyKTtcbiAgICAgICAgaWYgKCFidWNrZXQpIGNvbnRpbnVlO1xuICAgICAgICB2YXIgZWxlbWVudEdyb3VwcyA9IGJ1Y2tldC5lbGVtZW50R3JvdXBzLmNvbGxpc2lvbkJveDtcblxuICAgICAgICBpZiAoIWVsZW1lbnRHcm91cHMpIGNvbnRpbnVlO1xuICAgICAgICBpZiAoIWJ1Y2tldC5idWZmZXJzKSBjb250aW51ZTtcbiAgICAgICAgaWYgKGVsZW1lbnRHcm91cHNbMF0udmVydGV4TGVuZ3RoID09PSAwKSBjb250aW51ZTtcblxuICAgICAgICB2YXIgYnVmZmVyID0gYnVja2V0LmJ1ZmZlcnMuY29sbGlzaW9uQm94VmVydGV4O1xuICAgICAgICBidWZmZXIuYmluZChnbCk7XG4gICAgICAgIGJ1ZmZlci5zZXRBdHRyaWJQb2ludGVycyhnbCwgc2hhZGVyLCAwKTtcblxuICAgICAgICB2YXIgcG9zTWF0cml4ID0gcGFpbnRlci5jYWxjdWxhdGVQb3NNYXRyaXgoY29vcmQsIHNvdXJjZS5tYXh6b29tKTtcbiAgICAgICAgZ2wuc2V0UG9zTWF0cml4KHBvc01hdHJpeCk7XG5cbiAgICAgICAgcGFpbnRlci5lbmFibGVUaWxlQ2xpcHBpbmdNYXNrKGNvb3JkKTtcblxuICAgICAgICBnbC5saW5lV2lkdGgoMSk7XG4gICAgICAgIGdsLnVuaWZvcm0xZihzaGFkZXIudV9zY2FsZSwgTWF0aC5wb3coMiwgcGFpbnRlci50cmFuc2Zvcm0uem9vbSAtIHRpbGUuY29vcmQueikpO1xuICAgICAgICBnbC51bmlmb3JtMWYoc2hhZGVyLnVfem9vbSwgcGFpbnRlci50cmFuc2Zvcm0uem9vbSAqIDEwKTtcbiAgICAgICAgZ2wudW5pZm9ybTFmKHNoYWRlci51X21heHpvb20sICh0aWxlLmNvb3JkLnogKyAxKSAqIDEwKTtcblxuICAgICAgICBnbC5kcmF3QXJyYXlzKFxuICAgICAgICAgICAgZ2wuTElORVMsXG4gICAgICAgICAgICBlbGVtZW50R3JvdXBzWzBdLnZlcnRleFN0YXJ0SW5kZXgsXG4gICAgICAgICAgICBlbGVtZW50R3JvdXBzWzBdLnZlcnRleExlbmd0aFxuICAgICAgICApO1xuXG4gICAgfVxufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdGV4dFZlcnRpY2VzID0gcmVxdWlyZSgnLi4vbGliL2RlYnVndGV4dCcpO1xudmFyIGJyb3dzZXIgPSByZXF1aXJlKCcuLi91dGlsL2Jyb3dzZXInKTtcbnZhciBtYXQ0ID0gcmVxdWlyZSgnZ2wtbWF0cml4JykubWF0NDtcbnZhciBFWFRFTlQgPSByZXF1aXJlKCcuLi9kYXRhL2J1Y2tldCcpLkVYVEVOVDtcblxubW9kdWxlLmV4cG9ydHMgPSBkcmF3RGVidWc7XG5cbmZ1bmN0aW9uIGRyYXdEZWJ1ZyhwYWludGVyLCBzb3VyY2UsIGNvb3Jkcykge1xuICAgIGlmIChwYWludGVyLmlzT3BhcXVlUGFzcykgcmV0dXJuO1xuICAgIGlmICghcGFpbnRlci5vcHRpb25zLmRlYnVnKSByZXR1cm47XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvb3Jkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBkcmF3RGVidWdUaWxlKHBhaW50ZXIsIHNvdXJjZSwgY29vcmRzW2ldKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRyYXdEZWJ1Z1RpbGUocGFpbnRlciwgc291cmNlLCBjb29yZCkge1xuICAgIHZhciBnbCA9IHBhaW50ZXIuZ2w7XG5cbiAgICBnbC5kaXNhYmxlKGdsLlNURU5DSUxfVEVTVCk7XG4gICAgZ2wubGluZVdpZHRoKDEgKiBicm93c2VyLmRldmljZVBpeGVsUmF0aW8pO1xuXG4gICAgdmFyIHBvc01hdHJpeCA9IHBhaW50ZXIuY2FsY3VsYXRlUG9zTWF0cml4KGNvb3JkLCBzb3VyY2UubWF4em9vbSk7XG4gICAgdmFyIHNoYWRlciA9IHBhaW50ZXIuZGVidWdTaGFkZXI7XG4gICAgZ2wuc3dpdGNoU2hhZGVyKHNoYWRlciwgcG9zTWF0cml4KTtcblxuICAgIC8vIGRyYXcgYm91bmRpbmcgcmVjdGFuZ2xlXG4gICAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIHBhaW50ZXIuZGVidWdCdWZmZXIpO1xuICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIoc2hhZGVyLmFfcG9zLCBwYWludGVyLmRlYnVnQnVmZmVyLml0ZW1TaXplLCBnbC5TSE9SVCwgZmFsc2UsIDAsIDApO1xuICAgIGdsLnVuaWZvcm00ZihzaGFkZXIudV9jb2xvciwgMSwgMCwgMCwgMSk7XG4gICAgZ2wuZHJhd0FycmF5cyhnbC5MSU5FX1NUUklQLCAwLCBwYWludGVyLmRlYnVnQnVmZmVyLml0ZW1Db3VudCk7XG5cbiAgICB2YXIgdmVydGljZXMgPSB0ZXh0VmVydGljZXMoY29vcmQudG9TdHJpbmcoKSwgNTAsIDIwMCwgNSk7XG4gICAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIHBhaW50ZXIuZGVidWdUZXh0QnVmZmVyKTtcbiAgICBnbC5idWZmZXJEYXRhKGdsLkFSUkFZX0JVRkZFUiwgbmV3IEludDE2QXJyYXkodmVydGljZXMpLCBnbC5TVFJFQU1fRFJBVyk7XG4gICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcihzaGFkZXIuYV9wb3MsIHBhaW50ZXIuZGVidWdUZXh0QnVmZmVyLml0ZW1TaXplLCBnbC5TSE9SVCwgZmFsc2UsIDAsIDApO1xuICAgIGdsLnVuaWZvcm00ZihzaGFkZXIudV9jb2xvciwgMSwgMSwgMSwgMSk7XG5cbiAgICAvLyBEcmF3IHRoZSBoYWxvIHdpdGggbXVsdGlwbGUgMXB4IGxpbmVzIGluc3RlYWQgb2Ygb25lIHdpZGVyIGxpbmUgYmVjYXVzZVxuICAgIC8vIHRoZSBnbCBzcGVjIGRvZXNuJ3QgZ3VhcmFudGVlIHN1cHBvcnQgZm9yIGxpbmVzIHdpdGggd2lkdGggPiAxLlxuICAgIHZhciB0aWxlU2l6ZSA9IHNvdXJjZS5nZXRUaWxlKGNvb3JkKS50aWxlU2l6ZTtcbiAgICB2YXIgb25lUGl4ZWwgPSBFWFRFTlQgLyAoTWF0aC5wb3coMiwgcGFpbnRlci50cmFuc2Zvcm0uem9vbSAtIGNvb3JkLnopICogdGlsZVNpemUpO1xuICAgIHZhciB0cmFuc2xhdGlvbnMgPSBbWy0xLCAtMV0sIFstMSwgMV0sIFsxLCAtMV0sIFsxLCAxXV07XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0cmFuc2xhdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHRyYW5zbGF0aW9uID0gdHJhbnNsYXRpb25zW2ldO1xuICAgICAgICBnbC5zZXRQb3NNYXRyaXgobWF0NC50cmFuc2xhdGUoW10sIHBvc01hdHJpeCwgW29uZVBpeGVsICogdHJhbnNsYXRpb25bMF0sIG9uZVBpeGVsICogdHJhbnNsYXRpb25bMV0sIDBdKSk7XG4gICAgICAgIGdsLmRyYXdBcnJheXMoZ2wuTElORVMsIDAsIHZlcnRpY2VzLmxlbmd0aCAvIHBhaW50ZXIuZGVidWdUZXh0QnVmZmVyLml0ZW1TaXplKTtcbiAgICB9XG5cbiAgICBnbC51bmlmb3JtNGYoc2hhZGVyLnVfY29sb3IsIDAsIDAsIDAsIDEpO1xuICAgIGdsLnNldFBvc01hdHJpeChwb3NNYXRyaXgpO1xuICAgIGdsLmRyYXdBcnJheXMoZ2wuTElORVMsIDAsIHZlcnRpY2VzLmxlbmd0aCAvIHBhaW50ZXIuZGVidWdUZXh0QnVmZmVyLml0ZW1TaXplKTtcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsL3V0aWwnKTtcbnZhciBwaXhlbHNUb1RpbGVVbml0cyA9IHJlcXVpcmUoJy4uL3NvdXJjZS9waXhlbHNfdG9fdGlsZV91bml0cycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGRyYXc7XG5cbmZ1bmN0aW9uIGRyYXcocGFpbnRlciwgc291cmNlLCBsYXllciwgY29vcmRzKSB7XG4gICAgdmFyIGdsID0gcGFpbnRlci5nbDtcbiAgICBnbC5lbmFibGUoZ2wuU1RFTkNJTF9URVNUKTtcblxuICAgIHZhciBjb2xvciA9IHV0aWwucHJlbXVsdGlwbHkobGF5ZXIucGFpbnRbJ2ZpbGwtY29sb3InXSwgbGF5ZXIucGFpbnRbJ2ZpbGwtb3BhY2l0eSddKTtcbiAgICB2YXIgaW1hZ2UgPSBsYXllci5wYWludFsnZmlsbC1wYXR0ZXJuJ107XG4gICAgdmFyIHN0cm9rZUNvbG9yID0gdXRpbC5wcmVtdWx0aXBseShsYXllci5wYWludFsnZmlsbC1vdXRsaW5lLWNvbG9yJ10sIGxheWVyLnBhaW50WydmaWxsLW9wYWNpdHknXSk7XG5cbiAgICAvLyBEcmF3IGZpbGxcbiAgICBpZiAoaW1hZ2UgPyAhcGFpbnRlci5pc09wYXF1ZVBhc3MgOiBwYWludGVyLmlzT3BhcXVlUGFzcyA9PT0gKGNvbG9yWzNdID09PSAxKSkge1xuICAgICAgICAvLyBPbmNlIHdlIHN3aXRjaCB0byBlYXJjdXQgZHJhd2luZyB3ZSBjYW4gcHVsbCBtb3N0IG9mIHRoZSBXZWJHTCBzZXR1cFxuICAgICAgICAvLyBvdXRzaWRlIG9mIHRoaXMgY29vcmRzIGxvb3AuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29vcmRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBkcmF3RmlsbChwYWludGVyLCBzb3VyY2UsIGxheWVyLCBjb29yZHNbaV0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gRHJhdyBzdHJva2VcbiAgICBpZiAoIXBhaW50ZXIuaXNPcGFxdWVQYXNzICYmIGxheWVyLnBhaW50WydmaWxsLWFudGlhbGlhcyddICYmICEobGF5ZXIucGFpbnRbJ2ZpbGwtcGF0dGVybiddICYmICFzdHJva2VDb2xvcikpIHtcbiAgICAgICAgZ2wuc3dpdGNoU2hhZGVyKHBhaW50ZXIub3V0bGluZVNoYWRlcik7XG4gICAgICAgIGdsLmxpbmVXaWR0aCgyKTtcbiAgICAgICAgcGFpbnRlci5kZXB0aE1hc2soZmFsc2UpO1xuXG4gICAgICAgIGlmIChzdHJva2VDb2xvcikge1xuICAgICAgICAgICAgLy8gSWYgd2UgZGVmaW5lZCBhIGRpZmZlcmVudCBjb2xvciBmb3IgdGhlIGZpbGwgb3V0bGluZSwgd2UgYXJlXG4gICAgICAgICAgICAvLyBnb2luZyB0byBpZ25vcmUgdGhlIGJpdHMgaW4gMHgwNyBhbmQganVzdCBjYXJlIGFib3V0IHRoZSBnbG9iYWxcbiAgICAgICAgICAgIC8vIGNsaXBwaW5nIG1hc2suXG4gICAgICAgICAgICBwYWludGVyLnNldERlcHRoU3VibGF5ZXIoMik7XG5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIE90aGVyd2lzZSwgd2Ugb25seSB3YW50IHRvIGRyYXdGaWxsIHRoZSBhbnRpYWxpYXNlZCBwYXJ0cyB0aGF0IGFyZVxuICAgICAgICAgICAgLy8gKm91dHNpZGUqIHRoZSBjdXJyZW50IHNoYXBlLiBUaGlzIGlzIGltcG9ydGFudCBpbiBjYXNlIHRoZSBmaWxsXG4gICAgICAgICAgICAvLyBvciBzdHJva2UgY29sb3IgaXMgdHJhbnNsdWNlbnQuIElmIHdlIHdvdWxkbid0IGNsaXAgdG8gb3V0c2lkZVxuICAgICAgICAgICAgLy8gdGhlIGN1cnJlbnQgc2hhcGUsIHNvbWUgcGl4ZWxzIGZyb20gdGhlIG91dGxpbmUgc3Ryb2tlIG92ZXJsYXBwZWRcbiAgICAgICAgICAgIC8vIHRoZSAobm9uLWFudGlhbGlhc2VkKSBmaWxsLlxuICAgICAgICAgICAgcGFpbnRlci5zZXREZXB0aFN1YmxheWVyKDApO1xuICAgICAgICB9XG5cbiAgICAgICAgZ2wudW5pZm9ybTJmKHBhaW50ZXIub3V0bGluZVNoYWRlci51X3dvcmxkLCBnbC5kcmF3aW5nQnVmZmVyV2lkdGgsIGdsLmRyYXdpbmdCdWZmZXJIZWlnaHQpO1xuICAgICAgICBnbC51bmlmb3JtNGZ2KHBhaW50ZXIub3V0bGluZVNoYWRlci51X2NvbG9yLCBzdHJva2VDb2xvciA/IHN0cm9rZUNvbG9yIDogY29sb3IpO1xuXG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgY29vcmRzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICBkcmF3U3Ryb2tlKHBhaW50ZXIsIHNvdXJjZSwgbGF5ZXIsIGNvb3Jkc1tqXSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRyYXdGaWxsKHBhaW50ZXIsIHNvdXJjZSwgbGF5ZXIsIGNvb3JkKSB7XG4gICAgdmFyIHRpbGUgPSBzb3VyY2UuZ2V0VGlsZShjb29yZCk7XG4gICAgdmFyIGJ1Y2tldCA9IHRpbGUuZ2V0QnVja2V0KGxheWVyKTtcbiAgICBpZiAoIWJ1Y2tldCkgcmV0dXJuO1xuICAgIHZhciBlbGVtZW50R3JvdXBzID0gYnVja2V0LmVsZW1lbnRHcm91cHMuZmlsbDtcbiAgICBpZiAoIWVsZW1lbnRHcm91cHMpIHJldHVybjtcblxuICAgIHZhciBnbCA9IHBhaW50ZXIuZ2w7XG5cbiAgICB2YXIgY29sb3IgPSB1dGlsLnByZW11bHRpcGx5KGxheWVyLnBhaW50WydmaWxsLWNvbG9yJ10sIGxheWVyLnBhaW50WydmaWxsLW9wYWNpdHknXSk7XG4gICAgdmFyIGltYWdlID0gbGF5ZXIucGFpbnRbJ2ZpbGwtcGF0dGVybiddO1xuICAgIHZhciBvcGFjaXR5ID0gbGF5ZXIucGFpbnRbJ2ZpbGwtb3BhY2l0eSddO1xuXG4gICAgdmFyIHBvc01hdHJpeCA9IHBhaW50ZXIuY2FsY3VsYXRlUG9zTWF0cml4KGNvb3JkLCBzb3VyY2UubWF4em9vbSk7XG4gICAgdmFyIHRyYW5zbGF0ZWRQb3NNYXRyaXggPSBwYWludGVyLnRyYW5zbGF0ZVBvc01hdHJpeChwb3NNYXRyaXgsIHRpbGUsIGxheWVyLnBhaW50WydmaWxsLXRyYW5zbGF0ZSddLCBsYXllci5wYWludFsnZmlsbC10cmFuc2xhdGUtYW5jaG9yJ10pO1xuXG4gICAgLy8gRHJhdyB0aGUgc3RlbmNpbCBtYXNrLlxuICAgIHBhaW50ZXIuc2V0RGVwdGhTdWJsYXllcigxKTtcblxuICAgIC8vIFdlJ3JlIG9ubHkgZHJhd0ZpbGxpbmcgdG8gdGhlIGZpcnN0IHNldmVuIGJpdHMgKD09IHN1cHBvcnQgYSBtYXhpbXVtIG9mXG4gICAgLy8gOCBvdmVybGFwcGluZyBwb2x5Z29ucyBpbiBvbmUgcGxhY2UgYmVmb3JlIHdlIGdldCByZW5kZXJpbmcgZXJyb3JzKS5cbiAgICBnbC5zdGVuY2lsTWFzaygweDA3KTtcbiAgICBnbC5jbGVhcihnbC5TVEVOQ0lMX0JVRkZFUl9CSVQpO1xuXG4gICAgLy8gRHJhdyBmcm9udCBmYWNpbmcgdHJpYW5nbGVzLiBXaGVyZXZlciB0aGUgMHg4MCBiaXQgaXMgMSwgd2UgYXJlXG4gICAgLy8gaW5jcmVhc2luZyB0aGUgbG93ZXIgNyBiaXRzIGJ5IG9uZSBpZiB0aGUgdHJpYW5nbGUgaXMgYSBmcm9udC1mYWNpbmdcbiAgICAvLyB0cmlhbmdsZS4gVGhpcyBtZWFucyB0aGF0IGFsbCB2aXNpYmxlIHBvbHlnb25zIHNob3VsZCBiZSBpbiBDQ1dcbiAgICAvLyBvcmllbnRhdGlvbiwgd2hpbGUgYWxsIGhvbGVzIChzZWUgYmVsb3cpIGFyZSBpbiBDVyBvcmllbnRhdGlvbi5cbiAgICBwYWludGVyLmVuYWJsZVRpbGVDbGlwcGluZ01hc2soY29vcmQpO1xuXG4gICAgLy8gV2hlbiB3ZSBkbyBhIG5vbnplcm8gZmlsbCwgd2UgY291bnQgdGhlIG51bWJlciBvZiB0aW1lcyBhIHBpeGVsIGlzXG4gICAgLy8gY292ZXJlZCBieSBhIGNvdW50ZXJjbG9ja3dpc2UgcG9seWdvbiwgYW5kIHN1YnRyYWN0IHRoZSBudW1iZXIgb2ZcbiAgICAvLyB0aW1lcyBpdCBpcyBcInVuY292ZXJlZFwiIGJ5IGEgY2xvY2t3aXNlIHBvbHlnb24uXG4gICAgZ2wuc3RlbmNpbE9wU2VwYXJhdGUoZ2wuRlJPTlQsIGdsLktFRVAsIGdsLktFRVAsIGdsLklOQ1JfV1JBUCk7XG4gICAgZ2wuc3RlbmNpbE9wU2VwYXJhdGUoZ2wuQkFDSywgZ2wuS0VFUCwgZ2wuS0VFUCwgZ2wuREVDUl9XUkFQKTtcblxuICAgIC8vIFdoZW4gZHJhd0ZpbGxpbmcgYSBzaGFwZSwgd2UgZmlyc3QgZHJhd0ZpbGwgYWxsIHNoYXBlcyB0byB0aGUgc3RlbmNpbCBidWZmZXJcbiAgICAvLyBhbmQgaW5jcmVtZW50aW5nIGFsbCBhcmVhcyB3aGVyZSBwb2x5Z29ucyBhcmVcbiAgICBnbC5jb2xvck1hc2soZmFsc2UsIGZhbHNlLCBmYWxzZSwgZmFsc2UpO1xuICAgIHBhaW50ZXIuZGVwdGhNYXNrKGZhbHNlKTtcblxuICAgIC8vIERyYXcgdGhlIGFjdHVhbCB0cmlhbmdsZSBmYW4gaW50byB0aGUgc3RlbmNpbCBidWZmZXIuXG4gICAgZ2wuc3dpdGNoU2hhZGVyKHBhaW50ZXIuZmlsbFNoYWRlciwgdHJhbnNsYXRlZFBvc01hdHJpeCk7XG5cbiAgICAvLyBEcmF3IGFsbCBidWZmZXJzXG4gICAgdmFyIHZlcnRleCA9IGJ1Y2tldC5idWZmZXJzLmZpbGxWZXJ0ZXg7XG4gICAgdmVydGV4LmJpbmQoZ2wpO1xuXG4gICAgdmFyIGVsZW1lbnRzID0gYnVja2V0LmJ1ZmZlcnMuZmlsbEVsZW1lbnQ7XG4gICAgZWxlbWVudHMuYmluZChnbCk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVsZW1lbnRHcm91cHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGdyb3VwID0gZWxlbWVudEdyb3Vwc1tpXTtcbiAgICAgICAgdmFyIG9mZnNldCA9IGdyb3VwLnZlcnRleFN0YXJ0SW5kZXggKiB2ZXJ0ZXguaXRlbVNpemU7XG4gICAgICAgIHZlcnRleC5zZXRBdHRyaWJQb2ludGVycyhnbCwgcGFpbnRlci5maWxsU2hhZGVyLCBvZmZzZXQpO1xuXG4gICAgICAgIHZhciBjb3VudCA9IGdyb3VwLmVsZW1lbnRMZW5ndGggKiAzO1xuICAgICAgICB2YXIgZWxlbWVudE9mZnNldCA9IGdyb3VwLmVsZW1lbnRTdGFydEluZGV4ICogZWxlbWVudHMuaXRlbVNpemU7XG4gICAgICAgIGdsLmRyYXdFbGVtZW50cyhnbC5UUklBTkdMRVMsIGNvdW50LCBnbC5VTlNJR05FRF9TSE9SVCwgZWxlbWVudE9mZnNldCk7XG4gICAgfVxuXG4gICAgLy8gTm93IHRoYXQgd2UgaGF2ZSB0aGUgc3RlbmNpbCBtYXNrIGluIHRoZSBzdGVuY2lsIGJ1ZmZlciwgd2UgY2FuIHN0YXJ0XG4gICAgLy8gd3JpdGluZyB0byB0aGUgY29sb3IgYnVmZmVyLlxuICAgIGdsLmNvbG9yTWFzayh0cnVlLCB0cnVlLCB0cnVlLCB0cnVlKTtcbiAgICBwYWludGVyLmRlcHRoTWFzayh0cnVlKTtcblxuICAgIC8vIEZyb20gbm93IG9uLCB3ZSBkb24ndCB3YW50IHRvIHVwZGF0ZSB0aGUgc3RlbmNpbCBidWZmZXIgYW55bW9yZS5cbiAgICBnbC5zdGVuY2lsT3AoZ2wuS0VFUCwgZ2wuS0VFUCwgZ2wuS0VFUCk7XG4gICAgZ2wuc3RlbmNpbE1hc2soMHgwKTtcbiAgICB2YXIgc2hhZGVyO1xuXG4gICAgaWYgKGltYWdlKSB7XG4gICAgICAgIC8vIERyYXcgdGV4dHVyZSBmaWxsXG4gICAgICAgIHZhciBpbWFnZVBvc0EgPSBwYWludGVyLnNwcml0ZUF0bGFzLmdldFBvc2l0aW9uKGltYWdlLmZyb20sIHRydWUpO1xuICAgICAgICB2YXIgaW1hZ2VQb3NCID0gcGFpbnRlci5zcHJpdGVBdGxhcy5nZXRQb3NpdGlvbihpbWFnZS50bywgdHJ1ZSk7XG4gICAgICAgIGlmICghaW1hZ2VQb3NBIHx8ICFpbWFnZVBvc0IpIHJldHVybjtcblxuICAgICAgICBzaGFkZXIgPSBwYWludGVyLnBhdHRlcm5TaGFkZXI7XG4gICAgICAgIGdsLnN3aXRjaFNoYWRlcihzaGFkZXIsIHBvc01hdHJpeCk7XG4gICAgICAgIGdsLnVuaWZvcm0xaShzaGFkZXIudV9pbWFnZSwgMCk7XG4gICAgICAgIGdsLnVuaWZvcm0yZnYoc2hhZGVyLnVfcGF0dGVybl90bF9hLCBpbWFnZVBvc0EudGwpO1xuICAgICAgICBnbC51bmlmb3JtMmZ2KHNoYWRlci51X3BhdHRlcm5fYnJfYSwgaW1hZ2VQb3NBLmJyKTtcbiAgICAgICAgZ2wudW5pZm9ybTJmdihzaGFkZXIudV9wYXR0ZXJuX3RsX2IsIGltYWdlUG9zQi50bCk7XG4gICAgICAgIGdsLnVuaWZvcm0yZnYoc2hhZGVyLnVfcGF0dGVybl9icl9iLCBpbWFnZVBvc0IuYnIpO1xuICAgICAgICBnbC51bmlmb3JtMWYoc2hhZGVyLnVfb3BhY2l0eSwgb3BhY2l0eSk7XG4gICAgICAgIGdsLnVuaWZvcm0xZihzaGFkZXIudV9taXgsIGltYWdlLnQpO1xuXG4gICAgICAgIHZhciBpbWFnZVNpemVTY2FsZWRBID0gW1xuICAgICAgICAgICAgKGltYWdlUG9zQS5zaXplWzBdICogaW1hZ2UuZnJvbVNjYWxlKSxcbiAgICAgICAgICAgIChpbWFnZVBvc0Euc2l6ZVsxXSAqIGltYWdlLmZyb21TY2FsZSlcbiAgICAgICAgXTtcbiAgICAgICAgdmFyIGltYWdlU2l6ZVNjYWxlZEIgPSBbXG4gICAgICAgICAgICAoaW1hZ2VQb3NCLnNpemVbMF0gKiBpbWFnZS50b1NjYWxlKSxcbiAgICAgICAgICAgIChpbWFnZVBvc0Iuc2l6ZVsxXSAqIGltYWdlLnRvU2NhbGUpXG4gICAgICAgIF07XG5cbiAgICAgICAgZ2wudW5pZm9ybTJmdihzaGFkZXIudV9wYXR0ZXJuc2NhbGVfYSwgW1xuICAgICAgICAgICAgMSAvIHBpeGVsc1RvVGlsZVVuaXRzKHRpbGUsIGltYWdlU2l6ZVNjYWxlZEFbMF0sIHBhaW50ZXIudHJhbnNmb3JtLnRpbGVab29tKSxcbiAgICAgICAgICAgIDEgLyBwaXhlbHNUb1RpbGVVbml0cyh0aWxlLCBpbWFnZVNpemVTY2FsZWRBWzFdLCBwYWludGVyLnRyYW5zZm9ybS50aWxlWm9vbSlcbiAgICAgICAgXSk7XG5cbiAgICAgICAgZ2wudW5pZm9ybTJmdihzaGFkZXIudV9wYXR0ZXJuc2NhbGVfYiwgW1xuICAgICAgICAgICAgMSAvIHBpeGVsc1RvVGlsZVVuaXRzKHRpbGUsIGltYWdlU2l6ZVNjYWxlZEJbMF0sIHBhaW50ZXIudHJhbnNmb3JtLnRpbGVab29tKSxcbiAgICAgICAgICAgIDEgLyBwaXhlbHNUb1RpbGVVbml0cyh0aWxlLCBpbWFnZVNpemVTY2FsZWRCWzFdLCBwYWludGVyLnRyYW5zZm9ybS50aWxlWm9vbSlcbiAgICAgICAgXSk7XG5cbiAgICAgICAgdmFyIHRpbGVTaXplQXROZWFyZXN0Wm9vbSA9IHRpbGUudGlsZVNpemUgKiBNYXRoLnBvdygyLCBwYWludGVyLnRyYW5zZm9ybS50aWxlWm9vbSAtIHRpbGUuY29vcmQueik7XG5cbiAgICAgICAgLy8gc2hpZnQgaW1hZ2VzIHRvIG1hdGNoIGF0IHRpbGUgYm91bmRhcmllc1xuICAgICAgICB2YXIgb2Zmc2V0QXggPSAoKHRpbGVTaXplQXROZWFyZXN0Wm9vbSAvIGltYWdlU2l6ZVNjYWxlZEFbMF0pICUgMSkgKiAodGlsZS5jb29yZC54ICsgY29vcmQudyAqIE1hdGgucG93KDIsIHRpbGUuY29vcmQueikpO1xuICAgICAgICB2YXIgb2Zmc2V0QXkgPSAoKHRpbGVTaXplQXROZWFyZXN0Wm9vbSAvIGltYWdlU2l6ZVNjYWxlZEFbMV0pICUgMSkgKiB0aWxlLmNvb3JkLnk7XG5cbiAgICAgICAgdmFyIG9mZnNldEJ4ID0gKCh0aWxlU2l6ZUF0TmVhcmVzdFpvb20gLyBpbWFnZVNpemVTY2FsZWRCWzBdKSAlIDEpICogKHRpbGUuY29vcmQueCArIGNvb3JkLncgKiBNYXRoLnBvdygyLCB0aWxlLmNvb3JkLnopKTtcbiAgICAgICAgdmFyIG9mZnNldEJ5ID0gKCh0aWxlU2l6ZUF0TmVhcmVzdFpvb20gLyBpbWFnZVNpemVTY2FsZWRCWzFdKSAlIDEpICogdGlsZS5jb29yZC55O1xuXG4gICAgICAgIGdsLnVuaWZvcm0yZnYoc2hhZGVyLnVfb2Zmc2V0X2EsIFtvZmZzZXRBeCwgb2Zmc2V0QXldKTtcbiAgICAgICAgZ2wudW5pZm9ybTJmdihzaGFkZXIudV9vZmZzZXRfYiwgW29mZnNldEJ4LCBvZmZzZXRCeV0pO1xuXG4gICAgICAgIGdsLmFjdGl2ZVRleHR1cmUoZ2wuVEVYVFVSRTApO1xuICAgICAgICBwYWludGVyLnNwcml0ZUF0bGFzLmJpbmQoZ2wsIHRydWUpO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gRHJhdyBmaWxsaW5nIHJlY3RhbmdsZS5cbiAgICAgICAgc2hhZGVyID0gcGFpbnRlci5maWxsU2hhZGVyO1xuICAgICAgICBnbC5zd2l0Y2hTaGFkZXIoc2hhZGVyLCBwb3NNYXRyaXgpO1xuICAgICAgICBnbC51bmlmb3JtNGZ2KHNoYWRlci51X2NvbG9yLCBjb2xvcik7XG4gICAgfVxuXG4gICAgLy8gT25seSBkcmF3IHJlZ2lvbnMgdGhhdCB3ZSBtYXJrZWRcbiAgICBnbC5zdGVuY2lsRnVuYyhnbC5OT1RFUVVBTCwgMHgwLCAweDA3KTtcbiAgICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgcGFpbnRlci50aWxlRXh0ZW50QnVmZmVyKTtcbiAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKHNoYWRlci5hX3BvcywgcGFpbnRlci50aWxlRXh0ZW50QnVmZmVyLml0ZW1TaXplLCBnbC5TSE9SVCwgZmFsc2UsIDAsIDApO1xuICAgIGdsLmRyYXdBcnJheXMoZ2wuVFJJQU5HTEVfU1RSSVAsIDAsIHBhaW50ZXIudGlsZUV4dGVudEJ1ZmZlci5pdGVtQ291bnQpO1xuXG4gICAgZ2wuc3RlbmNpbE1hc2soMHgwMCk7XG59XG5cbmZ1bmN0aW9uIGRyYXdTdHJva2UocGFpbnRlciwgc291cmNlLCBsYXllciwgY29vcmQpIHtcbiAgICB2YXIgdGlsZSA9IHNvdXJjZS5nZXRUaWxlKGNvb3JkKTtcbiAgICB2YXIgYnVja2V0ID0gdGlsZS5nZXRCdWNrZXQobGF5ZXIpO1xuICAgIGlmICghYnVja2V0KSByZXR1cm47XG5cbiAgICB2YXIgZ2wgPSBwYWludGVyLmdsO1xuICAgIHZhciBlbGVtZW50R3JvdXBzID0gYnVja2V0LmVsZW1lbnRHcm91cHMuZmlsbDtcblxuICAgIGdsLnNldFBvc01hdHJpeChwYWludGVyLnRyYW5zbGF0ZVBvc01hdHJpeChcbiAgICAgICAgcGFpbnRlci5jYWxjdWxhdGVQb3NNYXRyaXgoY29vcmQsIHNvdXJjZS5tYXh6b29tKSxcbiAgICAgICAgdGlsZSxcbiAgICAgICAgbGF5ZXIucGFpbnRbJ2ZpbGwtdHJhbnNsYXRlJ10sXG4gICAgICAgIGxheWVyLnBhaW50WydmaWxsLXRyYW5zbGF0ZS1hbmNob3InXVxuICAgICkpO1xuXG4gICAgLy8gRHJhdyBhbGwgYnVmZmVyc1xuICAgIHZhciB2ZXJ0ZXggPSBidWNrZXQuYnVmZmVycy5maWxsVmVydGV4O1xuICAgIHZhciBlbGVtZW50cyA9IGJ1Y2tldC5idWZmZXJzLmZpbGxTZWNvbmRFbGVtZW50O1xuICAgIHZlcnRleC5iaW5kKGdsKTtcbiAgICBlbGVtZW50cy5iaW5kKGdsKTtcblxuICAgIHBhaW50ZXIuZW5hYmxlVGlsZUNsaXBwaW5nTWFzayhjb29yZCk7XG5cbiAgICBmb3IgKHZhciBrID0gMDsgayA8IGVsZW1lbnRHcm91cHMubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgdmFyIGdyb3VwID0gZWxlbWVudEdyb3Vwc1trXTtcbiAgICAgICAgdmFyIG9mZnNldCA9IGdyb3VwLnZlcnRleFN0YXJ0SW5kZXggKiB2ZXJ0ZXguaXRlbVNpemU7XG4gICAgICAgIHZlcnRleC5zZXRBdHRyaWJQb2ludGVycyhnbCwgcGFpbnRlci5vdXRsaW5lU2hhZGVyLCBvZmZzZXQpO1xuXG4gICAgICAgIHZhciBjb3VudCA9IGdyb3VwLnNlY29uZEVsZW1lbnRMZW5ndGggKiAyO1xuICAgICAgICB2YXIgZWxlbWVudE9mZnNldCA9IGdyb3VwLnNlY29uZEVsZW1lbnRTdGFydEluZGV4ICogZWxlbWVudHMuaXRlbVNpemU7XG4gICAgICAgIGdsLmRyYXdFbGVtZW50cyhnbC5MSU5FUywgY291bnQsIGdsLlVOU0lHTkVEX1NIT1JULCBlbGVtZW50T2Zmc2V0KTtcbiAgICB9XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBicm93c2VyID0gcmVxdWlyZSgnLi4vdXRpbC9icm93c2VyJyk7XG52YXIgbWF0MiA9IHJlcXVpcmUoJ2dsLW1hdHJpeCcpLm1hdDI7XG52YXIgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwvdXRpbCcpO1xudmFyIHBpeGVsc1RvVGlsZVVuaXRzID0gcmVxdWlyZSgnLi4vc291cmNlL3BpeGVsc190b190aWxlX3VuaXRzJyk7XG5cbi8qKlxuICogRHJhdyBhIGxpbmUuIFVuZGVyIHRoZSBob29kIHRoaXMgd2lsbCByZWFkIGVsZW1lbnRzIGZyb21cbiAqIGEgdGlsZSwgZGFzaCB0ZXh0dXJlcyBmcm9tIGEgbGluZUF0bGFzLCBhbmQgc3R5bGUgcHJvcGVydGllcyBmcm9tIGEgbGF5ZXIuXG4gKiBAcGFyYW0ge09iamVjdH0gcGFpbnRlclxuICogQHBhcmFtIHtPYmplY3R9IGxheWVyXG4gKiBAcGFyYW0ge09iamVjdH0gcG9zTWF0cml4XG4gKiBAcGFyYW0ge1RpbGV9IHRpbGVcbiAqIEByZXR1cm5zIHt1bmRlZmluZWR9IGRyYXdzIHdpdGggdGhlIHBhaW50ZXJcbiAqIEBwcml2YXRlXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZHJhd0xpbmUocGFpbnRlciwgc291cmNlLCBsYXllciwgY29vcmRzKSB7XG4gICAgaWYgKHBhaW50ZXIuaXNPcGFxdWVQYXNzKSByZXR1cm47XG4gICAgcGFpbnRlci5zZXREZXB0aFN1YmxheWVyKDApO1xuICAgIHBhaW50ZXIuZGVwdGhNYXNrKGZhbHNlKTtcblxuICAgIHZhciBoYXNEYXRhID0gY29vcmRzLnNvbWUoZnVuY3Rpb24oY29vcmQpIHtcbiAgICAgICAgdmFyIGJ1Y2tldCA9IHNvdXJjZS5nZXRUaWxlKGNvb3JkKS5nZXRCdWNrZXQobGF5ZXIpO1xuICAgICAgICByZXR1cm4gYnVja2V0ICYmIGJ1Y2tldC5lbGVtZW50R3JvdXBzLmxpbmU7XG4gICAgfSk7XG4gICAgaWYgKCFoYXNEYXRhKSByZXR1cm47XG5cbiAgICB2YXIgZ2wgPSBwYWludGVyLmdsO1xuICAgIGdsLmVuYWJsZShnbC5TVEVOQ0lMX1RFU1QpO1xuXG4gICAgLy8gZG9uJ3QgZHJhdyB6ZXJvLXdpZHRoIGxpbmVzXG4gICAgaWYgKGxheWVyLnBhaW50WydsaW5lLXdpZHRoJ10gPD0gMCkgcmV0dXJuO1xuXG4gICAgLy8gdGhlIGRpc3RhbmNlIG92ZXIgd2hpY2ggdGhlIGxpbmUgZWRnZSBmYWRlcyBvdXQuXG4gICAgLy8gUmV0aW5hIGRldmljZXMgbmVlZCBhIHNtYWxsZXIgZGlzdGFuY2UgdG8gYXZvaWQgYWxpYXNpbmcuXG4gICAgdmFyIGFudGlhbGlhc2luZyA9IDEgLyBicm93c2VyLmRldmljZVBpeGVsUmF0aW87XG5cbiAgICB2YXIgYmx1ciA9IGxheWVyLnBhaW50WydsaW5lLWJsdXInXSArIGFudGlhbGlhc2luZztcbiAgICB2YXIgZWRnZVdpZHRoID0gbGF5ZXIucGFpbnRbJ2xpbmUtd2lkdGgnXSAvIDI7XG4gICAgdmFyIGluc2V0ID0gLTE7XG4gICAgdmFyIG9mZnNldCA9IDA7XG4gICAgdmFyIHNoaWZ0ID0gMDtcblxuICAgIGlmIChsYXllci5wYWludFsnbGluZS1nYXAtd2lkdGgnXSA+IDApIHtcbiAgICAgICAgaW5zZXQgPSBsYXllci5wYWludFsnbGluZS1nYXAtd2lkdGgnXSAvIDIgKyBhbnRpYWxpYXNpbmcgKiAwLjU7XG4gICAgICAgIGVkZ2VXaWR0aCA9IGxheWVyLnBhaW50WydsaW5lLXdpZHRoJ107XG5cbiAgICAgICAgLy8gc2hpZnQgb3V0ZXIgbGluZXMgaGFsZiBhIHBpeGVsIHRvd2FyZHMgdGhlIG1pZGRsZSB0byBlbGltaW5hdGUgdGhlIGNyYWNrXG4gICAgICAgIG9mZnNldCA9IGluc2V0IC0gYW50aWFsaWFzaW5nIC8gMjtcbiAgICB9XG5cbiAgICB2YXIgb3V0c2V0ID0gb2Zmc2V0ICsgZWRnZVdpZHRoICsgYW50aWFsaWFzaW5nIC8gMiArIHNoaWZ0O1xuICAgIHZhciBjb2xvciA9IHV0aWwucHJlbXVsdGlwbHkobGF5ZXIucGFpbnRbJ2xpbmUtY29sb3InXSwgbGF5ZXIucGFpbnRbJ2xpbmUtb3BhY2l0eSddKTtcblxuICAgIHZhciB0ciA9IHBhaW50ZXIudHJhbnNmb3JtO1xuXG4gICAgdmFyIGFudGlhbGlhc2luZ01hdHJpeCA9IG1hdDIuY3JlYXRlKCk7XG4gICAgbWF0Mi5zY2FsZShhbnRpYWxpYXNpbmdNYXRyaXgsIGFudGlhbGlhc2luZ01hdHJpeCwgWzEsIE1hdGguY29zKHRyLl9waXRjaCldKTtcbiAgICBtYXQyLnJvdGF0ZShhbnRpYWxpYXNpbmdNYXRyaXgsIGFudGlhbGlhc2luZ01hdHJpeCwgcGFpbnRlci50cmFuc2Zvcm0uYW5nbGUpO1xuXG4gICAgLy8gY2FsY3VsYXRlIGhvdyBtdWNoIGxvbmdlciB0aGUgcmVhbCB3b3JsZCBkaXN0YW5jZSBpcyBhdCB0aGUgdG9wIG9mIHRoZSBzY3JlZW5cbiAgICAvLyB0aGFuIGF0IHRoZSBtaWRkbGUgb2YgdGhlIHNjcmVlbi5cbiAgICB2YXIgdG9wZWRnZWxlbmd0aCA9IE1hdGguc3FydCh0ci5oZWlnaHQgKiB0ci5oZWlnaHQgLyA0ICAqICgxICsgdHIuYWx0aXR1ZGUgKiB0ci5hbHRpdHVkZSkpO1xuICAgIHZhciB4ID0gdHIuaGVpZ2h0IC8gMiAqIE1hdGgudGFuKHRyLl9waXRjaCk7XG4gICAgdmFyIGV4dHJhID0gKHRvcGVkZ2VsZW5ndGggKyB4KSAvIHRvcGVkZ2VsZW5ndGggLSAxO1xuXG4gICAgdmFyIGRhc2hhcnJheSA9IGxheWVyLnBhaW50WydsaW5lLWRhc2hhcnJheSddO1xuICAgIHZhciBpbWFnZSA9IGxheWVyLnBhaW50WydsaW5lLXBhdHRlcm4nXTtcbiAgICB2YXIgc2hhZGVyLCBwb3NBLCBwb3NCLCBpbWFnZVBvc0EsIGltYWdlUG9zQjtcblxuICAgIGlmIChkYXNoYXJyYXkpIHtcbiAgICAgICAgc2hhZGVyID0gcGFpbnRlci5saW5lc2RmcGF0dGVyblNoYWRlcjtcbiAgICAgICAgZ2wuc3dpdGNoU2hhZGVyKHNoYWRlcik7XG5cbiAgICAgICAgZ2wudW5pZm9ybTJmdihzaGFkZXIudV9saW5ld2lkdGgsIFsgb3V0c2V0LCBpbnNldCBdKTtcbiAgICAgICAgZ2wudW5pZm9ybTFmKHNoYWRlci51X2JsdXIsIGJsdXIpO1xuICAgICAgICBnbC51bmlmb3JtNGZ2KHNoYWRlci51X2NvbG9yLCBjb2xvcik7XG5cbiAgICAgICAgcG9zQSA9IHBhaW50ZXIubGluZUF0bGFzLmdldERhc2goZGFzaGFycmF5LmZyb20sIGxheWVyLmxheW91dFsnbGluZS1jYXAnXSA9PT0gJ3JvdW5kJyk7XG4gICAgICAgIHBvc0IgPSBwYWludGVyLmxpbmVBdGxhcy5nZXREYXNoKGRhc2hhcnJheS50bywgbGF5ZXIubGF5b3V0WydsaW5lLWNhcCddID09PSAncm91bmQnKTtcblxuICAgICAgICBnbC51bmlmb3JtMWkoc2hhZGVyLnVfaW1hZ2UsIDApO1xuICAgICAgICBnbC5hY3RpdmVUZXh0dXJlKGdsLlRFWFRVUkUwKTtcbiAgICAgICAgcGFpbnRlci5saW5lQXRsYXMuYmluZChnbCk7XG5cbiAgICAgICAgZ2wudW5pZm9ybTFmKHNoYWRlci51X3RleF95X2EsIHBvc0EueSk7XG4gICAgICAgIGdsLnVuaWZvcm0xZihzaGFkZXIudV90ZXhfeV9iLCBwb3NCLnkpO1xuICAgICAgICBnbC51bmlmb3JtMWYoc2hhZGVyLnVfbWl4LCBkYXNoYXJyYXkudCk7XG5cbiAgICAgICAgZ2wudW5pZm9ybTFmKHNoYWRlci51X2V4dHJhLCBleHRyYSk7XG4gICAgICAgIGdsLnVuaWZvcm0xZihzaGFkZXIudV9vZmZzZXQsIC1sYXllci5wYWludFsnbGluZS1vZmZzZXQnXSk7XG4gICAgICAgIGdsLnVuaWZvcm1NYXRyaXgyZnYoc2hhZGVyLnVfYW50aWFsaWFzaW5nbWF0cml4LCBmYWxzZSwgYW50aWFsaWFzaW5nTWF0cml4KTtcblxuICAgIH0gZWxzZSBpZiAoaW1hZ2UpIHtcbiAgICAgICAgaW1hZ2VQb3NBID0gcGFpbnRlci5zcHJpdGVBdGxhcy5nZXRQb3NpdGlvbihpbWFnZS5mcm9tLCB0cnVlKTtcbiAgICAgICAgaW1hZ2VQb3NCID0gcGFpbnRlci5zcHJpdGVBdGxhcy5nZXRQb3NpdGlvbihpbWFnZS50bywgdHJ1ZSk7XG4gICAgICAgIGlmICghaW1hZ2VQb3NBIHx8ICFpbWFnZVBvc0IpIHJldHVybjtcblxuICAgICAgICBzaGFkZXIgPSBwYWludGVyLmxpbmVwYXR0ZXJuU2hhZGVyO1xuICAgICAgICBnbC5zd2l0Y2hTaGFkZXIoc2hhZGVyKTtcblxuICAgICAgICBnbC51bmlmb3JtMWkoc2hhZGVyLnVfaW1hZ2UsIDApO1xuICAgICAgICBnbC5hY3RpdmVUZXh0dXJlKGdsLlRFWFRVUkUwKTtcbiAgICAgICAgcGFpbnRlci5zcHJpdGVBdGxhcy5iaW5kKGdsLCB0cnVlKTtcblxuICAgICAgICBnbC51bmlmb3JtMmZ2KHNoYWRlci51X2xpbmV3aWR0aCwgWyBvdXRzZXQsIGluc2V0IF0pO1xuICAgICAgICBnbC51bmlmb3JtMWYoc2hhZGVyLnVfYmx1ciwgYmx1cik7XG4gICAgICAgIGdsLnVuaWZvcm0yZnYoc2hhZGVyLnVfcGF0dGVybl90bF9hLCBpbWFnZVBvc0EudGwpO1xuICAgICAgICBnbC51bmlmb3JtMmZ2KHNoYWRlci51X3BhdHRlcm5fYnJfYSwgaW1hZ2VQb3NBLmJyKTtcbiAgICAgICAgZ2wudW5pZm9ybTJmdihzaGFkZXIudV9wYXR0ZXJuX3RsX2IsIGltYWdlUG9zQi50bCk7XG4gICAgICAgIGdsLnVuaWZvcm0yZnYoc2hhZGVyLnVfcGF0dGVybl9icl9iLCBpbWFnZVBvc0IuYnIpO1xuICAgICAgICBnbC51bmlmb3JtMWYoc2hhZGVyLnVfZmFkZSwgaW1hZ2UudCk7XG4gICAgICAgIGdsLnVuaWZvcm0xZihzaGFkZXIudV9vcGFjaXR5LCBsYXllci5wYWludFsnbGluZS1vcGFjaXR5J10pO1xuXG4gICAgICAgIGdsLnVuaWZvcm0xZihzaGFkZXIudV9leHRyYSwgZXh0cmEpO1xuICAgICAgICBnbC51bmlmb3JtMWYoc2hhZGVyLnVfb2Zmc2V0LCAtbGF5ZXIucGFpbnRbJ2xpbmUtb2Zmc2V0J10pO1xuICAgICAgICBnbC51bmlmb3JtTWF0cml4MmZ2KHNoYWRlci51X2FudGlhbGlhc2luZ21hdHJpeCwgZmFsc2UsIGFudGlhbGlhc2luZ01hdHJpeCk7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgICBzaGFkZXIgPSBwYWludGVyLmxpbmVTaGFkZXI7XG4gICAgICAgIGdsLnN3aXRjaFNoYWRlcihzaGFkZXIpO1xuXG4gICAgICAgIGdsLnVuaWZvcm0yZnYoc2hhZGVyLnVfbGluZXdpZHRoLCBbIG91dHNldCwgaW5zZXQgXSk7XG4gICAgICAgIGdsLnVuaWZvcm0xZihzaGFkZXIudV9ibHVyLCBibHVyKTtcbiAgICAgICAgZ2wudW5pZm9ybTFmKHNoYWRlci51X2V4dHJhLCBleHRyYSk7XG4gICAgICAgIGdsLnVuaWZvcm0xZihzaGFkZXIudV9vZmZzZXQsIC1sYXllci5wYWludFsnbGluZS1vZmZzZXQnXSk7XG4gICAgICAgIGdsLnVuaWZvcm1NYXRyaXgyZnYoc2hhZGVyLnVfYW50aWFsaWFzaW5nbWF0cml4LCBmYWxzZSwgYW50aWFsaWFzaW5nTWF0cml4KTtcbiAgICAgICAgZ2wudW5pZm9ybTRmdihzaGFkZXIudV9jb2xvciwgY29sb3IpO1xuICAgIH1cblxuICAgIGZvciAodmFyIGsgPSAwOyBrIDwgY29vcmRzLmxlbmd0aDsgaysrKSB7XG4gICAgICAgIHZhciBjb29yZCA9IGNvb3Jkc1trXTtcbiAgICAgICAgdmFyIHRpbGUgPSBzb3VyY2UuZ2V0VGlsZShjb29yZCk7XG4gICAgICAgIHZhciBidWNrZXQgPSB0aWxlLmdldEJ1Y2tldChsYXllcik7XG4gICAgICAgIGlmICghYnVja2V0KSBjb250aW51ZTtcbiAgICAgICAgdmFyIGVsZW1lbnRHcm91cHMgPSBidWNrZXQuZWxlbWVudEdyb3Vwcy5saW5lO1xuICAgICAgICBpZiAoIWVsZW1lbnRHcm91cHMpIGNvbnRpbnVlO1xuXG4gICAgICAgIHBhaW50ZXIuZW5hYmxlVGlsZUNsaXBwaW5nTWFzayhjb29yZCk7XG5cbiAgICAgICAgLy8gc2V0IHVuaWZvcm1zIHRoYXQgYXJlIGRpZmZlcmVudCBmb3IgZWFjaCB0aWxlXG4gICAgICAgIHZhciBwb3NNYXRyaXggPSBwYWludGVyLnRyYW5zbGF0ZVBvc01hdHJpeChwYWludGVyLmNhbGN1bGF0ZVBvc01hdHJpeChjb29yZCwgc291cmNlLm1heHpvb20pLCB0aWxlLCBsYXllci5wYWludFsnbGluZS10cmFuc2xhdGUnXSwgbGF5ZXIucGFpbnRbJ2xpbmUtdHJhbnNsYXRlLWFuY2hvciddKTtcblxuICAgICAgICBnbC5zZXRQb3NNYXRyaXgocG9zTWF0cml4KTtcbiAgICAgICAgZ2wuc2V0RXhNYXRyaXgocGFpbnRlci50cmFuc2Zvcm0uZXhNYXRyaXgpO1xuICAgICAgICB2YXIgcmF0aW8gPSAxIC8gcGl4ZWxzVG9UaWxlVW5pdHModGlsZSwgMSwgcGFpbnRlci50cmFuc2Zvcm0uem9vbSk7XG5cbiAgICAgICAgaWYgKGRhc2hhcnJheSkge1xuICAgICAgICAgICAgdmFyIHdpZHRoQSA9IHBvc0Eud2lkdGggKiBkYXNoYXJyYXkuZnJvbVNjYWxlO1xuICAgICAgICAgICAgdmFyIHdpZHRoQiA9IHBvc0Iud2lkdGggKiBkYXNoYXJyYXkudG9TY2FsZTtcbiAgICAgICAgICAgIHZhciBzY2FsZUEgPSBbMSAvIHBpeGVsc1RvVGlsZVVuaXRzKHRpbGUsIHdpZHRoQSwgcGFpbnRlci50cmFuc2Zvcm0udGlsZVpvb20pLCAtcG9zQS5oZWlnaHQgLyAyXTtcbiAgICAgICAgICAgIHZhciBzY2FsZUIgPSBbMSAvIHBpeGVsc1RvVGlsZVVuaXRzKHRpbGUsIHdpZHRoQiwgcGFpbnRlci50cmFuc2Zvcm0udGlsZVpvb20pLCAtcG9zQi5oZWlnaHQgLyAyXTtcbiAgICAgICAgICAgIHZhciBnYW1tYSA9IHBhaW50ZXIubGluZUF0bGFzLndpZHRoIC8gKE1hdGgubWluKHdpZHRoQSwgd2lkdGhCKSAqIDI1NiAqIGJyb3dzZXIuZGV2aWNlUGl4ZWxSYXRpbykgLyAyO1xuICAgICAgICAgICAgZ2wudW5pZm9ybTFmKHNoYWRlci51X3JhdGlvLCByYXRpbyk7XG4gICAgICAgICAgICBnbC51bmlmb3JtMmZ2KHNoYWRlci51X3BhdHRlcm5zY2FsZV9hLCBzY2FsZUEpO1xuICAgICAgICAgICAgZ2wudW5pZm9ybTJmdihzaGFkZXIudV9wYXR0ZXJuc2NhbGVfYiwgc2NhbGVCKTtcbiAgICAgICAgICAgIGdsLnVuaWZvcm0xZihzaGFkZXIudV9zZGZnYW1tYSwgZ2FtbWEpO1xuXG4gICAgICAgIH0gZWxzZSBpZiAoaW1hZ2UpIHtcbiAgICAgICAgICAgIGdsLnVuaWZvcm0xZihzaGFkZXIudV9yYXRpbywgcmF0aW8pO1xuICAgICAgICAgICAgZ2wudW5pZm9ybTJmdihzaGFkZXIudV9wYXR0ZXJuX3NpemVfYSwgW1xuICAgICAgICAgICAgICAgIHBpeGVsc1RvVGlsZVVuaXRzKHRpbGUsIGltYWdlUG9zQS5zaXplWzBdICogaW1hZ2UuZnJvbVNjYWxlLCBwYWludGVyLnRyYW5zZm9ybS50aWxlWm9vbSksXG4gICAgICAgICAgICAgICAgaW1hZ2VQb3NCLnNpemVbMV1cbiAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgZ2wudW5pZm9ybTJmdihzaGFkZXIudV9wYXR0ZXJuX3NpemVfYiwgW1xuICAgICAgICAgICAgICAgIHBpeGVsc1RvVGlsZVVuaXRzKHRpbGUsIGltYWdlUG9zQi5zaXplWzBdICogaW1hZ2UudG9TY2FsZSwgcGFpbnRlci50cmFuc2Zvcm0udGlsZVpvb20pLFxuICAgICAgICAgICAgICAgIGltYWdlUG9zQi5zaXplWzFdXG4gICAgICAgICAgICBdKTtcblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZ2wudW5pZm9ybTFmKHNoYWRlci51X3JhdGlvLCByYXRpbyk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdmVydGV4ID0gYnVja2V0LmJ1ZmZlcnMubGluZVZlcnRleDtcbiAgICAgICAgdmVydGV4LmJpbmQoZ2wpO1xuICAgICAgICB2YXIgZWxlbWVudCA9IGJ1Y2tldC5idWZmZXJzLmxpbmVFbGVtZW50O1xuICAgICAgICBlbGVtZW50LmJpbmQoZ2wpO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZWxlbWVudEdyb3Vwcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGdyb3VwID0gZWxlbWVudEdyb3Vwc1tpXTtcbiAgICAgICAgICAgIHZhciB2dHhPZmZzZXQgPSBncm91cC52ZXJ0ZXhTdGFydEluZGV4ICogdmVydGV4Lml0ZW1TaXplO1xuICAgICAgICAgICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcihzaGFkZXIuYV9wb3MsIDIsIGdsLlNIT1JULCBmYWxzZSwgOCwgdnR4T2Zmc2V0ICsgMCk7XG4gICAgICAgICAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKHNoYWRlci5hX2RhdGEsIDQsIGdsLlVOU0lHTkVEX0JZVEUsIGZhbHNlLCA4LCB2dHhPZmZzZXQgKyA0KTtcblxuICAgICAgICAgICAgdmFyIGNvdW50ID0gZ3JvdXAuZWxlbWVudExlbmd0aCAqIDM7XG4gICAgICAgICAgICB2YXIgZWxlbWVudE9mZnNldCA9IGdyb3VwLmVsZW1lbnRTdGFydEluZGV4ICogZWxlbWVudC5pdGVtU2l6ZTtcbiAgICAgICAgICAgIGdsLmRyYXdFbGVtZW50cyhnbC5UUklBTkdMRVMsIGNvdW50LCBnbC5VTlNJR05FRF9TSE9SVCwgZWxlbWVudE9mZnNldCk7XG4gICAgICAgIH1cbiAgICB9XG5cbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbC91dGlsJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZHJhd1Jhc3RlcjtcblxuZnVuY3Rpb24gZHJhd1Jhc3RlcihwYWludGVyLCBzb3VyY2UsIGxheWVyLCBjb29yZHMpIHtcbiAgICBpZiAocGFpbnRlci5pc09wYXF1ZVBhc3MpIHJldHVybjtcblxuICAgIHZhciBnbCA9IHBhaW50ZXIuZ2w7XG5cbiAgICBnbC5lbmFibGUoZ2wuREVQVEhfVEVTVCk7XG4gICAgcGFpbnRlci5kZXB0aE1hc2sodHJ1ZSk7XG5cbiAgICAvLyBDaGFuZ2UgZGVwdGggZnVuY3Rpb24gdG8gcHJldmVudCBkb3VibGUgZHJhd2luZyBpbiBhcmVhcyB3aGVyZSB0aWxlcyBvdmVybGFwLlxuICAgIGdsLmRlcHRoRnVuYyhnbC5MRVNTKTtcblxuICAgIHZhciBtaW5UaWxlWiA9IGNvb3Jkcy5sZW5ndGggJiYgY29vcmRzWzBdLno7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvb3Jkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgY29vcmQgPSBjb29yZHNbaV07XG4gICAgICAgIC8vIHNldCB0aGUgbG93ZXIgem9vbSBsZXZlbCB0byBzdWJsYXllciAwLCBhbmQgaGlnaGVyIHpvb20gbGV2ZWxzIHRvIGhpZ2hlciBzdWJsYXllcnNcbiAgICAgICAgcGFpbnRlci5zZXREZXB0aFN1YmxheWVyKGNvb3JkLnogLSBtaW5UaWxlWik7XG4gICAgICAgIGRyYXdSYXN0ZXJUaWxlKHBhaW50ZXIsIHNvdXJjZSwgbGF5ZXIsIGNvb3JkKTtcbiAgICB9XG5cbiAgICBnbC5kZXB0aEZ1bmMoZ2wuTEVRVUFMKTtcbn1cblxuZnVuY3Rpb24gZHJhd1Jhc3RlclRpbGUocGFpbnRlciwgc291cmNlLCBsYXllciwgY29vcmQpIHtcblxuICAgIHZhciBnbCA9IHBhaW50ZXIuZ2w7XG5cbiAgICBnbC5kaXNhYmxlKGdsLlNURU5DSUxfVEVTVCk7XG5cbiAgICB2YXIgdGlsZSA9IHNvdXJjZS5nZXRUaWxlKGNvb3JkKTtcbiAgICB2YXIgcG9zTWF0cml4ID0gcGFpbnRlci5jYWxjdWxhdGVQb3NNYXRyaXgoY29vcmQsIHNvdXJjZS5tYXh6b29tKTtcblxuICAgIHZhciBzaGFkZXIgPSBwYWludGVyLnJhc3RlclNoYWRlcjtcbiAgICBnbC5zd2l0Y2hTaGFkZXIoc2hhZGVyLCBwb3NNYXRyaXgpO1xuXG4gICAgLy8gY29sb3IgcGFyYW1ldGVyc1xuICAgIGdsLnVuaWZvcm0xZihzaGFkZXIudV9icmlnaHRuZXNzX2xvdywgbGF5ZXIucGFpbnRbJ3Jhc3Rlci1icmlnaHRuZXNzLW1pbiddKTtcbiAgICBnbC51bmlmb3JtMWYoc2hhZGVyLnVfYnJpZ2h0bmVzc19oaWdoLCBsYXllci5wYWludFsncmFzdGVyLWJyaWdodG5lc3MtbWF4J10pO1xuICAgIGdsLnVuaWZvcm0xZihzaGFkZXIudV9zYXR1cmF0aW9uX2ZhY3Rvciwgc2F0dXJhdGlvbkZhY3RvcihsYXllci5wYWludFsncmFzdGVyLXNhdHVyYXRpb24nXSkpO1xuICAgIGdsLnVuaWZvcm0xZihzaGFkZXIudV9jb250cmFzdF9mYWN0b3IsIGNvbnRyYXN0RmFjdG9yKGxheWVyLnBhaW50WydyYXN0ZXItY29udHJhc3QnXSkpO1xuICAgIGdsLnVuaWZvcm0zZnYoc2hhZGVyLnVfc3Bpbl93ZWlnaHRzLCBzcGluV2VpZ2h0cyhsYXllci5wYWludFsncmFzdGVyLWh1ZS1yb3RhdGUnXSkpO1xuXG4gICAgdmFyIHBhcmVudFRpbGUgPSB0aWxlLnNvdXJjZSAmJiB0aWxlLnNvdXJjZS5fcHlyYW1pZC5maW5kTG9hZGVkUGFyZW50KGNvb3JkLCAwLCB7fSksXG4gICAgICAgIG9wYWNpdGllcyA9IGdldE9wYWNpdGllcyh0aWxlLCBwYXJlbnRUaWxlLCBsYXllciwgcGFpbnRlci50cmFuc2Zvcm0pO1xuXG4gICAgdmFyIHBhcmVudFNjYWxlQnksIHBhcmVudFRMO1xuXG4gICAgZ2wuYWN0aXZlVGV4dHVyZShnbC5URVhUVVJFMCk7XG4gICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGlsZS50ZXh0dXJlKTtcblxuICAgIGlmIChwYXJlbnRUaWxlKSB7XG4gICAgICAgIGdsLmFjdGl2ZVRleHR1cmUoZ2wuVEVYVFVSRTEpO1xuICAgICAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCBwYXJlbnRUaWxlLnRleHR1cmUpO1xuXG4gICAgICAgIHBhcmVudFNjYWxlQnkgPSBNYXRoLnBvdygyLCBwYXJlbnRUaWxlLmNvb3JkLnogLSB0aWxlLmNvb3JkLnopO1xuICAgICAgICBwYXJlbnRUTCA9IFt0aWxlLmNvb3JkLnggKiBwYXJlbnRTY2FsZUJ5ICUgMSwgdGlsZS5jb29yZC55ICogcGFyZW50U2NhbGVCeSAlIDFdO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIG9wYWNpdGllc1sxXSA9IDA7XG4gICAgfVxuXG4gICAgLy8gY3Jvc3MtZmFkZSBwYXJhbWV0ZXJzXG4gICAgZ2wudW5pZm9ybTJmdihzaGFkZXIudV90bF9wYXJlbnQsIHBhcmVudFRMIHx8IFswLCAwXSk7XG4gICAgZ2wudW5pZm9ybTFmKHNoYWRlci51X3NjYWxlX3BhcmVudCwgcGFyZW50U2NhbGVCeSB8fCAxKTtcbiAgICBnbC51bmlmb3JtMWYoc2hhZGVyLnVfYnVmZmVyX3NjYWxlLCAxKTtcbiAgICBnbC51bmlmb3JtMWYoc2hhZGVyLnVfb3BhY2l0eTAsIG9wYWNpdGllc1swXSk7XG4gICAgZ2wudW5pZm9ybTFmKHNoYWRlci51X29wYWNpdHkxLCBvcGFjaXRpZXNbMV0pO1xuICAgIGdsLnVuaWZvcm0xaShzaGFkZXIudV9pbWFnZTAsIDApO1xuICAgIGdsLnVuaWZvcm0xaShzaGFkZXIudV9pbWFnZTEsIDEpO1xuXG4gICAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIHRpbGUuYm91bmRzQnVmZmVyIHx8IHBhaW50ZXIudGlsZUV4dGVudEJ1ZmZlcik7XG5cbiAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKHNoYWRlci5hX3BvcywgICAgICAgICAyLCBnbC5TSE9SVCwgZmFsc2UsIDgsIDApO1xuICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIoc2hhZGVyLmFfdGV4dHVyZV9wb3MsIDIsIGdsLlNIT1JULCBmYWxzZSwgOCwgNCk7XG4gICAgZ2wuZHJhd0FycmF5cyhnbC5UUklBTkdMRV9TVFJJUCwgMCwgNCk7XG59XG5cbmZ1bmN0aW9uIHNwaW5XZWlnaHRzKGFuZ2xlKSB7XG4gICAgYW5nbGUgKj0gTWF0aC5QSSAvIDE4MDtcbiAgICB2YXIgcyA9IE1hdGguc2luKGFuZ2xlKTtcbiAgICB2YXIgYyA9IE1hdGguY29zKGFuZ2xlKTtcbiAgICByZXR1cm4gW1xuICAgICAgICAoMiAqIGMgKyAxKSAvIDMsXG4gICAgICAgICgtTWF0aC5zcXJ0KDMpICogcyAtIGMgKyAxKSAvIDMsXG4gICAgICAgIChNYXRoLnNxcnQoMykgKiBzIC0gYyArIDEpIC8gM1xuICAgIF07XG59XG5cbmZ1bmN0aW9uIGNvbnRyYXN0RmFjdG9yKGNvbnRyYXN0KSB7XG4gICAgcmV0dXJuIGNvbnRyYXN0ID4gMCA/XG4gICAgICAgIDEgLyAoMSAtIGNvbnRyYXN0KSA6XG4gICAgICAgIDEgKyBjb250cmFzdDtcbn1cblxuZnVuY3Rpb24gc2F0dXJhdGlvbkZhY3RvcihzYXR1cmF0aW9uKSB7XG4gICAgcmV0dXJuIHNhdHVyYXRpb24gPiAwID9cbiAgICAgICAgMSAtIDEgLyAoMS4wMDEgLSBzYXR1cmF0aW9uKSA6XG4gICAgICAgIC1zYXR1cmF0aW9uO1xufVxuXG5mdW5jdGlvbiBnZXRPcGFjaXRpZXModGlsZSwgcGFyZW50VGlsZSwgbGF5ZXIsIHRyYW5zZm9ybSkge1xuICAgIHZhciBvcGFjaXR5ID0gWzEsIDBdO1xuICAgIHZhciBmYWRlRHVyYXRpb24gPSBsYXllci5wYWludFsncmFzdGVyLWZhZGUtZHVyYXRpb24nXTtcblxuICAgIGlmICh0aWxlLnNvdXJjZSAmJiBmYWRlRHVyYXRpb24gPiAwKSB7XG4gICAgICAgIHZhciBub3cgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcblxuICAgICAgICB2YXIgc2luY2VUaWxlID0gKG5vdyAtIHRpbGUudGltZUFkZGVkKSAvIGZhZGVEdXJhdGlvbjtcbiAgICAgICAgdmFyIHNpbmNlUGFyZW50ID0gcGFyZW50VGlsZSA/IChub3cgLSBwYXJlbnRUaWxlLnRpbWVBZGRlZCkgLyBmYWRlRHVyYXRpb24gOiAtMTtcblxuICAgICAgICB2YXIgaWRlYWxaID0gdGlsZS5zb3VyY2UuX3B5cmFtaWQuY292ZXJpbmdab29tTGV2ZWwodHJhbnNmb3JtKTtcbiAgICAgICAgdmFyIHBhcmVudEZ1cnRoZXIgPSBwYXJlbnRUaWxlID8gTWF0aC5hYnMocGFyZW50VGlsZS5jb29yZC56IC0gaWRlYWxaKSA+IE1hdGguYWJzKHRpbGUuY29vcmQueiAtIGlkZWFsWikgOiBmYWxzZTtcblxuICAgICAgICBpZiAoIXBhcmVudFRpbGUgfHwgcGFyZW50RnVydGhlcikge1xuICAgICAgICAgICAgLy8gaWYgbm8gcGFyZW50IG9yIHBhcmVudCBpcyBvbGRlclxuICAgICAgICAgICAgb3BhY2l0eVswXSA9IHV0aWwuY2xhbXAoc2luY2VUaWxlLCAwLCAxKTtcbiAgICAgICAgICAgIG9wYWNpdHlbMV0gPSAxIC0gb3BhY2l0eVswXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIHBhcmVudCBpcyB5b3VuZ2VyLCB6b29taW5nIG91dFxuICAgICAgICAgICAgb3BhY2l0eVswXSA9IHV0aWwuY2xhbXAoMSAtIHNpbmNlUGFyZW50LCAwLCAxKTtcbiAgICAgICAgICAgIG9wYWNpdHlbMV0gPSAxIC0gb3BhY2l0eVswXTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBvcCA9IGxheWVyLnBhaW50WydyYXN0ZXItb3BhY2l0eSddO1xuICAgIG9wYWNpdHlbMF0gKj0gb3A7XG4gICAgb3BhY2l0eVsxXSAqPSBvcDtcblxuICAgIHJldHVybiBvcGFjaXR5O1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgbWF0NCA9IHJlcXVpcmUoJ2dsLW1hdHJpeCcpLm1hdDQ7XG5cbnZhciBicm93c2VyID0gcmVxdWlyZSgnLi4vdXRpbC9icm93c2VyJyk7XG52YXIgZHJhd0NvbGxpc2lvbkRlYnVnID0gcmVxdWlyZSgnLi9kcmF3X2NvbGxpc2lvbl9kZWJ1ZycpO1xudmFyIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsL3V0aWwnKTtcbnZhciBwaXhlbHNUb1RpbGVVbml0cyA9IHJlcXVpcmUoJy4uL3NvdXJjZS9waXhlbHNfdG9fdGlsZV91bml0cycpO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gZHJhd1N5bWJvbHM7XG5cbmZ1bmN0aW9uIGRyYXdTeW1ib2xzKHBhaW50ZXIsIHNvdXJjZSwgbGF5ZXIsIGNvb3Jkcykge1xuICAgIGlmIChwYWludGVyLmlzT3BhcXVlUGFzcykgcmV0dXJuO1xuXG4gICAgdmFyIGRyYXdBY3Jvc3NFZGdlcyA9ICEobGF5ZXIubGF5b3V0Wyd0ZXh0LWFsbG93LW92ZXJsYXAnXSB8fCBsYXllci5sYXlvdXRbJ2ljb24tYWxsb3ctb3ZlcmxhcCddIHx8XG4gICAgICAgIGxheWVyLmxheW91dFsndGV4dC1pZ25vcmUtcGxhY2VtZW50J10gfHwgbGF5ZXIubGF5b3V0WydpY29uLWlnbm9yZS1wbGFjZW1lbnQnXSk7XG5cbiAgICB2YXIgZ2wgPSBwYWludGVyLmdsO1xuXG4gICAgLy8gRGlzYWJsZSB0aGUgc3RlbmNpbCB0ZXN0IHNvIHRoYXQgbGFiZWxzIGFyZW4ndCBjbGlwcGVkIHRvIHRpbGUgYm91bmRhcmllcy5cbiAgICAvL1xuICAgIC8vIExheWVycyB3aXRoIGZlYXR1cmVzIHRoYXQgbWF5IGJlIGRyYXduIG92ZXJsYXBwaW5nIGFyZW4ndCBjbGlwcGVkLiBUaGVzZVxuICAgIC8vIGxheWVycyBhcmUgc29ydGVkIGluIHRoZSB5IGRpcmVjdGlvbiwgYW5kIHRvIGRyYXcgdGhlIGNvcnJlY3Qgb3JkZXJpbmcgbmVhclxuICAgIC8vIHRpbGUgZWRnZXMgdGhlIGljb25zIGFyZSBpbmNsdWRlZCBpbiBib3RoIHRpbGVzIGFuZCBjbGlwcGVkIHdoZW4gZHJhd2luZy5cbiAgICBpZiAoZHJhd0Fjcm9zc0VkZ2VzKSB7XG4gICAgICAgIGdsLmRpc2FibGUoZ2wuU1RFTkNJTF9URVNUKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBnbC5lbmFibGUoZ2wuU1RFTkNJTF9URVNUKTtcbiAgICB9XG5cbiAgICBwYWludGVyLnNldERlcHRoU3VibGF5ZXIoMCk7XG4gICAgcGFpbnRlci5kZXB0aE1hc2soZmFsc2UpO1xuICAgIGdsLmRpc2FibGUoZ2wuREVQVEhfVEVTVCk7XG5cbiAgICB2YXIgdGlsZSwgZWxlbWVudEdyb3VwcywgYnVja2V0LCBwb3NNYXRyaXg7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvb3Jkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB0aWxlID0gc291cmNlLmdldFRpbGUoY29vcmRzW2ldKTtcbiAgICAgICAgYnVja2V0ID0gdGlsZS5nZXRCdWNrZXQobGF5ZXIpO1xuICAgICAgICBpZiAoIWJ1Y2tldCkgY29udGludWU7XG4gICAgICAgIGVsZW1lbnRHcm91cHMgPSBidWNrZXQuZWxlbWVudEdyb3VwcztcbiAgICAgICAgaWYgKCFlbGVtZW50R3JvdXBzLmljb24ubGVuZ3RoKSBjb250aW51ZTtcblxuICAgICAgICBwb3NNYXRyaXggPSBwYWludGVyLmNhbGN1bGF0ZVBvc01hdHJpeChjb29yZHNbaV0sIHNvdXJjZS5tYXh6b29tKTtcbiAgICAgICAgcGFpbnRlci5lbmFibGVUaWxlQ2xpcHBpbmdNYXNrKGNvb3Jkc1tpXSk7XG4gICAgICAgIGRyYXdTeW1ib2wocGFpbnRlciwgbGF5ZXIsIHBvc01hdHJpeCwgdGlsZSwgYnVja2V0LCBlbGVtZW50R3JvdXBzLmljb24sICdpY29uJywgZWxlbWVudEdyb3Vwcy5zZGZJY29ucywgZWxlbWVudEdyb3Vwcy5pY29uc05lZWRMaW5lYXIpO1xuICAgIH1cblxuICAgIGZvciAodmFyIGogPSAwOyBqIDwgY29vcmRzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIHRpbGUgPSBzb3VyY2UuZ2V0VGlsZShjb29yZHNbal0pO1xuICAgICAgICBidWNrZXQgPSB0aWxlLmdldEJ1Y2tldChsYXllcik7XG4gICAgICAgIGlmICghYnVja2V0KSBjb250aW51ZTtcbiAgICAgICAgZWxlbWVudEdyb3VwcyA9IGJ1Y2tldC5lbGVtZW50R3JvdXBzO1xuICAgICAgICBpZiAoIWVsZW1lbnRHcm91cHMuZ2x5cGgubGVuZ3RoKSBjb250aW51ZTtcblxuICAgICAgICBwb3NNYXRyaXggPSBwYWludGVyLmNhbGN1bGF0ZVBvc01hdHJpeChjb29yZHNbal0sIHNvdXJjZS5tYXh6b29tKTtcbiAgICAgICAgcGFpbnRlci5lbmFibGVUaWxlQ2xpcHBpbmdNYXNrKGNvb3Jkc1tqXSk7XG4gICAgICAgIGRyYXdTeW1ib2wocGFpbnRlciwgbGF5ZXIsIHBvc01hdHJpeCwgdGlsZSwgYnVja2V0LCBlbGVtZW50R3JvdXBzLmdseXBoLCAndGV4dCcsIHRydWUsIGZhbHNlKTtcbiAgICB9XG5cbiAgICBnbC5lbmFibGUoZ2wuREVQVEhfVEVTVCk7XG5cbiAgICBkcmF3Q29sbGlzaW9uRGVidWcocGFpbnRlciwgc291cmNlLCBsYXllciwgY29vcmRzKTtcbn1cblxudmFyIGRlZmF1bHRTaXplcyA9IHtcbiAgICBpY29uOiAxLFxuICAgIHRleHQ6IDI0XG59O1xuXG5mdW5jdGlvbiBkcmF3U3ltYm9sKHBhaW50ZXIsIGxheWVyLCBwb3NNYXRyaXgsIHRpbGUsIGJ1Y2tldCwgZWxlbWVudEdyb3VwcywgcHJlZml4LCBzZGYsIGljb25zTmVlZExpbmVhcikge1xuICAgIHZhciBnbCA9IHBhaW50ZXIuZ2w7XG5cbiAgICBwb3NNYXRyaXggPSBwYWludGVyLnRyYW5zbGF0ZVBvc01hdHJpeChwb3NNYXRyaXgsIHRpbGUsIGxheWVyLnBhaW50W3ByZWZpeCArICctdHJhbnNsYXRlJ10sIGxheWVyLnBhaW50W3ByZWZpeCArICctdHJhbnNsYXRlLWFuY2hvciddKTtcblxuICAgIHZhciB0ciA9IHBhaW50ZXIudHJhbnNmb3JtO1xuICAgIHZhciBhbGlnbmVkV2l0aE1hcCA9IGxheWVyLmxheW91dFtwcmVmaXggKyAnLXJvdGF0aW9uLWFsaWdubWVudCddID09PSAnbWFwJztcbiAgICB2YXIgc2tld2VkID0gYWxpZ25lZFdpdGhNYXA7XG4gICAgdmFyIGV4TWF0cml4LCBzLCBnYW1tYVNjYWxlO1xuXG4gICAgaWYgKHNrZXdlZCkge1xuICAgICAgICBleE1hdHJpeCA9IG1hdDQuY3JlYXRlKCk7XG4gICAgICAgIHMgPSBwaXhlbHNUb1RpbGVVbml0cyh0aWxlLCAxLCBwYWludGVyLnRyYW5zZm9ybS56b29tKTtcbiAgICAgICAgZ2FtbWFTY2FsZSA9IDEgLyBNYXRoLmNvcyh0ci5fcGl0Y2gpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGV4TWF0cml4ID0gbWF0NC5jbG9uZShwYWludGVyLnRyYW5zZm9ybS5leE1hdHJpeCk7XG4gICAgICAgIHMgPSBwYWludGVyLnRyYW5zZm9ybS5hbHRpdHVkZTtcbiAgICAgICAgZ2FtbWFTY2FsZSA9IDE7XG4gICAgfVxuICAgIG1hdDQuc2NhbGUoZXhNYXRyaXgsIGV4TWF0cml4LCBbcywgcywgMV0pO1xuXG4gICAgdmFyIGZvbnRTaXplID0gbGF5ZXIubGF5b3V0W3ByZWZpeCArICctc2l6ZSddO1xuICAgIHZhciBmb250U2NhbGUgPSBmb250U2l6ZSAvIGRlZmF1bHRTaXplc1twcmVmaXhdO1xuICAgIG1hdDQuc2NhbGUoZXhNYXRyaXgsIGV4TWF0cml4LCBbIGZvbnRTY2FsZSwgZm9udFNjYWxlLCAxIF0pO1xuXG4gICAgLy8gY2FsY3VsYXRlIGhvdyBtdWNoIGxvbmdlciB0aGUgcmVhbCB3b3JsZCBkaXN0YW5jZSBpcyBhdCB0aGUgdG9wIG9mIHRoZSBzY3JlZW5cbiAgICAvLyB0aGFuIGF0IHRoZSBtaWRkbGUgb2YgdGhlIHNjcmVlbi5cbiAgICB2YXIgdG9wZWRnZWxlbmd0aCA9IE1hdGguc3FydCh0ci5oZWlnaHQgKiB0ci5oZWlnaHQgLyA0ICAqICgxICsgdHIuYWx0aXR1ZGUgKiB0ci5hbHRpdHVkZSkpO1xuICAgIHZhciB4ID0gdHIuaGVpZ2h0IC8gMiAqIE1hdGgudGFuKHRyLl9waXRjaCk7XG4gICAgdmFyIGV4dHJhID0gKHRvcGVkZ2VsZW5ndGggKyB4KSAvIHRvcGVkZ2VsZW5ndGggLSAxO1xuXG4gICAgdmFyIHRleHQgPSBwcmVmaXggPT09ICd0ZXh0JztcbiAgICB2YXIgc2hhZGVyLCB2ZXJ0ZXgsIGVsZW1lbnRzLCB0ZXhzaXplO1xuXG4gICAgaWYgKCF0ZXh0ICYmICFwYWludGVyLnN0eWxlLnNwcml0ZS5sb2FkZWQoKSlcbiAgICAgICAgcmV0dXJuO1xuXG4gICAgZ2wuYWN0aXZlVGV4dHVyZShnbC5URVhUVVJFMCk7XG5cbiAgICBpZiAoc2RmKSB7XG4gICAgICAgIHNoYWRlciA9IHBhaW50ZXIuc2RmU2hhZGVyO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHNoYWRlciA9IHBhaW50ZXIuaWNvblNoYWRlcjtcbiAgICB9XG5cbiAgICBpZiAodGV4dCkge1xuICAgICAgICAvLyB1c2UgdGhlIGZvbnN0YWNrIHVzZWQgd2hlbiBwYXJzaW5nIHRoZSB0aWxlLCBub3QgdGhlIGZvbnRzdGFja1xuICAgICAgICAvLyBhdCB0aGUgY3VycmVudCB6b29tIGxldmVsIChsYXlvdXRbJ3RleHQtZm9udCddKS5cbiAgICAgICAgdmFyIGZvbnRzdGFjayA9IGVsZW1lbnRHcm91cHMuZm9udHN0YWNrO1xuICAgICAgICB2YXIgZ2x5cGhBdGxhcyA9IGZvbnRzdGFjayAmJiBwYWludGVyLmdseXBoU291cmNlLmdldEdseXBoQXRsYXMoZm9udHN0YWNrKTtcbiAgICAgICAgaWYgKCFnbHlwaEF0bGFzKSByZXR1cm47XG5cbiAgICAgICAgZ2x5cGhBdGxhcy51cGRhdGVUZXh0dXJlKGdsKTtcbiAgICAgICAgdmVydGV4ID0gYnVja2V0LmJ1ZmZlcnMuZ2x5cGhWZXJ0ZXg7XG4gICAgICAgIGVsZW1lbnRzID0gYnVja2V0LmJ1ZmZlcnMuZ2x5cGhFbGVtZW50O1xuICAgICAgICB0ZXhzaXplID0gW2dseXBoQXRsYXMud2lkdGggLyA0LCBnbHlwaEF0bGFzLmhlaWdodCAvIDRdO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBtYXBNb3ZpbmcgPSBwYWludGVyLm9wdGlvbnMucm90YXRpbmcgfHwgcGFpbnRlci5vcHRpb25zLnpvb21pbmc7XG4gICAgICAgIHZhciBpY29uU2NhbGVkID0gZm9udFNjYWxlICE9PSAxIHx8IGJyb3dzZXIuZGV2aWNlUGl4ZWxSYXRpbyAhPT0gcGFpbnRlci5zcHJpdGVBdGxhcy5waXhlbFJhdGlvIHx8IGljb25zTmVlZExpbmVhcjtcbiAgICAgICAgdmFyIGljb25UcmFuc2Zvcm1lZCA9IGFsaWduZWRXaXRoTWFwIHx8IHBhaW50ZXIudHJhbnNmb3JtLnBpdGNoO1xuICAgICAgICBwYWludGVyLnNwcml0ZUF0bGFzLmJpbmQoZ2wsIHNkZiB8fCBtYXBNb3ZpbmcgfHwgaWNvblNjYWxlZCB8fCBpY29uVHJhbnNmb3JtZWQpO1xuICAgICAgICB2ZXJ0ZXggPSBidWNrZXQuYnVmZmVycy5pY29uVmVydGV4O1xuICAgICAgICBlbGVtZW50cyA9IGJ1Y2tldC5idWZmZXJzLmljb25FbGVtZW50O1xuICAgICAgICB0ZXhzaXplID0gW3BhaW50ZXIuc3ByaXRlQXRsYXMud2lkdGggLyA0LCBwYWludGVyLnNwcml0ZUF0bGFzLmhlaWdodCAvIDRdO1xuICAgIH1cblxuICAgIGdsLnN3aXRjaFNoYWRlcihzaGFkZXIsIHBvc01hdHJpeCwgZXhNYXRyaXgpO1xuICAgIGdsLnVuaWZvcm0xaShzaGFkZXIudV90ZXh0dXJlLCAwKTtcbiAgICBnbC51bmlmb3JtMmZ2KHNoYWRlci51X3RleHNpemUsIHRleHNpemUpO1xuICAgIGdsLnVuaWZvcm0xaShzaGFkZXIudV9za2V3ZWQsIHNrZXdlZCk7XG4gICAgZ2wudW5pZm9ybTFmKHNoYWRlci51X2V4dHJhLCBleHRyYSk7XG5cbiAgICAvLyBhZGp1c3QgbWluL21heCB6b29tcyBmb3IgdmFyaWFibGUgZm9udCBzaXplc1xuICAgIHZhciB6b29tQWRqdXN0ID0gTWF0aC5sb2coZm9udFNpemUgLyBlbGVtZW50R3JvdXBzLmFkanVzdGVkU2l6ZSkgLyBNYXRoLkxOMiB8fCAwO1xuXG5cbiAgICBnbC51bmlmb3JtMWYoc2hhZGVyLnVfem9vbSwgKHBhaW50ZXIudHJhbnNmb3JtLnpvb20gLSB6b29tQWRqdXN0KSAqIDEwKTsgLy8gY3VycmVudCB6b29tIGxldmVsXG5cbiAgICB2YXIgZiA9IHBhaW50ZXIuZnJhbWVIaXN0b3J5LmdldEZhZGVQcm9wZXJ0aWVzKDMwMCk7XG4gICAgZ2wudW5pZm9ybTFmKHNoYWRlci51X2ZhZGVkaXN0LCBmLmZhZGVkaXN0ICogMTApO1xuICAgIGdsLnVuaWZvcm0xZihzaGFkZXIudV9taW5mYWRlem9vbSwgTWF0aC5mbG9vcihmLm1pbmZhZGV6b29tICogMTApKTtcbiAgICBnbC51bmlmb3JtMWYoc2hhZGVyLnVfbWF4ZmFkZXpvb20sIE1hdGguZmxvb3IoZi5tYXhmYWRlem9vbSAqIDEwKSk7XG4gICAgZ2wudW5pZm9ybTFmKHNoYWRlci51X2ZhZGV6b29tLCAocGFpbnRlci50cmFuc2Zvcm0uem9vbSArIGYuYnVtcCkgKiAxMCk7XG5cbiAgICB2YXIgZ3JvdXAsIG9mZnNldCwgY291bnQsIGVsZW1lbnRPZmZzZXQ7XG5cbiAgICBlbGVtZW50cy5iaW5kKGdsKTtcblxuICAgIGlmIChzZGYpIHtcbiAgICAgICAgdmFyIHNkZlB4ID0gODtcbiAgICAgICAgdmFyIGJsdXJPZmZzZXQgPSAxLjE5O1xuICAgICAgICB2YXIgaGFsb09mZnNldCA9IDY7XG4gICAgICAgIHZhciBnYW1tYSA9IDAuMTA1ICogZGVmYXVsdFNpemVzW3ByZWZpeF0gLyBmb250U2l6ZSAvIGJyb3dzZXIuZGV2aWNlUGl4ZWxSYXRpbztcblxuICAgICAgICBpZiAobGF5ZXIucGFpbnRbcHJlZml4ICsgJy1oYWxvLXdpZHRoJ10pIHtcbiAgICAgICAgICAgIHZhciBoYWxvQ29sb3IgPSB1dGlsLnByZW11bHRpcGx5KGxheWVyLnBhaW50W3ByZWZpeCArICctaGFsby1jb2xvciddLCBsYXllci5wYWludFtwcmVmaXggKyAnLW9wYWNpdHknXSk7XG5cbiAgICAgICAgICAgIC8vIERyYXcgaGFsbyB1bmRlcm5lYXRoIHRoZSB0ZXh0LlxuICAgICAgICAgICAgZ2wudW5pZm9ybTFmKHNoYWRlci51X2dhbW1hLCAobGF5ZXIucGFpbnRbcHJlZml4ICsgJy1oYWxvLWJsdXInXSAqIGJsdXJPZmZzZXQgLyBmb250U2NhbGUgLyBzZGZQeCArIGdhbW1hKSAqIGdhbW1hU2NhbGUpO1xuICAgICAgICAgICAgZ2wudW5pZm9ybTRmdihzaGFkZXIudV9jb2xvciwgaGFsb0NvbG9yKTtcbiAgICAgICAgICAgIGdsLnVuaWZvcm0xZihzaGFkZXIudV9idWZmZXIsIChoYWxvT2Zmc2V0IC0gbGF5ZXIucGFpbnRbcHJlZml4ICsgJy1oYWxvLXdpZHRoJ10gLyBmb250U2NhbGUpIC8gc2RmUHgpO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGVsZW1lbnRHcm91cHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICBncm91cCA9IGVsZW1lbnRHcm91cHNbal07XG4gICAgICAgICAgICAgICAgb2Zmc2V0ID0gZ3JvdXAudmVydGV4U3RhcnRJbmRleCAqIHZlcnRleC5pdGVtU2l6ZTtcbiAgICAgICAgICAgICAgICB2ZXJ0ZXguYmluZChnbCk7XG4gICAgICAgICAgICAgICAgdmVydGV4LnNldEF0dHJpYlBvaW50ZXJzKGdsLCBzaGFkZXIsIG9mZnNldCk7XG5cbiAgICAgICAgICAgICAgICBjb3VudCA9IGdyb3VwLmVsZW1lbnRMZW5ndGggKiAzO1xuICAgICAgICAgICAgICAgIGVsZW1lbnRPZmZzZXQgPSBncm91cC5lbGVtZW50U3RhcnRJbmRleCAqIGVsZW1lbnRzLml0ZW1TaXplO1xuICAgICAgICAgICAgICAgIGdsLmRyYXdFbGVtZW50cyhnbC5UUklBTkdMRVMsIGNvdW50LCBnbC5VTlNJR05FRF9TSE9SVCwgZWxlbWVudE9mZnNldCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgY29sb3IgPSB1dGlsLnByZW11bHRpcGx5KGxheWVyLnBhaW50W3ByZWZpeCArICctY29sb3InXSwgbGF5ZXIucGFpbnRbcHJlZml4ICsgJy1vcGFjaXR5J10pO1xuICAgICAgICBnbC51bmlmb3JtMWYoc2hhZGVyLnVfZ2FtbWEsIGdhbW1hICogZ2FtbWFTY2FsZSk7XG4gICAgICAgIGdsLnVuaWZvcm00ZnYoc2hhZGVyLnVfY29sb3IsIGNvbG9yKTtcbiAgICAgICAgZ2wudW5pZm9ybTFmKHNoYWRlci51X2J1ZmZlciwgKDI1NiAtIDY0KSAvIDI1Nik7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbGVtZW50R3JvdXBzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBncm91cCA9IGVsZW1lbnRHcm91cHNbaV07XG4gICAgICAgICAgICBvZmZzZXQgPSBncm91cC52ZXJ0ZXhTdGFydEluZGV4ICogdmVydGV4Lml0ZW1TaXplO1xuICAgICAgICAgICAgdmVydGV4LmJpbmQoZ2wpO1xuICAgICAgICAgICAgdmVydGV4LnNldEF0dHJpYlBvaW50ZXJzKGdsLCBzaGFkZXIsIG9mZnNldCk7XG5cbiAgICAgICAgICAgIGNvdW50ID0gZ3JvdXAuZWxlbWVudExlbmd0aCAqIDM7XG4gICAgICAgICAgICBlbGVtZW50T2Zmc2V0ID0gZ3JvdXAuZWxlbWVudFN0YXJ0SW5kZXggKiBlbGVtZW50cy5pdGVtU2l6ZTtcbiAgICAgICAgICAgIGdsLmRyYXdFbGVtZW50cyhnbC5UUklBTkdMRVMsIGNvdW50LCBnbC5VTlNJR05FRF9TSE9SVCwgZWxlbWVudE9mZnNldCk7XG4gICAgICAgIH1cblxuICAgIH0gZWxzZSB7XG4gICAgICAgIGdsLnVuaWZvcm0xZihzaGFkZXIudV9vcGFjaXR5LCBsYXllci5wYWludFsnaWNvbi1vcGFjaXR5J10pO1xuICAgICAgICBmb3IgKHZhciBrID0gMDsgayA8IGVsZW1lbnRHcm91cHMubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgICAgIGdyb3VwID0gZWxlbWVudEdyb3Vwc1trXTtcbiAgICAgICAgICAgIG9mZnNldCA9IGdyb3VwLnZlcnRleFN0YXJ0SW5kZXggKiB2ZXJ0ZXguaXRlbVNpemU7XG4gICAgICAgICAgICB2ZXJ0ZXguYmluZChnbCk7XG4gICAgICAgICAgICB2ZXJ0ZXguc2V0QXR0cmliUG9pbnRlcnMoZ2wsIHNoYWRlciwgb2Zmc2V0KTtcblxuICAgICAgICAgICAgY291bnQgPSBncm91cC5lbGVtZW50TGVuZ3RoICogMztcbiAgICAgICAgICAgIGVsZW1lbnRPZmZzZXQgPSBncm91cC5lbGVtZW50U3RhcnRJbmRleCAqIGVsZW1lbnRzLml0ZW1TaXplO1xuICAgICAgICAgICAgZ2wuZHJhd0VsZW1lbnRzKGdsLlRSSUFOR0xFUywgY291bnQsIGdsLlVOU0lHTkVEX1NIT1JULCBlbGVtZW50T2Zmc2V0KTtcbiAgICAgICAgfVxuICAgIH1cbn1cbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBGcmFtZUhpc3Rvcnk7XG5cbmZ1bmN0aW9uIEZyYW1lSGlzdG9yeSgpIHtcbiAgICB0aGlzLmZyYW1lSGlzdG9yeSA9IFtdO1xufVxuXG5GcmFtZUhpc3RvcnkucHJvdG90eXBlLmdldEZhZGVQcm9wZXJ0aWVzID0gZnVuY3Rpb24oZHVyYXRpb24pIHtcbiAgICBpZiAoZHVyYXRpb24gPT09IHVuZGVmaW5lZCkgZHVyYXRpb24gPSAzMDA7XG4gICAgdmFyIGN1cnJlbnRUaW1lID0gKG5ldyBEYXRlKCkpLmdldFRpbWUoKTtcblxuICAgIC8vIFJlbW92ZSBmcmFtZXMgdW50aWwgb25seSBvbmUgaXMgb3V0c2lkZSB0aGUgZHVyYXRpb24sIG9yIHVudGlsIHRoZXJlIGFyZSBvbmx5IHRocmVlXG4gICAgd2hpbGUgKHRoaXMuZnJhbWVIaXN0b3J5Lmxlbmd0aCA+IDMgJiYgdGhpcy5mcmFtZUhpc3RvcnlbMV0udGltZSArIGR1cmF0aW9uIDwgY3VycmVudFRpbWUpIHtcbiAgICAgICAgdGhpcy5mcmFtZUhpc3Rvcnkuc2hpZnQoKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5mcmFtZUhpc3RvcnlbMV0udGltZSArIGR1cmF0aW9uIDwgY3VycmVudFRpbWUpIHtcbiAgICAgICAgdGhpcy5mcmFtZUhpc3RvcnlbMF0ueiA9IHRoaXMuZnJhbWVIaXN0b3J5WzFdLno7XG4gICAgfVxuXG4gICAgdmFyIGZyYW1lTGVuID0gdGhpcy5mcmFtZUhpc3RvcnkubGVuZ3RoO1xuICAgIGlmIChmcmFtZUxlbiA8IDMpIGNvbnNvbGUud2FybigndGhlcmUgc2hvdWxkIG5ldmVyIGJlIGxlc3MgdGhhbiB0aHJlZSBmcmFtZXMgaW4gdGhlIGhpc3RvcnknKTtcblxuICAgIC8vIEZpbmQgdGhlIHJhbmdlIG9mIHpvb20gbGV2ZWxzIHdlIHdhbnQgdG8gZmFkZSBiZXR3ZWVuXG4gICAgdmFyIHN0YXJ0aW5nWiA9IHRoaXMuZnJhbWVIaXN0b3J5WzBdLnosXG4gICAgICAgIGxhc3RGcmFtZSA9IHRoaXMuZnJhbWVIaXN0b3J5W2ZyYW1lTGVuIC0gMV0sXG4gICAgICAgIGVuZGluZ1ogPSBsYXN0RnJhbWUueixcbiAgICAgICAgbG93WiA9IE1hdGgubWluKHN0YXJ0aW5nWiwgZW5kaW5nWiksXG4gICAgICAgIGhpZ2haID0gTWF0aC5tYXgoc3RhcnRpbmdaLCBlbmRpbmdaKTtcblxuICAgIC8vIENhbGN1bGF0ZSB0aGUgc3BlZWQgb2Ygem9vbWluZywgYW5kIGhvdyBmYXIgaXQgd291bGQgem9vbSBpbiB0ZXJtcyBvZiB6b29tIGxldmVscyBpbiBvbmUgZHVyYXRpb25cbiAgICB2YXIgem9vbURpZmYgPSBsYXN0RnJhbWUueiAtIHRoaXMuZnJhbWVIaXN0b3J5WzFdLnosXG4gICAgICAgIHRpbWVEaWZmID0gbGFzdEZyYW1lLnRpbWUgLSB0aGlzLmZyYW1lSGlzdG9yeVsxXS50aW1lO1xuICAgIHZhciBmYWRlZGlzdCA9IHpvb21EaWZmIC8gKHRpbWVEaWZmIC8gZHVyYXRpb24pO1xuXG4gICAgaWYgKGlzTmFOKGZhZGVkaXN0KSkgY29uc29sZS53YXJuKCdmYWRlZGlzdCBzaG91bGQgbmV2ZXIgYmUgTmFOJyk7XG5cbiAgICAvLyBBdCBlbmQgb2YgYSB6b29tIHdoZW4gdGhlIHpvb20gc3RvcHMgY2hhbmdpbmcgY29udGludWUgcHJldGVuZGluZyB0byB6b29tIGF0IHRoYXQgc3BlZWRcbiAgICAvLyBidW1wIGlzIGhvdyBtdWNoIGZhcnRoZXIgaXQgd291bGQgaGF2ZSBiZWVuIGlmIGl0IGhhZCBjb250aW51ZWQgem9vbWluZyBhdCB0aGUgc2FtZSByYXRlXG4gICAgdmFyIGJ1bXAgPSAoY3VycmVudFRpbWUgLSBsYXN0RnJhbWUudGltZSkgLyBkdXJhdGlvbiAqIGZhZGVkaXN0O1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgZmFkZWRpc3Q6IGZhZGVkaXN0LFxuICAgICAgICBtaW5mYWRlem9vbTogbG93WixcbiAgICAgICAgbWF4ZmFkZXpvb206IGhpZ2haLFxuICAgICAgICBidW1wOiBidW1wXG4gICAgfTtcbn07XG5cbi8vIFJlY29yZCBmcmFtZSBoaXN0b3J5IHRoYXQgd2lsbCBiZSB1c2VkIHRvIGNhbGN1bGF0ZSBmYWRpbmcgcGFyYW1zXG5GcmFtZUhpc3RvcnkucHJvdG90eXBlLnJlY29yZCA9IGZ1bmN0aW9uKHpvb20pIHtcbiAgICB2YXIgY3VycmVudFRpbWUgPSAobmV3IERhdGUoKSkuZ2V0VGltZSgpO1xuXG4gICAgLy8gZmlyc3QgZnJhbWUgZXZlclxuICAgIGlmICghdGhpcy5mcmFtZUhpc3RvcnkubGVuZ3RoKSB7XG4gICAgICAgIHRoaXMuZnJhbWVIaXN0b3J5LnB1c2goe3RpbWU6IDAsIHo6IHpvb20gfSwge3RpbWU6IDAsIHo6IHpvb20gfSk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuZnJhbWVIaXN0b3J5Lmxlbmd0aCA9PT0gMiB8fCB0aGlzLmZyYW1lSGlzdG9yeVt0aGlzLmZyYW1lSGlzdG9yeS5sZW5ndGggLSAxXS56ICE9PSB6b29tKSB7XG4gICAgICAgIHRoaXMuZnJhbWVIaXN0b3J5LnB1c2goe1xuICAgICAgICAgICAgdGltZTogY3VycmVudFRpbWUsXG4gICAgICAgICAgICB6OiB6b29tXG4gICAgICAgIH0pO1xuICAgIH1cbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBzaGFkZXJzID0gcmVxdWlyZSgnLi9zaGFkZXJzJyk7XG52YXIgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwvdXRpbCcpO1xuXG5leHBvcnRzLmV4dGVuZCA9IGZ1bmN0aW9uKGNvbnRleHQpIHtcbiAgICB2YXIgb3JpZ0xpbmVXaWR0aCA9IGNvbnRleHQubGluZVdpZHRoLFxuICAgICAgICBsaW5lV2lkdGhSYW5nZSA9IGNvbnRleHQuZ2V0UGFyYW1ldGVyKGNvbnRleHQuQUxJQVNFRF9MSU5FX1dJRFRIX1JBTkdFKTtcblxuICAgIGNvbnRleHQubGluZVdpZHRoID0gZnVuY3Rpb24od2lkdGgpIHtcbiAgICAgICAgb3JpZ0xpbmVXaWR0aC5jYWxsKGNvbnRleHQsIHV0aWwuY2xhbXAod2lkdGgsIGxpbmVXaWR0aFJhbmdlWzBdLCBsaW5lV2lkdGhSYW5nZVsxXSkpO1xuICAgIH07XG5cbiAgICBjb250ZXh0LmdldFNoYWRlciA9IGZ1bmN0aW9uKG5hbWUsIHR5cGUpIHtcbiAgICAgICAgdmFyIHR5cGVTdHJpbmcgPSB0eXBlID09PSB0aGlzLkZSQUdNRU5UX1NIQURFUiA/ICdmcmFnbWVudCcgOiAndmVydGV4JztcbiAgICAgICAgaWYgKCFzaGFkZXJzW25hbWVdIHx8ICFzaGFkZXJzW25hbWVdW3R5cGVTdHJpbmddKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZCBub3QgZmluZCBzaGFkZXIgXCIgKyBuYW1lKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzaGFkZXIgPSB0aGlzLmNyZWF0ZVNoYWRlcih0eXBlKTtcbiAgICAgICAgdmFyIHNoYWRlclNvdXJjZSA9IHNoYWRlcnNbbmFtZV1bdHlwZVN0cmluZ107XG5cbiAgICAgICAgdGhpcy5zaGFkZXJTb3VyY2Uoc2hhZGVyLCBzaGFkZXJTb3VyY2UpO1xuICAgICAgICB0aGlzLmNvbXBpbGVTaGFkZXIoc2hhZGVyKTtcbiAgICAgICAgaWYgKCF0aGlzLmdldFNoYWRlclBhcmFtZXRlcihzaGFkZXIsIHRoaXMuQ09NUElMRV9TVEFUVVMpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IobmFtZSArICcgJyArIHR5cGVTdHJpbmcgKyB0aGlzLmdldFNoYWRlckluZm9Mb2coc2hhZGVyKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNoYWRlcjtcbiAgICB9O1xuXG4gICAgY29udGV4dC5pbml0aWFsaXplU2hhZGVyID0gZnVuY3Rpb24obmFtZSwgYXR0cmlidXRlcywgdW5pZm9ybXMpIHtcbiAgICAgICAgdmFyIHNoYWRlciA9IHtcbiAgICAgICAgICAgIHByb2dyYW06IHRoaXMuY3JlYXRlUHJvZ3JhbSgpLFxuICAgICAgICAgICAgZnJhZ21lbnQ6IHRoaXMuZ2V0U2hhZGVyKG5hbWUsIHRoaXMuRlJBR01FTlRfU0hBREVSKSxcbiAgICAgICAgICAgIHZlcnRleDogdGhpcy5nZXRTaGFkZXIobmFtZSwgdGhpcy5WRVJURVhfU0hBREVSKSxcbiAgICAgICAgICAgIGF0dHJpYnV0ZXM6IFtdXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuYXR0YWNoU2hhZGVyKHNoYWRlci5wcm9ncmFtLCBzaGFkZXIudmVydGV4KTtcbiAgICAgICAgdGhpcy5hdHRhY2hTaGFkZXIoc2hhZGVyLnByb2dyYW0sIHNoYWRlci5mcmFnbWVudCk7XG4gICAgICAgIHRoaXMubGlua1Byb2dyYW0oc2hhZGVyLnByb2dyYW0pO1xuXG4gICAgICAgIGlmICghdGhpcy5nZXRQcm9ncmFtUGFyYW1ldGVyKHNoYWRlci5wcm9ncmFtLCB0aGlzLkxJTktfU1RBVFVTKSkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihuYW1lICsgJyBFUlJPUjogJyArIHRoaXMuZ2V0UHJvZ3JhbUluZm9Mb2coc2hhZGVyLnByb2dyYW0pKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXR0cmlidXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHNoYWRlclthdHRyaWJ1dGVzW2ldXSA9IHRoaXMuZ2V0QXR0cmliTG9jYXRpb24oc2hhZGVyLnByb2dyYW0sIGF0dHJpYnV0ZXNbaV0pO1xuICAgICAgICAgICAgICAgIHNoYWRlci5hdHRyaWJ1dGVzLnB1c2goc2hhZGVyW2F0dHJpYnV0ZXNbaV1dKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgdW5pZm9ybXMubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgICAgICAgICBzaGFkZXJbdW5pZm9ybXNba11dID0gdGhpcy5nZXRVbmlmb3JtTG9jYXRpb24oc2hhZGVyLnByb2dyYW0sIHVuaWZvcm1zW2tdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzaGFkZXI7XG4gICAgfTtcblxuICAgIC8vIFN3aXRjaGVzIHRvIGEgZGlmZmVyZW50IHNoYWRlciBwcm9ncmFtLlxuICAgIGNvbnRleHQuc3dpdGNoU2hhZGVyID0gZnVuY3Rpb24oc2hhZGVyLCBwb3NNYXRyaXgsIGV4TWF0cml4KSB7XG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnRTaGFkZXIgIT09IHNoYWRlcikge1xuICAgICAgICAgICAgdGhpcy51c2VQcm9ncmFtKHNoYWRlci5wcm9ncmFtKTtcblxuICAgICAgICAgICAgLy8gRGlzYWJsZSBhbGwgYXR0cmlidXRlcyBmcm9tIHRoZSBleGlzdGluZyBzaGFkZXIgdGhhdCBhcmVuJ3QgdXNlZCBpblxuICAgICAgICAgICAgLy8gdGhlIG5ldyBzaGFkZXIuIE5vdGU6IGF0dHJpYnV0ZSBpbmRpY2VzIGFyZSAqbm90KiBwcm9ncmFtIHNwZWNpZmljIVxuICAgICAgICAgICAgdmFyIGVuYWJsZWQgPSB0aGlzLmN1cnJlbnRTaGFkZXIgPyB0aGlzLmN1cnJlbnRTaGFkZXIuYXR0cmlidXRlcyA6IFtdO1xuICAgICAgICAgICAgdmFyIHJlcXVpcmVkID0gc2hhZGVyLmF0dHJpYnV0ZXM7XG5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZW5hYmxlZC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChyZXF1aXJlZC5pbmRleE9mKGVuYWJsZWRbaV0pIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRpc2FibGVWZXJ0ZXhBdHRyaWJBcnJheShlbmFibGVkW2ldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEVuYWJsZSBhbGwgYXR0cmlidXRlcyBmb3IgdGhlIG5ldyBzaGFkZXIuXG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHJlcXVpcmVkLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVuYWJsZWQuaW5kZXhPZihyZXF1aXJlZFtqXSkgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkocmVxdWlyZWRbal0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5jdXJyZW50U2hhZGVyID0gc2hhZGVyO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHBvc01hdHJpeCAhPT0gdW5kZWZpbmVkKSBjb250ZXh0LnNldFBvc01hdHJpeChwb3NNYXRyaXgpO1xuICAgICAgICBpZiAoZXhNYXRyaXggIT09IHVuZGVmaW5lZCkgY29udGV4dC5zZXRFeE1hdHJpeChleE1hdHJpeCk7XG4gICAgfTtcblxuICAgIC8vIFVwZGF0ZSB0aGUgbWF0cmljZXMgaWYgbmVjZXNzYXJ5LiBOb3RlOiBUaGlzIHJlbGllcyBvbiBvYmplY3QgaWRlbnRpdHkhXG4gICAgLy8gVGhpcyBtZWFucyBjaGFuZ2luZyB0aGUgbWF0cml4IHZhbHVlcyB3aXRob3V0IHRoZSBhY3R1YWwgbWF0cml4IG9iamVjdFxuICAgIC8vIHdpbGwgRkFJTCB0byB1cGRhdGUgdGhlIG1hdHJpeCBwcm9wZXJseS5cbiAgICBjb250ZXh0LnNldFBvc01hdHJpeCA9IGZ1bmN0aW9uKHBvc01hdHJpeCkge1xuICAgICAgICB2YXIgc2hhZGVyID0gdGhpcy5jdXJyZW50U2hhZGVyO1xuICAgICAgICBpZiAoc2hhZGVyLnBvc01hdHJpeCAhPT0gcG9zTWF0cml4KSB7XG4gICAgICAgICAgICB0aGlzLnVuaWZvcm1NYXRyaXg0ZnYoc2hhZGVyLnVfbWF0cml4LCBmYWxzZSwgcG9zTWF0cml4KTtcbiAgICAgICAgICAgIHNoYWRlci5wb3NNYXRyaXggPSBwb3NNYXRyaXg7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gVXBkYXRlIHRoZSBtYXRyaWNlcyBpZiBuZWNlc3NhcnkuIE5vdGU6IFRoaXMgcmVsaWVzIG9uIG9iamVjdCBpZGVudGl0eSFcbiAgICAvLyBUaGlzIG1lYW5zIGNoYW5naW5nIHRoZSBtYXRyaXggdmFsdWVzIHdpdGhvdXQgdGhlIGFjdHVhbCBtYXRyaXggb2JqZWN0XG4gICAgLy8gd2lsbCBGQUlMIHRvIHVwZGF0ZSB0aGUgbWF0cml4IHByb3Blcmx5LlxuICAgIGNvbnRleHQuc2V0RXhNYXRyaXggPSBmdW5jdGlvbihleE1hdHJpeCkge1xuICAgICAgICB2YXIgc2hhZGVyID0gdGhpcy5jdXJyZW50U2hhZGVyO1xuICAgICAgICBpZiAoZXhNYXRyaXggJiYgc2hhZGVyLmV4TWF0cml4ICE9PSBleE1hdHJpeCAmJiBzaGFkZXIudV9leG1hdHJpeCkge1xuICAgICAgICAgICAgdGhpcy51bmlmb3JtTWF0cml4NGZ2KHNoYWRlci51X2V4bWF0cml4LCBmYWxzZSwgZXhNYXRyaXgpO1xuICAgICAgICAgICAgc2hhZGVyLmV4TWF0cml4ID0gZXhNYXRyaXg7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgY29udGV4dC52ZXJ0ZXhBdHRyaWIyZnYgPSBmdW5jdGlvbihhdHRyaWJ1dGUsIHZhbHVlcykge1xuICAgICAgICBjb250ZXh0LnZlcnRleEF0dHJpYjJmKGF0dHJpYnV0ZSwgdmFsdWVzWzBdLCB2YWx1ZXNbMV0pO1xuICAgIH07XG5cbiAgICBjb250ZXh0LnZlcnRleEF0dHJpYjNmdiA9IGZ1bmN0aW9uKGF0dHJpYnV0ZSwgdmFsdWVzKSB7XG4gICAgICAgIGNvbnRleHQudmVydGV4QXR0cmliM2YoYXR0cmlidXRlLCB2YWx1ZXNbMF0sIHZhbHVlc1sxXSwgdmFsdWVzWzJdKTtcbiAgICB9O1xuXG4gICAgY29udGV4dC52ZXJ0ZXhBdHRyaWI0ZnYgPSBmdW5jdGlvbihhdHRyaWJ1dGUsIHZhbHVlcykge1xuICAgICAgICBjb250ZXh0LnZlcnRleEF0dHJpYjRmKGF0dHJpYnV0ZSwgdmFsdWVzWzBdLCB2YWx1ZXNbMV0sIHZhbHVlc1syXSwgdmFsdWVzWzNdKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIGNvbnRleHQ7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IExpbmVBdGxhcztcblxuLyoqXG4gKiBBIExpbmVBdGxhcyBsZXRzIHVzIHJldXNlIHJlbmRlcmVkIGRhc2hlZCBsaW5lc1xuICogYnkgd3JpdGluZyBtYW55IG9mIHRoZW0gdG8gYSB0ZXh0dXJlIGFuZCB0aGVuIGZldGNoaW5nIHRoZWlyIHBvc2l0aW9uc1xuICogdXNpbmcgLmdldERhc2guXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IHdpZHRoXG4gKiBAcGFyYW0ge251bWJlcn0gaGVpZ2h0XG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBMaW5lQXRsYXMod2lkdGgsIGhlaWdodCkge1xuICAgIHRoaXMud2lkdGggPSB3aWR0aDtcbiAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcbiAgICB0aGlzLm5leHRSb3cgPSAwO1xuXG4gICAgdGhpcy5ieXRlcyA9IDQ7XG4gICAgdGhpcy5kYXRhID0gbmV3IFVpbnQ4QXJyYXkodGhpcy53aWR0aCAqIHRoaXMuaGVpZ2h0ICogdGhpcy5ieXRlcyk7XG5cbiAgICB0aGlzLnBvc2l0aW9ucyA9IHt9O1xufVxuXG5MaW5lQXRsYXMucHJvdG90eXBlLnNldFNwcml0ZSA9IGZ1bmN0aW9uKHNwcml0ZSkge1xuICAgIHRoaXMuc3ByaXRlID0gc3ByaXRlO1xufTtcblxuLyoqXG4gKiBHZXQgb3IgY3JlYXRlIGEgZGFzaCBsaW5lIHBhdHRlcm4uXG4gKlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBkYXNoYXJyYXlcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gcm91bmQgd2hldGhlciB0byBhZGQgY2lyY2xlIGNhcHMgaW4gYmV0d2VlbiBkYXNoIHNlZ21lbnRzXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBwb3NpdGlvbiBvZiBkYXNoIHRleHR1cmUgaW4geyB5LCBoZWlnaHQsIHdpZHRoIH1cbiAqIEBwcml2YXRlXG4gKi9cbkxpbmVBdGxhcy5wcm90b3R5cGUuZ2V0RGFzaCA9IGZ1bmN0aW9uKGRhc2hhcnJheSwgcm91bmQpIHtcbiAgICB2YXIga2V5ID0gZGFzaGFycmF5LmpvaW4oXCIsXCIpICsgcm91bmQ7XG5cbiAgICBpZiAoIXRoaXMucG9zaXRpb25zW2tleV0pIHtcbiAgICAgICAgdGhpcy5wb3NpdGlvbnNba2V5XSA9IHRoaXMuYWRkRGFzaChkYXNoYXJyYXksIHJvdW5kKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMucG9zaXRpb25zW2tleV07XG59O1xuXG5MaW5lQXRsYXMucHJvdG90eXBlLmFkZERhc2ggPSBmdW5jdGlvbihkYXNoYXJyYXksIHJvdW5kKSB7XG5cbiAgICB2YXIgbiA9IHJvdW5kID8gNyA6IDA7XG4gICAgdmFyIGhlaWdodCA9IDIgKiBuICsgMTtcbiAgICB2YXIgb2Zmc2V0ID0gMTI4O1xuXG4gICAgaWYgKHRoaXMubmV4dFJvdyArIGhlaWdodCA+IHRoaXMuaGVpZ2h0KSB7XG4gICAgICAgIGNvbnNvbGUud2FybignTGluZUF0bGFzIG91dCBvZiBzcGFjZScpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgbGVuZ3RoID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRhc2hhcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgICBsZW5ndGggKz0gZGFzaGFycmF5W2ldO1xuICAgIH1cblxuICAgIHZhciBzdHJldGNoID0gdGhpcy53aWR0aCAvIGxlbmd0aDtcbiAgICB2YXIgaGFsZldpZHRoID0gc3RyZXRjaCAvIDI7XG5cbiAgICAvLyBJZiBkYXNoYXJyYXkgaGFzIGFuIG9kZCBsZW5ndGgsIGJvdGggdGhlIGZpcnN0IGFuZCBsYXN0IHBhcnRzXG4gICAgLy8gYXJlIGRhc2hlcyBhbmQgc2hvdWxkIGJlIGpvaW5lZCBzZWFtbGVzc2x5LlxuICAgIHZhciBvZGRMZW5ndGggPSBkYXNoYXJyYXkubGVuZ3RoICUgMiA9PT0gMTtcblxuICAgIGZvciAodmFyIHkgPSAtbjsgeSA8PSBuOyB5KyspIHtcbiAgICAgICAgdmFyIHJvdyA9IHRoaXMubmV4dFJvdyArIG4gKyB5O1xuICAgICAgICB2YXIgaW5kZXggPSB0aGlzLndpZHRoICogcm93O1xuXG4gICAgICAgIHZhciBsZWZ0ID0gb2RkTGVuZ3RoID8gLWRhc2hhcnJheVtkYXNoYXJyYXkubGVuZ3RoIC0gMV0gOiAwO1xuICAgICAgICB2YXIgcmlnaHQgPSBkYXNoYXJyYXlbMF07XG4gICAgICAgIHZhciBwYXJ0SW5kZXggPSAxO1xuXG4gICAgICAgIGZvciAodmFyIHggPSAwOyB4IDwgdGhpcy53aWR0aDsgeCsrKSB7XG5cbiAgICAgICAgICAgIHdoaWxlIChyaWdodCA8IHggLyBzdHJldGNoKSB7XG4gICAgICAgICAgICAgICAgbGVmdCA9IHJpZ2h0O1xuICAgICAgICAgICAgICAgIHJpZ2h0ID0gcmlnaHQgKyBkYXNoYXJyYXlbcGFydEluZGV4XTtcblxuICAgICAgICAgICAgICAgIGlmIChvZGRMZW5ndGggJiYgcGFydEluZGV4ID09PSBkYXNoYXJyYXkubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgICAgICByaWdodCArPSBkYXNoYXJyYXlbMF07XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcGFydEluZGV4Kys7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBkaXN0TGVmdCA9IE1hdGguYWJzKHggLSBsZWZ0ICogc3RyZXRjaCk7XG4gICAgICAgICAgICB2YXIgZGlzdFJpZ2h0ID0gTWF0aC5hYnMoeCAtIHJpZ2h0ICogc3RyZXRjaCk7XG4gICAgICAgICAgICB2YXIgZGlzdCA9IE1hdGgubWluKGRpc3RMZWZ0LCBkaXN0UmlnaHQpO1xuICAgICAgICAgICAgdmFyIGluc2lkZSA9IChwYXJ0SW5kZXggJSAyKSA9PT0gMTtcbiAgICAgICAgICAgIHZhciBzaWduZWREaXN0YW5jZTtcblxuICAgICAgICAgICAgaWYgKHJvdW5kKSB7XG4gICAgICAgICAgICAgICAgLy8gQWRkIGNpcmNsZSBjYXBzXG4gICAgICAgICAgICAgICAgdmFyIGRpc3RNaWRkbGUgPSBuID8geSAvIG4gKiAoaGFsZldpZHRoICsgMSkgOiAwO1xuICAgICAgICAgICAgICAgIGlmIChpbnNpZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRpc3RFZGdlID0gaGFsZldpZHRoIC0gTWF0aC5hYnMoZGlzdE1pZGRsZSk7XG4gICAgICAgICAgICAgICAgICAgIHNpZ25lZERpc3RhbmNlID0gTWF0aC5zcXJ0KGRpc3QgKiBkaXN0ICsgZGlzdEVkZ2UgKiBkaXN0RWRnZSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc2lnbmVkRGlzdGFuY2UgPSBoYWxmV2lkdGggLSBNYXRoLnNxcnQoZGlzdCAqIGRpc3QgKyBkaXN0TWlkZGxlICogZGlzdE1pZGRsZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzaWduZWREaXN0YW5jZSA9IChpbnNpZGUgPyAxIDogLTEpICogZGlzdDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5kYXRhWzMgKyAoaW5kZXggKyB4KSAqIDRdID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oMjU1LCBzaWduZWREaXN0YW5jZSArIG9mZnNldCkpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHBvcyA9IHtcbiAgICAgICAgeTogKHRoaXMubmV4dFJvdyArIG4gKyAwLjUpIC8gdGhpcy5oZWlnaHQsXG4gICAgICAgIGhlaWdodDogMiAqIG4gLyB0aGlzLmhlaWdodCxcbiAgICAgICAgd2lkdGg6IGxlbmd0aFxuICAgIH07XG5cbiAgICB0aGlzLm5leHRSb3cgKz0gaGVpZ2h0O1xuICAgIHRoaXMuZGlydHkgPSB0cnVlO1xuXG4gICAgcmV0dXJuIHBvcztcbn07XG5cbkxpbmVBdGxhcy5wcm90b3R5cGUuYmluZCA9IGZ1bmN0aW9uKGdsKSB7XG4gICAgaWYgKCF0aGlzLnRleHR1cmUpIHtcbiAgICAgICAgdGhpcy50ZXh0dXJlID0gZ2wuY3JlYXRlVGV4dHVyZSgpO1xuICAgICAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0aGlzLnRleHR1cmUpO1xuICAgICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9TLCBnbC5SRVBFQVQpO1xuICAgICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9ULCBnbC5SRVBFQVQpO1xuICAgICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUlOX0ZJTFRFUiwgZ2wuTElORUFSKTtcbiAgICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01BR19GSUxURVIsIGdsLkxJTkVBUik7XG4gICAgICAgIGdsLnRleEltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgMCwgZ2wuUkdCQSwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQsIDAsIGdsLlJHQkEsIGdsLlVOU0lHTkVEX0JZVEUsIHRoaXMuZGF0YSk7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0aGlzLnRleHR1cmUpO1xuXG4gICAgICAgIGlmICh0aGlzLmRpcnR5KSB7XG4gICAgICAgICAgICB0aGlzLmRpcnR5ID0gZmFsc2U7XG4gICAgICAgICAgICBnbC50ZXhTdWJJbWFnZTJEKGdsLlRFWFRVUkVfMkQsIDAsIDAsIDAsIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0LCBnbC5SR0JBLCBnbC5VTlNJR05FRF9CWVRFLCB0aGlzLmRhdGEpO1xuICAgICAgICB9XG4gICAgfVxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGdsdXRpbCA9IHJlcXVpcmUoJy4vZ2xfdXRpbCcpO1xudmFyIGJyb3dzZXIgPSByZXF1aXJlKCcuLi91dGlsL2Jyb3dzZXInKTtcbnZhciBtYXQ0ID0gcmVxdWlyZSgnZ2wtbWF0cml4JykubWF0NDtcbnZhciBGcmFtZUhpc3RvcnkgPSByZXF1aXJlKCcuL2ZyYW1lX2hpc3RvcnknKTtcbnZhciBUaWxlQ29vcmQgPSByZXF1aXJlKCcuLi9zb3VyY2UvdGlsZV9jb29yZCcpO1xudmFyIFRpbGVQeXJhbWlkID0gcmVxdWlyZSgnLi4vc291cmNlL3RpbGVfcHlyYW1pZCcpO1xudmFyIEVYVEVOVCA9IHJlcXVpcmUoJy4uL2RhdGEvYnVja2V0JykuRVhURU5UO1xudmFyIHBpeGVsc1RvVGlsZVVuaXRzID0gcmVxdWlyZSgnLi4vc291cmNlL3BpeGVsc190b190aWxlX3VuaXRzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gUGFpbnRlcjtcblxuLyoqXG4gKiBJbml0aWFsaXplIGEgbmV3IHBhaW50ZXIgb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB7Q2FudmFzfSBnbCBhbiBleHBlcmltZW50YWwtd2ViZ2wgZHJhd2luZyBjb250ZXh0XG4gKi9cbmZ1bmN0aW9uIFBhaW50ZXIoZ2wsIHRyYW5zZm9ybSkge1xuICAgIHRoaXMuZ2wgPSBnbHV0aWwuZXh0ZW5kKGdsKTtcbiAgICB0aGlzLnRyYW5zZm9ybSA9IHRyYW5zZm9ybTtcblxuICAgIHRoaXMucmV1c2FibGVUZXh0dXJlcyA9IHt9O1xuICAgIHRoaXMucHJlRmJvcyA9IHt9O1xuXG4gICAgdGhpcy5mcmFtZUhpc3RvcnkgPSBuZXcgRnJhbWVIaXN0b3J5KCk7XG5cbiAgICB0aGlzLnNldHVwKCk7XG5cbiAgICAvLyBXaXRoaW4gZWFjaCBsYXllciB0aGVyZSBhcmUgbXVsdGlwbGUgZGlzdGluY3Qgei1wbGFuZXMgdGhhdCBjYW4gYmUgZHJhd24gdG8uXG4gICAgLy8gVGhpcyBpcyBpbXBsZW1lbnRlZCB1c2luZyB0aGUgV2ViR0wgZGVwdGggYnVmZmVyLlxuICAgIHRoaXMubnVtU3VibGF5ZXJzID0gVGlsZVB5cmFtaWQubWF4VW5kZXJ6b29taW5nICsgVGlsZVB5cmFtaWQubWF4T3Zlcnpvb21pbmcgKyAxO1xuICAgIHRoaXMuZGVwdGhFcHNpbG9uID0gMSAvIE1hdGgucG93KDIsIDE2KTtcbn1cblxuLypcbiAqIFVwZGF0ZSB0aGUgR0wgdmlld3BvcnQsIHByb2plY3Rpb24gbWF0cml4LCBhbmQgdHJhbnNmb3JtcyB0byBjb21wZW5zYXRlXG4gKiBmb3IgYSBuZXcgd2lkdGggYW5kIGhlaWdodCB2YWx1ZS5cbiAqL1xuUGFpbnRlci5wcm90b3R5cGUucmVzaXplID0gZnVuY3Rpb24od2lkdGgsIGhlaWdodCkge1xuICAgIHZhciBnbCA9IHRoaXMuZ2w7XG5cbiAgICB0aGlzLndpZHRoID0gd2lkdGggKiBicm93c2VyLmRldmljZVBpeGVsUmF0aW87XG4gICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQgKiBicm93c2VyLmRldmljZVBpeGVsUmF0aW87XG4gICAgZ2wudmlld3BvcnQoMCwgMCwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xuXG59O1xuXG5cblBhaW50ZXIucHJvdG90eXBlLnNldHVwID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGdsID0gdGhpcy5nbDtcblxuICAgIGdsLnZlcmJvc2UgPSB0cnVlO1xuXG4gICAgLy8gV2UgYXJlIGJsZW5kaW5nIHRoZSBuZXcgcGl4ZWxzICpiZWhpbmQqIHRoZSBleGlzdGluZyBwaXhlbHMuIFRoYXQgd2F5IHdlIGNhblxuICAgIC8vIGRyYXcgZnJvbnQtdG8tYmFjayBhbmQgdXNlIHRoZW4gc3RlbmNpbCBidWZmZXIgdG8gY3VsbCBvcGFxdWUgcGl4ZWxzIGVhcmx5LlxuICAgIGdsLmVuYWJsZShnbC5CTEVORCk7XG4gICAgZ2wuYmxlbmRGdW5jKGdsLk9ORSwgZ2wuT05FX01JTlVTX1NSQ19BTFBIQSk7XG5cbiAgICBnbC5lbmFibGUoZ2wuU1RFTkNJTF9URVNUKTtcblxuICAgIGdsLmVuYWJsZShnbC5ERVBUSF9URVNUKTtcbiAgICBnbC5kZXB0aEZ1bmMoZ2wuTEVRVUFMKTtcblxuICAgIHRoaXMuX2RlcHRoTWFzayA9IGZhbHNlO1xuICAgIGdsLmRlcHRoTWFzayhmYWxzZSk7XG5cbiAgICAvLyBJbml0aWFsaXplIHNoYWRlcnNcbiAgICB0aGlzLmRlYnVnU2hhZGVyID0gZ2wuaW5pdGlhbGl6ZVNoYWRlcignZGVidWcnLFxuICAgICAgICBbJ2FfcG9zJ10sXG4gICAgICAgIFsndV9tYXRyaXgnLCAndV9jb2xvciddKTtcblxuICAgIHRoaXMucmFzdGVyU2hhZGVyID0gZ2wuaW5pdGlhbGl6ZVNoYWRlcigncmFzdGVyJyxcbiAgICAgICAgWydhX3BvcycsICdhX3RleHR1cmVfcG9zJ10sXG4gICAgICAgIFsndV9tYXRyaXgnLCAndV9icmlnaHRuZXNzX2xvdycsICd1X2JyaWdodG5lc3NfaGlnaCcsICd1X3NhdHVyYXRpb25fZmFjdG9yJywgJ3Vfc3Bpbl93ZWlnaHRzJywgJ3VfY29udHJhc3RfZmFjdG9yJywgJ3Vfb3BhY2l0eTAnLCAndV9vcGFjaXR5MScsICd1X2ltYWdlMCcsICd1X2ltYWdlMScsICd1X3RsX3BhcmVudCcsICd1X3NjYWxlX3BhcmVudCcsICd1X2J1ZmZlcl9zY2FsZSddKTtcblxuICAgIHRoaXMuY2lyY2xlU2hhZGVyID0gZ2wuaW5pdGlhbGl6ZVNoYWRlcignY2lyY2xlJyxcbiAgICAgICAgWydhX3BvcyddLFxuICAgICAgICBbJ3VfbWF0cml4JywgJ3VfZXhtYXRyaXgnLCAndV9ibHVyJywgJ3Vfc2l6ZScsICd1X2NvbG9yJ10pO1xuXG4gICAgdGhpcy5saW5lU2hhZGVyID0gZ2wuaW5pdGlhbGl6ZVNoYWRlcignbGluZScsXG4gICAgICAgIFsnYV9wb3MnLCAnYV9kYXRhJ10sXG4gICAgICAgIFsndV9tYXRyaXgnLCAndV9saW5ld2lkdGgnLCAndV9jb2xvcicsICd1X3JhdGlvJywgJ3VfYmx1cicsICd1X2V4dHJhJywgJ3VfYW50aWFsaWFzaW5nbWF0cml4JywgJ3Vfb2Zmc2V0JywgJ3VfZXhtYXRyaXgnXSk7XG5cbiAgICB0aGlzLmxpbmVwYXR0ZXJuU2hhZGVyID0gZ2wuaW5pdGlhbGl6ZVNoYWRlcignbGluZXBhdHRlcm4nLFxuICAgICAgICBbJ2FfcG9zJywgJ2FfZGF0YSddLFxuICAgICAgICBbJ3VfbWF0cml4JywgJ3VfbGluZXdpZHRoJywgJ3VfcmF0aW8nLCAndV9wYXR0ZXJuX3NpemVfYScsICd1X3BhdHRlcm5fc2l6ZV9iJywgJ3VfcGF0dGVybl90bF9hJywgJ3VfcGF0dGVybl9icl9hJywgJ3VfcGF0dGVybl90bF9iJywgJ3VfcGF0dGVybl9icl9iJywgJ3VfYmx1cicsICd1X2ZhZGUnLCAndV9vcGFjaXR5JywgJ3VfZXh0cmEnLCAndV9hbnRpYWxpYXNpbmdtYXRyaXgnLCAndV9vZmZzZXQnXSk7XG5cbiAgICB0aGlzLmxpbmVzZGZwYXR0ZXJuU2hhZGVyID0gZ2wuaW5pdGlhbGl6ZVNoYWRlcignbGluZXNkZnBhdHRlcm4nLFxuICAgICAgICBbJ2FfcG9zJywgJ2FfZGF0YSddLFxuICAgICAgICBbJ3VfbWF0cml4JywgJ3VfbGluZXdpZHRoJywgJ3VfY29sb3InLCAndV9yYXRpbycsICd1X2JsdXInLCAndV9wYXR0ZXJuc2NhbGVfYScsICd1X3RleF95X2EnLCAndV9wYXR0ZXJuc2NhbGVfYicsICd1X3RleF95X2InLCAndV9pbWFnZScsICd1X3NkZmdhbW1hJywgJ3VfbWl4JywgJ3VfZXh0cmEnLCAndV9hbnRpYWxpYXNpbmdtYXRyaXgnLCAndV9vZmZzZXQnXSk7XG5cbiAgICB0aGlzLnNkZlNoYWRlciA9IGdsLmluaXRpYWxpemVTaGFkZXIoJ3NkZicsXG4gICAgICAgIFsnYV9wb3MnLCAnYV9vZmZzZXQnLCAnYV9kYXRhMScsICdhX2RhdGEyJ10sXG4gICAgICAgIFsndV9tYXRyaXgnLCAndV9leG1hdHJpeCcsICd1X3RleHR1cmUnLCAndV90ZXhzaXplJywgJ3VfY29sb3InLCAndV9nYW1tYScsICd1X2J1ZmZlcicsICd1X3pvb20nLCAndV9mYWRlZGlzdCcsICd1X21pbmZhZGV6b29tJywgJ3VfbWF4ZmFkZXpvb20nLCAndV9mYWRlem9vbScsICd1X3NrZXdlZCcsICd1X2V4dHJhJ10pO1xuXG4gICAgdGhpcy5pY29uU2hhZGVyID0gZ2wuaW5pdGlhbGl6ZVNoYWRlcignaWNvbicsXG4gICAgICAgIFsnYV9wb3MnLCAnYV9vZmZzZXQnLCAnYV9kYXRhMScsICdhX2RhdGEyJ10sXG4gICAgICAgIFsndV9tYXRyaXgnLCAndV9leG1hdHJpeCcsICd1X3RleHR1cmUnLCAndV90ZXhzaXplJywgJ3Vfem9vbScsICd1X2ZhZGVkaXN0JywgJ3VfbWluZmFkZXpvb20nLCAndV9tYXhmYWRlem9vbScsICd1X2ZhZGV6b29tJywgJ3Vfb3BhY2l0eScsICd1X3NrZXdlZCcsICd1X2V4dHJhJ10pO1xuXG4gICAgdGhpcy5vdXRsaW5lU2hhZGVyID0gZ2wuaW5pdGlhbGl6ZVNoYWRlcignb3V0bGluZScsXG4gICAgICAgIFsnYV9wb3MnXSxcbiAgICAgICAgWyd1X21hdHJpeCcsICd1X2NvbG9yJywgJ3Vfd29ybGQnXVxuICAgICk7XG5cbiAgICB0aGlzLnBhdHRlcm5TaGFkZXIgPSBnbC5pbml0aWFsaXplU2hhZGVyKCdwYXR0ZXJuJyxcbiAgICAgICAgWydhX3BvcyddLFxuICAgICAgICBbJ3VfbWF0cml4JywgJ3VfcGF0dGVybl90bF9hJywgJ3VfcGF0dGVybl9icl9hJywgJ3VfcGF0dGVybl90bF9iJywgJ3VfcGF0dGVybl9icl9iJywgJ3VfbWl4JywgJ3VfcGF0dGVybnNjYWxlX2EnLCAndV9wYXR0ZXJuc2NhbGVfYicsICd1X29wYWNpdHknLCAndV9pbWFnZScsICd1X29mZnNldF9hJywgJ3Vfb2Zmc2V0X2InXVxuICAgICk7XG5cbiAgICB0aGlzLmZpbGxTaGFkZXIgPSBnbC5pbml0aWFsaXplU2hhZGVyKCdmaWxsJyxcbiAgICAgICAgWydhX3BvcyddLFxuICAgICAgICBbJ3VfbWF0cml4JywgJ3VfY29sb3InXVxuICAgICk7XG5cbiAgICB0aGlzLmNvbGxpc2lvbkJveFNoYWRlciA9IGdsLmluaXRpYWxpemVTaGFkZXIoJ2NvbGxpc2lvbmJveCcsXG4gICAgICAgIFsnYV9wb3MnLCAnYV9leHRydWRlJywgJ2FfZGF0YSddLFxuICAgICAgICBbJ3VfbWF0cml4JywgJ3Vfc2NhbGUnLCAndV96b29tJywgJ3VfbWF4em9vbSddXG4gICAgKTtcblxuICAgIHRoaXMuaWRlbnRpdHlNYXRyaXggPSBtYXQ0LmNyZWF0ZSgpO1xuXG4gICAgLy8gVGhlIGJhY2tncm91bmRCdWZmZXIgaXMgdXNlZCB3aGVuIGRyYXdpbmcgdG8gdGhlIGZ1bGwgKmNhbnZhcypcbiAgICB0aGlzLmJhY2tncm91bmRCdWZmZXIgPSBnbC5jcmVhdGVCdWZmZXIoKTtcbiAgICB0aGlzLmJhY2tncm91bmRCdWZmZXIuaXRlbVNpemUgPSAyO1xuICAgIHRoaXMuYmFja2dyb3VuZEJ1ZmZlci5pdGVtQ291bnQgPSA0O1xuICAgIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCB0aGlzLmJhY2tncm91bmRCdWZmZXIpO1xuICAgIGdsLmJ1ZmZlckRhdGEoZ2wuQVJSQVlfQlVGRkVSLCBuZXcgSW50MTZBcnJheShbLTEsIC0xLCAxLCAtMSwgLTEsIDEsIDEsIDFdKSwgZ2wuU1RBVElDX0RSQVcpO1xuXG4gICAgLy8gVGhlIHRpbGVFeHRlbnRCdWZmZXIgaXMgdXNlZCB3aGVuIGRyYXdpbmcgdG8gYSBmdWxsICp0aWxlKlxuICAgIHRoaXMudGlsZUV4dGVudEJ1ZmZlciA9IGdsLmNyZWF0ZUJ1ZmZlcigpO1xuICAgIHRoaXMudGlsZUV4dGVudEJ1ZmZlci5pdGVtU2l6ZSA9IDQ7XG4gICAgdGhpcy50aWxlRXh0ZW50QnVmZmVyLml0ZW1Db3VudCA9IDQ7XG4gICAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIHRoaXMudGlsZUV4dGVudEJ1ZmZlcik7XG4gICAgZ2wuYnVmZmVyRGF0YShcbiAgICAgICAgZ2wuQVJSQVlfQlVGRkVSLFxuICAgICAgICBuZXcgSW50MTZBcnJheShbXG4gICAgICAgICAgICAvLyB0aWxlIGNvb3JkIHgsIHRpbGUgY29vcmQgeSwgdGV4dHVyZSBjb29yZCB4LCB0ZXh0dXJlIGNvb3JkIHlcbiAgICAgICAgICAgIDAsIDAsIDAsIDAsXG4gICAgICAgICAgICBFWFRFTlQsIDAsIDMyNzY3LCAwLFxuICAgICAgICAgICAgMCwgRVhURU5ULCAwLCAzMjc2NyxcbiAgICAgICAgICAgIEVYVEVOVCwgRVhURU5ULCAgMzI3NjcsIDMyNzY3XG4gICAgICAgIF0pLFxuICAgICAgICBnbC5TVEFUSUNfRFJBVyk7XG5cbiAgICAvLyBUaGUgZGVidWdCdWZmZXIgaXMgdXNlZCB0byBkcmF3IHRpbGUgb3V0bGluZXMgZm9yIGRlYnVnZ2luZ1xuICAgIHRoaXMuZGVidWdCdWZmZXIgPSBnbC5jcmVhdGVCdWZmZXIoKTtcbiAgICB0aGlzLmRlYnVnQnVmZmVyLml0ZW1TaXplID0gMjtcbiAgICB0aGlzLmRlYnVnQnVmZmVyLml0ZW1Db3VudCA9IDU7XG4gICAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIHRoaXMuZGVidWdCdWZmZXIpO1xuICAgIGdsLmJ1ZmZlckRhdGEoXG4gICAgICAgIGdsLkFSUkFZX0JVRkZFUixcbiAgICAgICAgbmV3IEludDE2QXJyYXkoW1xuICAgICAgICAgICAgMCwgMCwgRVhURU5ULCAwLCBFWFRFTlQsIEVYVEVOVCwgMCwgRVhURU5ULCAwLCAwXSksXG4gICAgICAgIGdsLlNUQVRJQ19EUkFXKTtcblxuICAgIC8vIFRoZSBkZWJ1Z1RleHRCdWZmZXIgaXMgdXNlZCB0byBkcmF3IHRpbGUgSURzIGZvciBkZWJ1Z2dpbmdcbiAgICB0aGlzLmRlYnVnVGV4dEJ1ZmZlciA9IGdsLmNyZWF0ZUJ1ZmZlcigpO1xuICAgIHRoaXMuZGVidWdUZXh0QnVmZmVyLml0ZW1TaXplID0gMjtcbn07XG5cbi8qXG4gKiBSZXNldCB0aGUgY29sb3IgYnVmZmVycyBvZiB0aGUgZHJhd2luZyBjYW52YXMuXG4gKi9cblBhaW50ZXIucHJvdG90eXBlLmNsZWFyQ29sb3IgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgZ2wgPSB0aGlzLmdsO1xuICAgIGdsLmNsZWFyQ29sb3IoMCwgMCwgMCwgMCk7XG4gICAgZ2wuY2xlYXIoZ2wuQ09MT1JfQlVGRkVSX0JJVCk7XG59O1xuXG4vKlxuICogUmVzZXQgdGhlIGRyYXdpbmcgY2FudmFzIGJ5IGNsZWFyaW5nIHRoZSBzdGVuY2lsIGJ1ZmZlciBzbyB0aGF0IHdlIGNhbiBkcmF3XG4gKiBuZXcgdGlsZXMgYXQgdGhlIHNhbWUgbG9jYXRpb24sIHdoaWxlIHJldGFpbmluZyBwcmV2aW91c2x5IGRyYXduIHBpeGVscy5cbiAqL1xuUGFpbnRlci5wcm90b3R5cGUuY2xlYXJTdGVuY2lsID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGdsID0gdGhpcy5nbDtcbiAgICBnbC5jbGVhclN0ZW5jaWwoMHgwKTtcbiAgICBnbC5zdGVuY2lsTWFzaygweEZGKTtcbiAgICBnbC5jbGVhcihnbC5TVEVOQ0lMX0JVRkZFUl9CSVQpO1xufTtcblxuUGFpbnRlci5wcm90b3R5cGUuY2xlYXJEZXB0aCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBnbCA9IHRoaXMuZ2w7XG4gICAgZ2wuY2xlYXJEZXB0aCgxKTtcbiAgICB0aGlzLmRlcHRoTWFzayh0cnVlKTtcbiAgICBnbC5jbGVhcihnbC5ERVBUSF9CVUZGRVJfQklUKTtcbn07XG5cblBhaW50ZXIucHJvdG90eXBlLl9yZW5kZXJUaWxlQ2xpcHBpbmdNYXNrcyA9IGZ1bmN0aW9uKGNvb3Jkcywgc291cmNlTWF4Wm9vbSkge1xuICAgIHZhciBnbCA9IHRoaXMuZ2w7XG4gICAgZ2wuY29sb3JNYXNrKGZhbHNlLCBmYWxzZSwgZmFsc2UsIGZhbHNlKTtcbiAgICB0aGlzLmRlcHRoTWFzayhmYWxzZSk7XG4gICAgZ2wuZGlzYWJsZShnbC5ERVBUSF9URVNUKTtcbiAgICBnbC5lbmFibGUoZ2wuU1RFTkNJTF9URVNUKTtcblxuICAgIC8vIE9ubHkgd3JpdGUgY2xpcHBpbmcgSURzIHRvIHRoZSBsYXN0IDUgYml0cy4gVGhlIGZpcnN0IHRocmVlIGFyZSB1c2VkIGZvciBkcmF3aW5nIGZpbGxzLlxuICAgIGdsLnN0ZW5jaWxNYXNrKDB4RjgpO1xuICAgIC8vIFRlc3RzIHdpbGwgYWx3YXlzIHBhc3MsIGFuZCByZWYgdmFsdWUgd2lsbCBiZSB3cml0dGVuIHRvIHN0ZW5jaWwgYnVmZmVyLlxuICAgIGdsLnN0ZW5jaWxPcChnbC5LRUVQLCBnbC5LRUVQLCBnbC5SRVBMQUNFKTtcblxuICAgIHZhciBpZE5leHQgPSAxO1xuICAgIHRoaXMuX3RpbGVDbGlwcGluZ01hc2tJRHMgPSB7fTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvb3Jkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgY29vcmQgPSBjb29yZHNbaV07XG4gICAgICAgIHZhciBpZCA9IHRoaXMuX3RpbGVDbGlwcGluZ01hc2tJRHNbY29vcmQuaWRdID0gKGlkTmV4dCsrKSA8PCAzO1xuXG4gICAgICAgIGdsLnN0ZW5jaWxGdW5jKGdsLkFMV0FZUywgaWQsIDB4RjgpO1xuXG4gICAgICAgIGdsLnN3aXRjaFNoYWRlcih0aGlzLmZpbGxTaGFkZXIsIHRoaXMuY2FsY3VsYXRlUG9zTWF0cml4KGNvb3JkLCBzb3VyY2VNYXhab29tKSk7XG5cbiAgICAgICAgLy8gRHJhdyB0aGUgY2xpcHBpbmcgbWFza1xuICAgICAgICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgdGhpcy50aWxlRXh0ZW50QnVmZmVyKTtcbiAgICAgICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcih0aGlzLmZpbGxTaGFkZXIuYV9wb3MsIHRoaXMudGlsZUV4dGVudEJ1ZmZlci5pdGVtU2l6ZSwgZ2wuU0hPUlQsIGZhbHNlLCA4LCAwKTtcbiAgICAgICAgZ2wuZHJhd0FycmF5cyhnbC5UUklBTkdMRV9TVFJJUCwgMCwgdGhpcy50aWxlRXh0ZW50QnVmZmVyLml0ZW1Db3VudCk7XG4gICAgfVxuXG4gICAgZ2wuc3RlbmNpbE1hc2soMHgwMCk7XG4gICAgZ2wuY29sb3JNYXNrKHRydWUsIHRydWUsIHRydWUsIHRydWUpO1xuICAgIHRoaXMuZGVwdGhNYXNrKHRydWUpO1xuICAgIGdsLmVuYWJsZShnbC5ERVBUSF9URVNUKTtcbn07XG5cblBhaW50ZXIucHJvdG90eXBlLmVuYWJsZVRpbGVDbGlwcGluZ01hc2sgPSBmdW5jdGlvbihjb29yZCkge1xuICAgIHZhciBnbCA9IHRoaXMuZ2w7XG4gICAgZ2wuc3RlbmNpbEZ1bmMoZ2wuRVFVQUwsIHRoaXMuX3RpbGVDbGlwcGluZ01hc2tJRHNbY29vcmQuaWRdLCAweEY4KTtcbn07XG5cbi8vIE92ZXJyaWRkZW4gYnkgaGVhZGxlc3MgdGVzdHMuXG5QYWludGVyLnByb3RvdHlwZS5wcmVwYXJlQnVmZmVycyA9IGZ1bmN0aW9uKCkge307XG5QYWludGVyLnByb3RvdHlwZS5iaW5kRGVmYXVsdEZyYW1lYnVmZmVyID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGdsID0gdGhpcy5nbDtcbiAgICBnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIG51bGwpO1xufTtcblxudmFyIGRyYXcgPSB7XG4gICAgc3ltYm9sOiByZXF1aXJlKCcuL2RyYXdfc3ltYm9sJyksXG4gICAgY2lyY2xlOiByZXF1aXJlKCcuL2RyYXdfY2lyY2xlJyksXG4gICAgbGluZTogcmVxdWlyZSgnLi9kcmF3X2xpbmUnKSxcbiAgICBmaWxsOiByZXF1aXJlKCcuL2RyYXdfZmlsbCcpLFxuICAgIHJhc3RlcjogcmVxdWlyZSgnLi9kcmF3X3Jhc3RlcicpLFxuICAgIGJhY2tncm91bmQ6IHJlcXVpcmUoJy4vZHJhd19iYWNrZ3JvdW5kJyksXG4gICAgZGVidWc6IHJlcXVpcmUoJy4vZHJhd19kZWJ1ZycpXG59O1xuXG5QYWludGVyLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbihzdHlsZSwgb3B0aW9ucykge1xuICAgIHRoaXMuc3R5bGUgPSBzdHlsZTtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuXG4gICAgdGhpcy5saW5lQXRsYXMgPSBzdHlsZS5saW5lQXRsYXM7XG5cbiAgICB0aGlzLnNwcml0ZUF0bGFzID0gc3R5bGUuc3ByaXRlQXRsYXM7XG4gICAgdGhpcy5zcHJpdGVBdGxhcy5zZXRTcHJpdGUoc3R5bGUuc3ByaXRlKTtcblxuICAgIHRoaXMuZ2x5cGhTb3VyY2UgPSBzdHlsZS5nbHlwaFNvdXJjZTtcblxuICAgIHRoaXMuZnJhbWVIaXN0b3J5LnJlY29yZCh0aGlzLnRyYW5zZm9ybS56b29tKTtcblxuICAgIHRoaXMucHJlcGFyZUJ1ZmZlcnMoKTtcbiAgICB0aGlzLmNsZWFyQ29sb3IoKTtcbiAgICB0aGlzLmNsZWFyRGVwdGgoKTtcblxuICAgIHRoaXMuZGVwdGhSYW5nZSA9IChzdHlsZS5fb3JkZXIubGVuZ3RoICsgMikgKiB0aGlzLm51bVN1YmxheWVycyAqIHRoaXMuZGVwdGhFcHNpbG9uO1xuXG4gICAgdGhpcy5yZW5kZXJQYXNzKHtpc09wYXF1ZVBhc3M6IHRydWV9KTtcbiAgICB0aGlzLnJlbmRlclBhc3Moe2lzT3BhcXVlUGFzczogZmFsc2V9KTtcbn07XG5cblBhaW50ZXIucHJvdG90eXBlLnJlbmRlclBhc3MgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgdmFyIGdyb3VwcyA9IHRoaXMuc3R5bGUuX2dyb3VwcztcbiAgICB2YXIgaXNPcGFxdWVQYXNzID0gb3B0aW9ucy5pc09wYXF1ZVBhc3M7XG4gICAgdGhpcy5jdXJyZW50TGF5ZXIgPSBpc09wYXF1ZVBhc3MgPyB0aGlzLnN0eWxlLl9vcmRlci5sZW5ndGggOiAtMTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZ3JvdXBzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBncm91cCA9IGdyb3Vwc1tpc09wYXF1ZVBhc3MgPyBncm91cHMubGVuZ3RoIC0gMSAtIGkgOiBpXTtcbiAgICAgICAgdmFyIHNvdXJjZSA9IHRoaXMuc3R5bGUuc291cmNlc1tncm91cC5zb3VyY2VdO1xuXG4gICAgICAgIHZhciBjb29yZHMgPSBbXTtcbiAgICAgICAgaWYgKHNvdXJjZSkge1xuICAgICAgICAgICAgY29vcmRzID0gc291cmNlLmdldFZpc2libGVDb29yZGluYXRlcygpO1xuICAgICAgICAgICAgdGhpcy5jbGVhclN0ZW5jaWwoKTtcbiAgICAgICAgICAgIGlmIChzb3VyY2UucHJlcGFyZSkgc291cmNlLnByZXBhcmUoKTtcbiAgICAgICAgICAgIGlmIChzb3VyY2UuaXNUaWxlQ2xpcHBlZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3JlbmRlclRpbGVDbGlwcGluZ01hc2tzKGNvb3Jkcywgc291cmNlLm1heHpvb20pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzT3BhcXVlUGFzcykge1xuICAgICAgICAgICAgdGhpcy5nbC5kaXNhYmxlKHRoaXMuZ2wuQkxFTkQpO1xuICAgICAgICAgICAgdGhpcy5pc09wYXF1ZVBhc3MgPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5nbC5lbmFibGUodGhpcy5nbC5CTEVORCk7XG4gICAgICAgICAgICB0aGlzLmlzT3BhcXVlUGFzcyA9IGZhbHNlO1xuICAgICAgICAgICAgY29vcmRzLnJldmVyc2UoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgZ3JvdXAubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIHZhciBsYXllciA9IGdyb3VwW2lzT3BhcXVlUGFzcyA/IGdyb3VwLmxlbmd0aCAtIDEgLSBqIDogal07XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRMYXllciArPSBpc09wYXF1ZVBhc3MgPyAtMSA6IDE7XG4gICAgICAgICAgICB0aGlzLnJlbmRlckxheWVyKHRoaXMsIHNvdXJjZSwgbGF5ZXIsIGNvb3Jkcyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc291cmNlKSB7XG4gICAgICAgICAgICBkcmF3LmRlYnVnKHRoaXMsIHNvdXJjZSwgY29vcmRzKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cblBhaW50ZXIucHJvdG90eXBlLmRlcHRoTWFzayA9IGZ1bmN0aW9uKG1hc2spIHtcbiAgICBpZiAobWFzayAhPT0gdGhpcy5fZGVwdGhNYXNrKSB7XG4gICAgICAgIHRoaXMuX2RlcHRoTWFzayA9IG1hc2s7XG4gICAgICAgIHRoaXMuZ2wuZGVwdGhNYXNrKG1hc2spO1xuICAgIH1cbn07XG5cblBhaW50ZXIucHJvdG90eXBlLnJlbmRlckxheWVyID0gZnVuY3Rpb24ocGFpbnRlciwgc291cmNlLCBsYXllciwgY29vcmRzKSB7XG4gICAgaWYgKGxheWVyLmlzSGlkZGVuKHRoaXMudHJhbnNmb3JtLnpvb20pKSByZXR1cm47XG4gICAgaWYgKGxheWVyLnR5cGUgIT09ICdiYWNrZ3JvdW5kJyAmJiAhY29vcmRzLmxlbmd0aCkgcmV0dXJuO1xuICAgIGRyYXdbbGF5ZXIudHlwZV0ocGFpbnRlciwgc291cmNlLCBsYXllciwgY29vcmRzKTtcbn07XG5cbi8vIERyYXdzIG5vbi1vcGFxdWUgYXJlYXMuIFRoaXMgaXMgZm9yIGRlYnVnZ2luZyBwdXJwb3Nlcy5cblBhaW50ZXIucHJvdG90eXBlLmRyYXdTdGVuY2lsQnVmZmVyID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGdsID0gdGhpcy5nbDtcbiAgICBnbC5zd2l0Y2hTaGFkZXIodGhpcy5maWxsU2hhZGVyLCB0aGlzLmlkZW50aXR5TWF0cml4KTtcblxuICAgIGdsLnN0ZW5jaWxNYXNrKDB4MDApO1xuICAgIGdsLnN0ZW5jaWxGdW5jKGdsLkVRVUFMLCAweDgwLCAweDgwKTtcblxuICAgIC8vIERydyB0aGUgZmlsbGluZyBxdWFkIHdoZXJlIHRoZSBzdGVuY2lsIGJ1ZmZlciBpc24ndCBzZXQuXG4gICAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIHRoaXMuYmFja2dyb3VuZEJ1ZmZlcik7XG4gICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcih0aGlzLmZpbGxTaGFkZXIuYV9wb3MsIHRoaXMuYmFja2dyb3VuZEJ1ZmZlci5pdGVtU2l6ZSwgZ2wuU0hPUlQsIGZhbHNlLCAwLCAwKTtcblxuICAgIGdsLnVuaWZvcm00ZnYodGhpcy5maWxsU2hhZGVyLnVfY29sb3IsIFswLCAwLCAwLCAwLjVdKTtcbiAgICBnbC5kcmF3QXJyYXlzKGdsLlRSSUFOR0xFX1NUUklQLCAwLCB0aGlzLnRpbGVFeHRlbnRCdWZmZXIuaXRlbUNvdW50KTtcbn07XG5cblBhaW50ZXIucHJvdG90eXBlLnNldERlcHRoU3VibGF5ZXIgPSBmdW5jdGlvbihuKSB7XG4gICAgdmFyIGZhckRlcHRoID0gMSAtICgoMSArIHRoaXMuY3VycmVudExheWVyKSAqIHRoaXMubnVtU3VibGF5ZXJzICsgbikgKiB0aGlzLmRlcHRoRXBzaWxvbjtcbiAgICB2YXIgbmVhckRlcHRoID0gZmFyRGVwdGggLSAxICsgdGhpcy5kZXB0aFJhbmdlO1xuICAgIHRoaXMuZ2wuZGVwdGhSYW5nZShuZWFyRGVwdGgsIGZhckRlcHRoKTtcbn07XG5cblBhaW50ZXIucHJvdG90eXBlLnRyYW5zbGF0ZVBvc01hdHJpeCA9IGZ1bmN0aW9uKG1hdHJpeCwgdGlsZSwgdHJhbnNsYXRlLCBhbmNob3IpIHtcbiAgICBpZiAoIXRyYW5zbGF0ZVswXSAmJiAhdHJhbnNsYXRlWzFdKSByZXR1cm4gbWF0cml4O1xuXG4gICAgaWYgKGFuY2hvciA9PT0gJ3ZpZXdwb3J0Jykge1xuICAgICAgICB2YXIgc2luQSA9IE1hdGguc2luKC10aGlzLnRyYW5zZm9ybS5hbmdsZSk7XG4gICAgICAgIHZhciBjb3NBID0gTWF0aC5jb3MoLXRoaXMudHJhbnNmb3JtLmFuZ2xlKTtcbiAgICAgICAgdHJhbnNsYXRlID0gW1xuICAgICAgICAgICAgdHJhbnNsYXRlWzBdICogY29zQSAtIHRyYW5zbGF0ZVsxXSAqIHNpbkEsXG4gICAgICAgICAgICB0cmFuc2xhdGVbMF0gKiBzaW5BICsgdHJhbnNsYXRlWzFdICogY29zQVxuICAgICAgICBdO1xuICAgIH1cblxuICAgIHZhciB0cmFuc2xhdGlvbiA9IFtcbiAgICAgICAgcGl4ZWxzVG9UaWxlVW5pdHModGlsZSwgdHJhbnNsYXRlWzBdLCB0aGlzLnRyYW5zZm9ybS56b29tKSxcbiAgICAgICAgcGl4ZWxzVG9UaWxlVW5pdHModGlsZSwgdHJhbnNsYXRlWzFdLCB0aGlzLnRyYW5zZm9ybS56b29tKSxcbiAgICAgICAgMFxuICAgIF07XG5cbiAgICB2YXIgdHJhbnNsYXRlZE1hdHJpeCA9IG5ldyBGbG9hdDMyQXJyYXkoMTYpO1xuICAgIG1hdDQudHJhbnNsYXRlKHRyYW5zbGF0ZWRNYXRyaXgsIG1hdHJpeCwgdHJhbnNsYXRpb24pO1xuICAgIHJldHVybiB0cmFuc2xhdGVkTWF0cml4O1xufTtcblxuLyoqXG4gKiBDYWxjdWxhdGUgdGhlIHBvc01hdHJpeCB0aGF0IHRoaXMgdGlsZSB1c2VzIHRvIGRpc3BsYXkgaXRzZWxmIGluIGEgbWFwLFxuICogZ2l2ZW4gYSBjb29yZGluYXRlIGFzICh6LCB4LCB5KSBhbmQgYSB0cmFuc2Zvcm1cbiAqIEBwYXJhbSB7T2JqZWN0fSB0cmFuc2Zvcm1cbiAqIEBwcml2YXRlXG4gKi9cblBhaW50ZXIucHJvdG90eXBlLmNhbGN1bGF0ZVBvc01hdHJpeCA9IGZ1bmN0aW9uKGNvb3JkLCBtYXhab29tKSB7XG5cbiAgICBpZiAoY29vcmQgaW5zdGFuY2VvZiBUaWxlQ29vcmQpIHtcbiAgICAgICAgY29vcmQgPSBjb29yZC50b0Nvb3JkaW5hdGUoKTtcbiAgICB9XG4gICAgdmFyIHRyYW5zZm9ybSA9IHRoaXMudHJhbnNmb3JtO1xuXG4gICAgaWYgKG1heFpvb20gPT09IHVuZGVmaW5lZCkgbWF4Wm9vbSA9IEluZmluaXR5O1xuXG4gICAgLy8gSW5pdGlhbGl6ZSBtb2RlbC12aWV3IG1hdHJpeCB0aGF0IGNvbnZlcnRzIGZyb20gdGhlIHRpbGUgY29vcmRpbmF0ZXNcbiAgICAvLyB0byBzY3JlZW4gY29vcmRpbmF0ZXMuXG5cbiAgICAvLyBpZiB6ID4gbWF4em9vbSB0aGVuIHRoZSB0aWxlIGlzIGFjdHVhbGx5IGEgb3ZlcnNjYWxlZCBtYXh6b29tIHRpbGUsXG4gICAgLy8gc28gY2FsY3VsYXRlIHRoZSBtYXRyaXggdGhlIG1heHpvb20gdGlsZSB3b3VsZCB1c2UuXG4gICAgdmFyIHogPSBNYXRoLm1pbihjb29yZC56b29tLCBtYXhab29tKTtcbiAgICB2YXIgeCA9IGNvb3JkLmNvbHVtbjtcbiAgICB2YXIgeSA9IGNvb3JkLnJvdztcblxuICAgIHZhciBzY2FsZSA9IHRyYW5zZm9ybS53b3JsZFNpemUgLyBNYXRoLnBvdygyLCB6KTtcblxuICAgIC8vIFRoZSBwb3NpdGlvbiBtYXRyaXhcbiAgICB2YXIgcG9zTWF0cml4ID0gbmV3IEZsb2F0NjRBcnJheSgxNik7XG5cbiAgICBtYXQ0LmlkZW50aXR5KHBvc01hdHJpeCk7XG4gICAgbWF0NC50cmFuc2xhdGUocG9zTWF0cml4LCBwb3NNYXRyaXgsIFt4ICogc2NhbGUsIHkgKiBzY2FsZSwgMF0pO1xuICAgIG1hdDQuc2NhbGUocG9zTWF0cml4LCBwb3NNYXRyaXgsIFsgc2NhbGUgLyBFWFRFTlQsIHNjYWxlIC8gRVhURU5ULCAxIF0pO1xuICAgIG1hdDQubXVsdGlwbHkocG9zTWF0cml4LCB0cmFuc2Zvcm0ucHJvak1hdHJpeCwgcG9zTWF0cml4KTtcblxuICAgIHJldHVybiBuZXcgRmxvYXQzMkFycmF5KHBvc01hdHJpeCk7XG59O1xuXG5QYWludGVyLnByb3RvdHlwZS5zYXZlVGV4dHVyZSA9IGZ1bmN0aW9uKHRleHR1cmUpIHtcbiAgICB2YXIgdGV4dHVyZXMgPSB0aGlzLnJldXNhYmxlVGV4dHVyZXNbdGV4dHVyZS5zaXplXTtcbiAgICBpZiAoIXRleHR1cmVzKSB7XG4gICAgICAgIHRoaXMucmV1c2FibGVUZXh0dXJlc1t0ZXh0dXJlLnNpemVdID0gW3RleHR1cmVdO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRleHR1cmVzLnB1c2godGV4dHVyZSk7XG4gICAgfVxufTtcblxuXG5QYWludGVyLnByb3RvdHlwZS5nZXRUZXh0dXJlID0gZnVuY3Rpb24oc2l6ZSkge1xuICAgIHZhciB0ZXh0dXJlcyA9IHRoaXMucmV1c2FibGVUZXh0dXJlc1tzaXplXTtcbiAgICByZXR1cm4gdGV4dHVyZXMgJiYgdGV4dHVyZXMubGVuZ3RoID4gMCA/IHRleHR1cmVzLnBvcCgpIDogbnVsbDtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cblxudmFyIHBhdGggPSByZXF1aXJlKCdwYXRoJyk7XG5cbi8vIE11c3QgYmUgd3JpdHRlbiBvdXQgbG9uZy1mb3JtIGZvciBicmZzLlxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgZGVidWc6IHtcbiAgICAgICAgZnJhZ21lbnQ6IFwicHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XFxuXFxudW5pZm9ybSBsb3dwIHZlYzQgdV9jb2xvcjtcXG5cXG52b2lkIG1haW4oKSB7XFxuICAgIGdsX0ZyYWdDb2xvciA9IHVfY29sb3I7XFxufVxcblwiLFxuICAgICAgICB2ZXJ0ZXg6IFwicHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcblxcbmF0dHJpYnV0ZSB2ZWMyIGFfcG9zO1xcblxcbnVuaWZvcm0gbWF0NCB1X21hdHJpeDtcXG5cXG52b2lkIG1haW4oKSB7XFxuICAgIGdsX1Bvc2l0aW9uID0gdV9tYXRyaXggKiB2ZWM0KGFfcG9zLCBzdGVwKDMyNzY3LjAsIGFfcG9zLngpLCAxKTtcXG59XFxuXCJcbiAgICB9LFxuICAgIGZpbGw6IHtcbiAgICAgICAgZnJhZ21lbnQ6IFwicHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XFxuXFxudW5pZm9ybSBsb3dwIHZlYzQgdV9jb2xvcjtcXG5cXG52b2lkIG1haW4oKSB7XFxuICAgIGdsX0ZyYWdDb2xvciA9IHVfY29sb3I7XFxufVxcblwiLFxuICAgICAgICB2ZXJ0ZXg6IFwicHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcblxcbmF0dHJpYnV0ZSB2ZWMyIGFfcG9zO1xcbnVuaWZvcm0gbWF0NCB1X21hdHJpeDtcXG5cXG52b2lkIG1haW4oKSB7XFxuICAgIGdsX1Bvc2l0aW9uID0gdV9tYXRyaXggKiB2ZWM0KGFfcG9zLCAwLCAxKTtcXG59XFxuXCJcbiAgICB9LFxuICAgIGNpcmNsZToge1xuICAgICAgICBmcmFnbWVudDogXCJwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcXG5cXG51bmlmb3JtIGxvd3AgdmVjNCB1X2NvbG9yO1xcbnVuaWZvcm0gbG93cCBmbG9hdCB1X2JsdXI7XFxuXFxudmFyeWluZyB2ZWMyIHZfZXh0cnVkZTtcXG5cXG52b2lkIG1haW4oKSB7XFxuICAgIGZsb2F0IHQgPSBzbW9vdGhzdGVwKDEuMCAtIHVfYmx1ciwgMS4wLCBsZW5ndGgodl9leHRydWRlKSk7XFxuICAgIGdsX0ZyYWdDb2xvciA9IHVfY29sb3IgKiAoMS4wIC0gdCk7XFxufVxcblwiLFxuICAgICAgICB2ZXJ0ZXg6IFwicHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcblxcbnVuaWZvcm0gbWF0NCB1X21hdHJpeDtcXG51bmlmb3JtIG1hdDQgdV9leG1hdHJpeDtcXG51bmlmb3JtIG1lZGl1bXAgZmxvYXQgdV9zaXplO1xcblxcbmF0dHJpYnV0ZSB2ZWMyIGFfcG9zO1xcblxcbnZhcnlpbmcgdmVjMiB2X2V4dHJ1ZGU7XFxuXFxudm9pZCBtYWluKHZvaWQpIHtcXG4gICAgLy8gdW5lbmNvZGUgdGhlIGV4dHJ1c2lvbiB2ZWN0b3IgdGhhdCB3ZSBzbnVjayBpbnRvIHRoZSBhX3BvcyB2ZWN0b3JcXG4gICAgdl9leHRydWRlID0gdmVjMihtb2QoYV9wb3MsIDIuMCkgKiAyLjAgLSAxLjApO1xcblxcbiAgICB2ZWM0IGV4dHJ1ZGUgPSB1X2V4bWF0cml4ICogdmVjNCh2X2V4dHJ1ZGUgKiB1X3NpemUsIDAsIDApO1xcbiAgICAvLyBtdWx0aXBseSBhX3BvcyBieSAwLjUsIHNpbmNlIHdlIGhhZCBpdCAqIDIgaW4gb3JkZXIgdG8gc25lYWtcXG4gICAgLy8gaW4gZXh0cnVzaW9uIGRhdGFcXG4gICAgZ2xfUG9zaXRpb24gPSB1X21hdHJpeCAqIHZlYzQoZmxvb3IoYV9wb3MgKiAwLjUpLCAwLCAxKTtcXG5cXG4gICAgLy8gZ2xfUG9zaXRpb24gaXMgZGl2aWRlZCBieSBnbF9Qb3NpdGlvbi53IGFmdGVyIHRoaXMgc2hhZGVyIHJ1bnMuXFxuICAgIC8vIE11bHRpcGx5IHRoZSBleHRydWRlIGJ5IGl0IHNvIHRoYXQgaXQgaXNuJ3QgYWZmZWN0ZWQgYnkgaXQuXFxuICAgIGdsX1Bvc2l0aW9uICs9IGV4dHJ1ZGUgKiBnbF9Qb3NpdGlvbi53O1xcbn1cXG5cIlxuICAgIH0sXG4gICAgbGluZToge1xuICAgICAgICBmcmFnbWVudDogXCJwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcXG5cXG51bmlmb3JtIHZlYzIgdV9saW5ld2lkdGg7XFxudW5pZm9ybSBsb3dwIHZlYzQgdV9jb2xvcjtcXG51bmlmb3JtIGZsb2F0IHVfYmx1cjtcXG5cXG52YXJ5aW5nIHZlYzIgdl9ub3JtYWw7XFxudmFyeWluZyBmbG9hdCB2X2xpbmVzb2ZhcjtcXG52YXJ5aW5nIGZsb2F0IHZfZ2FtbWFfc2NhbGU7XFxuXFxudm9pZCBtYWluKCkge1xcbiAgICAvLyBDYWxjdWxhdGUgdGhlIGRpc3RhbmNlIG9mIHRoZSBwaXhlbCBmcm9tIHRoZSBsaW5lIGluIHBpeGVscy5cXG4gICAgZmxvYXQgZGlzdCA9IGxlbmd0aCh2X25vcm1hbCkgKiB1X2xpbmV3aWR0aC5zO1xcblxcbiAgICAvLyBDYWxjdWxhdGUgdGhlIGFudGlhbGlhc2luZyBmYWRlIGZhY3Rvci4gVGhpcyBpcyBlaXRoZXIgd2hlbiBmYWRpbmcgaW5cXG4gICAgLy8gdGhlIGxpbmUgaW4gY2FzZSBvZiBhbiBvZmZzZXQgbGluZSAodl9saW5ld2lkdGgudCkgb3Igd2hlbiBmYWRpbmcgb3V0XFxuICAgIC8vICh2X2xpbmV3aWR0aC5zKVxcbiAgICBmbG9hdCBibHVyID0gdV9ibHVyICogdl9nYW1tYV9zY2FsZTtcXG4gICAgZmxvYXQgYWxwaGEgPSBjbGFtcChtaW4oZGlzdCAtICh1X2xpbmV3aWR0aC50IC0gYmx1ciksIHVfbGluZXdpZHRoLnMgLSBkaXN0KSAvIGJsdXIsIDAuMCwgMS4wKTtcXG5cXG4gICAgZ2xfRnJhZ0NvbG9yID0gdV9jb2xvciAqIGFscGhhO1xcbn1cXG5cIixcbiAgICAgICAgdmVydGV4OiBcInByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG5cXG4vLyBmbG9vcigxMjcgLyAyKSA9PSA2My4wXFxuLy8gdGhlIG1heGltdW0gYWxsb3dlZCBtaXRlciBsaW1pdCBpcyAyLjAgYXQgdGhlIG1vbWVudC4gdGhlIGV4dHJ1ZGUgbm9ybWFsIGlzXFxuLy8gc3RvcmVkIGluIGEgYnl0ZSAoLTEyOC4uMTI3KS4gd2Ugc2NhbGUgcmVndWxhciBub3JtYWxzIHVwIHRvIGxlbmd0aCA2MywgYnV0XFxuLy8gdGhlcmUgYXJlIGFsc28gXFxcInNwZWNpYWxcXFwiIG5vcm1hbHMgdGhhdCBoYXZlIGEgYmlnZ2VyIGxlbmd0aCAob2YgdXAgdG8gMTI2IGluXFxuLy8gdGhpcyBjYXNlKS5cXG4vLyAjZGVmaW5lIHNjYWxlIDYzLjBcXG4jZGVmaW5lIHNjYWxlIDAuMDE1ODczMDE2XFxuXFxuYXR0cmlidXRlIHZlYzIgYV9wb3M7XFxuYXR0cmlidXRlIHZlYzQgYV9kYXRhO1xcblxcbnVuaWZvcm0gbWF0NCB1X21hdHJpeDtcXG51bmlmb3JtIGZsb2F0IHVfcmF0aW87XFxudW5pZm9ybSBtZWRpdW1wIHZlYzIgdV9saW5ld2lkdGg7XFxudW5pZm9ybSBmbG9hdCB1X2V4dHJhO1xcbnVuaWZvcm0gbWF0MiB1X2FudGlhbGlhc2luZ21hdHJpeDtcXG51bmlmb3JtIG1lZGl1bXAgZmxvYXQgdV9vZmZzZXQ7XFxuXFxudmFyeWluZyB2ZWMyIHZfbm9ybWFsO1xcbnZhcnlpbmcgZmxvYXQgdl9saW5lc29mYXI7XFxudmFyeWluZyBmbG9hdCB2X2dhbW1hX3NjYWxlO1xcblxcbnZvaWQgbWFpbigpIHtcXG4gICAgdmVjMiBhX2V4dHJ1ZGUgPSBhX2RhdGEueHkgLSAxMjguMDtcXG4gICAgZmxvYXQgYV9kaXJlY3Rpb24gPSBtb2QoYV9kYXRhLnosIDQuMCkgLSAxLjA7XFxuXFxuICAgIC8vIFdlIHN0b3JlIHRoZSB0ZXh0dXJlIG5vcm1hbHMgaW4gdGhlIG1vc3QgaW5zaWduaWZpY2FudCBiaXRcXG4gICAgLy8gdHJhbnNmb3JtIHkgc28gdGhhdCAwID0+IC0xIGFuZCAxID0+IDFcXG4gICAgLy8gSW4gdGhlIHRleHR1cmUgbm9ybWFsLCB4IGlzIDAgaWYgdGhlIG5vcm1hbCBwb2ludHMgc3RyYWlnaHQgdXAvZG93biBhbmQgMSBpZiBpdCdzIGEgcm91bmQgY2FwXFxuICAgIC8vIHkgaXMgMSBpZiB0aGUgbm9ybWFsIHBvaW50cyB1cCwgYW5kIC0xIGlmIGl0IHBvaW50cyBkb3duXFxuICAgIG1lZGl1bXAgdmVjMiBub3JtYWwgPSBtb2QoYV9wb3MsIDIuMCk7XFxuICAgIG5vcm1hbC55ID0gc2lnbihub3JtYWwueSAtIDAuNSk7XFxuICAgIHZfbm9ybWFsID0gbm9ybWFsO1xcblxcbiAgICAvLyBTY2FsZSB0aGUgZXh0cnVzaW9uIHZlY3RvciBkb3duIHRvIGEgbm9ybWFsIGFuZCB0aGVuIHVwIGJ5IHRoZSBsaW5lIHdpZHRoXFxuICAgIC8vIG9mIHRoaXMgdmVydGV4LlxcbiAgICBtZWRpdW1wIHZlYzQgZGlzdCA9IHZlYzQodV9saW5ld2lkdGgucyAqIGFfZXh0cnVkZSAqIHNjYWxlLCAwLjAsIDAuMCk7XFxuXFxuICAgIC8vIENhbGN1bGF0ZSB0aGUgb2Zmc2V0IHdoZW4gZHJhd2luZyBhIGxpbmUgdGhhdCBpcyB0byB0aGUgc2lkZSBvZiB0aGUgYWN0dWFsIGxpbmUuXFxuICAgIC8vIFdlIGRvIHRoaXMgYnkgY3JlYXRpbmcgYSB2ZWN0b3IgdGhhdCBwb2ludHMgdG93YXJkcyB0aGUgZXh0cnVkZSwgYnV0IHJvdGF0ZVxcbiAgICAvLyBpdCB3aGVuIHdlJ3JlIGRyYXdpbmcgcm91bmQgZW5kIHBvaW50cyAoYV9kaXJlY3Rpb24gPSAtMSBvciAxKSBzaW5jZSB0aGVpclxcbiAgICAvLyBleHRydWRlIHZlY3RvciBwb2ludHMgaW4gYW5vdGhlciBkaXJlY3Rpb24uXFxuICAgIG1lZGl1bXAgZmxvYXQgdSA9IDAuNSAqIGFfZGlyZWN0aW9uO1xcbiAgICBtZWRpdW1wIGZsb2F0IHQgPSAxLjAgLSBhYnModSk7XFxuICAgIG1lZGl1bXAgdmVjMiBvZmZzZXQgPSB1X29mZnNldCAqIGFfZXh0cnVkZSAqIHNjYWxlICogbm9ybWFsLnkgKiBtYXQyKHQsIC11LCB1LCB0KTtcXG5cXG4gICAgLy8gUmVtb3ZlIHRoZSB0ZXh0dXJlIG5vcm1hbCBiaXQgb2YgdGhlIHBvc2l0aW9uIGJlZm9yZSBzY2FsaW5nIGl0IHdpdGggdGhlXFxuICAgIC8vIG1vZGVsL3ZpZXcgbWF0cml4LlxcbiAgICBnbF9Qb3NpdGlvbiA9IHVfbWF0cml4ICogdmVjNChmbG9vcihhX3BvcyAqIDAuNSkgKyAob2Zmc2V0ICsgZGlzdC54eSkgLyB1X3JhdGlvLCAwLjAsIDEuMCk7XFxuXFxuICAgIC8vIHBvc2l0aW9uIG9mIHkgb24gdGhlIHNjcmVlblxcbiAgICBmbG9hdCB5ID0gZ2xfUG9zaXRpb24ueSAvIGdsX1Bvc2l0aW9uLnc7XFxuXFxuICAgIC8vIGhvdyBtdWNoIGZlYXR1cmVzIGFyZSBzcXVpc2hlZCBpbiB0aGUgeSBkaXJlY3Rpb24gYnkgdGhlIHRpbHRcXG4gICAgZmxvYXQgc3F1aXNoX3NjYWxlID0gbGVuZ3RoKGFfZXh0cnVkZSkgLyBsZW5ndGgodV9hbnRpYWxpYXNpbmdtYXRyaXggKiBhX2V4dHJ1ZGUpO1xcblxcbiAgICAvLyBob3cgbXVjaCBmZWF0dXJlcyBhcmUgc3F1aXNoZWQgaW4gYWxsIGRpcmVjdGlvbnMgYnkgdGhlIHBlcnNwZWN0aXZlbmVzc1xcbiAgICBmbG9hdCBwZXJzcGVjdGl2ZV9zY2FsZSA9IDEuMCAvICgxLjAgLSBtaW4oeSAqIHVfZXh0cmEsIDAuOSkpO1xcblxcbiAgICB2X2dhbW1hX3NjYWxlID0gcGVyc3BlY3RpdmVfc2NhbGUgKiBzcXVpc2hfc2NhbGU7XFxufVxcblwiXG4gICAgfSxcbiAgICBsaW5lcGF0dGVybjoge1xuICAgICAgICBmcmFnbWVudDogXCJwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcXG5cXG51bmlmb3JtIHZlYzIgdV9saW5ld2lkdGg7XFxudW5pZm9ybSBmbG9hdCB1X3BvaW50O1xcbnVuaWZvcm0gZmxvYXQgdV9ibHVyO1xcblxcbnVuaWZvcm0gdmVjMiB1X3BhdHRlcm5fc2l6ZV9hO1xcbnVuaWZvcm0gdmVjMiB1X3BhdHRlcm5fc2l6ZV9iO1xcbnVuaWZvcm0gdmVjMiB1X3BhdHRlcm5fdGxfYTtcXG51bmlmb3JtIHZlYzIgdV9wYXR0ZXJuX2JyX2E7XFxudW5pZm9ybSB2ZWMyIHVfcGF0dGVybl90bF9iO1xcbnVuaWZvcm0gdmVjMiB1X3BhdHRlcm5fYnJfYjtcXG51bmlmb3JtIGZsb2F0IHVfZmFkZTtcXG51bmlmb3JtIGZsb2F0IHVfb3BhY2l0eTtcXG5cXG51bmlmb3JtIHNhbXBsZXIyRCB1X2ltYWdlO1xcblxcbnZhcnlpbmcgdmVjMiB2X25vcm1hbDtcXG52YXJ5aW5nIGZsb2F0IHZfbGluZXNvZmFyO1xcbnZhcnlpbmcgZmxvYXQgdl9nYW1tYV9zY2FsZTtcXG5cXG52b2lkIG1haW4oKSB7XFxuICAgIC8vIENhbGN1bGF0ZSB0aGUgZGlzdGFuY2Ugb2YgdGhlIHBpeGVsIGZyb20gdGhlIGxpbmUgaW4gcGl4ZWxzLlxcbiAgICBmbG9hdCBkaXN0ID0gbGVuZ3RoKHZfbm9ybWFsKSAqIHVfbGluZXdpZHRoLnM7XFxuXFxuICAgIC8vIENhbGN1bGF0ZSB0aGUgYW50aWFsaWFzaW5nIGZhZGUgZmFjdG9yLiBUaGlzIGlzIGVpdGhlciB3aGVuIGZhZGluZyBpblxcbiAgICAvLyB0aGUgbGluZSBpbiBjYXNlIG9mIGFuIG9mZnNldCBsaW5lICh2X2xpbmV3aWR0aC50KSBvciB3aGVuIGZhZGluZyBvdXRcXG4gICAgLy8gKHZfbGluZXdpZHRoLnMpXFxuICAgIGZsb2F0IGJsdXIgPSB1X2JsdXIgKiB2X2dhbW1hX3NjYWxlO1xcbiAgICBmbG9hdCBhbHBoYSA9IGNsYW1wKG1pbihkaXN0IC0gKHVfbGluZXdpZHRoLnQgLSBibHVyKSwgdV9saW5ld2lkdGgucyAtIGRpc3QpIC8gYmx1ciwgMC4wLCAxLjApO1xcblxcbiAgICBmbG9hdCB4X2EgPSBtb2Qodl9saW5lc29mYXIgLyB1X3BhdHRlcm5fc2l6ZV9hLngsIDEuMCk7XFxuICAgIGZsb2F0IHhfYiA9IG1vZCh2X2xpbmVzb2ZhciAvIHVfcGF0dGVybl9zaXplX2IueCwgMS4wKTtcXG4gICAgZmxvYXQgeV9hID0gMC41ICsgKHZfbm9ybWFsLnkgKiB1X2xpbmV3aWR0aC5zIC8gdV9wYXR0ZXJuX3NpemVfYS55KTtcXG4gICAgZmxvYXQgeV9iID0gMC41ICsgKHZfbm9ybWFsLnkgKiB1X2xpbmV3aWR0aC5zIC8gdV9wYXR0ZXJuX3NpemVfYi55KTtcXG4gICAgdmVjMiBwb3MgPSBtaXgodV9wYXR0ZXJuX3RsX2EsIHVfcGF0dGVybl9icl9hLCB2ZWMyKHhfYSwgeV9hKSk7XFxuICAgIHZlYzIgcG9zMiA9IG1peCh1X3BhdHRlcm5fdGxfYiwgdV9wYXR0ZXJuX2JyX2IsIHZlYzIoeF9iLCB5X2IpKTtcXG5cXG4gICAgdmVjNCBjb2xvciA9IG1peCh0ZXh0dXJlMkQodV9pbWFnZSwgcG9zKSwgdGV4dHVyZTJEKHVfaW1hZ2UsIHBvczIpLCB1X2ZhZGUpO1xcblxcbiAgICBhbHBoYSAqPSB1X29wYWNpdHk7XFxuXFxuICAgIGdsX0ZyYWdDb2xvciA9IGNvbG9yICogYWxwaGE7XFxufVxcblwiLFxuICAgICAgICB2ZXJ0ZXg6IFwicHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcblxcbi8vIGZsb29yKDEyNyAvIDIpID09IDYzLjBcXG4vLyB0aGUgbWF4aW11bSBhbGxvd2VkIG1pdGVyIGxpbWl0IGlzIDIuMCBhdCB0aGUgbW9tZW50LiB0aGUgZXh0cnVkZSBub3JtYWwgaXNcXG4vLyBzdG9yZWQgaW4gYSBieXRlICgtMTI4Li4xMjcpLiB3ZSBzY2FsZSByZWd1bGFyIG5vcm1hbHMgdXAgdG8gbGVuZ3RoIDYzLCBidXRcXG4vLyB0aGVyZSBhcmUgYWxzbyBcXFwic3BlY2lhbFxcXCIgbm9ybWFscyB0aGF0IGhhdmUgYSBiaWdnZXIgbGVuZ3RoIChvZiB1cCB0byAxMjYgaW5cXG4vLyB0aGlzIGNhc2UpLlxcbi8vICNkZWZpbmUgc2NhbGUgNjMuMFxcbiNkZWZpbmUgc2NhbGUgMC4wMTU4NzMwMTZcXG5cXG4vLyBXZSBzY2FsZSB0aGUgZGlzdGFuY2UgYmVmb3JlIGFkZGluZyBpdCB0byB0aGUgYnVmZmVycyBzbyB0aGF0IHdlIGNhbiBzdG9yZVxcbi8vIGxvbmcgZGlzdGFuY2VzIGZvciBsb25nIHNlZ21lbnRzLiBVc2UgdGhpcyB2YWx1ZSB0byB1bnNjYWxlIHRoZSBkaXN0YW5jZS5cXG4jZGVmaW5lIExJTkVfRElTVEFOQ0VfU0NBTEUgMi4wXFxuXFxuYXR0cmlidXRlIHZlYzIgYV9wb3M7XFxuYXR0cmlidXRlIHZlYzQgYV9kYXRhO1xcblxcbnVuaWZvcm0gbWF0NCB1X21hdHJpeDtcXG51bmlmb3JtIG1lZGl1bXAgZmxvYXQgdV9yYXRpbztcXG51bmlmb3JtIG1lZGl1bXAgdmVjMiB1X2xpbmV3aWR0aDtcXG51bmlmb3JtIGZsb2F0IHVfZXh0cmE7XFxudW5pZm9ybSBtYXQyIHVfYW50aWFsaWFzaW5nbWF0cml4O1xcbnVuaWZvcm0gbWVkaXVtcCBmbG9hdCB1X29mZnNldDtcXG5cXG52YXJ5aW5nIHZlYzIgdl9ub3JtYWw7XFxudmFyeWluZyBmbG9hdCB2X2xpbmVzb2ZhcjtcXG52YXJ5aW5nIGZsb2F0IHZfZ2FtbWFfc2NhbGU7XFxuXFxudm9pZCBtYWluKCkge1xcbiAgICB2ZWMyIGFfZXh0cnVkZSA9IGFfZGF0YS54eSAtIDEyOC4wO1xcbiAgICBmbG9hdCBhX2RpcmVjdGlvbiA9IG1vZChhX2RhdGEueiwgNC4wKSAtIDEuMDtcXG4gICAgZmxvYXQgYV9saW5lc29mYXIgPSAoZmxvb3IoYV9kYXRhLnogLyA0LjApICsgYV9kYXRhLncgKiA2NC4wKSAqIExJTkVfRElTVEFOQ0VfU0NBTEU7XFxuXFxuICAgIC8vIFdlIHN0b3JlIHRoZSB0ZXh0dXJlIG5vcm1hbHMgaW4gdGhlIG1vc3QgaW5zaWduaWZpY2FudCBiaXRcXG4gICAgLy8gdHJhbnNmb3JtIHkgc28gdGhhdCAwID0+IC0xIGFuZCAxID0+IDFcXG4gICAgLy8gSW4gdGhlIHRleHR1cmUgbm9ybWFsLCB4IGlzIDAgaWYgdGhlIG5vcm1hbCBwb2ludHMgc3RyYWlnaHQgdXAvZG93biBhbmQgMSBpZiBpdCdzIGEgcm91bmQgY2FwXFxuICAgIC8vIHkgaXMgMSBpZiB0aGUgbm9ybWFsIHBvaW50cyB1cCwgYW5kIC0xIGlmIGl0IHBvaW50cyBkb3duXFxuICAgIG1lZGl1bXAgdmVjMiBub3JtYWwgPSBtb2QoYV9wb3MsIDIuMCk7XFxuICAgIG5vcm1hbC55ID0gc2lnbihub3JtYWwueSAtIDAuNSk7XFxuICAgIHZfbm9ybWFsID0gbm9ybWFsO1xcblxcbiAgICAvLyBTY2FsZSB0aGUgZXh0cnVzaW9uIHZlY3RvciBkb3duIHRvIGEgbm9ybWFsIGFuZCB0aGVuIHVwIGJ5IHRoZSBsaW5lIHdpZHRoXFxuICAgIC8vIG9mIHRoaXMgdmVydGV4LlxcbiAgICBtZWRpdW1wIHZlYzIgZXh0cnVkZSA9IGFfZXh0cnVkZSAqIHNjYWxlO1xcbiAgICBtZWRpdW1wIHZlYzIgZGlzdCA9IHVfbGluZXdpZHRoLnMgKiBleHRydWRlO1xcblxcbiAgICAvLyBDYWxjdWxhdGUgdGhlIG9mZnNldCB3aGVuIGRyYXdpbmcgYSBsaW5lIHRoYXQgaXMgdG8gdGhlIHNpZGUgb2YgdGhlIGFjdHVhbCBsaW5lLlxcbiAgICAvLyBXZSBkbyB0aGlzIGJ5IGNyZWF0aW5nIGEgdmVjdG9yIHRoYXQgcG9pbnRzIHRvd2FyZHMgdGhlIGV4dHJ1ZGUsIGJ1dCByb3RhdGVcXG4gICAgLy8gaXQgd2hlbiB3ZSdyZSBkcmF3aW5nIHJvdW5kIGVuZCBwb2ludHMgKGFfZGlyZWN0aW9uID0gLTEgb3IgMSkgc2luY2UgdGhlaXJcXG4gICAgLy8gZXh0cnVkZSB2ZWN0b3IgcG9pbnRzIGluIGFub3RoZXIgZGlyZWN0aW9uLlxcbiAgICBtZWRpdW1wIGZsb2F0IHUgPSAwLjUgKiBhX2RpcmVjdGlvbjtcXG4gICAgbWVkaXVtcCBmbG9hdCB0ID0gMS4wIC0gYWJzKHUpO1xcbiAgICBtZWRpdW1wIHZlYzIgb2Zmc2V0ID0gdV9vZmZzZXQgKiBhX2V4dHJ1ZGUgKiBzY2FsZSAqIG5vcm1hbC55ICogbWF0Mih0LCAtdSwgdSwgdCk7XFxuXFxuICAgIC8vIFJlbW92ZSB0aGUgdGV4dHVyZSBub3JtYWwgYml0IG9mIHRoZSBwb3NpdGlvbiBiZWZvcmUgc2NhbGluZyBpdCB3aXRoIHRoZVxcbiAgICAvLyBtb2RlbC92aWV3IG1hdHJpeC5cXG4gICAgZ2xfUG9zaXRpb24gPSB1X21hdHJpeCAqIHZlYzQoZmxvb3IoYV9wb3MgKiAwLjUpICsgKG9mZnNldCArIGRpc3QueHkpIC8gdV9yYXRpbywgMC4wLCAxLjApO1xcbiAgICB2X2xpbmVzb2ZhciA9IGFfbGluZXNvZmFyO1xcblxcbiAgICAvLyBwb3NpdGlvbiBvZiB5IG9uIHRoZSBzY3JlZW5cXG4gICAgZmxvYXQgeSA9IGdsX1Bvc2l0aW9uLnkgLyBnbF9Qb3NpdGlvbi53O1xcblxcbiAgICAvLyBob3cgbXVjaCBmZWF0dXJlcyBhcmUgc3F1aXNoZWQgaW4gdGhlIHkgZGlyZWN0aW9uIGJ5IHRoZSB0aWx0XFxuICAgIGZsb2F0IHNxdWlzaF9zY2FsZSA9IGxlbmd0aChhX2V4dHJ1ZGUpIC8gbGVuZ3RoKHVfYW50aWFsaWFzaW5nbWF0cml4ICogYV9leHRydWRlKTtcXG5cXG4gICAgLy8gaG93IG11Y2ggZmVhdHVyZXMgYXJlIHNxdWlzaGVkIGluIGFsbCBkaXJlY3Rpb25zIGJ5IHRoZSBwZXJzcGVjdGl2ZW5lc3NcXG4gICAgZmxvYXQgcGVyc3BlY3RpdmVfc2NhbGUgPSAxLjAgLyAoMS4wIC0gbWluKHkgKiB1X2V4dHJhLCAwLjkpKTtcXG5cXG4gICAgdl9nYW1tYV9zY2FsZSA9IHBlcnNwZWN0aXZlX3NjYWxlICogc3F1aXNoX3NjYWxlO1xcbn1cXG5cIlxuICAgIH0sXG4gICAgbGluZXNkZnBhdHRlcm46IHtcbiAgICAgICAgZnJhZ21lbnQ6IFwicHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XFxuXFxudW5pZm9ybSB2ZWMyIHVfbGluZXdpZHRoO1xcbnVuaWZvcm0gbG93cCB2ZWM0IHVfY29sb3I7XFxudW5pZm9ybSBmbG9hdCB1X2JsdXI7XFxudW5pZm9ybSBzYW1wbGVyMkQgdV9pbWFnZTtcXG51bmlmb3JtIGZsb2F0IHVfc2RmZ2FtbWE7XFxudW5pZm9ybSBmbG9hdCB1X21peDtcXG5cXG52YXJ5aW5nIHZlYzIgdl9ub3JtYWw7XFxudmFyeWluZyB2ZWMyIHZfdGV4X2E7XFxudmFyeWluZyB2ZWMyIHZfdGV4X2I7XFxudmFyeWluZyBmbG9hdCB2X2dhbW1hX3NjYWxlO1xcblxcbnZvaWQgbWFpbigpIHtcXG4gICAgLy8gQ2FsY3VsYXRlIHRoZSBkaXN0YW5jZSBvZiB0aGUgcGl4ZWwgZnJvbSB0aGUgbGluZSBpbiBwaXhlbHMuXFxuICAgIGZsb2F0IGRpc3QgPSBsZW5ndGgodl9ub3JtYWwpICogdV9saW5ld2lkdGgucztcXG5cXG4gICAgLy8gQ2FsY3VsYXRlIHRoZSBhbnRpYWxpYXNpbmcgZmFkZSBmYWN0b3IuIFRoaXMgaXMgZWl0aGVyIHdoZW4gZmFkaW5nIGluXFxuICAgIC8vIHRoZSBsaW5lIGluIGNhc2Ugb2YgYW4gb2Zmc2V0IGxpbmUgKHZfbGluZXdpZHRoLnQpIG9yIHdoZW4gZmFkaW5nIG91dFxcbiAgICAvLyAodl9saW5ld2lkdGgucylcXG4gICAgZmxvYXQgYmx1ciA9IHVfYmx1ciAqIHZfZ2FtbWFfc2NhbGU7XFxuICAgIGZsb2F0IGFscGhhID0gY2xhbXAobWluKGRpc3QgLSAodV9saW5ld2lkdGgudCAtIGJsdXIpLCB1X2xpbmV3aWR0aC5zIC0gZGlzdCkgLyBibHVyLCAwLjAsIDEuMCk7XFxuXFxuICAgIGZsb2F0IHNkZmRpc3RfYSA9IHRleHR1cmUyRCh1X2ltYWdlLCB2X3RleF9hKS5hO1xcbiAgICBmbG9hdCBzZGZkaXN0X2IgPSB0ZXh0dXJlMkQodV9pbWFnZSwgdl90ZXhfYikuYTtcXG4gICAgZmxvYXQgc2RmZGlzdCA9IG1peChzZGZkaXN0X2EsIHNkZmRpc3RfYiwgdV9taXgpO1xcbiAgICBhbHBoYSAqPSBzbW9vdGhzdGVwKDAuNSAtIHVfc2RmZ2FtbWEsIDAuNSArIHVfc2RmZ2FtbWEsIHNkZmRpc3QpO1xcblxcbiAgICBnbF9GcmFnQ29sb3IgPSB1X2NvbG9yICogYWxwaGE7XFxufVxcblwiLFxuICAgICAgICB2ZXJ0ZXg6IFwicHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcblxcbi8vIGZsb29yKDEyNyAvIDIpID09IDYzLjBcXG4vLyB0aGUgbWF4aW11bSBhbGxvd2VkIG1pdGVyIGxpbWl0IGlzIDIuMCBhdCB0aGUgbW9tZW50LiB0aGUgZXh0cnVkZSBub3JtYWwgaXNcXG4vLyBzdG9yZWQgaW4gYSBieXRlICgtMTI4Li4xMjcpLiB3ZSBzY2FsZSByZWd1bGFyIG5vcm1hbHMgdXAgdG8gbGVuZ3RoIDYzLCBidXRcXG4vLyB0aGVyZSBhcmUgYWxzbyBcXFwic3BlY2lhbFxcXCIgbm9ybWFscyB0aGF0IGhhdmUgYSBiaWdnZXIgbGVuZ3RoIChvZiB1cCB0byAxMjYgaW5cXG4vLyB0aGlzIGNhc2UpLlxcbi8vICNkZWZpbmUgc2NhbGUgNjMuMFxcbiNkZWZpbmUgc2NhbGUgMC4wMTU4NzMwMTZcXG5cXG4vLyBXZSBzY2FsZSB0aGUgZGlzdGFuY2UgYmVmb3JlIGFkZGluZyBpdCB0byB0aGUgYnVmZmVycyBzbyB0aGF0IHdlIGNhbiBzdG9yZVxcbi8vIGxvbmcgZGlzdGFuY2VzIGZvciBsb25nIHNlZ21lbnRzLiBVc2UgdGhpcyB2YWx1ZSB0byB1bnNjYWxlIHRoZSBkaXN0YW5jZS5cXG4jZGVmaW5lIExJTkVfRElTVEFOQ0VfU0NBTEUgMi4wXFxuXFxuYXR0cmlidXRlIHZlYzIgYV9wb3M7XFxuYXR0cmlidXRlIHZlYzQgYV9kYXRhO1xcblxcbnVuaWZvcm0gbWF0NCB1X21hdHJpeDtcXG51bmlmb3JtIG1lZGl1bXAgdmVjMiB1X2xpbmV3aWR0aDtcXG51bmlmb3JtIG1lZGl1bXAgZmxvYXQgdV9yYXRpbztcXG51bmlmb3JtIHZlYzIgdV9wYXR0ZXJuc2NhbGVfYTtcXG51bmlmb3JtIGZsb2F0IHVfdGV4X3lfYTtcXG51bmlmb3JtIHZlYzIgdV9wYXR0ZXJuc2NhbGVfYjtcXG51bmlmb3JtIGZsb2F0IHVfdGV4X3lfYjtcXG51bmlmb3JtIGZsb2F0IHVfZXh0cmE7XFxudW5pZm9ybSBtYXQyIHVfYW50aWFsaWFzaW5nbWF0cml4O1xcbnVuaWZvcm0gbWVkaXVtcCBmbG9hdCB1X29mZnNldDtcXG5cXG52YXJ5aW5nIHZlYzIgdl9ub3JtYWw7XFxudmFyeWluZyB2ZWMyIHZfdGV4X2E7XFxudmFyeWluZyB2ZWMyIHZfdGV4X2I7XFxudmFyeWluZyBmbG9hdCB2X2dhbW1hX3NjYWxlO1xcblxcbnZvaWQgbWFpbigpIHtcXG4gICAgdmVjMiBhX2V4dHJ1ZGUgPSBhX2RhdGEueHkgLSAxMjguMDtcXG4gICAgZmxvYXQgYV9kaXJlY3Rpb24gPSBtb2QoYV9kYXRhLnosIDQuMCkgLSAxLjA7XFxuICAgIGZsb2F0IGFfbGluZXNvZmFyID0gKGZsb29yKGFfZGF0YS56IC8gNC4wKSArIGFfZGF0YS53ICogNjQuMCkgKiBMSU5FX0RJU1RBTkNFX1NDQUxFO1xcblxcbiAgICAvLyBXZSBzdG9yZSB0aGUgdGV4dHVyZSBub3JtYWxzIGluIHRoZSBtb3N0IGluc2lnbmlmaWNhbnQgYml0XFxuICAgIC8vIHRyYW5zZm9ybSB5IHNvIHRoYXQgMCA9PiAtMSBhbmQgMSA9PiAxXFxuICAgIC8vIEluIHRoZSB0ZXh0dXJlIG5vcm1hbCwgeCBpcyAwIGlmIHRoZSBub3JtYWwgcG9pbnRzIHN0cmFpZ2h0IHVwL2Rvd24gYW5kIDEgaWYgaXQncyBhIHJvdW5kIGNhcFxcbiAgICAvLyB5IGlzIDEgaWYgdGhlIG5vcm1hbCBwb2ludHMgdXAsIGFuZCAtMSBpZiBpdCBwb2ludHMgZG93blxcbiAgICBtZWRpdW1wIHZlYzIgbm9ybWFsID0gbW9kKGFfcG9zLCAyLjApO1xcbiAgICBub3JtYWwueSA9IHNpZ24obm9ybWFsLnkgLSAwLjUpO1xcbiAgICB2X25vcm1hbCA9IG5vcm1hbDtcXG5cXG4gICAgLy8gU2NhbGUgdGhlIGV4dHJ1c2lvbiB2ZWN0b3IgZG93biB0byBhIG5vcm1hbCBhbmQgdGhlbiB1cCBieSB0aGUgbGluZSB3aWR0aFxcbiAgICAvLyBvZiB0aGlzIHZlcnRleC5cXG4gICAgbWVkaXVtcCB2ZWM0IGRpc3QgPSB2ZWM0KHVfbGluZXdpZHRoLnMgKiBhX2V4dHJ1ZGUgKiBzY2FsZSwgMC4wLCAwLjApO1xcblxcbiAgICAvLyBDYWxjdWxhdGUgdGhlIG9mZnNldCB3aGVuIGRyYXdpbmcgYSBsaW5lIHRoYXQgaXMgdG8gdGhlIHNpZGUgb2YgdGhlIGFjdHVhbCBsaW5lLlxcbiAgICAvLyBXZSBkbyB0aGlzIGJ5IGNyZWF0aW5nIGEgdmVjdG9yIHRoYXQgcG9pbnRzIHRvd2FyZHMgdGhlIGV4dHJ1ZGUsIGJ1dCByb3RhdGVcXG4gICAgLy8gaXQgd2hlbiB3ZSdyZSBkcmF3aW5nIHJvdW5kIGVuZCBwb2ludHMgKGFfZGlyZWN0aW9uID0gLTEgb3IgMSkgc2luY2UgdGhlaXJcXG4gICAgLy8gZXh0cnVkZSB2ZWN0b3IgcG9pbnRzIGluIGFub3RoZXIgZGlyZWN0aW9uLlxcbiAgICBtZWRpdW1wIGZsb2F0IHUgPSAwLjUgKiBhX2RpcmVjdGlvbjtcXG4gICAgbWVkaXVtcCBmbG9hdCB0ID0gMS4wIC0gYWJzKHUpO1xcbiAgICBtZWRpdW1wIHZlYzIgb2Zmc2V0ID0gdV9vZmZzZXQgKiBhX2V4dHJ1ZGUgKiBzY2FsZSAqIG5vcm1hbC55ICogbWF0Mih0LCAtdSwgdSwgdCk7XFxuXFxuICAgIC8vIFJlbW92ZSB0aGUgdGV4dHVyZSBub3JtYWwgYml0IG9mIHRoZSBwb3NpdGlvbiBiZWZvcmUgc2NhbGluZyBpdCB3aXRoIHRoZVxcbiAgICAvLyBtb2RlbC92aWV3IG1hdHJpeC5cXG4gICAgZ2xfUG9zaXRpb24gPSB1X21hdHJpeCAqIHZlYzQoZmxvb3IoYV9wb3MgKiAwLjUpICsgKG9mZnNldCArIGRpc3QueHkpIC8gdV9yYXRpbywgMC4wLCAxLjApO1xcblxcbiAgICB2X3RleF9hID0gdmVjMihhX2xpbmVzb2ZhciAqIHVfcGF0dGVybnNjYWxlX2EueCwgbm9ybWFsLnkgKiB1X3BhdHRlcm5zY2FsZV9hLnkgKyB1X3RleF95X2EpO1xcbiAgICB2X3RleF9iID0gdmVjMihhX2xpbmVzb2ZhciAqIHVfcGF0dGVybnNjYWxlX2IueCwgbm9ybWFsLnkgKiB1X3BhdHRlcm5zY2FsZV9iLnkgKyB1X3RleF95X2IpO1xcblxcbiAgICAvLyBwb3NpdGlvbiBvZiB5IG9uIHRoZSBzY3JlZW5cXG4gICAgZmxvYXQgeSA9IGdsX1Bvc2l0aW9uLnkgLyBnbF9Qb3NpdGlvbi53O1xcblxcbiAgICAvLyBob3cgbXVjaCBmZWF0dXJlcyBhcmUgc3F1aXNoZWQgaW4gdGhlIHkgZGlyZWN0aW9uIGJ5IHRoZSB0aWx0XFxuICAgIGZsb2F0IHNxdWlzaF9zY2FsZSA9IGxlbmd0aChhX2V4dHJ1ZGUpIC8gbGVuZ3RoKHVfYW50aWFsaWFzaW5nbWF0cml4ICogYV9leHRydWRlKTtcXG5cXG4gICAgLy8gaG93IG11Y2ggZmVhdHVyZXMgYXJlIHNxdWlzaGVkIGluIGFsbCBkaXJlY3Rpb25zIGJ5IHRoZSBwZXJzcGVjdGl2ZW5lc3NcXG4gICAgZmxvYXQgcGVyc3BlY3RpdmVfc2NhbGUgPSAxLjAgLyAoMS4wIC0gbWluKHkgKiB1X2V4dHJhLCAwLjkpKTtcXG5cXG4gICAgdl9nYW1tYV9zY2FsZSA9IHBlcnNwZWN0aXZlX3NjYWxlICogc3F1aXNoX3NjYWxlO1xcbn1cXG5cIlxuICAgIH0sXG4gICAgb3V0bGluZToge1xuICAgICAgICBmcmFnbWVudDogXCJwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcXG5cXG51bmlmb3JtIGxvd3AgdmVjNCB1X2NvbG9yO1xcblxcbnZhcnlpbmcgdmVjMiB2X3BvcztcXG5cXG52b2lkIG1haW4oKSB7XFxuICAgIGZsb2F0IGRpc3QgPSBsZW5ndGgodl9wb3MgLSBnbF9GcmFnQ29vcmQueHkpO1xcbiAgICBmbG9hdCBhbHBoYSA9IHNtb290aHN0ZXAoMS4wLCAwLjAsIGRpc3QpO1xcbiAgICBnbF9GcmFnQ29sb3IgPSB1X2NvbG9yICogYWxwaGE7XFxufVxcblwiLFxuICAgICAgICB2ZXJ0ZXg6IFwicHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcblxcbmF0dHJpYnV0ZSB2ZWMyIGFfcG9zO1xcblxcbnVuaWZvcm0gbWF0NCB1X21hdHJpeDtcXG51bmlmb3JtIHZlYzIgdV93b3JsZDtcXG5cXG52YXJ5aW5nIHZlYzIgdl9wb3M7XFxuXFxudm9pZCBtYWluKCkge1xcbiAgICBnbF9Qb3NpdGlvbiA9IHVfbWF0cml4ICogdmVjNChhX3BvcywgMCwgMSk7XFxuICAgIHZfcG9zID0gKGdsX1Bvc2l0aW9uLnh5L2dsX1Bvc2l0aW9uLncgKyAxLjApIC8gMi4wICogdV93b3JsZDtcXG59XFxuXCJcbiAgICB9LFxuICAgIHBhdHRlcm46IHtcbiAgICAgICAgZnJhZ21lbnQ6IFwicHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XFxuXFxudW5pZm9ybSBmbG9hdCB1X29wYWNpdHk7XFxudW5pZm9ybSB2ZWMyIHVfcGF0dGVybl90bF9hO1xcbnVuaWZvcm0gdmVjMiB1X3BhdHRlcm5fYnJfYTtcXG51bmlmb3JtIHZlYzIgdV9wYXR0ZXJuX3RsX2I7XFxudW5pZm9ybSB2ZWMyIHVfcGF0dGVybl9icl9iO1xcbnVuaWZvcm0gZmxvYXQgdV9taXg7XFxuXFxudW5pZm9ybSBzYW1wbGVyMkQgdV9pbWFnZTtcXG5cXG52YXJ5aW5nIHZlYzIgdl9wb3NfYTtcXG52YXJ5aW5nIHZlYzIgdl9wb3NfYjtcXG5cXG52b2lkIG1haW4oKSB7XFxuXFxuICAgIHZlYzIgaW1hZ2Vjb29yZCA9IG1vZCh2X3Bvc19hLCAxLjApO1xcbiAgICB2ZWMyIHBvcyA9IG1peCh1X3BhdHRlcm5fdGxfYSwgdV9wYXR0ZXJuX2JyX2EsIGltYWdlY29vcmQpO1xcbiAgICB2ZWM0IGNvbG9yMSA9IHRleHR1cmUyRCh1X2ltYWdlLCBwb3MpO1xcblxcbiAgICB2ZWMyIGltYWdlY29vcmRfYiA9IG1vZCh2X3Bvc19iLCAxLjApO1xcbiAgICB2ZWMyIHBvczIgPSBtaXgodV9wYXR0ZXJuX3RsX2IsIHVfcGF0dGVybl9icl9iLCBpbWFnZWNvb3JkX2IpO1xcbiAgICB2ZWM0IGNvbG9yMiA9IHRleHR1cmUyRCh1X2ltYWdlLCBwb3MyKTtcXG5cXG4gICAgZ2xfRnJhZ0NvbG9yID0gbWl4KGNvbG9yMSwgY29sb3IyLCB1X21peCkgKiB1X29wYWNpdHk7XFxufVxcblwiLFxuICAgICAgICB2ZXJ0ZXg6IFwicHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcblxcbnVuaWZvcm0gbWF0NCB1X21hdHJpeDtcXG51bmlmb3JtIHZlYzIgdV9wYXR0ZXJuc2NhbGVfYTtcXG51bmlmb3JtIHZlYzIgdV9wYXR0ZXJuc2NhbGVfYjtcXG51bmlmb3JtIHZlYzIgdV9vZmZzZXRfYTtcXG51bmlmb3JtIHZlYzIgdV9vZmZzZXRfYjtcXG5cXG5hdHRyaWJ1dGUgdmVjMiBhX3BvcztcXG5cXG52YXJ5aW5nIHZlYzIgdl9wb3NfYTtcXG52YXJ5aW5nIHZlYzIgdl9wb3NfYjtcXG5cXG52b2lkIG1haW4oKSB7XFxuICAgIGdsX1Bvc2l0aW9uID0gdV9tYXRyaXggKiB2ZWM0KGFfcG9zLCAwLCAxKTtcXG4gICAgdl9wb3NfYSA9IHVfcGF0dGVybnNjYWxlX2EgKiBhX3BvcyArIHVfb2Zmc2V0X2E7XFxuICAgIHZfcG9zX2IgPSB1X3BhdHRlcm5zY2FsZV9iICogYV9wb3MgKyB1X29mZnNldF9iO1xcbn1cXG5cIlxuICAgIH0sXG4gICAgcmFzdGVyOiB7XG4gICAgICAgIGZyYWdtZW50OiBcInByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xcblxcbnVuaWZvcm0gZmxvYXQgdV9vcGFjaXR5MDtcXG51bmlmb3JtIGZsb2F0IHVfb3BhY2l0eTE7XFxudW5pZm9ybSBzYW1wbGVyMkQgdV9pbWFnZTA7XFxudW5pZm9ybSBzYW1wbGVyMkQgdV9pbWFnZTE7XFxudmFyeWluZyB2ZWMyIHZfcG9zMDtcXG52YXJ5aW5nIHZlYzIgdl9wb3MxO1xcblxcbnVuaWZvcm0gZmxvYXQgdV9icmlnaHRuZXNzX2xvdztcXG51bmlmb3JtIGZsb2F0IHVfYnJpZ2h0bmVzc19oaWdoO1xcblxcbnVuaWZvcm0gZmxvYXQgdV9zYXR1cmF0aW9uX2ZhY3RvcjtcXG51bmlmb3JtIGZsb2F0IHVfY29udHJhc3RfZmFjdG9yO1xcbnVuaWZvcm0gdmVjMyB1X3NwaW5fd2VpZ2h0cztcXG5cXG52b2lkIG1haW4oKSB7XFxuXFxuICAgIC8vIHJlYWQgYW5kIGNyb3NzLWZhZGUgY29sb3JzIGZyb20gdGhlIG1haW4gYW5kIHBhcmVudCB0aWxlc1xcbiAgICB2ZWM0IGNvbG9yMCA9IHRleHR1cmUyRCh1X2ltYWdlMCwgdl9wb3MwKTtcXG4gICAgdmVjNCBjb2xvcjEgPSB0ZXh0dXJlMkQodV9pbWFnZTEsIHZfcG9zMSk7XFxuICAgIHZlYzQgY29sb3IgPSBjb2xvcjAgKiB1X29wYWNpdHkwICsgY29sb3IxICogdV9vcGFjaXR5MTtcXG4gICAgdmVjMyByZ2IgPSBjb2xvci5yZ2I7XFxuXFxuICAgIC8vIHNwaW5cXG4gICAgcmdiID0gdmVjMyhcXG4gICAgICAgIGRvdChyZ2IsIHVfc3Bpbl93ZWlnaHRzLnh5eiksXFxuICAgICAgICBkb3QocmdiLCB1X3NwaW5fd2VpZ2h0cy56eHkpLFxcbiAgICAgICAgZG90KHJnYiwgdV9zcGluX3dlaWdodHMueXp4KSk7XFxuXFxuICAgIC8vIHNhdHVyYXRpb25cXG4gICAgZmxvYXQgYXZlcmFnZSA9IChjb2xvci5yICsgY29sb3IuZyArIGNvbG9yLmIpIC8gMy4wO1xcbiAgICByZ2IgKz0gKGF2ZXJhZ2UgLSByZ2IpICogdV9zYXR1cmF0aW9uX2ZhY3RvcjtcXG5cXG4gICAgLy8gY29udHJhc3RcXG4gICAgcmdiID0gKHJnYiAtIDAuNSkgKiB1X2NvbnRyYXN0X2ZhY3RvciArIDAuNTtcXG5cXG4gICAgLy8gYnJpZ2h0bmVzc1xcbiAgICB2ZWMzIHVfaGlnaF92ZWMgPSB2ZWMzKHVfYnJpZ2h0bmVzc19sb3csIHVfYnJpZ2h0bmVzc19sb3csIHVfYnJpZ2h0bmVzc19sb3cpO1xcbiAgICB2ZWMzIHVfbG93X3ZlYyA9IHZlYzModV9icmlnaHRuZXNzX2hpZ2gsIHVfYnJpZ2h0bmVzc19oaWdoLCB1X2JyaWdodG5lc3NfaGlnaCk7XFxuXFxuICAgIGdsX0ZyYWdDb2xvciA9IHZlYzQobWl4KHVfaGlnaF92ZWMsIHVfbG93X3ZlYywgcmdiKSwgY29sb3IuYSk7XFxufVxcblwiLFxuICAgICAgICB2ZXJ0ZXg6IFwicHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcblxcbnVuaWZvcm0gbWF0NCB1X21hdHJpeDtcXG51bmlmb3JtIHZlYzIgdV90bF9wYXJlbnQ7XFxudW5pZm9ybSBmbG9hdCB1X3NjYWxlX3BhcmVudDtcXG51bmlmb3JtIGZsb2F0IHVfYnVmZmVyX3NjYWxlO1xcblxcbmF0dHJpYnV0ZSB2ZWMyIGFfcG9zO1xcbmF0dHJpYnV0ZSB2ZWMyIGFfdGV4dHVyZV9wb3M7XFxuXFxudmFyeWluZyB2ZWMyIHZfcG9zMDtcXG52YXJ5aW5nIHZlYzIgdl9wb3MxO1xcblxcbnZvaWQgbWFpbigpIHtcXG4gICAgZ2xfUG9zaXRpb24gPSB1X21hdHJpeCAqIHZlYzQoYV9wb3MsIDAsIDEpO1xcbiAgICB2X3BvczAgPSAoKChhX3RleHR1cmVfcG9zIC8gMzI3NjcuMCkgLSAwLjUpIC8gdV9idWZmZXJfc2NhbGUgKSArIDAuNTtcXG4gICAgdl9wb3MxID0gKHZfcG9zMCAqIHVfc2NhbGVfcGFyZW50KSArIHVfdGxfcGFyZW50O1xcbn1cXG5cIlxuICAgIH0sXG4gICAgaWNvbjoge1xuICAgICAgICBmcmFnbWVudDogXCJwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcXG5cXG51bmlmb3JtIHNhbXBsZXIyRCB1X3RleHR1cmU7XFxuXFxudmFyeWluZyB2ZWMyIHZfdGV4O1xcbnZhcnlpbmcgZmxvYXQgdl9hbHBoYTtcXG5cXG52b2lkIG1haW4oKSB7XFxuICAgIGdsX0ZyYWdDb2xvciA9IHRleHR1cmUyRCh1X3RleHR1cmUsIHZfdGV4KSAqIHZfYWxwaGE7XFxufVxcblwiLFxuICAgICAgICB2ZXJ0ZXg6IFwicHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcblxcbmF0dHJpYnV0ZSB2ZWMyIGFfcG9zO1xcbmF0dHJpYnV0ZSB2ZWMyIGFfb2Zmc2V0O1xcbmF0dHJpYnV0ZSB2ZWM0IGFfZGF0YTE7XFxuYXR0cmlidXRlIHZlYzQgYV9kYXRhMjtcXG5cXG5cXG4vLyBtYXRyaXggaXMgZm9yIHRoZSB2ZXJ0ZXggcG9zaXRpb24sIGV4bWF0cml4IGlzIGZvciByb3RhdGluZyBhbmQgcHJvamVjdGluZ1xcbi8vIHRoZSBleHRydXNpb24gdmVjdG9yLlxcbnVuaWZvcm0gbWF0NCB1X21hdHJpeDtcXG51bmlmb3JtIG1hdDQgdV9leG1hdHJpeDtcXG51bmlmb3JtIG1lZGl1bXAgZmxvYXQgdV96b29tO1xcbnVuaWZvcm0gbWVkaXVtcCBmbG9hdCB1X2ZhZGVkaXN0O1xcbnVuaWZvcm0gbWVkaXVtcCBmbG9hdCB1X21pbmZhZGV6b29tO1xcbnVuaWZvcm0gbWVkaXVtcCBmbG9hdCB1X21heGZhZGV6b29tO1xcbnVuaWZvcm0gbWVkaXVtcCBmbG9hdCB1X2ZhZGV6b29tO1xcbnVuaWZvcm0gbG93cCBmbG9hdCB1X29wYWNpdHk7XFxudW5pZm9ybSBib29sIHVfc2tld2VkO1xcbnVuaWZvcm0gZmxvYXQgdV9leHRyYTtcXG5cXG51bmlmb3JtIHZlYzIgdV90ZXhzaXplO1xcblxcbnZhcnlpbmcgdmVjMiB2X3RleDtcXG52YXJ5aW5nIGZsb2F0IHZfYWxwaGE7XFxuXFxudm9pZCBtYWluKCkge1xcbiAgICB2ZWMyIGFfdGV4ID0gYV9kYXRhMS54eTtcXG4gICAgbWVkaXVtcCBmbG9hdCBhX2xhYmVsbWluem9vbSA9IGFfZGF0YTFbMl07XFxuICAgIG1lZGl1bXAgdmVjMiBhX3pvb20gPSBhX2RhdGEyLnN0O1xcbiAgICBtZWRpdW1wIGZsb2F0IGFfbWluem9vbSA9IGFfem9vbVswXTtcXG4gICAgbWVkaXVtcCBmbG9hdCBhX21heHpvb20gPSBhX3pvb21bMV07XFxuXFxuICAgIGZsb2F0IGFfZmFkZWRpc3QgPSAxMC4wO1xcblxcbiAgICAvLyB1X3pvb20gaXMgdGhlIGN1cnJlbnQgem9vbSBsZXZlbCBhZGp1c3RlZCBmb3IgdGhlIGNoYW5nZSBpbiBmb250IHNpemVcXG4gICAgbWVkaXVtcCBmbG9hdCB6ID0gMi4wIC0gc3RlcChhX21pbnpvb20sIHVfem9vbSkgLSAoMS4wIC0gc3RlcChhX21heHpvb20sIHVfem9vbSkpO1xcblxcbiAgICAvLyBmYWRlIG91dCBsYWJlbHNcXG4gICAgbWVkaXVtcCBmbG9hdCBhbHBoYSA9IGNsYW1wKCh1X2ZhZGV6b29tIC0gYV9sYWJlbG1pbnpvb20pIC8gdV9mYWRlZGlzdCwgMC4wLCAxLjApO1xcblxcbiAgICBpZiAodV9mYWRlZGlzdCA+PSAwLjApIHtcXG4gICAgICAgIHZfYWxwaGEgPSBhbHBoYTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICAgIHZfYWxwaGEgPSAxLjAgLSBhbHBoYTtcXG4gICAgfVxcbiAgICBpZiAodV9tYXhmYWRlem9vbSA8IGFfbGFiZWxtaW56b29tKSB7XFxuICAgICAgICB2X2FscGhhID0gMC4wO1xcbiAgICB9XFxuICAgIGlmICh1X21pbmZhZGV6b29tID49IGFfbGFiZWxtaW56b29tKSB7XFxuICAgICAgICB2X2FscGhhID0gMS4wO1xcbiAgICB9XFxuXFxuICAgIC8vIGlmIGxhYmVsIGhhcyBiZWVuIGZhZGVkIG91dCwgY2xpcCBpdFxcbiAgICB6ICs9IHN0ZXAodl9hbHBoYSwgMC4wKTtcXG5cXG4gICAgaWYgKHVfc2tld2VkKSB7XFxuICAgICAgICB2ZWM0IGV4dHJ1ZGUgPSB1X2V4bWF0cml4ICogdmVjNChhX29mZnNldCAvIDY0LjAsIDAsIDApO1xcbiAgICAgICAgZ2xfUG9zaXRpb24gPSB1X21hdHJpeCAqIHZlYzQoYV9wb3MgKyBleHRydWRlLnh5LCAwLCAxKTtcXG4gICAgICAgIGdsX1Bvc2l0aW9uLnogKz0geiAqIGdsX1Bvc2l0aW9uLnc7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgICB2ZWM0IGV4dHJ1ZGUgPSB1X2V4bWF0cml4ICogdmVjNChhX29mZnNldCAvIDY0LjAsIHosIDApO1xcbiAgICAgICAgZ2xfUG9zaXRpb24gPSB1X21hdHJpeCAqIHZlYzQoYV9wb3MsIDAsIDEpICsgZXh0cnVkZTtcXG4gICAgfVxcblxcbiAgICB2X3RleCA9IGFfdGV4IC8gdV90ZXhzaXplO1xcblxcbiAgICB2X2FscGhhICo9IHVfb3BhY2l0eTtcXG59XFxuXCJcbiAgICB9LFxuICAgIHNkZjoge1xuICAgICAgICBmcmFnbWVudDogXCJwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcXG5cXG51bmlmb3JtIHNhbXBsZXIyRCB1X3RleHR1cmU7XFxudW5pZm9ybSBsb3dwIHZlYzQgdV9jb2xvcjtcXG51bmlmb3JtIGxvd3AgZmxvYXQgdV9idWZmZXI7XFxudW5pZm9ybSBsb3dwIGZsb2F0IHVfZ2FtbWE7XFxuXFxudmFyeWluZyB2ZWMyIHZfdGV4O1xcbnZhcnlpbmcgZmxvYXQgdl9hbHBoYTtcXG52YXJ5aW5nIGZsb2F0IHZfZ2FtbWFfc2NhbGU7XFxuXFxudm9pZCBtYWluKCkge1xcbiAgICBsb3dwIGZsb2F0IGdhbW1hID0gdV9nYW1tYSAqIHZfZ2FtbWFfc2NhbGU7XFxuICAgIGxvd3AgZmxvYXQgZGlzdCA9IHRleHR1cmUyRCh1X3RleHR1cmUsIHZfdGV4KS5hO1xcbiAgICBsb3dwIGZsb2F0IGFscGhhID0gc21vb3Roc3RlcCh1X2J1ZmZlciAtIGdhbW1hLCB1X2J1ZmZlciArIGdhbW1hLCBkaXN0KSAqIHZfYWxwaGE7XFxuICAgIGdsX0ZyYWdDb2xvciA9IHVfY29sb3IgKiBhbHBoYTtcXG59XFxuXCIsXG4gICAgICAgIHZlcnRleDogXCJwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuXFxuYXR0cmlidXRlIHZlYzIgYV9wb3M7XFxuYXR0cmlidXRlIHZlYzIgYV9vZmZzZXQ7XFxuYXR0cmlidXRlIHZlYzQgYV9kYXRhMTtcXG5hdHRyaWJ1dGUgdmVjNCBhX2RhdGEyO1xcblxcblxcbi8vIG1hdHJpeCBpcyBmb3IgdGhlIHZlcnRleCBwb3NpdGlvbiwgZXhtYXRyaXggaXMgZm9yIHJvdGF0aW5nIGFuZCBwcm9qZWN0aW5nXFxuLy8gdGhlIGV4dHJ1c2lvbiB2ZWN0b3IuXFxudW5pZm9ybSBtYXQ0IHVfbWF0cml4O1xcbnVuaWZvcm0gbWF0NCB1X2V4bWF0cml4O1xcblxcbnVuaWZvcm0gbWVkaXVtcCBmbG9hdCB1X3pvb207XFxudW5pZm9ybSBtZWRpdW1wIGZsb2F0IHVfZmFkZWRpc3Q7XFxudW5pZm9ybSBtZWRpdW1wIGZsb2F0IHVfbWluZmFkZXpvb207XFxudW5pZm9ybSBtZWRpdW1wIGZsb2F0IHVfbWF4ZmFkZXpvb207XFxudW5pZm9ybSBtZWRpdW1wIGZsb2F0IHVfZmFkZXpvb207XFxudW5pZm9ybSBib29sIHVfc2tld2VkO1xcbnVuaWZvcm0gZmxvYXQgdV9leHRyYTtcXG5cXG51bmlmb3JtIHZlYzIgdV90ZXhzaXplO1xcblxcbnZhcnlpbmcgdmVjMiB2X3RleDtcXG52YXJ5aW5nIGZsb2F0IHZfYWxwaGE7XFxudmFyeWluZyBmbG9hdCB2X2dhbW1hX3NjYWxlO1xcblxcbnZvaWQgbWFpbigpIHtcXG4gICAgdmVjMiBhX3RleCA9IGFfZGF0YTEueHk7XFxuICAgIG1lZGl1bXAgZmxvYXQgYV9sYWJlbG1pbnpvb20gPSBhX2RhdGExWzJdO1xcbiAgICBtZWRpdW1wIHZlYzIgYV96b29tID0gYV9kYXRhMi5zdDtcXG4gICAgbWVkaXVtcCBmbG9hdCBhX21pbnpvb20gPSBhX3pvb21bMF07XFxuICAgIG1lZGl1bXAgZmxvYXQgYV9tYXh6b29tID0gYV96b29tWzFdO1xcblxcbiAgICAvLyB1X3pvb20gaXMgdGhlIGN1cnJlbnQgem9vbSBsZXZlbCBhZGp1c3RlZCBmb3IgdGhlIGNoYW5nZSBpbiBmb250IHNpemVcXG4gICAgbWVkaXVtcCBmbG9hdCB6ID0gMi4wIC0gc3RlcChhX21pbnpvb20sIHVfem9vbSkgLSAoMS4wIC0gc3RlcChhX21heHpvb20sIHVfem9vbSkpO1xcblxcbiAgICAvLyBmYWRlIG91dCBsYWJlbHNcXG4gICAgbWVkaXVtcCBmbG9hdCBhbHBoYSA9IGNsYW1wKCh1X2ZhZGV6b29tIC0gYV9sYWJlbG1pbnpvb20pIC8gdV9mYWRlZGlzdCwgMC4wLCAxLjApO1xcblxcbiAgICBpZiAodV9mYWRlZGlzdCA+PSAwLjApIHtcXG4gICAgICAgIHZfYWxwaGEgPSBhbHBoYTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICAgIHZfYWxwaGEgPSAxLjAgLSBhbHBoYTtcXG4gICAgfVxcbiAgICBpZiAodV9tYXhmYWRlem9vbSA8IGFfbGFiZWxtaW56b29tKSB7XFxuICAgICAgICB2X2FscGhhID0gMC4wO1xcbiAgICB9XFxuICAgIGlmICh1X21pbmZhZGV6b29tID49IGFfbGFiZWxtaW56b29tKSB7XFxuICAgICAgICB2X2FscGhhID0gMS4wO1xcbiAgICB9XFxuXFxuICAgIC8vIGlmIGxhYmVsIGhhcyBiZWVuIGZhZGVkIG91dCwgY2xpcCBpdFxcbiAgICB6ICs9IHN0ZXAodl9hbHBoYSwgMC4wKTtcXG5cXG4gICAgaWYgKHVfc2tld2VkKSB7XFxuICAgICAgICB2ZWM0IGV4dHJ1ZGUgPSB1X2V4bWF0cml4ICogdmVjNChhX29mZnNldCAvIDY0LjAsIDAsIDApO1xcbiAgICAgICAgZ2xfUG9zaXRpb24gPSB1X21hdHJpeCAqIHZlYzQoYV9wb3MgKyBleHRydWRlLnh5LCAwLCAxKTtcXG4gICAgICAgIGdsX1Bvc2l0aW9uLnogKz0geiAqIGdsX1Bvc2l0aW9uLnc7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgICB2ZWM0IGV4dHJ1ZGUgPSB1X2V4bWF0cml4ICogdmVjNChhX29mZnNldCAvIDY0LjAsIHosIDApO1xcbiAgICAgICAgZ2xfUG9zaXRpb24gPSB1X21hdHJpeCAqIHZlYzQoYV9wb3MsIDAsIDEpICsgZXh0cnVkZTtcXG4gICAgfVxcblxcbiAgICAvLyBwb3NpdGlvbiBvZiB5IG9uIHRoZSBzY3JlZW5cXG4gICAgZmxvYXQgeSA9IGdsX1Bvc2l0aW9uLnkgLyBnbF9Qb3NpdGlvbi53O1xcbiAgICAvLyBob3cgbXVjaCBmZWF0dXJlcyBhcmUgc3F1aXNoZWQgaW4gYWxsIGRpcmVjdGlvbnMgYnkgdGhlIHBlcnNwZWN0aXZlbmVzc1xcbiAgICBmbG9hdCBwZXJzcGVjdGl2ZV9zY2FsZSA9IDEuMCAvICgxLjAgLSB5ICogdV9leHRyYSk7XFxuICAgIHZfZ2FtbWFfc2NhbGUgPSBwZXJzcGVjdGl2ZV9zY2FsZTtcXG5cXG4gICAgdl90ZXggPSBhX3RleCAvIHVfdGV4c2l6ZTtcXG59XFxuXCJcbiAgICB9LFxuICAgIGNvbGxpc2lvbmJveDoge1xuICAgICAgICBmcmFnbWVudDogXCJwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcXG5cXG51bmlmb3JtIGZsb2F0IHVfem9vbTtcXG51bmlmb3JtIGZsb2F0IHVfbWF4em9vbTtcXG5cXG52YXJ5aW5nIGZsb2F0IHZfbWF4X3pvb207XFxudmFyeWluZyBmbG9hdCB2X3BsYWNlbWVudF96b29tO1xcblxcbnZvaWQgbWFpbigpIHtcXG5cXG4gICAgZmxvYXQgYWxwaGEgPSAwLjU7XFxuXFxuICAgIGdsX0ZyYWdDb2xvciA9IHZlYzQoMC4wLCAxLjAsIDAuMCwgMS4wKSAqIGFscGhhO1xcblxcbiAgICBpZiAodl9wbGFjZW1lbnRfem9vbSA+IHVfem9vbSkge1xcbiAgICAgICAgZ2xfRnJhZ0NvbG9yID0gdmVjNCgxLjAsIDAuMCwgMC4wLCAxLjApICogYWxwaGE7XFxuICAgIH1cXG5cXG4gICAgaWYgKHVfem9vbSA+PSB2X21heF96b29tKSB7XFxuICAgICAgICBnbF9GcmFnQ29sb3IgPSB2ZWM0KDAuMCwgMC4wLCAwLjAsIDEuMCkgKiBhbHBoYSAqIDAuMjU7XFxuICAgIH1cXG5cXG4gICAgaWYgKHZfcGxhY2VtZW50X3pvb20gPj0gdV9tYXh6b29tKSB7XFxuICAgICAgICBnbF9GcmFnQ29sb3IgPSB2ZWM0KDAuMCwgMC4wLCAxLjAsIDEuMCkgKiBhbHBoYSAqIDAuMjtcXG4gICAgfVxcbn1cXG5cIixcbiAgICAgICAgdmVydGV4OiBcInByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG5cXG5hdHRyaWJ1dGUgdmVjMiBhX3BvcztcXG5hdHRyaWJ1dGUgdmVjMiBhX2V4dHJ1ZGU7XFxuYXR0cmlidXRlIHZlYzIgYV9kYXRhO1xcblxcbnVuaWZvcm0gbWF0NCB1X21hdHJpeDtcXG51bmlmb3JtIGZsb2F0IHVfc2NhbGU7XFxuXFxudmFyeWluZyBmbG9hdCB2X21heF96b29tO1xcbnZhcnlpbmcgZmxvYXQgdl9wbGFjZW1lbnRfem9vbTtcXG5cXG52b2lkIG1haW4oKSB7XFxuICAgICBnbF9Qb3NpdGlvbiA9IHVfbWF0cml4ICogdmVjNChhX3BvcyArIGFfZXh0cnVkZSAvIHVfc2NhbGUsIDAuMCwgMS4wKTtcXG5cXG4gICAgIHZfbWF4X3pvb20gPSBhX2RhdGEueDtcXG4gICAgIHZfcGxhY2VtZW50X3pvb20gPSBhX2RhdGEueTtcXG59XFxuXCJcbiAgICB9XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwvdXRpbCcpO1xudmFyIEV2ZW50ZWQgPSByZXF1aXJlKCcuLi91dGlsL2V2ZW50ZWQnKTtcbnZhciBUaWxlUHlyYW1pZCA9IHJlcXVpcmUoJy4vdGlsZV9weXJhbWlkJyk7XG52YXIgU291cmNlID0gcmVxdWlyZSgnLi9zb3VyY2UnKTtcbnZhciB1cmxSZXNvbHZlID0gcmVxdWlyZSgncmVzb2x2ZS11cmwnKTtcbnZhciBFWFRFTlQgPSByZXF1aXJlKCcuLi9kYXRhL2J1Y2tldCcpLkVYVEVOVDtcblxubW9kdWxlLmV4cG9ydHMgPSBHZW9KU09OU291cmNlO1xuXG4vKipcbiAqIENyZWF0ZSBhIEdlb0pTT04gZGF0YSBzb3VyY2UgaW5zdGFuY2UgZ2l2ZW4gYW4gb3B0aW9ucyBvYmplY3RcbiAqIEBjbGFzcyBHZW9KU09OU291cmNlXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiBAcGFyYW0ge09iamVjdHxzdHJpbmd9IG9wdGlvbnMuZGF0YSBBIEdlb0pTT04gZGF0YSBvYmplY3Qgb3IgVVJMIHRvIGl0LiBUaGUgbGF0dGVyIGlzIHByZWZlcmFibGUgaW4gY2FzZSBvZiBsYXJnZSBHZW9KU09OIGZpbGVzLlxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLm1heHpvb209MThdIE1heGltdW0gem9vbSB0byBwcmVzZXJ2ZSBkZXRhaWwgYXQuXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMuYnVmZmVyXSBUaWxlIGJ1ZmZlciBvbiBlYWNoIHNpZGUgaW4gcGl4ZWxzLlxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLnRvbGVyYW5jZV0gU2ltcGxpZmljYXRpb24gdG9sZXJhbmNlIChoaWdoZXIgbWVhbnMgc2ltcGxlcikgaW4gcGl4ZWxzLlxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLmNsdXN0ZXJdIElmIHRoZSBkYXRhIGlzIGEgY29sbGVjdGlvbiBvZiBwb2ludCBmZWF0dXJlcywgc2V0dGluZyB0aGlzIHRvIHRydWUgY2x1c3RlcnMgdGhlIHBvaW50cyBieSByYWRpdXMgaW50byBncm91cHMuXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMuY2x1c3RlclJhZGl1cz01MF0gUmFkaXVzIG9mIGVhY2ggY2x1c3RlciB3aGVuIGNsdXN0ZXJpbmcgcG9pbnRzLCBpbiBwaXhlbHMuXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMuY2x1c3Rlck1heFpvb21dIE1heCB6b29tIHRvIGNsdXN0ZXIgcG9pbnRzIG9uLiBEZWZhdWx0cyB0byBvbmUgem9vbSBsZXNzIHRoYW4gYG1heHpvb21gIChzbyB0aGF0IGxhc3Qgem9vbSBmZWF0dXJlcyBhcmUgbm90IGNsdXN0ZXJlZCkuXG5cbiAqIEBleGFtcGxlXG4gKiB2YXIgc291cmNlT2JqID0gbmV3IG1hcGJveGdsLkdlb0pTT05Tb3VyY2Uoe1xuICogICAgZGF0YToge1xuICogICAgICAgIFwidHlwZVwiOiBcIkZlYXR1cmVDb2xsZWN0aW9uXCIsXG4gKiAgICAgICAgXCJmZWF0dXJlc1wiOiBbe1xuICogICAgICAgICAgICBcInR5cGVcIjogXCJGZWF0dXJlXCIsXG4gKiAgICAgICAgICAgIFwiZ2VvbWV0cnlcIjoge1xuICogICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiUG9pbnRcIixcbiAqICAgICAgICAgICAgICAgIFwiY29vcmRpbmF0ZXNcIjogW1xuICogICAgICAgICAgICAgICAgICAgIC03Ni41MzA2MzI5NzI3MTcyOSxcbiAqICAgICAgICAgICAgICAgICAgICAzOS4xODE3NDA3Nzk5NDEwOFxuICogICAgICAgICAgICAgICAgXVxuICogICAgICAgICAgICB9XG4gKiAgICAgICAgfV1cbiAqICAgIH1cbiAqIH0pO1xuICogbWFwLmFkZFNvdXJjZSgnc29tZSBpZCcsIHNvdXJjZU9iaik7IC8vIGFkZFxuICogbWFwLnJlbW92ZVNvdXJjZSgnc29tZSBpZCcpOyAgLy8gcmVtb3ZlXG4gKi9cbmZ1bmN0aW9uIEdlb0pTT05Tb3VyY2Uob3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgdGhpcy5fZGF0YSA9IG9wdGlvbnMuZGF0YTtcblxuICAgIGlmIChvcHRpb25zLm1heHpvb20gIT09IHVuZGVmaW5lZCkgdGhpcy5tYXh6b29tID0gb3B0aW9ucy5tYXh6b29tO1xuXG4gICAgdmFyIHNjYWxlID0gRVhURU5UIC8gdGhpcy50aWxlU2l6ZTtcblxuICAgIHRoaXMuZ2VvanNvblZ0T3B0aW9ucyA9IHtcbiAgICAgICAgYnVmZmVyOiAob3B0aW9ucy5idWZmZXIgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuYnVmZmVyIDogMTI4KSAqIHNjYWxlLFxuICAgICAgICB0b2xlcmFuY2U6IChvcHRpb25zLnRvbGVyYW5jZSAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy50b2xlcmFuY2UgOiAwLjM3NSkgKiBzY2FsZSxcbiAgICAgICAgZXh0ZW50OiBFWFRFTlQsXG4gICAgICAgIG1heFpvb206IHRoaXMubWF4em9vbVxuICAgIH07XG5cbiAgICB0aGlzLmNsdXN0ZXIgPSBvcHRpb25zLmNsdXN0ZXIgfHwgZmFsc2U7XG4gICAgdGhpcy5zdXBlcmNsdXN0ZXJPcHRpb25zID0ge1xuICAgICAgICBtYXhab29tOiBNYXRoLm1heChvcHRpb25zLmNsdXN0ZXJNYXhab29tLCB0aGlzLm1heHpvb20gLSAxKSB8fCAodGhpcy5tYXh6b29tIC0gMSksXG4gICAgICAgIGV4dGVudDogRVhURU5ULFxuICAgICAgICByYWRpdXM6IChvcHRpb25zLmNsdXN0ZXJSYWRpdXMgfHwgNTApICogc2NhbGUsXG4gICAgICAgIGxvZzogZmFsc2VcbiAgICB9O1xuXG4gICAgdGhpcy5fcHlyYW1pZCA9IG5ldyBUaWxlUHlyYW1pZCh7XG4gICAgICAgIHRpbGVTaXplOiB0aGlzLnRpbGVTaXplLFxuICAgICAgICBtaW56b29tOiB0aGlzLm1pbnpvb20sXG4gICAgICAgIG1heHpvb206IHRoaXMubWF4em9vbSxcbiAgICAgICAgcmVwYXJzZU92ZXJzY2FsZWQ6IHRydWUsXG4gICAgICAgIGxvYWQ6IHRoaXMuX2xvYWRUaWxlLmJpbmQodGhpcyksXG4gICAgICAgIGFib3J0OiB0aGlzLl9hYm9ydFRpbGUuYmluZCh0aGlzKSxcbiAgICAgICAgdW5sb2FkOiB0aGlzLl91bmxvYWRUaWxlLmJpbmQodGhpcyksXG4gICAgICAgIGFkZDogdGhpcy5fYWRkVGlsZS5iaW5kKHRoaXMpLFxuICAgICAgICByZW1vdmU6IHRoaXMuX3JlbW92ZVRpbGUuYmluZCh0aGlzKSxcbiAgICAgICAgcmVkb1BsYWNlbWVudDogdGhpcy5fcmVkb1RpbGVQbGFjZW1lbnQuYmluZCh0aGlzKVxuICAgIH0pO1xufVxuXG5HZW9KU09OU291cmNlLnByb3RvdHlwZSA9IHV0aWwuaW5oZXJpdChFdmVudGVkLCAvKiogQGxlbmRzIEdlb0pTT05Tb3VyY2UucHJvdG90eXBlICove1xuICAgIG1pbnpvb206IDAsXG4gICAgbWF4em9vbTogMTgsXG4gICAgdGlsZVNpemU6IDUxMixcbiAgICBfZGlydHk6IHRydWUsXG4gICAgaXNUaWxlQ2xpcHBlZDogdHJ1ZSxcblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSBzb3VyY2UgZ2VvanNvbiBkYXRhIGFuZCByZXJlbmRlciBtYXBcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fHN0cmluZ30gZGF0YSBBIEdlb0pTT04gZGF0YSBvYmplY3Qgb3IgVVJMIHRvIGl0LiBUaGUgbGF0dGVyIGlzIHByZWZlcmFibGUgaW4gY2FzZSBvZiBsYXJnZSBHZW9KU09OIGZpbGVzLlxuICAgICAqIEByZXR1cm5zIHtHZW9KU09OU291cmNlfSB0aGlzXG4gICAgICovXG4gICAgc2V0RGF0YTogZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICB0aGlzLl9kYXRhID0gZGF0YTtcbiAgICAgICAgdGhpcy5fZGlydHkgPSB0cnVlO1xuXG4gICAgICAgIHRoaXMuZmlyZSgnY2hhbmdlJyk7XG5cbiAgICAgICAgaWYgKHRoaXMubWFwKVxuICAgICAgICAgICAgdGhpcy51cGRhdGUodGhpcy5tYXAudHJhbnNmb3JtKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgb25BZGQ6IGZ1bmN0aW9uKG1hcCkge1xuICAgICAgICB0aGlzLm1hcCA9IG1hcDtcbiAgICB9LFxuXG4gICAgbG9hZGVkOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xvYWRlZCAmJiB0aGlzLl9weXJhbWlkLmxvYWRlZCgpO1xuICAgIH0sXG5cbiAgICB1cGRhdGU6IGZ1bmN0aW9uKHRyYW5zZm9ybSkge1xuICAgICAgICBpZiAodGhpcy5fZGlydHkpIHtcbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZURhdGEoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLl9sb2FkZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX3B5cmFtaWQudXBkYXRlKHRoaXMudXNlZCwgdHJhbnNmb3JtKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICByZWxvYWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5fbG9hZGVkKSB7XG4gICAgICAgICAgICB0aGlzLl9weXJhbWlkLnJlbG9hZCgpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIHNlcmlhbGl6ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiAnZ2VvanNvbicsXG4gICAgICAgICAgICBkYXRhOiB0aGlzLl9kYXRhXG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIGdldFZpc2libGVDb29yZGluYXRlczogU291cmNlLl9nZXRWaXNpYmxlQ29vcmRpbmF0ZXMsXG4gICAgZ2V0VGlsZTogU291cmNlLl9nZXRUaWxlLFxuXG4gICAgcXVlcnlSZW5kZXJlZEZlYXR1cmVzOiBTb3VyY2UuX3F1ZXJ5UmVuZGVyZWRWZWN0b3JGZWF0dXJlcyxcbiAgICBxdWVyeVNvdXJjZUZlYXR1cmVzOiBTb3VyY2UuX3F1ZXJ5U291cmNlRmVhdHVyZXMsXG5cbiAgICBfdXBkYXRlRGF0YTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuX2RpcnR5ID0gZmFsc2U7XG4gICAgICAgIHZhciBvcHRpb25zID0ge1xuICAgICAgICAgICAgdGlsZVNpemU6IHRoaXMudGlsZVNpemUsXG4gICAgICAgICAgICBzb3VyY2U6IHRoaXMuaWQsXG4gICAgICAgICAgICBnZW9qc29uVnRPcHRpb25zOiB0aGlzLmdlb2pzb25WdE9wdGlvbnMsXG4gICAgICAgICAgICBjbHVzdGVyOiB0aGlzLmNsdXN0ZXIsXG4gICAgICAgICAgICBzdXBlcmNsdXN0ZXJPcHRpb25zOiB0aGlzLnN1cGVyY2x1c3Rlck9wdGlvbnNcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgZGF0YSA9IHRoaXMuX2RhdGE7XG4gICAgICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIG9wdGlvbnMudXJsID0gdHlwZW9mIHdpbmRvdyAhPSAndW5kZWZpbmVkJyA/IHVybFJlc29sdmUod2luZG93LmxvY2F0aW9uLmhyZWYsIGRhdGEpIDogZGF0YTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG9wdGlvbnMuZGF0YSA9IEpTT04uc3RyaW5naWZ5KGRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMud29ya2VySUQgPSB0aGlzLmRpc3BhdGNoZXIuc2VuZCgncGFyc2UgZ2VvanNvbicsIG9wdGlvbnMsIGZ1bmN0aW9uKGVycikge1xuICAgICAgICAgICAgdGhpcy5fbG9hZGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZpcmUoJ2Vycm9yJywge2Vycm9yOiBlcnJ9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcHlyYW1pZC5yZWxvYWQoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmZpcmUoJ2NoYW5nZScpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH0uYmluZCh0aGlzKSk7XG4gICAgfSxcblxuICAgIF9sb2FkVGlsZTogZnVuY3Rpb24odGlsZSkge1xuICAgICAgICB2YXIgb3ZlcnNjYWxpbmcgPSB0aWxlLmNvb3JkLnogPiB0aGlzLm1heHpvb20gPyBNYXRoLnBvdygyLCB0aWxlLmNvb3JkLnogLSB0aGlzLm1heHpvb20pIDogMTtcbiAgICAgICAgdmFyIHBhcmFtcyA9IHtcbiAgICAgICAgICAgIHVpZDogdGlsZS51aWQsXG4gICAgICAgICAgICBjb29yZDogdGlsZS5jb29yZCxcbiAgICAgICAgICAgIHpvb206IHRpbGUuY29vcmQueixcbiAgICAgICAgICAgIG1heFpvb206IHRoaXMubWF4em9vbSxcbiAgICAgICAgICAgIHRpbGVTaXplOiB0aGlzLnRpbGVTaXplLFxuICAgICAgICAgICAgc291cmNlOiB0aGlzLmlkLFxuICAgICAgICAgICAgb3ZlcnNjYWxpbmc6IG92ZXJzY2FsaW5nLFxuICAgICAgICAgICAgYW5nbGU6IHRoaXMubWFwLnRyYW5zZm9ybS5hbmdsZSxcbiAgICAgICAgICAgIHBpdGNoOiB0aGlzLm1hcC50cmFuc2Zvcm0ucGl0Y2gsXG4gICAgICAgICAgICBzaG93Q29sbGlzaW9uQm94ZXM6IHRoaXMubWFwLnNob3dDb2xsaXNpb25Cb3hlc1xuICAgICAgICB9O1xuXG4gICAgICAgIHRpbGUud29ya2VySUQgPSB0aGlzLmRpc3BhdGNoZXIuc2VuZCgnbG9hZCBnZW9qc29uIHRpbGUnLCBwYXJhbXMsIGZ1bmN0aW9uKGVyciwgZGF0YSkge1xuXG4gICAgICAgICAgICB0aWxlLnVubG9hZFZlY3RvckRhdGEodGhpcy5tYXAucGFpbnRlcik7XG5cbiAgICAgICAgICAgIGlmICh0aWxlLmFib3J0ZWQpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuXG4gICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5maXJlKCd0aWxlLmVycm9yJywge3RpbGU6IHRpbGV9KTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRpbGUubG9hZFZlY3RvckRhdGEoZGF0YSk7XG5cbiAgICAgICAgICAgIGlmICh0aWxlLnJlZG9XaGVuRG9uZSkge1xuICAgICAgICAgICAgICAgIHRpbGUucmVkb1doZW5Eb25lID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgdGlsZS5yZWRvUGxhY2VtZW50KHRoaXMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLmZpcmUoJ3RpbGUubG9hZCcsIHt0aWxlOiB0aWxlfSk7XG5cbiAgICAgICAgfS5iaW5kKHRoaXMpLCB0aGlzLndvcmtlcklEKTtcbiAgICB9LFxuXG4gICAgX2Fib3J0VGlsZTogZnVuY3Rpb24odGlsZSkge1xuICAgICAgICB0aWxlLmFib3J0ZWQgPSB0cnVlO1xuICAgIH0sXG5cbiAgICBfYWRkVGlsZTogZnVuY3Rpb24odGlsZSkge1xuICAgICAgICB0aGlzLmZpcmUoJ3RpbGUuYWRkJywge3RpbGU6IHRpbGV9KTtcbiAgICB9LFxuXG4gICAgX3JlbW92ZVRpbGU6IGZ1bmN0aW9uKHRpbGUpIHtcbiAgICAgICAgdGhpcy5maXJlKCd0aWxlLnJlbW92ZScsIHt0aWxlOiB0aWxlfSk7XG4gICAgfSxcblxuICAgIF91bmxvYWRUaWxlOiBmdW5jdGlvbih0aWxlKSB7XG4gICAgICAgIHRpbGUudW5sb2FkVmVjdG9yRGF0YSh0aGlzLm1hcC5wYWludGVyKTtcbiAgICAgICAgdGhpcy5kaXNwYXRjaGVyLnNlbmQoJ3JlbW92ZSB0aWxlJywgeyB1aWQ6IHRpbGUudWlkLCBzb3VyY2U6IHRoaXMuaWQgfSwgbnVsbCwgdGlsZS53b3JrZXJJRCk7XG4gICAgfSxcblxuICAgIHJlZG9QbGFjZW1lbnQ6IFNvdXJjZS5yZWRvUGxhY2VtZW50LFxuXG4gICAgX3JlZG9UaWxlUGxhY2VtZW50OiBmdW5jdGlvbih0aWxlKSB7XG4gICAgICAgIHRpbGUucmVkb1BsYWNlbWVudCh0aGlzKTtcbiAgICB9XG59KTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIFBvaW50ID0gcmVxdWlyZSgncG9pbnQtZ2VvbWV0cnknKTtcbnZhciBWZWN0b3JUaWxlRmVhdHVyZSA9IHJlcXVpcmUoJ3ZlY3Rvci10aWxlJykuVmVjdG9yVGlsZUZlYXR1cmU7XG52YXIgRVhURU5UID0gcmVxdWlyZSgnLi4vZGF0YS9idWNrZXQnKS5FWFRFTlQ7XG5cbm1vZHVsZS5leHBvcnRzID0gR2VvSlNPTldyYXBwZXI7XG5cbi8vIGNvbmZvcm0gdG8gdmVjdG9ydGlsZSBhcGlcbmZ1bmN0aW9uIEdlb0pTT05XcmFwcGVyKGZlYXR1cmVzKSB7XG4gICAgdGhpcy5mZWF0dXJlcyA9IGZlYXR1cmVzO1xuICAgIHRoaXMubGVuZ3RoID0gZmVhdHVyZXMubGVuZ3RoO1xuICAgIHRoaXMuZXh0ZW50ID0gRVhURU5UO1xufVxuXG5HZW9KU09OV3JhcHBlci5wcm90b3R5cGUuZmVhdHVyZSA9IGZ1bmN0aW9uKGkpIHtcbiAgICByZXR1cm4gbmV3IEZlYXR1cmVXcmFwcGVyKHRoaXMuZmVhdHVyZXNbaV0pO1xufTtcblxuZnVuY3Rpb24gRmVhdHVyZVdyYXBwZXIoZmVhdHVyZSkge1xuICAgIHRoaXMudHlwZSA9IGZlYXR1cmUudHlwZTtcbiAgICB0aGlzLnJhd0dlb21ldHJ5ID0gZmVhdHVyZS50eXBlID09PSAxID8gW2ZlYXR1cmUuZ2VvbWV0cnldIDogZmVhdHVyZS5nZW9tZXRyeTtcbiAgICB0aGlzLnByb3BlcnRpZXMgPSBmZWF0dXJlLnRhZ3M7XG4gICAgdGhpcy5leHRlbnQgPSBFWFRFTlQ7XG59XG5cbkZlYXR1cmVXcmFwcGVyLnByb3RvdHlwZS5sb2FkR2VvbWV0cnkgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgcmluZ3MgPSB0aGlzLnJhd0dlb21ldHJ5O1xuICAgIHRoaXMuZ2VvbWV0cnkgPSBbXTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmluZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHJpbmcgPSByaW5nc1tpXSxcbiAgICAgICAgICAgIG5ld1JpbmcgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCByaW5nLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICBuZXdSaW5nLnB1c2gobmV3IFBvaW50KHJpbmdbal1bMF0sIHJpbmdbal1bMV0pKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmdlb21ldHJ5LnB1c2gobmV3UmluZyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmdlb21ldHJ5O1xufTtcblxuRmVhdHVyZVdyYXBwZXIucHJvdG90eXBlLmJib3ggPSBmdW5jdGlvbigpIHtcbiAgICBpZiAoIXRoaXMuZ2VvbWV0cnkpIHRoaXMubG9hZEdlb21ldHJ5KCk7XG5cbiAgICB2YXIgcmluZ3MgPSB0aGlzLmdlb21ldHJ5LFxuICAgICAgICB4MSA9IEluZmluaXR5LFxuICAgICAgICB4MiA9IC1JbmZpbml0eSxcbiAgICAgICAgeTEgPSBJbmZpbml0eSxcbiAgICAgICAgeTIgPSAtSW5maW5pdHk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJpbmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciByaW5nID0gcmluZ3NbaV07XG5cbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCByaW5nLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICB2YXIgY29vcmQgPSByaW5nW2pdO1xuXG4gICAgICAgICAgICB4MSA9IE1hdGgubWluKHgxLCBjb29yZC54KTtcbiAgICAgICAgICAgIHgyID0gTWF0aC5tYXgoeDIsIGNvb3JkLngpO1xuICAgICAgICAgICAgeTEgPSBNYXRoLm1pbih5MSwgY29vcmQueSk7XG4gICAgICAgICAgICB5MiA9IE1hdGgubWF4KHkyLCBjb29yZC55KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBbeDEsIHkxLCB4MiwgeTJdO1xufTtcblxuRmVhdHVyZVdyYXBwZXIucHJvdG90eXBlLnRvR2VvSlNPTiA9IFZlY3RvclRpbGVGZWF0dXJlLnByb3RvdHlwZS50b0dlb0pTT047XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbC91dGlsJyk7XG52YXIgVGlsZSA9IHJlcXVpcmUoJy4vdGlsZScpO1xudmFyIFRpbGVDb29yZCA9IHJlcXVpcmUoJy4vdGlsZV9jb29yZCcpO1xudmFyIExuZ0xhdCA9IHJlcXVpcmUoJy4uL2dlby9sbmdfbGF0Jyk7XG52YXIgUG9pbnQgPSByZXF1aXJlKCdwb2ludC1nZW9tZXRyeScpO1xudmFyIEV2ZW50ZWQgPSByZXF1aXJlKCcuLi91dGlsL2V2ZW50ZWQnKTtcbnZhciBhamF4ID0gcmVxdWlyZSgnLi4vdXRpbC9hamF4Jyk7XG52YXIgRVhURU5UID0gcmVxdWlyZSgnLi4vZGF0YS9idWNrZXQnKS5FWFRFTlQ7XG5cbm1vZHVsZS5leHBvcnRzID0gSW1hZ2VTb3VyY2U7XG5cbi8qKlxuICogQ3JlYXRlIGFuIEltYWdlIHNvdXJjZSBpbnN0YW5jZSBnaXZlbiBhbiBvcHRpb25zIG9iamVjdFxuICogQGNsYXNzIEltYWdlU291cmNlXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy51cmwgQSBzdHJpbmcgVVJMIG9mIGFuIGltYWdlIGZpbGVcbiAqIEBwYXJhbSB7QXJyYXl9IG9wdGlvbnMuY29vcmRpbmF0ZXMgRm91ciBnZW9ncmFwaGljYWwgW2xuZywgbGF0XSBjb29yZGluYXRlcyBpbiBjbG9ja3dpc2Ugb3JkZXIgZGVmaW5pbmcgdGhlIGNvcm5lcnMgKHN0YXJ0aW5nIHdpdGggdG9wIGxlZnQpIG9mIHRoZSBpbWFnZS4gRG9lcyBub3QgaGF2ZSB0byBiZSBhIHJlY3RhbmdsZS5cbiAqIEBleGFtcGxlXG4gKiB2YXIgc291cmNlT2JqID0gbmV3IG1hcGJveGdsLkltYWdlU291cmNlKHtcbiAqICAgIHVybDogJ2h0dHBzOi8vd3d3Lm1hcGJveC5jb20vaW1hZ2VzL2Zvby5wbmcnLFxuICogICAgY29vcmRpbmF0ZXM6IFtcbiAqICAgICAgICBbLTc2LjU0MzM1NzM3MjI4Mzk0LCAzOS4xODU3OTkwNzIyOTc0OF0sXG4gKiAgICAgICAgWy03Ni41MjgwMzY1OTQzOTA4NywgMzkuMTgzODM2NDg0NzU4N10sXG4gKiAgICAgICAgWy03Ni41Mjk1Mzg2MzE0MzkyLCAzOS4xNzY4MzM5MjUwNzYwNl0sXG4gKiAgICAgICAgWy03Ni41NDUyMDI3MzIwODYxOCwgMzkuMTc4NzYzNDQxMDY2NDJdXG4gKiAgICBdXG4gKiB9KTtcbiAqIG1hcC5hZGRTb3VyY2UoJ3NvbWUgaWQnLCBzb3VyY2VPYmopOyAvLyBhZGRcbiAqIG1hcC5yZW1vdmVTb3VyY2UoJ3NvbWUgaWQnKTsgIC8vIHJlbW92ZVxuICovXG5mdW5jdGlvbiBJbWFnZVNvdXJjZShvcHRpb25zKSB7XG4gICAgdGhpcy51cmxzID0gb3B0aW9ucy51cmxzO1xuICAgIHRoaXMuY29vcmRpbmF0ZXMgPSBvcHRpb25zLmNvb3JkaW5hdGVzO1xuXG4gICAgYWpheC5nZXRJbWFnZShvcHRpb25zLnVybCwgZnVuY3Rpb24oZXJyLCBpbWFnZSkge1xuICAgICAgICAvLyBAVE9ETyBoYW5kbGUgZXJyb3JzIHZpYSBldmVudC5cbiAgICAgICAgaWYgKGVycikgcmV0dXJuO1xuXG4gICAgICAgIHRoaXMuaW1hZ2UgPSBpbWFnZTtcblxuICAgICAgICB0aGlzLmltYWdlLmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWQnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHRoaXMubWFwLl9yZXJlbmRlcigpO1xuICAgICAgICB9LmJpbmQodGhpcykpO1xuXG4gICAgICAgIHRoaXMuX2xvYWRlZCA9IHRydWU7XG5cbiAgICAgICAgaWYgKHRoaXMubWFwKSB7XG4gICAgICAgICAgICB0aGlzLnNldENvb3JkaW5hdGVzKG9wdGlvbnMuY29vcmRpbmF0ZXMpO1xuICAgICAgICB9XG4gICAgfS5iaW5kKHRoaXMpKTtcbn1cblxuSW1hZ2VTb3VyY2UucHJvdG90eXBlID0gdXRpbC5pbmhlcml0KEV2ZW50ZWQsIHtcbiAgICBvbkFkZDogZnVuY3Rpb24obWFwKSB7XG4gICAgICAgIHRoaXMubWFwID0gbWFwO1xuICAgICAgICBpZiAodGhpcy5pbWFnZSkge1xuICAgICAgICAgICAgdGhpcy5zZXRDb29yZGluYXRlcyh0aGlzLmNvb3JkaW5hdGVzKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgaW1hZ2UgY29vcmRpbmF0ZXMgYW5kIHJlcmVuZGVyIG1hcFxuICAgICAqXG4gICAgICogQHBhcmFtIHtBcnJheX0gY29vcmRpbmF0ZXMgRm91ciBnZW9ncmFwaGljYWwgW2xuZywgbGF0XSBjb29yZGluYXRlcyBpbiBjbG9ja3dpc2Ugb3JkZXIgZGVmaW5pbmcgdGhlIGNvcm5lcnMgKHN0YXJ0aW5nIHdpdGggdG9wIGxlZnQpIG9mIHRoZSBpbWFnZS4gRG9lcyBub3QgaGF2ZSB0byBiZSBhIHJlY3RhbmdsZS5cbiAgICAgKiBAcmV0dXJucyB7SW1hZ2VTb3VyY2V9IHRoaXNcbiAgICAgKi9cbiAgICBzZXRDb29yZGluYXRlczogZnVuY3Rpb24oY29vcmRpbmF0ZXMpIHtcbiAgICAgICAgdGhpcy5jb29yZGluYXRlcyA9IGNvb3JkaW5hdGVzO1xuXG4gICAgICAgIC8vIENhbGN1bGF0ZSB3aGljaCBtZXJjYXRvciB0aWxlIGlzIHN1aXRhYmxlIGZvciByZW5kZXJpbmcgdGhlIGltYWdlIGluXG4gICAgICAgIC8vIGFuZCBjcmVhdGUgYSBidWZmZXIgd2l0aCB0aGUgY29ybmVyIGNvb3JkaW5hdGVzLiBUaGVzZSBjb29yZGluYXRlc1xuICAgICAgICAvLyBtYXkgYmUgb3V0c2lkZSB0aGUgdGlsZSwgYmVjYXVzZSByYXN0ZXIgdGlsZXMgYXJlbid0IGNsaXBwZWQgd2hlbiByZW5kZXJpbmcuXG5cbiAgICAgICAgdmFyIG1hcCA9IHRoaXMubWFwO1xuICAgICAgICB2YXIgY29ybmVyWjBDb29yZHMgPSBjb29yZGluYXRlcy5tYXAoZnVuY3Rpb24oY29vcmQpIHtcbiAgICAgICAgICAgIHJldHVybiBtYXAudHJhbnNmb3JtLmxvY2F0aW9uQ29vcmRpbmF0ZShMbmdMYXQuY29udmVydChjb29yZCkpLnpvb21UbygwKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdmFyIGNlbnRlckNvb3JkID0gdGhpcy5jZW50ZXJDb29yZCA9IHV0aWwuZ2V0Q29vcmRpbmF0ZXNDZW50ZXIoY29ybmVyWjBDb29yZHMpO1xuICAgICAgICBjZW50ZXJDb29yZC5jb2x1bW4gPSBNYXRoLnJvdW5kKGNlbnRlckNvb3JkLmNvbHVtbik7XG4gICAgICAgIGNlbnRlckNvb3JkLnJvdyA9IE1hdGgucm91bmQoY2VudGVyQ29vcmQucm93KTtcblxuICAgICAgICB2YXIgdGlsZUNvb3JkcyA9IGNvcm5lclowQ29vcmRzLm1hcChmdW5jdGlvbihjb29yZCkge1xuICAgICAgICAgICAgdmFyIHpvb21lZENvb3JkID0gY29vcmQuem9vbVRvKGNlbnRlckNvb3JkLnpvb20pO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQb2ludChcbiAgICAgICAgICAgICAgICBNYXRoLnJvdW5kKCh6b29tZWRDb29yZC5jb2x1bW4gLSBjZW50ZXJDb29yZC5jb2x1bW4pICogRVhURU5UKSxcbiAgICAgICAgICAgICAgICBNYXRoLnJvdW5kKCh6b29tZWRDb29yZC5yb3cgLSBjZW50ZXJDb29yZC5yb3cpICogRVhURU5UKSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHZhciBnbCA9IG1hcC5wYWludGVyLmdsO1xuICAgICAgICB2YXIgbWF4SW50MTYgPSAzMjc2NztcbiAgICAgICAgdmFyIGFycmF5ID0gbmV3IEludDE2QXJyYXkoW1xuICAgICAgICAgICAgdGlsZUNvb3Jkc1swXS54LCB0aWxlQ29vcmRzWzBdLnksIDAsIDAsXG4gICAgICAgICAgICB0aWxlQ29vcmRzWzFdLngsIHRpbGVDb29yZHNbMV0ueSwgbWF4SW50MTYsIDAsXG4gICAgICAgICAgICB0aWxlQ29vcmRzWzNdLngsIHRpbGVDb29yZHNbM10ueSwgMCwgbWF4SW50MTYsXG4gICAgICAgICAgICB0aWxlQ29vcmRzWzJdLngsIHRpbGVDb29yZHNbMl0ueSwgbWF4SW50MTYsIG1heEludDE2XG4gICAgICAgIF0pO1xuXG4gICAgICAgIHRoaXMudGlsZSA9IG5ldyBUaWxlKG5ldyBUaWxlQ29vcmQoY2VudGVyQ29vcmQuem9vbSwgY2VudGVyQ29vcmQuY29sdW1uLCBjZW50ZXJDb29yZC5yb3cpKTtcbiAgICAgICAgdGhpcy50aWxlLmJ1Y2tldHMgPSB7fTtcblxuICAgICAgICB0aGlzLnRpbGUuYm91bmRzQnVmZmVyID0gZ2wuY3JlYXRlQnVmZmVyKCk7XG4gICAgICAgIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCB0aGlzLnRpbGUuYm91bmRzQnVmZmVyKTtcbiAgICAgICAgZ2wuYnVmZmVyRGF0YShnbC5BUlJBWV9CVUZGRVIsIGFycmF5LCBnbC5TVEFUSUNfRFJBVyk7XG5cbiAgICAgICAgdGhpcy5maXJlKCdjaGFuZ2UnKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgbG9hZGVkOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW1hZ2UgJiYgdGhpcy5pbWFnZS5jb21wbGV0ZTtcbiAgICB9LFxuXG4gICAgdXBkYXRlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgLy8gbm9vcFxuICAgIH0sXG5cbiAgICByZWxvYWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAvLyBub29wXG4gICAgfSxcblxuICAgIHByZXBhcmU6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoIXRoaXMuX2xvYWRlZCB8fCAhdGhpcy5sb2FkZWQoKSkgcmV0dXJuO1xuXG4gICAgICAgIHZhciBwYWludGVyID0gdGhpcy5tYXAucGFpbnRlcjtcbiAgICAgICAgdmFyIGdsID0gcGFpbnRlci5nbDtcblxuICAgICAgICBpZiAoIXRoaXMudGlsZS50ZXh0dXJlKSB7XG4gICAgICAgICAgICB0aGlzLnRpbGUudGV4dHVyZSA9IGdsLmNyZWF0ZVRleHR1cmUoKTtcbiAgICAgICAgICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRoaXMudGlsZS50ZXh0dXJlKTtcbiAgICAgICAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1MsIGdsLkNMQU1QX1RPX0VER0UpO1xuICAgICAgICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfVCwgZ2wuQ0xBTVBfVE9fRURHRSk7XG4gICAgICAgICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUlOX0ZJTFRFUiwgZ2wuTElORUFSKTtcbiAgICAgICAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NQUdfRklMVEVSLCBnbC5MSU5FQVIpO1xuICAgICAgICAgICAgZ2wudGV4SW1hZ2UyRChnbC5URVhUVVJFXzJELCAwLCBnbC5SR0JBLCBnbC5SR0JBLCBnbC5VTlNJR05FRF9CWVRFLCB0aGlzLmltYWdlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRoaXMudGlsZS50ZXh0dXJlKTtcbiAgICAgICAgICAgIGdsLnRleFN1YkltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgMCwgMCwgMCwgZ2wuUkdCQSwgZ2wuVU5TSUdORURfQllURSwgdGhpcy5pbWFnZSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgZ2V0VmlzaWJsZUNvb3JkaW5hdGVzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMudGlsZSkgcmV0dXJuIFt0aGlzLnRpbGUuY29vcmRdO1xuICAgICAgICBlbHNlIHJldHVybiBbXTtcbiAgICB9LFxuXG4gICAgZ2V0VGlsZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRpbGU7XG4gICAgfSxcblxuICAgIHNlcmlhbGl6ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiAnaW1hZ2UnLFxuICAgICAgICAgICAgdXJsczogdGhpcy51cmxzLFxuICAgICAgICAgICAgY29vcmRpbmF0ZXM6IHRoaXMuY29vcmRpbmF0ZXNcbiAgICAgICAgfTtcbiAgICB9XG59KTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIEJ1Y2tldCA9IHJlcXVpcmUoJy4uL2RhdGEvYnVja2V0Jyk7XG5cbi8qKlxuICogQ29udmVydHMgYSBwaXhlbCB2YWx1ZSBhdCBhIHRoZSBnaXZlbiB6b29tIGxldmVsIHRvIHRpbGUgdW5pdHMuXG4gKlxuICogVGhlIHNoYWRlcnMgbW9zdGx5IGNhbGN1bGF0ZSBldmVyeXRoaW5nIGluIHRpbGUgdW5pdHMgc28gc3R5bGVcbiAqIHByb3BlcnRpZXMgbmVlZCB0byBiZSBjb252ZXJ0ZWQgZnJvbSBwaXhlbHMgdG8gdGlsZSB1bml0cyB1c2luZyB0aGlzLlxuICpcbiAqIEZvciBleGFtcGxlLCBhIHRyYW5zbGF0aW9uIGJ5IDMwIHBpeGVscyBhdCB6b29tIDYuNSB3aWxsIGJlIGFcbiAqIHRyYW5zbGF0aW9uIGJ5IHBpeGVsc1RvVGlsZVVuaXRzKDMwLCA2LjUpIHRpbGUgdW5pdHMuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IHRpbGUgYSB7VGlsZSBvYmplY3R9IHdpbGwgd29yayB3ZWxsLCBidXQgYW55IG9iamVjdCB0aGF0IGZvbGxvd3MgdGhlIGZvcm1hdCB7Y29vcmQ6IHtUaWxlQ29yZCBvYmplY3R9LCB0aWxlU2l6ZToge251bWJlcn19IHdpbGwgd29ya1xuICogQHBhcmFtIHtudW1iZXJ9IHBpeGVsVmFsdWVcbiAqIEBwYXJhbSB7bnVtYmVyfSB6XG4gKiBAcmV0dXJucyB7bnVtYmVyfSB2YWx1ZSBpbiB0aWxlIHVuaXRzXG4gKiBAcHJpdmF0ZVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHRpbGUsIHBpeGVsVmFsdWUsIHopIHtcbiAgICByZXR1cm4gcGl4ZWxWYWx1ZSAqIChCdWNrZXQuRVhURU5UIC8gKHRpbGUudGlsZVNpemUgKiBNYXRoLnBvdygyLCB6IC0gdGlsZS5jb29yZC56KSkpO1xufTtcblxuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwvdXRpbCcpO1xudmFyIGFqYXggPSByZXF1aXJlKCcuLi91dGlsL2FqYXgnKTtcbnZhciBFdmVudGVkID0gcmVxdWlyZSgnLi4vdXRpbC9ldmVudGVkJyk7XG52YXIgU291cmNlID0gcmVxdWlyZSgnLi9zb3VyY2UnKTtcbnZhciBub3JtYWxpemVVUkwgPSByZXF1aXJlKCcuLi91dGlsL21hcGJveCcpLm5vcm1hbGl6ZVRpbGVVUkw7XG5cbm1vZHVsZS5leHBvcnRzID0gUmFzdGVyVGlsZVNvdXJjZTtcblxuZnVuY3Rpb24gUmFzdGVyVGlsZVNvdXJjZShvcHRpb25zKSB7XG4gICAgdXRpbC5leHRlbmQodGhpcywgdXRpbC5waWNrKG9wdGlvbnMsIFsndXJsJywgJ3RpbGVTaXplJ10pKTtcblxuICAgIFNvdXJjZS5fbG9hZFRpbGVKU09OLmNhbGwodGhpcywgb3B0aW9ucyk7XG59XG5cblJhc3RlclRpbGVTb3VyY2UucHJvdG90eXBlID0gdXRpbC5pbmhlcml0KEV2ZW50ZWQsIHtcbiAgICBtaW56b29tOiAwLFxuICAgIG1heHpvb206IDIyLFxuICAgIHJvdW5kWm9vbTogdHJ1ZSxcbiAgICB0aWxlU2l6ZTogNTEyLFxuICAgIF9sb2FkZWQ6IGZhbHNlLFxuXG4gICAgb25BZGQ6IGZ1bmN0aW9uKG1hcCkge1xuICAgICAgICB0aGlzLm1hcCA9IG1hcDtcbiAgICB9LFxuXG4gICAgbG9hZGVkOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3B5cmFtaWQgJiYgdGhpcy5fcHlyYW1pZC5sb2FkZWQoKTtcbiAgICB9LFxuXG4gICAgdXBkYXRlOiBmdW5jdGlvbih0cmFuc2Zvcm0pIHtcbiAgICAgICAgaWYgKHRoaXMuX3B5cmFtaWQpIHtcbiAgICAgICAgICAgIHRoaXMuX3B5cmFtaWQudXBkYXRlKHRoaXMudXNlZCwgdHJhbnNmb3JtLCB0aGlzLm1hcC5zdHlsZS5yYXN0ZXJGYWRlRHVyYXRpb24pO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIHJlbG9hZDogZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vIG5vb3BcbiAgICB9LFxuXG4gICAgc2VyaWFsaXplOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6ICdyYXN0ZXInLFxuICAgICAgICAgICAgdXJsOiB0aGlzLnVybCxcbiAgICAgICAgICAgIHRpbGVTaXplOiB0aGlzLnRpbGVTaXplXG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIGdldFZpc2libGVDb29yZGluYXRlczogU291cmNlLl9nZXRWaXNpYmxlQ29vcmRpbmF0ZXMsXG4gICAgZ2V0VGlsZTogU291cmNlLl9nZXRUaWxlLFxuXG4gICAgX2xvYWRUaWxlOiBmdW5jdGlvbih0aWxlKSB7XG4gICAgICAgIHZhciB1cmwgPSBub3JtYWxpemVVUkwodGlsZS5jb29yZC51cmwodGhpcy50aWxlcyksIHRoaXMudXJsLCB0aGlzLnRpbGVTaXplKTtcblxuICAgICAgICB0aWxlLnJlcXVlc3QgPSBhamF4LmdldEltYWdlKHVybCwgZG9uZS5iaW5kKHRoaXMpKTtcblxuICAgICAgICBmdW5jdGlvbiBkb25lKGVyciwgaW1nKSB7XG4gICAgICAgICAgICBkZWxldGUgdGlsZS5yZXF1ZXN0O1xuXG4gICAgICAgICAgICBpZiAodGlsZS5hYm9ydGVkKVxuICAgICAgICAgICAgICAgIHJldHVybjtcblxuICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgIHRpbGUuZXJyb3JlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy5maXJlKCd0aWxlLmVycm9yJywge3RpbGU6IHRpbGUsIGVycm9yOiBlcnJ9KTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBnbCA9IHRoaXMubWFwLnBhaW50ZXIuZ2w7XG4gICAgICAgICAgICB0aWxlLnRleHR1cmUgPSB0aGlzLm1hcC5wYWludGVyLmdldFRleHR1cmUoaW1nLndpZHRoKTtcbiAgICAgICAgICAgIGlmICh0aWxlLnRleHR1cmUpIHtcbiAgICAgICAgICAgICAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0aWxlLnRleHR1cmUpO1xuICAgICAgICAgICAgICAgIGdsLnRleFN1YkltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgMCwgMCwgMCwgZ2wuUkdCQSwgZ2wuVU5TSUdORURfQllURSwgaW1nKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGlsZS50ZXh0dXJlID0gZ2wuY3JlYXRlVGV4dHVyZSgpO1xuICAgICAgICAgICAgICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRpbGUudGV4dHVyZSk7XG4gICAgICAgICAgICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01JTl9GSUxURVIsIGdsLkxJTkVBUl9NSVBNQVBfTkVBUkVTVCk7XG4gICAgICAgICAgICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01BR19GSUxURVIsIGdsLkxJTkVBUik7XG4gICAgICAgICAgICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfUywgZ2wuQ0xBTVBfVE9fRURHRSk7XG4gICAgICAgICAgICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfVCwgZ2wuQ0xBTVBfVE9fRURHRSk7XG4gICAgICAgICAgICAgICAgZ2wucGl4ZWxTdG9yZWkoZ2wuVU5QQUNLX1BSRU1VTFRJUExZX0FMUEhBX1dFQkdMLCB0cnVlKTtcbiAgICAgICAgICAgICAgICBnbC50ZXhJbWFnZTJEKGdsLlRFWFRVUkVfMkQsIDAsIGdsLlJHQkEsIGdsLlJHQkEsIGdsLlVOU0lHTkVEX0JZVEUsIGltZyk7XG4gICAgICAgICAgICAgICAgdGlsZS50ZXh0dXJlLnNpemUgPSBpbWcud2lkdGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBnbC5nZW5lcmF0ZU1pcG1hcChnbC5URVhUVVJFXzJEKTtcblxuICAgICAgICAgICAgdGlsZS50aW1lQWRkZWQgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICAgICAgICAgIHRoaXMubWFwLmFuaW1hdGlvbkxvb3Auc2V0KHRoaXMuc3R5bGUucmFzdGVyRmFkZUR1cmF0aW9uKTtcblxuICAgICAgICAgICAgdGlsZS5zb3VyY2UgPSB0aGlzO1xuICAgICAgICAgICAgdGlsZS5sb2FkZWQgPSB0cnVlO1xuXG4gICAgICAgICAgICB0aGlzLmZpcmUoJ3RpbGUubG9hZCcsIHt0aWxlOiB0aWxlfSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgX2Fib3J0VGlsZTogZnVuY3Rpb24odGlsZSkge1xuICAgICAgICB0aWxlLmFib3J0ZWQgPSB0cnVlO1xuXG4gICAgICAgIGlmICh0aWxlLnJlcXVlc3QpIHtcbiAgICAgICAgICAgIHRpbGUucmVxdWVzdC5hYm9ydCgpO1xuICAgICAgICAgICAgZGVsZXRlIHRpbGUucmVxdWVzdDtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBfYWRkVGlsZTogZnVuY3Rpb24odGlsZSkge1xuICAgICAgICB0aGlzLmZpcmUoJ3RpbGUuYWRkJywge3RpbGU6IHRpbGV9KTtcbiAgICB9LFxuXG4gICAgX3JlbW92ZVRpbGU6IGZ1bmN0aW9uKHRpbGUpIHtcbiAgICAgICAgdGhpcy5maXJlKCd0aWxlLnJlbW92ZScsIHt0aWxlOiB0aWxlfSk7XG4gICAgfSxcblxuICAgIF91bmxvYWRUaWxlOiBmdW5jdGlvbih0aWxlKSB7XG4gICAgICAgIGlmICh0aWxlLnRleHR1cmUpIHRoaXMubWFwLnBhaW50ZXIuc2F2ZVRleHR1cmUodGlsZS50ZXh0dXJlKTtcbiAgICB9XG59KTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsL3V0aWwnKTtcbnZhciBhamF4ID0gcmVxdWlyZSgnLi4vdXRpbC9hamF4Jyk7XG52YXIgYnJvd3NlciA9IHJlcXVpcmUoJy4uL3V0aWwvYnJvd3NlcicpO1xudmFyIFRpbGVQeXJhbWlkID0gcmVxdWlyZSgnLi90aWxlX3B5cmFtaWQnKTtcbnZhciBub3JtYWxpemVVUkwgPSByZXF1aXJlKCcuLi91dGlsL21hcGJveCcpLm5vcm1hbGl6ZVNvdXJjZVVSTDtcbnZhciBUaWxlQ29vcmQgPSByZXF1aXJlKCcuL3RpbGVfY29vcmQnKTtcblxuZXhwb3J0cy5fbG9hZFRpbGVKU09OID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIHZhciBsb2FkZWQgPSBmdW5jdGlvbihlcnIsIHRpbGVKU09OKSB7XG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgIHRoaXMuZmlyZSgnZXJyb3InLCB7ZXJyb3I6IGVycn0pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdXRpbC5leHRlbmQodGhpcywgdXRpbC5waWNrKHRpbGVKU09OLFxuICAgICAgICAgICAgWyd0aWxlcycsICdtaW56b29tJywgJ21heHpvb20nLCAnYXR0cmlidXRpb24nXSkpO1xuXG4gICAgICAgIGlmICh0aWxlSlNPTi52ZWN0b3JfbGF5ZXJzKSB7XG4gICAgICAgICAgICB0aGlzLnZlY3RvckxheWVycyA9IHRpbGVKU09OLnZlY3Rvcl9sYXllcnM7XG4gICAgICAgICAgICB0aGlzLnZlY3RvckxheWVySWRzID0gdGhpcy52ZWN0b3JMYXllcnMubWFwKGZ1bmN0aW9uKGxheWVyKSB7IHJldHVybiBsYXllci5pZDsgfSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9weXJhbWlkID0gbmV3IFRpbGVQeXJhbWlkKHtcbiAgICAgICAgICAgIHRpbGVTaXplOiB0aGlzLnRpbGVTaXplLFxuICAgICAgICAgICAgbWluem9vbTogdGhpcy5taW56b29tLFxuICAgICAgICAgICAgbWF4em9vbTogdGhpcy5tYXh6b29tLFxuICAgICAgICAgICAgcm91bmRab29tOiB0aGlzLnJvdW5kWm9vbSxcbiAgICAgICAgICAgIHJlcGFyc2VPdmVyc2NhbGVkOiB0aGlzLnJlcGFyc2VPdmVyc2NhbGVkLFxuICAgICAgICAgICAgbG9hZDogdGhpcy5fbG9hZFRpbGUuYmluZCh0aGlzKSxcbiAgICAgICAgICAgIGFib3J0OiB0aGlzLl9hYm9ydFRpbGUuYmluZCh0aGlzKSxcbiAgICAgICAgICAgIHVubG9hZDogdGhpcy5fdW5sb2FkVGlsZS5iaW5kKHRoaXMpLFxuICAgICAgICAgICAgYWRkOiB0aGlzLl9hZGRUaWxlLmJpbmQodGhpcyksXG4gICAgICAgICAgICByZW1vdmU6IHRoaXMuX3JlbW92ZVRpbGUuYmluZCh0aGlzKSxcbiAgICAgICAgICAgIHJlZG9QbGFjZW1lbnQ6IHRoaXMuX3JlZG9UaWxlUGxhY2VtZW50ID8gdGhpcy5fcmVkb1RpbGVQbGFjZW1lbnQuYmluZCh0aGlzKSA6IHVuZGVmaW5lZFxuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLmZpcmUoJ2xvYWQnKTtcbiAgICB9LmJpbmQodGhpcyk7XG5cbiAgICBpZiAob3B0aW9ucy51cmwpIHtcbiAgICAgICAgYWpheC5nZXRKU09OKG5vcm1hbGl6ZVVSTChvcHRpb25zLnVybCksIGxvYWRlZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgYnJvd3Nlci5mcmFtZShsb2FkZWQuYmluZCh0aGlzLCBudWxsLCBvcHRpb25zKSk7XG4gICAgfVxufTtcblxuZXhwb3J0cy5yZWRvUGxhY2VtZW50ID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKCF0aGlzLl9weXJhbWlkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgaWRzID0gdGhpcy5fcHlyYW1pZC5vcmRlcmVkSURzKCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHRpbGUgPSB0aGlzLl9weXJhbWlkLmdldFRpbGUoaWRzW2ldKTtcbiAgICAgICAgdGhpcy5fcmVkb1RpbGVQbGFjZW1lbnQodGlsZSk7XG4gICAgfVxufTtcblxuZXhwb3J0cy5fZ2V0VGlsZSA9IGZ1bmN0aW9uKGNvb3JkKSB7XG4gICAgcmV0dXJuIHRoaXMuX3B5cmFtaWQuZ2V0VGlsZShjb29yZC5pZCk7XG59O1xuXG5leHBvcnRzLl9nZXRWaXNpYmxlQ29vcmRpbmF0ZXMgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAoIXRoaXMuX3B5cmFtaWQpIHJldHVybiBbXTtcbiAgICBlbHNlIHJldHVybiB0aGlzLl9weXJhbWlkLnJlbmRlcmVkSURzKCkubWFwKFRpbGVDb29yZC5mcm9tSUQpO1xufTtcblxuZnVuY3Rpb24gc29ydFRpbGVzSW4oYSwgYikge1xuICAgIHZhciBjb29yZEEgPSBhLnRpbGUuY29vcmQ7XG4gICAgdmFyIGNvb3JkQiA9IGIudGlsZS5jb29yZDtcbiAgICByZXR1cm4gKGNvb3JkQS56IC0gY29vcmRCLnopIHx8IChjb29yZEEueSAtIGNvb3JkQi55KSB8fCAoY29vcmRBLnggLSBjb29yZEIueCk7XG59XG5cbmZ1bmN0aW9uIG1lcmdlUmVuZGVyZWRGZWF0dXJlTGF5ZXJzKHRpbGVzKSB7XG4gICAgdmFyIHJlc3VsdCA9IHRpbGVzWzBdIHx8IHt9O1xuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgdGlsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHRpbGUgPSB0aWxlc1tpXTtcbiAgICAgICAgZm9yICh2YXIgbGF5ZXJJRCBpbiB0aWxlKSB7XG4gICAgICAgICAgICB2YXIgdGlsZUZlYXR1cmVzID0gdGlsZVtsYXllcklEXTtcbiAgICAgICAgICAgIHZhciByZXN1bHRGZWF0dXJlcyA9IHJlc3VsdFtsYXllcklEXTtcbiAgICAgICAgICAgIGlmIChyZXN1bHRGZWF0dXJlcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0RmVhdHVyZXMgPSByZXN1bHRbbGF5ZXJJRF0gPSB0aWxlRmVhdHVyZXM7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGYgPSAwOyBmIDwgdGlsZUZlYXR1cmVzLmxlbmd0aDsgZisrKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdEZlYXR1cmVzLnB1c2godGlsZUZlYXR1cmVzW2ZdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZXhwb3J0cy5fcXVlcnlSZW5kZXJlZFZlY3RvckZlYXR1cmVzID0gZnVuY3Rpb24ocXVlcnlHZW9tZXRyeSwgcGFyYW1zLCBjbGFzc2VzLCB6b29tLCBiZWFyaW5nKSB7XG4gICAgaWYgKCF0aGlzLl9weXJhbWlkKVxuICAgICAgICByZXR1cm4ge307XG5cbiAgICB2YXIgdGlsZXNJbiA9IHRoaXMuX3B5cmFtaWQudGlsZXNJbihxdWVyeUdlb21ldHJ5KTtcblxuICAgIHRpbGVzSW4uc29ydChzb3J0VGlsZXNJbik7XG5cbiAgICB2YXIgc3R5bGVMYXllcnMgPSB0aGlzLm1hcC5zdHlsZS5fbGF5ZXJzO1xuXG4gICAgdmFyIHJlbmRlcmVkRmVhdHVyZUxheWVycyA9IFtdO1xuICAgIGZvciAodmFyIHIgPSAwOyByIDwgdGlsZXNJbi5sZW5ndGg7IHIrKykge1xuICAgICAgICB2YXIgdGlsZUluID0gdGlsZXNJbltyXTtcbiAgICAgICAgaWYgKCF0aWxlSW4udGlsZS5mZWF0dXJlSW5kZXgpIGNvbnRpbnVlO1xuXG4gICAgICAgIHJlbmRlcmVkRmVhdHVyZUxheWVycy5wdXNoKHRpbGVJbi50aWxlLmZlYXR1cmVJbmRleC5xdWVyeSh7XG4gICAgICAgICAgICBxdWVyeUdlb21ldHJ5OiB0aWxlSW4ucXVlcnlHZW9tZXRyeSxcbiAgICAgICAgICAgIHNjYWxlOiB0aWxlSW4uc2NhbGUsXG4gICAgICAgICAgICB0aWxlU2l6ZTogdGlsZUluLnRpbGUudGlsZVNpemUsXG4gICAgICAgICAgICBiZWFyaW5nOiBiZWFyaW5nLFxuICAgICAgICAgICAgcGFyYW1zOiBwYXJhbXNcbiAgICAgICAgfSwgc3R5bGVMYXllcnMpKTtcbiAgICB9XG4gICAgcmV0dXJuIG1lcmdlUmVuZGVyZWRGZWF0dXJlTGF5ZXJzKHJlbmRlcmVkRmVhdHVyZUxheWVycyk7XG59O1xuXG5leHBvcnRzLl9xdWVyeVNvdXJjZUZlYXR1cmVzID0gZnVuY3Rpb24ocGFyYW1zKSB7XG4gICAgaWYgKCF0aGlzLl9weXJhbWlkKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG5cbiAgICB2YXIgcHlyYW1pZCA9IHRoaXMuX3B5cmFtaWQ7XG4gICAgdmFyIHRpbGVzID0gcHlyYW1pZC5yZW5kZXJlZElEcygpLm1hcChmdW5jdGlvbihpZCkge1xuICAgICAgICByZXR1cm4gcHlyYW1pZC5nZXRUaWxlKGlkKTtcbiAgICB9KTtcblxuICAgIHZhciByZXN1bHQgPSBbXTtcblxuICAgIHZhciBkYXRhVGlsZXMgPSB7fTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRpbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciB0aWxlID0gdGlsZXNbaV07XG4gICAgICAgIHZhciBkYXRhSUQgPSBuZXcgVGlsZUNvb3JkKE1hdGgubWluKHRpbGUuc291cmNlTWF4Wm9vbSwgdGlsZS5jb29yZC56KSwgdGlsZS5jb29yZC54LCB0aWxlLmNvb3JkLnksIDApLmlkO1xuICAgICAgICBpZiAoIWRhdGFUaWxlc1tkYXRhSURdKSB7XG4gICAgICAgICAgICBkYXRhVGlsZXNbZGF0YUlEXSA9IHRydWU7XG4gICAgICAgICAgICB0aWxlLnF1ZXJ5U291cmNlRmVhdHVyZXMocmVzdWx0LCBwYXJhbXMpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qXG4gKiBDcmVhdGUgYSB0aWxlZCBkYXRhIHNvdXJjZSBpbnN0YW5jZSBnaXZlbiBhbiBvcHRpb25zIG9iamVjdFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy50eXBlIEVpdGhlciBgcmFzdGVyYCBvciBgdmVjdG9yYC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLnVybCBBIHRpbGUgc291cmNlIFVSTC4gVGhpcyBzaG91bGQgZWl0aGVyIGJlIGBtYXBib3g6Ly97bWFwaWR9YCBvciBhIGZ1bGwgYGh0dHBbc11gIHVybCB0aGF0IHBvaW50cyB0byBhIFRpbGVKU09OIGVuZHBvaW50LlxuICogQHBhcmFtIHtBcnJheX0gb3B0aW9ucy50aWxlcyBBbiBhcnJheSBvZiB0aWxlIHNvdXJjZXMuIElmIGB1cmxgIGlzIG5vdCBzcGVjaWZpZWQsIGB0aWxlc2AgY2FuIGJlIHVzZWQgaW5zdGVhZCB0byBzcGVjaWZ5IHRpbGUgc291cmNlcywgYXMgaW4gdGhlIFRpbGVKU09OIHNwZWMuIE90aGVyIFRpbGVKU09OIGtleXMgc3VjaCBhcyBgbWluem9vbWAgYW5kIGBtYXh6b29tYCBjYW4gYmUgc3BlY2lmaWVkIGluIGEgc291cmNlIG9iamVjdCBpZiBgdGlsZXNgIGlzIHVzZWQuXG4gKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy5pZCBBbiBvcHRpb25hbCBgaWRgIHRvIGFzc2lnbiB0byB0aGUgc291cmNlXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMudGlsZVNpemU9NTEyXSBPcHRpb25hbCB0aWxlIHNpemUgKHdpZHRoIGFuZCBoZWlnaHQgaW4gcGl4ZWxzLCBhc3N1bWluZyB0aWxlcyBhcmUgc3F1YXJlKS4gVGhpcyBvcHRpb24gaXMgb25seSBjb25maWd1cmFibGUgZm9yIHJhc3RlciBzb3VyY2VzXG4gKiBAZXhhbXBsZVxuICogdmFyIHNvdXJjZU9iaiA9IG5ldyBtYXBib3hnbC5Tb3VyY2UuY3JlYXRlKHtcbiAqICAgIHR5cGU6ICd2ZWN0b3InLFxuICogICAgdXJsOiAnbWFwYm94Oi8vbWFwYm94Lm1hcGJveC1zdHJlZXRzLXY1J1xuICogfSk7XG4gKiBtYXAuYWRkU291cmNlKCdzb21lIGlkJywgc291cmNlT2JqKTsgLy8gYWRkXG4gKiBtYXAucmVtb3ZlU291cmNlKCdzb21lIGlkJyk7ICAvLyByZW1vdmVcbiAqL1xuZXhwb3J0cy5jcmVhdGUgPSBmdW5jdGlvbihzb3VyY2UpIHtcbiAgICAvLyBUaGlzIGlzIG5vdCBhdCBmaWxlIHNjb3BlIGluIG9yZGVyIHRvIGF2b2lkIGEgY2lyY3VsYXIgcmVxdWlyZS5cbiAgICB2YXIgc291cmNlcyA9IHtcbiAgICAgICAgdmVjdG9yOiByZXF1aXJlKCcuL3ZlY3Rvcl90aWxlX3NvdXJjZScpLFxuICAgICAgICByYXN0ZXI6IHJlcXVpcmUoJy4vcmFzdGVyX3RpbGVfc291cmNlJyksXG4gICAgICAgIGdlb2pzb246IHJlcXVpcmUoJy4vZ2VvanNvbl9zb3VyY2UnKSxcbiAgICAgICAgdmlkZW86IHJlcXVpcmUoJy4vdmlkZW9fc291cmNlJyksXG4gICAgICAgIGltYWdlOiByZXF1aXJlKCcuL2ltYWdlX3NvdXJjZScpXG4gICAgfTtcblxuICAgIHJldHVybiBleHBvcnRzLmlzKHNvdXJjZSkgPyBzb3VyY2UgOiBuZXcgc291cmNlc1tzb3VyY2UudHlwZV0oc291cmNlKTtcbn07XG5cbmV4cG9ydHMuaXMgPSBmdW5jdGlvbihzb3VyY2UpIHtcbiAgICAvLyBUaGlzIGlzIG5vdCBhdCBmaWxlIHNjb3BlIGluIG9yZGVyIHRvIGF2b2lkIGEgY2lyY3VsYXIgcmVxdWlyZS5cbiAgICB2YXIgc291cmNlcyA9IHtcbiAgICAgICAgdmVjdG9yOiByZXF1aXJlKCcuL3ZlY3Rvcl90aWxlX3NvdXJjZScpLFxuICAgICAgICByYXN0ZXI6IHJlcXVpcmUoJy4vcmFzdGVyX3RpbGVfc291cmNlJyksXG4gICAgICAgIGdlb2pzb246IHJlcXVpcmUoJy4vZ2VvanNvbl9zb3VyY2UnKSxcbiAgICAgICAgdmlkZW86IHJlcXVpcmUoJy4vdmlkZW9fc291cmNlJyksXG4gICAgICAgIGltYWdlOiByZXF1aXJlKCcuL2ltYWdlX3NvdXJjZScpXG4gICAgfTtcblxuICAgIGZvciAodmFyIHR5cGUgaW4gc291cmNlcykge1xuICAgICAgICBpZiAoc291cmNlIGluc3RhbmNlb2Ygc291cmNlc1t0eXBlXSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwvdXRpbCcpO1xudmFyIEJ1Y2tldCA9IHJlcXVpcmUoJy4uL2RhdGEvYnVja2V0Jyk7XG52YXIgRmVhdHVyZUluZGV4ID0gcmVxdWlyZSgnLi4vZGF0YS9mZWF0dXJlX2luZGV4Jyk7XG52YXIgdnQgPSByZXF1aXJlKCd2ZWN0b3ItdGlsZScpO1xudmFyIFByb3RvYnVmID0gcmVxdWlyZSgncGJmJyk7XG52YXIgR2VvSlNPTkZlYXR1cmUgPSByZXF1aXJlKCcuLi91dGlsL3ZlY3RvcnRpbGVfdG9fZ2VvanNvbicpO1xudmFyIGZlYXR1cmVGaWx0ZXIgPSByZXF1aXJlKCdmZWF0dXJlLWZpbHRlcicpO1xudmFyIENvbGxpc2lvblRpbGUgPSByZXF1aXJlKCcuLi9zeW1ib2wvY29sbGlzaW9uX3RpbGUnKTtcbnZhciBDb2xsaXNpb25Cb3hBcnJheSA9IHJlcXVpcmUoJy4uL3N5bWJvbC9jb2xsaXNpb25fYm94Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0gVGlsZTtcblxuLyoqXG4gKiBBIHRpbGUgb2JqZWN0IGlzIHRoZSBjb21iaW5hdGlvbiBvZiBhIENvb3JkaW5hdGUsIHdoaWNoIGRlZmluZXNcbiAqIGl0cyBwbGFjZSwgYXMgd2VsbCBhcyBhIHVuaXF1ZSBJRCBhbmQgZGF0YSB0cmFja2luZyBmb3IgaXRzIGNvbnRlbnRcbiAqXG4gKiBAcGFyYW0ge0Nvb3JkaW5hdGV9IGNvb3JkXG4gKiBAcGFyYW0ge251bWJlcn0gc2l6ZVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gVGlsZShjb29yZCwgc2l6ZSwgc291cmNlTWF4Wm9vbSkge1xuICAgIHRoaXMuY29vcmQgPSBjb29yZDtcbiAgICB0aGlzLnVpZCA9IHV0aWwudW5pcXVlSWQoKTtcbiAgICB0aGlzLmxvYWRlZCA9IGZhbHNlOyAvLyBUT0RPIHJlbmFtZSBsb2FkZWRcbiAgICB0aGlzLmlzVW5sb2FkZWQgPSBmYWxzZTtcbiAgICB0aGlzLnVzZXMgPSAwO1xuICAgIHRoaXMudGlsZVNpemUgPSBzaXplO1xuICAgIHRoaXMuc291cmNlTWF4Wm9vbSA9IHNvdXJjZU1heFpvb207XG4gICAgdGhpcy5idWNrZXRzID0ge307XG59XG5cblRpbGUucHJvdG90eXBlID0ge1xuXG4gICAgLyoqXG4gICAgICogR2l2ZW4gYSBkYXRhIG9iamVjdCB3aXRoIGEgJ2J1ZmZlcnMnIHByb3BlcnR5LCBsb2FkIGl0IGludG9cbiAgICAgKiB0aGlzIHRpbGUncyBlbGVtZW50R3JvdXBzIGFuZCBidWZmZXJzIHByb3BlcnRpZXMgYW5kIHNldCBsb2FkZWRcbiAgICAgKiB0byB0cnVlLiBJZiB0aGUgZGF0YSBpcyBudWxsLCBsaWtlIGluIHRoZSBjYXNlIG9mIGFuIGVtcHR5XG4gICAgICogR2VvSlNPTiB0aWxlLCBuby1vcCBidXQgc3RpbGwgc2V0IGxvYWRlZCB0byB0cnVlLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGxvYWRWZWN0b3JEYXRhOiBmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgIHRoaXMubG9hZGVkID0gdHJ1ZTtcblxuICAgICAgICAvLyBlbXB0eSBHZW9KU09OIHRpbGVcbiAgICAgICAgaWYgKCFkYXRhKSByZXR1cm47XG5cbiAgICAgICAgdGhpcy5jb2xsaXNpb25Cb3hBcnJheSA9IG5ldyBDb2xsaXNpb25Cb3hBcnJheShkYXRhLmNvbGxpc2lvbkJveEFycmF5KTtcbiAgICAgICAgdGhpcy5jb2xsaXNpb25UaWxlID0gbmV3IENvbGxpc2lvblRpbGUoZGF0YS5jb2xsaXNpb25UaWxlLCB0aGlzLmNvbGxpc2lvbkJveEFycmF5KTtcbiAgICAgICAgdGhpcy5mZWF0dXJlSW5kZXggPSBuZXcgRmVhdHVyZUluZGV4KGRhdGEuZmVhdHVyZUluZGV4LCBkYXRhLnJhd1RpbGVEYXRhLCB0aGlzLmNvbGxpc2lvblRpbGUpO1xuICAgICAgICB0aGlzLnJhd1RpbGVEYXRhID0gZGF0YS5yYXdUaWxlRGF0YTtcbiAgICAgICAgdGhpcy5idWNrZXRzID0gdW5zZXJpYWxpemVCdWNrZXRzKGRhdGEuYnVja2V0cyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIGdpdmVuIGEgZGF0YSBvYmplY3QgYW5kIGEgR0wgcGFpbnRlciwgZGVzdHJveSBhbmQgcmUtY3JlYXRlXG4gICAgICogYWxsIG9mIGl0cyBidWZmZXJzLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHBhaW50ZXJcbiAgICAgKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgcmVsb2FkU3ltYm9sRGF0YTogZnVuY3Rpb24oZGF0YSwgcGFpbnRlcikge1xuICAgICAgICBpZiAodGhpcy5pc1VubG9hZGVkKSByZXR1cm47XG5cbiAgICAgICAgdGhpcy5jb2xsaXNpb25UaWxlID0gbmV3IENvbGxpc2lvblRpbGUoZGF0YS5jb2xsaXNpb25UaWxlLCB0aGlzLmNvbGxpc2lvbkJveEFycmF5KTtcbiAgICAgICAgdGhpcy5mZWF0dXJlSW5kZXguc2V0Q29sbGlzaW9uVGlsZSh0aGlzLmNvbGxpc2lvblRpbGUpO1xuXG4gICAgICAgIC8vIERlc3Ryb3kgYW5kIGRlbGV0ZSBleGlzdGluZyBzeW1ib2wgYnVja2V0c1xuICAgICAgICBmb3IgKHZhciBpZCBpbiB0aGlzLmJ1Y2tldHMpIHtcbiAgICAgICAgICAgIHZhciBidWNrZXQgPSB0aGlzLmJ1Y2tldHNbaWRdO1xuICAgICAgICAgICAgaWYgKGJ1Y2tldC50eXBlID09PSAnc3ltYm9sJykge1xuICAgICAgICAgICAgICAgIGJ1Y2tldC5kZXN0cm95KHBhaW50ZXIuZ2wpO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmJ1Y2tldHNbaWRdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gQWRkIG5ldyBzeW1ib2wgYnVja2V0c1xuICAgICAgICB1dGlsLmV4dGVuZCh0aGlzLmJ1Y2tldHMsIHVuc2VyaWFsaXplQnVja2V0cyhkYXRhLmJ1Y2tldHMpKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWFrZSBzdXJlIHRoYXQgdGhpcyB0aWxlIGRvZXNuJ3Qgb3duIGFueSBkYXRhIHdpdGhpbiBhIGdpdmVuXG4gICAgICogcGFpbnRlciwgc28gdGhhdCBpdCBkb2Vzbid0IGNvbnN1bWUgYW55IG1lbW9yeSBvciBtYWludGFpblxuICAgICAqIGFueSByZWZlcmVuY2VzIHRvIHRoZSBwYWludGVyLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwYWludGVyIGdsIHBhaW50ZXIgb2JqZWN0XG4gICAgICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHVubG9hZFZlY3RvckRhdGE6IGZ1bmN0aW9uKHBhaW50ZXIpIHtcbiAgICAgICAgZm9yICh2YXIgaWQgaW4gdGhpcy5idWNrZXRzKSB7XG4gICAgICAgICAgICB2YXIgYnVja2V0ID0gdGhpcy5idWNrZXRzW2lkXTtcbiAgICAgICAgICAgIGJ1Y2tldC5kZXN0cm95KHBhaW50ZXIuZ2wpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5idWNrZXRzID0gbnVsbDtcbiAgICAgICAgdGhpcy5sb2FkZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5pc1VubG9hZGVkID0gdHJ1ZTtcbiAgICB9LFxuXG4gICAgcmVkb1BsYWNlbWVudDogZnVuY3Rpb24oc291cmNlKSB7XG4gICAgICAgIGlmICghdGhpcy5sb2FkZWQgfHwgdGhpcy5yZWRvaW5nUGxhY2VtZW50KSB7XG4gICAgICAgICAgICB0aGlzLnJlZG9XaGVuRG9uZSA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnJlZG9pbmdQbGFjZW1lbnQgPSB0cnVlO1xuXG4gICAgICAgIHNvdXJjZS5kaXNwYXRjaGVyLnNlbmQoJ3JlZG8gcGxhY2VtZW50Jywge1xuICAgICAgICAgICAgdWlkOiB0aGlzLnVpZCxcbiAgICAgICAgICAgIHNvdXJjZTogc291cmNlLmlkLFxuICAgICAgICAgICAgYW5nbGU6IHNvdXJjZS5tYXAudHJhbnNmb3JtLmFuZ2xlLFxuICAgICAgICAgICAgcGl0Y2g6IHNvdXJjZS5tYXAudHJhbnNmb3JtLnBpdGNoLFxuICAgICAgICAgICAgc2hvd0NvbGxpc2lvbkJveGVzOiBzb3VyY2UubWFwLnNob3dDb2xsaXNpb25Cb3hlc1xuICAgICAgICB9LCBkb25lLmJpbmQodGhpcyksIHRoaXMud29ya2VySUQpO1xuXG4gICAgICAgIGZ1bmN0aW9uIGRvbmUoXywgZGF0YSkge1xuICAgICAgICAgICAgdGhpcy5yZWxvYWRTeW1ib2xEYXRhKGRhdGEsIHNvdXJjZS5tYXAucGFpbnRlcik7XG4gICAgICAgICAgICBzb3VyY2UuZmlyZSgndGlsZS5sb2FkJywge3RpbGU6IHRoaXN9KTtcblxuICAgICAgICAgICAgdGhpcy5yZWRvaW5nUGxhY2VtZW50ID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAodGhpcy5yZWRvV2hlbkRvbmUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlZG9QbGFjZW1lbnQoc291cmNlKTtcbiAgICAgICAgICAgICAgICB0aGlzLnJlZG9XaGVuRG9uZSA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIGdldEJ1Y2tldDogZnVuY3Rpb24obGF5ZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYnVja2V0cyAmJiB0aGlzLmJ1Y2tldHNbbGF5ZXIucmVmIHx8IGxheWVyLmlkXTtcbiAgICB9LFxuXG4gICAgcXVlcnlTb3VyY2VGZWF0dXJlczogZnVuY3Rpb24ocmVzdWx0LCBwYXJhbXMpIHtcbiAgICAgICAgaWYgKCF0aGlzLnJhd1RpbGVEYXRhKSByZXR1cm47XG5cbiAgICAgICAgaWYgKCF0aGlzLnZ0TGF5ZXJzKSB7XG4gICAgICAgICAgICB0aGlzLnZ0TGF5ZXJzID0gbmV3IHZ0LlZlY3RvclRpbGUobmV3IFByb3RvYnVmKG5ldyBVaW50OEFycmF5KHRoaXMucmF3VGlsZURhdGEpKSkubGF5ZXJzO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGxheWVyID0gdGhpcy52dExheWVycy5fZ2VvanNvblRpbGVMYXllciB8fCB0aGlzLnZ0TGF5ZXJzW3BhcmFtcy5zb3VyY2VMYXllcl07XG5cbiAgICAgICAgaWYgKCFsYXllcikgcmV0dXJuO1xuXG4gICAgICAgIHZhciBmaWx0ZXIgPSBmZWF0dXJlRmlsdGVyKHBhcmFtcy5maWx0ZXIpO1xuICAgICAgICB2YXIgY29vcmQgPSB7IHo6IHRoaXMuY29vcmQueiwgeDogdGhpcy5jb29yZC54LCB5OiB0aGlzLmNvb3JkLnkgfTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxheWVyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgZmVhdHVyZSA9IGxheWVyLmZlYXR1cmUoaSk7XG4gICAgICAgICAgICBpZiAoZmlsdGVyKGZlYXR1cmUpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGdlb2pzb25GZWF0dXJlID0gbmV3IEdlb0pTT05GZWF0dXJlKGZlYXR1cmUsIHRoaXMuY29vcmQueiwgdGhpcy5jb29yZC54LCB0aGlzLmNvb3JkLnkpO1xuICAgICAgICAgICAgICAgIGdlb2pzb25GZWF0dXJlLnRpbGUgPSBjb29yZDtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChnZW9qc29uRmVhdHVyZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5mdW5jdGlvbiB1bnNlcmlhbGl6ZUJ1Y2tldHMoaW5wdXQpIHtcbiAgICB2YXIgb3V0cHV0ID0ge307XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbnB1dC5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgYnVja2V0ID0gQnVja2V0LmNyZWF0ZShpbnB1dFtpXSk7XG4gICAgICAgIG91dHB1dFtidWNrZXQuaWRdID0gYnVja2V0O1xuICAgIH1cbiAgICByZXR1cm4gb3V0cHV0O1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgYXNzZXJ0ID0gcmVxdWlyZSgnYXNzZXJ0Jyk7XG52YXIgQ29vcmRpbmF0ZSA9IHJlcXVpcmUoJy4uL2dlby9jb29yZGluYXRlJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gVGlsZUNvb3JkO1xuXG5mdW5jdGlvbiBUaWxlQ29vcmQoeiwgeCwgeSwgdykge1xuICAgIGFzc2VydCghaXNOYU4oeikgJiYgeiA+PSAwICYmIHogJSAxID09PSAwKTtcbiAgICBhc3NlcnQoIWlzTmFOKHgpICYmIHggPj0gMCAmJiB4ICUgMSA9PT0gMCk7XG4gICAgYXNzZXJ0KCFpc05hTih5KSAmJiB5ID49IDAgJiYgeSAlIDEgPT09IDApO1xuXG4gICAgaWYgKGlzTmFOKHcpKSB3ID0gMDtcblxuICAgIHRoaXMueiA9ICt6O1xuICAgIHRoaXMueCA9ICt4O1xuICAgIHRoaXMueSA9ICt5O1xuICAgIHRoaXMudyA9ICt3O1xuXG4gICAgLy8gY2FsY3VsYXRlIGlkXG4gICAgdyAqPSAyO1xuICAgIGlmICh3IDwgMCkgdyA9IHcgKiAtMSAtIDE7XG4gICAgdmFyIGRpbSA9IDEgPDwgdGhpcy56O1xuICAgIHRoaXMuaWQgPSAoKGRpbSAqIGRpbSAqIHcgKyBkaW0gKiB0aGlzLnkgKyB0aGlzLngpICogMzIpICsgdGhpcy56O1xufVxuXG5UaWxlQ29vcmQucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMueiArIFwiL1wiICsgdGhpcy54ICsgXCIvXCIgKyB0aGlzLnk7XG59O1xuXG5UaWxlQ29vcmQucHJvdG90eXBlLnRvQ29vcmRpbmF0ZSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciB6b29tID0gdGhpcy56O1xuICAgIHZhciB0aWxlU2NhbGUgPSBNYXRoLnBvdygyLCB6b29tKTtcbiAgICB2YXIgcm93ID0gdGhpcy55O1xuICAgIHZhciBjb2x1bW4gPSB0aGlzLnggKyB0aWxlU2NhbGUgKiB0aGlzLnc7XG4gICAgcmV0dXJuIG5ldyBDb29yZGluYXRlKGNvbHVtbiwgcm93LCB6b29tKTtcbn07XG5cbi8vIFBhcnNlIGEgcGFja2VkIGludGVnZXIgaWQgaW50byBhIFRpbGVDb29yZCBvYmplY3RcblRpbGVDb29yZC5mcm9tSUQgPSBmdW5jdGlvbihpZCkge1xuICAgIHZhciB6ID0gaWQgJSAzMiwgZGltID0gMSA8PCB6O1xuICAgIHZhciB4eSA9ICgoaWQgLSB6KSAvIDMyKTtcbiAgICB2YXIgeCA9IHh5ICUgZGltLCB5ID0gKCh4eSAtIHgpIC8gZGltKSAlIGRpbTtcbiAgICB2YXIgdyA9IE1hdGguZmxvb3IoeHkgLyAoZGltICogZGltKSk7XG4gICAgaWYgKHcgJSAyICE9PSAwKSB3ID0gdyAqIC0xIC0gMTtcbiAgICB3IC89IDI7XG4gICAgcmV0dXJuIG5ldyBUaWxlQ29vcmQoeiwgeCwgeSwgdyk7XG59O1xuXG4vLyBnaXZlbiBhIGxpc3Qgb2YgdXJscywgY2hvb3NlIGEgdXJsIHRlbXBsYXRlIGFuZCByZXR1cm4gYSB0aWxlIFVSTFxuVGlsZUNvb3JkLnByb3RvdHlwZS51cmwgPSBmdW5jdGlvbih1cmxzLCBzb3VyY2VNYXhab29tKSB7XG4gICAgcmV0dXJuIHVybHNbKHRoaXMueCArIHRoaXMueSkgJSB1cmxzLmxlbmd0aF1cbiAgICAgICAgLnJlcGxhY2UoJ3twcmVmaXh9JywgKHRoaXMueCAlIDE2KS50b1N0cmluZygxNikgKyAodGhpcy55ICUgMTYpLnRvU3RyaW5nKDE2KSlcbiAgICAgICAgLnJlcGxhY2UoJ3t6fScsIE1hdGgubWluKHRoaXMueiwgc291cmNlTWF4Wm9vbSB8fCB0aGlzLnopKVxuICAgICAgICAucmVwbGFjZSgne3h9JywgdGhpcy54KVxuICAgICAgICAucmVwbGFjZSgne3l9JywgdGhpcy55KTtcbn07XG5cbi8vIFJldHVybiB0aGUgY29vcmRpbmF0ZSBvZiB0aGUgcGFyZW50IHRpbGVcblRpbGVDb29yZC5wcm90b3R5cGUucGFyZW50ID0gZnVuY3Rpb24oc291cmNlTWF4Wm9vbSkge1xuICAgIGlmICh0aGlzLnogPT09IDApIHJldHVybiBudWxsO1xuXG4gICAgLy8gdGhlIGlkIHJlcHJlc2VudHMgYW4gb3ZlcnNjYWxlZCB0aWxlLCByZXR1cm4gdGhlIHNhbWUgY29vcmRpbmF0ZXMgd2l0aCBhIGxvd2VyIHpcbiAgICBpZiAodGhpcy56ID4gc291cmNlTWF4Wm9vbSkge1xuICAgICAgICByZXR1cm4gbmV3IFRpbGVDb29yZCh0aGlzLnogLSAxLCB0aGlzLngsIHRoaXMueSwgdGhpcy53KTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IFRpbGVDb29yZCh0aGlzLnogLSAxLCBNYXRoLmZsb29yKHRoaXMueCAvIDIpLCBNYXRoLmZsb29yKHRoaXMueSAvIDIpLCB0aGlzLncpO1xufTtcblxuVGlsZUNvb3JkLnByb3RvdHlwZS53cmFwcGVkID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIG5ldyBUaWxlQ29vcmQodGhpcy56LCB0aGlzLngsIHRoaXMueSwgMCk7XG59O1xuXG4vLyBSZXR1cm4gdGhlIGNvb3JkaW5hdGVzIG9mIHRoZSB0aWxlJ3MgY2hpbGRyZW5cblRpbGVDb29yZC5wcm90b3R5cGUuY2hpbGRyZW4gPSBmdW5jdGlvbihzb3VyY2VNYXhab29tKSB7XG5cbiAgICBpZiAodGhpcy56ID49IHNvdXJjZU1heFpvb20pIHtcbiAgICAgICAgLy8gcmV0dXJuIGEgc2luZ2xlIHRpbGUgY29vcmQgcmVwcmVzZW50aW5nIGEgYW4gb3ZlcnNjYWxlZCB0aWxlXG4gICAgICAgIHJldHVybiBbbmV3IFRpbGVDb29yZCh0aGlzLnogKyAxLCB0aGlzLngsIHRoaXMueSwgdGhpcy53KV07XG4gICAgfVxuXG4gICAgdmFyIHogPSB0aGlzLnogKyAxO1xuICAgIHZhciB4ID0gdGhpcy54ICogMjtcbiAgICB2YXIgeSA9IHRoaXMueSAqIDI7XG4gICAgcmV0dXJuIFtcbiAgICAgICAgbmV3IFRpbGVDb29yZCh6LCB4LCB5LCB0aGlzLncpLFxuICAgICAgICBuZXcgVGlsZUNvb3JkKHosIHggKyAxLCB5LCB0aGlzLncpLFxuICAgICAgICBuZXcgVGlsZUNvb3JkKHosIHgsIHkgKyAxLCB0aGlzLncpLFxuICAgICAgICBuZXcgVGlsZUNvb3JkKHosIHggKyAxLCB5ICsgMSwgdGhpcy53KVxuICAgIF07XG59O1xuXG4vLyBUYWtlbiBmcm9tIHBvbHltYXBzIHNyYy9MYXllci5qc1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL3NpbXBsZWdlby9wb2x5bWFwcy9ibG9iL21hc3Rlci9zcmMvTGF5ZXIuanMjTDMzMy1MMzgzXG5cbmZ1bmN0aW9uIGVkZ2UoYSwgYikge1xuICAgIGlmIChhLnJvdyA+IGIucm93KSB7IHZhciB0ID0gYTsgYSA9IGI7IGIgPSB0OyB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgeDA6IGEuY29sdW1uLFxuICAgICAgICB5MDogYS5yb3csXG4gICAgICAgIHgxOiBiLmNvbHVtbixcbiAgICAgICAgeTE6IGIucm93LFxuICAgICAgICBkeDogYi5jb2x1bW4gLSBhLmNvbHVtbixcbiAgICAgICAgZHk6IGIucm93IC0gYS5yb3dcbiAgICB9O1xufVxuXG5mdW5jdGlvbiBzY2FuU3BhbnMoZTAsIGUxLCB5bWluLCB5bWF4LCBzY2FuTGluZSkge1xuICAgIHZhciB5MCA9IE1hdGgubWF4KHltaW4sIE1hdGguZmxvb3IoZTEueTApKTtcbiAgICB2YXIgeTEgPSBNYXRoLm1pbih5bWF4LCBNYXRoLmNlaWwoZTEueTEpKTtcblxuICAgIC8vIHNvcnQgZWRnZXMgYnkgeC1jb29yZGluYXRlXG4gICAgaWYgKChlMC54MCA9PT0gZTEueDAgJiYgZTAueTAgPT09IGUxLnkwKSA/XG4gICAgICAgICAgICAoZTAueDAgKyBlMS5keSAvIGUwLmR5ICogZTAuZHggPCBlMS54MSkgOlxuICAgICAgICAgICAgKGUwLngxIC0gZTEuZHkgLyBlMC5keSAqIGUwLmR4IDwgZTEueDApKSB7XG4gICAgICAgIHZhciB0ID0gZTA7IGUwID0gZTE7IGUxID0gdDtcbiAgICB9XG5cbiAgICAvLyBzY2FuIGxpbmVzIVxuICAgIHZhciBtMCA9IGUwLmR4IC8gZTAuZHk7XG4gICAgdmFyIG0xID0gZTEuZHggLyBlMS5keTtcbiAgICB2YXIgZDAgPSBlMC5keCA+IDA7IC8vIHVzZSB5ICsgMSB0byBjb21wdXRlIHgwXG4gICAgdmFyIGQxID0gZTEuZHggPCAwOyAvLyB1c2UgeSArIDEgdG8gY29tcHV0ZSB4MVxuICAgIGZvciAodmFyIHkgPSB5MDsgeSA8IHkxOyB5KyspIHtcbiAgICAgICAgdmFyIHgwID0gbTAgKiBNYXRoLm1heCgwLCBNYXRoLm1pbihlMC5keSwgeSArIGQwIC0gZTAueTApKSArIGUwLngwO1xuICAgICAgICB2YXIgeDEgPSBtMSAqIE1hdGgubWF4KDAsIE1hdGgubWluKGUxLmR5LCB5ICsgZDEgLSBlMS55MCkpICsgZTEueDA7XG4gICAgICAgIHNjYW5MaW5lKE1hdGguZmxvb3IoeDEpLCBNYXRoLmNlaWwoeDApLCB5KTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHNjYW5UcmlhbmdsZShhLCBiLCBjLCB5bWluLCB5bWF4LCBzY2FuTGluZSkge1xuICAgIHZhciBhYiA9IGVkZ2UoYSwgYiksXG4gICAgICAgIGJjID0gZWRnZShiLCBjKSxcbiAgICAgICAgY2EgPSBlZGdlKGMsIGEpO1xuXG4gICAgdmFyIHQ7XG5cbiAgICAvLyBzb3J0IGVkZ2VzIGJ5IHktbGVuZ3RoXG4gICAgaWYgKGFiLmR5ID4gYmMuZHkpIHsgdCA9IGFiOyBhYiA9IGJjOyBiYyA9IHQ7IH1cbiAgICBpZiAoYWIuZHkgPiBjYS5keSkgeyB0ID0gYWI7IGFiID0gY2E7IGNhID0gdDsgfVxuICAgIGlmIChiYy5keSA+IGNhLmR5KSB7IHQgPSBiYzsgYmMgPSBjYTsgY2EgPSB0OyB9XG5cbiAgICAvLyBzY2FuIHNwYW4hIHNjYW4gc3BhbiFcbiAgICBpZiAoYWIuZHkpIHNjYW5TcGFucyhjYSwgYWIsIHltaW4sIHltYXgsIHNjYW5MaW5lKTtcbiAgICBpZiAoYmMuZHkpIHNjYW5TcGFucyhjYSwgYmMsIHltaW4sIHltYXgsIHNjYW5MaW5lKTtcbn1cblxuVGlsZUNvb3JkLmNvdmVyID0gZnVuY3Rpb24oeiwgYm91bmRzLCBhY3R1YWxaKSB7XG4gICAgdmFyIHRpbGVzID0gMSA8PCB6O1xuICAgIHZhciB0ID0ge307XG5cbiAgICBmdW5jdGlvbiBzY2FuTGluZSh4MCwgeDEsIHkpIHtcbiAgICAgICAgdmFyIHgsIHd4LCBjb29yZDtcbiAgICAgICAgaWYgKHkgPj0gMCAmJiB5IDw9IHRpbGVzKSB7XG4gICAgICAgICAgICBmb3IgKHggPSB4MDsgeCA8IHgxOyB4KyspIHtcbiAgICAgICAgICAgICAgICB3eCA9ICh4ICUgdGlsZXMgKyB0aWxlcykgJSB0aWxlcztcbiAgICAgICAgICAgICAgICBjb29yZCA9IG5ldyBUaWxlQ29vcmQoYWN0dWFsWiwgd3gsIHksIE1hdGguZmxvb3IoeCAvIHRpbGVzKSk7XG4gICAgICAgICAgICAgICAgdFtjb29yZC5pZF0gPSBjb29yZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIERpdmlkZSB0aGUgc2NyZWVuIHVwIGluIHR3byB0cmlhbmdsZXMgYW5kIHNjYW4gZWFjaCBvZiB0aGVtOlxuICAgIC8vICstLS0vXG4gICAgLy8gfCAvIHxcbiAgICAvLyAvLS0tK1xuICAgIHNjYW5UcmlhbmdsZShib3VuZHNbMF0sIGJvdW5kc1sxXSwgYm91bmRzWzJdLCAwLCB0aWxlcywgc2NhbkxpbmUpO1xuICAgIHNjYW5UcmlhbmdsZShib3VuZHNbMl0sIGJvdW5kc1szXSwgYm91bmRzWzBdLCAwLCB0aWxlcywgc2NhbkxpbmUpO1xuXG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKHQpLm1hcChmdW5jdGlvbihpZCkge1xuICAgICAgICByZXR1cm4gdFtpZF07XG4gICAgfSk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgVGlsZSA9IHJlcXVpcmUoJy4vdGlsZScpO1xudmFyIFRpbGVDb29yZCA9IHJlcXVpcmUoJy4vdGlsZV9jb29yZCcpO1xudmFyIFBvaW50ID0gcmVxdWlyZSgncG9pbnQtZ2VvbWV0cnknKTtcbnZhciBDYWNoZSA9IHJlcXVpcmUoJy4uL3V0aWwvbHJ1X2NhY2hlJyk7XG52YXIgQ29vcmRpbmF0ZSA9IHJlcXVpcmUoJy4uL2dlby9jb29yZGluYXRlJyk7XG52YXIgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwvdXRpbCcpO1xudmFyIEVYVEVOVCA9IHJlcXVpcmUoJy4uL2RhdGEvYnVja2V0JykuRVhURU5UO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFRpbGVQeXJhbWlkO1xuXG4vKipcbiAqIEEgdGlsZSBweXJhbWlkIGlzIGEgc3BlY2lhbGl6ZWQgY2FjaGUgYW5kIGRhdGFzdHJ1Y3R1cmVcbiAqIHRoYXQgY29udGFpbnMgdGlsZXMuIEl0J3MgdXNlZCBieSBzb3VyY2VzIHRvIG1hbmFnZSB0aGVpclxuICogZGF0YS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQHBhcmFtIHtudW1iZXJ9IG9wdGlvbnMudGlsZVNpemVcbiAqIEBwYXJhbSB7bnVtYmVyfSBvcHRpb25zLm1pbnpvb21cbiAqIEBwYXJhbSB7bnVtYmVyfSBvcHRpb25zLm1heHpvb21cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIFRpbGVQeXJhbWlkKG9wdGlvbnMpIHtcbiAgICB0aGlzLnRpbGVTaXplID0gb3B0aW9ucy50aWxlU2l6ZTtcbiAgICB0aGlzLm1pbnpvb20gPSBvcHRpb25zLm1pbnpvb207XG4gICAgdGhpcy5tYXh6b29tID0gb3B0aW9ucy5tYXh6b29tO1xuICAgIHRoaXMucm91bmRab29tID0gb3B0aW9ucy5yb3VuZFpvb207XG4gICAgdGhpcy5yZXBhcnNlT3ZlcnNjYWxlZCA9IG9wdGlvbnMucmVwYXJzZU92ZXJzY2FsZWQ7XG5cbiAgICB0aGlzLl9sb2FkID0gb3B0aW9ucy5sb2FkO1xuICAgIHRoaXMuX2Fib3J0ID0gb3B0aW9ucy5hYm9ydDtcbiAgICB0aGlzLl91bmxvYWQgPSBvcHRpb25zLnVubG9hZDtcbiAgICB0aGlzLl9hZGQgPSBvcHRpb25zLmFkZDtcbiAgICB0aGlzLl9yZW1vdmUgPSBvcHRpb25zLnJlbW92ZTtcbiAgICB0aGlzLl9yZWRvUGxhY2VtZW50ID0gb3B0aW9ucy5yZWRvUGxhY2VtZW50O1xuXG4gICAgdGhpcy5fdGlsZXMgPSB7fTtcbiAgICB0aGlzLl9jYWNoZSA9IG5ldyBDYWNoZSgwLCBmdW5jdGlvbih0aWxlKSB7IHJldHVybiB0aGlzLl91bmxvYWQodGlsZSk7IH0uYmluZCh0aGlzKSk7XG5cbiAgICB0aGlzLl9maWx0ZXJSZW5kZXJlZCA9IHRoaXMuX2ZpbHRlclJlbmRlcmVkLmJpbmQodGhpcyk7XG59XG5cblxuVGlsZVB5cmFtaWQubWF4T3Zlcnpvb21pbmcgPSAxMDtcblRpbGVQeXJhbWlkLm1heFVuZGVyem9vbWluZyA9IDM7XG5cblRpbGVQeXJhbWlkLnByb3RvdHlwZSA9IHtcbiAgICAvKipcbiAgICAgKiBDb25maXJtIHRoYXQgZXZlcnkgdHJhY2tlZCB0aWxlIGlzIGxvYWRlZC5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gd2hldGhlciBhbGwgdGlsZXMgYXJlIGxvYWRlZC5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGxvYWRlZDogZnVuY3Rpb24oKSB7XG4gICAgICAgIGZvciAodmFyIHQgaW4gdGhpcy5fdGlsZXMpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5fdGlsZXNbdF0ubG9hZGVkICYmICF0aGlzLl90aWxlc1t0XS5lcnJvcmVkKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIGFsbCB0aWxlIGlkcyBvcmRlcmVkIHdpdGggei1vcmRlciwgYW5kIGNhc3QgdG8gbnVtYmVyc1xuICAgICAqIEByZXR1cm5zIHtBcnJheTxudW1iZXI+fSBpZHNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIG9yZGVyZWRJRHM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gT2JqZWN0LmtleXModGhpcy5fdGlsZXMpLm1hcChOdW1iZXIpLnNvcnQoY29tcGFyZUtleVpvb20pO1xuICAgIH0sXG5cbiAgICByZW5kZXJlZElEczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9yZGVyZWRJRHMoKS5maWx0ZXIodGhpcy5fZmlsdGVyUmVuZGVyZWQpO1xuICAgIH0sXG5cbiAgICBfZmlsdGVyUmVuZGVyZWQ6IGZ1bmN0aW9uKGlkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl90aWxlc1tpZF0ubG9hZGVkICYmICF0aGlzLl9jb3ZlcmVkVGlsZXNbaWRdO1xuICAgIH0sXG5cbiAgICByZWxvYWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLl9jYWNoZS5yZXNldCgpO1xuICAgICAgICBmb3IgKHZhciBpIGluIHRoaXMuX3RpbGVzKSB7XG4gICAgICAgICAgICB0aGlzLl9sb2FkKHRoaXMuX3RpbGVzW2ldKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgYSBzcGVjaWZpYyB0aWxlIGJ5IGlkXG4gICAgICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSBpZCB0aWxlIGlkXG4gICAgICogQHJldHVybnMge09iamVjdH0gdGlsZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgZ2V0VGlsZTogZnVuY3Rpb24oaWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RpbGVzW2lkXTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogZ2V0IHRoZSB6b29tIGxldmVsIGFkanVzdGVkIGZvciB0aGUgZGlmZmVyZW5jZSBpbiBtYXAgYW5kIHNvdXJjZSB0aWxlc2l6ZXNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdHJhbnNmb3JtXG4gICAgICogQHJldHVybnMge251bWJlcn0gem9vbSBsZXZlbFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgZ2V0Wm9vbTogZnVuY3Rpb24odHJhbnNmb3JtKSB7XG4gICAgICAgIHJldHVybiB0cmFuc2Zvcm0uem9vbSArIE1hdGgubG9nKHRyYW5zZm9ybS50aWxlU2l6ZSAvIHRoaXMudGlsZVNpemUpIC8gTWF0aC5MTjI7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybiBhIHpvb20gbGV2ZWwgdGhhdCB3aWxsIGNvdmVyIGFsbCB0aWxlcyBpbiBhIGdpdmVuIHRyYW5zZm9ybVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB0cmFuc2Zvcm1cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSB6b29tIGxldmVsXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBjb3ZlcmluZ1pvb21MZXZlbDogZnVuY3Rpb24odHJhbnNmb3JtKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5yb3VuZFpvb20gPyBNYXRoLnJvdW5kIDogTWF0aC5mbG9vcikodGhpcy5nZXRab29tKHRyYW5zZm9ybSkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHaXZlbiBhIHRyYW5zZm9ybSwgcmV0dXJuIGFsbCBjb29yZGluYXRlcyB0aGF0IGNvdWxkIGNvdmVyIHRoYXRcbiAgICAgKiB0cmFuc2Zvcm0gZm9yIGEgY292ZXJpbmcgem9vbSBsZXZlbC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdHJhbnNmb3JtXG4gICAgICogQHJldHVybnMge0FycmF5PFRpbGU+fSB0aWxlc1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgY292ZXJpbmdUaWxlczogZnVuY3Rpb24odHJhbnNmb3JtKSB7XG4gICAgICAgIHZhciB6ID0gdGhpcy5jb3ZlcmluZ1pvb21MZXZlbCh0cmFuc2Zvcm0pO1xuICAgICAgICB2YXIgYWN0dWFsWiA9IHo7XG5cbiAgICAgICAgaWYgKHogPCB0aGlzLm1pbnpvb20pIHJldHVybiBbXTtcbiAgICAgICAgaWYgKHogPiB0aGlzLm1heHpvb20pIHogPSB0aGlzLm1heHpvb207XG5cbiAgICAgICAgdmFyIHRyID0gdHJhbnNmb3JtLFxuICAgICAgICAgICAgdGlsZUNlbnRlciA9IHRyLmxvY2F0aW9uQ29vcmRpbmF0ZSh0ci5jZW50ZXIpLl96b29tVG8oeiksXG4gICAgICAgICAgICBjZW50ZXJQb2ludCA9IG5ldyBQb2ludCh0aWxlQ2VudGVyLmNvbHVtbiAtIDAuNSwgdGlsZUNlbnRlci5yb3cgLSAwLjUpO1xuXG4gICAgICAgIHJldHVybiBUaWxlQ29vcmQuY292ZXIoeiwgW1xuICAgICAgICAgICAgdHIucG9pbnRDb29yZGluYXRlKG5ldyBQb2ludCgwLCAwKSkuX3pvb21Ubyh6KSxcbiAgICAgICAgICAgIHRyLnBvaW50Q29vcmRpbmF0ZShuZXcgUG9pbnQodHIud2lkdGgsIDApKS5fem9vbVRvKHopLFxuICAgICAgICAgICAgdHIucG9pbnRDb29yZGluYXRlKG5ldyBQb2ludCh0ci53aWR0aCwgdHIuaGVpZ2h0KSkuX3pvb21Ubyh6KSxcbiAgICAgICAgICAgIHRyLnBvaW50Q29vcmRpbmF0ZShuZXcgUG9pbnQoMCwgdHIuaGVpZ2h0KSkuX3pvb21Ubyh6KVxuICAgICAgICBdLCB0aGlzLnJlcGFyc2VPdmVyc2NhbGVkID8gYWN0dWFsWiA6IHopLnNvcnQoZnVuY3Rpb24oYSwgYikge1xuICAgICAgICAgICAgcmV0dXJuIGNlbnRlclBvaW50LmRpc3QoYSkgLSBjZW50ZXJQb2ludC5kaXN0KGIpO1xuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVjdXJzaXZlbHkgZmluZCBjaGlsZHJlbiBvZiB0aGUgZ2l2ZW4gdGlsZSAodXAgdG8gbWF4Q292ZXJpbmdab29tKSB0aGF0IGFyZSBhbHJlYWR5IGxvYWRlZDtcbiAgICAgKiBhZGRzIGZvdW5kIHRpbGVzIHRvIHJldGFpbiBvYmplY3Q7IHJldHVybnMgdHJ1ZSBpZiBhbnkgY2hpbGQgaXMgZm91bmQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0Nvb3JkaW5hdGV9IGNvb3JkXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG1heENvdmVyaW5nWm9vbVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gcmV0YWluXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IHdoZXRoZXIgdGhlIG9wZXJhdGlvbiB3YXMgY29tcGxldGVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGZpbmRMb2FkZWRDaGlsZHJlbjogZnVuY3Rpb24oY29vcmQsIG1heENvdmVyaW5nWm9vbSwgcmV0YWluKSB7XG4gICAgICAgIHZhciBmb3VuZCA9IGZhbHNlO1xuXG4gICAgICAgIGZvciAodmFyIGlkIGluIHRoaXMuX3RpbGVzKSB7XG4gICAgICAgICAgICB2YXIgdGlsZSA9IHRoaXMuX3RpbGVzW2lkXTtcblxuICAgICAgICAgICAgLy8gb25seSBjb25zaWRlciBsb2FkZWQgdGlsZXMgb24gaGlnaGVyIHpvb20gbGV2ZWxzICh1cCB0byBtYXhDb3ZlcmluZ1pvb20pXG4gICAgICAgICAgICBpZiAocmV0YWluW2lkXSB8fCAhdGlsZS5sb2FkZWQgfHwgdGlsZS5jb29yZC56IDw9IGNvb3JkLnogfHwgdGlsZS5jb29yZC56ID4gbWF4Q292ZXJpbmdab29tKSBjb250aW51ZTtcblxuICAgICAgICAgICAgLy8gZGlzcmVnYXJkIHRpbGVzIHRoYXQgYXJlIG5vdCBkZXNjZW5kYW50cyBvZiB0aGUgZ2l2ZW4gdGlsZSBjb29yZGluYXRlXG4gICAgICAgICAgICB2YXIgejIgPSBNYXRoLnBvdygyLCBNYXRoLm1pbih0aWxlLmNvb3JkLnosIHRoaXMubWF4em9vbSkgLSBNYXRoLm1pbihjb29yZC56LCB0aGlzLm1heHpvb20pKTtcbiAgICAgICAgICAgIGlmIChNYXRoLmZsb29yKHRpbGUuY29vcmQueCAvIHoyKSAhPT0gY29vcmQueCB8fFxuICAgICAgICAgICAgICAgIE1hdGguZmxvb3IodGlsZS5jb29yZC55IC8gejIpICE9PSBjb29yZC55KVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuXG4gICAgICAgICAgICAvLyBmb3VuZCBsb2FkZWQgY2hpbGRcbiAgICAgICAgICAgIHJldGFpbltpZF0gPSB0cnVlO1xuICAgICAgICAgICAgZm91bmQgPSB0cnVlO1xuXG4gICAgICAgICAgICAvLyBsb29wIHRocm91Z2ggcGFyZW50czsgcmV0YWluIHRoZSB0b3Btb3N0IGxvYWRlZCBvbmUgaWYgZm91bmRcbiAgICAgICAgICAgIHdoaWxlICh0aWxlICYmIHRpbGUuY29vcmQueiAtIDEgPiBjb29yZC56KSB7XG4gICAgICAgICAgICAgICAgdmFyIHBhcmVudElkID0gdGlsZS5jb29yZC5wYXJlbnQodGhpcy5tYXh6b29tKS5pZDtcbiAgICAgICAgICAgICAgICB0aWxlID0gdGhpcy5fdGlsZXNbcGFyZW50SWRdO1xuXG4gICAgICAgICAgICAgICAgaWYgKHRpbGUgJiYgdGlsZS5sb2FkZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHJldGFpbltpZF07XG4gICAgICAgICAgICAgICAgICAgIHJldGFpbltwYXJlbnRJZF0gPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZm91bmQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEZpbmQgYSBsb2FkZWQgcGFyZW50IG9mIHRoZSBnaXZlbiB0aWxlICh1cCB0byBtaW5Db3ZlcmluZ1pvb20pO1xuICAgICAqIGFkZHMgdGhlIGZvdW5kIHRpbGUgdG8gcmV0YWluIG9iamVjdCBhbmQgcmV0dXJucyB0aGUgdGlsZSBpZiBmb3VuZFxuICAgICAqXG4gICAgICogQHBhcmFtIHtDb29yZGluYXRlfSBjb29yZFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBtaW5Db3ZlcmluZ1pvb21cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHJldGFpblxuICAgICAqIEByZXR1cm5zIHtUaWxlfSB0aWxlIG9iamVjdFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgZmluZExvYWRlZFBhcmVudDogZnVuY3Rpb24oY29vcmQsIG1pbkNvdmVyaW5nWm9vbSwgcmV0YWluKSB7XG4gICAgICAgIGZvciAodmFyIHogPSBjb29yZC56IC0gMTsgeiA+PSBtaW5Db3ZlcmluZ1pvb207IHotLSkge1xuICAgICAgICAgICAgY29vcmQgPSBjb29yZC5wYXJlbnQodGhpcy5tYXh6b29tKTtcbiAgICAgICAgICAgIHZhciB0aWxlID0gdGhpcy5fdGlsZXNbY29vcmQuaWRdO1xuICAgICAgICAgICAgaWYgKHRpbGUgJiYgdGlsZS5sb2FkZWQpIHtcbiAgICAgICAgICAgICAgICByZXRhaW5bY29vcmQuaWRdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGlsZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLl9jYWNoZS5oYXMoY29vcmQuaWQpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGRUaWxlKGNvb3JkKTtcbiAgICAgICAgICAgICAgICByZXRhaW5bY29vcmQuaWRdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fdGlsZXNbY29vcmQuaWRdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlc2l6ZXMgdGhlIHRpbGUgY2FjaGUgYmFzZWQgb24gdGhlIGN1cnJlbnQgdmlld3BvcnQncyBzaXplLlxuICAgICAqXG4gICAgICogTGFyZ2VyIHZpZXdwb3J0cyB1c2UgbW9yZSB0aWxlcyBhbmQgbmVlZCBsYXJnZXIgY2FjaGVzLiBMYXJnZXIgdmlld3BvcnRzXG4gICAgICogYXJlIG1vcmUgbGlrZWx5IHRvIGJlIGZvdW5kIG9uIGRldmljZXMgd2l0aCBtb3JlIG1lbW9yeSBhbmQgb24gcGFnZXMgd2hlcmVcbiAgICAgKiB0aGUgbWFwIGlzIG1vcmUgaW1wb3J0YW50LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB1cGRhdGVDYWNoZVNpemU6IGZ1bmN0aW9uKHRyYW5zZm9ybSkge1xuICAgICAgICB2YXIgd2lkdGhJblRpbGVzID0gTWF0aC5jZWlsKHRyYW5zZm9ybS53aWR0aCAvIHRyYW5zZm9ybS50aWxlU2l6ZSkgKyAxO1xuICAgICAgICB2YXIgaGVpZ2h0SW5UaWxlcyA9IE1hdGguY2VpbCh0cmFuc2Zvcm0uaGVpZ2h0IC8gdHJhbnNmb3JtLnRpbGVTaXplKSArIDE7XG4gICAgICAgIHZhciBhcHByb3hUaWxlc0luVmlldyA9IHdpZHRoSW5UaWxlcyAqIGhlaWdodEluVGlsZXM7XG4gICAgICAgIHZhciBjb21tb25ab29tUmFuZ2UgPSA1O1xuICAgICAgICB0aGlzLl9jYWNoZS5zZXRNYXhTaXplKE1hdGguZmxvb3IoYXBwcm94VGlsZXNJblZpZXcgKiBjb21tb25ab29tUmFuZ2UpKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyB0aWxlcyB0aGF0IGFyZSBvdXRzaWRlIHRoZSB2aWV3cG9ydCBhbmQgYWRkcyBuZXcgdGlsZXMgdGhhdFxuICAgICAqIGFyZSBpbnNpZGUgdGhlIHZpZXdwb3J0LlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdXBkYXRlOiBmdW5jdGlvbih1c2VkLCB0cmFuc2Zvcm0sIGZhZGVEdXJhdGlvbikge1xuICAgICAgICB2YXIgaTtcbiAgICAgICAgdmFyIGNvb3JkO1xuICAgICAgICB2YXIgdGlsZTtcblxuICAgICAgICB0aGlzLnVwZGF0ZUNhY2hlU2l6ZSh0cmFuc2Zvcm0pO1xuXG4gICAgICAgIC8vIERldGVybWluZSB0aGUgb3Zlcnpvb21pbmcvdW5kZXJ6b29taW5nIGFtb3VudHMuXG4gICAgICAgIHZhciB6b29tID0gKHRoaXMucm91bmRab29tID8gTWF0aC5yb3VuZCA6IE1hdGguZmxvb3IpKHRoaXMuZ2V0Wm9vbSh0cmFuc2Zvcm0pKTtcbiAgICAgICAgdmFyIG1pbkNvdmVyaW5nWm9vbSA9IE1hdGgubWF4KHpvb20gLSBUaWxlUHlyYW1pZC5tYXhPdmVyem9vbWluZywgdGhpcy5taW56b29tKTtcbiAgICAgICAgdmFyIG1heENvdmVyaW5nWm9vbSA9IE1hdGgubWF4KHpvb20gKyBUaWxlUHlyYW1pZC5tYXhVbmRlcnpvb21pbmcsICB0aGlzLm1pbnpvb20pO1xuXG4gICAgICAgIC8vIFJldGFpbiBpcyBhIGxpc3Qgb2YgdGlsZXMgdGhhdCB3ZSBzaG91bGRuJ3QgZGVsZXRlLCBldmVuIGlmIHRoZXkgYXJlIG5vdFxuICAgICAgICAvLyB0aGUgbW9zdCBpZGVhbCB0aWxlIGZvciB0aGUgY3VycmVudCB2aWV3cG9ydC4gVGhpcyBtYXkgaW5jbHVkZSB0aWxlcyBsaWtlXG4gICAgICAgIC8vIHBhcmVudCBvciBjaGlsZCB0aWxlcyB0aGF0IGFyZSAqYWxyZWFkeSogbG9hZGVkLlxuICAgICAgICB2YXIgcmV0YWluID0ge307XG4gICAgICAgIHZhciBub3cgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcblxuICAgICAgICAvLyBDb3ZlcmVkIGlzIGEgbGlzdCBvZiByZXRhaW5lZCB0aWxlcyB3aG8ncyBhcmVhcyBhcmUgZnVsbCBjb3ZlcmVkIGJ5IG90aGVyLFxuICAgICAgICAvLyBiZXR0ZXIsIHJldGFpbmVkIHRpbGVzLiBUaGV5IGFyZSBub3QgZHJhd24gc2VwYXJhdGVseS5cbiAgICAgICAgdGhpcy5fY292ZXJlZFRpbGVzID0ge307XG5cbiAgICAgICAgdmFyIHJlcXVpcmVkID0gdXNlZCA/IHRoaXMuY292ZXJpbmdUaWxlcyh0cmFuc2Zvcm0pIDogW107XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCByZXF1aXJlZC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29vcmQgPSByZXF1aXJlZFtpXTtcbiAgICAgICAgICAgIHRpbGUgPSB0aGlzLmFkZFRpbGUoY29vcmQpO1xuXG4gICAgICAgICAgICByZXRhaW5bY29vcmQuaWRdID0gdHJ1ZTtcblxuICAgICAgICAgICAgaWYgKHRpbGUubG9hZGVkKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuXG4gICAgICAgICAgICAvLyBUaGUgdGlsZSB3ZSByZXF1aXJlIGlzIG5vdCB5ZXQgbG9hZGVkLlxuICAgICAgICAgICAgLy8gUmV0YWluIGNoaWxkIG9yIHBhcmVudCB0aWxlcyB0aGF0IGNvdmVyIHRoZSBzYW1lIGFyZWEuXG4gICAgICAgICAgICBpZiAoIXRoaXMuZmluZExvYWRlZENoaWxkcmVuKGNvb3JkLCBtYXhDb3ZlcmluZ1pvb20sIHJldGFpbikpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZpbmRMb2FkZWRQYXJlbnQoY29vcmQsIG1pbkNvdmVyaW5nWm9vbSwgcmV0YWluKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBwYXJlbnRzRm9yRmFkaW5nID0ge307XG5cbiAgICAgICAgdmFyIGlkcyA9IE9iamVjdC5rZXlzKHJldGFpbik7XG4gICAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgaWRzLmxlbmd0aDsgaysrKSB7XG4gICAgICAgICAgICB2YXIgaWQgPSBpZHNba107XG4gICAgICAgICAgICBjb29yZCA9IFRpbGVDb29yZC5mcm9tSUQoaWQpO1xuICAgICAgICAgICAgdGlsZSA9IHRoaXMuX3RpbGVzW2lkXTtcbiAgICAgICAgICAgIGlmICh0aWxlICYmIHRpbGUudGltZUFkZGVkID4gbm93IC0gKGZhZGVEdXJhdGlvbiB8fCAwKSkge1xuICAgICAgICAgICAgICAgIC8vIFRoaXMgdGlsZSBpcyBzdGlsbCBmYWRpbmcgaW4uIEZpbmQgdGlsZXMgdG8gY3Jvc3MtZmFkZSB3aXRoIGl0LlxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmZpbmRMb2FkZWRDaGlsZHJlbihjb29yZCwgbWF4Q292ZXJpbmdab29tLCByZXRhaW4pKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldGFpbltpZF0gPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmZpbmRMb2FkZWRQYXJlbnQoY29vcmQsIG1pbkNvdmVyaW5nWm9vbSwgcGFyZW50c0ZvckZhZGluZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZmFkZWRQYXJlbnQ7XG4gICAgICAgIGZvciAoZmFkZWRQYXJlbnQgaW4gcGFyZW50c0ZvckZhZGluZykge1xuICAgICAgICAgICAgaWYgKCFyZXRhaW5bZmFkZWRQYXJlbnRdKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgYSB0aWxlIGlzIG9ubHkgbmVlZGVkIGZvciBmYWRpbmcsIG1hcmsgaXQgYXMgY292ZXJlZCBzbyB0aGF0IGl0IGlzbid0IHJlbmRlcmVkIG9uIGl0J3Mgb3duLlxuICAgICAgICAgICAgICAgIHRoaXMuX2NvdmVyZWRUaWxlc1tmYWRlZFBhcmVudF0gPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAoZmFkZWRQYXJlbnQgaW4gcGFyZW50c0ZvckZhZGluZykge1xuICAgICAgICAgICAgcmV0YWluW2ZhZGVkUGFyZW50XSA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBSZW1vdmUgdGhlIHRpbGVzIHdlIGRvbid0IG5lZWQgYW55bW9yZS5cbiAgICAgICAgdmFyIHJlbW92ZSA9IHV0aWwua2V5c0RpZmZlcmVuY2UodGhpcy5fdGlsZXMsIHJldGFpbik7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCByZW1vdmUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlVGlsZSgrcmVtb3ZlW2ldKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMudHJhbnNmb3JtID0gdHJhbnNmb3JtO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBZGQgYSB0aWxlLCBnaXZlbiBpdHMgY29vcmRpbmF0ZSwgdG8gdGhlIHB5cmFtaWQuXG4gICAgICogQHBhcmFtIHtDb29yZGluYXRlfSBjb29yZFxuICAgICAqIEByZXR1cm5zIHtDb29yZGluYXRlfSB0aGUgY29vcmRpbmF0ZS5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGFkZFRpbGU6IGZ1bmN0aW9uKGNvb3JkKSB7XG4gICAgICAgIHZhciB0aWxlID0gdGhpcy5fdGlsZXNbY29vcmQuaWRdO1xuICAgICAgICBpZiAodGlsZSlcbiAgICAgICAgICAgIHJldHVybiB0aWxlO1xuXG4gICAgICAgIHZhciB3cmFwcGVkID0gY29vcmQud3JhcHBlZCgpO1xuICAgICAgICB0aWxlID0gdGhpcy5fdGlsZXNbd3JhcHBlZC5pZF07XG5cbiAgICAgICAgaWYgKCF0aWxlKSB7XG4gICAgICAgICAgICB0aWxlID0gdGhpcy5fY2FjaGUuZ2V0KHdyYXBwZWQuaWQpO1xuICAgICAgICAgICAgaWYgKHRpbGUgJiYgdGhpcy5fcmVkb1BsYWNlbWVudCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3JlZG9QbGFjZW1lbnQodGlsZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRpbGUpIHtcbiAgICAgICAgICAgIHZhciB6b29tID0gY29vcmQuejtcbiAgICAgICAgICAgIHZhciBvdmVyc2NhbGluZyA9IHpvb20gPiB0aGlzLm1heHpvb20gPyBNYXRoLnBvdygyLCB6b29tIC0gdGhpcy5tYXh6b29tKSA6IDE7XG4gICAgICAgICAgICB0aWxlID0gbmV3IFRpbGUod3JhcHBlZCwgdGhpcy50aWxlU2l6ZSAqIG92ZXJzY2FsaW5nLCB0aGlzLm1heHpvb20pO1xuICAgICAgICAgICAgdGhpcy5fbG9hZCh0aWxlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRpbGUudXNlcysrO1xuICAgICAgICB0aGlzLl90aWxlc1tjb29yZC5pZF0gPSB0aWxlO1xuICAgICAgICB0aGlzLl9hZGQodGlsZSwgY29vcmQpO1xuXG4gICAgICAgIHJldHVybiB0aWxlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmUgYSB0aWxlLCBnaXZlbiBpdHMgaWQsIGZyb20gdGhlIHB5cmFtaWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ9IGlkIHRpbGUgaWRcbiAgICAgKiBAcmV0dXJucyB7dW5kZWZpbmVkfSBub3RoaW5nXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICByZW1vdmVUaWxlOiBmdW5jdGlvbihpZCkge1xuICAgICAgICB2YXIgdGlsZSA9IHRoaXMuX3RpbGVzW2lkXTtcbiAgICAgICAgaWYgKCF0aWxlKVxuICAgICAgICAgICAgcmV0dXJuO1xuXG4gICAgICAgIHRpbGUudXNlcy0tO1xuICAgICAgICBkZWxldGUgdGhpcy5fdGlsZXNbaWRdO1xuICAgICAgICB0aGlzLl9yZW1vdmUodGlsZSk7XG5cbiAgICAgICAgaWYgKHRpbGUudXNlcyA+IDApXG4gICAgICAgICAgICByZXR1cm47XG5cbiAgICAgICAgaWYgKHRpbGUubG9hZGVkKSB7XG4gICAgICAgICAgICB0aGlzLl9jYWNoZS5hZGQodGlsZS5jb29yZC53cmFwcGVkKCkuaWQsIHRpbGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fYWJvcnQodGlsZSk7XG4gICAgICAgICAgICB0aGlzLl91bmxvYWQodGlsZSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlIGFsbCB0aWxlcyBmcm9tIHRoaXMgcHlyYW1pZFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgY2xlYXJUaWxlczogZnVuY3Rpb24oKSB7XG4gICAgICAgIGZvciAodmFyIGlkIGluIHRoaXMuX3RpbGVzKVxuICAgICAgICAgICAgdGhpcy5yZW1vdmVUaWxlKGlkKTtcbiAgICAgICAgdGhpcy5fY2FjaGUucmVzZXQoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2VhcmNoIHRocm91Z2ggb3VyIGN1cnJlbnQgdGlsZXMgYW5kIGF0dGVtcHQgdG8gZmluZCB0aGUgdGlsZXMgdGhhdFxuICAgICAqIGNvdmVyIHRoZSBnaXZlbiBib3VuZHMuXG4gICAgICogQHBhcmFtIHtBcnJheTxDb29yZGluYXRlPn0gcXVlcnlHZW9tZXRyeSBjb29yZGluYXRlcyBvZiB0aGUgY29ybmVycyBvZiBib3VuZGluZyByZWN0YW5nbGVcbiAgICAgKiBAcmV0dXJucyB7QXJyYXk8T2JqZWN0Pn0gcmVzdWx0IGl0ZW1zIGhhdmUge3RpbGUsIG1pblgsIG1heFgsIG1pblksIG1heFl9LCB3aGVyZSBtaW4vbWF4IGJvdW5kaW5nIHZhbHVlcyBhcmUgdGhlIGdpdmVuIGJvdW5kcyB0cmFuc2Zvcm1lZCBpbiBpbnRvIHRoZSBjb29yZGluYXRlIHNwYWNlIG9mIHRoaXMgdGlsZS5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRpbGVzSW46IGZ1bmN0aW9uKHF1ZXJ5R2VvbWV0cnkpIHtcbiAgICAgICAgdmFyIHRpbGVSZXN1bHRzID0ge307XG4gICAgICAgIHZhciBpZHMgPSB0aGlzLm9yZGVyZWRJRHMoKTtcblxuICAgICAgICB2YXIgbWluWCA9IEluZmluaXR5O1xuICAgICAgICB2YXIgbWluWSA9IEluZmluaXR5O1xuICAgICAgICB2YXIgbWF4WCA9IC1JbmZpbml0eTtcbiAgICAgICAgdmFyIG1heFkgPSAtSW5maW5pdHk7XG4gICAgICAgIHZhciB6ID0gcXVlcnlHZW9tZXRyeVswXS56b29tO1xuXG4gICAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgcXVlcnlHZW9tZXRyeS5sZW5ndGg7IGsrKykge1xuICAgICAgICAgICAgdmFyIHAgPSBxdWVyeUdlb21ldHJ5W2tdO1xuICAgICAgICAgICAgbWluWCA9IE1hdGgubWluKG1pblgsIHAuY29sdW1uKTtcbiAgICAgICAgICAgIG1pblkgPSBNYXRoLm1pbihtaW5ZLCBwLnJvdyk7XG4gICAgICAgICAgICBtYXhYID0gTWF0aC5tYXgobWF4WCwgcC5jb2x1bW4pO1xuICAgICAgICAgICAgbWF4WSA9IE1hdGgubWF4KG1heFksIHAucm93KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaWRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgdGlsZSA9IHRoaXMuX3RpbGVzW2lkc1tpXV07XG4gICAgICAgICAgICB2YXIgY29vcmQgPSBUaWxlQ29vcmQuZnJvbUlEKGlkc1tpXSk7XG5cbiAgICAgICAgICAgIHZhciB0aWxlU3BhY2VCb3VuZHMgPSBbXG4gICAgICAgICAgICAgICAgY29vcmRpbmF0ZVRvVGlsZVBvaW50KGNvb3JkLCB0aWxlLnNvdXJjZU1heFpvb20sIG5ldyBDb29yZGluYXRlKG1pblgsIG1pblksIHopKSxcbiAgICAgICAgICAgICAgICBjb29yZGluYXRlVG9UaWxlUG9pbnQoY29vcmQsIHRpbGUuc291cmNlTWF4Wm9vbSwgbmV3IENvb3JkaW5hdGUobWF4WCwgbWF4WSwgeikpXG4gICAgICAgICAgICBdO1xuXG4gICAgICAgICAgICBpZiAodGlsZVNwYWNlQm91bmRzWzBdLnggPCBFWFRFTlQgJiYgdGlsZVNwYWNlQm91bmRzWzBdLnkgPCBFWFRFTlQgJiZcbiAgICAgICAgICAgICAgICB0aWxlU3BhY2VCb3VuZHNbMV0ueCA+PSAwICYmIHRpbGVTcGFjZUJvdW5kc1sxXS55ID49IDApIHtcblxuICAgICAgICAgICAgICAgIHZhciB0aWxlU3BhY2VRdWVyeUdlb21ldHJ5ID0gW107XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBxdWVyeUdlb21ldHJ5Lmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIHRpbGVTcGFjZVF1ZXJ5R2VvbWV0cnkucHVzaChjb29yZGluYXRlVG9UaWxlUG9pbnQoY29vcmQsIHRpbGUuc291cmNlTWF4Wm9vbSwgcXVlcnlHZW9tZXRyeVtqXSkpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciB0aWxlUmVzdWx0ID0gdGlsZVJlc3VsdHNbdGlsZS5jb29yZC5pZF07XG4gICAgICAgICAgICAgICAgaWYgKHRpbGVSZXN1bHQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICB0aWxlUmVzdWx0ID0gdGlsZVJlc3VsdHNbdGlsZS5jb29yZC5pZF0gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aWxlOiB0aWxlLFxuICAgICAgICAgICAgICAgICAgICAgICAgcXVlcnlHZW9tZXRyeTogW10sXG4gICAgICAgICAgICAgICAgICAgICAgICBzY2FsZTogTWF0aC5wb3coMiwgdGhpcy50cmFuc2Zvcm0uem9vbSAtIHRpbGUuY29vcmQueilcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBXcmFwcGVkIHRpbGVzIHNoYXJlIG9uZSB0aWxlUmVzdWx0IG9iamVjdCBidXQgY2FuIGhhdmUgbXVsdGlwbGUgcXVlcnlHZW9tZXRyeSBwYXJ0c1xuICAgICAgICAgICAgICAgIHRpbGVSZXN1bHQucXVlcnlHZW9tZXRyeS5wdXNoKHRpbGVTcGFjZVF1ZXJ5R2VvbWV0cnkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJlc3VsdHMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgdCBpbiB0aWxlUmVzdWx0cykge1xuICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHRpbGVSZXN1bHRzW3RdKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICB9XG59O1xuXG4vKipcbiAqIENvbnZlcnQgYSBjb29yZGluYXRlIHRvIGEgcG9pbnQgaW4gYSB0aWxlJ3MgY29vcmRpbmF0ZSBzcGFjZS5cbiAqIEBwYXJhbSB7Q29vcmRpbmF0ZX0gdGlsZUNvb3JkXG4gKiBAcGFyYW0ge0Nvb3JkaW5hdGV9IGNvb3JkXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBwb3NpdGlvblxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gY29vcmRpbmF0ZVRvVGlsZVBvaW50KHRpbGVDb29yZCwgc291cmNlTWF4Wm9vbSwgY29vcmQpIHtcbiAgICB2YXIgem9vbWVkQ29vcmQgPSBjb29yZC56b29tVG8oTWF0aC5taW4odGlsZUNvb3JkLnosIHNvdXJjZU1heFpvb20pKTtcbiAgICByZXR1cm4ge1xuICAgICAgICB4OiAoem9vbWVkQ29vcmQuY29sdW1uIC0gKHRpbGVDb29yZC54ICsgdGlsZUNvb3JkLncgKiBNYXRoLnBvdygyLCB0aWxlQ29vcmQueikpKSAqIEVYVEVOVCxcbiAgICAgICAgeTogKHpvb21lZENvb3JkLnJvdyAtIHRpbGVDb29yZC55KSAqIEVYVEVOVFxuICAgIH07XG5cbn1cblxuZnVuY3Rpb24gY29tcGFyZUtleVpvb20oYSwgYikge1xuICAgIHJldHVybiAoYSAlIDMyKSAtIChiICUgMzIpO1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwvdXRpbCcpO1xudmFyIEV2ZW50ZWQgPSByZXF1aXJlKCcuLi91dGlsL2V2ZW50ZWQnKTtcbnZhciBTb3VyY2UgPSByZXF1aXJlKCcuL3NvdXJjZScpO1xudmFyIG5vcm1hbGl6ZVVSTCA9IHJlcXVpcmUoJy4uL3V0aWwvbWFwYm94Jykubm9ybWFsaXplVGlsZVVSTDtcblxubW9kdWxlLmV4cG9ydHMgPSBWZWN0b3JUaWxlU291cmNlO1xuXG5mdW5jdGlvbiBWZWN0b3JUaWxlU291cmNlKG9wdGlvbnMpIHtcbiAgICB1dGlsLmV4dGVuZCh0aGlzLCB1dGlsLnBpY2sob3B0aW9ucywgWyd1cmwnLCAndGlsZVNpemUnXSkpO1xuICAgIHRoaXMuX29wdGlvbnMgPSB1dGlsLmV4dGVuZCh7IHR5cGU6ICd2ZWN0b3InIH0sIG9wdGlvbnMpO1xuXG4gICAgaWYgKHRoaXMudGlsZVNpemUgIT09IDUxMikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3ZlY3RvciB0aWxlIHNvdXJjZXMgbXVzdCBoYXZlIGEgdGlsZVNpemUgb2YgNTEyJyk7XG4gICAgfVxuXG4gICAgU291cmNlLl9sb2FkVGlsZUpTT04uY2FsbCh0aGlzLCBvcHRpb25zKTtcbn1cblxuVmVjdG9yVGlsZVNvdXJjZS5wcm90b3R5cGUgPSB1dGlsLmluaGVyaXQoRXZlbnRlZCwge1xuICAgIG1pbnpvb206IDAsXG4gICAgbWF4em9vbTogMjIsXG4gICAgdGlsZVNpemU6IDUxMixcbiAgICByZXBhcnNlT3ZlcnNjYWxlZDogdHJ1ZSxcbiAgICBfbG9hZGVkOiBmYWxzZSxcbiAgICBpc1RpbGVDbGlwcGVkOiB0cnVlLFxuXG4gICAgb25BZGQ6IGZ1bmN0aW9uKG1hcCkge1xuICAgICAgICB0aGlzLm1hcCA9IG1hcDtcbiAgICB9LFxuXG4gICAgbG9hZGVkOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3B5cmFtaWQgJiYgdGhpcy5fcHlyYW1pZC5sb2FkZWQoKTtcbiAgICB9LFxuXG4gICAgdXBkYXRlOiBmdW5jdGlvbih0cmFuc2Zvcm0pIHtcbiAgICAgICAgaWYgKHRoaXMuX3B5cmFtaWQpIHtcbiAgICAgICAgICAgIHRoaXMuX3B5cmFtaWQudXBkYXRlKHRoaXMudXNlZCwgdHJhbnNmb3JtKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICByZWxvYWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5fcHlyYW1pZCkge1xuICAgICAgICAgICAgdGhpcy5fcHlyYW1pZC5yZWxvYWQoKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBzZXJpYWxpemU6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdXRpbC5leHRlbmQoe30sIHRoaXMuX29wdGlvbnMpO1xuICAgIH0sXG5cbiAgICBnZXRWaXNpYmxlQ29vcmRpbmF0ZXM6IFNvdXJjZS5fZ2V0VmlzaWJsZUNvb3JkaW5hdGVzLFxuICAgIGdldFRpbGU6IFNvdXJjZS5fZ2V0VGlsZSxcblxuICAgIHF1ZXJ5UmVuZGVyZWRGZWF0dXJlczogU291cmNlLl9xdWVyeVJlbmRlcmVkVmVjdG9yRmVhdHVyZXMsXG4gICAgcXVlcnlTb3VyY2VGZWF0dXJlczogU291cmNlLl9xdWVyeVNvdXJjZUZlYXR1cmVzLFxuXG4gICAgX2xvYWRUaWxlOiBmdW5jdGlvbih0aWxlKSB7XG4gICAgICAgIHZhciBvdmVyc2NhbGluZyA9IHRpbGUuY29vcmQueiA+IHRoaXMubWF4em9vbSA/IE1hdGgucG93KDIsIHRpbGUuY29vcmQueiAtIHRoaXMubWF4em9vbSkgOiAxO1xuICAgICAgICB2YXIgcGFyYW1zID0ge1xuICAgICAgICAgICAgdXJsOiBub3JtYWxpemVVUkwodGlsZS5jb29yZC51cmwodGhpcy50aWxlcywgdGhpcy5tYXh6b29tKSwgdGhpcy51cmwpLFxuICAgICAgICAgICAgdWlkOiB0aWxlLnVpZCxcbiAgICAgICAgICAgIGNvb3JkOiB0aWxlLmNvb3JkLFxuICAgICAgICAgICAgem9vbTogdGlsZS5jb29yZC56LFxuICAgICAgICAgICAgdGlsZVNpemU6IHRoaXMudGlsZVNpemUgKiBvdmVyc2NhbGluZyxcbiAgICAgICAgICAgIHNvdXJjZTogdGhpcy5pZCxcbiAgICAgICAgICAgIG92ZXJzY2FsaW5nOiBvdmVyc2NhbGluZyxcbiAgICAgICAgICAgIGFuZ2xlOiB0aGlzLm1hcC50cmFuc2Zvcm0uYW5nbGUsXG4gICAgICAgICAgICBwaXRjaDogdGhpcy5tYXAudHJhbnNmb3JtLnBpdGNoLFxuICAgICAgICAgICAgc2hvd0NvbGxpc2lvbkJveGVzOiB0aGlzLm1hcC5zaG93Q29sbGlzaW9uQm94ZXNcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAodGlsZS53b3JrZXJJRCkge1xuICAgICAgICAgICAgcGFyYW1zLnJhd1RpbGVEYXRhID0gdGlsZS5yYXdUaWxlRGF0YTtcbiAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hlci5zZW5kKCdyZWxvYWQgdGlsZScsIHBhcmFtcywgdGhpcy5fdGlsZUxvYWRlZC5iaW5kKHRoaXMsIHRpbGUpLCB0aWxlLndvcmtlcklEKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRpbGUud29ya2VySUQgPSB0aGlzLmRpc3BhdGNoZXIuc2VuZCgnbG9hZCB0aWxlJywgcGFyYW1zLCB0aGlzLl90aWxlTG9hZGVkLmJpbmQodGhpcywgdGlsZSkpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIF90aWxlTG9hZGVkOiBmdW5jdGlvbih0aWxlLCBlcnIsIGRhdGEpIHtcbiAgICAgICAgaWYgKHRpbGUuYWJvcnRlZClcbiAgICAgICAgICAgIHJldHVybjtcblxuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICB0aWxlLmVycm9yZWQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5maXJlKCd0aWxlLmVycm9yJywge3RpbGU6IHRpbGUsIGVycm9yOiBlcnJ9KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRpbGUubG9hZFZlY3RvckRhdGEoZGF0YSk7XG5cbiAgICAgICAgaWYgKHRpbGUucmVkb1doZW5Eb25lKSB7XG4gICAgICAgICAgICB0aWxlLnJlZG9XaGVuRG9uZSA9IGZhbHNlO1xuICAgICAgICAgICAgdGlsZS5yZWRvUGxhY2VtZW50KHRoaXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5maXJlKCd0aWxlLmxvYWQnLCB7dGlsZTogdGlsZX0pO1xuICAgICAgICB0aGlzLmZpcmUoJ3RpbGUuc3RhdHMnLCBkYXRhLmJ1Y2tldFN0YXRzKTtcbiAgICB9LFxuXG4gICAgX2Fib3J0VGlsZTogZnVuY3Rpb24odGlsZSkge1xuICAgICAgICB0aWxlLmFib3J0ZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLmRpc3BhdGNoZXIuc2VuZCgnYWJvcnQgdGlsZScsIHsgdWlkOiB0aWxlLnVpZCwgc291cmNlOiB0aGlzLmlkIH0sIG51bGwsIHRpbGUud29ya2VySUQpO1xuICAgIH0sXG5cbiAgICBfYWRkVGlsZTogZnVuY3Rpb24odGlsZSkge1xuICAgICAgICB0aGlzLmZpcmUoJ3RpbGUuYWRkJywge3RpbGU6IHRpbGV9KTtcbiAgICB9LFxuXG4gICAgX3JlbW92ZVRpbGU6IGZ1bmN0aW9uKHRpbGUpIHtcbiAgICAgICAgdGhpcy5maXJlKCd0aWxlLnJlbW92ZScsIHt0aWxlOiB0aWxlfSk7XG4gICAgfSxcblxuICAgIF91bmxvYWRUaWxlOiBmdW5jdGlvbih0aWxlKSB7XG4gICAgICAgIHRpbGUudW5sb2FkVmVjdG9yRGF0YSh0aGlzLm1hcC5wYWludGVyKTtcbiAgICAgICAgdGhpcy5kaXNwYXRjaGVyLnNlbmQoJ3JlbW92ZSB0aWxlJywgeyB1aWQ6IHRpbGUudWlkLCBzb3VyY2U6IHRoaXMuaWQgfSwgbnVsbCwgdGlsZS53b3JrZXJJRCk7XG4gICAgfSxcblxuICAgIHJlZG9QbGFjZW1lbnQ6IFNvdXJjZS5yZWRvUGxhY2VtZW50LFxuXG4gICAgX3JlZG9UaWxlUGxhY2VtZW50OiBmdW5jdGlvbih0aWxlKSB7XG4gICAgICAgIHRpbGUucmVkb1BsYWNlbWVudCh0aGlzKTtcbiAgICB9XG59KTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsL3V0aWwnKTtcbnZhciBUaWxlID0gcmVxdWlyZSgnLi90aWxlJyk7XG52YXIgVGlsZUNvb3JkID0gcmVxdWlyZSgnLi90aWxlX2Nvb3JkJyk7XG52YXIgTG5nTGF0ID0gcmVxdWlyZSgnLi4vZ2VvL2xuZ19sYXQnKTtcbnZhciBQb2ludCA9IHJlcXVpcmUoJ3BvaW50LWdlb21ldHJ5Jyk7XG52YXIgRXZlbnRlZCA9IHJlcXVpcmUoJy4uL3V0aWwvZXZlbnRlZCcpO1xudmFyIGFqYXggPSByZXF1aXJlKCcuLi91dGlsL2FqYXgnKTtcbnZhciBFWFRFTlQgPSByZXF1aXJlKCcuLi9kYXRhL2J1Y2tldCcpLkVYVEVOVDtcblxubW9kdWxlLmV4cG9ydHMgPSBWaWRlb1NvdXJjZTtcblxuLyoqXG4gKiBDcmVhdGUgYSBWaWRlbyBkYXRhIHNvdXJjZSBpbnN0YW5jZSBnaXZlbiBhbiBvcHRpb25zIG9iamVjdFxuICogQGNsYXNzIFZpZGVvU291cmNlXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiBAcGFyYW0ge0FycmF5PHN0cmluZz59IG9wdGlvbnMudXJscyBBbiBhcnJheSBvZiBVUkxzIHRvIHZpZGVvIGZpbGVzXG4gKiBAcGFyYW0ge0FycmF5fSBvcHRpb25zLmNvb3JkaW5hdGVzIEZvdXIgZ2VvZ3JhcGhpY2FsIFtsbmcsIGxhdF0gY29vcmRpbmF0ZXMgaW4gY2xvY2t3aXNlIG9yZGVyIGRlZmluaW5nIHRoZSBjb3JuZXJzIChzdGFydGluZyB3aXRoIHRvcCBsZWZ0KSBvZiB0aGUgdmlkZW8uIERvZXMgbm90IGhhdmUgdG8gYmUgYSByZWN0YW5nbGUuXG4gKiBAZXhhbXBsZVxuICogdmFyIHNvdXJjZU9iaiA9IG5ldyBtYXBib3hnbC5WaWRlb1NvdXJjZSh7XG4gKiAgICB1cmw6IFtcbiAqICAgICAgICAnaHR0cHM6Ly93d3cubWFwYm94LmNvbS92aWRlb3MvYmFsdGltb3JlLXNtb2tlLm1wNCcsXG4gKiAgICAgICAgJ2h0dHBzOi8vd3d3Lm1hcGJveC5jb20vdmlkZW9zL2JhbHRpbW9yZS1zbW9rZS53ZWJtJ1xuICogICAgXSxcbiAqICAgIGNvb3JkaW5hdGVzOiBbXG4gKiAgICAgICAgWy03Ni41NDMzNTczNzIyODM5NCwgMzkuMTg1Nzk5MDcyMjk3NDhdLFxuICogICAgICAgIFstNzYuNTI4MDM2NTk0MzkwODcsIDM5LjE4MzgzNjQ4NDc1ODddLFxuICogICAgICAgIFstNzYuNTI5NTM4NjMxNDM5MiwgMzkuMTc2ODMzOTI1MDc2MDZdLFxuICogICAgICAgIFstNzYuNTQ1MjAyNzMyMDg2MTgsIDM5LjE3ODc2MzQ0MTA2NjQyXVxuICogICAgXVxuICogfSk7XG4gKiBtYXAuYWRkU291cmNlKCdzb21lIGlkJywgc291cmNlT2JqKTsgLy8gYWRkXG4gKiBtYXAucmVtb3ZlU291cmNlKCdzb21lIGlkJyk7ICAvLyByZW1vdmVcbiAqL1xuZnVuY3Rpb24gVmlkZW9Tb3VyY2Uob3B0aW9ucykge1xuICAgIHRoaXMudXJscyA9IG9wdGlvbnMudXJscztcbiAgICB0aGlzLmNvb3JkaW5hdGVzID0gb3B0aW9ucy5jb29yZGluYXRlcztcblxuICAgIGFqYXguZ2V0VmlkZW8ob3B0aW9ucy51cmxzLCBmdW5jdGlvbihlcnIsIHZpZGVvKSB7XG4gICAgICAgIC8vIEBUT0RPIGhhbmRsZSBlcnJvcnMgdmlhIGV2ZW50LlxuICAgICAgICBpZiAoZXJyKSByZXR1cm47XG5cbiAgICAgICAgdGhpcy52aWRlbyA9IHZpZGVvO1xuICAgICAgICB0aGlzLnZpZGVvLmxvb3AgPSB0cnVlO1xuXG4gICAgICAgIHZhciBsb29wSUQ7XG5cbiAgICAgICAgLy8gc3RhcnQgcmVwYWludGluZyB3aGVuIHZpZGVvIHN0YXJ0cyBwbGF5aW5nXG4gICAgICAgIHRoaXMudmlkZW8uYWRkRXZlbnRMaXN0ZW5lcigncGxheWluZycsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgbG9vcElEID0gdGhpcy5tYXAuc3R5bGUuYW5pbWF0aW9uTG9vcC5zZXQoSW5maW5pdHkpO1xuICAgICAgICAgICAgdGhpcy5tYXAuX3JlcmVuZGVyKCk7XG4gICAgICAgIH0uYmluZCh0aGlzKSk7XG5cbiAgICAgICAgLy8gc3RvcCByZXBhaW50aW5nIHdoZW4gdmlkZW8gc3RvcHNcbiAgICAgICAgdGhpcy52aWRlby5hZGRFdmVudExpc3RlbmVyKCdwYXVzZScsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdGhpcy5tYXAuc3R5bGUuYW5pbWF0aW9uTG9vcC5jYW5jZWwobG9vcElEKTtcbiAgICAgICAgfS5iaW5kKHRoaXMpKTtcblxuICAgICAgICB0aGlzLl9sb2FkZWQgPSB0cnVlO1xuXG4gICAgICAgIGlmICh0aGlzLm1hcCkge1xuICAgICAgICAgICAgdGhpcy52aWRlby5wbGF5KCk7XG4gICAgICAgICAgICB0aGlzLnNldENvb3JkaW5hdGVzKG9wdGlvbnMuY29vcmRpbmF0ZXMpO1xuICAgICAgICB9XG4gICAgfS5iaW5kKHRoaXMpKTtcbn1cblxuVmlkZW9Tb3VyY2UucHJvdG90eXBlID0gdXRpbC5pbmhlcml0KEV2ZW50ZWQsIC8qKiBAbGVuZHMgVmlkZW9Tb3VyY2UucHJvdG90eXBlICove1xuICAgIHJvdW5kWm9vbTogdHJ1ZSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybiB0aGUgSFRNTCB2aWRlbyBlbGVtZW50LlxuICAgICAqXG4gICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgKi9cbiAgICBnZXRWaWRlbzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZpZGVvO1xuICAgIH0sXG5cbiAgICBvbkFkZDogZnVuY3Rpb24obWFwKSB7XG4gICAgICAgIHRoaXMubWFwID0gbWFwO1xuICAgICAgICBpZiAodGhpcy52aWRlbykge1xuICAgICAgICAgICAgdGhpcy52aWRlby5wbGF5KCk7XG4gICAgICAgICAgICB0aGlzLnNldENvb3JkaW5hdGVzKHRoaXMuY29vcmRpbmF0ZXMpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSB2aWRlbyBjb29yZGluYXRlcyBhbmQgcmVyZW5kZXIgbWFwXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBjb29yZGluYXRlcyBGb3VyIGdlb2dyYXBoaWNhbCBbbG5nLCBsYXRdIGNvb3JkaW5hdGVzIGluIGNsb2Nrd2lzZSBvcmRlciBkZWZpbmluZyB0aGUgY29ybmVycyAoc3RhcnRpbmcgd2l0aCB0b3AgbGVmdCkgb2YgdGhlIHZpZGVvLiBEb2VzIG5vdCBoYXZlIHRvIGJlIGEgcmVjdGFuZ2xlLlxuICAgICAqIEByZXR1cm5zIHtWaWRlb1NvdXJjZX0gdGhpc1xuICAgICAqL1xuICAgIHNldENvb3JkaW5hdGVzOiBmdW5jdGlvbihjb29yZGluYXRlcykge1xuICAgICAgICB0aGlzLmNvb3JkaW5hdGVzID0gY29vcmRpbmF0ZXM7XG5cbiAgICAgICAgLy8gQ2FsY3VsYXRlIHdoaWNoIG1lcmNhdG9yIHRpbGUgaXMgc3VpdGFibGUgZm9yIHJlbmRlcmluZyB0aGUgdmlkZW8gaW5cbiAgICAgICAgLy8gYW5kIGNyZWF0ZSBhIGJ1ZmZlciB3aXRoIHRoZSBjb3JuZXIgY29vcmRpbmF0ZXMuIFRoZXNlIGNvb3JkaW5hdGVzXG4gICAgICAgIC8vIG1heSBiZSBvdXRzaWRlIHRoZSB0aWxlLCBiZWNhdXNlIHJhc3RlciB0aWxlcyBhcmVuJ3QgY2xpcHBlZCB3aGVuIHJlbmRlcmluZy5cblxuICAgICAgICB2YXIgbWFwID0gdGhpcy5tYXA7XG4gICAgICAgIHZhciBjb3JuZXJaMENvb3JkcyA9IGNvb3JkaW5hdGVzLm1hcChmdW5jdGlvbihjb29yZCkge1xuICAgICAgICAgICAgcmV0dXJuIG1hcC50cmFuc2Zvcm0ubG9jYXRpb25Db29yZGluYXRlKExuZ0xhdC5jb252ZXJ0KGNvb3JkKSkuem9vbVRvKDApO1xuICAgICAgICB9KTtcblxuICAgICAgICB2YXIgY2VudGVyQ29vcmQgPSB0aGlzLmNlbnRlckNvb3JkID0gdXRpbC5nZXRDb29yZGluYXRlc0NlbnRlcihjb3JuZXJaMENvb3Jkcyk7XG4gICAgICAgIGNlbnRlckNvb3JkLmNvbHVtbiA9IE1hdGgucm91bmQoY2VudGVyQ29vcmQuY29sdW1uKTtcbiAgICAgICAgY2VudGVyQ29vcmQucm93ID0gTWF0aC5yb3VuZChjZW50ZXJDb29yZC5yb3cpO1xuXG5cbiAgICAgICAgdmFyIHRpbGVDb29yZHMgPSBjb3JuZXJaMENvb3Jkcy5tYXAoZnVuY3Rpb24oY29vcmQpIHtcbiAgICAgICAgICAgIHZhciB6b29tZWRDb29yZCA9IGNvb3JkLnpvb21UbyhjZW50ZXJDb29yZC56b29tKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUG9pbnQoXG4gICAgICAgICAgICAgICAgTWF0aC5yb3VuZCgoem9vbWVkQ29vcmQuY29sdW1uIC0gY2VudGVyQ29vcmQuY29sdW1uKSAqIEVYVEVOVCksXG4gICAgICAgICAgICAgICAgTWF0aC5yb3VuZCgoem9vbWVkQ29vcmQucm93IC0gY2VudGVyQ29vcmQucm93KSAqIEVYVEVOVCkpO1xuICAgICAgICB9KTtcblxuICAgICAgICB2YXIgZ2wgPSBtYXAucGFpbnRlci5nbDtcbiAgICAgICAgdmFyIG1heEludDE2ID0gMzI3Njc7XG4gICAgICAgIHZhciBhcnJheSA9IG5ldyBJbnQxNkFycmF5KFtcbiAgICAgICAgICAgIHRpbGVDb29yZHNbMF0ueCwgdGlsZUNvb3Jkc1swXS55LCAwLCAwLFxuICAgICAgICAgICAgdGlsZUNvb3Jkc1sxXS54LCB0aWxlQ29vcmRzWzFdLnksIG1heEludDE2LCAwLFxuICAgICAgICAgICAgdGlsZUNvb3Jkc1szXS54LCB0aWxlQ29vcmRzWzNdLnksIDAsIG1heEludDE2LFxuICAgICAgICAgICAgdGlsZUNvb3Jkc1syXS54LCB0aWxlQ29vcmRzWzJdLnksIG1heEludDE2LCBtYXhJbnQxNlxuICAgICAgICBdKTtcblxuICAgICAgICB0aGlzLnRpbGUgPSBuZXcgVGlsZShuZXcgVGlsZUNvb3JkKGNlbnRlckNvb3JkLnpvb20sIGNlbnRlckNvb3JkLmNvbHVtbiwgY2VudGVyQ29vcmQucm93KSk7XG4gICAgICAgIHRoaXMudGlsZS5idWNrZXRzID0ge307XG5cbiAgICAgICAgdGhpcy50aWxlLmJvdW5kc0J1ZmZlciA9IGdsLmNyZWF0ZUJ1ZmZlcigpO1xuICAgICAgICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgdGhpcy50aWxlLmJvdW5kc0J1ZmZlcik7XG4gICAgICAgIGdsLmJ1ZmZlckRhdGEoZ2wuQVJSQVlfQlVGRkVSLCBhcnJheSwgZ2wuU1RBVElDX0RSQVcpO1xuXG4gICAgICAgIHRoaXMuZmlyZSgnY2hhbmdlJyk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIGxvYWRlZDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZpZGVvICYmIHRoaXMudmlkZW8ucmVhZHlTdGF0ZSA+PSAyO1xuICAgIH0sXG5cbiAgICB1cGRhdGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAvLyBub29wXG4gICAgfSxcblxuICAgIHJlbG9hZDogZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vIG5vb3BcbiAgICB9LFxuXG4gICAgcHJlcGFyZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICghdGhpcy5fbG9hZGVkKSByZXR1cm47XG4gICAgICAgIGlmICh0aGlzLnZpZGVvLnJlYWR5U3RhdGUgPCAyKSByZXR1cm47IC8vIG5vdCBlbm91Z2ggZGF0YSBmb3IgY3VycmVudCBwb3NpdGlvblxuXG4gICAgICAgIHZhciBnbCA9IHRoaXMubWFwLnBhaW50ZXIuZ2w7XG4gICAgICAgIGlmICghdGhpcy50aWxlLnRleHR1cmUpIHtcbiAgICAgICAgICAgIHRoaXMudGlsZS50ZXh0dXJlID0gZ2wuY3JlYXRlVGV4dHVyZSgpO1xuICAgICAgICAgICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGhpcy50aWxlLnRleHR1cmUpO1xuICAgICAgICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfUywgZ2wuQ0xBTVBfVE9fRURHRSk7XG4gICAgICAgICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9ULCBnbC5DTEFNUF9UT19FREdFKTtcbiAgICAgICAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NSU5fRklMVEVSLCBnbC5MSU5FQVIpO1xuICAgICAgICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01BR19GSUxURVIsIGdsLkxJTkVBUik7XG4gICAgICAgICAgICBnbC50ZXhJbWFnZTJEKGdsLlRFWFRVUkVfMkQsIDAsIGdsLlJHQkEsIGdsLlJHQkEsIGdsLlVOU0lHTkVEX0JZVEUsIHRoaXMudmlkZW8pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGhpcy50aWxlLnRleHR1cmUpO1xuICAgICAgICAgICAgZ2wudGV4U3ViSW1hZ2UyRChnbC5URVhUVVJFXzJELCAwLCAwLCAwLCBnbC5SR0JBLCBnbC5VTlNJR05FRF9CWVRFLCB0aGlzLnZpZGVvKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2N1cnJlbnRUaW1lID0gdGhpcy52aWRlby5jdXJyZW50VGltZTtcbiAgICB9LFxuXG4gICAgZ2V0VmlzaWJsZUNvb3JkaW5hdGVzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMudGlsZSkgcmV0dXJuIFt0aGlzLnRpbGUuY29vcmRdO1xuICAgICAgICBlbHNlIHJldHVybiBbXTtcbiAgICB9LFxuXG4gICAgZ2V0VGlsZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRpbGU7XG4gICAgfSxcblxuICAgIHNlcmlhbGl6ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiAndmlkZW8nLFxuICAgICAgICAgICAgdXJsczogdGhpcy51cmxzLFxuICAgICAgICAgICAgY29vcmRpbmF0ZXM6IHRoaXMuY29vcmRpbmF0ZXNcbiAgICAgICAgfTtcbiAgICB9XG59KTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIEFjdG9yID0gcmVxdWlyZSgnLi4vdXRpbC9hY3RvcicpO1xudmFyIFdvcmtlclRpbGUgPSByZXF1aXJlKCcuL3dvcmtlcl90aWxlJyk7XG52YXIgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwvdXRpbCcpO1xudmFyIGFqYXggPSByZXF1aXJlKCcuLi91dGlsL2FqYXgnKTtcbnZhciB2dCA9IHJlcXVpcmUoJ3ZlY3Rvci10aWxlJyk7XG52YXIgUHJvdG9idWYgPSByZXF1aXJlKCdwYmYnKTtcbnZhciBzdXBlcmNsdXN0ZXIgPSByZXF1aXJlKCdzdXBlcmNsdXN0ZXInKTtcblxudmFyIGdlb2pzb252dCA9IHJlcXVpcmUoJ2dlb2pzb24tdnQnKTtcbnZhciByZXdpbmQgPSByZXF1aXJlKCdnZW9qc29uLXJld2luZCcpO1xudmFyIEdlb0pTT05XcmFwcGVyID0gcmVxdWlyZSgnLi9nZW9qc29uX3dyYXBwZXInKTtcbnZhciB2dHBiZiA9IHJlcXVpcmUoJ3Z0LXBiZicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHNlbGYpIHtcbiAgICByZXR1cm4gbmV3IFdvcmtlcihzZWxmKTtcbn07XG5cbmZ1bmN0aW9uIFdvcmtlcihzZWxmKSB7XG4gICAgdGhpcy5zZWxmID0gc2VsZjtcbiAgICB0aGlzLmFjdG9yID0gbmV3IEFjdG9yKHNlbGYsIHRoaXMpO1xuICAgIHRoaXMubG9hZGluZyA9IHt9O1xuXG4gICAgdGhpcy5sb2FkZWQgPSB7fTtcbiAgICB0aGlzLmxheWVycyA9IFtdO1xuICAgIHRoaXMuZ2VvSlNPTkluZGV4ZXMgPSB7fTtcbn1cblxudXRpbC5leHRlbmQoV29ya2VyLnByb3RvdHlwZSwge1xuICAgICdzZXQgbGF5ZXJzJzogZnVuY3Rpb24obGF5ZXJzKSB7XG4gICAgICAgIHRoaXMubGF5ZXJzID0gbGF5ZXJzO1xuICAgIH0sXG5cbiAgICAndXBkYXRlIGxheWVycyc6IGZ1bmN0aW9uKGxheWVycykge1xuICAgICAgICB2YXIgbGF5ZXJzQnlJZCA9IHt9O1xuICAgICAgICB2YXIgaTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxheWVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGF5ZXJzQnlJZFtsYXllcnNbaV0uaWRdID0gbGF5ZXJzW2ldO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLmxheWVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdGhpcy5sYXllcnNbaV0gPSBsYXllcnNCeUlkW3RoaXMubGF5ZXJzW2ldLmlkXSB8fCB0aGlzLmxheWVyc1tpXTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAnbG9hZCB0aWxlJzogZnVuY3Rpb24ocGFyYW1zLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgc291cmNlID0gcGFyYW1zLnNvdXJjZSxcbiAgICAgICAgICAgIHVpZCA9IHBhcmFtcy51aWQ7XG5cbiAgICAgICAgaWYgKCF0aGlzLmxvYWRpbmdbc291cmNlXSlcbiAgICAgICAgICAgIHRoaXMubG9hZGluZ1tzb3VyY2VdID0ge307XG5cblxuICAgICAgICB2YXIgdGlsZSA9IHRoaXMubG9hZGluZ1tzb3VyY2VdW3VpZF0gPSBuZXcgV29ya2VyVGlsZShwYXJhbXMpO1xuXG4gICAgICAgIHRpbGUueGhyID0gYWpheC5nZXRBcnJheUJ1ZmZlcihwYXJhbXMudXJsLCBkb25lLmJpbmQodGhpcykpO1xuXG4gICAgICAgIGZ1bmN0aW9uIGRvbmUoZXJyLCBkYXRhKSB7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5sb2FkaW5nW3NvdXJjZV1bdWlkXTtcblxuICAgICAgICAgICAgaWYgKGVycikgcmV0dXJuIGNhbGxiYWNrKGVycik7XG5cbiAgICAgICAgICAgIHRpbGUuZGF0YSA9IG5ldyB2dC5WZWN0b3JUaWxlKG5ldyBQcm90b2J1ZihuZXcgVWludDhBcnJheShkYXRhKSkpO1xuICAgICAgICAgICAgdGlsZS5wYXJzZSh0aWxlLmRhdGEsIHRoaXMubGF5ZXJzLCB0aGlzLmFjdG9yLCBkYXRhLCBjYWxsYmFjayk7XG5cbiAgICAgICAgICAgIHRoaXMubG9hZGVkW3NvdXJjZV0gPSB0aGlzLmxvYWRlZFtzb3VyY2VdIHx8IHt9O1xuICAgICAgICAgICAgdGhpcy5sb2FkZWRbc291cmNlXVt1aWRdID0gdGlsZTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAncmVsb2FkIHRpbGUnOiBmdW5jdGlvbihwYXJhbXMsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBsb2FkZWQgPSB0aGlzLmxvYWRlZFtwYXJhbXMuc291cmNlXSxcbiAgICAgICAgICAgIHVpZCA9IHBhcmFtcy51aWQ7XG4gICAgICAgIGlmIChsb2FkZWQgJiYgbG9hZGVkW3VpZF0pIHtcbiAgICAgICAgICAgIHZhciB0aWxlID0gbG9hZGVkW3VpZF07XG4gICAgICAgICAgICB0aWxlLnBhcnNlKHRpbGUuZGF0YSwgdGhpcy5sYXllcnMsIHRoaXMuYWN0b3IsIHBhcmFtcy5yYXdUaWxlRGF0YSwgY2FsbGJhY2spO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgICdhYm9ydCB0aWxlJzogZnVuY3Rpb24ocGFyYW1zKSB7XG4gICAgICAgIHZhciBsb2FkaW5nID0gdGhpcy5sb2FkaW5nW3BhcmFtcy5zb3VyY2VdLFxuICAgICAgICAgICAgdWlkID0gcGFyYW1zLnVpZDtcbiAgICAgICAgaWYgKGxvYWRpbmcgJiYgbG9hZGluZ1t1aWRdKSB7XG4gICAgICAgICAgICBsb2FkaW5nW3VpZF0ueGhyLmFib3J0KCk7XG4gICAgICAgICAgICBkZWxldGUgbG9hZGluZ1t1aWRdO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgICdyZW1vdmUgdGlsZSc6IGZ1bmN0aW9uKHBhcmFtcykge1xuICAgICAgICB2YXIgbG9hZGVkID0gdGhpcy5sb2FkZWRbcGFyYW1zLnNvdXJjZV0sXG4gICAgICAgICAgICB1aWQgPSBwYXJhbXMudWlkO1xuICAgICAgICBpZiAobG9hZGVkICYmIGxvYWRlZFt1aWRdKSB7XG4gICAgICAgICAgICBkZWxldGUgbG9hZGVkW3VpZF07XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgJ3JlZG8gcGxhY2VtZW50JzogZnVuY3Rpb24ocGFyYW1zLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgbG9hZGVkID0gdGhpcy5sb2FkZWRbcGFyYW1zLnNvdXJjZV0sXG4gICAgICAgICAgICBsb2FkaW5nID0gdGhpcy5sb2FkaW5nW3BhcmFtcy5zb3VyY2VdLFxuICAgICAgICAgICAgdWlkID0gcGFyYW1zLnVpZDtcblxuICAgICAgICBpZiAobG9hZGVkICYmIGxvYWRlZFt1aWRdKSB7XG4gICAgICAgICAgICB2YXIgdGlsZSA9IGxvYWRlZFt1aWRdO1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHRpbGUucmVkb1BsYWNlbWVudChwYXJhbXMuYW5nbGUsIHBhcmFtcy5waXRjaCwgcGFyYW1zLnNob3dDb2xsaXNpb25Cb3hlcyk7XG5cbiAgICAgICAgICAgIGlmIChyZXN1bHQucmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgcmVzdWx0LnJlc3VsdCwgcmVzdWx0LnRyYW5zZmVyYWJsZXMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH0gZWxzZSBpZiAobG9hZGluZyAmJiBsb2FkaW5nW3VpZF0pIHtcbiAgICAgICAgICAgIGxvYWRpbmdbdWlkXS5hbmdsZSA9IHBhcmFtcy5hbmdsZTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAncGFyc2UgZ2VvanNvbic6IGZ1bmN0aW9uKHBhcmFtcywgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIGluZGV4RGF0YSA9IGZ1bmN0aW9uKGVyciwgZGF0YSkge1xuICAgICAgICAgICAgcmV3aW5kKGRhdGEsIHRydWUpO1xuICAgICAgICAgICAgaWYgKGVycikgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGRhdGEgIT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2sobmV3IEVycm9yKFwiSW5wdXQgZGF0YSBpcyBub3QgYSB2YWxpZCBHZW9KU09OIG9iamVjdC5cIikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB0aGlzLmdlb0pTT05JbmRleGVzW3BhcmFtcy5zb3VyY2VdID0gcGFyYW1zLmNsdXN0ZXIgP1xuICAgICAgICAgICAgICAgICAgICBzdXBlcmNsdXN0ZXIocGFyYW1zLnN1cGVyY2x1c3Rlck9wdGlvbnMpLmxvYWQoZGF0YS5mZWF0dXJlcykgOlxuICAgICAgICAgICAgICAgICAgICBnZW9qc29udnQoZGF0YSwgcGFyYW1zLmdlb2pzb25WdE9wdGlvbnMpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYWxsYmFjayhudWxsKTtcbiAgICAgICAgfS5iaW5kKHRoaXMpO1xuXG4gICAgICAgIC8vIE5vdCwgYmVjYXVzZSBvZiBzYW1lIG9yaWdpbiBpc3N1ZXMsIHVybHMgbXVzdCBlaXRoZXIgaW5jbHVkZSBhblxuICAgICAgICAvLyBleHBsaWNpdCBvcmlnaW4gb3IgYWJzb2x1dGUgcGF0aC5cbiAgICAgICAgLy8gaWU6IC9mb28vYmFyLmpzb24gb3IgaHR0cDovL2V4YW1wbGUuY29tL2Jhci5qc29uXG4gICAgICAgIC8vIGJ1dCBub3QgLi4vZm9vL2Jhci5qc29uXG4gICAgICAgIGlmIChwYXJhbXMudXJsKSB7XG4gICAgICAgICAgICBhamF4LmdldEpTT04ocGFyYW1zLnVybCwgaW5kZXhEYXRhKTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgcGFyYW1zLmRhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBpbmRleERhdGEobnVsbCwgSlNPTi5wYXJzZShwYXJhbXMuZGF0YSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG5ldyBFcnJvcihcIklucHV0IGRhdGEgaXMgbm90IGEgdmFsaWQgR2VvSlNPTiBvYmplY3QuXCIpKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAnbG9hZCBnZW9qc29uIHRpbGUnOiBmdW5jdGlvbihwYXJhbXMsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBzb3VyY2UgPSBwYXJhbXMuc291cmNlLFxuICAgICAgICAgICAgY29vcmQgPSBwYXJhbXMuY29vcmQ7XG5cbiAgICAgICAgaWYgKCF0aGlzLmdlb0pTT05JbmRleGVzW3NvdXJjZV0pIHJldHVybiBjYWxsYmFjayhudWxsLCBudWxsKTsgLy8gd2UgY291bGRuJ3QgbG9hZCB0aGUgZmlsZVxuXG4gICAgICAgIC8vIGNvbnNvbGUudGltZSgndGlsZSAnICsgY29vcmQueiArICcgJyArIGNvb3JkLnggKyAnICcgKyBjb29yZC55KTtcblxuICAgICAgICB2YXIgZ2VvSlNPTlRpbGUgPSB0aGlzLmdlb0pTT05JbmRleGVzW3NvdXJjZV0uZ2V0VGlsZShNYXRoLm1pbihjb29yZC56LCBwYXJhbXMubWF4Wm9vbSksIGNvb3JkLngsIGNvb3JkLnkpO1xuXG4gICAgICAgIC8vIGNvbnNvbGUudGltZUVuZCgndGlsZSAnICsgY29vcmQueiArICcgJyArIGNvb3JkLnggKyAnICcgKyBjb29yZC55KTtcblxuICAgICAgICAvLyBpZiAoIWdlb0pTT05UaWxlKSBjb25zb2xlLmxvZygnbm90IGZvdW5kJywgdGhpcy5nZW9KU09OSW5kZXhlc1tzb3VyY2VdLCBjb29yZCk7XG5cbiAgICAgICAgdmFyIHRpbGUgPSBnZW9KU09OVGlsZSA/IG5ldyBXb3JrZXJUaWxlKHBhcmFtcykgOiB1bmRlZmluZWQ7XG5cbiAgICAgICAgdGhpcy5sb2FkZWRbc291cmNlXSA9IHRoaXMubG9hZGVkW3NvdXJjZV0gfHwge307XG4gICAgICAgIHRoaXMubG9hZGVkW3NvdXJjZV1bcGFyYW1zLnVpZF0gPSB0aWxlO1xuXG4gICAgICAgIGlmIChnZW9KU09OVGlsZSkge1xuICAgICAgICAgICAgdmFyIGdlb2pzb25XcmFwcGVyID0gbmV3IEdlb0pTT05XcmFwcGVyKGdlb0pTT05UaWxlLmZlYXR1cmVzKTtcbiAgICAgICAgICAgIGdlb2pzb25XcmFwcGVyLm5hbWUgPSAnX2dlb2pzb25UaWxlTGF5ZXInO1xuICAgICAgICAgICAgdmFyIHJhd1RpbGVEYXRhID0gdnRwYmYoeyBsYXllcnM6IHsgJ19nZW9qc29uVGlsZUxheWVyJzogZ2VvanNvbldyYXBwZXIgfX0pLmJ1ZmZlcjtcbiAgICAgICAgICAgIHRpbGUucGFyc2UoZ2VvanNvbldyYXBwZXIsIHRoaXMubGF5ZXJzLCB0aGlzLmFjdG9yLCByYXdUaWxlRGF0YSwgY2FsbGJhY2spO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwsIG51bGwpOyAvLyBub3RoaW5nIGluIHRoZSBnaXZlbiB0aWxlXG4gICAgICAgIH1cbiAgICB9XG59KTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIEZlYXR1cmVJbmRleCA9IHJlcXVpcmUoJy4uL2RhdGEvZmVhdHVyZV9pbmRleCcpO1xudmFyIENvbGxpc2lvblRpbGUgPSByZXF1aXJlKCcuLi9zeW1ib2wvY29sbGlzaW9uX3RpbGUnKTtcbnZhciBCdWNrZXQgPSByZXF1aXJlKCcuLi9kYXRhL2J1Y2tldCcpO1xudmFyIENvbGxpc2lvbkJveEFycmF5ID0gcmVxdWlyZSgnLi4vc3ltYm9sL2NvbGxpc2lvbl9ib3gnKTtcbnZhciBEaWN0aW9uYXJ5Q29kZXIgPSByZXF1aXJlKCcuLi91dGlsL2RpY3Rpb25hcnlfY29kZXInKTtcblxubW9kdWxlLmV4cG9ydHMgPSBXb3JrZXJUaWxlO1xuXG5mdW5jdGlvbiBXb3JrZXJUaWxlKHBhcmFtcykge1xuICAgIHRoaXMuY29vcmQgPSBwYXJhbXMuY29vcmQ7XG4gICAgdGhpcy51aWQgPSBwYXJhbXMudWlkO1xuICAgIHRoaXMuem9vbSA9IHBhcmFtcy56b29tO1xuICAgIHRoaXMudGlsZVNpemUgPSBwYXJhbXMudGlsZVNpemU7XG4gICAgdGhpcy5zb3VyY2UgPSBwYXJhbXMuc291cmNlO1xuICAgIHRoaXMub3ZlcnNjYWxpbmcgPSBwYXJhbXMub3ZlcnNjYWxpbmc7XG4gICAgdGhpcy5hbmdsZSA9IHBhcmFtcy5hbmdsZTtcbiAgICB0aGlzLnBpdGNoID0gcGFyYW1zLnBpdGNoO1xuICAgIHRoaXMuc2hvd0NvbGxpc2lvbkJveGVzID0gcGFyYW1zLnNob3dDb2xsaXNpb25Cb3hlcztcbn1cblxuV29ya2VyVGlsZS5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbihkYXRhLCBsYXllcnMsIGFjdG9yLCByYXdUaWxlRGF0YSwgY2FsbGJhY2spIHtcblxuICAgIHRoaXMuc3RhdHVzID0gJ3BhcnNpbmcnO1xuICAgIHRoaXMuZGF0YSA9IGRhdGE7XG5cbiAgICB0aGlzLmNvbGxpc2lvbkJveEFycmF5ID0gbmV3IENvbGxpc2lvbkJveEFycmF5KCk7XG4gICAgdmFyIGNvbGxpc2lvblRpbGUgPSBuZXcgQ29sbGlzaW9uVGlsZSh0aGlzLmFuZ2xlLCB0aGlzLnBpdGNoLCB0aGlzLmNvbGxpc2lvbkJveEFycmF5KTtcbiAgICB2YXIgZmVhdHVyZUluZGV4ID0gbmV3IEZlYXR1cmVJbmRleCh0aGlzLmNvb3JkLCB0aGlzLm92ZXJzY2FsaW5nLCBjb2xsaXNpb25UaWxlLCBkYXRhLmxheWVycyk7XG4gICAgdmFyIHNvdXJjZUxheWVyQ29kZXIgPSBuZXcgRGljdGlvbmFyeUNvZGVyKGRhdGEubGF5ZXJzID8gT2JqZWN0LmtleXMoZGF0YS5sYXllcnMpLnNvcnQoKSA6IFsnX2dlb2pzb25UaWxlTGF5ZXInXSk7XG5cbiAgICB2YXIgc3RhdHMgPSB7IF90b3RhbDogMCB9O1xuXG4gICAgdmFyIHRpbGUgPSB0aGlzO1xuICAgIHZhciBidWNrZXRzQnlJZCA9IHt9O1xuICAgIHZhciBidWNrZXRzQnlTb3VyY2VMYXllciA9IHt9O1xuICAgIHZhciBpO1xuICAgIHZhciBsYXllcjtcbiAgICB2YXIgc291cmNlTGF5ZXJJZDtcbiAgICB2YXIgYnVja2V0O1xuXG4gICAgLy8gTWFwIG5vbi1yZWYgbGF5ZXJzIHRvIGJ1Y2tldHMuXG4gICAgZm9yIChpID0gMDsgaSA8IGxheWVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICBsYXllciA9IGxheWVyc1tpXTtcblxuICAgICAgICBpZiAobGF5ZXIuc291cmNlICE9PSB0aGlzLnNvdXJjZSkgY29udGludWU7XG4gICAgICAgIGlmIChsYXllci5yZWYpIGNvbnRpbnVlO1xuICAgICAgICBpZiAobGF5ZXIubWluem9vbSAmJiB0aGlzLnpvb20gPCBsYXllci5taW56b29tKSBjb250aW51ZTtcbiAgICAgICAgaWYgKGxheWVyLm1heHpvb20gJiYgdGhpcy56b29tID49IGxheWVyLm1heHpvb20pIGNvbnRpbnVlO1xuICAgICAgICBpZiAobGF5ZXIubGF5b3V0ICYmIGxheWVyLmxheW91dC52aXNpYmlsaXR5ID09PSAnbm9uZScpIGNvbnRpbnVlO1xuXG4gICAgICAgIGJ1Y2tldCA9IEJ1Y2tldC5jcmVhdGUoe1xuICAgICAgICAgICAgbGF5ZXI6IGxheWVyLFxuICAgICAgICAgICAgaW5kZXg6IGksXG4gICAgICAgICAgICB6b29tOiB0aGlzLnpvb20sXG4gICAgICAgICAgICBvdmVyc2NhbGluZzogdGhpcy5vdmVyc2NhbGluZyxcbiAgICAgICAgICAgIHNob3dDb2xsaXNpb25Cb3hlczogdGhpcy5zaG93Q29sbGlzaW9uQm94ZXMsXG4gICAgICAgICAgICBjb2xsaXNpb25Cb3hBcnJheTogdGhpcy5jb2xsaXNpb25Cb3hBcnJheSxcbiAgICAgICAgICAgIHNvdXJjZUxheWVySW5kZXg6IHNvdXJjZUxheWVyQ29kZXIuZW5jb2RlKGxheWVyWydzb3VyY2UtbGF5ZXInXSB8fCAnX2dlb2pzb25UaWxlTGF5ZXInKVxuICAgICAgICB9KTtcbiAgICAgICAgYnVja2V0LmNyZWF0ZUZpbHRlcigpO1xuXG4gICAgICAgIGJ1Y2tldHNCeUlkW2xheWVyLmlkXSA9IGJ1Y2tldDtcblxuICAgICAgICBpZiAoZGF0YS5sYXllcnMpIHsgLy8gdmVjdG9ydGlsZVxuICAgICAgICAgICAgc291cmNlTGF5ZXJJZCA9IGxheWVyWydzb3VyY2UtbGF5ZXInXTtcbiAgICAgICAgICAgIGJ1Y2tldHNCeVNvdXJjZUxheWVyW3NvdXJjZUxheWVySWRdID0gYnVja2V0c0J5U291cmNlTGF5ZXJbc291cmNlTGF5ZXJJZF0gfHwge307XG4gICAgICAgICAgICBidWNrZXRzQnlTb3VyY2VMYXllcltzb3VyY2VMYXllcklkXVtsYXllci5pZF0gPSBidWNrZXQ7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBJbmRleCByZWYgbGF5ZXJzLlxuICAgIGZvciAoaSA9IDA7IGkgPCBsYXllcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGF5ZXIgPSBsYXllcnNbaV07XG4gICAgICAgIGlmIChsYXllci5zb3VyY2UgPT09IHRoaXMuc291cmNlICYmIGxheWVyLnJlZiAmJiBidWNrZXRzQnlJZFtsYXllci5yZWZdKSB7XG4gICAgICAgICAgICBidWNrZXRzQnlJZFtsYXllci5yZWZdLmxheWVySURzLnB1c2gobGF5ZXIuaWQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gcmVhZCBlYWNoIGxheWVyLCBhbmQgc29ydCBpdHMgZmVhdHVyZXMgaW50byBidWNrZXRzXG4gICAgaWYgKGRhdGEubGF5ZXJzKSB7IC8vIHZlY3RvcnRpbGVcbiAgICAgICAgZm9yIChzb3VyY2VMYXllcklkIGluIGJ1Y2tldHNCeVNvdXJjZUxheWVyKSB7XG4gICAgICAgICAgICBsYXllciA9IGRhdGEubGF5ZXJzW3NvdXJjZUxheWVySWRdO1xuICAgICAgICAgICAgaWYgKGxheWVyKSB7XG4gICAgICAgICAgICAgICAgc29ydExheWVySW50b0J1Y2tldHMobGF5ZXIsIGJ1Y2tldHNCeVNvdXJjZUxheWVyW3NvdXJjZUxheWVySWRdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0gZWxzZSB7IC8vIGdlb2pzb25cbiAgICAgICAgc29ydExheWVySW50b0J1Y2tldHMoZGF0YSwgYnVja2V0c0J5SWQpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNvcnRMYXllckludG9CdWNrZXRzKGxheWVyLCBidWNrZXRzKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGF5ZXIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBmZWF0dXJlID0gbGF5ZXIuZmVhdHVyZShpKTtcbiAgICAgICAgICAgIGZlYXR1cmUuaW5kZXggPSBpO1xuICAgICAgICAgICAgZm9yICh2YXIgaWQgaW4gYnVja2V0cykge1xuICAgICAgICAgICAgICAgIGlmIChidWNrZXRzW2lkXS5maWx0ZXIoZmVhdHVyZSkpXG4gICAgICAgICAgICAgICAgICAgIGJ1Y2tldHNbaWRdLmZlYXR1cmVzLnB1c2goZmVhdHVyZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgYnVja2V0cyA9IFtdLFxuICAgICAgICBzeW1ib2xCdWNrZXRzID0gdGhpcy5zeW1ib2xCdWNrZXRzID0gW10sXG4gICAgICAgIG90aGVyQnVja2V0cyA9IFtdO1xuXG4gICAgZmVhdHVyZUluZGV4LmJ1Y2tldExheWVySURzID0ge307XG5cbiAgICBmb3IgKHZhciBpZCBpbiBidWNrZXRzQnlJZCkge1xuICAgICAgICBidWNrZXQgPSBidWNrZXRzQnlJZFtpZF07XG4gICAgICAgIGlmIChidWNrZXQuZmVhdHVyZXMubGVuZ3RoID09PSAwKSBjb250aW51ZTtcblxuICAgICAgICBmZWF0dXJlSW5kZXguYnVja2V0TGF5ZXJJRHNbYnVja2V0LmluZGV4XSA9IGJ1Y2tldC5sYXllcklEcztcblxuICAgICAgICBidWNrZXRzLnB1c2goYnVja2V0KTtcblxuICAgICAgICBpZiAoYnVja2V0LnR5cGUgPT09ICdzeW1ib2wnKVxuICAgICAgICAgICAgc3ltYm9sQnVja2V0cy5wdXNoKGJ1Y2tldCk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIG90aGVyQnVja2V0cy5wdXNoKGJ1Y2tldCk7XG4gICAgfVxuXG4gICAgdmFyIGljb25zID0ge307XG4gICAgdmFyIHN0YWNrcyA9IHt9O1xuICAgIHZhciBkZXBzID0gMDtcblxuXG4gICAgaWYgKHN5bWJvbEJ1Y2tldHMubGVuZ3RoID4gMCkge1xuXG4gICAgICAgIC8vIEdldCBkZXBlbmRlbmNpZXMgZm9yIHN5bWJvbCBidWNrZXRzXG4gICAgICAgIGZvciAoaSA9IHN5bWJvbEJ1Y2tldHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIHN5bWJvbEJ1Y2tldHNbaV0udXBkYXRlSWNvbnMoaWNvbnMpO1xuICAgICAgICAgICAgc3ltYm9sQnVja2V0c1tpXS51cGRhdGVGb250KHN0YWNrcyk7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHZhciBmb250TmFtZSBpbiBzdGFja3MpIHtcbiAgICAgICAgICAgIHN0YWNrc1tmb250TmFtZV0gPSBPYmplY3Qua2V5cyhzdGFja3NbZm9udE5hbWVdKS5tYXAoTnVtYmVyKTtcbiAgICAgICAgfVxuICAgICAgICBpY29ucyA9IE9iamVjdC5rZXlzKGljb25zKTtcblxuICAgICAgICBhY3Rvci5zZW5kKCdnZXQgZ2x5cGhzJywge3VpZDogdGhpcy51aWQsIHN0YWNrczogc3RhY2tzfSwgZnVuY3Rpb24oZXJyLCBuZXdTdGFja3MpIHtcbiAgICAgICAgICAgIHN0YWNrcyA9IG5ld1N0YWNrcztcbiAgICAgICAgICAgIGdvdERlcGVuZGVuY3koZXJyKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKGljb25zLmxlbmd0aCkge1xuICAgICAgICAgICAgYWN0b3Iuc2VuZCgnZ2V0IGljb25zJywge2ljb25zOiBpY29uc30sIGZ1bmN0aW9uKGVyciwgbmV3SWNvbnMpIHtcbiAgICAgICAgICAgICAgICBpY29ucyA9IG5ld0ljb25zO1xuICAgICAgICAgICAgICAgIGdvdERlcGVuZGVuY3koZXJyKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZ290RGVwZW5kZW5jeSgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gaW1tZWRpYXRlbHkgcGFyc2Ugbm9uLXN5bWJvbCBidWNrZXRzICh0aGV5IGhhdmUgbm8gZGVwZW5kZW5jaWVzKVxuICAgIGZvciAoaSA9IG90aGVyQnVja2V0cy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBwYXJzZUJ1Y2tldCh0aGlzLCBvdGhlckJ1Y2tldHNbaV0pO1xuICAgIH1cblxuICAgIGlmIChzeW1ib2xCdWNrZXRzLmxlbmd0aCA9PT0gMClcbiAgICAgICAgcmV0dXJuIGRvbmUoKTtcblxuICAgIGZ1bmN0aW9uIGdvdERlcGVuZGVuY3koZXJyKSB7XG4gICAgICAgIGlmIChlcnIpIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgICAgICBkZXBzKys7XG4gICAgICAgIGlmIChkZXBzID09PSAyKSB7XG4gICAgICAgICAgICAvLyBhbGwgc3ltYm9sIGJ1Y2tldCBkZXBlbmRlbmNpZXMgZmV0Y2hlZDsgcGFyc2UgdGhlbSBpbiBwcm9wZXIgb3JkZXJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSBzeW1ib2xCdWNrZXRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICAgICAgcGFyc2VCdWNrZXQodGlsZSwgc3ltYm9sQnVja2V0c1tpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkb25lKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZUJ1Y2tldCh0aWxlLCBidWNrZXQpIHtcbiAgICAgICAgdmFyIG5vdyA9IERhdGUubm93KCk7XG4gICAgICAgIGJ1Y2tldC5wb3B1bGF0ZUJ1ZmZlcnMoY29sbGlzaW9uVGlsZSwgc3RhY2tzLCBpY29ucyk7XG4gICAgICAgIHZhciB0aW1lID0gRGF0ZS5ub3coKSAtIG5vdztcblxuXG4gICAgICAgIGlmIChidWNrZXQudHlwZSAhPT0gJ3N5bWJvbCcpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYnVja2V0LmZlYXR1cmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGZlYXR1cmUgPSBidWNrZXQuZmVhdHVyZXNbaV07XG4gICAgICAgICAgICAgICAgZmVhdHVyZUluZGV4Lmluc2VydChmZWF0dXJlLCBmZWF0dXJlLmluZGV4LCBidWNrZXQuc291cmNlTGF5ZXJJbmRleCwgYnVja2V0LmluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGJ1Y2tldC5mZWF0dXJlcyA9IG51bGw7XG5cbiAgICAgICAgc3RhdHMuX3RvdGFsICs9IHRpbWU7XG4gICAgICAgIHN0YXRzW2J1Y2tldC5pZF0gPSAoc3RhdHNbYnVja2V0LmlkXSB8fCAwKSArIHRpbWU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZG9uZSgpIHtcbiAgICAgICAgdGlsZS5zdGF0dXMgPSAnZG9uZSc7XG5cbiAgICAgICAgaWYgKHRpbGUucmVkb1BsYWNlbWVudEFmdGVyRG9uZSkge1xuICAgICAgICAgICAgdGlsZS5yZWRvUGxhY2VtZW50KHRpbGUuYW5nbGUsIHRpbGUucGl0Y2gsIG51bGwpO1xuICAgICAgICAgICAgdGlsZS5yZWRvUGxhY2VtZW50QWZ0ZXJEb25lID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZmVhdHVyZUluZGV4XyA9IGZlYXR1cmVJbmRleC5zZXJpYWxpemUoKTtcbiAgICAgICAgdmFyIGNvbGxpc2lvblRpbGVfID0gY29sbGlzaW9uVGlsZS5zZXJpYWxpemUoKTtcbiAgICAgICAgdmFyIGNvbGxpc2lvbkJveEFycmF5ID0gdGlsZS5jb2xsaXNpb25Cb3hBcnJheS5zZXJpYWxpemUoKTtcbiAgICAgICAgdmFyIHRyYW5zZmVyYWJsZXMgPSBbcmF3VGlsZURhdGFdLmNvbmNhdChmZWF0dXJlSW5kZXhfLnRyYW5zZmVyYWJsZXMpLmNvbmNhdChjb2xsaXNpb25UaWxlXy50cmFuc2ZlcmFibGVzKTtcblxuICAgICAgICB2YXIgbm9uRW1wdHlCdWNrZXRzID0gYnVja2V0cy5maWx0ZXIoaXNCdWNrZXRFbXB0eSk7XG5cbiAgICAgICAgY2FsbGJhY2sobnVsbCwge1xuICAgICAgICAgICAgYnVja2V0czogbm9uRW1wdHlCdWNrZXRzLm1hcChzZXJpYWxpemVCdWNrZXQpLFxuICAgICAgICAgICAgYnVja2V0U3RhdHM6IHN0YXRzLCAvLyBUT0RPIHB1dCB0aGlzIGluIGEgc2VwYXJhdGUgbWVzc2FnZT9cbiAgICAgICAgICAgIGZlYXR1cmVJbmRleDogZmVhdHVyZUluZGV4Xy5kYXRhLFxuICAgICAgICAgICAgY29sbGlzaW9uVGlsZTogY29sbGlzaW9uVGlsZV8uZGF0YSxcbiAgICAgICAgICAgIGNvbGxpc2lvbkJveEFycmF5OiBjb2xsaXNpb25Cb3hBcnJheSxcbiAgICAgICAgICAgIHJhd1RpbGVEYXRhOiByYXdUaWxlRGF0YVxuICAgICAgICB9LCBnZXRUcmFuc2ZlcmFibGVzKG5vbkVtcHR5QnVja2V0cykuY29uY2F0KHRyYW5zZmVyYWJsZXMpKTtcbiAgICB9XG59O1xuXG5Xb3JrZXJUaWxlLnByb3RvdHlwZS5yZWRvUGxhY2VtZW50ID0gZnVuY3Rpb24oYW5nbGUsIHBpdGNoLCBzaG93Q29sbGlzaW9uQm94ZXMpIHtcbiAgICBpZiAodGhpcy5zdGF0dXMgIT09ICdkb25lJykge1xuICAgICAgICB0aGlzLnJlZG9QbGFjZW1lbnRBZnRlckRvbmUgPSB0cnVlO1xuICAgICAgICB0aGlzLmFuZ2xlID0gYW5nbGU7XG4gICAgICAgIHJldHVybiB7fTtcbiAgICB9XG5cbiAgICB2YXIgY29sbGlzaW9uVGlsZSA9IG5ldyBDb2xsaXNpb25UaWxlKGFuZ2xlLCBwaXRjaCwgdGhpcy5jb2xsaXNpb25Cb3hBcnJheSk7XG5cbiAgICB2YXIgYnVja2V0cyA9IHRoaXMuc3ltYm9sQnVja2V0cztcblxuICAgIGZvciAodmFyIGkgPSBidWNrZXRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIGJ1Y2tldHNbaV0ucGxhY2VGZWF0dXJlcyhjb2xsaXNpb25UaWxlLCBzaG93Q29sbGlzaW9uQm94ZXMpO1xuICAgIH1cblxuICAgIHZhciBjb2xsaXNpb25UaWxlXyA9IGNvbGxpc2lvblRpbGUuc2VyaWFsaXplKCk7XG5cbiAgICB2YXIgbm9uRW1wdHlCdWNrZXRzID0gYnVja2V0cy5maWx0ZXIoaXNCdWNrZXRFbXB0eSk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgICByZXN1bHQ6IHtcbiAgICAgICAgICAgIGJ1Y2tldHM6IG5vbkVtcHR5QnVja2V0cy5tYXAoc2VyaWFsaXplQnVja2V0KSxcbiAgICAgICAgICAgIGNvbGxpc2lvblRpbGU6IGNvbGxpc2lvblRpbGVfLmRhdGFcbiAgICAgICAgfSxcbiAgICAgICAgdHJhbnNmZXJhYmxlczogZ2V0VHJhbnNmZXJhYmxlcyhub25FbXB0eUJ1Y2tldHMpLmNvbmNhdChjb2xsaXNpb25UaWxlXy50cmFuc2ZlcmFibGVzKVxuICAgIH07XG59O1xuXG5mdW5jdGlvbiBpc0J1Y2tldEVtcHR5KGJ1Y2tldCkge1xuICAgIGZvciAodmFyIGJ1ZmZlck5hbWUgaW4gYnVja2V0LmFycmF5cykge1xuICAgICAgICBpZiAoYnVja2V0LmFycmF5c1tidWZmZXJOYW1lXS5sZW5ndGggPiAwKSByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBzZXJpYWxpemVCdWNrZXQoYnVja2V0KSB7XG4gICAgcmV0dXJuIGJ1Y2tldC5zZXJpYWxpemUoKTtcbn1cblxuZnVuY3Rpb24gZ2V0VHJhbnNmZXJhYmxlcyhidWNrZXRzKSB7XG4gICAgdmFyIHRyYW5zZmVyYWJsZXMgPSBbXTtcbiAgICBmb3IgKHZhciBpIGluIGJ1Y2tldHMpIHtcbiAgICAgICAgdmFyIGJ1Y2tldCA9IGJ1Y2tldHNbaV07XG4gICAgICAgIGZvciAodmFyIGogaW4gYnVja2V0LmFycmF5cykge1xuICAgICAgICAgICAgdHJhbnNmZXJhYmxlcy5wdXNoKGJ1Y2tldC5hcnJheXNbal0uYXJyYXlCdWZmZXIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cmFuc2ZlcmFibGVzO1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEFuaW1hdGlvbkxvb3A7XG5cbmZ1bmN0aW9uIEFuaW1hdGlvbkxvb3AoKSB7XG4gICAgdGhpcy5uID0gMDtcbiAgICB0aGlzLnRpbWVzID0gW107XG59XG5cbi8vIEFyZSBhbGwgYW5pbWF0aW9ucyBkb25lP1xuQW5pbWF0aW9uTG9vcC5wcm90b3R5cGUuc3RvcHBlZCA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMudGltZXMgPSB0aGlzLnRpbWVzLmZpbHRlcihmdW5jdGlvbih0KSB7XG4gICAgICAgIHJldHVybiB0LnRpbWUgPj0gKG5ldyBEYXRlKCkpLmdldFRpbWUoKTtcbiAgICB9KTtcbiAgICByZXR1cm4gIXRoaXMudGltZXMubGVuZ3RoO1xufTtcblxuLy8gQWRkIGEgbmV3IGFuaW1hdGlvbiB0aGF0IHdpbGwgcnVuIHQgbWlsbGlzZWNvbmRzXG4vLyBSZXR1cm5zIGFuIGlkIHRoYXQgY2FuIGJlIHVzZWQgdG8gY2FuY2VsIGl0IGxheWVyXG5BbmltYXRpb25Mb29wLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbih0KSB7XG4gICAgdGhpcy50aW1lcy5wdXNoKHsgaWQ6IHRoaXMubiwgdGltZTogdCArIChuZXcgRGF0ZSgpKS5nZXRUaW1lKCkgfSk7XG4gICAgcmV0dXJuIHRoaXMubisrO1xufTtcblxuLy8gQ2FuY2VsIGFuIGFuaW1hdGlvblxuQW5pbWF0aW9uTG9vcC5wcm90b3R5cGUuY2FuY2VsID0gZnVuY3Rpb24obikge1xuICAgIHRoaXMudGltZXMgPSB0aGlzLnRpbWVzLmZpbHRlcihmdW5jdGlvbih0KSB7XG4gICAgICAgIHJldHVybiB0LmlkICE9PSBuO1xuICAgIH0pO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIEV2ZW50ZWQgPSByZXF1aXJlKCcuLi91dGlsL2V2ZW50ZWQnKTtcbnZhciBhamF4ID0gcmVxdWlyZSgnLi4vdXRpbC9hamF4Jyk7XG52YXIgYnJvd3NlciA9IHJlcXVpcmUoJy4uL3V0aWwvYnJvd3NlcicpO1xudmFyIG5vcm1hbGl6ZVVSTCA9IHJlcXVpcmUoJy4uL3V0aWwvbWFwYm94Jykubm9ybWFsaXplU3ByaXRlVVJMO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEltYWdlU3ByaXRlO1xuXG5mdW5jdGlvbiBJbWFnZVNwcml0ZShiYXNlKSB7XG4gICAgdGhpcy5iYXNlID0gYmFzZTtcbiAgICB0aGlzLnJldGluYSA9IGJyb3dzZXIuZGV2aWNlUGl4ZWxSYXRpbyA+IDE7XG5cbiAgICB2YXIgZm9ybWF0ID0gdGhpcy5yZXRpbmEgPyAnQDJ4JyA6ICcnO1xuXG4gICAgYWpheC5nZXRKU09OKG5vcm1hbGl6ZVVSTChiYXNlLCBmb3JtYXQsICcuanNvbicpLCBmdW5jdGlvbihlcnIsIGRhdGEpIHtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgdGhpcy5maXJlKCdlcnJvcicsIHtlcnJvcjogZXJyfSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgICAgICBpZiAodGhpcy5pbWcpIHRoaXMuZmlyZSgnbG9hZCcpO1xuICAgIH0uYmluZCh0aGlzKSk7XG5cbiAgICBhamF4LmdldEltYWdlKG5vcm1hbGl6ZVVSTChiYXNlLCBmb3JtYXQsICcucG5nJyksIGZ1bmN0aW9uKGVyciwgaW1nKSB7XG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgIHRoaXMuZmlyZSgnZXJyb3InLCB7ZXJyb3I6IGVycn0pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcHJlbXVsdGlwbHkgdGhlIHNwcml0ZVxuICAgICAgICB2YXIgZGF0YSA9IGltZy5nZXREYXRhKCk7XG4gICAgICAgIHZhciBuZXdkYXRhID0gaW1nLmRhdGEgPSBuZXcgVWludDhBcnJheShkYXRhLmxlbmd0aCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkgKz0gNCkge1xuICAgICAgICAgICAgdmFyIGFscGhhID0gZGF0YVtpICsgM10gLyAyNTU7XG4gICAgICAgICAgICBuZXdkYXRhW2kgKyAwXSA9IGRhdGFbaSArIDBdICogYWxwaGE7XG4gICAgICAgICAgICBuZXdkYXRhW2kgKyAxXSA9IGRhdGFbaSArIDFdICogYWxwaGE7XG4gICAgICAgICAgICBuZXdkYXRhW2kgKyAyXSA9IGRhdGFbaSArIDJdICogYWxwaGE7XG4gICAgICAgICAgICBuZXdkYXRhW2kgKyAzXSA9IGRhdGFbaSArIDNdO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5pbWcgPSBpbWc7XG4gICAgICAgIGlmICh0aGlzLmRhdGEpIHRoaXMuZmlyZSgnbG9hZCcpO1xuICAgIH0uYmluZCh0aGlzKSk7XG59XG5cbkltYWdlU3ByaXRlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRXZlbnRlZCk7XG5cbkltYWdlU3ByaXRlLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5iYXNlO1xufTtcblxuSW1hZ2VTcHJpdGUucHJvdG90eXBlLmxvYWRlZCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiAhISh0aGlzLmRhdGEgJiYgdGhpcy5pbWcpO1xufTtcblxuSW1hZ2VTcHJpdGUucHJvdG90eXBlLnJlc2l6ZSA9IGZ1bmN0aW9uKC8qZ2wqLykge1xuICAgIGlmIChicm93c2VyLmRldmljZVBpeGVsUmF0aW8gPiAxICE9PSB0aGlzLnJldGluYSkge1xuICAgICAgICB2YXIgbmV3U3ByaXRlID0gbmV3IEltYWdlU3ByaXRlKHRoaXMuYmFzZSk7XG4gICAgICAgIG5ld1Nwcml0ZS5vbignbG9hZCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdGhpcy5pbWcgPSBuZXdTcHJpdGUuaW1nO1xuICAgICAgICAgICAgdGhpcy5kYXRhID0gbmV3U3ByaXRlLmRhdGE7XG4gICAgICAgICAgICB0aGlzLnJldGluYSA9IG5ld1Nwcml0ZS5yZXRpbmE7XG4gICAgICAgIH0uYmluZCh0aGlzKSk7XG4gICAgfVxufTtcblxuZnVuY3Rpb24gU3ByaXRlUG9zaXRpb24oKSB7fVxuU3ByaXRlUG9zaXRpb24ucHJvdG90eXBlID0geyB4OiAwLCB5OiAwLCB3aWR0aDogMCwgaGVpZ2h0OiAwLCBwaXhlbFJhdGlvOiAxLCBzZGY6IGZhbHNlIH07XG5cbkltYWdlU3ByaXRlLnByb3RvdHlwZS5nZXRTcHJpdGVQb3NpdGlvbiA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICBpZiAoIXRoaXMubG9hZGVkKCkpIHJldHVybiBuZXcgU3ByaXRlUG9zaXRpb24oKTtcblxuICAgIHZhciBwb3MgPSB0aGlzLmRhdGEgJiYgdGhpcy5kYXRhW25hbWVdO1xuICAgIGlmIChwb3MgJiYgdGhpcy5pbWcpIHJldHVybiBwb3M7XG5cbiAgICByZXR1cm4gbmV3IFNwcml0ZVBvc2l0aW9uKCk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgcGFyc2VDU1NDb2xvciA9IHJlcXVpcmUoJ2Nzc2NvbG9ycGFyc2VyJykucGFyc2VDU1NDb2xvcjtcbnZhciB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbC91dGlsJyk7XG5cbnZhciBjb2xvckNhY2hlID0ge307XG5cbmZ1bmN0aW9uIHBhcnNlQ29sb3IoaW5wdXQpIHtcblxuICAgIGlmIChjb2xvckNhY2hlW2lucHV0XSkge1xuICAgICAgICByZXR1cm4gY29sb3JDYWNoZVtpbnB1dF07XG5cbiAgICAvLyBSR0JBIGFycmF5XG4gICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGlucHV0KSkge1xuICAgICAgICByZXR1cm4gaW5wdXQ7XG5cbiAgICAvLyBHTCBmdW5jdGlvblxuICAgIH0gZWxzZSBpZiAoaW5wdXQgJiYgaW5wdXQuc3RvcHMpIHtcbiAgICAgICAgcmV0dXJuIHV0aWwuZXh0ZW5kKHt9LCBpbnB1dCwge1xuICAgICAgICAgICAgc3RvcHM6IGlucHV0LnN0b3BzLm1hcChwYXJzZUZ1bmN0aW9uU3RvcENvbG9yKVxuICAgICAgICB9KTtcblxuICAgIC8vIENvbG9yIHN0cmluZ1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJykge1xuICAgICAgICB2YXIgcGFyc2VkQ29sb3IgPSBwYXJzZUNTU0NvbG9yKGlucHV0KTtcbiAgICAgICAgaWYgKCFwYXJzZWRDb2xvcikgeyB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgY29sb3IgJyArIGlucHV0KTsgfVxuXG4gICAgICAgIHZhciBvdXRwdXQgPSBjb2xvckRvd25ncmFkZShwYXJzZWRDb2xvcik7XG4gICAgICAgIGNvbG9yQ2FjaGVbaW5wdXRdID0gb3V0cHV0O1xuICAgICAgICByZXR1cm4gb3V0cHV0O1xuXG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGNvbG9yICcgKyBpbnB1dCk7XG4gICAgfVxuXG59XG5cbmZ1bmN0aW9uIHBhcnNlRnVuY3Rpb25TdG9wQ29sb3Ioc3RvcCkge1xuICAgIHJldHVybiBbc3RvcFswXSwgcGFyc2VDb2xvcihzdG9wWzFdKV07XG59XG5cbmZ1bmN0aW9uIGNvbG9yRG93bmdyYWRlKGNvbG9yKSB7XG4gICAgcmV0dXJuIFtjb2xvclswXSAvIDI1NSwgY29sb3JbMV0gLyAyNTUsIGNvbG9yWzJdIC8gMjU1LCBjb2xvclszXSAvIDFdO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHBhcnNlQ29sb3I7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBFdmVudGVkID0gcmVxdWlyZSgnLi4vdXRpbC9ldmVudGVkJyk7XG52YXIgc3R5bGVCYXRjaCA9IHJlcXVpcmUoJy4vc3R5bGVfYmF0Y2gnKTtcbnZhciBTdHlsZUxheWVyID0gcmVxdWlyZSgnLi9zdHlsZV9sYXllcicpO1xudmFyIEltYWdlU3ByaXRlID0gcmVxdWlyZSgnLi9pbWFnZV9zcHJpdGUnKTtcbnZhciBHbHlwaFNvdXJjZSA9IHJlcXVpcmUoJy4uL3N5bWJvbC9nbHlwaF9zb3VyY2UnKTtcbnZhciBTcHJpdGVBdGxhcyA9IHJlcXVpcmUoJy4uL3N5bWJvbC9zcHJpdGVfYXRsYXMnKTtcbnZhciBMaW5lQXRsYXMgPSByZXF1aXJlKCcuLi9yZW5kZXIvbGluZV9hdGxhcycpO1xudmFyIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsL3V0aWwnKTtcbnZhciBhamF4ID0gcmVxdWlyZSgnLi4vdXRpbC9hamF4Jyk7XG52YXIgbm9ybWFsaXplVVJMID0gcmVxdWlyZSgnLi4vdXRpbC9tYXBib3gnKS5ub3JtYWxpemVTdHlsZVVSTDtcbnZhciBicm93c2VyID0gcmVxdWlyZSgnLi4vdXRpbC9icm93c2VyJyk7XG52YXIgRGlzcGF0Y2hlciA9IHJlcXVpcmUoJy4uL3V0aWwvZGlzcGF0Y2hlcicpO1xudmFyIEFuaW1hdGlvbkxvb3AgPSByZXF1aXJlKCcuL2FuaW1hdGlvbl9sb29wJyk7XG52YXIgdmFsaWRhdGVTdHlsZSA9IHJlcXVpcmUoJy4vdmFsaWRhdGVfc3R5bGUnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBTdHlsZTtcblxuZnVuY3Rpb24gU3R5bGUoc3R5bGVzaGVldCwgYW5pbWF0aW9uTG9vcCkge1xuICAgIHRoaXMuYW5pbWF0aW9uTG9vcCA9IGFuaW1hdGlvbkxvb3AgfHwgbmV3IEFuaW1hdGlvbkxvb3AoKTtcbiAgICB0aGlzLmRpc3BhdGNoZXIgPSBuZXcgRGlzcGF0Y2hlcihNYXRoLm1heCgxKSwgdGhpcyk7XG4gICAgdGhpcy5zcHJpdGVBdGxhcyA9IG5ldyBTcHJpdGVBdGxhcyg1MTIsIDUxMik7XG4gICAgdGhpcy5saW5lQXRsYXMgPSBuZXcgTGluZUF0bGFzKDI1NiwgNTEyKTtcblxuICAgIHRoaXMuX2xheWVycyA9IHt9O1xuICAgIHRoaXMuX29yZGVyICA9IFtdO1xuICAgIHRoaXMuX2dyb3VwcyA9IFtdO1xuICAgIHRoaXMuc291cmNlcyA9IHt9O1xuXG4gICAgdGhpcy56b29tSGlzdG9yeSA9IHt9O1xuXG4gICAgdXRpbC5iaW5kQWxsKFtcbiAgICAgICAgJ19mb3J3YXJkU291cmNlRXZlbnQnLFxuICAgICAgICAnX2ZvcndhcmRUaWxlRXZlbnQnLFxuICAgICAgICAnX2ZvcndhcmRMYXllckV2ZW50JyxcbiAgICAgICAgJ19yZWRvUGxhY2VtZW50J1xuICAgIF0sIHRoaXMpO1xuXG4gICAgdmFyIGxvYWRlZCA9IGZ1bmN0aW9uKGVyciwgc3R5bGVzaGVldCkge1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICB0aGlzLmZpcmUoJ2Vycm9yJywge2Vycm9yOiBlcnJ9KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh2YWxpZGF0ZVN0eWxlLmVtaXRFcnJvcnModGhpcywgdmFsaWRhdGVTdHlsZShzdHlsZXNoZWV0KSkpIHJldHVybjtcblxuICAgICAgICB0aGlzLl9sb2FkZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLnN0eWxlc2hlZXQgPSBzdHlsZXNoZWV0O1xuXG4gICAgICAgIHZhciBzb3VyY2VzID0gc3R5bGVzaGVldC5zb3VyY2VzO1xuICAgICAgICBmb3IgKHZhciBpZCBpbiBzb3VyY2VzKSB7XG4gICAgICAgICAgICB0aGlzLmFkZFNvdXJjZShpZCwgc291cmNlc1tpZF0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHN0eWxlc2hlZXQuc3ByaXRlKSB7XG4gICAgICAgICAgICB0aGlzLnNwcml0ZSA9IG5ldyBJbWFnZVNwcml0ZShzdHlsZXNoZWV0LnNwcml0ZSk7XG4gICAgICAgICAgICB0aGlzLnNwcml0ZS5vbignbG9hZCcsIHRoaXMuZmlyZS5iaW5kKHRoaXMsICdjaGFuZ2UnKSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmdseXBoU291cmNlID0gbmV3IEdseXBoU291cmNlKHN0eWxlc2hlZXQuZ2x5cGhzKTtcbiAgICAgICAgdGhpcy5fcmVzb2x2ZSgpO1xuICAgICAgICB0aGlzLmZpcmUoJ2xvYWQnKTtcbiAgICB9LmJpbmQodGhpcyk7XG5cbiAgICBpZiAodHlwZW9mIHN0eWxlc2hlZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGFqYXguZ2V0SlNPTihub3JtYWxpemVVUkwoc3R5bGVzaGVldCksIGxvYWRlZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgYnJvd3Nlci5mcmFtZShsb2FkZWQuYmluZCh0aGlzLCBudWxsLCBzdHlsZXNoZWV0KSk7XG4gICAgfVxuXG4gICAgdGhpcy5vbignc291cmNlLmxvYWQnLCBmdW5jdGlvbihldmVudCkge1xuICAgICAgICB2YXIgc291cmNlID0gZXZlbnQuc291cmNlO1xuICAgICAgICBpZiAoc291cmNlICYmIHNvdXJjZS52ZWN0b3JMYXllcklkcykge1xuICAgICAgICAgICAgZm9yICh2YXIgbGF5ZXJJZCBpbiB0aGlzLl9sYXllcnMpIHtcbiAgICAgICAgICAgICAgICB2YXIgbGF5ZXIgPSB0aGlzLl9sYXllcnNbbGF5ZXJJZF07XG4gICAgICAgICAgICAgICAgaWYgKGxheWVyLnNvdXJjZSA9PT0gc291cmNlLmlkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3ZhbGlkYXRlTGF5ZXIobGF5ZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xufVxuXG5TdHlsZS5wcm90b3R5cGUgPSB1dGlsLmluaGVyaXQoRXZlbnRlZCwge1xuICAgIF9sb2FkZWQ6IGZhbHNlLFxuXG4gICAgX3ZhbGlkYXRlTGF5ZXI6IGZ1bmN0aW9uKGxheWVyKSB7XG4gICAgICAgIHZhciBzb3VyY2UgPSB0aGlzLnNvdXJjZXNbbGF5ZXIuc291cmNlXTtcblxuICAgICAgICBpZiAoIWxheWVyLnNvdXJjZUxheWVyKSByZXR1cm47XG4gICAgICAgIGlmICghc291cmNlKSByZXR1cm47XG4gICAgICAgIGlmICghc291cmNlLnZlY3RvckxheWVySWRzKSByZXR1cm47XG5cbiAgICAgICAgaWYgKHNvdXJjZS52ZWN0b3JMYXllcklkcy5pbmRleE9mKGxheWVyLnNvdXJjZUxheWVyKSA9PT0gLTEpIHtcbiAgICAgICAgICAgIHRoaXMuZmlyZSgnZXJyb3InLCB7XG4gICAgICAgICAgICAgICAgZXJyb3I6IG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgICAgICAgJ1NvdXJjZSBsYXllciBcIicgKyBsYXllci5zb3VyY2VMYXllciArICdcIiAnICtcbiAgICAgICAgICAgICAgICAgICAgJ2RvZXMgbm90IGV4aXN0IG9uIHNvdXJjZSBcIicgKyBzb3VyY2UuaWQgKyAnXCIgJyArXG4gICAgICAgICAgICAgICAgICAgICdhcyBzcGVjaWZpZWQgYnkgc3R5bGUgbGF5ZXIgXCInICsgbGF5ZXIuaWQgKyAnXCInXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgbG9hZGVkOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9sb2FkZWQpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG5cbiAgICAgICAgZm9yICh2YXIgaWQgaW4gdGhpcy5zb3VyY2VzKVxuICAgICAgICAgICAgaWYgKCF0aGlzLnNvdXJjZXNbaWRdLmxvYWRlZCgpKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcblxuICAgICAgICBpZiAodGhpcy5zcHJpdGUgJiYgIXRoaXMuc3ByaXRlLmxvYWRlZCgpKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sXG5cbiAgICBfcmVzb2x2ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBsYXllciwgbGF5ZXJKU09OO1xuXG4gICAgICAgIHRoaXMuX2xheWVycyA9IHt9O1xuICAgICAgICB0aGlzLl9vcmRlciAgPSB0aGlzLnN0eWxlc2hlZXQubGF5ZXJzLm1hcChmdW5jdGlvbihsYXllcikge1xuICAgICAgICAgICAgcmV0dXJuIGxheWVyLmlkO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyByZXNvbHZlIGFsbCBsYXllcnMgV0lUSE9VVCBhIHJlZlxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuc3R5bGVzaGVldC5sYXllcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxheWVySlNPTiA9IHRoaXMuc3R5bGVzaGVldC5sYXllcnNbaV07XG4gICAgICAgICAgICBpZiAobGF5ZXJKU09OLnJlZikgY29udGludWU7XG4gICAgICAgICAgICBsYXllciA9IFN0eWxlTGF5ZXIuY3JlYXRlKGxheWVySlNPTik7XG4gICAgICAgICAgICB0aGlzLl9sYXllcnNbbGF5ZXIuaWRdID0gbGF5ZXI7XG4gICAgICAgICAgICBsYXllci5vbignZXJyb3InLCB0aGlzLl9mb3J3YXJkTGF5ZXJFdmVudCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyByZXNvbHZlIGFsbCBsYXllcnMgV0lUSCBhIHJlZlxuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHRoaXMuc3R5bGVzaGVldC5sYXllcnMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIGxheWVySlNPTiA9IHRoaXMuc3R5bGVzaGVldC5sYXllcnNbal07XG4gICAgICAgICAgICBpZiAoIWxheWVySlNPTi5yZWYpIGNvbnRpbnVlO1xuICAgICAgICAgICAgdmFyIHJlZkxheWVyID0gdGhpcy5nZXRMYXllcihsYXllckpTT04ucmVmKTtcbiAgICAgICAgICAgIGxheWVyID0gU3R5bGVMYXllci5jcmVhdGUobGF5ZXJKU09OLCByZWZMYXllcik7XG4gICAgICAgICAgICB0aGlzLl9sYXllcnNbbGF5ZXIuaWRdID0gbGF5ZXI7XG4gICAgICAgICAgICBsYXllci5vbignZXJyb3InLCB0aGlzLl9mb3J3YXJkTGF5ZXJFdmVudCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9ncm91cExheWVycygpO1xuICAgICAgICB0aGlzLl9icm9hZGNhc3RMYXllcnMoKTtcbiAgICB9LFxuXG4gICAgX2dyb3VwTGF5ZXJzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGdyb3VwO1xuXG4gICAgICAgIHRoaXMuX2dyb3VwcyA9IFtdO1xuXG4gICAgICAgIC8vIFNwbGl0IGludG8gZ3JvdXBzIG9mIGNvbnNlY3V0aXZlIHRvcC1sZXZlbCBsYXllcnMgd2l0aCB0aGUgc2FtZSBzb3VyY2UuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fb3JkZXIubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHZhciBsYXllciA9IHRoaXMuX2xheWVyc1t0aGlzLl9vcmRlcltpXV07XG5cbiAgICAgICAgICAgIGlmICghZ3JvdXAgfHwgbGF5ZXIuc291cmNlICE9PSBncm91cC5zb3VyY2UpIHtcbiAgICAgICAgICAgICAgICBncm91cCA9IFtdO1xuICAgICAgICAgICAgICAgIGdyb3VwLnNvdXJjZSA9IGxheWVyLnNvdXJjZTtcbiAgICAgICAgICAgICAgICB0aGlzLl9ncm91cHMucHVzaChncm91cCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGdyb3VwLnB1c2gobGF5ZXIpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIF9icm9hZGNhc3RMYXllcnM6IGZ1bmN0aW9uKGlkcykge1xuICAgICAgICB0aGlzLmRpc3BhdGNoZXIuYnJvYWRjYXN0KGlkcyA/ICd1cGRhdGUgbGF5ZXJzJyA6ICdzZXQgbGF5ZXJzJywgdGhpcy5fc2VyaWFsaXplTGF5ZXJzKGlkcykpO1xuICAgIH0sXG5cbiAgICBfc2VyaWFsaXplTGF5ZXJzOiBmdW5jdGlvbihpZHMpIHtcbiAgICAgICAgaWRzID0gaWRzIHx8IHRoaXMuX29yZGVyO1xuICAgICAgICB2YXIgc2VyaWFsaXplZCA9IFtdO1xuICAgICAgICB2YXIgb3B0aW9ucyA9IHtpbmNsdWRlUmVmUHJvcGVydGllczogdHJ1ZX07XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaWRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBzZXJpYWxpemVkLnB1c2godGhpcy5fbGF5ZXJzW2lkc1tpXV0uc2VyaWFsaXplKG9wdGlvbnMpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2VyaWFsaXplZDtcbiAgICB9LFxuXG4gICAgX2Nhc2NhZGU6IGZ1bmN0aW9uKGNsYXNzZXMsIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9sb2FkZWQpIHJldHVybjtcblxuICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7XG4gICAgICAgICAgICB0cmFuc2l0aW9uOiB0cnVlXG4gICAgICAgIH07XG5cbiAgICAgICAgZm9yICh2YXIgaWQgaW4gdGhpcy5fbGF5ZXJzKSB7XG4gICAgICAgICAgICB0aGlzLl9sYXllcnNbaWRdLmNhc2NhZGUoY2xhc3Nlcywgb3B0aW9ucyxcbiAgICAgICAgICAgICAgICB0aGlzLnN0eWxlc2hlZXQudHJhbnNpdGlvbiB8fCB7fSxcbiAgICAgICAgICAgICAgICB0aGlzLmFuaW1hdGlvbkxvb3ApO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5maXJlKCdjaGFuZ2UnKTtcbiAgICB9LFxuXG4gICAgX3JlY2FsY3VsYXRlOiBmdW5jdGlvbih6KSB7XG4gICAgICAgIGZvciAodmFyIHNvdXJjZUlkIGluIHRoaXMuc291cmNlcylcbiAgICAgICAgICAgIHRoaXMuc291cmNlc1tzb3VyY2VJZF0udXNlZCA9IGZhbHNlO1xuXG4gICAgICAgIHRoaXMuX3VwZGF0ZVpvb21IaXN0b3J5KHopO1xuXG4gICAgICAgIHRoaXMucmFzdGVyRmFkZUR1cmF0aW9uID0gMzAwO1xuICAgICAgICBmb3IgKHZhciBsYXllcklkIGluIHRoaXMuX2xheWVycykge1xuICAgICAgICAgICAgdmFyIGxheWVyID0gdGhpcy5fbGF5ZXJzW2xheWVySWRdO1xuXG4gICAgICAgICAgICBsYXllci5yZWNhbGN1bGF0ZSh6LCB0aGlzLnpvb21IaXN0b3J5KTtcbiAgICAgICAgICAgIGlmICghbGF5ZXIuaXNIaWRkZW4oeikgJiYgbGF5ZXIuc291cmNlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zb3VyY2VzW2xheWVyLnNvdXJjZV0udXNlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbWF4Wm9vbVRyYW5zaXRpb25EdXJhdGlvbiA9IDMwMDtcbiAgICAgICAgaWYgKE1hdGguZmxvb3IodGhpcy56KSAhPT0gTWF0aC5mbG9vcih6KSkge1xuICAgICAgICAgICAgdGhpcy5hbmltYXRpb25Mb29wLnNldChtYXhab29tVHJhbnNpdGlvbkR1cmF0aW9uKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMueiA9IHo7XG4gICAgICAgIHRoaXMuZmlyZSgnem9vbScpO1xuICAgIH0sXG5cbiAgICBfdXBkYXRlWm9vbUhpc3Rvcnk6IGZ1bmN0aW9uKHopIHtcblxuICAgICAgICB2YXIgemggPSB0aGlzLnpvb21IaXN0b3J5O1xuXG4gICAgICAgIGlmICh6aC5sYXN0SW50ZWdlclpvb20gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgLy8gZmlyc3QgdGltZVxuICAgICAgICAgICAgemgubGFzdEludGVnZXJab29tID0gTWF0aC5mbG9vcih6KTtcbiAgICAgICAgICAgIHpoLmxhc3RJbnRlZ2VyWm9vbVRpbWUgPSAwO1xuICAgICAgICAgICAgemgubGFzdFpvb20gPSB6O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gY2hlY2sgd2hldGhlciBhbiBpbnRlZ2VyIHpvb20gbGV2ZWwgYXMgcGFzc2VkIHNpbmNlIHRoZSBsYXN0IGZyYW1lXG4gICAgICAgIC8vIGFuZCBpZiB5ZXMsIHJlY29yZCBpdCB3aXRoIHRoZSB0aW1lLiBVc2VkIGZvciB0cmFuc2l0aW9uaW5nIHBhdHRlcm5zLlxuICAgICAgICBpZiAoTWF0aC5mbG9vcih6aC5sYXN0Wm9vbSkgPCBNYXRoLmZsb29yKHopKSB7XG4gICAgICAgICAgICB6aC5sYXN0SW50ZWdlclpvb20gPSBNYXRoLmZsb29yKHopO1xuICAgICAgICAgICAgemgubGFzdEludGVnZXJab29tVGltZSA9IERhdGUubm93KCk7XG5cbiAgICAgICAgfSBlbHNlIGlmIChNYXRoLmZsb29yKHpoLmxhc3Rab29tKSA+IE1hdGguZmxvb3IoeikpIHtcbiAgICAgICAgICAgIHpoLmxhc3RJbnRlZ2VyWm9vbSA9IE1hdGguZmxvb3IoeiArIDEpO1xuICAgICAgICAgICAgemgubGFzdEludGVnZXJab29tVGltZSA9IERhdGUubm93KCk7XG4gICAgICAgIH1cblxuICAgICAgICB6aC5sYXN0Wm9vbSA9IHo7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFwcGx5IG11bHRpcGxlIHN0eWxlIG11dGF0aW9ucyBpbiBhIGJhdGNoXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gd29yayBGdW5jdGlvbiB3aGljaCBhY2NlcHRzIHRoZSBTdHlsZUJhdGNoIGludGVyZmFjZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgYmF0Y2g6IGZ1bmN0aW9uKHdvcmspIHtcbiAgICAgICAgc3R5bGVCYXRjaCh0aGlzLCB3b3JrKTtcbiAgICB9LFxuXG4gICAgYWRkU291cmNlOiBmdW5jdGlvbihpZCwgc291cmNlKSB7XG4gICAgICAgIHRoaXMuYmF0Y2goZnVuY3Rpb24oYmF0Y2gpIHtcbiAgICAgICAgICAgIGJhdGNoLmFkZFNvdXJjZShpZCwgc291cmNlKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlbW92ZSBhIHNvdXJjZSBmcm9tIHRoaXMgc3R5bGVzaGVldCwgZ2l2ZW4gaXRzIGlkLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpZCBpZCBvZiB0aGUgc291cmNlIHRvIHJlbW92ZVxuICAgICAqIEByZXR1cm5zIHtTdHlsZX0gdGhpcyBzdHlsZVxuICAgICAqIEB0aHJvd3Mge0Vycm9yfSBpZiBubyBzb3VyY2UgaXMgZm91bmQgd2l0aCB0aGUgZ2l2ZW4gSURcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHJlbW92ZVNvdXJjZTogZnVuY3Rpb24oaWQpIHtcbiAgICAgICAgdGhpcy5iYXRjaChmdW5jdGlvbihiYXRjaCkge1xuICAgICAgICAgICAgYmF0Y2gucmVtb3ZlU291cmNlKGlkKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldCBhIHNvdXJjZSBieSBpZC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gaWQgaWQgb2YgdGhlIGRlc2lyZWQgc291cmNlXG4gICAgICogQHJldHVybnMge09iamVjdH0gc291cmNlXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBnZXRTb3VyY2U6IGZ1bmN0aW9uKGlkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNvdXJjZXNbaWRdO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBZGQgYSBsYXllciB0byB0aGUgbWFwIHN0eWxlLiBUaGUgbGF5ZXIgd2lsbCBiZSBpbnNlcnRlZCBiZWZvcmUgdGhlIGxheWVyIHdpdGhcbiAgICAgKiBJRCBgYmVmb3JlYCwgb3IgYXBwZW5kZWQgaWYgYGJlZm9yZWAgaXMgb21pdHRlZC5cbiAgICAgKiBAcGFyYW0ge1N0eWxlTGF5ZXJ8T2JqZWN0fSBsYXllclxuICAgICAqIEBwYXJhbSB7c3RyaW5nPX0gYmVmb3JlICBJRCBvZiBhbiBleGlzdGluZyBsYXllciB0byBpbnNlcnQgYmVmb3JlXG4gICAgICogQGZpcmVzIGxheWVyLmFkZFxuICAgICAqIEByZXR1cm5zIHtTdHlsZX0gYHRoaXNgXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBhZGRMYXllcjogZnVuY3Rpb24obGF5ZXIsIGJlZm9yZSkge1xuICAgICAgICB0aGlzLmJhdGNoKGZ1bmN0aW9uKGJhdGNoKSB7XG4gICAgICAgICAgICBiYXRjaC5hZGRMYXllcihsYXllciwgYmVmb3JlKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlbW92ZSBhIGxheWVyIGZyb20gdGhpcyBzdHlsZXNoZWV0LCBnaXZlbiBpdHMgaWQuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGlkIGlkIG9mIHRoZSBsYXllciB0byByZW1vdmVcbiAgICAgKiBAcmV0dXJucyB7U3R5bGV9IHRoaXMgc3R5bGVcbiAgICAgKiBAdGhyb3dzIHtFcnJvcn0gaWYgbm8gbGF5ZXIgaXMgZm91bmQgd2l0aCB0aGUgZ2l2ZW4gSURcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHJlbW92ZUxheWVyOiBmdW5jdGlvbihpZCkge1xuICAgICAgICB0aGlzLmJhdGNoKGZ1bmN0aW9uKGJhdGNoKSB7XG4gICAgICAgICAgICBiYXRjaC5yZW1vdmVMYXllcihpZCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdGhlIHN0eWxlIGxheWVyIG9iamVjdCB3aXRoIHRoZSBnaXZlbiBgaWRgLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGlkIC0gaWQgb2YgdGhlIGRlc2lyZWQgbGF5ZXJcbiAgICAgKiBAcmV0dXJucyB7P09iamVjdH0gYSBsYXllciwgaWYgb25lIHdpdGggdGhlIGdpdmVuIGBpZGAgZXhpc3RzXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBnZXRMYXllcjogZnVuY3Rpb24oaWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xheWVyc1tpZF07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIElmIGEgbGF5ZXIgaGFzIGEgYHJlZmAgcHJvcGVydHkgdGhhdCBtYWtlcyBpdCBkZXJpdmUgc29tZSB2YWx1ZXNcbiAgICAgKiBmcm9tIGFub3RoZXIgbGF5ZXIsIHJldHVybiB0aGF0IHJlZmVyZW50IGxheWVyLiBPdGhlcndpc2UsXG4gICAgICogcmV0dXJucyB0aGUgbGF5ZXIgaXRzZWxmLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpZCB0aGUgbGF5ZXIncyBpZFxuICAgICAqIEByZXR1cm5zIHtMYXllcn0gdGhlIHJlZmVyZW50IGxheWVyIG9yIHRoZSBsYXllciBpdHNlbGZcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGdldFJlZmVyZW50TGF5ZXI6IGZ1bmN0aW9uKGlkKSB7XG4gICAgICAgIHZhciBsYXllciA9IHRoaXMuZ2V0TGF5ZXIoaWQpO1xuICAgICAgICBpZiAobGF5ZXIucmVmKSB7XG4gICAgICAgICAgICBsYXllciA9IHRoaXMuZ2V0TGF5ZXIobGF5ZXIucmVmKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbGF5ZXI7XG4gICAgfSxcblxuICAgIHNldEZpbHRlcjogZnVuY3Rpb24obGF5ZXIsIGZpbHRlcikge1xuICAgICAgICB0aGlzLmJhdGNoKGZ1bmN0aW9uKGJhdGNoKSB7XG4gICAgICAgICAgICBiYXRjaC5zZXRGaWx0ZXIobGF5ZXIsIGZpbHRlcik7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBzZXRMYXllclpvb21SYW5nZTogZnVuY3Rpb24obGF5ZXJJZCwgbWluem9vbSwgbWF4em9vbSkge1xuICAgICAgICB0aGlzLmJhdGNoKGZ1bmN0aW9uKGJhdGNoKSB7XG4gICAgICAgICAgICBiYXRjaC5zZXRMYXllclpvb21SYW5nZShsYXllcklkLCBtaW56b29tLCBtYXh6b29tKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldCBhIGxheWVyJ3MgZmlsdGVyIG9iamVjdFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBsYXllciB0aGUgbGF5ZXIgdG8gaW5zcGVjdFxuICAgICAqIEByZXR1cm5zIHsqfSB0aGUgbGF5ZXIncyBmaWx0ZXIsIGlmIGFueVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgZ2V0RmlsdGVyOiBmdW5jdGlvbihsYXllcikge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRSZWZlcmVudExheWVyKGxheWVyKS5maWx0ZXI7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldCBhIGxheW91dCBwcm9wZXJ0eSdzIHZhbHVlIGZyb20gYSBnaXZlbiBsYXllclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBsYXllciB0aGUgbGF5ZXIgdG8gaW5zcGVjdFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIHRoZSBuYW1lIG9mIHRoZSBsYXlvdXQgcHJvcGVydHlcbiAgICAgKiBAcmV0dXJucyB7Kn0gdGhlIHByb3BlcnR5IHZhbHVlXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBnZXRMYXlvdXRQcm9wZXJ0eTogZnVuY3Rpb24obGF5ZXIsIG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0UmVmZXJlbnRMYXllcihsYXllcikuZ2V0TGF5b3V0UHJvcGVydHkobmFtZSk7XG4gICAgfSxcblxuICAgIGdldFBhaW50UHJvcGVydHk6IGZ1bmN0aW9uKGxheWVyLCBuYW1lLCBrbGFzcykge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRMYXllcihsYXllcikuZ2V0UGFpbnRQcm9wZXJ0eShuYW1lLCBrbGFzcyk7XG4gICAgfSxcblxuICAgIHNlcmlhbGl6ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB1dGlsLmZpbHRlck9iamVjdCh7XG4gICAgICAgICAgICB2ZXJzaW9uOiB0aGlzLnN0eWxlc2hlZXQudmVyc2lvbixcbiAgICAgICAgICAgIG5hbWU6IHRoaXMuc3R5bGVzaGVldC5uYW1lLFxuICAgICAgICAgICAgbWV0YWRhdGE6IHRoaXMuc3R5bGVzaGVldC5tZXRhZGF0YSxcbiAgICAgICAgICAgIGNlbnRlcjogdGhpcy5zdHlsZXNoZWV0LmNlbnRlcixcbiAgICAgICAgICAgIHpvb206IHRoaXMuc3R5bGVzaGVldC56b29tLFxuICAgICAgICAgICAgYmVhcmluZzogdGhpcy5zdHlsZXNoZWV0LmJlYXJpbmcsXG4gICAgICAgICAgICBwaXRjaDogdGhpcy5zdHlsZXNoZWV0LnBpdGNoLFxuICAgICAgICAgICAgc3ByaXRlOiB0aGlzLnN0eWxlc2hlZXQuc3ByaXRlLFxuICAgICAgICAgICAgZ2x5cGhzOiB0aGlzLnN0eWxlc2hlZXQuZ2x5cGhzLFxuICAgICAgICAgICAgdHJhbnNpdGlvbjogdGhpcy5zdHlsZXNoZWV0LnRyYW5zaXRpb24sXG4gICAgICAgICAgICBzb3VyY2VzOiB1dGlsLm1hcE9iamVjdCh0aGlzLnNvdXJjZXMsIGZ1bmN0aW9uKHNvdXJjZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzb3VyY2Uuc2VyaWFsaXplKCk7XG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIGxheWVyczogdGhpcy5fb3JkZXIubWFwKGZ1bmN0aW9uKGlkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2xheWVyc1tpZF0uc2VyaWFsaXplKCk7XG4gICAgICAgICAgICB9LCB0aGlzKVxuICAgICAgICB9LCBmdW5jdGlvbih2YWx1ZSkgeyByZXR1cm4gdmFsdWUgIT09IHVuZGVmaW5lZDsgfSk7XG4gICAgfSxcblxuICAgIF9mbGF0dGVuUmVuZGVyZWRGZWF0dXJlczogZnVuY3Rpb24oc291cmNlUmVzdWx0cykge1xuICAgICAgICB2YXIgZmVhdHVyZXMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgbCA9IHRoaXMuX29yZGVyLmxlbmd0aCAtIDE7IGwgPj0gMDsgbC0tKSB7XG4gICAgICAgICAgICB2YXIgbGF5ZXJJRCA9IHRoaXMuX29yZGVyW2xdO1xuICAgICAgICAgICAgZm9yICh2YXIgcyA9IDA7IHMgPCBzb3VyY2VSZXN1bHRzLmxlbmd0aDsgcysrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGxheWVyRmVhdHVyZXMgPSBzb3VyY2VSZXN1bHRzW3NdW2xheWVySURdO1xuICAgICAgICAgICAgICAgIGlmIChsYXllckZlYXR1cmVzKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGYgPSAwOyBmIDwgbGF5ZXJGZWF0dXJlcy5sZW5ndGg7IGYrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZmVhdHVyZXMucHVzaChsYXllckZlYXR1cmVzW2ZdKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmVhdHVyZXM7XG4gICAgfSxcblxuICAgIHF1ZXJ5UmVuZGVyZWRGZWF0dXJlczogZnVuY3Rpb24ocXVlcnlHZW9tZXRyeSwgcGFyYW1zLCBjbGFzc2VzLCB6b29tLCBiZWFyaW5nKSB7XG4gICAgICAgIHZhciBzb3VyY2VSZXN1bHRzID0gW107XG4gICAgICAgIGZvciAodmFyIGlkIGluIHRoaXMuc291cmNlcykge1xuICAgICAgICAgICAgdmFyIHNvdXJjZSA9IHRoaXMuc291cmNlc1tpZF07XG4gICAgICAgICAgICBpZiAoc291cmNlLnF1ZXJ5UmVuZGVyZWRGZWF0dXJlcykge1xuICAgICAgICAgICAgICAgIHNvdXJjZVJlc3VsdHMucHVzaChzb3VyY2UucXVlcnlSZW5kZXJlZEZlYXR1cmVzKHF1ZXJ5R2VvbWV0cnksIHBhcmFtcywgY2xhc3Nlcywgem9vbSwgYmVhcmluZykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9mbGF0dGVuUmVuZGVyZWRGZWF0dXJlcyhzb3VyY2VSZXN1bHRzKTtcbiAgICB9LFxuXG4gICAgX3JlbW92ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2hlci5yZW1vdmUoKTtcbiAgICB9LFxuXG4gICAgX3JlbG9hZFNvdXJjZTogZnVuY3Rpb24oaWQpIHtcbiAgICAgICAgdGhpcy5zb3VyY2VzW2lkXS5yZWxvYWQoKTtcbiAgICB9LFxuXG4gICAgX3VwZGF0ZVNvdXJjZXM6IGZ1bmN0aW9uKHRyYW5zZm9ybSkge1xuICAgICAgICBmb3IgKHZhciBpZCBpbiB0aGlzLnNvdXJjZXMpIHtcbiAgICAgICAgICAgIHRoaXMuc291cmNlc1tpZF0udXBkYXRlKHRyYW5zZm9ybSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgX3JlZG9QbGFjZW1lbnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICBmb3IgKHZhciBpZCBpbiB0aGlzLnNvdXJjZXMpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnNvdXJjZXNbaWRdLnJlZG9QbGFjZW1lbnQpIHRoaXMuc291cmNlc1tpZF0ucmVkb1BsYWNlbWVudCgpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIF9mb3J3YXJkU291cmNlRXZlbnQ6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgdGhpcy5maXJlKCdzb3VyY2UuJyArIGUudHlwZSwgdXRpbC5leHRlbmQoe3NvdXJjZTogZS50YXJnZXR9LCBlKSk7XG4gICAgfSxcblxuICAgIF9mb3J3YXJkVGlsZUV2ZW50OiBmdW5jdGlvbihlKSB7XG4gICAgICAgIHRoaXMuZmlyZShlLnR5cGUsIHV0aWwuZXh0ZW5kKHtzb3VyY2U6IGUudGFyZ2V0fSwgZSkpO1xuICAgIH0sXG5cbiAgICBfZm9yd2FyZExheWVyRXZlbnQ6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgdGhpcy5maXJlKCdsYXllci4nICsgZS50eXBlLCB1dGlsLmV4dGVuZCh7bGF5ZXI6IHtpZDogZS50YXJnZXQuaWR9fSwgZSkpO1xuICAgIH0sXG5cbiAgICAvLyBDYWxsYmFja3MgZnJvbSB3ZWIgd29ya2Vyc1xuXG4gICAgJ2dldCBzcHJpdGUganNvbic6IGZ1bmN0aW9uKHBhcmFtcywgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIHNwcml0ZSA9IHRoaXMuc3ByaXRlO1xuICAgICAgICBpZiAoc3ByaXRlLmxvYWRlZCgpKSB7XG4gICAgICAgICAgICBjYWxsYmFjayhudWxsLCB7IHNwcml0ZTogc3ByaXRlLmRhdGEsIHJldGluYTogc3ByaXRlLnJldGluYSB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNwcml0ZS5vbignbG9hZCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIHsgc3ByaXRlOiBzcHJpdGUuZGF0YSwgcmV0aW5hOiBzcHJpdGUucmV0aW5hIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgJ2dldCBpY29ucyc6IGZ1bmN0aW9uKHBhcmFtcywgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIHNwcml0ZSA9IHRoaXMuc3ByaXRlO1xuICAgICAgICB2YXIgc3ByaXRlQXRsYXMgPSB0aGlzLnNwcml0ZUF0bGFzO1xuICAgICAgICBpZiAoc3ByaXRlLmxvYWRlZCgpKSB7XG4gICAgICAgICAgICBzcHJpdGVBdGxhcy5zZXRTcHJpdGUoc3ByaXRlKTtcbiAgICAgICAgICAgIHNwcml0ZUF0bGFzLmFkZEljb25zKHBhcmFtcy5pY29ucywgY2FsbGJhY2spO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3ByaXRlLm9uKCdsb2FkJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgc3ByaXRlQXRsYXMuc2V0U3ByaXRlKHNwcml0ZSk7XG4gICAgICAgICAgICAgICAgc3ByaXRlQXRsYXMuYWRkSWNvbnMocGFyYW1zLmljb25zLCBjYWxsYmFjayk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAnZ2V0IGdseXBocyc6IGZ1bmN0aW9uKHBhcmFtcywgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIHN0YWNrcyA9IHBhcmFtcy5zdGFja3MsXG4gICAgICAgICAgICByZW1haW5pbmcgPSBPYmplY3Qua2V5cyhzdGFja3MpLmxlbmd0aCxcbiAgICAgICAgICAgIGFsbEdseXBocyA9IHt9O1xuXG4gICAgICAgIGZvciAodmFyIGZvbnROYW1lIGluIHN0YWNrcykge1xuICAgICAgICAgICAgdGhpcy5nbHlwaFNvdXJjZS5nZXRTaW1wbGVHbHlwaHMoZm9udE5hbWUsIHN0YWNrc1tmb250TmFtZV0sIHBhcmFtcy51aWQsIGRvbmUpO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gZG9uZShlcnIsIGdseXBocywgZm9udE5hbWUpIHtcbiAgICAgICAgICAgIGlmIChlcnIpIGNvbnNvbGUuZXJyb3IoZXJyKTtcblxuICAgICAgICAgICAgYWxsR2x5cGhzW2ZvbnROYW1lXSA9IGdseXBocztcbiAgICAgICAgICAgIHJlbWFpbmluZy0tO1xuXG4gICAgICAgICAgICBpZiAocmVtYWluaW5nID09PSAwKVxuICAgICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIGFsbEdseXBocyk7XG4gICAgICAgIH1cbiAgICB9XG59KTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIFNvdXJjZSA9IHJlcXVpcmUoJy4uL3NvdXJjZS9zb3VyY2UnKTtcbnZhciBTdHlsZUxheWVyID0gcmVxdWlyZSgnLi9zdHlsZV9sYXllcicpO1xudmFyIHZhbGlkYXRlU3R5bGUgPSByZXF1aXJlKCcuL3ZhbGlkYXRlX3N0eWxlJyk7XG52YXIgc3R5bGVTcGVjID0gcmVxdWlyZSgnLi9zdHlsZV9zcGVjJyk7XG52YXIgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwvdXRpbCcpO1xuXG5mdW5jdGlvbiBzdHlsZUJhdGNoKHN0eWxlLCB3b3JrKSB7XG4gICAgaWYgKCFzdHlsZS5fbG9hZGVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignU3R5bGUgaXMgbm90IGRvbmUgbG9hZGluZycpO1xuICAgIH1cblxuICAgIHZhciBiYXRjaCA9IE9iamVjdC5jcmVhdGUoc3R5bGVCYXRjaC5wcm90b3R5cGUpO1xuXG4gICAgYmF0Y2guX3N0eWxlID0gc3R5bGU7XG4gICAgYmF0Y2guX2dyb3VwTGF5ZXJzID0gZmFsc2U7XG4gICAgYmF0Y2guX3VwZGF0ZUFsbExheWVycyA9IGZhbHNlO1xuICAgIGJhdGNoLl91cGRhdGVkTGF5ZXJzID0ge307XG4gICAgYmF0Y2guX3VwZGF0ZWRTb3VyY2VzID0ge307XG4gICAgYmF0Y2guX2V2ZW50cyA9IFtdO1xuICAgIGJhdGNoLl9jaGFuZ2UgPSBmYWxzZTtcblxuICAgIHdvcmsoYmF0Y2gpO1xuXG4gICAgaWYgKGJhdGNoLl9ncm91cExheWVycykge1xuICAgICAgICBiYXRjaC5fc3R5bGUuX2dyb3VwTGF5ZXJzKCk7XG4gICAgfVxuXG4gICAgaWYgKGJhdGNoLl91cGRhdGVBbGxMYXllcnMpIHtcbiAgICAgICAgYmF0Y2guX3N0eWxlLl9icm9hZGNhc3RMYXllcnMoKTtcblxuICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciB1cGRhdGVkSWRzID0gT2JqZWN0LmtleXMoYmF0Y2guX3VwZGF0ZWRMYXllcnMpO1xuICAgICAgICBpZiAodXBkYXRlZElkcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGJhdGNoLl9zdHlsZS5fYnJvYWRjYXN0TGF5ZXJzKHVwZGF0ZWRJZHMpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgT2JqZWN0LmtleXMoYmF0Y2guX3VwZGF0ZWRTb3VyY2VzKS5mb3JFYWNoKGZ1bmN0aW9uKHNvdXJjZUlkKSB7XG4gICAgICAgIGJhdGNoLl9zdHlsZS5fcmVsb2FkU291cmNlKHNvdXJjZUlkKTtcbiAgICB9KTtcblxuICAgIGJhdGNoLl9ldmVudHMuZm9yRWFjaChmdW5jdGlvbihhcmdzKSB7XG4gICAgICAgIGJhdGNoLl9zdHlsZS5maXJlLmFwcGx5KGJhdGNoLl9zdHlsZSwgYXJncyk7XG4gICAgfSk7XG5cbiAgICBpZiAoYmF0Y2guX2NoYW5nZSkge1xuICAgICAgICBiYXRjaC5fc3R5bGUuZmlyZSgnY2hhbmdlJyk7XG4gICAgfVxufVxuXG5zdHlsZUJhdGNoLnByb3RvdHlwZSA9IHtcblxuICAgIGFkZExheWVyOiBmdW5jdGlvbihsYXllciwgYmVmb3JlKSB7XG4gICAgICAgIGlmICghKGxheWVyIGluc3RhbmNlb2YgU3R5bGVMYXllcikpIHtcbiAgICAgICAgICAgIGlmICh2YWxpZGF0ZVN0eWxlLmVtaXRFcnJvcnModGhpcy5fc3R5bGUsIHZhbGlkYXRlU3R5bGUubGF5ZXIoe1xuICAgICAgICAgICAgICAgIGtleTogJ2xheWVycy4nICsgbGF5ZXIuaWQsXG4gICAgICAgICAgICAgICAgdmFsdWU6IGxheWVyLFxuICAgICAgICAgICAgICAgIHN0eWxlOiB0aGlzLl9zdHlsZS5zZXJpYWxpemUoKSxcbiAgICAgICAgICAgICAgICBzdHlsZVNwZWM6IHN0eWxlU3BlYyxcbiAgICAgICAgICAgICAgICAvLyB0aGlzIGxheWVyIGlzIG5vdCBpbiB0aGUgc3R5bGUubGF5ZXJzIGFycmF5LCBzbyB3ZSBwYXNzIGFuXG4gICAgICAgICAgICAgICAgLy8gaW1wb3NzaWJsZSBhcnJheSBpbmRleFxuICAgICAgICAgICAgICAgIGFycmF5SW5kZXg6IC0xXG4gICAgICAgICAgICB9KSkpIHJldHVybiB0aGlzO1xuXG4gICAgICAgICAgICB2YXIgcmVmTGF5ZXIgPSBsYXllci5yZWYgJiYgdGhpcy5fc3R5bGUuZ2V0TGF5ZXIobGF5ZXIucmVmKTtcbiAgICAgICAgICAgIGxheWVyID0gU3R5bGVMYXllci5jcmVhdGUobGF5ZXIsIHJlZkxheWVyKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9zdHlsZS5fdmFsaWRhdGVMYXllcihsYXllcik7XG5cbiAgICAgICAgbGF5ZXIub24oJ2Vycm9yJywgdGhpcy5fc3R5bGUuX2ZvcndhcmRMYXllckV2ZW50KTtcblxuICAgICAgICB0aGlzLl9zdHlsZS5fbGF5ZXJzW2xheWVyLmlkXSA9IGxheWVyO1xuICAgICAgICB0aGlzLl9zdHlsZS5fb3JkZXIuc3BsaWNlKGJlZm9yZSA/IHRoaXMuX3N0eWxlLl9vcmRlci5pbmRleE9mKGJlZm9yZSkgOiBJbmZpbml0eSwgMCwgbGF5ZXIuaWQpO1xuXG4gICAgICAgIHRoaXMuX2dyb3VwTGF5ZXJzID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fdXBkYXRlQWxsTGF5ZXJzID0gdHJ1ZTtcbiAgICAgICAgaWYgKGxheWVyLnNvdXJjZSkge1xuICAgICAgICAgICAgdGhpcy5fdXBkYXRlZFNvdXJjZXNbbGF5ZXIuc291cmNlXSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fZXZlbnRzLnB1c2goWydsYXllci5hZGQnLCB7bGF5ZXI6IGxheWVyfV0pO1xuICAgICAgICB0aGlzLl9jaGFuZ2UgPSB0cnVlO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICByZW1vdmVMYXllcjogZnVuY3Rpb24oaWQpIHtcbiAgICAgICAgdmFyIGxheWVyID0gdGhpcy5fc3R5bGUuX2xheWVyc1tpZF07XG4gICAgICAgIGlmIChsYXllciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZXJlIGlzIG5vIGxheWVyIHdpdGggdGhpcyBJRCcpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGkgaW4gdGhpcy5fc3R5bGUuX2xheWVycykge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3N0eWxlLl9sYXllcnNbaV0ucmVmID09PSBpZCkge1xuICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlTGF5ZXIoaSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBsYXllci5vZmYoJ2Vycm9yJywgdGhpcy5fc3R5bGUuX2ZvcndhcmRMYXllckV2ZW50KTtcblxuICAgICAgICBkZWxldGUgdGhpcy5fc3R5bGUuX2xheWVyc1tpZF07XG4gICAgICAgIHRoaXMuX3N0eWxlLl9vcmRlci5zcGxpY2UodGhpcy5fc3R5bGUuX29yZGVyLmluZGV4T2YoaWQpLCAxKTtcblxuICAgICAgICB0aGlzLl9ncm91cExheWVycyA9IHRydWU7XG4gICAgICAgIHRoaXMuX3VwZGF0ZUFsbExheWVycyA9IHRydWU7XG4gICAgICAgIHRoaXMuX2V2ZW50cy5wdXNoKFsnbGF5ZXIucmVtb3ZlJywge2xheWVyOiBsYXllcn1dKTtcbiAgICAgICAgdGhpcy5fY2hhbmdlID0gdHJ1ZTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgc2V0UGFpbnRQcm9wZXJ0eTogZnVuY3Rpb24obGF5ZXJJZCwgbmFtZSwgdmFsdWUsIGtsYXNzKSB7XG4gICAgICAgIHRoaXMuX3N0eWxlLmdldExheWVyKGxheWVySWQpLnNldFBhaW50UHJvcGVydHkobmFtZSwgdmFsdWUsIGtsYXNzKTtcbiAgICAgICAgdGhpcy5fY2hhbmdlID0gdHJ1ZTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgc2V0TGF5b3V0UHJvcGVydHk6IGZ1bmN0aW9uKGxheWVySWQsIG5hbWUsIHZhbHVlKSB7XG4gICAgICAgIHZhciBsYXllciA9IHRoaXMuX3N0eWxlLmdldFJlZmVyZW50TGF5ZXIobGF5ZXJJZCk7XG4gICAgICAgIGxheWVySWQgPSBsYXllci5pZDtcblxuICAgICAgICBpZiAobGF5ZXIuZ2V0TGF5b3V0UHJvcGVydHkobmFtZSkgPT09IHZhbHVlKSByZXR1cm4gdGhpcztcblxuICAgICAgICBsYXllci5zZXRMYXlvdXRQcm9wZXJ0eShuYW1lLCB2YWx1ZSk7XG5cbiAgICAgICAgdGhpcy5fdXBkYXRlZExheWVyc1tsYXllcklkXSA9IHRydWU7XG5cbiAgICAgICAgaWYgKGxheWVyLnNvdXJjZSkge1xuICAgICAgICAgICAgdGhpcy5fdXBkYXRlZFNvdXJjZXNbbGF5ZXIuc291cmNlXSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fY2hhbmdlID0gdHJ1ZTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgc2V0RmlsdGVyOiBmdW5jdGlvbihsYXllcklkLCBmaWx0ZXIpIHtcbiAgICAgICAgdmFyIGxheWVyID0gdGhpcy5fc3R5bGUuZ2V0UmVmZXJlbnRMYXllcihsYXllcklkKTtcbiAgICAgICAgbGF5ZXJJZCA9IGxheWVyLmlkO1xuXG4gICAgICAgIGlmICh2YWxpZGF0ZVN0eWxlLmVtaXRFcnJvcnModGhpcy5fc3R5bGUsIHZhbGlkYXRlU3R5bGUuZmlsdGVyKHtcbiAgICAgICAgICAgIGtleTogJ2xheWVycy4nICsgbGF5ZXJJZCArICcuZmlsdGVyJyxcbiAgICAgICAgICAgIHZhbHVlOiBmaWx0ZXIsXG4gICAgICAgICAgICBzdHlsZTogdGhpcy5fc3R5bGUuc2VyaWFsaXplKCksXG4gICAgICAgICAgICBzdHlsZVNwZWM6IHN0eWxlU3BlY1xuICAgICAgICB9KSkpIHJldHVybiB0aGlzO1xuXG4gICAgICAgIGlmICh1dGlsLmRlZXBFcXVhbChsYXllci5maWx0ZXIsIGZpbHRlcikpIHJldHVybiB0aGlzO1xuICAgICAgICBsYXllci5maWx0ZXIgPSBmaWx0ZXI7XG5cbiAgICAgICAgdGhpcy5fdXBkYXRlZExheWVyc1tsYXllcklkXSA9IHRydWU7XG4gICAgICAgIGlmIChsYXllci5zb3VyY2UpIHtcbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZWRTb3VyY2VzW2xheWVyLnNvdXJjZV0gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2NoYW5nZSA9IHRydWU7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIHNldExheWVyWm9vbVJhbmdlOiBmdW5jdGlvbihsYXllcklkLCBtaW56b29tLCBtYXh6b29tKSB7XG4gICAgICAgIHZhciBsYXllciA9IHRoaXMuX3N0eWxlLmdldFJlZmVyZW50TGF5ZXIobGF5ZXJJZCk7XG4gICAgICAgIGxheWVySWQgPSBsYXllci5pZDtcblxuICAgICAgICBpZiAobGF5ZXIubWluem9vbSA9PT0gbWluem9vbSAmJiBsYXllci5tYXh6b29tID09PSBtYXh6b29tKSByZXR1cm4gdGhpcztcblxuICAgICAgICBpZiAobWluem9vbSAhPSBudWxsKSB7XG4gICAgICAgICAgICBsYXllci5taW56b29tID0gbWluem9vbTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWF4em9vbSAhPSBudWxsKSB7XG4gICAgICAgICAgICBsYXllci5tYXh6b29tID0gbWF4em9vbTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3VwZGF0ZWRMYXllcnNbbGF5ZXJJZF0gPSB0cnVlO1xuICAgICAgICBpZiAobGF5ZXIuc291cmNlKSB7XG4gICAgICAgICAgICB0aGlzLl91cGRhdGVkU291cmNlc1tsYXllci5zb3VyY2VdID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9jaGFuZ2UgPSB0cnVlO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBhZGRTb3VyY2U6IGZ1bmN0aW9uKGlkLCBzb3VyY2UpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9zdHlsZS5fbG9hZGVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1N0eWxlIGlzIG5vdCBkb25lIGxvYWRpbmcnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fc3R5bGUuc291cmNlc1tpZF0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGVyZSBpcyBhbHJlYWR5IGEgc291cmNlIHdpdGggdGhpcyBJRCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFTb3VyY2UuaXMoc291cmNlKSkge1xuICAgICAgICAgICAgaWYgKHZhbGlkYXRlU3R5bGUuZW1pdEVycm9ycyh0aGlzLl9zdHlsZSwgdmFsaWRhdGVTdHlsZS5zb3VyY2Uoe1xuICAgICAgICAgICAgICAgIGtleTogJ3NvdXJjZXMuJyArIGlkLFxuICAgICAgICAgICAgICAgIHN0eWxlOiB0aGlzLl9zdHlsZS5zZXJpYWxpemUoKSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogc291cmNlLFxuICAgICAgICAgICAgICAgIHN0eWxlU3BlYzogc3R5bGVTcGVjXG4gICAgICAgICAgICB9KSkpIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgc291cmNlID0gU291cmNlLmNyZWF0ZShzb3VyY2UpO1xuICAgICAgICB0aGlzLl9zdHlsZS5zb3VyY2VzW2lkXSA9IHNvdXJjZTtcbiAgICAgICAgc291cmNlLmlkID0gaWQ7XG4gICAgICAgIHNvdXJjZS5zdHlsZSA9IHRoaXMuX3N0eWxlO1xuICAgICAgICBzb3VyY2UuZGlzcGF0Y2hlciA9IHRoaXMuX3N0eWxlLmRpc3BhdGNoZXI7XG4gICAgICAgIHNvdXJjZVxuICAgICAgICAgICAgLm9uKCdsb2FkJywgdGhpcy5fc3R5bGUuX2ZvcndhcmRTb3VyY2VFdmVudClcbiAgICAgICAgICAgIC5vbignZXJyb3InLCB0aGlzLl9zdHlsZS5fZm9yd2FyZFNvdXJjZUV2ZW50KVxuICAgICAgICAgICAgLm9uKCdjaGFuZ2UnLCB0aGlzLl9zdHlsZS5fZm9yd2FyZFNvdXJjZUV2ZW50KVxuICAgICAgICAgICAgLm9uKCd0aWxlLmFkZCcsIHRoaXMuX3N0eWxlLl9mb3J3YXJkVGlsZUV2ZW50KVxuICAgICAgICAgICAgLm9uKCd0aWxlLmxvYWQnLCB0aGlzLl9zdHlsZS5fZm9yd2FyZFRpbGVFdmVudClcbiAgICAgICAgICAgIC5vbigndGlsZS5lcnJvcicsIHRoaXMuX3N0eWxlLl9mb3J3YXJkVGlsZUV2ZW50KVxuICAgICAgICAgICAgLm9uKCd0aWxlLnJlbW92ZScsIHRoaXMuX3N0eWxlLl9mb3J3YXJkVGlsZUV2ZW50KVxuICAgICAgICAgICAgLm9uKCd0aWxlLnN0YXRzJywgdGhpcy5fc3R5bGUuX2ZvcndhcmRUaWxlRXZlbnQpO1xuXG4gICAgICAgIHRoaXMuX2V2ZW50cy5wdXNoKFsnc291cmNlLmFkZCcsIHtzb3VyY2U6IHNvdXJjZX1dKTtcbiAgICAgICAgdGhpcy5fY2hhbmdlID0gdHJ1ZTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgcmVtb3ZlU291cmNlOiBmdW5jdGlvbihpZCkge1xuICAgICAgICBpZiAodGhpcy5fc3R5bGUuc291cmNlc1tpZF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGVyZSBpcyBubyBzb3VyY2Ugd2l0aCB0aGlzIElEJyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHNvdXJjZSA9IHRoaXMuX3N0eWxlLnNvdXJjZXNbaWRdO1xuICAgICAgICBkZWxldGUgdGhpcy5fc3R5bGUuc291cmNlc1tpZF07XG4gICAgICAgIHNvdXJjZVxuICAgICAgICAgICAgLm9mZignbG9hZCcsIHRoaXMuX3N0eWxlLl9mb3J3YXJkU291cmNlRXZlbnQpXG4gICAgICAgICAgICAub2ZmKCdlcnJvcicsIHRoaXMuX3N0eWxlLl9mb3J3YXJkU291cmNlRXZlbnQpXG4gICAgICAgICAgICAub2ZmKCdjaGFuZ2UnLCB0aGlzLl9zdHlsZS5fZm9yd2FyZFNvdXJjZUV2ZW50KVxuICAgICAgICAgICAgLm9mZigndGlsZS5hZGQnLCB0aGlzLl9zdHlsZS5fZm9yd2FyZFRpbGVFdmVudClcbiAgICAgICAgICAgIC5vZmYoJ3RpbGUubG9hZCcsIHRoaXMuX3N0eWxlLl9mb3J3YXJkVGlsZUV2ZW50KVxuICAgICAgICAgICAgLm9mZigndGlsZS5lcnJvcicsIHRoaXMuX3N0eWxlLl9mb3J3YXJkVGlsZUV2ZW50KVxuICAgICAgICAgICAgLm9mZigndGlsZS5yZW1vdmUnLCB0aGlzLl9zdHlsZS5fZm9yd2FyZFRpbGVFdmVudClcbiAgICAgICAgICAgIC5vZmYoJ3RpbGUuc3RhdHMnLCB0aGlzLl9zdHlsZS5fZm9yd2FyZFRpbGVFdmVudCk7XG5cbiAgICAgICAgdGhpcy5fZXZlbnRzLnB1c2goWydzb3VyY2UucmVtb3ZlJywge3NvdXJjZTogc291cmNlfV0pO1xuICAgICAgICB0aGlzLl9jaGFuZ2UgPSB0cnVlO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gc3R5bGVCYXRjaDtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIE1hcGJveEdMRnVuY3Rpb24gPSByZXF1aXJlKCdtYXBib3gtZ2wtZnVuY3Rpb24nKTtcbnZhciBwYXJzZUNvbG9yID0gcmVxdWlyZSgnLi9wYXJzZV9jb2xvcicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFN0eWxlRGVjbGFyYXRpb247XG5cbmZ1bmN0aW9uIFN0eWxlRGVjbGFyYXRpb24ocmVmZXJlbmNlLCB2YWx1ZSkge1xuICAgIHRoaXMudHlwZSA9IHJlZmVyZW5jZS50eXBlO1xuICAgIHRoaXMudHJhbnNpdGlvbmFibGUgPSByZWZlcmVuY2UudHJhbnNpdGlvbjtcbiAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgdGhpcy5pc0Z1bmN0aW9uID0gISF2YWx1ZS5zdG9wcztcblxuICAgIC8vIGltbXV0YWJsZSByZXByZXNlbnRhdGlvbiBvZiB2YWx1ZS4gdXNlZCBmb3IgY29tcGFyaXNvblxuICAgIHRoaXMuanNvbiA9IEpTT04uc3RyaW5naWZ5KHRoaXMudmFsdWUpO1xuXG4gICAgdmFyIHBhcnNlZFZhbHVlID0gdGhpcy50eXBlID09PSAnY29sb3InID8gcGFyc2VDb2xvcih0aGlzLnZhbHVlKSA6IHZhbHVlO1xuICAgIGlmIChyZWZlcmVuY2UuZnVuY3Rpb24gPT09ICdpbnRlcnBvbGF0ZWQnKSB7XG4gICAgICAgIHRoaXMuY2FsY3VsYXRlID0gTWFwYm94R0xGdW5jdGlvbi5pbnRlcnBvbGF0ZWQocGFyc2VkVmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuY2FsY3VsYXRlID0gTWFwYm94R0xGdW5jdGlvblsncGllY2V3aXNlLWNvbnN0YW50J10ocGFyc2VkVmFsdWUpO1xuICAgICAgICBpZiAocmVmZXJlbmNlLnRyYW5zaXRpb24pIHtcbiAgICAgICAgICAgIHRoaXMuY2FsY3VsYXRlID0gdHJhbnNpdGlvbmVkKHRoaXMuY2FsY3VsYXRlKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZnVuY3Rpb24gdHJhbnNpdGlvbmVkKGNhbGN1bGF0ZSkge1xuICAgIHJldHVybiBmdW5jdGlvbih6LCB6aCwgZHVyYXRpb24pIHtcbiAgICAgICAgdmFyIGZyYWN0aW9uID0geiAlIDE7XG4gICAgICAgIHZhciB0ID0gTWF0aC5taW4oKERhdGUubm93KCkgLSB6aC5sYXN0SW50ZWdlclpvb21UaW1lKSAvIGR1cmF0aW9uLCAxKTtcbiAgICAgICAgdmFyIGZyb21TY2FsZSA9IDE7XG4gICAgICAgIHZhciB0b1NjYWxlID0gMTtcbiAgICAgICAgdmFyIG1peCwgZnJvbSwgdG87XG5cbiAgICAgICAgaWYgKHogPiB6aC5sYXN0SW50ZWdlclpvb20pIHtcbiAgICAgICAgICAgIG1peCA9IGZyYWN0aW9uICsgKDEgLSBmcmFjdGlvbikgKiB0O1xuICAgICAgICAgICAgZnJvbVNjYWxlICo9IDI7XG4gICAgICAgICAgICBmcm9tID0gY2FsY3VsYXRlKHogLSAxKTtcbiAgICAgICAgICAgIHRvID0gY2FsY3VsYXRlKHopO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbWl4ID0gMSAtICgxIC0gdCkgKiBmcmFjdGlvbjtcbiAgICAgICAgICAgIHRvID0gY2FsY3VsYXRlKHopO1xuICAgICAgICAgICAgZnJvbSA9IGNhbGN1bGF0ZSh6ICsgMSk7XG4gICAgICAgICAgICBmcm9tU2NhbGUgLz0gMjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBmcm9tOiBmcm9tLFxuICAgICAgICAgICAgZnJvbVNjYWxlOiBmcm9tU2NhbGUsXG4gICAgICAgICAgICB0bzogdG8sXG4gICAgICAgICAgICB0b1NjYWxlOiB0b1NjYWxlLFxuICAgICAgICAgICAgdDogbWl4XG4gICAgICAgIH07XG4gICAgfTtcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsL3V0aWwnKTtcbnZhciBTdHlsZVRyYW5zaXRpb24gPSByZXF1aXJlKCcuL3N0eWxlX3RyYW5zaXRpb24nKTtcbnZhciBTdHlsZURlY2xhcmF0aW9uID0gcmVxdWlyZSgnLi9zdHlsZV9kZWNsYXJhdGlvbicpO1xudmFyIHN0eWxlU3BlYyA9IHJlcXVpcmUoJy4vc3R5bGVfc3BlYycpO1xudmFyIHZhbGlkYXRlU3R5bGUgPSByZXF1aXJlKCcuL3ZhbGlkYXRlX3N0eWxlJyk7XG52YXIgcGFyc2VDb2xvciA9IHJlcXVpcmUoJy4vcGFyc2VfY29sb3InKTtcbnZhciBFdmVudGVkID0gcmVxdWlyZSgnLi4vdXRpbC9ldmVudGVkJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gU3R5bGVMYXllcjtcblxudmFyIFRSQU5TSVRJT05fU1VGRklYID0gJy10cmFuc2l0aW9uJztcblxuU3R5bGVMYXllci5jcmVhdGUgPSBmdW5jdGlvbihsYXllciwgcmVmTGF5ZXIpIHtcbiAgICB2YXIgQ2xhc3NlcyA9IHtcbiAgICAgICAgYmFja2dyb3VuZDogcmVxdWlyZSgnLi9zdHlsZV9sYXllci9iYWNrZ3JvdW5kX3N0eWxlX2xheWVyJyksXG4gICAgICAgIGNpcmNsZTogcmVxdWlyZSgnLi9zdHlsZV9sYXllci9jaXJjbGVfc3R5bGVfbGF5ZXInKSxcbiAgICAgICAgZmlsbDogcmVxdWlyZSgnLi9zdHlsZV9sYXllci9maWxsX3N0eWxlX2xheWVyJyksXG4gICAgICAgIGxpbmU6IHJlcXVpcmUoJy4vc3R5bGVfbGF5ZXIvbGluZV9zdHlsZV9sYXllcicpLFxuICAgICAgICByYXN0ZXI6IHJlcXVpcmUoJy4vc3R5bGVfbGF5ZXIvcmFzdGVyX3N0eWxlX2xheWVyJyksXG4gICAgICAgIHN5bWJvbDogcmVxdWlyZSgnLi9zdHlsZV9sYXllci9zeW1ib2xfc3R5bGVfbGF5ZXInKVxuICAgIH07XG4gICAgcmV0dXJuIG5ldyBDbGFzc2VzWyhyZWZMYXllciB8fCBsYXllcikudHlwZV0obGF5ZXIsIHJlZkxheWVyKTtcbn07XG5cbmZ1bmN0aW9uIFN0eWxlTGF5ZXIobGF5ZXIsIHJlZkxheWVyKSB7XG4gICAgdGhpcy5pZCA9IGxheWVyLmlkO1xuICAgIHRoaXMucmVmID0gbGF5ZXIucmVmO1xuICAgIHRoaXMubWV0YWRhdGEgPSBsYXllci5tZXRhZGF0YTtcbiAgICB0aGlzLnR5cGUgPSAocmVmTGF5ZXIgfHwgbGF5ZXIpLnR5cGU7XG4gICAgdGhpcy5zb3VyY2UgPSAocmVmTGF5ZXIgfHwgbGF5ZXIpLnNvdXJjZTtcbiAgICB0aGlzLnNvdXJjZUxheWVyID0gKHJlZkxheWVyIHx8IGxheWVyKVsnc291cmNlLWxheWVyJ107XG4gICAgdGhpcy5taW56b29tID0gKHJlZkxheWVyIHx8IGxheWVyKS5taW56b29tO1xuICAgIHRoaXMubWF4em9vbSA9IChyZWZMYXllciB8fCBsYXllcikubWF4em9vbTtcbiAgICB0aGlzLmZpbHRlciA9IChyZWZMYXllciB8fCBsYXllcikuZmlsdGVyO1xuXG4gICAgdGhpcy5wYWludCA9IHt9O1xuICAgIHRoaXMubGF5b3V0ID0ge307XG5cbiAgICB0aGlzLl9wYWludFNwZWNpZmljYXRpb25zID0gc3R5bGVTcGVjWydwYWludF8nICsgdGhpcy50eXBlXTtcbiAgICB0aGlzLl9sYXlvdXRTcGVjaWZpY2F0aW9ucyA9IHN0eWxlU3BlY1snbGF5b3V0XycgKyB0aGlzLnR5cGVdO1xuXG4gICAgdGhpcy5fcGFpbnRUcmFuc2l0aW9ucyA9IHt9OyAvLyB7W3Byb3BlcnR5TmFtZV06IFN0eWxlVHJhbnNpdGlvbn1cbiAgICB0aGlzLl9wYWludFRyYW5zaXRpb25PcHRpb25zID0ge307IC8vIHtbY2xhc3NOYW1lXToge1twcm9wZXJ0eU5hbWVdOiB7IGR1cmF0aW9uOk51bWJlciwgZGVsYXk6TnVtYmVyIH19fVxuICAgIHRoaXMuX3BhaW50RGVjbGFyYXRpb25zID0ge307IC8vIHtbY2xhc3NOYW1lXToge1twcm9wZXJ0eU5hbWVdOiBTdHlsZURlY2xhcmF0aW9ufX1cbiAgICB0aGlzLl9sYXlvdXREZWNsYXJhdGlvbnMgPSB7fTsgLy8ge1twcm9wZXJ0eU5hbWVdOiBTdHlsZURlY2xhcmF0aW9ufVxuXG4gICAgLy8gUmVzb2x2ZSBwYWludCBkZWNsYXJhdGlvbnNcbiAgICBmb3IgKHZhciBrZXkgaW4gbGF5ZXIpIHtcbiAgICAgICAgdmFyIG1hdGNoID0ga2V5Lm1hdGNoKC9ecGFpbnQoPzpcXC4oLiopKT8kLyk7XG4gICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgdmFyIGtsYXNzID0gbWF0Y2hbMV0gfHwgJyc7XG4gICAgICAgICAgICBmb3IgKHZhciBwYWludE5hbWUgaW4gbGF5ZXJba2V5XSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0UGFpbnRQcm9wZXJ0eShwYWludE5hbWUsIGxheWVyW2tleV1bcGFpbnROYW1lXSwga2xhc3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gUmVzb2x2ZSBsYXlvdXQgZGVjbGFyYXRpb25zXG4gICAgaWYgKHRoaXMucmVmKSB7XG4gICAgICAgIHRoaXMuX2xheW91dERlY2xhcmF0aW9ucyA9IHJlZkxheWVyLl9sYXlvdXREZWNsYXJhdGlvbnM7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZm9yICh2YXIgbGF5b3V0TmFtZSBpbiBsYXllci5sYXlvdXQpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0TGF5b3V0UHJvcGVydHkobGF5b3V0TmFtZSwgbGF5ZXIubGF5b3V0W2xheW91dE5hbWVdKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMucmVjYWxjdWxhdGVTdGF0aWMoKTtcbn1cblxuU3R5bGVMYXllci5wcm90b3R5cGUgPSB1dGlsLmluaGVyaXQoRXZlbnRlZCwge1xuXG4gICAgc2V0TGF5b3V0UHJvcGVydHk6IGZ1bmN0aW9uKG5hbWUsIHZhbHVlKSB7XG5cbiAgICAgICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9sYXlvdXREZWNsYXJhdGlvbnNbbmFtZV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAodmFsaWRhdGVTdHlsZS5lbWl0RXJyb3JzKHRoaXMsIHZhbGlkYXRlU3R5bGUubGF5b3V0UHJvcGVydHkoe1xuICAgICAgICAgICAgICAgIGtleTogJ2xheWVycy4nICsgdGhpcy5pZCArICcubGF5b3V0LicgKyBuYW1lLFxuICAgICAgICAgICAgICAgIGxheWVyVHlwZTogdGhpcy50eXBlLFxuICAgICAgICAgICAgICAgIG9iamVjdEtleTogbmFtZSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgICAgICAgc3R5bGVTcGVjOiBzdHlsZVNwZWNcbiAgICAgICAgICAgIH0pKSkgcmV0dXJuO1xuICAgICAgICAgICAgdGhpcy5fbGF5b3V0RGVjbGFyYXRpb25zW25hbWVdID0gbmV3IFN0eWxlRGVjbGFyYXRpb24odGhpcy5fbGF5b3V0U3BlY2lmaWNhdGlvbnNbbmFtZV0sIHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBnZXRMYXlvdXRQcm9wZXJ0eTogZnVuY3Rpb24obmFtZSkge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgdGhpcy5fbGF5b3V0RGVjbGFyYXRpb25zW25hbWVdICYmXG4gICAgICAgICAgICB0aGlzLl9sYXlvdXREZWNsYXJhdGlvbnNbbmFtZV0udmFsdWVcbiAgICAgICAgKTtcbiAgICB9LFxuXG4gICAgZ2V0TGF5b3V0VmFsdWU6IGZ1bmN0aW9uKG5hbWUsIHpvb20sIHpvb21IaXN0b3J5KSB7XG4gICAgICAgIHZhciBzcGVjaWZpY2F0aW9uID0gdGhpcy5fbGF5b3V0U3BlY2lmaWNhdGlvbnNbbmFtZV07XG4gICAgICAgIHZhciBkZWNsYXJhdGlvbiA9IHRoaXMuX2xheW91dERlY2xhcmF0aW9uc1tuYW1lXTtcblxuICAgICAgICBpZiAoZGVjbGFyYXRpb24pIHtcbiAgICAgICAgICAgIHJldHVybiBkZWNsYXJhdGlvbi5jYWxjdWxhdGUoem9vbSwgem9vbUhpc3RvcnkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHNwZWNpZmljYXRpb24uZGVmYXVsdDtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBzZXRQYWludFByb3BlcnR5OiBmdW5jdGlvbihuYW1lLCB2YWx1ZSwga2xhc3MpIHtcbiAgICAgICAgdmFyIHZhbGlkYXRlU3R5bGVLZXkgPSAnbGF5ZXJzLicgKyB0aGlzLmlkICsgKGtsYXNzID8gJ1tcInBhaW50LicgKyBrbGFzcyArICdcIl0uJyA6ICcucGFpbnQuJykgKyBuYW1lO1xuXG4gICAgICAgIGlmICh1dGlsLmVuZHNXaXRoKG5hbWUsIFRSQU5TSVRJT05fU1VGRklYKSkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9wYWludFRyYW5zaXRpb25PcHRpb25zW2tsYXNzIHx8ICcnXSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3BhaW50VHJhbnNpdGlvbk9wdGlvbnNba2xhc3MgfHwgJyddID0ge307XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9wYWludFRyYW5zaXRpb25PcHRpb25zW2tsYXNzIHx8ICcnXVtuYW1lXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHZhbGlkYXRlU3R5bGUuZW1pdEVycm9ycyh0aGlzLCB2YWxpZGF0ZVN0eWxlLnBhaW50UHJvcGVydHkoe1xuICAgICAgICAgICAgICAgICAgICBrZXk6IHZhbGlkYXRlU3R5bGVLZXksXG4gICAgICAgICAgICAgICAgICAgIGxheWVyVHlwZTogdGhpcy50eXBlLFxuICAgICAgICAgICAgICAgICAgICBvYmplY3RLZXk6IG5hbWUsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgc3R5bGVTcGVjOiBzdHlsZVNwZWNcbiAgICAgICAgICAgICAgICB9KSkpIHJldHVybjtcbiAgICAgICAgICAgICAgICB0aGlzLl9wYWludFRyYW5zaXRpb25PcHRpb25zW2tsYXNzIHx8ICcnXVtuYW1lXSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9wYWludERlY2xhcmF0aW9uc1trbGFzcyB8fCAnJ10pIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9wYWludERlY2xhcmF0aW9uc1trbGFzcyB8fCAnJ10gPSB7fTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuX3BhaW50RGVjbGFyYXRpb25zW2tsYXNzIHx8ICcnXVtuYW1lXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHZhbGlkYXRlU3R5bGUuZW1pdEVycm9ycyh0aGlzLCB2YWxpZGF0ZVN0eWxlLnBhaW50UHJvcGVydHkoe1xuICAgICAgICAgICAgICAgICAgICBrZXk6IHZhbGlkYXRlU3R5bGVLZXksXG4gICAgICAgICAgICAgICAgICAgIGxheWVyVHlwZTogdGhpcy50eXBlLFxuICAgICAgICAgICAgICAgICAgICBvYmplY3RLZXk6IG5hbWUsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgc3R5bGVTcGVjOiBzdHlsZVNwZWNcbiAgICAgICAgICAgICAgICB9KSkpIHJldHVybjtcbiAgICAgICAgICAgICAgICB0aGlzLl9wYWludERlY2xhcmF0aW9uc1trbGFzcyB8fCAnJ11bbmFtZV0gPSBuZXcgU3R5bGVEZWNsYXJhdGlvbih0aGlzLl9wYWludFNwZWNpZmljYXRpb25zW25hbWVdLCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgZ2V0UGFpbnRQcm9wZXJ0eTogZnVuY3Rpb24obmFtZSwga2xhc3MpIHtcbiAgICAgICAga2xhc3MgPSBrbGFzcyB8fCAnJztcbiAgICAgICAgaWYgKHV0aWwuZW5kc1dpdGgobmFtZSwgVFJBTlNJVElPTl9TVUZGSVgpKSB7XG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgIHRoaXMuX3BhaW50VHJhbnNpdGlvbk9wdGlvbnNba2xhc3NdICYmXG4gICAgICAgICAgICAgICAgdGhpcy5fcGFpbnRUcmFuc2l0aW9uT3B0aW9uc1trbGFzc11bbmFtZV1cbiAgICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgIHRoaXMuX3BhaW50RGVjbGFyYXRpb25zW2tsYXNzXSAmJlxuICAgICAgICAgICAgICAgIHRoaXMuX3BhaW50RGVjbGFyYXRpb25zW2tsYXNzXVtuYW1lXSAmJlxuICAgICAgICAgICAgICAgIHRoaXMuX3BhaW50RGVjbGFyYXRpb25zW2tsYXNzXVtuYW1lXS52YWx1ZVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBnZXRQYWludFZhbHVlOiBmdW5jdGlvbihuYW1lLCB6b29tLCB6b29tSGlzdG9yeSkge1xuICAgICAgICB2YXIgc3BlY2lmaWNhdGlvbiA9IHRoaXMuX3BhaW50U3BlY2lmaWNhdGlvbnNbbmFtZV07XG4gICAgICAgIHZhciB0cmFuc2l0aW9uID0gdGhpcy5fcGFpbnRUcmFuc2l0aW9uc1tuYW1lXTtcblxuICAgICAgICBpZiAodHJhbnNpdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuIHRyYW5zaXRpb24uYXQoem9vbSwgem9vbUhpc3RvcnkpO1xuICAgICAgICB9IGVsc2UgaWYgKHNwZWNpZmljYXRpb24udHlwZSA9PT0gJ2NvbG9yJyAmJiBzcGVjaWZpY2F0aW9uLmRlZmF1bHQpIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJzZUNvbG9yKHNwZWNpZmljYXRpb24uZGVmYXVsdCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gc3BlY2lmaWNhdGlvbi5kZWZhdWx0O1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIGlzSGlkZGVuOiBmdW5jdGlvbih6b29tKSB7XG4gICAgICAgIGlmICh0aGlzLm1pbnpvb20gJiYgem9vbSA8IHRoaXMubWluem9vbSkgcmV0dXJuIHRydWU7XG4gICAgICAgIGlmICh0aGlzLm1heHpvb20gJiYgem9vbSA+PSB0aGlzLm1heHpvb20pIHJldHVybiB0cnVlO1xuICAgICAgICBpZiAodGhpcy5sYXlvdXRbJ3Zpc2liaWxpdHknXSA9PT0gJ25vbmUnKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgaWYgKHRoaXMucGFpbnRbdGhpcy50eXBlICsgJy1vcGFjaXR5J10gPT09IDApIHJldHVybiB0cnVlO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcblxuICAgIC8vIHVwZGF0ZSBjbGFzc2VzXG4gICAgY2FzY2FkZTogZnVuY3Rpb24oY2xhc3Nlcywgb3B0aW9ucywgZ2xvYmFsVHJhbnNpdGlvbk9wdGlvbnMsIGFuaW1hdGlvbkxvb3ApIHtcbiAgICAgICAgdmFyIG9sZFRyYW5zaXRpb25zID0gdGhpcy5fcGFpbnRUcmFuc2l0aW9ucztcbiAgICAgICAgdmFyIG5ld1RyYW5zaXRpb25zID0gdGhpcy5fcGFpbnRUcmFuc2l0aW9ucyA9IHt9O1xuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG5cbiAgICAgICAgLy8gQXBwbHkgbmV3IGRlY2xhcmF0aW9ucyBpbiBhbGwgYWN0aXZlIGNsYXNzZXNcbiAgICAgICAgZm9yICh2YXIga2xhc3MgaW4gdGhpcy5fcGFpbnREZWNsYXJhdGlvbnMpIHtcbiAgICAgICAgICAgIGlmIChrbGFzcyAhPT0gXCJcIiAmJiAhY2xhc3Nlc1trbGFzc10pIGNvbnRpbnVlO1xuICAgICAgICAgICAgZm9yICh2YXIgbmFtZSBpbiB0aGlzLl9wYWludERlY2xhcmF0aW9uc1trbGFzc10pIHtcbiAgICAgICAgICAgICAgICBhcHBseURlY2xhcmF0aW9uKG5hbWUsIHRoaXMuX3BhaW50RGVjbGFyYXRpb25zW2tsYXNzXVtuYW1lXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBBcHBseSByZW1vdmVkIGRlY2xhcmF0aW9uc1xuICAgICAgICB2YXIgcmVtb3ZlZE5hbWVzID0gdXRpbC5rZXlzRGlmZmVyZW5jZShvbGRUcmFuc2l0aW9ucywgbmV3VHJhbnNpdGlvbnMpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlbW92ZWROYW1lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIHNwZWMgPSB0aGlzLl9wYWludFNwZWNpZmljYXRpb25zW3JlbW92ZWROYW1lc1tpXV07XG4gICAgICAgICAgICBhcHBseURlY2xhcmF0aW9uKHJlbW92ZWROYW1lc1tpXSwgbmV3IFN0eWxlRGVjbGFyYXRpb24oc3BlYywgc3BlYy5kZWZhdWx0KSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnJlY2FsY3VsYXRlU3RhdGljKCk7XG5cbiAgICAgICAgZnVuY3Rpb24gYXBwbHlEZWNsYXJhdGlvbihuYW1lLCBkZWNsYXJhdGlvbikge1xuICAgICAgICAgICAgdmFyIG9sZFRyYW5zaXRpb24gPSBvcHRpb25zLnRyYW5zaXRpb24gPyBvbGRUcmFuc2l0aW9uc1tuYW1lXSA6IHVuZGVmaW5lZDtcblxuICAgICAgICAgICAgaWYgKG9sZFRyYW5zaXRpb24gJiYgb2xkVHJhbnNpdGlvbi5kZWNsYXJhdGlvbi5qc29uID09PSBkZWNsYXJhdGlvbi5qc29uKSB7XG4gICAgICAgICAgICAgICAgbmV3VHJhbnNpdGlvbnNbbmFtZV0gPSBvbGRUcmFuc2l0aW9uO1xuXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBuZXdUcmFuc2l0aW9uID0gbmV3IFN0eWxlVHJhbnNpdGlvbihkZWNsYXJhdGlvbiwgb2xkVHJhbnNpdGlvbiwgdXRpbC5leHRlbmQoXG4gICAgICAgICAgICAgICAgICAgIHtkdXJhdGlvbjogMzAwLCBkZWxheTogMH0sXG4gICAgICAgICAgICAgICAgICAgIGdsb2JhbFRyYW5zaXRpb25PcHRpb25zLFxuICAgICAgICAgICAgICAgICAgICB0aGF0LmdldFBhaW50UHJvcGVydHkobmFtZSArIFRSQU5TSVRJT05fU1VGRklYKVxuICAgICAgICAgICAgICAgICkpO1xuXG4gICAgICAgICAgICAgICAgaWYgKCFuZXdUcmFuc2l0aW9uLmluc3RhbnQoKSkge1xuICAgICAgICAgICAgICAgICAgICBuZXdUcmFuc2l0aW9uLmxvb3BJRCA9IGFuaW1hdGlvbkxvb3Auc2V0KG5ld1RyYW5zaXRpb24uZW5kVGltZSAtIChuZXcgRGF0ZSgpKS5nZXRUaW1lKCkpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChvbGRUcmFuc2l0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIGFuaW1hdGlvbkxvb3AuY2FuY2VsKG9sZFRyYW5zaXRpb24ubG9vcElEKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBuZXdUcmFuc2l0aW9uc1tuYW1lXSA9IG5ld1RyYW5zaXRpb247XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgcmVjYWxjdWxhdGVTdGF0aWM6IGZ1bmN0aW9uKCkge1xuICAgICAgICBmb3IgKHZhciBwYWludE5hbWUgaW4gdGhpcy5fcGFpbnRTcGVjaWZpY2F0aW9ucykge1xuICAgICAgICAgICAgaWYgKCEocGFpbnROYW1lIGluIHRoaXMuX3BhaW50VHJhbnNpdGlvbnMpKVxuICAgICAgICAgICAgICAgIHRoaXMucGFpbnRbcGFpbnROYW1lXSA9IHRoaXMuZ2V0UGFpbnRWYWx1ZShwYWludE5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2xheW91dEZ1bmN0aW9ucyA9IHt9O1xuICAgICAgICBmb3IgKHZhciBsYXlvdXROYW1lIGluIHRoaXMuX2xheW91dFNwZWNpZmljYXRpb25zKSB7XG4gICAgICAgICAgICB2YXIgZGVjbGFyYXRpb24gPSB0aGlzLl9sYXlvdXREZWNsYXJhdGlvbnNbbGF5b3V0TmFtZV07XG4gICAgICAgICAgICBpZiAoZGVjbGFyYXRpb24gJiYgZGVjbGFyYXRpb24uaXNGdW5jdGlvbikge1xuICAgICAgICAgICAgICAgIHRoaXMuX2xheW91dEZ1bmN0aW9uc1tsYXlvdXROYW1lXSA9IHRydWU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMubGF5b3V0W2xheW91dE5hbWVdID0gdGhpcy5nZXRMYXlvdXRWYWx1ZShsYXlvdXROYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvLyB1cGRhdGUgem9vbVxuICAgIHJlY2FsY3VsYXRlOiBmdW5jdGlvbih6b29tLCB6b29tSGlzdG9yeSkge1xuICAgICAgICBmb3IgKHZhciBwYWludE5hbWUgaW4gdGhpcy5fcGFpbnRUcmFuc2l0aW9ucykge1xuICAgICAgICAgICAgdGhpcy5wYWludFtwYWludE5hbWVdID0gdGhpcy5nZXRQYWludFZhbHVlKHBhaW50TmFtZSwgem9vbSwgem9vbUhpc3RvcnkpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGxheW91dE5hbWUgaW4gdGhpcy5fbGF5b3V0RnVuY3Rpb25zKSB7XG4gICAgICAgICAgICB0aGlzLmxheW91dFtsYXlvdXROYW1lXSA9IHRoaXMuZ2V0TGF5b3V0VmFsdWUobGF5b3V0TmFtZSwgem9vbSwgem9vbUhpc3RvcnkpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIHNlcmlhbGl6ZTogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgICB2YXIgb3V0cHV0ID0ge1xuICAgICAgICAgICAgJ2lkJzogdGhpcy5pZCxcbiAgICAgICAgICAgICdyZWYnOiB0aGlzLnJlZixcbiAgICAgICAgICAgICdtZXRhZGF0YSc6IHRoaXMubWV0YWRhdGEsXG4gICAgICAgICAgICAnbWluem9vbSc6IHRoaXMubWluem9vbSxcbiAgICAgICAgICAgICdtYXh6b29tJzogdGhpcy5tYXh6b29tXG4gICAgICAgIH07XG5cbiAgICAgICAgZm9yICh2YXIga2xhc3MgaW4gdGhpcy5fcGFpbnREZWNsYXJhdGlvbnMpIHtcbiAgICAgICAgICAgIHZhciBrZXkgPSBrbGFzcyA9PT0gJycgPyAncGFpbnQnIDogJ3BhaW50LicgKyBrbGFzcztcbiAgICAgICAgICAgIG91dHB1dFtrZXldID0gdXRpbC5tYXBPYmplY3QodGhpcy5fcGFpbnREZWNsYXJhdGlvbnNba2xhc3NdLCBnZXREZWNsYXJhdGlvblZhbHVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdGhpcy5yZWYgfHwgKG9wdGlvbnMgJiYgb3B0aW9ucy5pbmNsdWRlUmVmUHJvcGVydGllcykpIHtcbiAgICAgICAgICAgIHV0aWwuZXh0ZW5kKG91dHB1dCwge1xuICAgICAgICAgICAgICAgICd0eXBlJzogdGhpcy50eXBlLFxuICAgICAgICAgICAgICAgICdzb3VyY2UnOiB0aGlzLnNvdXJjZSxcbiAgICAgICAgICAgICAgICAnc291cmNlLWxheWVyJzogdGhpcy5zb3VyY2VMYXllcixcbiAgICAgICAgICAgICAgICAnZmlsdGVyJzogdGhpcy5maWx0ZXIsXG4gICAgICAgICAgICAgICAgJ2xheW91dCc6IHV0aWwubWFwT2JqZWN0KHRoaXMuX2xheW91dERlY2xhcmF0aW9ucywgZ2V0RGVjbGFyYXRpb25WYWx1ZSlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHV0aWwuZmlsdGVyT2JqZWN0KG91dHB1dCwgZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlICE9PSB1bmRlZmluZWQgJiYgIShrZXkgPT09ICdsYXlvdXQnICYmICFPYmplY3Qua2V5cyh2YWx1ZSkubGVuZ3RoKTtcbiAgICAgICAgfSk7XG4gICAgfVxufSk7XG5cbmZ1bmN0aW9uIGdldERlY2xhcmF0aW9uVmFsdWUoZGVjbGFyYXRpb24pIHtcbiAgICByZXR1cm4gZGVjbGFyYXRpb24udmFsdWU7XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlsID0gcmVxdWlyZSgnLi4vLi4vdXRpbC91dGlsJyk7XG52YXIgU3R5bGVMYXllciA9IHJlcXVpcmUoJy4uL3N0eWxlX2xheWVyJyk7XG5cbmZ1bmN0aW9uIEJhY2tncm91bmRTdHlsZUxheWVyKCkge1xuICAgIFN0eWxlTGF5ZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBCYWNrZ3JvdW5kU3R5bGVMYXllcjtcblxuQmFja2dyb3VuZFN0eWxlTGF5ZXIucHJvdG90eXBlID0gdXRpbC5pbmhlcml0KFN0eWxlTGF5ZXIsIHt9KTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWwgPSByZXF1aXJlKCcuLi8uLi91dGlsL3V0aWwnKTtcbnZhciBTdHlsZUxheWVyID0gcmVxdWlyZSgnLi4vc3R5bGVfbGF5ZXInKTtcblxuZnVuY3Rpb24gQ2lyY2xlU3R5bGVMYXllcigpIHtcbiAgICBTdHlsZUxheWVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gQ2lyY2xlU3R5bGVMYXllcjtcblxuQ2lyY2xlU3R5bGVMYXllci5wcm90b3R5cGUgPSB1dGlsLmluaGVyaXQoU3R5bGVMYXllciwge30pO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbCA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvdXRpbCcpO1xudmFyIFN0eWxlTGF5ZXIgPSByZXF1aXJlKCcuLi9zdHlsZV9sYXllcicpO1xuXG5mdW5jdGlvbiBGaWxsU3R5bGVMYXllcigpIHtcbiAgICBTdHlsZUxheWVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gRmlsbFN0eWxlTGF5ZXI7XG5cbkZpbGxTdHlsZUxheWVyLnByb3RvdHlwZSA9IHV0aWwuaW5oZXJpdChTdHlsZUxheWVyLCB7fSk7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlsID0gcmVxdWlyZSgnLi4vLi4vdXRpbC91dGlsJyk7XG52YXIgU3R5bGVMYXllciA9IHJlcXVpcmUoJy4uL3N0eWxlX2xheWVyJyk7XG5cbmZ1bmN0aW9uIExpbmVTdHlsZUxheWVyKCkge1xuICAgIFN0eWxlTGF5ZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBMaW5lU3R5bGVMYXllcjtcblxuTGluZVN0eWxlTGF5ZXIucHJvdG90eXBlID0gdXRpbC5pbmhlcml0KFN0eWxlTGF5ZXIsIHtcblxuICAgIGdldFBhaW50VmFsdWU6IGZ1bmN0aW9uKG5hbWUsIHpvb20sIHpvb21IaXN0b3J5KSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IFN0eWxlTGF5ZXIucHJvdG90eXBlLmdldFBhaW50VmFsdWUuY2FsbCh0aGlzLCBuYW1lLCB6b29tLCB6b29tSGlzdG9yeSk7XG5cbiAgICAgICAgLy8gSWYgdGhlIGxpbmUgaXMgZGFzaGVkLCBzY2FsZSB0aGUgZGFzaCBsZW5ndGhzIGJ5IHRoZSBsaW5lXG4gICAgICAgIC8vIHdpZHRoIGF0IHRoZSBwcmV2aW91cyByb3VuZCB6b29tIGxldmVsLlxuICAgICAgICBpZiAodmFsdWUgJiYgbmFtZSA9PT0gJ2xpbmUtZGFzaGFycmF5Jykge1xuICAgICAgICAgICAgdmFyIGZsb29yZWRab29tID0gTWF0aC5mbG9vcih6b29tKTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9mbG9vcmVkWm9vbSAhPT0gZmxvb3JlZFpvb20pIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9mbG9vcmVkWm9vbSA9IGZsb29yZWRab29tO1xuICAgICAgICAgICAgICAgIHRoaXMuX2Zsb29yZWRMaW5lV2lkdGggPSB0aGlzLmdldFBhaW50VmFsdWUoJ2xpbmUtd2lkdGgnLCBmbG9vcmVkWm9vbSwgSW5maW5pdHkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YWx1ZS5mcm9tU2NhbGUgKj0gdGhpcy5fZmxvb3JlZExpbmVXaWR0aDtcbiAgICAgICAgICAgIHZhbHVlLnRvU2NhbGUgKj0gdGhpcy5fZmxvb3JlZExpbmVXaWR0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG59KTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWwgPSByZXF1aXJlKCcuLi8uLi91dGlsL3V0aWwnKTtcbnZhciBTdHlsZUxheWVyID0gcmVxdWlyZSgnLi4vc3R5bGVfbGF5ZXInKTtcblxuZnVuY3Rpb24gUmFzdGVyU3R5bGVMYXllcigpIHtcbiAgICBTdHlsZUxheWVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gUmFzdGVyU3R5bGVMYXllcjtcblxuUmFzdGVyU3R5bGVMYXllci5wcm90b3R5cGUgPSB1dGlsLmluaGVyaXQoU3R5bGVMYXllciwge30pO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbCA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvdXRpbCcpO1xudmFyIFN0eWxlTGF5ZXIgPSByZXF1aXJlKCcuLi9zdHlsZV9sYXllcicpO1xuXG5mdW5jdGlvbiBTeW1ib2xTdHlsZUxheWVyKCkge1xuICAgIFN0eWxlTGF5ZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBTeW1ib2xTdHlsZUxheWVyO1xuXG5TeW1ib2xTdHlsZUxheWVyLnByb3RvdHlwZSA9IHV0aWwuaW5oZXJpdChTdHlsZUxheWVyLCB7XG5cbiAgICBpc0hpZGRlbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmIChTdHlsZUxheWVyLnByb3RvdHlwZS5pc0hpZGRlbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpKSByZXR1cm4gdHJ1ZTtcblxuICAgICAgICB2YXIgaXNUZXh0SGlkZGVuID0gdGhpcy5wYWludFsndGV4dC1vcGFjaXR5J10gPT09IDAgfHwgIXRoaXMubGF5b3V0Wyd0ZXh0LWZpZWxkJ107XG4gICAgICAgIHZhciBpc0ljb25IaWRkZW4gPSB0aGlzLnBhaW50WydpY29uLW9wYWNpdHknXSA9PT0gMCB8fCAhdGhpcy5sYXlvdXRbJ2ljb24taW1hZ2UnXTtcbiAgICAgICAgaWYgKGlzVGV4dEhpZGRlbiAmJiBpc0ljb25IaWRkZW4pIHJldHVybiB0cnVlO1xuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuXG4gICAgZ2V0TGF5b3V0VmFsdWU6IGZ1bmN0aW9uKG5hbWUsIHpvb20sIHpvb21IaXN0b3J5KSB7XG4gICAgICAgIGlmIChuYW1lID09PSAndGV4dC1yb3RhdGlvbi1hbGlnbm1lbnQnICYmXG4gICAgICAgICAgICAgICAgdGhpcy5nZXRMYXlvdXRWYWx1ZSgnc3ltYm9sLXBsYWNlbWVudCcsIHpvb20sIHpvb21IaXN0b3J5KSA9PT0gJ2xpbmUnICYmXG4gICAgICAgICAgICAgICAgIXRoaXMuZ2V0TGF5b3V0UHJvcGVydHkoJ3RleHQtcm90YXRpb24tYWxpZ25tZW50JykpIHtcbiAgICAgICAgICAgIHJldHVybiAnbWFwJztcbiAgICAgICAgfSBlbHNlIGlmIChuYW1lID09PSAnaWNvbi1yb3RhdGlvbi1hbGlnbm1lbnQnICYmXG4gICAgICAgICAgICAgICAgdGhpcy5nZXRMYXlvdXRWYWx1ZSgnc3ltYm9sLXBsYWNlbWVudCcsIHpvb20sIHpvb21IaXN0b3J5KSA9PT0gJ2xpbmUnICYmXG4gICAgICAgICAgICAgICAgIXRoaXMuZ2V0TGF5b3V0UHJvcGVydHkoJ2ljb24tcm90YXRpb24tYWxpZ25tZW50JykpIHtcbiAgICAgICAgICAgIHJldHVybiAnbWFwJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBTdHlsZUxheWVyLnByb3RvdHlwZS5nZXRMYXlvdXRWYWx1ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG4gICAgfVxuXG59KTtcbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCdtYXBib3gtZ2wtc3R5bGUtc3BlYy9yZWZlcmVuY2UvbGF0ZXN0Jyk7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbC91dGlsJyk7XG52YXIgaW50ZXJwb2xhdGUgPSByZXF1aXJlKCcuLi91dGlsL2ludGVycG9sYXRlJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gU3R5bGVUcmFuc2l0aW9uO1xuXG4vKlxuICogUmVwcmVzZW50cyBhIHRyYW5zaXRpb24gYmV0d2VlbiB0d28gZGVjbGFyYXRpb25zXG4gKi9cbmZ1bmN0aW9uIFN0eWxlVHJhbnNpdGlvbihkZWNsYXJhdGlvbiwgb2xkVHJhbnNpdGlvbiwgdmFsdWUpIHtcblxuICAgIHRoaXMuZGVjbGFyYXRpb24gPSBkZWNsYXJhdGlvbjtcbiAgICB0aGlzLnN0YXJ0VGltZSA9IHRoaXMuZW5kVGltZSA9IChuZXcgRGF0ZSgpKS5nZXRUaW1lKCk7XG5cbiAgICB2YXIgdHlwZSA9IGRlY2xhcmF0aW9uLnR5cGU7XG4gICAgaWYgKCh0eXBlID09PSAnc3RyaW5nJyB8fCB0eXBlID09PSAnYXJyYXknKSAmJiBkZWNsYXJhdGlvbi50cmFuc2l0aW9uYWJsZSkge1xuICAgICAgICB0aGlzLmludGVycCA9IGludGVycFpvb21UcmFuc2l0aW9uZWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5pbnRlcnAgPSBpbnRlcnBvbGF0ZVt0eXBlXTtcbiAgICB9XG5cbiAgICB0aGlzLm9sZFRyYW5zaXRpb24gPSBvbGRUcmFuc2l0aW9uO1xuICAgIHRoaXMuZHVyYXRpb24gPSB2YWx1ZS5kdXJhdGlvbiB8fCAwO1xuICAgIHRoaXMuZGVsYXkgPSB2YWx1ZS5kZWxheSB8fCAwO1xuXG4gICAgaWYgKCF0aGlzLmluc3RhbnQoKSkge1xuICAgICAgICB0aGlzLmVuZFRpbWUgPSB0aGlzLnN0YXJ0VGltZSArIHRoaXMuZHVyYXRpb24gKyB0aGlzLmRlbGF5O1xuICAgICAgICB0aGlzLmVhc2UgPSB1dGlsLmVhc2VDdWJpY0luT3V0O1xuICAgIH1cblxuICAgIGlmIChvbGRUcmFuc2l0aW9uICYmIG9sZFRyYW5zaXRpb24uZW5kVGltZSA8PSB0aGlzLnN0YXJ0VGltZSkge1xuICAgICAgICAvLyBPbGQgdHJhbnNpdGlvbiBpcyBkb25lIHJ1bm5pbmcsIHNvIHdlIGNhblxuICAgICAgICAvLyBkZWxldGUgaXRzIHJlZmVyZW5jZSB0byBpdHMgb2xkIHRyYW5zaXRpb24uXG5cbiAgICAgICAgZGVsZXRlIG9sZFRyYW5zaXRpb24ub2xkVHJhbnNpdGlvbjtcbiAgICB9XG59XG5cblN0eWxlVHJhbnNpdGlvbi5wcm90b3R5cGUuaW5zdGFudCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiAhdGhpcy5vbGRUcmFuc2l0aW9uIHx8ICF0aGlzLmludGVycCB8fCAodGhpcy5kdXJhdGlvbiA9PT0gMCAmJiB0aGlzLmRlbGF5ID09PSAwKTtcbn07XG5cbi8qXG4gKiBSZXR1cm4gdGhlIHZhbHVlIG9mIHRoZSB0cmFuc2l0aW9uaW5nIHByb3BlcnR5IGF0IHpvb20gbGV2ZWwgYHpgIGFuZCBvcHRpb25hbCB0aW1lIGB0YFxuICovXG5TdHlsZVRyYW5zaXRpb24ucHJvdG90eXBlLmF0ID0gZnVuY3Rpb24oeiwgem9vbUhpc3RvcnksIHQpIHtcblxuICAgIHZhciB2YWx1ZSA9IHRoaXMuZGVjbGFyYXRpb24uY2FsY3VsYXRlKHosIHpvb21IaXN0b3J5LCB0aGlzLmR1cmF0aW9uKTtcblxuICAgIGlmICh0aGlzLmluc3RhbnQoKSkgcmV0dXJuIHZhbHVlO1xuXG4gICAgdCA9IHQgfHwgRGF0ZS5ub3coKTtcblxuICAgIGlmICh0IDwgdGhpcy5lbmRUaW1lKSB7XG4gICAgICAgIHZhciBvbGRWYWx1ZSA9IHRoaXMub2xkVHJhbnNpdGlvbi5hdCh6LCB6b29tSGlzdG9yeSwgdGhpcy5zdGFydFRpbWUpO1xuICAgICAgICB2YXIgZWFzZWQgPSB0aGlzLmVhc2UoKHQgLSB0aGlzLnN0YXJ0VGltZSAtIHRoaXMuZGVsYXkpIC8gdGhpcy5kdXJhdGlvbik7XG4gICAgICAgIHZhbHVlID0gdGhpcy5pbnRlcnAob2xkVmFsdWUsIHZhbHVlLCBlYXNlZCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbHVlO1xuXG59O1xuXG5mdW5jdGlvbiBpbnRlcnBab29tVHJhbnNpdGlvbmVkKGZyb20sIHRvLCB0KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZnJvbTogZnJvbS50byxcbiAgICAgICAgZnJvbVNjYWxlOiBmcm9tLnRvU2NhbGUsXG4gICAgICAgIHRvOiB0by50byxcbiAgICAgICAgdG9TY2FsZTogdG8udG9TY2FsZSxcbiAgICAgICAgdDogdFxuICAgIH07XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnbWFwYm94LWdsLXN0eWxlLXNwZWMvbGliL3ZhbGlkYXRlX3N0eWxlLm1pbicpO1xuXG5tb2R1bGUuZXhwb3J0cy5lbWl0RXJyb3JzID0gZnVuY3Rpb24gdGhyb3dFcnJvcnMoZW1pdHRlciwgZXJyb3JzKSB7XG4gICAgaWYgKGVycm9ycyAmJiBlcnJvcnMubGVuZ3RoKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZXJyb3JzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBlbWl0dGVyLmZpcmUoJ2Vycm9yJywgeyBlcnJvcjogbmV3IEVycm9yKGVycm9yc1tpXS5tZXNzYWdlKSB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIFBvaW50ID0gcmVxdWlyZSgncG9pbnQtZ2VvbWV0cnknKTtcblxubW9kdWxlLmV4cG9ydHMgPSBBbmNob3I7XG5cbmZ1bmN0aW9uIEFuY2hvcih4LCB5LCBhbmdsZSwgc2VnbWVudCkge1xuICAgIHRoaXMueCA9IHg7XG4gICAgdGhpcy55ID0geTtcbiAgICB0aGlzLmFuZ2xlID0gYW5nbGU7XG5cbiAgICBpZiAoc2VnbWVudCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMuc2VnbWVudCA9IHNlZ21lbnQ7XG4gICAgfVxufVxuXG5BbmNob3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShQb2ludC5wcm90b3R5cGUpO1xuXG5BbmNob3IucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIG5ldyBBbmNob3IodGhpcy54LCB0aGlzLnksIHRoaXMuYW5nbGUsIHRoaXMuc2VnbWVudCk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGNoZWNrTWF4QW5nbGU7XG5cbi8qKlxuICogTGFiZWxzIHBsYWNlZCBhcm91bmQgcmVhbGx5IHNoYXJwIGFuZ2xlcyBhcmVuJ3QgcmVhZGFibGUuIENoZWNrIGlmIGFueVxuICogcGFydCBvZiB0aGUgcG90ZW50aWFsIGxhYmVsIGhhcyBhIGNvbWJpbmVkIGFuZ2xlIHRoYXQgaXMgdG9vIGJpZy5cbiAqXG4gKiBAcGFyYW0ge0FycmF5PFBvaW50Pn0gbGluZVxuICogQHBhcmFtIHtBbmNob3J9IGFuY2hvciBUaGUgcG9pbnQgb24gdGhlIGxpbmUgYXJvdW5kIHdoaWNoIHRoZSBsYWJlbCBpcyBhbmNob3JlZC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBsYWJlbExlbmd0aCBUaGUgbGVuZ3RoIG9mIHRoZSBsYWJlbCBpbiBnZW9tZXRyeSB1bml0cy5cbiAqIEBwYXJhbSB7bnVtYmVyfSB3aW5kb3dTaXplIFRoZSBjaGVjayBmYWlscyBpZiB0aGUgY29tYmluZWQgYW5nbGVzIHdpdGhpbiBhIHBhcnQgb2YgdGhlIGxpbmUgdGhhdCBpcyBgd2luZG93U2l6ZWAgbG9uZyBpcyB0b28gYmlnLlxuICogQHBhcmFtIHtudW1iZXJ9IG1heEFuZ2xlIFRoZSBtYXhpbXVtIGNvbWJpbmVkIGFuZ2xlIHRoYXQgYW55IHdpbmRvdyBhbG9uZyB0aGUgbGFiZWwgaXMgYWxsb3dlZCB0byBoYXZlLlxuICpcbiAqIEByZXR1cm5zIHtib29sZWFufSB3aGV0aGVyIHRoZSBsYWJlbCBzaG91bGQgYmUgcGxhY2VkXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBjaGVja01heEFuZ2xlKGxpbmUsIGFuY2hvciwgbGFiZWxMZW5ndGgsIHdpbmRvd1NpemUsIG1heEFuZ2xlKSB7XG5cbiAgICAvLyBob3Jpem9udGFsIGxhYmVscyBhbHdheXMgcGFzc1xuICAgIGlmIChhbmNob3Iuc2VnbWVudCA9PT0gdW5kZWZpbmVkKSByZXR1cm4gdHJ1ZTtcblxuICAgIHZhciBwID0gYW5jaG9yO1xuICAgIHZhciBpbmRleCA9IGFuY2hvci5zZWdtZW50ICsgMTtcbiAgICB2YXIgYW5jaG9yRGlzdGFuY2UgPSAwO1xuXG4gICAgLy8gbW92ZSBiYWNrd2FyZHMgYWxvbmcgdGhlIGxpbmUgdG8gdGhlIGZpcnN0IHNlZ21lbnQgdGhlIGxhYmVsIGFwcGVhcnMgb25cbiAgICB3aGlsZSAoYW5jaG9yRGlzdGFuY2UgPiAtbGFiZWxMZW5ndGggLyAyKSB7XG4gICAgICAgIGluZGV4LS07XG5cbiAgICAgICAgLy8gdGhlcmUgaXNuJ3QgZW5vdWdoIHJvb20gZm9yIHRoZSBsYWJlbCBhZnRlciB0aGUgYmVnaW5uaW5nIG9mIHRoZSBsaW5lXG4gICAgICAgIGlmIChpbmRleCA8IDApIHJldHVybiBmYWxzZTtcblxuICAgICAgICBhbmNob3JEaXN0YW5jZSAtPSBsaW5lW2luZGV4XS5kaXN0KHApO1xuICAgICAgICBwID0gbGluZVtpbmRleF07XG4gICAgfVxuXG4gICAgYW5jaG9yRGlzdGFuY2UgKz0gbGluZVtpbmRleF0uZGlzdChsaW5lW2luZGV4ICsgMV0pO1xuICAgIGluZGV4Kys7XG5cbiAgICAvLyBzdG9yZSByZWNlbnQgY29ybmVycyBhbmQgdGhlaXIgdG90YWwgYW5nbGUgZGlmZmVyZW5jZVxuICAgIHZhciByZWNlbnRDb3JuZXJzID0gW107XG4gICAgdmFyIHJlY2VudEFuZ2xlRGVsdGEgPSAwO1xuXG4gICAgLy8gbW92ZSBmb3J3YXJkcyBieSB0aGUgbGVuZ3RoIG9mIHRoZSBsYWJlbCBhbmQgY2hlY2sgYW5nbGVzIGFsb25nIHRoZSB3YXlcbiAgICB3aGlsZSAoYW5jaG9yRGlzdGFuY2UgPCBsYWJlbExlbmd0aCAvIDIpIHtcbiAgICAgICAgdmFyIHByZXYgPSBsaW5lW2luZGV4IC0gMV07XG4gICAgICAgIHZhciBjdXJyZW50ID0gbGluZVtpbmRleF07XG4gICAgICAgIHZhciBuZXh0ID0gbGluZVtpbmRleCArIDFdO1xuXG4gICAgICAgIC8vIHRoZXJlIGlzbid0IGVub3VnaCByb29tIGZvciB0aGUgbGFiZWwgYmVmb3JlIHRoZSBlbmQgb2YgdGhlIGxpbmVcbiAgICAgICAgaWYgKCFuZXh0KSByZXR1cm4gZmFsc2U7XG5cbiAgICAgICAgdmFyIGFuZ2xlRGVsdGEgPSBwcmV2LmFuZ2xlVG8oY3VycmVudCkgLSBjdXJyZW50LmFuZ2xlVG8obmV4dCk7XG4gICAgICAgIC8vIHJlc3RyaWN0IGFuZ2xlIHRvIC1waS4ucGkgcmFuZ2VcbiAgICAgICAgYW5nbGVEZWx0YSA9IE1hdGguYWJzKCgoYW5nbGVEZWx0YSArIDMgKiBNYXRoLlBJKSAlIChNYXRoLlBJICogMikpIC0gTWF0aC5QSSk7XG5cbiAgICAgICAgcmVjZW50Q29ybmVycy5wdXNoKHtcbiAgICAgICAgICAgIGRpc3RhbmNlOiBhbmNob3JEaXN0YW5jZSxcbiAgICAgICAgICAgIGFuZ2xlRGVsdGE6IGFuZ2xlRGVsdGFcbiAgICAgICAgfSk7XG4gICAgICAgIHJlY2VudEFuZ2xlRGVsdGEgKz0gYW5nbGVEZWx0YTtcblxuICAgICAgICAvLyByZW1vdmUgY29ybmVycyB0aGF0IGFyZSBmYXIgZW5vdWdoIGF3YXkgZnJvbSB0aGUgbGlzdCBvZiByZWNlbnQgYW5jaG9yc1xuICAgICAgICB3aGlsZSAoYW5jaG9yRGlzdGFuY2UgLSByZWNlbnRDb3JuZXJzWzBdLmRpc3RhbmNlID4gd2luZG93U2l6ZSkge1xuICAgICAgICAgICAgcmVjZW50QW5nbGVEZWx0YSAtPSByZWNlbnRDb3JuZXJzLnNoaWZ0KCkuYW5nbGVEZWx0YTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHRoZSBzdW0gb2YgYW5nbGVzIHdpdGhpbiB0aGUgd2luZG93IGFyZWEgZXhjZWVkcyB0aGUgbWF4aW11bSBhbGxvd2VkIHZhbHVlLiBjaGVjayBmYWlscy5cbiAgICAgICAgaWYgKHJlY2VudEFuZ2xlRGVsdGEgPiBtYXhBbmdsZSkgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAgIGluZGV4Kys7XG4gICAgICAgIGFuY2hvckRpc3RhbmNlICs9IGN1cnJlbnQuZGlzdChuZXh0KTtcbiAgICB9XG5cbiAgICAvLyBubyBwYXJ0IG9mIHRoZSBsaW5lIGhhZCBhbiBhbmdsZSBncmVhdGVyIHRoYW4gdGhlIG1heGltdW0gYWxsb3dlZC4gY2hlY2sgcGFzc2VzLlxuICAgIHJldHVybiB0cnVlO1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgUG9pbnQgPSByZXF1aXJlKCdwb2ludC1nZW9tZXRyeScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGNsaXBMaW5lO1xuXG4vKipcbiAqIFJldHVybnMgdGhlIHBhcnQgb2YgYSBtdWx0aWxpbmUgdGhhdCBpbnRlcnNlY3RzIHdpdGggdGhlIHByb3ZpZGVkIHJlY3Rhbmd1bGFyIGJveC5cbiAqXG4gKiBAcGFyYW0ge0FycmF5PEFycmF5PFBvaW50Pj59IGxpbmVzXG4gKiBAcGFyYW0ge251bWJlcn0geDEgdGhlIGxlZnQgZWRnZSBvZiB0aGUgYm94XG4gKiBAcGFyYW0ge251bWJlcn0geTEgdGhlIHRvcCBlZGdlIG9mIHRoZSBib3hcbiAqIEBwYXJhbSB7bnVtYmVyfSB4MiB0aGUgcmlnaHQgZWRnZSBvZiB0aGUgYm94XG4gKiBAcGFyYW0ge251bWJlcn0geTIgdGhlIGJvdHRvbSBlZGdlIG9mIHRoZSBib3hcbiAqIEByZXR1cm5zIHtBcnJheTxBcnJheTxQb2ludD4+fSBsaW5lc1xuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gY2xpcExpbmUobGluZXMsIHgxLCB5MSwgeDIsIHkyKSB7XG4gICAgdmFyIGNsaXBwZWRMaW5lcyA9IFtdO1xuXG4gICAgZm9yICh2YXIgbCA9IDA7IGwgPCBsaW5lcy5sZW5ndGg7IGwrKykge1xuICAgICAgICB2YXIgbGluZSA9IGxpbmVzW2xdO1xuICAgICAgICB2YXIgY2xpcHBlZExpbmU7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaW5lLmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgICAgICAgdmFyIHAwID0gbGluZVtpXTtcbiAgICAgICAgICAgIHZhciBwMSA9IGxpbmVbaSArIDFdO1xuXG5cbiAgICAgICAgICAgIGlmIChwMC54IDwgeDEgJiYgcDEueCA8IHgxKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHAwLnggPCB4MSkge1xuICAgICAgICAgICAgICAgIHAwID0gbmV3IFBvaW50KHgxLCBwMC55ICsgKHAxLnkgLSBwMC55KSAqICgoeDEgLSBwMC54KSAvIChwMS54IC0gcDAueCkpKS5fcm91bmQoKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocDEueCA8IHgxKSB7XG4gICAgICAgICAgICAgICAgcDEgPSBuZXcgUG9pbnQoeDEsIHAwLnkgKyAocDEueSAtIHAwLnkpICogKCh4MSAtIHAwLngpIC8gKHAxLnggLSBwMC54KSkpLl9yb3VuZCgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAocDAueSA8IHkxICYmIHAxLnkgPCB5MSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChwMC55IDwgeTEpIHtcbiAgICAgICAgICAgICAgICBwMCA9IG5ldyBQb2ludChwMC54ICsgKHAxLnggLSBwMC54KSAqICgoeTEgLSBwMC55KSAvIChwMS55IC0gcDAueSkpLCB5MSkuX3JvdW5kKCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHAxLnkgPCB5MSkge1xuICAgICAgICAgICAgICAgIHAxID0gbmV3IFBvaW50KHAwLnggKyAocDEueCAtIHAwLngpICogKCh5MSAtIHAwLnkpIC8gKHAxLnkgLSBwMC55KSksIHkxKS5fcm91bmQoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHAwLnggPj0geDIgJiYgcDEueCA+PSB4Mikge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChwMC54ID49IHgyKSB7XG4gICAgICAgICAgICAgICAgcDAgPSBuZXcgUG9pbnQoeDIsIHAwLnkgKyAocDEueSAtIHAwLnkpICogKCh4MiAtIHAwLngpIC8gKHAxLnggLSBwMC54KSkpLl9yb3VuZCgpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChwMS54ID49IHgyKSB7XG4gICAgICAgICAgICAgICAgcDEgPSBuZXcgUG9pbnQoeDIsIHAwLnkgKyAocDEueSAtIHAwLnkpICogKCh4MiAtIHAwLngpIC8gKHAxLnggLSBwMC54KSkpLl9yb3VuZCgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAocDAueSA+PSB5MiAmJiBwMS55ID49IHkyKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHAwLnkgPj0geTIpIHtcbiAgICAgICAgICAgICAgICBwMCA9IG5ldyBQb2ludChwMC54ICsgKHAxLnggLSBwMC54KSAqICgoeTIgLSBwMC55KSAvIChwMS55IC0gcDAueSkpLCB5MikuX3JvdW5kKCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHAxLnkgPj0geTIpIHtcbiAgICAgICAgICAgICAgICBwMSA9IG5ldyBQb2ludChwMC54ICsgKHAxLnggLSBwMC54KSAqICgoeTIgLSBwMC55KSAvIChwMS55IC0gcDAueSkpLCB5MikuX3JvdW5kKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghY2xpcHBlZExpbmUgfHwgIXAwLmVxdWFscyhjbGlwcGVkTGluZVtjbGlwcGVkTGluZS5sZW5ndGggLSAxXSkpIHtcbiAgICAgICAgICAgICAgICBjbGlwcGVkTGluZSA9IFtwMF07XG4gICAgICAgICAgICAgICAgY2xpcHBlZExpbmVzLnB1c2goY2xpcHBlZExpbmUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjbGlwcGVkTGluZS5wdXNoKHAxKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBjbGlwcGVkTGluZXM7XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBTdHJ1Y3RBcnJheVR5cGUgPSByZXF1aXJlKCcuLi91dGlsL3N0cnVjdF9hcnJheScpO1xudmFyIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsL3V0aWwnKTtcbnZhciBQb2ludCA9IHJlcXVpcmUoJ3BvaW50LWdlb21ldHJ5Jyk7XG5cbi8qKlxuICogQSBjb2xsaXNpb24gYm94IHJlcHJlc2VudHMgYW4gYXJlYSBvZiB0aGUgbWFwIHRoYXQgdGhhdCBpcyBjb3ZlcmVkIGJ5IGFcbiAqIGxhYmVsLiBDb2xsaXNpb25GZWF0dXJlIHVzZXMgb25lIG9yIG1vcmUgb2YgdGhlc2UgY29sbGlzaW9uIGJveGVzIHRvXG4gKiByZXByZXNlbnQgYWxsIHRoZSBhcmVhIGNvdmVyZWQgYnkgYSBzaW5nbGUgbGFiZWwuIFRoZXkgYXJlIHVzZWQgdG9cbiAqIHByZXZlbnQgY29sbGlzaW9ucyBiZXR3ZWVuIGxhYmVscy5cbiAqXG4gKiBBIGNvbGxpc2lvbiBib3ggYWN0dWFsbHkgcmVwcmVzZW50cyBhIDNkIHZvbHVtZS4gVGhlIGZpcnN0IHR3byBkaW1lbnNpb25zLFxuICogeCBhbmQgeSwgYXJlIHNwZWNpZmllZCB3aXRoIGBhbmNob3JgIGFsb25nIHdpdGggYHgxYCwgYHkxYCwgYHgyYCwgYHkyYC5cbiAqIFRoZSB0aGlyZCBkaW1lbnNpb24sIHpvb20sIGlzIGxpbWl0ZWQgYnkgYG1heFNjYWxlYCB3aGljaCBkZXRlcm1pbmVzXG4gKiBob3cgZmFyIGluIHRoZSB6IGRpbWVuc2lvbnMgdGhlIGJveCBleHRlbmRzLlxuICpcbiAqIEFzIHlvdSB6b29tIGluIG9uIGEgbWFwLCBhbGwgcG9pbnRzIG9uIHRoZSBtYXAgZ2V0IGZ1cnRoZXIgYW5kIGZ1cnRoZXIgYXBhcnRcbiAqIGJ1dCBsYWJlbHMgc3RheSByb3VnaGx5IHRoZSBzYW1lIHNpemUuIExhYmVscyBjb3ZlciBsZXNzIHJlYWwgd29ybGQgYXJlYSBvblxuICogdGhlIG1hcCBhdCBoaWdoZXIgem9vbSBsZXZlbHMgdGhhbiB0aGV5IGRvIGF0IGxvd2VyIHpvb20gbGV2ZWxzLiBUaGlzIGlzIHdoeVxuICogYXJlYXMgYXJlIGFyZSByZXByZXNlbnRlZCB3aXRoIGFuIGFuY2hvciBwb2ludCBhbmQgb2Zmc2V0cyBmcm9tIHRoYXQgcG9pbnRcbiAqIGluc3RlYWQgb2YganVzdCB1c2luZyBmb3VyIGFic29sdXRlIHBvaW50cy5cbiAqXG4gKiBMaW5lIGxhYmVscyBhcmUgcmVwcmVzZW50ZWQgYnkgYSBzZXQgb2YgdGhlc2UgYm94ZXMgc3BhY2VkIG91dCBhbG9uZyBhIGxpbmUuXG4gKiBXaGVuIHlvdSB6b29tIGluLCBsaW5lIGxhYmVscyBjb3ZlciBsZXNzIHJlYWwgd29ybGQgZGlzdGFuY2UgYWxvbmcgdGhlIGxpbmVcbiAqIHRoYW4gdGhleSB1c2VkIHRvLiBDb2xsaXNpb24gYm94ZXMgbmVhciB0aGUgZWRnZXMgdGhhdCB1c2VkIHRvIGNvdmVyIGxhYmVsXG4gKiBubyBsb25nZXIgZG8uIElmIGEgYm94IGRvZXNuJ3QgY292ZXIgdGhlIGxhYmVsIGFueW1vcmUgaXQgc2hvdWxkIGJlIGlnbm9yZWRcbiAqIHdoZW4gZG9pbmcgY29sbGlzaW9uIGNoZWNrcy4gYG1heFNjYWxlYCBpcyBob3cgbXVjaCB5b3UgY2FuIHNjYWxlIHRoZSBtYXBcbiAqIGJlZm9yZSB0aGUgbGFiZWwgaXNuJ3Qgd2l0aGluIHRoZSBib3ggYW55bW9yZS5cbiAqIEZvciBleGFtcGxlXG4gKiBsb3dlciB6b29tOlxuICogaHR0cHM6Ly9jbG91ZC5naXRodWJ1c2VyY29udGVudC5jb20vYXNzZXRzLzE0MjE2NTIvODA2MDA5NC80ZDk3NWY3Ni0wZTkxLTExZTUtODRiMS00ZWRlYjMwYTU4NzUucG5nXG4gKiBzbGlnaHRseSBoaWdoZXIgem9vbTpcbiAqIGh0dHBzOi8vY2xvdWQuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2Fzc2V0cy8xNDIxNjUyLzgwNjAwNjEvMjZhZTFjMzgtMGU5MS0xMWU1LThjNWEtOWYzODBiZjI5ZjBhLnBuZ1xuICogSW4gdGhlIHpvb21lZCBpbiBpbWFnZSB0aGUgdHdvIGdyZXkgYm94ZXMgb24gZWl0aGVyIHNpZGUgZG9uJ3QgY292ZXIgdGhlXG4gKiBsYWJlbCBhbnltb3JlLiBUaGVpciBtYXhTY2FsZSBpcyBzbWFsbGVyIHRoYW4gdGhlIGN1cnJlbnQgc2NhbGUuXG4gKlxuICpcbiAqIEBjbGFzcyBDb2xsaXNpb25Cb3hBcnJheVxuICogQHByaXZhdGVcbiAqL1xuXG52YXIgQ29sbGlzaW9uQm94QXJyYXkgPSBtb2R1bGUuZXhwb3J0cyA9IG5ldyBTdHJ1Y3RBcnJheVR5cGUoe1xuICAgIG1lbWJlcnM6IFtcbiAgICAgICAgLy8gdGhlIGJveCBpcyBjZW50ZXJlZCBhcm91bmQgdGhlIGFuY2hvciBwb2ludFxuICAgICAgICB7IHR5cGU6ICdJbnQxNicsIG5hbWU6ICdhbmNob3JQb2ludFgnIH0sXG4gICAgICAgIHsgdHlwZTogJ0ludDE2JywgbmFtZTogJ2FuY2hvclBvaW50WScgfSxcblxuICAgICAgICAvLyBkaXN0YW5jZXMgdG8gdGhlIGVkZ2VzIGZyb20gdGhlIGFuY2hvclxuICAgICAgICB7IHR5cGU6ICdJbnQxNicsIG5hbWU6ICd4MScgfSxcbiAgICAgICAgeyB0eXBlOiAnSW50MTYnLCBuYW1lOiAneTEnIH0sXG4gICAgICAgIHsgdHlwZTogJ0ludDE2JywgbmFtZTogJ3gyJyB9LFxuICAgICAgICB7IHR5cGU6ICdJbnQxNicsIG5hbWU6ICd5MicgfSxcblxuICAgICAgICAvLyB0aGUgYm94IGlzIG9ubHkgdmFsaWQgZm9yIHNjYWxlcyA8IG1heFNjYWxlLlxuICAgICAgICAvLyBUaGUgYm94IGRvZXMgbm90IGJsb2NrIG90aGVyIGJveGVzIGF0IHNjYWxlcyA+PSBtYXhTY2FsZTtcbiAgICAgICAgeyB0eXBlOiAnRmxvYXQzMicsIG5hbWU6ICdtYXhTY2FsZScgfSxcblxuICAgICAgICAvLyB0aGUgaW5kZXggb2YgdGhlIGZlYXR1cmUgaW4gdGhlIG9yaWdpbmFsIHZlY3RvcnRpbGVcbiAgICAgICAgeyB0eXBlOiAnVWludDMyJywgbmFtZTogJ2ZlYXR1cmVJbmRleCcgfSxcbiAgICAgICAgLy8gdGhlIHNvdXJjZSBsYXllciB0aGUgZmVhdHVyZSBhcHBlYXJzIGluXG4gICAgICAgIHsgdHlwZTogJ1VpbnQxNicsIG5hbWU6ICdzb3VyY2VMYXllckluZGV4JyB9LFxuICAgICAgICAvLyB0aGUgYnVja2V0IHRoZSBmZWF0dXJlIGFwcGVhcnMgaW5cbiAgICAgICAgeyB0eXBlOiAnVWludDE2JywgbmFtZTogJ2J1Y2tldEluZGV4JyB9LFxuXG4gICAgICAgIC8vIHJvdGF0ZWQgYW5kIHNjYWxlZCBiYm94IHVzZWQgZm9yIGluZGV4aW5nXG4gICAgICAgIHsgdHlwZTogJ0ludDE2JywgbmFtZTogJ2Jib3gwJyB9LFxuICAgICAgICB7IHR5cGU6ICdJbnQxNicsIG5hbWU6ICdiYm94MScgfSxcbiAgICAgICAgeyB0eXBlOiAnSW50MTYnLCBuYW1lOiAnYmJveDInIH0sXG4gICAgICAgIHsgdHlwZTogJ0ludDE2JywgbmFtZTogJ2Jib3gzJyB9LFxuXG4gICAgICAgIHsgdHlwZTogJ0Zsb2F0MzInLCBuYW1lOiAncGxhY2VtZW50U2NhbGUnIH1cbiAgICBdfSk7XG5cbnV0aWwuZXh0ZW5kQWxsKENvbGxpc2lvbkJveEFycmF5LnByb3RvdHlwZS5TdHJ1Y3RUeXBlLnByb3RvdHlwZSwge1xuICAgIGdldCBhbmNob3JQb2ludCgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQb2ludCh0aGlzLmFuY2hvclBvaW50WCwgdGhpcy5hbmNob3JQb2ludFkpO1xuICAgIH1cbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IENvbGxpc2lvbkZlYXR1cmU7XG5cbi8qKlxuICogQSBDb2xsaXNpb25GZWF0dXJlIHJlcHJlc2VudHMgdGhlIGFyZWEgb2YgdGhlIHRpbGUgY292ZXJlZCBieSBhIHNpbmdsZSBsYWJlbC5cbiAqIEl0IGlzIHVzZWQgd2l0aCBDb2xsaXNpb25UaWxlIHRvIGNoZWNrIGlmIHRoZSBsYWJlbCBvdmVybGFwcyB3aXRoIGFueVxuICogcHJldmlvdXMgbGFiZWxzLiBBIENvbGxpc2lvbkZlYXR1cmUgaXMgbW9zdGx5IGp1c3QgYSBzZXQgb2YgQ29sbGlzaW9uQm94XG4gKiBvYmplY3RzLlxuICpcbiAqIEBjbGFzcyBDb2xsaXNpb25GZWF0dXJlXG4gKiBAcGFyYW0ge0FycmF5PFBvaW50Pn0gbGluZSBUaGUgZ2VvbWV0cnkgdGhlIGxhYmVsIGlzIHBsYWNlZCBvbi5cbiAqIEBwYXJhbSB7QW5jaG9yfSBhbmNob3IgVGhlIHBvaW50IGFsb25nIHRoZSBsaW5lIGFyb3VuZCB3aGljaCB0aGUgbGFiZWwgaXMgYW5jaG9yZWQuXG4gKiBAcGFyYW0ge1ZlY3RvclRpbGVGZWF0dXJlfSBmZWF0dXJlIFRoZSBWZWN0b3JUaWxlRmVhdHVyZSB0aGF0IHRoaXMgQ29sbGlzaW9uRmVhdHVyZSB3YXMgY3JlYXRlZCBmb3IuXG4gKiBAcGFyYW0ge0FycmF5PHN0cmluZz59IGxheWVySURzIFRoZSBJRHMgb2YgdGhlIGxheWVycyB0aGF0IHRoaXMgQ29sbGlzaW9uRmVhdHVyZSBpcyBhIHBhcnQgb2YuXG4gKiBAcGFyYW0ge09iamVjdH0gc2hhcGVkIFRoZSB0ZXh0IG9yIGljb24gc2hhcGluZyByZXN1bHRzLlxuICogQHBhcmFtIHtudW1iZXJ9IGJveFNjYWxlIEEgbWFnaWMgbnVtYmVyIHVzZWQgdG8gY29udmVydCBmcm9tIGdseXBoIG1ldHJpY3MgdW5pdHMgdG8gZ2VvbWV0cnkgdW5pdHMuXG4gKiBAcGFyYW0ge251bWJlcn0gcGFkZGluZyBUaGUgYW1vdW50IG9mIHBhZGRpbmcgdG8gYWRkIGFyb3VuZCB0aGUgbGFiZWwgZWRnZXMuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGFsaWduTGluZSBXaGV0aGVyIHRoZSBsYWJlbCBpcyBhbGlnbmVkIHdpdGggdGhlIGxpbmUgb3IgdGhlIHZpZXdwb3J0LlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIENvbGxpc2lvbkZlYXR1cmUoY29sbGlzaW9uQm94QXJyYXksIGxpbmUsIGFuY2hvciwgZmVhdHVyZUluZGV4LCBzb3VyY2VMYXllckluZGV4LCBidWNrZXRJbmRleCwgc2hhcGVkLCBib3hTY2FsZSwgcGFkZGluZywgYWxpZ25MaW5lLCBzdHJhaWdodCkge1xuXG4gICAgdmFyIHkxID0gc2hhcGVkLnRvcCAqIGJveFNjYWxlIC0gcGFkZGluZztcbiAgICB2YXIgeTIgPSBzaGFwZWQuYm90dG9tICogYm94U2NhbGUgKyBwYWRkaW5nO1xuICAgIHZhciB4MSA9IHNoYXBlZC5sZWZ0ICogYm94U2NhbGUgLSBwYWRkaW5nO1xuICAgIHZhciB4MiA9IHNoYXBlZC5yaWdodCAqIGJveFNjYWxlICsgcGFkZGluZztcblxuICAgIHRoaXMuYm94U3RhcnRJbmRleCA9IGNvbGxpc2lvbkJveEFycmF5Lmxlbmd0aDtcblxuICAgIGlmIChhbGlnbkxpbmUpIHtcblxuICAgICAgICB2YXIgaGVpZ2h0ID0geTIgLSB5MTtcbiAgICAgICAgdmFyIGxlbmd0aCA9IHgyIC0geDE7XG5cbiAgICAgICAgaWYgKGhlaWdodCA+IDApIHtcbiAgICAgICAgICAgIC8vIHNldCBtaW5pbXVtIGJveCBoZWlnaHQgdG8gYXZvaWQgdmVyeSBtYW55IHNtYWxsIGxhYmVsc1xuICAgICAgICAgICAgaGVpZ2h0ID0gTWF0aC5tYXgoMTAgKiBib3hTY2FsZSwgaGVpZ2h0KTtcblxuICAgICAgICAgICAgaWYgKHN0cmFpZ2h0KSB7XG4gICAgICAgICAgICAgICAgLy8gdXNlZCBmb3IgaWNvbiBsYWJlbHMgdGhhdCBhcmUgYWxpZ25lZCB3aXRoIHRoZSBsaW5lLCBidXQgZG9uJ3QgY3VydmUgYWxvbmcgaXRcbiAgICAgICAgICAgICAgICB2YXIgdmVjdG9yID0gbGluZVthbmNob3Iuc2VnbWVudCArIDFdLnN1YihsaW5lW2FuY2hvci5zZWdtZW50XSkuX3VuaXQoKS5fbXVsdChsZW5ndGgpO1xuICAgICAgICAgICAgICAgIHZhciBzdHJhaWdodExpbmUgPSBbYW5jaG9yLnN1Yih2ZWN0b3IpLCBhbmNob3IuYWRkKHZlY3RvcildO1xuICAgICAgICAgICAgICAgIHRoaXMuX2FkZExpbmVDb2xsaXNpb25Cb3hlcyhjb2xsaXNpb25Cb3hBcnJheSwgc3RyYWlnaHRMaW5lLCBhbmNob3IsIDAsIGxlbmd0aCwgaGVpZ2h0LCBmZWF0dXJlSW5kZXgsIHNvdXJjZUxheWVySW5kZXgsIGJ1Y2tldEluZGV4KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gdXNlZCBmb3IgdGV4dCBsYWJlbHMgdGhhdCBjdXJ2ZSBhbG9uZyBhIGxpbmVcbiAgICAgICAgICAgICAgICB0aGlzLl9hZGRMaW5lQ29sbGlzaW9uQm94ZXMoY29sbGlzaW9uQm94QXJyYXksIGxpbmUsIGFuY2hvciwgYW5jaG9yLnNlZ21lbnQsIGxlbmd0aCwgaGVpZ2h0LCBmZWF0dXJlSW5kZXgsIHNvdXJjZUxheWVySW5kZXgsIGJ1Y2tldEluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgfSBlbHNlIHtcbiAgICAgICAgY29sbGlzaW9uQm94QXJyYXkuZW1wbGFjZUJhY2soYW5jaG9yLngsIGFuY2hvci55LCB4MSwgeTEsIHgyLCB5MiwgSW5maW5pdHksIGZlYXR1cmVJbmRleCwgc291cmNlTGF5ZXJJbmRleCwgYnVja2V0SW5kZXgsXG4gICAgICAgICAgICAgICAgMCwgMCwgMCwgMCwgMCk7XG4gICAgfVxuXG4gICAgdGhpcy5ib3hFbmRJbmRleCA9IGNvbGxpc2lvbkJveEFycmF5Lmxlbmd0aDtcbn1cblxuLyoqXG4gKiBDcmVhdGUgYSBzZXQgb2YgQ29sbGlzaW9uQm94IG9iamVjdHMgZm9yIGEgbGluZS5cbiAqXG4gKiBAcGFyYW0ge0FycmF5PFBvaW50Pn0gbGluZVxuICogQHBhcmFtIHtBbmNob3J9IGFuY2hvclxuICogQHBhcmFtIHtudW1iZXJ9IGxhYmVsTGVuZ3RoIFRoZSBsZW5ndGggb2YgdGhlIGxhYmVsIGluIGdlb21ldHJ5IHVuaXRzLlxuICogQHBhcmFtIHtBbmNob3J9IGFuY2hvciBUaGUgcG9pbnQgYWxvbmcgdGhlIGxpbmUgYXJvdW5kIHdoaWNoIHRoZSBsYWJlbCBpcyBhbmNob3JlZC5cbiAqIEBwYXJhbSB7VmVjdG9yVGlsZUZlYXR1cmV9IGZlYXR1cmUgVGhlIFZlY3RvclRpbGVGZWF0dXJlIHRoYXQgdGhpcyBDb2xsaXNpb25GZWF0dXJlIHdhcyBjcmVhdGVkIGZvci5cbiAqIEBwYXJhbSB7bnVtYmVyfSBib3hTaXplIFRoZSBzaXplIG9mIHRoZSBjb2xsaXNpb24gYm94ZXMgdGhhdCB3aWxsIGJlIGNyZWF0ZWQuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuQ29sbGlzaW9uRmVhdHVyZS5wcm90b3R5cGUuX2FkZExpbmVDb2xsaXNpb25Cb3hlcyA9IGZ1bmN0aW9uKGNvbGxpc2lvbkJveEFycmF5LCBsaW5lLCBhbmNob3IsIHNlZ21lbnQsIGxhYmVsTGVuZ3RoLCBib3hTaXplLCBmZWF0dXJlSW5kZXgsIHNvdXJjZUxheWVySW5kZXgsIGJ1Y2tldEluZGV4KSB7XG4gICAgdmFyIHN0ZXAgPSBib3hTaXplIC8gMjtcbiAgICB2YXIgbkJveGVzID0gTWF0aC5mbG9vcihsYWJlbExlbmd0aCAvIHN0ZXApO1xuXG4gICAgLy8gb2Zmc2V0IHRoZSBjZW50ZXIgb2YgdGhlIGZpcnN0IGJveCBieSBoYWxmIGEgYm94IHNvIHRoYXQgdGhlIGVkZ2Ugb2YgdGhlXG4gICAgLy8gYm94IGlzIGF0IHRoZSBlZGdlIG9mIHRoZSBsYWJlbC5cbiAgICB2YXIgZmlyc3RCb3hPZmZzZXQgPSAtYm94U2l6ZSAvIDI7XG5cbiAgICB2YXIgYmJveGVzID0gdGhpcy5ib3hlcztcblxuICAgIHZhciBwID0gYW5jaG9yO1xuICAgIHZhciBpbmRleCA9IHNlZ21lbnQgKyAxO1xuICAgIHZhciBhbmNob3JEaXN0YW5jZSA9IGZpcnN0Qm94T2Zmc2V0O1xuXG4gICAgLy8gbW92ZSBiYWNrd2FyZHMgYWxvbmcgdGhlIGxpbmUgdG8gdGhlIGZpcnN0IHNlZ21lbnQgdGhlIGxhYmVsIGFwcGVhcnMgb25cbiAgICBkbyB7XG4gICAgICAgIGluZGV4LS07XG5cbiAgICAgICAgLy8gdGhlcmUgaXNuJ3QgZW5vdWdoIHJvb20gZm9yIHRoZSBsYWJlbCBhZnRlciB0aGUgYmVnaW5uaW5nIG9mIHRoZSBsaW5lXG4gICAgICAgIC8vIGNoZWNrTWF4QW5nbGUgc2hvdWxkIGhhdmUgYWxyZWFkeSBjYXVnaHQgdGhpc1xuICAgICAgICBpZiAoaW5kZXggPCAwKSByZXR1cm4gYmJveGVzO1xuXG4gICAgICAgIGFuY2hvckRpc3RhbmNlIC09IGxpbmVbaW5kZXhdLmRpc3QocCk7XG4gICAgICAgIHAgPSBsaW5lW2luZGV4XTtcbiAgICB9IHdoaWxlIChhbmNob3JEaXN0YW5jZSA+IC1sYWJlbExlbmd0aCAvIDIpO1xuXG4gICAgdmFyIHNlZ21lbnRMZW5ndGggPSBsaW5lW2luZGV4XS5kaXN0KGxpbmVbaW5kZXggKyAxXSk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5Cb3hlczsgaSsrKSB7XG4gICAgICAgIC8vIHRoZSBkaXN0YW5jZSB0aGUgYm94IHdpbGwgYmUgZnJvbSB0aGUgYW5jaG9yXG4gICAgICAgIHZhciBib3hEaXN0YW5jZVRvQW5jaG9yID0gLWxhYmVsTGVuZ3RoIC8gMiArIGkgKiBzdGVwO1xuXG4gICAgICAgIC8vIHRoZSBib3ggaXMgbm90IG9uIHRoZSBjdXJyZW50IHNlZ21lbnQuIE1vdmUgdG8gdGhlIG5leHQgc2VnbWVudC5cbiAgICAgICAgd2hpbGUgKGFuY2hvckRpc3RhbmNlICsgc2VnbWVudExlbmd0aCA8IGJveERpc3RhbmNlVG9BbmNob3IpIHtcbiAgICAgICAgICAgIGFuY2hvckRpc3RhbmNlICs9IHNlZ21lbnRMZW5ndGg7XG4gICAgICAgICAgICBpbmRleCsrO1xuXG4gICAgICAgICAgICAvLyBUaGVyZSBpc24ndCBlbm91Z2ggcm9vbSBiZWZvcmUgdGhlIGVuZCBvZiB0aGUgbGluZS5cbiAgICAgICAgICAgIGlmIChpbmRleCArIDEgPj0gbGluZS5sZW5ndGgpIHJldHVybiBiYm94ZXM7XG5cbiAgICAgICAgICAgIHNlZ21lbnRMZW5ndGggPSBsaW5lW2luZGV4XS5kaXN0KGxpbmVbaW5kZXggKyAxXSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyB0aGUgZGlzdGFuY2UgdGhlIGJveCB3aWxsIGJlIGZyb20gdGhlIGJlZ2lubmluZyBvZiB0aGUgc2VnbWVudFxuICAgICAgICB2YXIgc2VnbWVudEJveERpc3RhbmNlID0gYm94RGlzdGFuY2VUb0FuY2hvciAtIGFuY2hvckRpc3RhbmNlO1xuXG4gICAgICAgIHZhciBwMCA9IGxpbmVbaW5kZXhdO1xuICAgICAgICB2YXIgcDEgPSBsaW5lW2luZGV4ICsgMV07XG4gICAgICAgIHZhciBib3hBbmNob3JQb2ludCA9IHAxLnN1YihwMCkuX3VuaXQoKS5fbXVsdChzZWdtZW50Qm94RGlzdGFuY2UpLl9hZGQocDApLl9yb3VuZCgpO1xuXG4gICAgICAgIHZhciBkaXN0YW5jZVRvSW5uZXJFZGdlID0gTWF0aC5tYXgoTWF0aC5hYnMoYm94RGlzdGFuY2VUb0FuY2hvciAtIGZpcnN0Qm94T2Zmc2V0KSAtIHN0ZXAgLyAyLCAwKTtcbiAgICAgICAgdmFyIG1heFNjYWxlID0gbGFiZWxMZW5ndGggLyAyIC8gZGlzdGFuY2VUb0lubmVyRWRnZTtcblxuICAgICAgICBjb2xsaXNpb25Cb3hBcnJheS5lbXBsYWNlQmFjayhib3hBbmNob3JQb2ludC54LCBib3hBbmNob3JQb2ludC55LFxuICAgICAgICAgICAgICAgIC1ib3hTaXplIC8gMiwgLWJveFNpemUgLyAyLCBib3hTaXplIC8gMiwgYm94U2l6ZSAvIDIsIG1heFNjYWxlLFxuICAgICAgICAgICAgICAgIGZlYXR1cmVJbmRleCwgc291cmNlTGF5ZXJJbmRleCwgYnVja2V0SW5kZXgsXG4gICAgICAgICAgICAgICAgMCwgMCwgMCwgMCwgMCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGJib3hlcztcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBQb2ludCA9IHJlcXVpcmUoJ3BvaW50LWdlb21ldHJ5Jyk7XG52YXIgRVhURU5UID0gcmVxdWlyZSgnLi4vZGF0YS9idWNrZXQnKS5FWFRFTlQ7XG52YXIgR3JpZCA9IHJlcXVpcmUoJy4uL3V0aWwvZ3JpZCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IENvbGxpc2lvblRpbGU7XG5cbi8qKlxuICogQSBjb2xsaXNpb24gdGlsZSB1c2VkIHRvIHByZXZlbnQgc3ltYm9scyBmcm9tIG92ZXJsYXBwaW5nLiBJdCBrZWVwIHRyYWNrcyBvZlxuICogd2hlcmUgcHJldmlvdXMgc3ltYm9scyBoYXZlIGJlZW4gcGxhY2VkIGFuZCBpcyB1c2VkIHRvIGNoZWNrIGlmIGEgbmV3XG4gKiBzeW1ib2wgb3ZlcmxhcHMgd2l0aCBhbnkgcHJldmlvdXNseSBhZGRlZCBzeW1ib2xzLlxuICpcbiAqIEBjbGFzcyBDb2xsaXNpb25UaWxlXG4gKiBAcGFyYW0ge251bWJlcn0gYW5nbGVcbiAqIEBwYXJhbSB7bnVtYmVyfSBwaXRjaFxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gQ29sbGlzaW9uVGlsZShhbmdsZSwgcGl0Y2gsIGNvbGxpc2lvbkJveEFycmF5KSB7XG4gICAgaWYgKHR5cGVvZiBhbmdsZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgdmFyIHNlcmlhbGl6ZWQgPSBhbmdsZTtcbiAgICAgICAgY29sbGlzaW9uQm94QXJyYXkgPSBwaXRjaDtcbiAgICAgICAgYW5nbGUgPSBzZXJpYWxpemVkLmFuZ2xlO1xuICAgICAgICBwaXRjaCA9IHNlcmlhbGl6ZWQucGl0Y2g7XG4gICAgICAgIHRoaXMuZ3JpZCA9IG5ldyBHcmlkKHNlcmlhbGl6ZWQuZ3JpZCk7XG4gICAgICAgIHRoaXMuaWdub3JlZEdyaWQgPSBuZXcgR3JpZChzZXJpYWxpemVkLmlnbm9yZWRHcmlkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmdyaWQgPSBuZXcgR3JpZCgxMiwgRVhURU5ULCA2KTtcbiAgICAgICAgdGhpcy5pZ25vcmVkR3JpZCA9IG5ldyBHcmlkKDEyLCBFWFRFTlQsIDApO1xuICAgIH1cblxuICAgIHRoaXMuYW5nbGUgPSBhbmdsZTtcbiAgICB0aGlzLnBpdGNoID0gcGl0Y2g7XG5cbiAgICB2YXIgc2luID0gTWF0aC5zaW4oYW5nbGUpLFxuICAgICAgICBjb3MgPSBNYXRoLmNvcyhhbmdsZSk7XG4gICAgdGhpcy5yb3RhdGlvbk1hdHJpeCA9IFtjb3MsIC1zaW4sIHNpbiwgY29zXTtcbiAgICB0aGlzLnJldmVyc2VSb3RhdGlvbk1hdHJpeCA9IFtjb3MsIHNpbiwgLXNpbiwgY29zXTtcblxuICAgIC8vIFN0cmV0Y2ggYm94ZXMgaW4geSBkaXJlY3Rpb24gdG8gYWNjb3VudCBmb3IgdGhlIG1hcCB0aWx0LlxuICAgIHRoaXMueVN0cmV0Y2ggPSAxIC8gTWF0aC5jb3MocGl0Y2ggLyAxODAgKiBNYXRoLlBJKTtcblxuICAgIC8vIFRoZSBhbW91bnQgdGhlIG1hcCBpcyBzcXVpc2hlZCBkZXBlbmRzIG9uIHRoZSB5IHBvc2l0aW9uLlxuICAgIC8vIFNvcnQgb2YgYWNjb3VudCBmb3IgdGhpcyBieSBtYWtpbmcgYWxsIGJveGVzIGEgYml0IGJpZ2dlci5cbiAgICB0aGlzLnlTdHJldGNoID0gTWF0aC5wb3codGhpcy55U3RyZXRjaCwgMS4zKTtcblxuICAgIHRoaXMuY29sbGlzaW9uQm94QXJyYXkgPSBjb2xsaXNpb25Cb3hBcnJheTtcbiAgICBpZiAoY29sbGlzaW9uQm94QXJyYXkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIC8vIHRoZSBmaXJzdCBjb2xsaXNpb25Cb3hBcnJheSBpcyBwYXNzZWQgdG8gYSBDb2xsaXNpb25UaWxlXG5cbiAgICAgICAgLy8gdGVtcENvbGxpc2lvbkJveFxuICAgICAgICBjb2xsaXNpb25Cb3hBcnJheS5lbXBsYWNlQmFjaygpO1xuXG4gICAgICAgIHZhciBtYXhJbnQxNiA9IDMyNzY3O1xuICAgICAgICAvL2xlZnRcbiAgICAgICAgY29sbGlzaW9uQm94QXJyYXkuZW1wbGFjZUJhY2soMCwgMCwgMCwgLW1heEludDE2LCAwLCBtYXhJbnQxNiwgbWF4SW50MTYsXG4gICAgICAgICAgICAgICAgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCxcbiAgICAgICAgICAgICAgICAwKTtcbiAgICAgICAgLy8gcmlnaHRcbiAgICAgICAgY29sbGlzaW9uQm94QXJyYXkuZW1wbGFjZUJhY2soRVhURU5ULCAwLCAwLCAtbWF4SW50MTYsIDAsIG1heEludDE2LCBtYXhJbnQxNixcbiAgICAgICAgICAgICAgICAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLFxuICAgICAgICAgICAgICAgIDApO1xuICAgICAgICAvLyB0b3BcbiAgICAgICAgY29sbGlzaW9uQm94QXJyYXkuZW1wbGFjZUJhY2soMCwgMCwgLW1heEludDE2LCAwLCBtYXhJbnQxNiwgMCwgbWF4SW50MTYsXG4gICAgICAgICAgICAgICAgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCxcbiAgICAgICAgICAgICAgICAwKTtcbiAgICAgICAgLy8gYm90dG9tXG4gICAgICAgIGNvbGxpc2lvbkJveEFycmF5LmVtcGxhY2VCYWNrKDAsIEVYVEVOVCwgLW1heEludDE2LCAwLCBtYXhJbnQxNiwgMCwgbWF4SW50MTYsXG4gICAgICAgICAgICAgICAgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCxcbiAgICAgICAgICAgICAgICAwKTtcbiAgICB9XG5cbiAgICB0aGlzLnRlbXBDb2xsaXNpb25Cb3ggPSBjb2xsaXNpb25Cb3hBcnJheS5nZXQoMCk7XG4gICAgdGhpcy5lZGdlcyA9IFtcbiAgICAgICAgY29sbGlzaW9uQm94QXJyYXkuZ2V0KDEpLFxuICAgICAgICBjb2xsaXNpb25Cb3hBcnJheS5nZXQoMiksXG4gICAgICAgIGNvbGxpc2lvbkJveEFycmF5LmdldCgzKSxcbiAgICAgICAgY29sbGlzaW9uQm94QXJyYXkuZ2V0KDQpXG4gICAgXTtcbn1cblxuQ29sbGlzaW9uVGlsZS5wcm90b3R5cGUuc2VyaWFsaXplID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGRhdGEgPSB7XG4gICAgICAgIGFuZ2xlOiB0aGlzLmFuZ2xlLFxuICAgICAgICBwaXRjaDogdGhpcy5waXRjaCxcbiAgICAgICAgZ3JpZDogdGhpcy5ncmlkLnRvQXJyYXlCdWZmZXIoKSxcbiAgICAgICAgaWdub3JlZEdyaWQ6IHRoaXMuaWdub3JlZEdyaWQudG9BcnJheUJ1ZmZlcigpXG4gICAgfTtcbiAgICByZXR1cm4ge1xuICAgICAgICBkYXRhOiBkYXRhLFxuICAgICAgICB0cmFuc2ZlcmFibGVzOiBbZGF0YS5ncmlkLCBkYXRhLmlnbm9yZWRHcmlkXVxuICAgIH07XG59O1xuXG5Db2xsaXNpb25UaWxlLnByb3RvdHlwZS5taW5TY2FsZSA9IDAuMjU7XG5Db2xsaXNpb25UaWxlLnByb3RvdHlwZS5tYXhTY2FsZSA9IDI7XG5cblxuLyoqXG4gKiBGaW5kIHRoZSBzY2FsZSBhdCB3aGljaCB0aGUgY29sbGlzaW9uRmVhdHVyZSBjYW4gYmUgc2hvd24gd2l0aG91dFxuICogb3ZlcmxhcHBpbmcgd2l0aCBvdGhlciBmZWF0dXJlcy5cbiAqXG4gKiBAcGFyYW0ge0NvbGxpc2lvbkZlYXR1cmV9IGNvbGxpc2lvbkZlYXR1cmVcbiAqIEByZXR1cm5zIHtudW1iZXJ9IHBsYWNlbWVudFNjYWxlXG4gKiBAcHJpdmF0ZVxuICovXG5Db2xsaXNpb25UaWxlLnByb3RvdHlwZS5wbGFjZUNvbGxpc2lvbkZlYXR1cmUgPSBmdW5jdGlvbihjb2xsaXNpb25GZWF0dXJlLCBhbGxvd092ZXJsYXAsIGF2b2lkRWRnZXMpIHtcblxuICAgIHZhciBjb2xsaXNpb25Cb3hBcnJheSA9IHRoaXMuY29sbGlzaW9uQm94QXJyYXk7XG4gICAgdmFyIG1pblBsYWNlbWVudFNjYWxlID0gdGhpcy5taW5TY2FsZTtcbiAgICB2YXIgcm90YXRpb25NYXRyaXggPSB0aGlzLnJvdGF0aW9uTWF0cml4O1xuICAgIHZhciB5U3RyZXRjaCA9IHRoaXMueVN0cmV0Y2g7XG5cbiAgICBmb3IgKHZhciBiID0gY29sbGlzaW9uRmVhdHVyZS5ib3hTdGFydEluZGV4OyBiIDwgY29sbGlzaW9uRmVhdHVyZS5ib3hFbmRJbmRleDsgYisrKSB7XG5cbiAgICAgICAgdmFyIGJveCA9IGNvbGxpc2lvbkJveEFycmF5LmdldChiKTtcblxuICAgICAgICB2YXIgYW5jaG9yUG9pbnQgPSBib3guYW5jaG9yUG9pbnQuX21hdE11bHQocm90YXRpb25NYXRyaXgpO1xuICAgICAgICB2YXIgeCA9IGFuY2hvclBvaW50Lng7XG4gICAgICAgIHZhciB5ID0gYW5jaG9yUG9pbnQueTtcblxuICAgICAgICB2YXIgeDEgPSB4ICsgYm94LngxO1xuICAgICAgICB2YXIgeTEgPSB5ICsgYm94LnkxICogeVN0cmV0Y2g7XG4gICAgICAgIHZhciB4MiA9IHggKyBib3gueDI7XG4gICAgICAgIHZhciB5MiA9IHkgKyBib3gueTIgKiB5U3RyZXRjaDtcblxuICAgICAgICBib3guYmJveDAgPSB4MTtcbiAgICAgICAgYm94LmJib3gxID0geTE7XG4gICAgICAgIGJveC5iYm94MiA9IHgyO1xuICAgICAgICBib3guYmJveDMgPSB5MjtcblxuICAgICAgICBpZiAoIWFsbG93T3ZlcmxhcCkge1xuICAgICAgICAgICAgdmFyIGJsb2NraW5nQm94ZXMgPSB0aGlzLmdyaWQucXVlcnkoeDEsIHkxLCB4MiwgeTIpO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJsb2NraW5nQm94ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgYmxvY2tpbmcgPSBjb2xsaXNpb25Cb3hBcnJheS5nZXQoYmxvY2tpbmdCb3hlc1tpXSk7XG4gICAgICAgICAgICAgICAgdmFyIGJsb2NraW5nQW5jaG9yUG9pbnQgPSBibG9ja2luZy5hbmNob3JQb2ludC5fbWF0TXVsdChyb3RhdGlvbk1hdHJpeCk7XG5cbiAgICAgICAgICAgICAgICBtaW5QbGFjZW1lbnRTY2FsZSA9IHRoaXMuZ2V0UGxhY2VtZW50U2NhbGUobWluUGxhY2VtZW50U2NhbGUsIGFuY2hvclBvaW50LCBib3gsIGJsb2NraW5nQW5jaG9yUG9pbnQsIGJsb2NraW5nKTtcbiAgICAgICAgICAgICAgICBpZiAobWluUGxhY2VtZW50U2NhbGUgPj0gdGhpcy5tYXhTY2FsZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWluUGxhY2VtZW50U2NhbGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGF2b2lkRWRnZXMpIHtcbiAgICAgICAgICAgIHZhciByb3RhdGVkQ29sbGlzaW9uQm94O1xuXG4gICAgICAgICAgICBpZiAodGhpcy5hbmdsZSkge1xuICAgICAgICAgICAgICAgIHZhciByZXZlcnNlUm90YXRpb25NYXRyaXggPSB0aGlzLnJldmVyc2VSb3RhdGlvbk1hdHJpeDtcbiAgICAgICAgICAgICAgICB2YXIgdGwgPSBuZXcgUG9pbnQoYm94LngxLCBib3gueTEpLm1hdE11bHQocmV2ZXJzZVJvdGF0aW9uTWF0cml4KTtcbiAgICAgICAgICAgICAgICB2YXIgdHIgPSBuZXcgUG9pbnQoYm94LngyLCBib3gueTEpLm1hdE11bHQocmV2ZXJzZVJvdGF0aW9uTWF0cml4KTtcbiAgICAgICAgICAgICAgICB2YXIgYmwgPSBuZXcgUG9pbnQoYm94LngxLCBib3gueTIpLm1hdE11bHQocmV2ZXJzZVJvdGF0aW9uTWF0cml4KTtcbiAgICAgICAgICAgICAgICB2YXIgYnIgPSBuZXcgUG9pbnQoYm94LngyLCBib3gueTIpLm1hdE11bHQocmV2ZXJzZVJvdGF0aW9uTWF0cml4KTtcblxuICAgICAgICAgICAgICAgIHJvdGF0ZWRDb2xsaXNpb25Cb3ggPSB0aGlzLnRlbXBDb2xsaXNpb25Cb3g7XG4gICAgICAgICAgICAgICAgcm90YXRlZENvbGxpc2lvbkJveC5hbmNob3JQb2ludFggPSBib3guYW5jaG9yUG9pbnQueDtcbiAgICAgICAgICAgICAgICByb3RhdGVkQ29sbGlzaW9uQm94LmFuY2hvclBvaW50WSA9IGJveC5hbmNob3JQb2ludC55O1xuICAgICAgICAgICAgICAgIHJvdGF0ZWRDb2xsaXNpb25Cb3gueDEgPSBNYXRoLm1pbih0bC54LCB0ci54LCBibC54LCBici54KTtcbiAgICAgICAgICAgICAgICByb3RhdGVkQ29sbGlzaW9uQm94LnkxID0gTWF0aC5taW4odGwueSwgdHIueCwgYmwueCwgYnIueCk7XG4gICAgICAgICAgICAgICAgcm90YXRlZENvbGxpc2lvbkJveC54MiA9IE1hdGgubWF4KHRsLngsIHRyLngsIGJsLngsIGJyLngpO1xuICAgICAgICAgICAgICAgIHJvdGF0ZWRDb2xsaXNpb25Cb3gueTIgPSBNYXRoLm1heCh0bC55LCB0ci54LCBibC54LCBici54KTtcbiAgICAgICAgICAgICAgICByb3RhdGVkQ29sbGlzaW9uQm94Lm1heFNjYWxlID0gYm94Lm1heFNjYWxlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByb3RhdGVkQ29sbGlzaW9uQm94ID0gYm94O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKHZhciBrID0gMDsgayA8IHRoaXMuZWRnZXMubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgZWRnZUJveCA9IHRoaXMuZWRnZXNba107XG4gICAgICAgICAgICAgICAgbWluUGxhY2VtZW50U2NhbGUgPSB0aGlzLmdldFBsYWNlbWVudFNjYWxlKG1pblBsYWNlbWVudFNjYWxlLCBib3guYW5jaG9yUG9pbnQsIHJvdGF0ZWRDb2xsaXNpb25Cb3gsIGVkZ2VCb3guYW5jaG9yUG9pbnQsIGVkZ2VCb3gpO1xuICAgICAgICAgICAgICAgIGlmIChtaW5QbGFjZW1lbnRTY2FsZSA+PSB0aGlzLm1heFNjYWxlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBtaW5QbGFjZW1lbnRTY2FsZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbWluUGxhY2VtZW50U2NhbGU7XG59O1xuXG5Db2xsaXNpb25UaWxlLnByb3RvdHlwZS5xdWVyeVJlbmRlcmVkU3ltYm9scyA9IGZ1bmN0aW9uKG1pblgsIG1pblksIG1heFgsIG1heFksIHNjYWxlKSB7XG4gICAgdmFyIHNvdXJjZUxheWVyRmVhdHVyZXMgPSB7fTtcbiAgICB2YXIgcmVzdWx0ID0gW107XG5cbiAgICB2YXIgY29sbGlzaW9uQm94QXJyYXkgPSB0aGlzLmNvbGxpc2lvbkJveEFycmF5O1xuICAgIHZhciByb3RhdGlvbk1hdHJpeCA9IHRoaXMucm90YXRpb25NYXRyaXg7XG4gICAgdmFyIGFuY2hvclBvaW50ID0gbmV3IFBvaW50KG1pblgsIG1pblkpLl9tYXRNdWx0KHJvdGF0aW9uTWF0cml4KTtcblxuICAgIHZhciBxdWVyeUJveCA9IHRoaXMudGVtcENvbGxpc2lvbkJveDtcbiAgICBxdWVyeUJveC5hbmNob3JYID0gYW5jaG9yUG9pbnQueDtcbiAgICBxdWVyeUJveC5hbmNob3JZID0gYW5jaG9yUG9pbnQueTtcbiAgICBxdWVyeUJveC54MSA9IDA7XG4gICAgcXVlcnlCb3gueTEgPSAwO1xuICAgIHF1ZXJ5Qm94LngyID0gbWF4WCAtIG1pblg7XG4gICAgcXVlcnlCb3gueTIgPSBtYXhZIC0gbWluWTtcbiAgICBxdWVyeUJveC5tYXhTY2FsZSA9IHNjYWxlO1xuXG4gICAgLy8gbWF4U2NhbGUgaXMgc3RvcmVkIHVzaW5nIGEgRmxvYXQzMi4gQ29udmVydCBgc2NhbGVgIHRvIHRoZSBzdG9yZWQgRmxvYXQzMiB2YWx1ZS5cbiAgICBzY2FsZSA9IHF1ZXJ5Qm94Lm1heFNjYWxlO1xuXG4gICAgdmFyIHNlYXJjaEJveCA9IFtcbiAgICAgICAgYW5jaG9yUG9pbnQueCArIHF1ZXJ5Qm94LngxIC8gc2NhbGUsXG4gICAgICAgIGFuY2hvclBvaW50LnkgKyBxdWVyeUJveC55MSAvIHNjYWxlICogdGhpcy55U3RyZXRjaCxcbiAgICAgICAgYW5jaG9yUG9pbnQueCArIHF1ZXJ5Qm94LngyIC8gc2NhbGUsXG4gICAgICAgIGFuY2hvclBvaW50LnkgKyBxdWVyeUJveC55MiAvIHNjYWxlICogdGhpcy55U3RyZXRjaFxuICAgIF07XG5cbiAgICB2YXIgYmxvY2tpbmdCb3hLZXlzID0gdGhpcy5ncmlkLnF1ZXJ5KHNlYXJjaEJveFswXSwgc2VhcmNoQm94WzFdLCBzZWFyY2hCb3hbMl0sIHNlYXJjaEJveFszXSk7XG4gICAgdmFyIGJsb2NraW5nQm94S2V5czIgPSB0aGlzLmlnbm9yZWRHcmlkLnF1ZXJ5KHNlYXJjaEJveFswXSwgc2VhcmNoQm94WzFdLCBzZWFyY2hCb3hbMl0sIHNlYXJjaEJveFszXSk7XG4gICAgZm9yICh2YXIgayA9IDA7IGsgPCBibG9ja2luZ0JveEtleXMyLmxlbmd0aDsgaysrKSB7XG4gICAgICAgIGJsb2NraW5nQm94S2V5cy5wdXNoKGJsb2NraW5nQm94S2V5czJba10pO1xuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYmxvY2tpbmdCb3hLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBibG9ja2luZyA9IGNvbGxpc2lvbkJveEFycmF5LmdldChibG9ja2luZ0JveEtleXNbaV0pO1xuXG4gICAgICAgIHZhciBzb3VyY2VMYXllciA9IGJsb2NraW5nLnNvdXJjZUxheWVySW5kZXg7XG4gICAgICAgIHZhciBmZWF0dXJlSW5kZXggPSBibG9ja2luZy5mZWF0dXJlSW5kZXg7XG4gICAgICAgIGlmIChzb3VyY2VMYXllckZlYXR1cmVzW3NvdXJjZUxheWVyXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBzb3VyY2VMYXllckZlYXR1cmVzW3NvdXJjZUxheWVyXSA9IHt9O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFzb3VyY2VMYXllckZlYXR1cmVzW3NvdXJjZUxheWVyXVtmZWF0dXJlSW5kZXhdKSB7XG4gICAgICAgICAgICB2YXIgYmxvY2tpbmdBbmNob3JQb2ludCA9IGJsb2NraW5nLmFuY2hvclBvaW50Lm1hdE11bHQocm90YXRpb25NYXRyaXgpO1xuICAgICAgICAgICAgdmFyIG1pblBsYWNlbWVudFNjYWxlID0gdGhpcy5nZXRQbGFjZW1lbnRTY2FsZSh0aGlzLm1pblNjYWxlLCBhbmNob3JQb2ludCwgcXVlcnlCb3gsIGJsb2NraW5nQW5jaG9yUG9pbnQsIGJsb2NraW5nKTtcbiAgICAgICAgICAgIGlmIChtaW5QbGFjZW1lbnRTY2FsZSA+PSBzY2FsZSkge1xuICAgICAgICAgICAgICAgIHNvdXJjZUxheWVyRmVhdHVyZXNbc291cmNlTGF5ZXJdW2ZlYXR1cmVJbmRleF0gPSB0cnVlO1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGJsb2NraW5nQm94S2V5c1tpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xufTtcblxuQ29sbGlzaW9uVGlsZS5wcm90b3R5cGUuZ2V0UGxhY2VtZW50U2NhbGUgPSBmdW5jdGlvbihtaW5QbGFjZW1lbnRTY2FsZSwgYW5jaG9yUG9pbnQsIGJveCwgYmxvY2tpbmdBbmNob3JQb2ludCwgYmxvY2tpbmcpIHtcblxuICAgIC8vIEZpbmQgdGhlIGxvd2VzdCBzY2FsZSBhdCB3aGljaCB0aGUgdHdvIGJveGVzIGNhbiBmaXQgc2lkZSBieSBzaWRlIHdpdGhvdXQgb3ZlcmxhcHBpbmcuXG4gICAgLy8gT3JpZ2luYWwgYWxnb3JpdGhtOlxuICAgIHZhciBhbmNob3JEaWZmWCA9IGFuY2hvclBvaW50LnggLSBibG9ja2luZ0FuY2hvclBvaW50Lng7XG4gICAgdmFyIGFuY2hvckRpZmZZID0gYW5jaG9yUG9pbnQueSAtIGJsb2NraW5nQW5jaG9yUG9pbnQueTtcbiAgICB2YXIgczEgPSAoYmxvY2tpbmcueDEgLSBib3gueDIpIC8gYW5jaG9yRGlmZlg7IC8vIHNjYWxlIGF0IHdoaWNoIG5ldyBib3ggaXMgdG8gdGhlIGxlZnQgb2Ygb2xkIGJveFxuICAgIHZhciBzMiA9IChibG9ja2luZy54MiAtIGJveC54MSkgLyBhbmNob3JEaWZmWDsgLy8gc2NhbGUgYXQgd2hpY2ggbmV3IGJveCBpcyB0byB0aGUgcmlnaHQgb2Ygb2xkIGJveFxuICAgIHZhciBzMyA9IChibG9ja2luZy55MSAtIGJveC55MikgKiB0aGlzLnlTdHJldGNoIC8gYW5jaG9yRGlmZlk7IC8vIHNjYWxlIGF0IHdoaWNoIG5ldyBib3ggaXMgdG8gdGhlIHRvcCBvZiBvbGQgYm94XG4gICAgdmFyIHM0ID0gKGJsb2NraW5nLnkyIC0gYm94LnkxKSAqIHRoaXMueVN0cmV0Y2ggLyBhbmNob3JEaWZmWTsgLy8gc2NhbGUgYXQgd2hpY2ggbmV3IGJveCBpcyB0byB0aGUgYm90dG9tIG9mIG9sZCBib3hcblxuICAgIGlmIChpc05hTihzMSkgfHwgaXNOYU4oczIpKSBzMSA9IHMyID0gMTtcbiAgICBpZiAoaXNOYU4oczMpIHx8IGlzTmFOKHM0KSkgczMgPSBzNCA9IDE7XG5cbiAgICB2YXIgY29sbGlzaW9uRnJlZVNjYWxlID0gTWF0aC5taW4oTWF0aC5tYXgoczEsIHMyKSwgTWF0aC5tYXgoczMsIHM0KSk7XG4gICAgdmFyIGJsb2NraW5nTWF4U2NhbGUgPSBibG9ja2luZy5tYXhTY2FsZTtcbiAgICB2YXIgYm94TWF4U2NhbGUgPSBib3gubWF4U2NhbGU7XG5cbiAgICBpZiAoY29sbGlzaW9uRnJlZVNjYWxlID4gYmxvY2tpbmdNYXhTY2FsZSkge1xuICAgICAgICAvLyBBZnRlciBhIGJveCdzIG1heFNjYWxlIHRoZSBsYWJlbCBoYXMgc2hydW5rIGVub3VnaCB0aGF0IHRoZSBib3ggaXMgbm8gbG9uZ2VyIG5lZWRlZCB0byBjb3ZlciBpdCxcbiAgICAgICAgLy8gc28gdW5ibG9jayB0aGUgbmV3IGJveCBhdCB0aGUgc2NhbGUgdGhhdCB0aGUgb2xkIGJveCBkaXNhcHBlYXJzLlxuICAgICAgICBjb2xsaXNpb25GcmVlU2NhbGUgPSBibG9ja2luZ01heFNjYWxlO1xuICAgIH1cblxuICAgIGlmIChjb2xsaXNpb25GcmVlU2NhbGUgPiBib3hNYXhTY2FsZSkge1xuICAgICAgICAvLyBJZiB0aGUgYm94IGNhbiBvbmx5IGJlIHNob3duIGFmdGVyIGl0IGlzIHZpc2libGUsIHRoZW4gdGhlIGJveCBjYW4gbmV2ZXIgYmUgc2hvd24uXG4gICAgICAgIC8vIEJ1dCB0aGUgbGFiZWwgY2FuIGJlIHNob3duIGFmdGVyIHRoaXMgYm94IGlzIG5vdCB2aXNpYmxlLlxuICAgICAgICBjb2xsaXNpb25GcmVlU2NhbGUgPSBib3hNYXhTY2FsZTtcbiAgICB9XG5cbiAgICBpZiAoY29sbGlzaW9uRnJlZVNjYWxlID4gbWluUGxhY2VtZW50U2NhbGUgJiZcbiAgICAgICAgICAgIGNvbGxpc2lvbkZyZWVTY2FsZSA+PSBibG9ja2luZy5wbGFjZW1lbnRTY2FsZSkge1xuICAgICAgICAvLyBJZiB0aGlzIGNvbGxpc2lvbiBvY2N1cnMgYXQgYSBsb3dlciBzY2FsZSB0aGFuIHByZXZpb3VzbHkgZm91bmQgY29sbGlzaW9uc1xuICAgICAgICAvLyBhbmQgdGhlIGNvbGxpc2lvbiBvY2N1cnMgd2hpbGUgdGhlIG90aGVyIGxhYmVsIGlzIHZpc2libGVcblxuICAgICAgICAvLyB0aGlzIHRoaXMgaXMgdGhlIGxvd2VzdCBzY2FsZSBhdCB3aGljaCB0aGUgbGFiZWwgd29uJ3QgY29sbGlkZSB3aXRoIGFueXRoaW5nXG4gICAgICAgIG1pblBsYWNlbWVudFNjYWxlID0gY29sbGlzaW9uRnJlZVNjYWxlO1xuICAgIH1cblxuICAgIHJldHVybiBtaW5QbGFjZW1lbnRTY2FsZTtcbn07XG5cblxuLyoqXG4gKiBSZW1lbWJlciB0aGlzIGNvbGxpc2lvbkZlYXR1cmUgYW5kIHdoYXQgc2NhbGUgaXQgd2FzIHBsYWNlZCBhdCB0byBibG9ja1xuICogbGF0ZXIgZmVhdHVyZXMgZnJvbSBvdmVybGFwcGluZyB3aXRoIGl0LlxuICpcbiAqIEBwYXJhbSB7Q29sbGlzaW9uRmVhdHVyZX0gY29sbGlzaW9uRmVhdHVyZVxuICogQHBhcmFtIHtudW1iZXJ9IG1pblBsYWNlbWVudFNjYWxlXG4gKiBAcHJpdmF0ZVxuICovXG5Db2xsaXNpb25UaWxlLnByb3RvdHlwZS5pbnNlcnRDb2xsaXNpb25GZWF0dXJlID0gZnVuY3Rpb24oY29sbGlzaW9uRmVhdHVyZSwgbWluUGxhY2VtZW50U2NhbGUsIGlnbm9yZVBsYWNlbWVudCkge1xuXG4gICAgdmFyIGdyaWQgPSBpZ25vcmVQbGFjZW1lbnQgPyB0aGlzLmlnbm9yZWRHcmlkIDogdGhpcy5ncmlkO1xuICAgIHZhciBjb2xsaXNpb25Cb3hBcnJheSA9IHRoaXMuY29sbGlzaW9uQm94QXJyYXk7XG5cbiAgICBmb3IgKHZhciBrID0gY29sbGlzaW9uRmVhdHVyZS5ib3hTdGFydEluZGV4OyBrIDwgY29sbGlzaW9uRmVhdHVyZS5ib3hFbmRJbmRleDsgaysrKSB7XG4gICAgICAgIHZhciBib3ggPSBjb2xsaXNpb25Cb3hBcnJheS5nZXQoayk7XG4gICAgICAgIGJveC5wbGFjZW1lbnRTY2FsZSA9IG1pblBsYWNlbWVudFNjYWxlO1xuICAgICAgICBpZiAobWluUGxhY2VtZW50U2NhbGUgPCB0aGlzLm1heFNjYWxlKSB7XG4gICAgICAgICAgICBncmlkLmluc2VydChrLCBib3guYmJveDAsIGJveC5iYm94MSwgYm94LmJib3gyLCBib3guYmJveDMpO1xuICAgICAgICB9XG4gICAgfVxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGludGVycG9sYXRlID0gcmVxdWlyZSgnLi4vdXRpbC9pbnRlcnBvbGF0ZScpO1xudmFyIEFuY2hvciA9IHJlcXVpcmUoJy4uL3N5bWJvbC9hbmNob3InKTtcbnZhciBjaGVja01heEFuZ2xlID0gcmVxdWlyZSgnLi9jaGVja19tYXhfYW5nbGUnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBnZXRBbmNob3JzO1xuXG5mdW5jdGlvbiBnZXRBbmNob3JzKGxpbmUsIHNwYWNpbmcsIG1heEFuZ2xlLCBzaGFwZWRUZXh0LCBzaGFwZWRJY29uLCBnbHlwaFNpemUsIGJveFNjYWxlLCBvdmVyc2NhbGluZywgdGlsZUV4dGVudCkge1xuXG4gICAgLy8gUmVzYW1wbGUgYSBsaW5lIHRvIGdldCBhbmNob3IgcG9pbnRzIGZvciBsYWJlbHMgYW5kIGNoZWNrIHRoYXQgZWFjaFxuICAgIC8vIHBvdGVudGlhbCBsYWJlbCBwYXNzZXMgdGV4dC1tYXgtYW5nbGUgY2hlY2sgYW5kIGhhcyBlbm91Z2ggZnJvb20gdG8gZml0XG4gICAgLy8gb24gdGhlIGxpbmUuXG5cbiAgICB2YXIgYW5nbGVXaW5kb3dTaXplID0gc2hhcGVkVGV4dCA/XG4gICAgICAgIDMgLyA1ICogZ2x5cGhTaXplICogYm94U2NhbGUgOlxuICAgICAgICAwO1xuXG4gICAgdmFyIGxhYmVsTGVuZ3RoID0gTWF0aC5tYXgoXG4gICAgICAgIHNoYXBlZFRleHQgPyBzaGFwZWRUZXh0LnJpZ2h0IC0gc2hhcGVkVGV4dC5sZWZ0IDogMCxcbiAgICAgICAgc2hhcGVkSWNvbiA/IHNoYXBlZEljb24ucmlnaHQgLSBzaGFwZWRJY29uLmxlZnQgOiAwKTtcblxuICAgIC8vIElzIHRoZSBsaW5lIGNvbnRpbnVlZCBmcm9tIG91dHNpZGUgdGhlIHRpbGUgYm91bmRhcnk/XG4gICAgdmFyIGlzTGluZUNvbnRpbnVlZCA9IGxpbmVbMF0ueCA9PT0gMCB8fCBsaW5lWzBdLnggPT09IHRpbGVFeHRlbnQgfHwgbGluZVswXS55ID09PSAwIHx8IGxpbmVbMF0ueSA9PT0gdGlsZUV4dGVudDtcblxuICAgIC8vIElzIHRoZSBsYWJlbCBsb25nLCByZWxhdGl2ZSB0byB0aGUgc3BhY2luZz9cbiAgICAvLyBJZiBzbywgYWRqdXN0IHRoZSBzcGFjaW5nIHNvIHRoZXJlIGlzIGFsd2F5cyBhIG1pbmltdW0gc3BhY2Ugb2YgYHNwYWNpbmcgLyA0YCBiZXR3ZWVuIGxhYmVsIGVkZ2VzLlxuICAgIGlmIChzcGFjaW5nIC0gbGFiZWxMZW5ndGggKiBib3hTY2FsZSAgPCBzcGFjaW5nIC8gNCkge1xuICAgICAgICBzcGFjaW5nID0gbGFiZWxMZW5ndGggKiBib3hTY2FsZSArIHNwYWNpbmcgLyA0O1xuICAgIH1cblxuICAgIC8vIE9mZnNldCB0aGUgZmlyc3QgYW5jaG9yIGJ5OlxuICAgIC8vIEVpdGhlciBoYWxmIHRoZSBsYWJlbCBsZW5ndGggcGx1cyBhIGZpeGVkIGV4dHJhIG9mZnNldCBpZiB0aGUgbGluZSBpcyBub3QgY29udGludWVkXG4gICAgLy8gT3IgaGFsZiB0aGUgc3BhY2luZyBpZiB0aGUgbGluZSBpcyBjb250aW51ZWQuXG5cbiAgICAvLyBGb3Igbm9uLWNvbnRpbnVlZCBsaW5lcywgYWRkIGEgYml0IG9mIGZpeGVkIGV4dHJhIG9mZnNldCB0byBhdm9pZCBjb2xsaXNpb25zIGF0IFQgaW50ZXJzZWN0aW9ucy5cbiAgICB2YXIgZml4ZWRFeHRyYU9mZnNldCA9IGdseXBoU2l6ZSAqIDI7XG5cbiAgICB2YXIgb2Zmc2V0ID0gIWlzTGluZUNvbnRpbnVlZCA/XG4gICAgICAgICgobGFiZWxMZW5ndGggLyAyICsgZml4ZWRFeHRyYU9mZnNldCkgKiBib3hTY2FsZSAqIG92ZXJzY2FsaW5nKSAlIHNwYWNpbmcgOlxuICAgICAgICAoc3BhY2luZyAvIDIgKiBvdmVyc2NhbGluZykgJSBzcGFjaW5nO1xuXG4gICAgcmV0dXJuIHJlc2FtcGxlKGxpbmUsIG9mZnNldCwgc3BhY2luZywgYW5nbGVXaW5kb3dTaXplLCBtYXhBbmdsZSwgbGFiZWxMZW5ndGggKiBib3hTY2FsZSwgaXNMaW5lQ29udGludWVkLCBmYWxzZSwgdGlsZUV4dGVudCk7XG59XG5cblxuZnVuY3Rpb24gcmVzYW1wbGUobGluZSwgb2Zmc2V0LCBzcGFjaW5nLCBhbmdsZVdpbmRvd1NpemUsIG1heEFuZ2xlLCBsYWJlbExlbmd0aCwgaXNMaW5lQ29udGludWVkLCBwbGFjZUF0TWlkZGxlLCB0aWxlRXh0ZW50KSB7XG5cbiAgICB2YXIgaGFsZkxhYmVsTGVuZ3RoID0gbGFiZWxMZW5ndGggLyAyO1xuICAgIHZhciBsaW5lTGVuZ3RoID0gMDtcbiAgICBmb3IgKHZhciBrID0gMDsgayA8IGxpbmUubGVuZ3RoIC0gMTsgaysrKSB7XG4gICAgICAgIGxpbmVMZW5ndGggKz0gbGluZVtrXS5kaXN0KGxpbmVbayArIDFdKTtcbiAgICB9XG5cbiAgICB2YXIgZGlzdGFuY2UgPSAwLFxuICAgICAgICBtYXJrZWREaXN0YW5jZSA9IG9mZnNldCAtIHNwYWNpbmc7XG5cbiAgICB2YXIgYW5jaG9ycyA9IFtdO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaW5lLmxlbmd0aCAtIDE7IGkrKykge1xuXG4gICAgICAgIHZhciBhID0gbGluZVtpXSxcbiAgICAgICAgICAgIGIgPSBsaW5lW2kgKyAxXTtcblxuICAgICAgICB2YXIgc2VnbWVudERpc3QgPSBhLmRpc3QoYiksXG4gICAgICAgICAgICBhbmdsZSA9IGIuYW5nbGVUbyhhKTtcblxuICAgICAgICB3aGlsZSAobWFya2VkRGlzdGFuY2UgKyBzcGFjaW5nIDwgZGlzdGFuY2UgKyBzZWdtZW50RGlzdCkge1xuICAgICAgICAgICAgbWFya2VkRGlzdGFuY2UgKz0gc3BhY2luZztcblxuICAgICAgICAgICAgdmFyIHQgPSAobWFya2VkRGlzdGFuY2UgLSBkaXN0YW5jZSkgLyBzZWdtZW50RGlzdCxcbiAgICAgICAgICAgICAgICB4ID0gaW50ZXJwb2xhdGUoYS54LCBiLngsIHQpLFxuICAgICAgICAgICAgICAgIHkgPSBpbnRlcnBvbGF0ZShhLnksIGIueSwgdCk7XG5cbiAgICAgICAgICAgIC8vIENoZWNrIHRoYXQgdGhlIHBvaW50IGlzIHdpdGhpbiB0aGUgdGlsZSBib3VuZGFyaWVzIGFuZCB0aGF0XG4gICAgICAgICAgICAvLyB0aGUgbGFiZWwgd291bGQgZml0IGJlZm9yZSB0aGUgYmVnaW5uaW5nIGFuZCBlbmQgb2YgdGhlIGxpbmVcbiAgICAgICAgICAgIC8vIGlmIHBsYWNlZCBhdCB0aGlzIHBvaW50LlxuICAgICAgICAgICAgaWYgKHggPj0gMCAmJiB4IDwgdGlsZUV4dGVudCAmJiB5ID49IDAgJiYgeSA8IHRpbGVFeHRlbnQgJiZcbiAgICAgICAgICAgICAgICAgICAgbWFya2VkRGlzdGFuY2UgLSBoYWxmTGFiZWxMZW5ndGggPj0gMCAmJlxuICAgICAgICAgICAgICAgICAgICBtYXJrZWREaXN0YW5jZSArIGhhbGZMYWJlbExlbmd0aCA8PSBsaW5lTGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGFuY2hvciA9IG5ldyBBbmNob3IoeCwgeSwgYW5nbGUsIGkpLl9yb3VuZCgpO1xuXG4gICAgICAgICAgICAgICAgaWYgKCFhbmdsZVdpbmRvd1NpemUgfHwgY2hlY2tNYXhBbmdsZShsaW5lLCBhbmNob3IsIGxhYmVsTGVuZ3RoLCBhbmdsZVdpbmRvd1NpemUsIG1heEFuZ2xlKSkge1xuICAgICAgICAgICAgICAgICAgICBhbmNob3JzLnB1c2goYW5jaG9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBkaXN0YW5jZSArPSBzZWdtZW50RGlzdDtcbiAgICB9XG5cbiAgICBpZiAoIXBsYWNlQXRNaWRkbGUgJiYgIWFuY2hvcnMubGVuZ3RoICYmICFpc0xpbmVDb250aW51ZWQpIHtcbiAgICAgICAgLy8gVGhlIGZpcnN0IGF0dGVtcHQgYXQgZmluZGluZyBhbmNob3JzIGF0IHdoaWNoIGxhYmVscyBjYW4gYmUgcGxhY2VkIGZhaWxlZC5cbiAgICAgICAgLy8gVHJ5IGFnYWluLCBidXQgdGhpcyB0aW1lIGp1c3QgdHJ5IHBsYWNpbmcgb25lIGFuY2hvciBhdCB0aGUgbWlkZGxlIG9mIHRoZSBsaW5lLlxuICAgICAgICAvLyBUaGlzIGhhcyB0aGUgbW9zdCBlZmZlY3QgZm9yIHNob3J0IGxpbmVzIGluIG92ZXJzY2FsZWQgdGlsZXMsIHNpbmNlIHRoZVxuICAgICAgICAvLyBpbml0aWFsIG9mZnNldCB1c2VkIGluIG92ZXJzY2FsZWQgdGlsZXMgaXMgY2FsY3VsYXRlZCB0byBhbGlnbiBsYWJlbHMgd2l0aCBwb3NpdGlvbnMgaW5cbiAgICAgICAgLy8gcGFyZW50IHRpbGVzIGluc3RlYWQgb2YgcGxhY2luZyB0aGUgbGFiZWwgYXMgY2xvc2UgdG8gdGhlIGJlZ2lubmluZyBhcyBwb3NzaWJsZS5cbiAgICAgICAgYW5jaG9ycyA9IHJlc2FtcGxlKGxpbmUsIGRpc3RhbmNlIC8gMiwgc3BhY2luZywgYW5nbGVXaW5kb3dTaXplLCBtYXhBbmdsZSwgbGFiZWxMZW5ndGgsIGlzTGluZUNvbnRpbnVlZCwgdHJ1ZSwgdGlsZUV4dGVudCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFuY2hvcnM7XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBTaGVsZlBhY2sgPSByZXF1aXJlKCdzaGVsZi1wYWNrJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gR2x5cGhBdGxhcztcbmZ1bmN0aW9uIEdseXBoQXRsYXMod2lkdGgsIGhlaWdodCkge1xuICAgIHRoaXMud2lkdGggPSB3aWR0aDtcbiAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcblxuICAgIHRoaXMuYmluID0gbmV3IFNoZWxmUGFjayh3aWR0aCwgaGVpZ2h0KTtcbiAgICB0aGlzLmluZGV4ID0ge307XG4gICAgdGhpcy5pZHMgPSB7fTtcbiAgICB0aGlzLmRhdGEgPSBuZXcgVWludDhBcnJheSh3aWR0aCAqIGhlaWdodCk7XG59XG5cbkdseXBoQXRsYXMucHJvdG90eXBlLmdldEdseXBocyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBnbHlwaHMgPSB7fSxcbiAgICAgICAgc3BsaXQsXG4gICAgICAgIG5hbWUsXG4gICAgICAgIGlkO1xuXG4gICAgZm9yICh2YXIga2V5IGluIHRoaXMuaWRzKSB7XG4gICAgICAgIHNwbGl0ID0ga2V5LnNwbGl0KCcjJyk7XG4gICAgICAgIG5hbWUgPSBzcGxpdFswXTtcbiAgICAgICAgaWQgPSBzcGxpdFsxXTtcblxuICAgICAgICBpZiAoIWdseXBoc1tuYW1lXSkgZ2x5cGhzW25hbWVdID0gW107XG4gICAgICAgIGdseXBoc1tuYW1lXS5wdXNoKGlkKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZ2x5cGhzO1xufTtcblxuR2x5cGhBdGxhcy5wcm90b3R5cGUuZ2V0UmVjdHMgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgcmVjdHMgPSB7fSxcbiAgICAgICAgc3BsaXQsXG4gICAgICAgIG5hbWUsXG4gICAgICAgIGlkO1xuXG4gICAgZm9yICh2YXIga2V5IGluIHRoaXMuaWRzKSB7XG4gICAgICAgIHNwbGl0ID0ga2V5LnNwbGl0KCcjJyk7XG4gICAgICAgIG5hbWUgPSBzcGxpdFswXTtcbiAgICAgICAgaWQgPSBzcGxpdFsxXTtcblxuICAgICAgICBpZiAoIXJlY3RzW25hbWVdKSByZWN0c1tuYW1lXSA9IHt9O1xuICAgICAgICByZWN0c1tuYW1lXVtpZF0gPSB0aGlzLmluZGV4W2tleV07XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlY3RzO1xufTtcblxuXG5HbHlwaEF0bGFzLnByb3RvdHlwZS5hZGRHbHlwaCA9IGZ1bmN0aW9uKGlkLCBuYW1lLCBnbHlwaCwgYnVmZmVyKSB7XG4gICAgaWYgKCFnbHlwaCkge1xuICAgICAgICAvLyBjb25zb2xlLndhcm4oJ21pc3NpbmcgZ2x5cGgnLCBjb2RlLCBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUpKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHZhciBrZXkgPSBuYW1lICsgXCIjXCIgKyBnbHlwaC5pZDtcblxuICAgIC8vIFRoZSBnbHlwaCBpcyBhbHJlYWR5IGluIHRoaXMgdGV4dHVyZS5cbiAgICBpZiAodGhpcy5pbmRleFtrZXldKSB7XG4gICAgICAgIGlmICh0aGlzLmlkc1trZXldLmluZGV4T2YoaWQpIDwgMCkge1xuICAgICAgICAgICAgdGhpcy5pZHNba2V5XS5wdXNoKGlkKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5pbmRleFtrZXldO1xuICAgIH1cblxuICAgIC8vIFRoZSBnbHlwaCBiaXRtYXAgaGFzIHplcm8gd2lkdGguXG4gICAgaWYgKCFnbHlwaC5iaXRtYXApIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgdmFyIGJ1ZmZlcmVkV2lkdGggPSBnbHlwaC53aWR0aCArIGJ1ZmZlciAqIDI7XG4gICAgdmFyIGJ1ZmZlcmVkSGVpZ2h0ID0gZ2x5cGguaGVpZ2h0ICsgYnVmZmVyICogMjtcblxuICAgIC8vIEFkZCBhIDFweCBib3JkZXIgYXJvdW5kIGV2ZXJ5IGltYWdlLlxuICAgIHZhciBwYWRkaW5nID0gMTtcbiAgICB2YXIgcGFja1dpZHRoID0gYnVmZmVyZWRXaWR0aCArIDIgKiBwYWRkaW5nO1xuICAgIHZhciBwYWNrSGVpZ2h0ID0gYnVmZmVyZWRIZWlnaHQgKyAyICogcGFkZGluZztcblxuICAgIC8vIEluY3JlYXNlIHRvIG5leHQgbnVtYmVyIGRpdmlzaWJsZSBieSA0LCBidXQgYXQgbGVhc3QgMS5cbiAgICAvLyBUaGlzIGlzIHNvIHdlIGNhbiBzY2FsZSBkb3duIHRoZSB0ZXh0dXJlIGNvb3JkaW5hdGVzIGFuZCBwYWNrIHRoZW1cbiAgICAvLyBpbnRvIDIgYnl0ZXMgcmF0aGVyIHRoYW4gNCBieXRlcy5cbiAgICBwYWNrV2lkdGggKz0gKDQgLSBwYWNrV2lkdGggJSA0KTtcbiAgICBwYWNrSGVpZ2h0ICs9ICg0IC0gcGFja0hlaWdodCAlIDQpO1xuXG4gICAgdmFyIHJlY3QgPSB0aGlzLmJpbi5hbGxvY2F0ZShwYWNrV2lkdGgsIHBhY2tIZWlnaHQpO1xuICAgIGlmIChyZWN0LnggPCAwKSB7XG4gICAgICAgIHRoaXMucmVzaXplKCk7XG4gICAgICAgIHJlY3QgPSB0aGlzLmJpbi5hbGxvY2F0ZShwYWNrV2lkdGgsIHBhY2tIZWlnaHQpO1xuICAgIH1cbiAgICBpZiAocmVjdC54IDwgMCkge1xuICAgICAgICBjb25zb2xlLndhcm4oJ2dseXBoIGJpdG1hcCBvdmVyZmxvdycpO1xuICAgICAgICByZXR1cm4geyBnbHlwaDogZ2x5cGgsIHJlY3Q6IG51bGwgfTtcbiAgICB9XG5cbiAgICB0aGlzLmluZGV4W2tleV0gPSByZWN0O1xuICAgIHRoaXMuaWRzW2tleV0gPSBbaWRdO1xuXG4gICAgdmFyIHRhcmdldCA9IHRoaXMuZGF0YTtcbiAgICB2YXIgc291cmNlID0gZ2x5cGguYml0bWFwO1xuICAgIGZvciAodmFyIHkgPSAwOyB5IDwgYnVmZmVyZWRIZWlnaHQ7IHkrKykge1xuICAgICAgICB2YXIgeTEgPSB0aGlzLndpZHRoICogKHJlY3QueSArIHkgKyBwYWRkaW5nKSArIHJlY3QueCArIHBhZGRpbmc7XG4gICAgICAgIHZhciB5MiA9IGJ1ZmZlcmVkV2lkdGggKiB5O1xuICAgICAgICBmb3IgKHZhciB4ID0gMDsgeCA8IGJ1ZmZlcmVkV2lkdGg7IHgrKykge1xuICAgICAgICAgICAgdGFyZ2V0W3kxICsgeF0gPSBzb3VyY2VbeTIgKyB4XTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuZGlydHkgPSB0cnVlO1xuXG4gICAgcmV0dXJuIHJlY3Q7XG59O1xuXG5HbHlwaEF0bGFzLnByb3RvdHlwZS5yZXNpemUgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgb3JpZ3cgPSB0aGlzLndpZHRoLFxuICAgICAgICBvcmlnaCA9IHRoaXMuaGVpZ2h0O1xuXG4gICAgLy8gRm9yIG5vdywgZG9uJ3QgZ3JvdyB0aGUgYXRsYXMgYmV5b25kIDEwMjR4MTAyNCBiZWNhdXNlIG9mIGhvd1xuICAgIC8vIHRleHR1cmUgY29vcmRzIHBhY2sgaW50byB1bnNpZ25lZCBieXRlIGluIHN5bWJvbCBidWNrZXQuXG4gICAgaWYgKG9yaWd3ID4gNTEyIHx8IG9yaWdoID4gNTEyKSByZXR1cm47XG5cbiAgICBpZiAodGhpcy50ZXh0dXJlKSB7XG4gICAgICAgIGlmICh0aGlzLmdsKSB7XG4gICAgICAgICAgICB0aGlzLmdsLmRlbGV0ZVRleHR1cmUodGhpcy50ZXh0dXJlKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRleHR1cmUgPSBudWxsO1xuICAgIH1cblxuICAgIHRoaXMud2lkdGggKj0gMjtcbiAgICB0aGlzLmhlaWdodCAqPSAyO1xuICAgIHRoaXMuYmluLnJlc2l6ZSh0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XG5cbiAgICB2YXIgYnVmID0gbmV3IEFycmF5QnVmZmVyKHRoaXMud2lkdGggKiB0aGlzLmhlaWdodCksXG4gICAgICAgIHNyYywgZHN0O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb3JpZ2g7IGkrKykge1xuICAgICAgICBzcmMgPSBuZXcgVWludDhBcnJheSh0aGlzLmRhdGEuYnVmZmVyLCBvcmlnaCAqIGksIG9yaWd3KTtcbiAgICAgICAgZHN0ID0gbmV3IFVpbnQ4QXJyYXkoYnVmLCBvcmlnaCAqIGkgKiAyLCBvcmlndyk7XG4gICAgICAgIGRzdC5zZXQoc3JjKTtcbiAgICB9XG4gICAgdGhpcy5kYXRhID0gbmV3IFVpbnQ4QXJyYXkoYnVmKTtcbn07XG5cbkdseXBoQXRsYXMucHJvdG90eXBlLmJpbmQgPSBmdW5jdGlvbihnbCkge1xuICAgIHRoaXMuZ2wgPSBnbDtcbiAgICBpZiAoIXRoaXMudGV4dHVyZSkge1xuICAgICAgICB0aGlzLnRleHR1cmUgPSBnbC5jcmVhdGVUZXh0dXJlKCk7XG4gICAgICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRoaXMudGV4dHVyZSk7XG4gICAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NQUdfRklMVEVSLCBnbC5MSU5FQVIpO1xuICAgICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUlOX0ZJTFRFUiwgZ2wuTElORUFSKTtcbiAgICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfUywgZ2wuQ0xBTVBfVE9fRURHRSk7XG4gICAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1QsIGdsLkNMQU1QX1RPX0VER0UpO1xuICAgICAgICBnbC50ZXhJbWFnZTJEKGdsLlRFWFRVUkVfMkQsIDAsIGdsLkFMUEhBLCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCwgMCwgZ2wuQUxQSEEsIGdsLlVOU0lHTkVEX0JZVEUsIG51bGwpO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGhpcy50ZXh0dXJlKTtcbiAgICB9XG59O1xuXG5HbHlwaEF0bGFzLnByb3RvdHlwZS51cGRhdGVUZXh0dXJlID0gZnVuY3Rpb24oZ2wpIHtcbiAgICB0aGlzLmJpbmQoZ2wpO1xuICAgIGlmICh0aGlzLmRpcnR5KSB7XG4gICAgICAgIGdsLnRleFN1YkltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgMCwgMCwgMCwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQsIGdsLkFMUEhBLCBnbC5VTlNJR05FRF9CWVRFLCB0aGlzLmRhdGEpO1xuICAgICAgICB0aGlzLmRpcnR5ID0gZmFsc2U7XG4gICAgfVxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIG5vcm1hbGl6ZVVSTCA9IHJlcXVpcmUoJy4uL3V0aWwvbWFwYm94Jykubm9ybWFsaXplR2x5cGhzVVJMO1xudmFyIGdldEFycmF5QnVmZmVyID0gcmVxdWlyZSgnLi4vdXRpbC9hamF4JykuZ2V0QXJyYXlCdWZmZXI7XG52YXIgR2x5cGhzID0gcmVxdWlyZSgnLi4vdXRpbC9nbHlwaHMnKTtcbnZhciBHbHlwaEF0bGFzID0gcmVxdWlyZSgnLi4vc3ltYm9sL2dseXBoX2F0bGFzJyk7XG52YXIgUHJvdG9idWYgPSByZXF1aXJlKCdwYmYnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBHbHlwaFNvdXJjZTtcblxuLyoqXG4gKiBBIGdseXBoIHNvdXJjZSBoYXMgYSBVUkwgZnJvbSB3aGljaCB0byBsb2FkIG5ldyBnbHlwaHMgYW5kIG1hbmFnZXNcbiAqIEdseXBoQXRsYXNlcyBpbiB3aGljaCB0byBzdG9yZSBnbHlwaHMgdXNlZCBieSB0aGUgcmVxdWVzdGVkIGZvbnRzdGFja3NcbiAqIGFuZCByYW5nZXMuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHVybCBnbHlwaCB0ZW1wbGF0ZSB1cmxcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIEdseXBoU291cmNlKHVybCkge1xuICAgIHRoaXMudXJsID0gdXJsICYmIG5vcm1hbGl6ZVVSTCh1cmwpO1xuICAgIHRoaXMuYXRsYXNlcyA9IHt9O1xuICAgIHRoaXMuc3RhY2tzID0ge307XG4gICAgdGhpcy5sb2FkaW5nID0ge307XG59XG5cbkdseXBoU291cmNlLnByb3RvdHlwZS5nZXRTaW1wbGVHbHlwaHMgPSBmdW5jdGlvbihmb250c3RhY2ssIGdseXBoSURzLCB1aWQsIGNhbGxiYWNrKSB7XG4gICAgaWYgKHRoaXMuc3RhY2tzW2ZvbnRzdGFja10gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLnN0YWNrc1tmb250c3RhY2tdID0ge307XG4gICAgfVxuICAgIGlmICh0aGlzLmF0bGFzZXNbZm9udHN0YWNrXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMuYXRsYXNlc1tmb250c3RhY2tdID0gbmV3IEdseXBoQXRsYXMoMTI4LCAxMjgpO1xuICAgIH1cblxuICAgIHZhciBnbHlwaHMgPSB7fTtcbiAgICB2YXIgc3RhY2sgPSB0aGlzLnN0YWNrc1tmb250c3RhY2tdO1xuICAgIHZhciBhdGxhcyA9IHRoaXMuYXRsYXNlc1tmb250c3RhY2tdO1xuXG4gICAgLy8gdGhlIG51bWJlciBvZiBwaXhlbHMgdGhlIHNkZiBiaXRtYXBzIGFyZSBwYWRkZWQgYnlcbiAgICB2YXIgYnVmZmVyID0gMztcblxuICAgIHZhciBtaXNzaW5nID0ge307XG4gICAgdmFyIHJlbWFpbmluZyA9IDA7XG4gICAgdmFyIHJhbmdlO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBnbHlwaElEcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZ2x5cGhJRCA9IGdseXBoSURzW2ldO1xuICAgICAgICByYW5nZSA9IE1hdGguZmxvb3IoZ2x5cGhJRCAvIDI1Nik7XG5cbiAgICAgICAgaWYgKHN0YWNrW3JhbmdlXSkge1xuICAgICAgICAgICAgdmFyIGdseXBoID0gc3RhY2tbcmFuZ2VdLmdseXBoc1tnbHlwaElEXTtcbiAgICAgICAgICAgIHZhciByZWN0ICA9IGF0bGFzLmFkZEdseXBoKHVpZCwgZm9udHN0YWNrLCBnbHlwaCwgYnVmZmVyKTtcbiAgICAgICAgICAgIGlmIChnbHlwaCkgZ2x5cGhzW2dseXBoSURdID0gbmV3IFNpbXBsZUdseXBoKGdseXBoLCByZWN0LCBidWZmZXIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKG1pc3NpbmdbcmFuZ2VdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBtaXNzaW5nW3JhbmdlXSA9IFtdO1xuICAgICAgICAgICAgICAgIHJlbWFpbmluZysrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbWlzc2luZ1tyYW5nZV0ucHVzaChnbHlwaElEKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmICghcmVtYWluaW5nKSBjYWxsYmFjayh1bmRlZmluZWQsIGdseXBocywgZm9udHN0YWNrKTtcblxuICAgIHZhciBvblJhbmdlTG9hZGVkID0gZnVuY3Rpb24oZXJyLCByYW5nZSwgZGF0YSkge1xuICAgICAgICAvLyBUT0RPIG5vdCBiZSBzaWxlbnQgYWJvdXQgZXJyb3JzXG4gICAgICAgIGlmICghZXJyKSB7XG4gICAgICAgICAgICB2YXIgc3RhY2sgPSB0aGlzLnN0YWNrc1tmb250c3RhY2tdW3JhbmdlXSA9IGRhdGEuc3RhY2tzWzBdO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtaXNzaW5nW3JhbmdlXS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBnbHlwaElEID0gbWlzc2luZ1tyYW5nZV1baV07XG4gICAgICAgICAgICAgICAgdmFyIGdseXBoID0gc3RhY2suZ2x5cGhzW2dseXBoSURdO1xuICAgICAgICAgICAgICAgIHZhciByZWN0ICA9IGF0bGFzLmFkZEdseXBoKHVpZCwgZm9udHN0YWNrLCBnbHlwaCwgYnVmZmVyKTtcbiAgICAgICAgICAgICAgICBpZiAoZ2x5cGgpIGdseXBoc1tnbHlwaElEXSA9IG5ldyBTaW1wbGVHbHlwaChnbHlwaCwgcmVjdCwgYnVmZmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZW1haW5pbmctLTtcbiAgICAgICAgaWYgKCFyZW1haW5pbmcpIGNhbGxiYWNrKHVuZGVmaW5lZCwgZ2x5cGhzLCBmb250c3RhY2spO1xuICAgIH0uYmluZCh0aGlzKTtcblxuICAgIGZvciAodmFyIHIgaW4gbWlzc2luZykge1xuICAgICAgICB0aGlzLmxvYWRSYW5nZShmb250c3RhY2ssIHIsIG9uUmFuZ2VMb2FkZWQpO1xuICAgIH1cbn07XG5cbi8vIEEgc2ltcGxpZmllZCByZXByZXNlbnRhdGlvbiBvZiB0aGUgZ2x5cGggY29udGFpbmluZyBvbmx5IHRoZSBwcm9wZXJ0aWVzIG5lZWRlZCBmb3Igc2hhcGluZy5cbmZ1bmN0aW9uIFNpbXBsZUdseXBoKGdseXBoLCByZWN0LCBidWZmZXIpIHtcbiAgICB2YXIgcGFkZGluZyA9IDE7XG4gICAgdGhpcy5hZHZhbmNlID0gZ2x5cGguYWR2YW5jZTtcbiAgICB0aGlzLmxlZnQgPSBnbHlwaC5sZWZ0IC0gYnVmZmVyIC0gcGFkZGluZztcbiAgICB0aGlzLnRvcCA9IGdseXBoLnRvcCArIGJ1ZmZlciArIHBhZGRpbmc7XG4gICAgdGhpcy5yZWN0ID0gcmVjdDtcbn1cblxuR2x5cGhTb3VyY2UucHJvdG90eXBlLmxvYWRSYW5nZSA9IGZ1bmN0aW9uKGZvbnRzdGFjaywgcmFuZ2UsIGNhbGxiYWNrKSB7XG4gICAgaWYgKHJhbmdlICogMjU2ID4gNjU1MzUpIHJldHVybiBjYWxsYmFjaygnZ2x5cGhzID4gNjU1MzUgbm90IHN1cHBvcnRlZCcpO1xuXG4gICAgaWYgKHRoaXMubG9hZGluZ1tmb250c3RhY2tdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5sb2FkaW5nW2ZvbnRzdGFja10gPSB7fTtcbiAgICB9XG4gICAgdmFyIGxvYWRpbmcgPSB0aGlzLmxvYWRpbmdbZm9udHN0YWNrXTtcblxuICAgIGlmIChsb2FkaW5nW3JhbmdlXSkge1xuICAgICAgICBsb2FkaW5nW3JhbmdlXS5wdXNoKGNhbGxiYWNrKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBsb2FkaW5nW3JhbmdlXSA9IFtjYWxsYmFja107XG5cbiAgICAgICAgdmFyIHJhbmdlTmFtZSA9IChyYW5nZSAqIDI1NikgKyAnLScgKyAocmFuZ2UgKiAyNTYgKyAyNTUpO1xuICAgICAgICB2YXIgdXJsID0gZ2x5cGhVcmwoZm9udHN0YWNrLCByYW5nZU5hbWUsIHRoaXMudXJsKTtcblxuICAgICAgICBnZXRBcnJheUJ1ZmZlcih1cmwsIGZ1bmN0aW9uKGVyciwgZGF0YSkge1xuICAgICAgICAgICAgdmFyIGdseXBocyA9ICFlcnIgJiYgbmV3IEdseXBocyhuZXcgUHJvdG9idWYobmV3IFVpbnQ4QXJyYXkoZGF0YSkpKTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbG9hZGluZ1tyYW5nZV0ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBsb2FkaW5nW3JhbmdlXVtpXShlcnIsIHJhbmdlLCBnbHlwaHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVsZXRlIGxvYWRpbmdbcmFuZ2VdO1xuICAgICAgICB9KTtcbiAgICB9XG59O1xuXG5HbHlwaFNvdXJjZS5wcm90b3R5cGUuZ2V0R2x5cGhBdGxhcyA9IGZ1bmN0aW9uKGZvbnRzdGFjaykge1xuICAgIHJldHVybiB0aGlzLmF0bGFzZXNbZm9udHN0YWNrXTtcbn07XG5cbi8qKlxuICogVXNlIENOQU1FIHNoYXJkaW5nIHRvIGxvYWQgYSBzcGVjaWZpYyBnbHlwaCByYW5nZSBvdmVyIGEgcmFuZG9taXplZFxuICogYnV0IGNvbnNpc3RlbnQgc3ViZG9tYWluLlxuICogQHBhcmFtIHtzdHJpbmd9IGZvbnRzdGFjayBjb21tYS1qb2luZWQgZm9udHNcbiAqIEBwYXJhbSB7c3RyaW5nfSByYW5nZSBjb21tYS1qb2luZWQgcmFuZ2VcbiAqIEBwYXJhbSB7dXJsfSB1cmwgdGVtcGxhdGVkIHVybFxuICogQHBhcmFtIHtzdHJpbmd9IFtzdWJkb21haW5zPWFiY10gc3ViZG9tYWlucyBhcyBhIHN0cmluZyB3aGVyZSBlYWNoIGxldHRlciBpcyBvbmUuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBhIHVybCB0byBsb2FkIHRoYXQgc2VjdGlvbiBvZiBnbHlwaHNcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGdseXBoVXJsKGZvbnRzdGFjaywgcmFuZ2UsIHVybCwgc3ViZG9tYWlucykge1xuICAgIHN1YmRvbWFpbnMgPSBzdWJkb21haW5zIHx8ICdhYmMnO1xuXG4gICAgcmV0dXJuIHVybFxuICAgICAgICAucmVwbGFjZSgne3N9Jywgc3ViZG9tYWluc1tmb250c3RhY2subGVuZ3RoICUgc3ViZG9tYWlucy5sZW5ndGhdKVxuICAgICAgICAucmVwbGFjZSgne2ZvbnRzdGFja30nLCBmb250c3RhY2spXG4gICAgICAgIC5yZXBsYWNlKCd7cmFuZ2V9JywgcmFuZ2UpO1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChmZWF0dXJlcywgdGV4dEZlYXR1cmVzLCBnZW9tZXRyaWVzKSB7XG5cbiAgICB2YXIgbGVmdEluZGV4ID0ge30sXG4gICAgICAgIHJpZ2h0SW5kZXggPSB7fSxcbiAgICAgICAgbWVyZ2VkRmVhdHVyZXMgPSBbXSxcbiAgICAgICAgbWVyZ2VkR2VvbSA9IFtdLFxuICAgICAgICBtZXJnZWRUZXh0cyA9IFtdLFxuICAgICAgICBtZXJnZWRJbmRleCA9IDAsXG4gICAgICAgIGs7XG5cbiAgICBmdW5jdGlvbiBhZGQoaykge1xuICAgICAgICBtZXJnZWRGZWF0dXJlcy5wdXNoKGZlYXR1cmVzW2tdKTtcbiAgICAgICAgbWVyZ2VkR2VvbS5wdXNoKGdlb21ldHJpZXNba10pO1xuICAgICAgICBtZXJnZWRUZXh0cy5wdXNoKHRleHRGZWF0dXJlc1trXSk7XG4gICAgICAgIG1lcmdlZEluZGV4Kys7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbWVyZ2VGcm9tUmlnaHQobGVmdEtleSwgcmlnaHRLZXksIGdlb20pIHtcbiAgICAgICAgdmFyIGkgPSByaWdodEluZGV4W2xlZnRLZXldO1xuICAgICAgICBkZWxldGUgcmlnaHRJbmRleFtsZWZ0S2V5XTtcbiAgICAgICAgcmlnaHRJbmRleFtyaWdodEtleV0gPSBpO1xuXG4gICAgICAgIG1lcmdlZEdlb21baV1bMF0ucG9wKCk7XG4gICAgICAgIG1lcmdlZEdlb21baV1bMF0gPSBtZXJnZWRHZW9tW2ldWzBdLmNvbmNhdChnZW9tWzBdKTtcbiAgICAgICAgcmV0dXJuIGk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbWVyZ2VGcm9tTGVmdChsZWZ0S2V5LCByaWdodEtleSwgZ2VvbSkge1xuICAgICAgICB2YXIgaSA9IGxlZnRJbmRleFtyaWdodEtleV07XG4gICAgICAgIGRlbGV0ZSBsZWZ0SW5kZXhbcmlnaHRLZXldO1xuICAgICAgICBsZWZ0SW5kZXhbbGVmdEtleV0gPSBpO1xuXG4gICAgICAgIG1lcmdlZEdlb21baV1bMF0uc2hpZnQoKTtcbiAgICAgICAgbWVyZ2VkR2VvbVtpXVswXSA9IGdlb21bMF0uY29uY2F0KG1lcmdlZEdlb21baV1bMF0pO1xuICAgICAgICByZXR1cm4gaTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRLZXkodGV4dCwgZ2VvbSwgb25SaWdodCkge1xuICAgICAgICB2YXIgcG9pbnQgPSBvblJpZ2h0ID8gZ2VvbVswXVtnZW9tWzBdLmxlbmd0aCAtIDFdIDogZ2VvbVswXVswXTtcbiAgICAgICAgcmV0dXJuIHRleHQgKyAnOicgKyBwb2ludC54ICsgJzonICsgcG9pbnQueTtcbiAgICB9XG5cbiAgICBmb3IgKGsgPSAwOyBrIDwgZmVhdHVyZXMubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgdmFyIGdlb20gPSBnZW9tZXRyaWVzW2tdLFxuICAgICAgICAgICAgdGV4dCA9IHRleHRGZWF0dXJlc1trXTtcblxuICAgICAgICBpZiAoIXRleHQpIHtcbiAgICAgICAgICAgIGFkZChrKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGxlZnRLZXkgPSBnZXRLZXkodGV4dCwgZ2VvbSksXG4gICAgICAgICAgICByaWdodEtleSA9IGdldEtleSh0ZXh0LCBnZW9tLCB0cnVlKTtcblxuICAgICAgICBpZiAoKGxlZnRLZXkgaW4gcmlnaHRJbmRleCkgJiYgKHJpZ2h0S2V5IGluIGxlZnRJbmRleCkgJiYgKHJpZ2h0SW5kZXhbbGVmdEtleV0gIT09IGxlZnRJbmRleFtyaWdodEtleV0pKSB7XG4gICAgICAgICAgICAvLyBmb3VuZCBsaW5lcyB3aXRoIHRoZSBzYW1lIHRleHQgYWRqYWNlbnQgdG8gYm90aCBlbmRzIG9mIHRoZSBjdXJyZW50IGxpbmUsIG1lcmdlIGFsbCB0aHJlZVxuICAgICAgICAgICAgdmFyIGogPSBtZXJnZUZyb21MZWZ0KGxlZnRLZXksIHJpZ2h0S2V5LCBnZW9tKTtcbiAgICAgICAgICAgIHZhciBpID0gbWVyZ2VGcm9tUmlnaHQobGVmdEtleSwgcmlnaHRLZXksIG1lcmdlZEdlb21bal0pO1xuXG4gICAgICAgICAgICBkZWxldGUgbGVmdEluZGV4W2xlZnRLZXldO1xuICAgICAgICAgICAgZGVsZXRlIHJpZ2h0SW5kZXhbcmlnaHRLZXldO1xuXG4gICAgICAgICAgICByaWdodEluZGV4W2dldEtleSh0ZXh0LCBtZXJnZWRHZW9tW2ldLCB0cnVlKV0gPSBpO1xuICAgICAgICAgICAgbWVyZ2VkR2VvbVtqXSA9IG51bGw7XG5cbiAgICAgICAgfSBlbHNlIGlmIChsZWZ0S2V5IGluIHJpZ2h0SW5kZXgpIHtcbiAgICAgICAgICAgIC8vIGZvdW5kIG1lcmdlYWJsZSBsaW5lIGFkamFjZW50IHRvIHRoZSBzdGFydCBvZiB0aGUgY3VycmVudCBsaW5lLCBtZXJnZVxuICAgICAgICAgICAgbWVyZ2VGcm9tUmlnaHQobGVmdEtleSwgcmlnaHRLZXksIGdlb20pO1xuXG4gICAgICAgIH0gZWxzZSBpZiAocmlnaHRLZXkgaW4gbGVmdEluZGV4KSB7XG4gICAgICAgICAgICAvLyBmb3VuZCBtZXJnZWFibGUgbGluZSBhZGphY2VudCB0byB0aGUgZW5kIG9mIHRoZSBjdXJyZW50IGxpbmUsIG1lcmdlXG4gICAgICAgICAgICBtZXJnZUZyb21MZWZ0KGxlZnRLZXksIHJpZ2h0S2V5LCBnZW9tKTtcblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gbm8gYWRqYWNlbnQgbGluZXMsIGFkZCBhcyBhIG5ldyBpdGVtXG4gICAgICAgICAgICBhZGQoayk7XG4gICAgICAgICAgICBsZWZ0SW5kZXhbbGVmdEtleV0gPSBtZXJnZWRJbmRleCAtIDE7XG4gICAgICAgICAgICByaWdodEluZGV4W3JpZ2h0S2V5XSA9IG1lcmdlZEluZGV4IC0gMTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICAgIGZlYXR1cmVzOiBtZXJnZWRGZWF0dXJlcyxcbiAgICAgICAgdGV4dEZlYXR1cmVzOiBtZXJnZWRUZXh0cyxcbiAgICAgICAgZ2VvbWV0cmllczogbWVyZ2VkR2VvbVxuICAgIH07XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgUG9pbnQgPSByZXF1aXJlKCdwb2ludC1nZW9tZXRyeScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBnZXRJY29uUXVhZHM6IGdldEljb25RdWFkcyxcbiAgICBnZXRHbHlwaFF1YWRzOiBnZXRHbHlwaFF1YWRzXG59O1xuXG52YXIgbWluU2NhbGUgPSAwLjU7IC8vIHVuZGVyc2NhbGUgYnkgMSB6b29tIGxldmVsXG5cbi8qKlxuICogQSB0ZXh0dXJlZCBxdWFkIGZvciByZW5kZXJpbmcgYSBzaW5nbGUgaWNvbiBvciBnbHlwaC5cbiAqXG4gKiBUaGUgem9vbSByYW5nZSB0aGUgZ2x5cGggY2FuIGJlIHNob3duIGlzIGRlZmluZWQgYnkgbWluU2NhbGUgYW5kIG1heFNjYWxlLlxuICpcbiAqIEBwYXJhbSB7UG9pbnR9IGFuY2hvclBvaW50IHRoZSBwb2ludCB0aGUgc3ltYm9sIGlzIGFuY2hvcmVkIGFyb3VuZFxuICogQHBhcmFtIHtQb2ludH0gdGwgVGhlIG9mZnNldCBvZiB0aGUgdG9wIGxlZnQgY29ybmVyIGZyb20gdGhlIGFuY2hvci5cbiAqIEBwYXJhbSB7UG9pbnR9IHRyIFRoZSBvZmZzZXQgb2YgdGhlIHRvcCByaWdodCBjb3JuZXIgZnJvbSB0aGUgYW5jaG9yLlxuICogQHBhcmFtIHtQb2ludH0gYmwgVGhlIG9mZnNldCBvZiB0aGUgYm90dG9tIGxlZnQgY29ybmVyIGZyb20gdGhlIGFuY2hvci5cbiAqIEBwYXJhbSB7UG9pbnR9IGJyIFRoZSBvZmZzZXQgb2YgdGhlIGJvdHRvbSByaWdodCBjb3JuZXIgZnJvbSB0aGUgYW5jaG9yLlxuICogQHBhcmFtIHtPYmplY3R9IHRleCBUaGUgdGV4dHVyZSBjb29yZGluYXRlcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBhbmdsZSBUaGUgYW5nbGUgb2YgdGhlIGxhYmVsIGF0IGl0J3MgY2VudGVyLCBub3QgdGhlIGFuZ2xlIG9mIHRoaXMgcXVhZC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBtaW5TY2FsZSBUaGUgbWluaW11bSBzY2FsZSwgcmVsYXRpdmUgdG8gdGhlIHRpbGUncyBpbnRlbmRlZCBzY2FsZSwgdGhhdCB0aGUgZ2x5cGggY2FuIGJlIHNob3duIGF0LlxuICogQHBhcmFtIHtudW1iZXJ9IG1heFNjYWxlIFRoZSBtYXhpbXVtIHNjYWxlLCByZWxhdGl2ZSB0byB0aGUgdGlsZSdzIGludGVuZGVkIHNjYWxlLCB0aGF0IHRoZSBnbHlwaCBjYW4gYmUgc2hvd24gYXQuXG4gKlxuICogQGNsYXNzIFN5bWJvbFF1YWRcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIFN5bWJvbFF1YWQoYW5jaG9yUG9pbnQsIHRsLCB0ciwgYmwsIGJyLCB0ZXgsIGFuZ2xlLCBtaW5TY2FsZSwgbWF4U2NhbGUpIHtcbiAgICB0aGlzLmFuY2hvclBvaW50ID0gYW5jaG9yUG9pbnQ7XG4gICAgdGhpcy50bCA9IHRsO1xuICAgIHRoaXMudHIgPSB0cjtcbiAgICB0aGlzLmJsID0gYmw7XG4gICAgdGhpcy5iciA9IGJyO1xuICAgIHRoaXMudGV4ID0gdGV4O1xuICAgIHRoaXMuYW5nbGUgPSBhbmdsZTtcbiAgICB0aGlzLm1pblNjYWxlID0gbWluU2NhbGU7XG4gICAgdGhpcy5tYXhTY2FsZSA9IG1heFNjYWxlO1xufVxuXG4vKipcbiAqIENyZWF0ZSB0aGUgcXVhZHMgdXNlZCBmb3IgcmVuZGVyaW5nIGFuIGljb24uXG4gKlxuICogQHBhcmFtIHtBbmNob3J9IGFuY2hvclxuICogQHBhcmFtIHtQb3NpdGlvbmVkSWNvbn0gc2hhcGVkSWNvblxuICogQHBhcmFtIHtudW1iZXJ9IGJveFNjYWxlIEEgbWFnaWMgbnVtYmVyIGZvciBjb252ZXJ0aW5nIGdseXBoIG1ldHJpYyB1bml0cyB0byBnZW9tZXRyeSB1bml0cy5cbiAqIEBwYXJhbSB7QXJyYXk8QXJyYXk8UG9pbnQ+Pn0gbGluZVxuICogQHBhcmFtIHtMYXlvdXRQcm9wZXJ0aWVzfSBsYXlvdXRcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gYWxvbmdMaW5lIFdoZXRoZXIgdGhlIGljb24gc2hvdWxkIGJlIHBsYWNlZCBhbG9uZyB0aGUgbGluZS5cbiAqIEByZXR1cm5zIHtBcnJheTxTeW1ib2xRdWFkPn1cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGdldEljb25RdWFkcyhhbmNob3IsIHNoYXBlZEljb24sIGJveFNjYWxlLCBsaW5lLCBsYXlvdXQsIGFsb25nTGluZSkge1xuXG4gICAgdmFyIHJlY3QgPSBzaGFwZWRJY29uLmltYWdlLnJlY3Q7XG5cbiAgICB2YXIgYm9yZGVyID0gMTtcbiAgICB2YXIgbGVmdCA9IHNoYXBlZEljb24ubGVmdCAtIGJvcmRlcjtcbiAgICB2YXIgcmlnaHQgPSBsZWZ0ICsgcmVjdC53IC8gc2hhcGVkSWNvbi5pbWFnZS5waXhlbFJhdGlvO1xuICAgIHZhciB0b3AgPSBzaGFwZWRJY29uLnRvcCAtIGJvcmRlcjtcbiAgICB2YXIgYm90dG9tID0gdG9wICsgcmVjdC5oIC8gc2hhcGVkSWNvbi5pbWFnZS5waXhlbFJhdGlvO1xuICAgIHZhciB0bCA9IG5ldyBQb2ludChsZWZ0LCB0b3ApO1xuICAgIHZhciB0ciA9IG5ldyBQb2ludChyaWdodCwgdG9wKTtcbiAgICB2YXIgYnIgPSBuZXcgUG9pbnQocmlnaHQsIGJvdHRvbSk7XG4gICAgdmFyIGJsID0gbmV3IFBvaW50KGxlZnQsIGJvdHRvbSk7XG5cbiAgICB2YXIgYW5nbGUgPSBsYXlvdXRbJ2ljb24tcm90YXRlJ10gKiBNYXRoLlBJIC8gMTgwO1xuICAgIGlmIChhbG9uZ0xpbmUpIHtcbiAgICAgICAgdmFyIHByZXYgPSBsaW5lW2FuY2hvci5zZWdtZW50XTtcbiAgICAgICAgaWYgKGFuY2hvci55ID09PSBwcmV2LnkgJiYgYW5jaG9yLnggPT09IHByZXYueCAmJiBhbmNob3Iuc2VnbWVudCArIDEgPCBsaW5lLmxlbmd0aCkge1xuICAgICAgICAgICAgdmFyIG5leHQgPSBsaW5lW2FuY2hvci5zZWdtZW50ICsgMV07XG4gICAgICAgICAgICBhbmdsZSArPSBNYXRoLmF0YW4yKGFuY2hvci55IC0gbmV4dC55LCBhbmNob3IueCAtIG5leHQueCkgKyBNYXRoLlBJO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYW5nbGUgKz0gTWF0aC5hdGFuMihhbmNob3IueSAtIHByZXYueSwgYW5jaG9yLnggLSBwcmV2LngpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGFuZ2xlKSB7XG4gICAgICAgIHZhciBzaW4gPSBNYXRoLnNpbihhbmdsZSksXG4gICAgICAgICAgICBjb3MgPSBNYXRoLmNvcyhhbmdsZSksXG4gICAgICAgICAgICBtYXRyaXggPSBbY29zLCAtc2luLCBzaW4sIGNvc107XG5cbiAgICAgICAgdGwgPSB0bC5tYXRNdWx0KG1hdHJpeCk7XG4gICAgICAgIHRyID0gdHIubWF0TXVsdChtYXRyaXgpO1xuICAgICAgICBibCA9IGJsLm1hdE11bHQobWF0cml4KTtcbiAgICAgICAgYnIgPSBici5tYXRNdWx0KG1hdHJpeCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIFtuZXcgU3ltYm9sUXVhZChuZXcgUG9pbnQoYW5jaG9yLngsIGFuY2hvci55KSwgdGwsIHRyLCBibCwgYnIsIHNoYXBlZEljb24uaW1hZ2UucmVjdCwgMCwgbWluU2NhbGUsIEluZmluaXR5KV07XG59XG5cbi8qKlxuICogQ3JlYXRlIHRoZSBxdWFkcyB1c2VkIGZvciByZW5kZXJpbmcgYSB0ZXh0IGxhYmVsLlxuICpcbiAqIEBwYXJhbSB7QW5jaG9yfSBhbmNob3JcbiAqIEBwYXJhbSB7U2hhcGluZ30gc2hhcGluZ1xuICogQHBhcmFtIHtudW1iZXJ9IGJveFNjYWxlIEEgbWFnaWMgbnVtYmVyIGZvciBjb252ZXJ0aW5nIGZyb20gZ2x5cGggbWV0cmljIHVuaXRzIHRvIGdlb21ldHJ5IHVuaXRzLlxuICogQHBhcmFtIHtBcnJheTxBcnJheTxQb2ludD4+fSBsaW5lXG4gKiBAcGFyYW0ge0xheW91dFByb3BlcnRpZXN9IGxheW91dFxuICogQHBhcmFtIHtib29sZWFufSBhbG9uZ0xpbmUgV2hldGhlciB0aGUgbGFiZWwgc2hvdWxkIGJlIHBsYWNlZCBhbG9uZyB0aGUgbGluZS5cbiAqIEByZXR1cm5zIHtBcnJheTxTeW1ib2xRdWFkPn1cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGdldEdseXBoUXVhZHMoYW5jaG9yLCBzaGFwaW5nLCBib3hTY2FsZSwgbGluZSwgbGF5b3V0LCBhbG9uZ0xpbmUpIHtcblxuICAgIHZhciB0ZXh0Um90YXRlID0gbGF5b3V0Wyd0ZXh0LXJvdGF0ZSddICogTWF0aC5QSSAvIDE4MDtcbiAgICB2YXIga2VlcFVwcmlnaHQgPSBsYXlvdXRbJ3RleHQta2VlcC11cHJpZ2h0J107XG5cbiAgICB2YXIgcG9zaXRpb25lZEdseXBocyA9IHNoYXBpbmcucG9zaXRpb25lZEdseXBocztcbiAgICB2YXIgcXVhZHMgPSBbXTtcblxuICAgIGZvciAodmFyIGsgPSAwOyBrIDwgcG9zaXRpb25lZEdseXBocy5sZW5ndGg7IGsrKykge1xuICAgICAgICB2YXIgcG9zaXRpb25lZEdseXBoID0gcG9zaXRpb25lZEdseXBoc1trXTtcbiAgICAgICAgdmFyIGdseXBoID0gcG9zaXRpb25lZEdseXBoLmdseXBoO1xuICAgICAgICB2YXIgcmVjdCA9IGdseXBoLnJlY3Q7XG5cbiAgICAgICAgaWYgKCFyZWN0KSBjb250aW51ZTtcblxuICAgICAgICB2YXIgY2VudGVyWCA9IChwb3NpdGlvbmVkR2x5cGgueCArIGdseXBoLmFkdmFuY2UgLyAyKSAqIGJveFNjYWxlO1xuXG4gICAgICAgIHZhciBnbHlwaEluc3RhbmNlcztcbiAgICAgICAgdmFyIGxhYmVsTWluU2NhbGUgPSBtaW5TY2FsZTtcbiAgICAgICAgaWYgKGFsb25nTGluZSkge1xuICAgICAgICAgICAgZ2x5cGhJbnN0YW5jZXMgPSBbXTtcbiAgICAgICAgICAgIGxhYmVsTWluU2NhbGUgPSBnZXRTZWdtZW50R2x5cGhzKGdseXBoSW5zdGFuY2VzLCBhbmNob3IsIGNlbnRlclgsIGxpbmUsIGFuY2hvci5zZWdtZW50LCB0cnVlKTtcbiAgICAgICAgICAgIGlmIChrZWVwVXByaWdodCkge1xuICAgICAgICAgICAgICAgIGxhYmVsTWluU2NhbGUgPSBNYXRoLm1pbihsYWJlbE1pblNjYWxlLCBnZXRTZWdtZW50R2x5cGhzKGdseXBoSW5zdGFuY2VzLCBhbmNob3IsIGNlbnRlclgsIGxpbmUsIGFuY2hvci5zZWdtZW50LCBmYWxzZSkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBnbHlwaEluc3RhbmNlcyA9IFt7XG4gICAgICAgICAgICAgICAgYW5jaG9yUG9pbnQ6IG5ldyBQb2ludChhbmNob3IueCwgYW5jaG9yLnkpLFxuICAgICAgICAgICAgICAgIG9mZnNldDogMCxcbiAgICAgICAgICAgICAgICBhbmdsZTogMCxcbiAgICAgICAgICAgICAgICBtYXhTY2FsZTogSW5maW5pdHksXG4gICAgICAgICAgICAgICAgbWluU2NhbGU6IG1pblNjYWxlXG4gICAgICAgICAgICB9XTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB4MSA9IHBvc2l0aW9uZWRHbHlwaC54ICsgZ2x5cGgubGVmdCxcbiAgICAgICAgICAgIHkxID0gcG9zaXRpb25lZEdseXBoLnkgLSBnbHlwaC50b3AsXG4gICAgICAgICAgICB4MiA9IHgxICsgcmVjdC53LFxuICAgICAgICAgICAgeTIgPSB5MSArIHJlY3QuaCxcblxuICAgICAgICAgICAgb3RsID0gbmV3IFBvaW50KHgxLCB5MSksXG4gICAgICAgICAgICBvdHIgPSBuZXcgUG9pbnQoeDIsIHkxKSxcbiAgICAgICAgICAgIG9ibCA9IG5ldyBQb2ludCh4MSwgeTIpLFxuICAgICAgICAgICAgb2JyID0gbmV3IFBvaW50KHgyLCB5Mik7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBnbHlwaEluc3RhbmNlcy5sZW5ndGg7IGkrKykge1xuXG4gICAgICAgICAgICB2YXIgaW5zdGFuY2UgPSBnbHlwaEluc3RhbmNlc1tpXSxcbiAgICAgICAgICAgICAgICB0bCA9IG90bCxcbiAgICAgICAgICAgICAgICB0ciA9IG90cixcbiAgICAgICAgICAgICAgICBibCA9IG9ibCxcbiAgICAgICAgICAgICAgICBiciA9IG9icixcbiAgICAgICAgICAgICAgICBhbmdsZSA9IGluc3RhbmNlLmFuZ2xlICsgdGV4dFJvdGF0ZTtcblxuICAgICAgICAgICAgaWYgKGFuZ2xlKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNpbiA9IE1hdGguc2luKGFuZ2xlKSxcbiAgICAgICAgICAgICAgICAgICAgY29zID0gTWF0aC5jb3MoYW5nbGUpLFxuICAgICAgICAgICAgICAgICAgICBtYXRyaXggPSBbY29zLCAtc2luLCBzaW4sIGNvc107XG5cbiAgICAgICAgICAgICAgICB0bCA9IHRsLm1hdE11bHQobWF0cml4KTtcbiAgICAgICAgICAgICAgICB0ciA9IHRyLm1hdE11bHQobWF0cml4KTtcbiAgICAgICAgICAgICAgICBibCA9IGJsLm1hdE11bHQobWF0cml4KTtcbiAgICAgICAgICAgICAgICBiciA9IGJyLm1hdE11bHQobWF0cml4KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gUHJldmVudCBsYWJlbCBmcm9tIGV4dGVuZGluZyBwYXN0IHRoZSBlbmQgb2YgdGhlIGxpbmVcbiAgICAgICAgICAgIHZhciBnbHlwaE1pblNjYWxlID0gTWF0aC5tYXgoaW5zdGFuY2UubWluU2NhbGUsIGxhYmVsTWluU2NhbGUpO1xuXG4gICAgICAgICAgICB2YXIgZ2x5cGhBbmdsZSA9IChhbmNob3IuYW5nbGUgKyB0ZXh0Um90YXRlICsgaW5zdGFuY2Uub2Zmc2V0ICsgMiAqIE1hdGguUEkpICUgKDIgKiBNYXRoLlBJKTtcbiAgICAgICAgICAgIHF1YWRzLnB1c2gobmV3IFN5bWJvbFF1YWQoaW5zdGFuY2UuYW5jaG9yUG9pbnQsIHRsLCB0ciwgYmwsIGJyLCByZWN0LCBnbHlwaEFuZ2xlLCBnbHlwaE1pblNjYWxlLCBpbnN0YW5jZS5tYXhTY2FsZSkpO1xuXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcXVhZHM7XG59XG5cbi8qKlxuICogV2UgY2FuIG9ubHkgcmVuZGVyIGdseXBoIHF1YWRzIHRoYXQgc2xpZGUgYWxvbmcgYSBzdHJhaWdodCBsaW5lLiBUbyBkcmF3XG4gKiBjdXJ2ZWQgbGluZXMgd2UgbmVlZCBhbiBpbnN0YW5jZSBvZiBhIGdseXBoIGZvciBlYWNoIHNlZ21lbnQgaXQgYXBwZWFycyBvbi5cbiAqIFRoaXMgY3JlYXRlcyBhbGwgdGhlIGluc3RhbmNlcyBvZiBhIGdseXBoIHRoYXQgYXJlIG5lY2Vzc2FyeSB0byByZW5kZXIgYSBsYWJlbC5cbiAqXG4gKiBXZSBuZWVkIGFcbiAqIEBwYXJhbSB7QXJyYXk8T2JqZWN0Pn0gZ2x5cGhJbnN0YW5jZXMgQW4gZW1wdHkgYXJyYXkgdGhhdCBnbHlwaEluc3RhbmNlcyBhcmUgYWRkZWQgdG8uXG4gKiBAcGFyYW0ge0FuY2hvcn0gYW5jaG9yXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IFRoZSBnbHlwaCdzIG9mZnNldCBmcm9tIHRoZSBjZW50ZXIgb2YgdGhlIGxhYmVsLlxuICogQHBhcmFtIHtBcnJheTxQb2ludD59IGxpbmVcbiAqIEBwYXJhbSB7bnVtYmVyfSBzZWdtZW50IFRoZSBpbmRleCBvZiB0aGUgc2VnbWVudCBvZiB0aGUgbGluZSBvbiB3aGljaCB0aGUgYW5jaG9yIGV4aXN0cy5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gZm9yd2FyZCBJZiB0cnVlIGdldCB0aGUgZ2x5cGhzIHRoYXQgY29tZSBsYXRlciBvbiB0aGUgbGluZSwgb3RoZXJ3aXNlIGdldCB0aGUgZ2x5cGhzIHRoYXQgY29tZSBlYXJsaWVyLlxuICpcbiAqIEByZXR1cm5zIHtBcnJheTxPYmplY3Q+fSBnbHlwaEluc3RhbmNlc1xuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZ2V0U2VnbWVudEdseXBocyhnbHlwaHMsIGFuY2hvciwgb2Zmc2V0LCBsaW5lLCBzZWdtZW50LCBmb3J3YXJkKSB7XG4gICAgdmFyIHVwc2lkZURvd24gPSAhZm9yd2FyZDtcblxuICAgIGlmIChvZmZzZXQgPCAwKSBmb3J3YXJkID0gIWZvcndhcmQ7XG5cbiAgICBpZiAoZm9yd2FyZCkgc2VnbWVudCsrO1xuXG4gICAgdmFyIG5ld0FuY2hvclBvaW50ID0gbmV3IFBvaW50KGFuY2hvci54LCBhbmNob3IueSk7XG4gICAgdmFyIGVuZCA9IGxpbmVbc2VnbWVudF07XG4gICAgdmFyIHByZXZTY2FsZSA9IEluZmluaXR5O1xuXG4gICAgb2Zmc2V0ID0gTWF0aC5hYnMob2Zmc2V0KTtcblxuICAgIHZhciBwbGFjZW1lbnRTY2FsZSA9IG1pblNjYWxlO1xuXG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgdmFyIGRpc3RhbmNlID0gbmV3QW5jaG9yUG9pbnQuZGlzdChlbmQpO1xuICAgICAgICB2YXIgc2NhbGUgPSBvZmZzZXQgLyBkaXN0YW5jZTtcblxuICAgICAgICAvLyBHZXQgdGhlIGFuZ2xlIG9mIHRoZSBsaW5lIHNlZ21lbnRcbiAgICAgICAgdmFyIGFuZ2xlID0gTWF0aC5hdGFuMihlbmQueSAtIG5ld0FuY2hvclBvaW50LnksIGVuZC54IC0gbmV3QW5jaG9yUG9pbnQueCk7XG4gICAgICAgIGlmICghZm9yd2FyZCkgYW5nbGUgKz0gTWF0aC5QSTtcbiAgICAgICAgaWYgKHVwc2lkZURvd24pIGFuZ2xlICs9IE1hdGguUEk7XG5cbiAgICAgICAgZ2x5cGhzLnB1c2goe1xuICAgICAgICAgICAgYW5jaG9yUG9pbnQ6IG5ld0FuY2hvclBvaW50LFxuICAgICAgICAgICAgb2Zmc2V0OiB1cHNpZGVEb3duID8gTWF0aC5QSSA6IDAsXG4gICAgICAgICAgICBtaW5TY2FsZTogc2NhbGUsXG4gICAgICAgICAgICBtYXhTY2FsZTogcHJldlNjYWxlLFxuICAgICAgICAgICAgYW5nbGU6IChhbmdsZSArIDIgKiBNYXRoLlBJKSAlICgyICogTWF0aC5QSSlcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKHNjYWxlIDw9IHBsYWNlbWVudFNjYWxlKSBicmVhaztcblxuICAgICAgICBuZXdBbmNob3JQb2ludCA9IGVuZDtcblxuICAgICAgICAvLyBza2lwIGR1cGxpY2F0ZSBub2Rlc1xuICAgICAgICB3aGlsZSAobmV3QW5jaG9yUG9pbnQuZXF1YWxzKGVuZCkpIHtcbiAgICAgICAgICAgIHNlZ21lbnQgKz0gZm9yd2FyZCA/IDEgOiAtMTtcbiAgICAgICAgICAgIGVuZCA9IGxpbmVbc2VnbWVudF07XG4gICAgICAgICAgICBpZiAoIWVuZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzY2FsZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB1bml0ID0gZW5kLnN1YihuZXdBbmNob3JQb2ludCkuX3VuaXQoKTtcbiAgICAgICAgbmV3QW5jaG9yUG9pbnQgPSBuZXdBbmNob3JQb2ludC5zdWIodW5pdC5fbXVsdChkaXN0YW5jZSkpO1xuXG4gICAgICAgIHByZXZTY2FsZSA9IHNjYWxlO1xuICAgIH1cblxuICAgIHJldHVybiBwbGFjZW1lbnRTY2FsZTtcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHJlc29sdmVUb2tlbnMgPSByZXF1aXJlKCcuLi91dGlsL3Rva2VuJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gcmVzb2x2ZVRleHQ7XG5cbi8qKlxuICogRm9yIGFuIGFycmF5IG9mIGZlYXR1cmVzIGRldGVybWluZSB3aGF0IGdseXBocyBuZWVkIHRvIGJlIGxvYWRlZFxuICogYW5kIGFwcGx5IGFueSB0ZXh0IHByZXByb2Nlc3NpbmcuIFRoZSByZW1haW5pbmcgdXNlcnMgb2YgdGV4dCBzaG91bGRcbiAqIHVzZSB0aGUgYHRleHRGZWF0dXJlc2Aga2V5IHJldHVybmVkIGJ5IHRoaXMgZnVuY3Rpb24gcmF0aGVyIHRoYW4gYWNjZXNzaW5nXG4gKiBmZWF0dXJlIHRleHQgZGlyZWN0bHkuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiByZXNvbHZlVGV4dChmZWF0dXJlcywgbGF5b3V0UHJvcGVydGllcywgY29kZXBvaW50cykge1xuICAgIHZhciB0ZXh0RmVhdHVyZXMgPSBbXTtcblxuICAgIGZvciAodmFyIGkgPSAwLCBmbCA9IGZlYXR1cmVzLmxlbmd0aDsgaSA8IGZsOyBpKyspIHtcbiAgICAgICAgdmFyIHRleHQgPSByZXNvbHZlVG9rZW5zKGZlYXR1cmVzW2ldLnByb3BlcnRpZXMsIGxheW91dFByb3BlcnRpZXNbJ3RleHQtZmllbGQnXSk7XG4gICAgICAgIGlmICghdGV4dCkge1xuICAgICAgICAgICAgdGV4dEZlYXR1cmVzW2ldID0gbnVsbDtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHRleHQgPSB0ZXh0LnRvU3RyaW5nKCk7XG5cbiAgICAgICAgdmFyIHRyYW5zZm9ybSA9IGxheW91dFByb3BlcnRpZXNbJ3RleHQtdHJhbnNmb3JtJ107XG4gICAgICAgIGlmICh0cmFuc2Zvcm0gPT09ICd1cHBlcmNhc2UnKSB7XG4gICAgICAgICAgICB0ZXh0ID0gdGV4dC50b0xvY2FsZVVwcGVyQ2FzZSgpO1xuICAgICAgICB9IGVsc2UgaWYgKHRyYW5zZm9ybSA9PT0gJ2xvd2VyY2FzZScpIHtcbiAgICAgICAgICAgIHRleHQgPSB0ZXh0LnRvTG9jYWxlTG93ZXJDYXNlKCk7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHRleHQubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIGNvZGVwb2ludHNbdGV4dC5jaGFyQ29kZUF0KGopXSA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUcmFjayBpbmRleGVzIG9mIGZlYXR1cmVzIHdpdGggdGV4dC5cbiAgICAgICAgdGV4dEZlYXR1cmVzW2ldID0gdGV4dDtcbiAgICB9XG5cbiAgICByZXR1cm4gdGV4dEZlYXR1cmVzO1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBzaGFwZVRleHQ6IHNoYXBlVGV4dCxcbiAgICBzaGFwZUljb246IHNoYXBlSWNvblxufTtcblxuXG4vLyBUaGUgcG9zaXRpb24gb2YgYSBnbHlwaCByZWxhdGl2ZSB0byB0aGUgdGV4dCdzIGFuY2hvciBwb2ludC5cbmZ1bmN0aW9uIFBvc2l0aW9uZWRHbHlwaChjb2RlUG9pbnQsIHgsIHksIGdseXBoKSB7XG4gICAgdGhpcy5jb2RlUG9pbnQgPSBjb2RlUG9pbnQ7XG4gICAgdGhpcy54ID0geDtcbiAgICB0aGlzLnkgPSB5O1xuICAgIHRoaXMuZ2x5cGggPSBnbHlwaDtcbn1cblxuLy8gQSBjb2xsZWN0aW9uIG9mIHBvc2l0aW9uZWQgZ2x5cGhzIGFuZCBzb21lIG1ldGFkYXRhXG5mdW5jdGlvbiBTaGFwaW5nKHBvc2l0aW9uZWRHbHlwaHMsIHRleHQsIHRvcCwgYm90dG9tLCBsZWZ0LCByaWdodCkge1xuICAgIHRoaXMucG9zaXRpb25lZEdseXBocyA9IHBvc2l0aW9uZWRHbHlwaHM7XG4gICAgdGhpcy50ZXh0ID0gdGV4dDtcbiAgICB0aGlzLnRvcCA9IHRvcDtcbiAgICB0aGlzLmJvdHRvbSA9IGJvdHRvbTtcbiAgICB0aGlzLmxlZnQgPSBsZWZ0O1xuICAgIHRoaXMucmlnaHQgPSByaWdodDtcbn1cblxuZnVuY3Rpb24gc2hhcGVUZXh0KHRleHQsIGdseXBocywgbWF4V2lkdGgsIGxpbmVIZWlnaHQsIGhvcml6b250YWxBbGlnbiwgdmVydGljYWxBbGlnbiwganVzdGlmeSwgc3BhY2luZywgdHJhbnNsYXRlKSB7XG5cbiAgICB2YXIgcG9zaXRpb25lZEdseXBocyA9IFtdO1xuICAgIHZhciBzaGFwaW5nID0gbmV3IFNoYXBpbmcocG9zaXRpb25lZEdseXBocywgdGV4dCwgdHJhbnNsYXRlWzFdLCB0cmFuc2xhdGVbMV0sIHRyYW5zbGF0ZVswXSwgdHJhbnNsYXRlWzBdKTtcblxuICAgIC8vIHRoZSB5IG9mZnNldCAqc2hvdWxkKiBiZSBwYXJ0IG9mIHRoZSBmb250IG1ldGFkYXRhXG4gICAgdmFyIHlPZmZzZXQgPSAtMTc7XG5cbiAgICB2YXIgeCA9IDA7XG4gICAgdmFyIHkgPSB5T2Zmc2V0O1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0ZXh0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjb2RlUG9pbnQgPSB0ZXh0LmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIHZhciBnbHlwaCA9IGdseXBoc1tjb2RlUG9pbnRdO1xuXG4gICAgICAgIGlmICghZ2x5cGgpIGNvbnRpbnVlO1xuXG4gICAgICAgIHBvc2l0aW9uZWRHbHlwaHMucHVzaChuZXcgUG9zaXRpb25lZEdseXBoKGNvZGVQb2ludCwgeCwgeSwgZ2x5cGgpKTtcbiAgICAgICAgeCArPSBnbHlwaC5hZHZhbmNlICsgc3BhY2luZztcbiAgICB9XG5cbiAgICBpZiAoIXBvc2l0aW9uZWRHbHlwaHMubGVuZ3RoKSByZXR1cm4gZmFsc2U7XG5cbiAgICBsaW5ld3JhcChzaGFwaW5nLCBnbHlwaHMsIGxpbmVIZWlnaHQsIG1heFdpZHRoLCBob3Jpem9udGFsQWxpZ24sIHZlcnRpY2FsQWxpZ24sIGp1c3RpZnksIHRyYW5zbGF0ZSk7XG5cbiAgICByZXR1cm4gc2hhcGluZztcbn1cblxudmFyIGludmlzaWJsZSA9IHtcbiAgICAweDIwOiAgIHRydWUsIC8vIHNwYWNlXG4gICAgMHgyMDBiOiB0cnVlICAvLyB6ZXJvLXdpZHRoIHNwYWNlXG59O1xuXG52YXIgYnJlYWthYmxlID0ge1xuICAgIDB4MjA6ICAgdHJ1ZSwgLy8gc3BhY2VcbiAgICAweDI2OiAgIHRydWUsIC8vIGFtcGVyc2FuZFxuICAgIDB4MmI6ICAgdHJ1ZSwgLy8gcGx1cyBzaWduXG4gICAgMHgyZDogICB0cnVlLCAvLyBoeXBoZW4tbWludXNcbiAgICAweDJmOiAgIHRydWUsIC8vIHNvbGlkdXNcbiAgICAweGFkOiAgIHRydWUsIC8vIHNvZnQgaHlwaGVuXG4gICAgMHhiNzogICB0cnVlLCAvLyBtaWRkbGUgZG90XG4gICAgMHgyMDBiOiB0cnVlLCAvLyB6ZXJvLXdpZHRoIHNwYWNlXG4gICAgMHgyMDEwOiB0cnVlLCAvLyBoeXBoZW5cbiAgICAweDIwMTM6IHRydWUgIC8vIGVuIGRhc2hcbn07XG5cbmZ1bmN0aW9uIGxpbmV3cmFwKHNoYXBpbmcsIGdseXBocywgbGluZUhlaWdodCwgbWF4V2lkdGgsIGhvcml6b250YWxBbGlnbiwgdmVydGljYWxBbGlnbiwganVzdGlmeSwgdHJhbnNsYXRlKSB7XG4gICAgdmFyIGxhc3RTYWZlQnJlYWsgPSBudWxsO1xuXG4gICAgdmFyIGxlbmd0aEJlZm9yZUN1cnJlbnRMaW5lID0gMDtcbiAgICB2YXIgbGluZVN0YXJ0SW5kZXggPSAwO1xuICAgIHZhciBsaW5lID0gMDtcblxuICAgIHZhciBtYXhMaW5lTGVuZ3RoID0gMDtcblxuICAgIHZhciBwb3NpdGlvbmVkR2x5cGhzID0gc2hhcGluZy5wb3NpdGlvbmVkR2x5cGhzO1xuXG4gICAgaWYgKG1heFdpZHRoKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcG9zaXRpb25lZEdseXBocy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIHBvc2l0aW9uZWRHbHlwaCA9IHBvc2l0aW9uZWRHbHlwaHNbaV07XG5cbiAgICAgICAgICAgIHBvc2l0aW9uZWRHbHlwaC54IC09IGxlbmd0aEJlZm9yZUN1cnJlbnRMaW5lO1xuICAgICAgICAgICAgcG9zaXRpb25lZEdseXBoLnkgKz0gbGluZUhlaWdodCAqIGxpbmU7XG5cbiAgICAgICAgICAgIGlmIChwb3NpdGlvbmVkR2x5cGgueCA+IG1heFdpZHRoICYmIGxhc3RTYWZlQnJlYWsgIT09IG51bGwpIHtcblxuICAgICAgICAgICAgICAgIHZhciBsaW5lTGVuZ3RoID0gcG9zaXRpb25lZEdseXBoc1tsYXN0U2FmZUJyZWFrICsgMV0ueDtcbiAgICAgICAgICAgICAgICBtYXhMaW5lTGVuZ3RoID0gTWF0aC5tYXgobGluZUxlbmd0aCwgbWF4TGluZUxlbmd0aCk7XG5cbiAgICAgICAgICAgICAgICBmb3IgKHZhciBrID0gbGFzdFNhZmVCcmVhayArIDE7IGsgPD0gaTsgaysrKSB7XG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uZWRHbHlwaHNba10ueSArPSBsaW5lSGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbmVkR2x5cGhzW2tdLnggLT0gbGluZUxlbmd0aDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoanVzdGlmeSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBDb2xsYXBzZSBpbnZpc2libGUgY2hhcmFjdGVycy5cbiAgICAgICAgICAgICAgICAgICAgdmFyIGxpbmVFbmQgPSBsYXN0U2FmZUJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW52aXNpYmxlW3Bvc2l0aW9uZWRHbHlwaHNbbGFzdFNhZmVCcmVha10uY29kZVBvaW50XSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGluZUVuZC0tO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAganVzdGlmeUxpbmUocG9zaXRpb25lZEdseXBocywgZ2x5cGhzLCBsaW5lU3RhcnRJbmRleCwgbGluZUVuZCwganVzdGlmeSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgbGluZVN0YXJ0SW5kZXggPSBsYXN0U2FmZUJyZWFrICsgMTtcbiAgICAgICAgICAgICAgICBsYXN0U2FmZUJyZWFrID0gbnVsbDtcbiAgICAgICAgICAgICAgICBsZW5ndGhCZWZvcmVDdXJyZW50TGluZSArPSBsaW5lTGVuZ3RoO1xuICAgICAgICAgICAgICAgIGxpbmUrKztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGJyZWFrYWJsZVtwb3NpdGlvbmVkR2x5cGguY29kZVBvaW50XSkge1xuICAgICAgICAgICAgICAgIGxhc3RTYWZlQnJlYWsgPSBpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGxhc3RQb3NpdGlvbmVkR2x5cGggPSBwb3NpdGlvbmVkR2x5cGhzW3Bvc2l0aW9uZWRHbHlwaHMubGVuZ3RoIC0gMV07XG4gICAgdmFyIGxhc3RMaW5lTGVuZ3RoID0gbGFzdFBvc2l0aW9uZWRHbHlwaC54ICsgZ2x5cGhzW2xhc3RQb3NpdGlvbmVkR2x5cGguY29kZVBvaW50XS5hZHZhbmNlO1xuICAgIG1heExpbmVMZW5ndGggPSBNYXRoLm1heChtYXhMaW5lTGVuZ3RoLCBsYXN0TGluZUxlbmd0aCk7XG5cbiAgICB2YXIgaGVpZ2h0ID0gKGxpbmUgKyAxKSAqIGxpbmVIZWlnaHQ7XG5cbiAgICBqdXN0aWZ5TGluZShwb3NpdGlvbmVkR2x5cGhzLCBnbHlwaHMsIGxpbmVTdGFydEluZGV4LCBwb3NpdGlvbmVkR2x5cGhzLmxlbmd0aCAtIDEsIGp1c3RpZnkpO1xuICAgIGFsaWduKHBvc2l0aW9uZWRHbHlwaHMsIGp1c3RpZnksIGhvcml6b250YWxBbGlnbiwgdmVydGljYWxBbGlnbiwgbWF4TGluZUxlbmd0aCwgbGluZUhlaWdodCwgbGluZSwgdHJhbnNsYXRlKTtcblxuICAgIC8vIENhbGN1bGF0ZSB0aGUgYm91bmRpbmcgYm94XG4gICAgc2hhcGluZy50b3AgKz0gLXZlcnRpY2FsQWxpZ24gKiBoZWlnaHQ7XG4gICAgc2hhcGluZy5ib3R0b20gPSBzaGFwaW5nLnRvcCArIGhlaWdodDtcbiAgICBzaGFwaW5nLmxlZnQgKz0gLWhvcml6b250YWxBbGlnbiAqIG1heExpbmVMZW5ndGg7XG4gICAgc2hhcGluZy5yaWdodCA9IHNoYXBpbmcubGVmdCArIG1heExpbmVMZW5ndGg7XG59XG5cbmZ1bmN0aW9uIGp1c3RpZnlMaW5lKHBvc2l0aW9uZWRHbHlwaHMsIGdseXBocywgc3RhcnQsIGVuZCwganVzdGlmeSkge1xuICAgIHZhciBsYXN0QWR2YW5jZSA9IGdseXBoc1twb3NpdGlvbmVkR2x5cGhzW2VuZF0uY29kZVBvaW50XS5hZHZhbmNlO1xuICAgIHZhciBsaW5lSW5kZW50ID0gKHBvc2l0aW9uZWRHbHlwaHNbZW5kXS54ICsgbGFzdEFkdmFuY2UpICoganVzdGlmeTtcblxuICAgIGZvciAodmFyIGogPSBzdGFydDsgaiA8PSBlbmQ7IGorKykge1xuICAgICAgICBwb3NpdGlvbmVkR2x5cGhzW2pdLnggLT0gbGluZUluZGVudDtcbiAgICB9XG5cbn1cblxuZnVuY3Rpb24gYWxpZ24ocG9zaXRpb25lZEdseXBocywganVzdGlmeSwgaG9yaXpvbnRhbEFsaWduLCB2ZXJ0aWNhbEFsaWduLCBtYXhMaW5lTGVuZ3RoLCBsaW5lSGVpZ2h0LCBsaW5lLCB0cmFuc2xhdGUpIHtcbiAgICB2YXIgc2hpZnRYID0gKGp1c3RpZnkgLSBob3Jpem9udGFsQWxpZ24pICogbWF4TGluZUxlbmd0aCArIHRyYW5zbGF0ZVswXTtcbiAgICB2YXIgc2hpZnRZID0gKC12ZXJ0aWNhbEFsaWduICogKGxpbmUgKyAxKSArIDAuNSkgKiBsaW5lSGVpZ2h0ICsgdHJhbnNsYXRlWzFdO1xuXG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBwb3NpdGlvbmVkR2x5cGhzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIHBvc2l0aW9uZWRHbHlwaHNbal0ueCArPSBzaGlmdFg7XG4gICAgICAgIHBvc2l0aW9uZWRHbHlwaHNbal0ueSArPSBzaGlmdFk7XG4gICAgfVxufVxuXG5cbmZ1bmN0aW9uIHNoYXBlSWNvbihpbWFnZSwgbGF5b3V0KSB7XG4gICAgaWYgKCFpbWFnZSB8fCAhaW1hZ2UucmVjdCkgcmV0dXJuIG51bGw7XG5cbiAgICB2YXIgZHggPSBsYXlvdXRbJ2ljb24tb2Zmc2V0J11bMF07XG4gICAgdmFyIGR5ID0gbGF5b3V0WydpY29uLW9mZnNldCddWzFdO1xuICAgIHZhciB4MSA9IGR4IC0gaW1hZ2Uud2lkdGggLyAyO1xuICAgIHZhciB4MiA9IHgxICsgaW1hZ2Uud2lkdGg7XG4gICAgdmFyIHkxID0gZHkgLSBpbWFnZS5oZWlnaHQgLyAyO1xuICAgIHZhciB5MiA9IHkxICsgaW1hZ2UuaGVpZ2h0O1xuXG4gICAgcmV0dXJuIG5ldyBQb3NpdGlvbmVkSWNvbihpbWFnZSwgeTEsIHkyLCB4MSwgeDIpO1xufVxuXG5mdW5jdGlvbiBQb3NpdGlvbmVkSWNvbihpbWFnZSwgdG9wLCBib3R0b20sIGxlZnQsIHJpZ2h0KSB7XG4gICAgdGhpcy5pbWFnZSA9IGltYWdlO1xuICAgIHRoaXMudG9wID0gdG9wO1xuICAgIHRoaXMuYm90dG9tID0gYm90dG9tO1xuICAgIHRoaXMubGVmdCA9IGxlZnQ7XG4gICAgdGhpcy5yaWdodCA9IHJpZ2h0O1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgU2hlbGZQYWNrID0gcmVxdWlyZSgnc2hlbGYtcGFjaycpO1xudmFyIGJyb3dzZXIgPSByZXF1aXJlKCcuLi91dGlsL2Jyb3dzZXInKTtcblxubW9kdWxlLmV4cG9ydHMgPSBTcHJpdGVBdGxhcztcbmZ1bmN0aW9uIFNwcml0ZUF0bGFzKHdpZHRoLCBoZWlnaHQpIHtcbiAgICB0aGlzLndpZHRoID0gd2lkdGg7XG4gICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG5cbiAgICB0aGlzLmJpbiA9IG5ldyBTaGVsZlBhY2sod2lkdGgsIGhlaWdodCk7XG4gICAgdGhpcy5pbWFnZXMgPSB7fTtcbiAgICB0aGlzLmRhdGEgPSBmYWxzZTtcbiAgICB0aGlzLnRleHR1cmUgPSAwOyAvLyBXZWJHTCBJRFxuICAgIHRoaXMuZmlsdGVyID0gMDsgLy8gV2ViR0wgSURcbiAgICB0aGlzLnBpeGVsUmF0aW8gPSAxO1xuICAgIHRoaXMuZGlydHkgPSB0cnVlO1xufVxuXG5mdW5jdGlvbiBjb3B5Qml0bWFwKHNyYywgc3JjU3RyaWRlLCBzcmNYLCBzcmNZLCBkc3QsIGRzdFN0cmlkZSwgZHN0WCwgZHN0WSwgd2lkdGgsIGhlaWdodCwgd3JhcCkge1xuICAgIHZhciBzcmNJID0gc3JjWSAqIHNyY1N0cmlkZSArIHNyY1g7XG4gICAgdmFyIGRzdEkgPSBkc3RZICogZHN0U3RyaWRlICsgZHN0WDtcbiAgICB2YXIgeCwgeTtcblxuICAgIGlmICh3cmFwKSB7XG4gICAgICAgIC8vIGFkZCAxIHBpeGVsIHdyYXBwZWQgcGFkZGluZyBvbiBlYWNoIHNpZGUgb2YgdGhlIGltYWdlXG4gICAgICAgIGRzdEkgLT0gZHN0U3RyaWRlO1xuICAgICAgICBmb3IgKHkgPSAtMTsgeSA8PSBoZWlnaHQ7IHkrKywgc3JjSSA9ICgoeSArIGhlaWdodCkgJSBoZWlnaHQgKyBzcmNZKSAqIHNyY1N0cmlkZSArIHNyY1gsIGRzdEkgKz0gZHN0U3RyaWRlKSB7XG4gICAgICAgICAgICBmb3IgKHggPSAtMTsgeCA8PSB3aWR0aDsgeCsrKSB7XG4gICAgICAgICAgICAgICAgZHN0W2RzdEkgKyB4XSA9IHNyY1tzcmNJICsgKCh4ICsgd2lkdGgpICUgd2lkdGgpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgfSBlbHNlIHtcbiAgICAgICAgZm9yICh5ID0gMDsgeSA8IGhlaWdodDsgeSsrLCBzcmNJICs9IHNyY1N0cmlkZSwgZHN0SSArPSBkc3RTdHJpZGUpIHtcbiAgICAgICAgICAgIGZvciAoeCA9IDA7IHggPCB3aWR0aDsgeCsrKSB7XG4gICAgICAgICAgICAgICAgZHN0W2RzdEkgKyB4XSA9IHNyY1tzcmNJICsgeF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5cblNwcml0ZUF0bGFzLnByb3RvdHlwZS5hbGxvY2F0ZUltYWdlID0gZnVuY3Rpb24ocGl4ZWxXaWR0aCwgcGl4ZWxIZWlnaHQpIHtcblxuICAgIHBpeGVsV2lkdGggPSBwaXhlbFdpZHRoIC8gdGhpcy5waXhlbFJhdGlvO1xuICAgIHBpeGVsSGVpZ2h0ID0gcGl4ZWxIZWlnaHQgLyB0aGlzLnBpeGVsUmF0aW87XG5cbiAgICAvLyBJbmNyZWFzZSB0byBuZXh0IG51bWJlciBkaXZpc2libGUgYnkgNCwgYnV0IGF0IGxlYXN0IDEuXG4gICAgLy8gVGhpcyBpcyBzbyB3ZSBjYW4gc2NhbGUgZG93biB0aGUgdGV4dHVyZSBjb29yZGluYXRlcyBhbmQgcGFjayB0aGVtXG4gICAgLy8gaW50byAyIGJ5dGVzIHJhdGhlciB0aGFuIDQgYnl0ZXMuXG4gICAgLy8gUGFkIGljb25zIHRvIHByZXZlbnQgdGhlbSBmcm9tIHBvbGx1dGluZyBuZWlnaGJvdXJzIGR1cmluZyBsaW5lYXIgaW50ZXJwb2xhdGlvblxuICAgIHZhciBwYWRkaW5nID0gMjtcbiAgICB2YXIgcGFja1dpZHRoID0gcGl4ZWxXaWR0aCArIHBhZGRpbmcgKyAoNCAtIChwaXhlbFdpZHRoICsgcGFkZGluZykgJSA0KTtcbiAgICB2YXIgcGFja0hlaWdodCA9IHBpeGVsSGVpZ2h0ICsgcGFkZGluZyArICg0IC0gKHBpeGVsSGVpZ2h0ICsgcGFkZGluZykgJSA0KTsvLyArIDQ7XG5cbiAgICAvLyBXZSBoYXZlIHRvIGFsbG9jYXRlIGEgbmV3IGFyZWEgaW4gdGhlIGJpbiwgYW5kIHN0b3JlIGFuIGVtcHR5IGltYWdlIGluIGl0LlxuICAgIC8vIEFkZCBhIDFweCBib3JkZXIgYXJvdW5kIGV2ZXJ5IGltYWdlLlxuICAgIHZhciByZWN0ID0gdGhpcy5iaW4uYWxsb2NhdGUocGFja1dpZHRoLCBwYWNrSGVpZ2h0KTtcbiAgICBpZiAocmVjdC54IDwgMCkge1xuICAgICAgICBjb25zb2xlLndhcm4oJ1Nwcml0ZUF0bGFzIG91dCBvZiBzcGFjZS4nKTtcbiAgICAgICAgcmV0dXJuIHJlY3Q7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlY3Q7XG59O1xuXG5TcHJpdGVBdGxhcy5wcm90b3R5cGUuZ2V0SW1hZ2UgPSBmdW5jdGlvbihuYW1lLCB3cmFwKSB7XG4gICAgaWYgKHRoaXMuaW1hZ2VzW25hbWVdKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmltYWdlc1tuYW1lXTtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuc3ByaXRlKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHZhciBwb3MgPSB0aGlzLnNwcml0ZS5nZXRTcHJpdGVQb3NpdGlvbihuYW1lKTtcbiAgICBpZiAoIXBvcy53aWR0aCB8fCAhcG9zLmhlaWdodCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgcmVjdCA9IHRoaXMuYWxsb2NhdGVJbWFnZShwb3Mud2lkdGgsIHBvcy5oZWlnaHQpO1xuICAgIGlmIChyZWN0LnggPCAwKSB7XG4gICAgICAgIHJldHVybiByZWN0O1xuICAgIH1cblxuICAgIHZhciBpbWFnZSA9IG5ldyBBdGxhc0ltYWdlKHJlY3QsIHBvcy53aWR0aCAvIHBvcy5waXhlbFJhdGlvLCBwb3MuaGVpZ2h0IC8gcG9zLnBpeGVsUmF0aW8sIHBvcy5zZGYsIHBvcy5waXhlbFJhdGlvIC8gdGhpcy5waXhlbFJhdGlvKTtcbiAgICB0aGlzLmltYWdlc1tuYW1lXSA9IGltYWdlO1xuXG4gICAgdGhpcy5jb3B5KHJlY3QsIHBvcywgd3JhcCk7XG5cbiAgICByZXR1cm4gaW1hZ2U7XG59O1xuXG5cbi8vIFJldHVybiBwb3NpdGlvbiBvZiBhIHJlcGVhdGluZyBmaWxsIHBhdHRlcm4uXG5TcHJpdGVBdGxhcy5wcm90b3R5cGUuZ2V0UG9zaXRpb24gPSBmdW5jdGlvbihuYW1lLCByZXBlYXRpbmcpIHtcbiAgICB2YXIgaW1hZ2UgPSB0aGlzLmdldEltYWdlKG5hbWUsIHJlcGVhdGluZyk7XG4gICAgdmFyIHJlY3QgPSBpbWFnZSAmJiBpbWFnZS5yZWN0O1xuXG4gICAgaWYgKCFyZWN0KSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHZhciB3aWR0aCA9IGltYWdlLndpZHRoICogaW1hZ2UucGl4ZWxSYXRpbztcbiAgICB2YXIgaGVpZ2h0ID0gaW1hZ2UuaGVpZ2h0ICogaW1hZ2UucGl4ZWxSYXRpbztcbiAgICB2YXIgcGFkZGluZyA9IDE7XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBzaXplOiBbaW1hZ2Uud2lkdGgsIGltYWdlLmhlaWdodF0sXG4gICAgICAgIHRsOiBbKHJlY3QueCArIHBhZGRpbmcpICAgICAgICAgLyB0aGlzLndpZHRoLCAocmVjdC55ICsgcGFkZGluZykgICAgICAgICAgLyB0aGlzLmhlaWdodF0sXG4gICAgICAgIGJyOiBbKHJlY3QueCArIHBhZGRpbmcgKyB3aWR0aCkgLyB0aGlzLndpZHRoLCAocmVjdC55ICsgcGFkZGluZyArIGhlaWdodCkgLyB0aGlzLmhlaWdodF1cbiAgICB9O1xufTtcblxuXG5TcHJpdGVBdGxhcy5wcm90b3R5cGUuYWxsb2NhdGUgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAoIXRoaXMuZGF0YSkge1xuICAgICAgICB2YXIgdyA9IE1hdGguZmxvb3IodGhpcy53aWR0aCAqIHRoaXMucGl4ZWxSYXRpbyk7XG4gICAgICAgIHZhciBoID0gTWF0aC5mbG9vcih0aGlzLmhlaWdodCAqIHRoaXMucGl4ZWxSYXRpbyk7XG4gICAgICAgIHRoaXMuZGF0YSA9IG5ldyBVaW50MzJBcnJheSh3ICogaCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5kYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLmRhdGFbaV0gPSAwO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuXG5TcHJpdGVBdGxhcy5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uKGRzdCwgc3JjLCB3cmFwKSB7XG4gICAgaWYgKCF0aGlzLnNwcml0ZS5pbWcuZGF0YSkgcmV0dXJuO1xuICAgIHZhciBzcmNJbWcgPSBuZXcgVWludDMyQXJyYXkodGhpcy5zcHJpdGUuaW1nLmRhdGEuYnVmZmVyKTtcblxuICAgIHRoaXMuYWxsb2NhdGUoKTtcbiAgICB2YXIgZHN0SW1nID0gdGhpcy5kYXRhO1xuXG4gICAgdmFyIHBhZGRpbmcgPSAxO1xuXG4gICAgY29weUJpdG1hcChcbiAgICAgICAgLyogc291cmNlIGJ1ZmZlciAqLyAgc3JjSW1nLFxuICAgICAgICAvKiBzb3VyY2Ugc3RyaWRlICovICB0aGlzLnNwcml0ZS5pbWcud2lkdGgsXG4gICAgICAgIC8qIHNvdXJjZSB4ICovICAgICAgIHNyYy54LFxuICAgICAgICAvKiBzb3VyY2UgeSAqLyAgICAgICBzcmMueSxcbiAgICAgICAgLyogZGVzdCBidWZmZXIgKi8gICAgZHN0SW1nLFxuICAgICAgICAvKiBkZXN0IHN0cmlkZSAqLyAgICB0aGlzLndpZHRoICogdGhpcy5waXhlbFJhdGlvLFxuICAgICAgICAvKiBkZXN0IHggKi8gICAgICAgICAoZHN0LnggKyBwYWRkaW5nKSAqIHRoaXMucGl4ZWxSYXRpbyxcbiAgICAgICAgLyogZGVzdCB5ICovICAgICAgICAgKGRzdC55ICsgcGFkZGluZykgKiB0aGlzLnBpeGVsUmF0aW8sXG4gICAgICAgIC8qIGljb24gZGltZW5zaW9uICovIHNyYy53aWR0aCxcbiAgICAgICAgLyogaWNvbiBkaW1lbnNpb24gKi8gc3JjLmhlaWdodCxcbiAgICAgICAgLyogd3JhcCAqLyB3cmFwXG4gICAgKTtcblxuICAgIHRoaXMuZGlydHkgPSB0cnVlO1xufTtcblxuU3ByaXRlQXRsYXMucHJvdG90eXBlLnNldFNwcml0ZSA9IGZ1bmN0aW9uKHNwcml0ZSkge1xuICAgIGlmIChzcHJpdGUpIHtcbiAgICAgICAgdGhpcy5waXhlbFJhdGlvID0gYnJvd3Nlci5kZXZpY2VQaXhlbFJhdGlvID4gMSA/IDIgOiAxO1xuXG4gICAgICAgIGlmICh0aGlzLmNhbnZhcykge1xuICAgICAgICAgICAgdGhpcy5jYW52YXMud2lkdGggPSB0aGlzLndpZHRoICogdGhpcy5waXhlbFJhdGlvO1xuICAgICAgICAgICAgdGhpcy5jYW52YXMuaGVpZ2h0ID0gdGhpcy5oZWlnaHQgKiB0aGlzLnBpeGVsUmF0aW87XG4gICAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5zcHJpdGUgPSBzcHJpdGU7XG59O1xuXG5TcHJpdGVBdGxhcy5wcm90b3R5cGUuYWRkSWNvbnMgPSBmdW5jdGlvbihpY29ucywgY2FsbGJhY2spIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGljb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMuZ2V0SW1hZ2UoaWNvbnNbaV0pO1xuICAgIH1cblxuICAgIGNhbGxiYWNrKG51bGwsIHRoaXMuaW1hZ2VzKTtcbn07XG5cblNwcml0ZUF0bGFzLnByb3RvdHlwZS5iaW5kID0gZnVuY3Rpb24oZ2wsIGxpbmVhcikge1xuICAgIHZhciBmaXJzdCA9IGZhbHNlO1xuICAgIGlmICghdGhpcy50ZXh0dXJlKSB7XG4gICAgICAgIHRoaXMudGV4dHVyZSA9IGdsLmNyZWF0ZVRleHR1cmUoKTtcbiAgICAgICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGhpcy50ZXh0dXJlKTtcbiAgICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfUywgZ2wuQ0xBTVBfVE9fRURHRSk7XG4gICAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1QsIGdsLkNMQU1QX1RPX0VER0UpO1xuICAgICAgICBmaXJzdCA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGhpcy50ZXh0dXJlKTtcbiAgICB9XG5cbiAgICB2YXIgZmlsdGVyVmFsID0gbGluZWFyID8gZ2wuTElORUFSIDogZ2wuTkVBUkVTVDtcbiAgICBpZiAoZmlsdGVyVmFsICE9PSB0aGlzLmZpbHRlcikge1xuICAgICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUlOX0ZJTFRFUiwgZmlsdGVyVmFsKTtcbiAgICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01BR19GSUxURVIsIGZpbHRlclZhbCk7XG4gICAgICAgIHRoaXMuZmlsdGVyID0gZmlsdGVyVmFsO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmRpcnR5KSB7XG4gICAgICAgIHRoaXMuYWxsb2NhdGUoKTtcblxuICAgICAgICBpZiAoZmlyc3QpIHtcbiAgICAgICAgICAgIGdsLnRleEltYWdlMkQoXG4gICAgICAgICAgICAgICAgZ2wuVEVYVFVSRV8yRCwgLy8gZW51bSB0YXJnZXRcbiAgICAgICAgICAgICAgICAwLCAvLyBpbmQgbGV2ZWxcbiAgICAgICAgICAgICAgICBnbC5SR0JBLCAvLyBpbmQgaW50ZXJuYWxmb3JtYXRcbiAgICAgICAgICAgICAgICB0aGlzLndpZHRoICogdGhpcy5waXhlbFJhdGlvLCAvLyBHTHNpemVpIHdpZHRoXG4gICAgICAgICAgICAgICAgdGhpcy5oZWlnaHQgKiB0aGlzLnBpeGVsUmF0aW8sIC8vIEdMc2l6ZWkgaGVpZ2h0XG4gICAgICAgICAgICAgICAgMCwgLy8gaW5kIGJvcmRlclxuICAgICAgICAgICAgICAgIGdsLlJHQkEsIC8vIGVudW0gZm9ybWF0XG4gICAgICAgICAgICAgICAgZ2wuVU5TSUdORURfQllURSwgLy8gZW51bSB0eXBlXG4gICAgICAgICAgICAgICAgbmV3IFVpbnQ4QXJyYXkodGhpcy5kYXRhLmJ1ZmZlcikgLy8gT2JqZWN0IGRhdGFcbiAgICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBnbC50ZXhTdWJJbWFnZTJEKFxuICAgICAgICAgICAgICAgIGdsLlRFWFRVUkVfMkQsIC8vIGVudW0gdGFyZ2V0XG4gICAgICAgICAgICAgICAgMCwgLy8gaW50IGxldmVsXG4gICAgICAgICAgICAgICAgMCwgLy8gaW50IHhvZmZzZXRcbiAgICAgICAgICAgICAgICAwLCAvLyBpbnQgeW9mZnNldFxuICAgICAgICAgICAgICAgIHRoaXMud2lkdGggKiB0aGlzLnBpeGVsUmF0aW8sIC8vIGxvbmcgd2lkdGhcbiAgICAgICAgICAgICAgICB0aGlzLmhlaWdodCAqIHRoaXMucGl4ZWxSYXRpbywgLy8gbG9uZyBoZWlnaHRcbiAgICAgICAgICAgICAgICBnbC5SR0JBLCAvLyBlbnVtIGZvcm1hdFxuICAgICAgICAgICAgICAgIGdsLlVOU0lHTkVEX0JZVEUsIC8vIGVudW0gdHlwZVxuICAgICAgICAgICAgICAgIG5ldyBVaW50OEFycmF5KHRoaXMuZGF0YS5idWZmZXIpIC8vIE9iamVjdCBwaXhlbHNcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmRpcnR5ID0gZmFsc2U7XG4gICAgfVxufTtcblxuZnVuY3Rpb24gQXRsYXNJbWFnZShyZWN0LCB3aWR0aCwgaGVpZ2h0LCBzZGYsIHBpeGVsUmF0aW8pIHtcbiAgICB0aGlzLnJlY3QgPSByZWN0O1xuICAgIHRoaXMud2lkdGggPSB3aWR0aDtcbiAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcbiAgICB0aGlzLnNkZiA9IHNkZjtcbiAgICB0aGlzLnBpeGVsUmF0aW8gPSBwaXhlbFJhdGlvO1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwvdXRpbCcpO1xudmFyIGludGVycG9sYXRlID0gcmVxdWlyZSgnLi4vdXRpbC9pbnRlcnBvbGF0ZScpO1xudmFyIGJyb3dzZXIgPSByZXF1aXJlKCcuLi91dGlsL2Jyb3dzZXInKTtcbnZhciBMbmdMYXQgPSByZXF1aXJlKCcuLi9nZW8vbG5nX2xhdCcpO1xudmFyIExuZ0xhdEJvdW5kcyA9IHJlcXVpcmUoJy4uL2dlby9sbmdfbGF0X2JvdW5kcycpO1xudmFyIFBvaW50ID0gcmVxdWlyZSgncG9pbnQtZ2VvbWV0cnknKTtcblxuLyoqXG4gKiBPcHRpb25zIGNvbW1vbiB0byBNYXAjanVtcFRvLCBNYXAjZWFzZVRvLCBhbmQgTWFwI2ZseVRvLCBjb250cm9sbGluZyB0aGUgZGVzdGluYXRpb25cbiAqIGxvY2F0aW9uLCB6b29tIGxldmVsLCBiZWFyaW5nIGFuZCBwaXRjaC4gQWxsIHByb3BlcnRpZXMgYXJlIG9wdGlvbnM7IHVuc3BlY2lmaWVkXG4gKiBvcHRpb25zIHdpbGwgZGVmYXVsdCB0byB0aGUgY3VycmVudCB2YWx1ZSBmb3IgdGhhdCBwcm9wZXJ0eS5cbiAqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBDYW1lcmFPcHRpb25zXG4gKiBAcHJvcGVydHkge0xuZ0xhdH0gY2VudGVyIE1hcCBjZW50ZXJcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB6b29tIE1hcCB6b29tIGxldmVsXG4gKiBAcHJvcGVydHkge251bWJlcn0gYmVhcmluZyBNYXAgcm90YXRpb24gYmVhcmluZyBpbiBkZWdyZWVzIGNvdW50ZXItY2xvY2t3aXNlIGZyb20gbm9ydGhcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBwaXRjaCBNYXAgYW5nbGUgaW4gZGVncmVlcyBhdCB3aGljaCB0aGUgY2FtZXJhIGlzIGxvb2tpbmcgYXQgdGhlIGdyb3VuZFxuICogQHByb3BlcnR5IHtMbmdMYXR9IGFyb3VuZCBJZiB6b29taW5nLCB0aGUgem9vbSBjZW50ZXIgKGRlZmF1bHRzIHRvIG1hcCBjZW50ZXIpXG4gKi9cblxuLyoqXG4gKiBPcHRpb25zIGNvbW1vbiB0byBtYXAgbW92ZW1lbnQgbWV0aG9kcyB0aGF0IGludm9sdmUgYW5pbWF0aW9uLCBzdWNoIGFzIE1hcCNwYW5CeSBhbmRcbiAqIE1hcCNlYXNlVG8sIGNvbnRyb2xsaW5nIHRoZSBkdXJhdGlvbiBvZiB0aGUgYW5pbWF0aW9uIGFuZCBlYXNpbmcgZnVuY3Rpb24uIEFsbCBwcm9wZXJ0aWVzXG4gKiBhcmUgb3B0aW9uYWwuXG4gKlxuICogQHR5cGVkZWYge09iamVjdH0gQW5pbWF0aW9uT3B0aW9uc1xuICogQHByb3BlcnR5IHtudW1iZXJ9IGR1cmF0aW9uIE51bWJlciBpbiBtaWxsaXNlY29uZHNcbiAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IGVhc2luZ1xuICogQHByb3BlcnR5IHtBcnJheX0gb2Zmc2V0IHBvaW50LCBvcmlnaW4gb2YgbW92ZW1lbnQgcmVsYXRpdmUgdG8gbWFwIGNlbnRlclxuICogQHByb3BlcnR5IHtib29sZWFufSBhbmltYXRlIFdoZW4gc2V0IHRvIGZhbHNlLCBubyBhbmltYXRpb24gaGFwcGVuc1xuICovXG5cbnZhciBDYW1lcmEgPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCkge307XG5cbnV0aWwuZXh0ZW5kKENhbWVyYS5wcm90b3R5cGUsIC8qKiBAbGVuZHMgTWFwLnByb3RvdHlwZSAqL3tcbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGN1cnJlbnQgdmlldyBnZW9ncmFwaGljYWwgcG9pbnQuXG4gICAgICogQHJldHVybnMge0xuZ0xhdH1cbiAgICAgKi9cbiAgICBnZXRDZW50ZXI6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy50cmFuc2Zvcm0uY2VudGVyOyB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0cyBhIG1hcCBsb2NhdGlvbi4gRXF1aXZhbGVudCB0byBganVtcFRvKHtjZW50ZXI6IGNlbnRlcn0pYC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7TG5nTGF0fSBjZW50ZXIgTWFwIGNlbnRlciB0byBqdW1wIHRvXG4gICAgICogQHBhcmFtIHtFdmVudERhdGF9IFtldmVudERhdGFdIERhdGEgdG8gcHJvcGFnYXRlIHRvIGFueSBldmVudCByZWNlaXZlcnNcbiAgICAgKiBAZmlyZXMgbW92ZXN0YXJ0XG4gICAgICogQGZpcmVzIG1vdmVlbmRcbiAgICAgKiBAcmV0dXJucyB7TWFwfSBgdGhpc2BcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIG1hcC5zZXRDZW50ZXIoWy03NCwgMzhdKTtcbiAgICAgKi9cbiAgICBzZXRDZW50ZXI6IGZ1bmN0aW9uKGNlbnRlciwgZXZlbnREYXRhKSB7XG4gICAgICAgIHRoaXMuanVtcFRvKHtjZW50ZXI6IGNlbnRlcn0sIGV2ZW50RGF0YSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBQYW4gYnkgYSBjZXJ0YWluIG51bWJlciBvZiBwaXhlbHNcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gb2Zmc2V0IFt4LCB5XVxuICAgICAqIEBwYXJhbSB7QW5pbWF0aW9uT3B0aW9uc30gW29wdGlvbnNdXG4gICAgICogQHBhcmFtIHtFdmVudERhdGF9IFtldmVudERhdGFdIERhdGEgdG8gcHJvcGFnYXRlIHRvIGFueSBldmVudCByZWNlaXZlcnNcbiAgICAgKiBAZmlyZXMgbW92ZXN0YXJ0XG4gICAgICogQGZpcmVzIG1vdmVlbmRcbiAgICAgKiBAcmV0dXJucyB7TWFwfSBgdGhpc2BcbiAgICAgKi9cbiAgICBwYW5CeTogZnVuY3Rpb24ob2Zmc2V0LCBvcHRpb25zLCBldmVudERhdGEpIHtcbiAgICAgICAgdGhpcy5wYW5Ubyh0aGlzLnRyYW5zZm9ybS5jZW50ZXIsXG4gICAgICAgICAgICB1dGlsLmV4dGVuZCh7b2Zmc2V0OiBQb2ludC5jb252ZXJ0KG9mZnNldCkubXVsdCgtMSl9LCBvcHRpb25zKSwgZXZlbnREYXRhKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFBhbiB0byBhIGNlcnRhaW4gbG9jYXRpb24gd2l0aCBlYXNpbmdcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7TG5nTGF0fSBsbmdsYXQgTG9jYXRpb24gdG8gcGFuIHRvXG4gICAgICogQHBhcmFtIHtBbmltYXRpb25PcHRpb25zfSBbb3B0aW9uc11cbiAgICAgKiBAcGFyYW0ge0V2ZW50RGF0YX0gW2V2ZW50RGF0YV0gRGF0YSB0byBwcm9wYWdhdGUgdG8gYW55IGV2ZW50IHJlY2VpdmVyc1xuICAgICAqIEBmaXJlcyBtb3Zlc3RhcnRcbiAgICAgKiBAZmlyZXMgbW92ZWVuZFxuICAgICAqIEByZXR1cm5zIHtNYXB9IGB0aGlzYFxuICAgICAqL1xuICAgIHBhblRvOiBmdW5jdGlvbihsbmdsYXQsIG9wdGlvbnMsIGV2ZW50RGF0YSkge1xuICAgICAgICByZXR1cm4gdGhpcy5lYXNlVG8odXRpbC5leHRlbmQoe1xuICAgICAgICAgICAgY2VudGVyOiBsbmdsYXRcbiAgICAgICAgfSwgb3B0aW9ucyksIGV2ZW50RGF0YSk7XG4gICAgfSxcblxuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBjdXJyZW50IHpvb21cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqL1xuICAgIGdldFpvb206IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy50cmFuc2Zvcm0uem9vbTsgfSxcblxuICAgIC8qKlxuICAgICAqIFNldHMgYSBtYXAgem9vbS4gRXF1aXZhbGVudCB0byBganVtcFRvKHt6b29tOiB6b29tfSlgLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHpvb20gTWFwIHpvb20gbGV2ZWxcbiAgICAgKiBAcGFyYW0ge0V2ZW50RGF0YX0gW2V2ZW50RGF0YV0gRGF0YSB0byBwcm9wYWdhdGUgdG8gYW55IGV2ZW50IHJlY2VpdmVyc1xuICAgICAqIEBmaXJlcyBtb3Zlc3RhcnRcbiAgICAgKiBAZmlyZXMgem9vbXN0YXJ0XG4gICAgICogQGZpcmVzIG1vdmVcbiAgICAgKiBAZmlyZXMgem9vbVxuICAgICAqIEBmaXJlcyBtb3ZlZW5kXG4gICAgICogQGZpcmVzIHpvb21lbmRcbiAgICAgKiBAcmV0dXJucyB7TWFwfSBgdGhpc2BcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIHpvb20gdGhlIG1hcCB0byA1XG4gICAgICogbWFwLnNldFpvb20oNSk7XG4gICAgICovXG4gICAgc2V0Wm9vbTogZnVuY3Rpb24oem9vbSwgZXZlbnREYXRhKSB7XG4gICAgICAgIHRoaXMuanVtcFRvKHt6b29tOiB6b29tfSwgZXZlbnREYXRhKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFpvb21zIHRvIGEgY2VydGFpbiB6b29tIGxldmVsIHdpdGggZWFzaW5nLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHpvb21cbiAgICAgKiBAcGFyYW0ge0FuaW1hdGlvbk9wdGlvbnN9IFtvcHRpb25zXVxuICAgICAqIEBwYXJhbSB7RXZlbnREYXRhfSBbZXZlbnREYXRhXSBEYXRhIHRvIHByb3BhZ2F0ZSB0byBhbnkgZXZlbnQgcmVjZWl2ZXJzXG4gICAgICogQGZpcmVzIG1vdmVzdGFydFxuICAgICAqIEBmaXJlcyB6b29tc3RhcnRcbiAgICAgKiBAZmlyZXMgbW92ZVxuICAgICAqIEBmaXJlcyB6b29tXG4gICAgICogQGZpcmVzIG1vdmVlbmRcbiAgICAgKiBAZmlyZXMgem9vbWVuZFxuICAgICAqIEByZXR1cm5zIHtNYXB9IGB0aGlzYFxuICAgICAqL1xuICAgIHpvb21UbzogZnVuY3Rpb24oem9vbSwgb3B0aW9ucywgZXZlbnREYXRhKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVhc2VUbyh1dGlsLmV4dGVuZCh7XG4gICAgICAgICAgICB6b29tOiB6b29tXG4gICAgICAgIH0sIG9wdGlvbnMpLCBldmVudERhdGEpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBab29tIGluIGJ5IDEgbGV2ZWxcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7QW5pbWF0aW9uT3B0aW9uc30gW29wdGlvbnNdXG4gICAgICogQHBhcmFtIHtFdmVudERhdGF9IFtldmVudERhdGFdIERhdGEgdG8gcHJvcGFnYXRlIHRvIGFueSBldmVudCByZWNlaXZlcnNcbiAgICAgKiBAZmlyZXMgbW92ZXN0YXJ0XG4gICAgICogQGZpcmVzIHpvb21zdGFydFxuICAgICAqIEBmaXJlcyBtb3ZlXG4gICAgICogQGZpcmVzIHpvb21cbiAgICAgKiBAZmlyZXMgbW92ZWVuZFxuICAgICAqIEBmaXJlcyB6b29tZW5kXG4gICAgICogQHJldHVybnMge01hcH0gYHRoaXNgXG4gICAgICovXG4gICAgem9vbUluOiBmdW5jdGlvbihvcHRpb25zLCBldmVudERhdGEpIHtcbiAgICAgICAgdGhpcy56b29tVG8odGhpcy5nZXRab29tKCkgKyAxLCBvcHRpb25zLCBldmVudERhdGEpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogWm9vbSBvdXQgYnkgMSBsZXZlbFxuICAgICAqXG4gICAgICogQHBhcmFtIHtBbmltYXRpb25PcHRpb25zfSBbb3B0aW9uc11cbiAgICAgKiBAcGFyYW0ge0V2ZW50RGF0YX0gW2V2ZW50RGF0YV0gRGF0YSB0byBwcm9wYWdhdGUgdG8gYW55IGV2ZW50IHJlY2VpdmVyc1xuICAgICAqIEBmaXJlcyBtb3Zlc3RhcnRcbiAgICAgKiBAZmlyZXMgem9vbXN0YXJ0XG4gICAgICogQGZpcmVzIG1vdmVcbiAgICAgKiBAZmlyZXMgem9vbVxuICAgICAqIEBmaXJlcyBtb3ZlZW5kXG4gICAgICogQGZpcmVzIHpvb21lbmRcbiAgICAgKiBAcmV0dXJucyB7TWFwfSBgdGhpc2BcbiAgICAgKi9cbiAgICB6b29tT3V0OiBmdW5jdGlvbihvcHRpb25zLCBldmVudERhdGEpIHtcbiAgICAgICAgdGhpcy56b29tVG8odGhpcy5nZXRab29tKCkgLSAxLCBvcHRpb25zLCBldmVudERhdGEpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGN1cnJlbnQgYmVhcmluZyBpbiBkZWdyZWVzXG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKi9cbiAgICBnZXRCZWFyaW5nOiBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMudHJhbnNmb3JtLmJlYXJpbmc7IH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIGEgbWFwIHJvdGF0aW9uLiBFcXVpdmFsZW50IHRvIGBqdW1wVG8oe2JlYXJpbmc6IGJlYXJpbmd9KWAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYmVhcmluZyBNYXAgcm90YXRpb24gYmVhcmluZyBpbiBkZWdyZWVzIGNvdW50ZXItY2xvY2t3aXNlIGZyb20gbm9ydGhcbiAgICAgKiBAcGFyYW0ge0V2ZW50RGF0YX0gW2V2ZW50RGF0YV0gRGF0YSB0byBwcm9wYWdhdGUgdG8gYW55IGV2ZW50IHJlY2VpdmVyc1xuICAgICAqIEBmaXJlcyBtb3Zlc3RhcnRcbiAgICAgKiBAZmlyZXMgbW92ZWVuZFxuICAgICAqIEByZXR1cm5zIHtNYXB9IGB0aGlzYFxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gcm90YXRlIHRoZSBtYXAgdG8gOTAgZGVncmVlc1xuICAgICAqIG1hcC5zZXRCZWFyaW5nKDkwKTtcbiAgICAgKi9cbiAgICBzZXRCZWFyaW5nOiBmdW5jdGlvbihiZWFyaW5nLCBldmVudERhdGEpIHtcbiAgICAgICAgdGhpcy5qdW1wVG8oe2JlYXJpbmc6IGJlYXJpbmd9LCBldmVudERhdGEpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUm90YXRlIGJlYXJpbmcgYnkgYSBjZXJ0YWluIG51bWJlciBvZiBkZWdyZWVzIHdpdGggZWFzaW5nXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYmVhcmluZ1xuICAgICAqIEBwYXJhbSB7QW5pbWF0aW9uT3B0aW9uc30gW29wdGlvbnNdXG4gICAgICogQHBhcmFtIHtFdmVudERhdGF9IFtldmVudERhdGFdIERhdGEgdG8gcHJvcGFnYXRlIHRvIGFueSBldmVudCByZWNlaXZlcnNcbiAgICAgKiBAZmlyZXMgbW92ZXN0YXJ0XG4gICAgICogQGZpcmVzIG1vdmVlbmRcbiAgICAgKiBAcmV0dXJucyB7TWFwfSBgdGhpc2BcbiAgICAgKi9cbiAgICByb3RhdGVUbzogZnVuY3Rpb24oYmVhcmluZywgb3B0aW9ucywgZXZlbnREYXRhKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVhc2VUbyh1dGlsLmV4dGVuZCh7XG4gICAgICAgICAgICBiZWFyaW5nOiBiZWFyaW5nXG4gICAgICAgIH0sIG9wdGlvbnMpLCBldmVudERhdGEpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIG1hcCBiZWFyaW5nIHRvIDAgKG5vcnRoKSB3aXRoIGVhc2luZ1xuICAgICAqXG4gICAgICogQHBhcmFtIHtBbmltYXRpb25PcHRpb25zfSBbb3B0aW9uc11cbiAgICAgKiBAcGFyYW0ge0V2ZW50RGF0YX0gW2V2ZW50RGF0YV0gRGF0YSB0byBwcm9wYWdhdGUgdG8gYW55IGV2ZW50IHJlY2VpdmVyc1xuICAgICAqIEBmaXJlcyBtb3Zlc3RhcnRcbiAgICAgKiBAZmlyZXMgbW92ZWVuZFxuICAgICAqIEByZXR1cm5zIHtNYXB9IGB0aGlzYFxuICAgICAqL1xuICAgIHJlc2V0Tm9ydGg6IGZ1bmN0aW9uKG9wdGlvbnMsIGV2ZW50RGF0YSkge1xuICAgICAgICB0aGlzLnJvdGF0ZVRvKDAsIHV0aWwuZXh0ZW5kKHtkdXJhdGlvbjogMTAwMH0sIG9wdGlvbnMpLCBldmVudERhdGEpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQW5pbWF0ZXMgbWFwIGJlYXJpbmcgdG8gMCAobm9ydGgpIGlmIGl0J3MgYWxyZWFkeSBjbG9zZSB0byBpdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7QW5pbWF0aW9uT3B0aW9uc30gW29wdGlvbnNdXG4gICAgICogQHBhcmFtIHtFdmVudERhdGF9IFtldmVudERhdGFdIERhdGEgdG8gcHJvcGFnYXRlIHRvIGFueSBldmVudCByZWNlaXZlcnNcbiAgICAgKiBAZmlyZXMgbW92ZXN0YXJ0XG4gICAgICogQGZpcmVzIG1vdmVlbmRcbiAgICAgKiBAcmV0dXJucyB7TWFwfSBgdGhpc2BcbiAgICAgKi9cbiAgICBzbmFwVG9Ob3J0aDogZnVuY3Rpb24ob3B0aW9ucywgZXZlbnREYXRhKSB7XG4gICAgICAgIGlmIChNYXRoLmFicyh0aGlzLmdldEJlYXJpbmcoKSkgPCB0aGlzLm9wdGlvbnMuYmVhcmluZ1NuYXApIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlc2V0Tm9ydGgob3B0aW9ucywgZXZlbnREYXRhKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBjdXJyZW50IGFuZ2xlIGluIGRlZ3JlZXNcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqL1xuICAgIGdldFBpdGNoOiBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMudHJhbnNmb3JtLnBpdGNoOyB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0cyBhIG1hcCBhbmdsZS4gRXF1aXZhbGVudCB0byBganVtcFRvKHtwaXRjaDogcGl0Y2h9KWAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcGl0Y2ggVGhlIGFuZ2xlIGF0IHdoaWNoIHRoZSBjYW1lcmEgaXMgbG9va2luZyBhdCB0aGUgZ3JvdW5kXG4gICAgICogQHBhcmFtIHtFdmVudERhdGF9IFtldmVudERhdGFdIERhdGEgdG8gcHJvcGFnYXRlIHRvIGFueSBldmVudCByZWNlaXZlcnNcbiAgICAgKiBAZmlyZXMgbW92ZXN0YXJ0XG4gICAgICogQGZpcmVzIG1vdmVlbmRcbiAgICAgKiBAcmV0dXJucyB7TWFwfSBgdGhpc2BcbiAgICAgKi9cbiAgICBzZXRQaXRjaDogZnVuY3Rpb24ocGl0Y2gsIGV2ZW50RGF0YSkge1xuICAgICAgICB0aGlzLmp1bXBUbyh7cGl0Y2g6IHBpdGNofSwgZXZlbnREYXRhKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuXG4gICAgLyoqXG4gICAgICogWm9vbSB0byBjb250YWluIGNlcnRhaW4gZ2VvZ3JhcGhpY2FsIGJvdW5kc1xuICAgICAqXG4gICAgICogQHBhcmFtIHtMbmdMYXRCb3VuZHN8QXJyYXk8QXJyYXk8bnVtYmVyPj59IGJvdW5kcyBbW21pbkxuZywgbWluTGF0XSwgW21heExuZywgbWF4TGF0XV1cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMubGluZWFyXSBXaGVuIHRydWUsIHRoZSBtYXAgdHJhbnNpdGlvbnMgdG8gdGhlIG5ldyBjYW1lcmEgdXNpbmdcbiAgICAgKiAgICAge0BsaW5rICNNYXAuZWFzZVRvfS4gV2hlbiBmYWxzZSwgdGhlIG1hcCB0cmFuc2l0aW9ucyB1c2luZyB7QGxpbmsgI01hcC5mbHlUb30uIFNlZVxuICAgICAqICAgICB7QGxpbmsgI01hcC5mbHlUb30gZm9yIGluZm9ybWF0aW9uIG9uIG9wdGlvbnMgc3BlY2lmaWMgdG8gdGhhdCBhbmltYXRpb24gdHJhbnNpdGlvbi5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBvcHRpb25zLmVhc2luZ1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBvcHRpb25zLnBhZGRpbmcgaG93IG11Y2ggcGFkZGluZyB0aGVyZSBpcyBhcm91bmQgdGhlIGdpdmVuIGJvdW5kcyBvbiBlYWNoIHNpZGUgaW4gcGl4ZWxzXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG9wdGlvbnMubWF4Wm9vbSBUaGUgcmVzdWx0aW5nIHpvb20gbGV2ZWwgd2lsbCBiZSBhdCBtb3N0XG4gICAgICogICAgIHRoaXMgdmFsdWUuXG4gICAgICogQHBhcmFtIHtFdmVudERhdGF9IFtldmVudERhdGFdIERhdGEgdG8gcHJvcGFnYXRlIHRvIGFueSBldmVudCByZWNlaXZlcnNcbiAgICAgKiBAZmlyZXMgbW92ZXN0YXJ0XG4gICAgICogQGZpcmVzIG1vdmVlbmRcbiAgICAgKiBAcmV0dXJucyB7TWFwfSBgdGhpc2BcbiAgICAgKi9cbiAgICBmaXRCb3VuZHM6IGZ1bmN0aW9uKGJvdW5kcywgb3B0aW9ucywgZXZlbnREYXRhKSB7XG5cbiAgICAgICAgb3B0aW9ucyA9IHV0aWwuZXh0ZW5kKHtcbiAgICAgICAgICAgIHBhZGRpbmc6IDAsXG4gICAgICAgICAgICBvZmZzZXQ6IFswLCAwXSxcbiAgICAgICAgICAgIG1heFpvb206IEluZmluaXR5XG4gICAgICAgIH0sIG9wdGlvbnMpO1xuXG4gICAgICAgIGJvdW5kcyA9IExuZ0xhdEJvdW5kcy5jb252ZXJ0KGJvdW5kcyk7XG5cbiAgICAgICAgdmFyIG9mZnNldCA9IFBvaW50LmNvbnZlcnQob3B0aW9ucy5vZmZzZXQpLFxuICAgICAgICAgICAgdHIgPSB0aGlzLnRyYW5zZm9ybSxcbiAgICAgICAgICAgIG53ID0gdHIucHJvamVjdChib3VuZHMuZ2V0Tm9ydGhXZXN0KCkpLFxuICAgICAgICAgICAgc2UgPSB0ci5wcm9qZWN0KGJvdW5kcy5nZXRTb3V0aEVhc3QoKSksXG4gICAgICAgICAgICBzaXplID0gc2Uuc3ViKG53KSxcbiAgICAgICAgICAgIHNjYWxlWCA9ICh0ci53aWR0aCAtIG9wdGlvbnMucGFkZGluZyAqIDIgLSBNYXRoLmFicyhvZmZzZXQueCkgKiAyKSAvIHNpemUueCxcbiAgICAgICAgICAgIHNjYWxlWSA9ICh0ci5oZWlnaHQgLSBvcHRpb25zLnBhZGRpbmcgKiAyIC0gTWF0aC5hYnMob2Zmc2V0LnkpICogMikgLyBzaXplLnk7XG5cbiAgICAgICAgb3B0aW9ucy5jZW50ZXIgPSB0ci51bnByb2plY3QobncuYWRkKHNlKS5kaXYoMikpO1xuICAgICAgICBvcHRpb25zLnpvb20gPSBNYXRoLm1pbih0ci5zY2FsZVpvb20odHIuc2NhbGUgKiBNYXRoLm1pbihzY2FsZVgsIHNjYWxlWSkpLCBvcHRpb25zLm1heFpvb20pO1xuICAgICAgICBvcHRpb25zLmJlYXJpbmcgPSAwO1xuXG4gICAgICAgIHJldHVybiBvcHRpb25zLmxpbmVhciA/XG4gICAgICAgICAgICB0aGlzLmVhc2VUbyhvcHRpb25zLCBldmVudERhdGEpIDpcbiAgICAgICAgICAgIHRoaXMuZmx5VG8ob3B0aW9ucywgZXZlbnREYXRhKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2hhbmdlIGFueSBjb21iaW5hdGlvbiBvZiBjZW50ZXIsIHpvb20sIGJlYXJpbmcsIGFuZCBwaXRjaCwgd2l0aG91dFxuICAgICAqIGEgdHJhbnNpdGlvbi4gVGhlIG1hcCB3aWxsIHJldGFpbiB0aGUgY3VycmVudCB2YWx1ZXMgZm9yIGFueSBvcHRpb25zXG4gICAgICogbm90IGluY2x1ZGVkIGluIGBvcHRpb25zYC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Q2FtZXJhT3B0aW9uc30gb3B0aW9ucyBtYXAgdmlldyBvcHRpb25zXG4gICAgICogQHBhcmFtIHtFdmVudERhdGF9IFtldmVudERhdGFdIERhdGEgdG8gcHJvcGFnYXRlIHRvIGFueSBldmVudCByZWNlaXZlcnNcbiAgICAgKiBAZmlyZXMgbW92ZXN0YXJ0XG4gICAgICogQGZpcmVzIHpvb21zdGFydFxuICAgICAqIEBmaXJlcyBtb3ZlXG4gICAgICogQGZpcmVzIHpvb21cbiAgICAgKiBAZmlyZXMgcm90YXRlXG4gICAgICogQGZpcmVzIHBpdGNoXG4gICAgICogQGZpcmVzIHpvb21lbmRcbiAgICAgKiBAZmlyZXMgbW92ZWVuZFxuICAgICAqIEByZXR1cm5zIHtNYXB9IGB0aGlzYFxuICAgICAqL1xuICAgIGp1bXBUbzogZnVuY3Rpb24ob3B0aW9ucywgZXZlbnREYXRhKSB7XG4gICAgICAgIHRoaXMuc3RvcCgpO1xuXG4gICAgICAgIHZhciB0ciA9IHRoaXMudHJhbnNmb3JtLFxuICAgICAgICAgICAgem9vbUNoYW5nZWQgPSBmYWxzZSxcbiAgICAgICAgICAgIGJlYXJpbmdDaGFuZ2VkID0gZmFsc2UsXG4gICAgICAgICAgICBwaXRjaENoYW5nZWQgPSBmYWxzZTtcblxuICAgICAgICBpZiAoJ3pvb20nIGluIG9wdGlvbnMgJiYgdHIuem9vbSAhPT0gK29wdGlvbnMuem9vbSkge1xuICAgICAgICAgICAgem9vbUNoYW5nZWQgPSB0cnVlO1xuICAgICAgICAgICAgdHIuem9vbSA9ICtvcHRpb25zLnpvb207XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoJ2NlbnRlcicgaW4gb3B0aW9ucykge1xuICAgICAgICAgICAgdHIuY2VudGVyID0gTG5nTGF0LmNvbnZlcnQob3B0aW9ucy5jZW50ZXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCdiZWFyaW5nJyBpbiBvcHRpb25zICYmIHRyLmJlYXJpbmcgIT09ICtvcHRpb25zLmJlYXJpbmcpIHtcbiAgICAgICAgICAgIGJlYXJpbmdDaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgICAgIHRyLmJlYXJpbmcgPSArb3B0aW9ucy5iZWFyaW5nO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCdwaXRjaCcgaW4gb3B0aW9ucyAmJiB0ci5waXRjaCAhPT0gK29wdGlvbnMucGl0Y2gpIHtcbiAgICAgICAgICAgIHBpdGNoQ2hhbmdlZCA9IHRydWU7XG4gICAgICAgICAgICB0ci5waXRjaCA9ICtvcHRpb25zLnBpdGNoO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5maXJlKCdtb3Zlc3RhcnQnLCBldmVudERhdGEpXG4gICAgICAgICAgICAuZmlyZSgnbW92ZScsIGV2ZW50RGF0YSk7XG5cbiAgICAgICAgaWYgKHpvb21DaGFuZ2VkKSB7XG4gICAgICAgICAgICB0aGlzLmZpcmUoJ3pvb21zdGFydCcsIGV2ZW50RGF0YSlcbiAgICAgICAgICAgICAgICAuZmlyZSgnem9vbScsIGV2ZW50RGF0YSlcbiAgICAgICAgICAgICAgICAuZmlyZSgnem9vbWVuZCcsIGV2ZW50RGF0YSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYmVhcmluZ0NoYW5nZWQpIHtcbiAgICAgICAgICAgIHRoaXMuZmlyZSgncm90YXRlJywgZXZlbnREYXRhKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwaXRjaENoYW5nZWQpIHtcbiAgICAgICAgICAgIHRoaXMuZmlyZSgncGl0Y2gnLCBldmVudERhdGEpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuZmlyZSgnbW92ZWVuZCcsIGV2ZW50RGF0YSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENoYW5nZSBhbnkgY29tYmluYXRpb24gb2YgY2VudGVyLCB6b29tLCBiZWFyaW5nLCBhbmQgcGl0Y2gsIHdpdGggYSBzbW9vdGggYW5pbWF0aW9uXG4gICAgICogYmV0d2VlbiBvbGQgYW5kIG5ldyB2YWx1ZXMuIFRoZSBtYXAgd2lsbCByZXRhaW4gdGhlIGN1cnJlbnQgdmFsdWVzIGZvciBhbnkgb3B0aW9uc1xuICAgICAqIG5vdCBpbmNsdWRlZCBpbiBgb3B0aW9uc2AuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0NhbWVyYU9wdGlvbnN8QW5pbWF0aW9uT3B0aW9uc30gb3B0aW9ucyBtYXAgdmlldyBhbmQgYW5pbWF0aW9uIG9wdGlvbnNcbiAgICAgKiBAcGFyYW0ge0V2ZW50RGF0YX0gW2V2ZW50RGF0YV0gRGF0YSB0byBwcm9wYWdhdGUgdG8gYW55IGV2ZW50IHJlY2VpdmVyc1xuICAgICAqIEBmaXJlcyBtb3Zlc3RhcnRcbiAgICAgKiBAZmlyZXMgem9vbXN0YXJ0XG4gICAgICogQGZpcmVzIG1vdmVcbiAgICAgKiBAZmlyZXMgem9vbVxuICAgICAqIEBmaXJlcyByb3RhdGVcbiAgICAgKiBAZmlyZXMgcGl0Y2hcbiAgICAgKiBAZmlyZXMgem9vbWVuZFxuICAgICAqIEBmaXJlcyBtb3ZlZW5kXG4gICAgICogQHJldHVybnMge01hcH0gYHRoaXNgXG4gICAgICovXG4gICAgZWFzZVRvOiBmdW5jdGlvbihvcHRpb25zLCBldmVudERhdGEpIHtcbiAgICAgICAgdGhpcy5zdG9wKCk7XG5cbiAgICAgICAgb3B0aW9ucyA9IHV0aWwuZXh0ZW5kKHtcbiAgICAgICAgICAgIG9mZnNldDogWzAsIDBdLFxuICAgICAgICAgICAgZHVyYXRpb246IDUwMCxcbiAgICAgICAgICAgIGVhc2luZzogdXRpbC5lYXNlXG4gICAgICAgIH0sIG9wdGlvbnMpO1xuXG4gICAgICAgIHZhciB0ciA9IHRoaXMudHJhbnNmb3JtLFxuICAgICAgICAgICAgb2Zmc2V0ID0gUG9pbnQuY29udmVydChvcHRpb25zLm9mZnNldCksXG4gICAgICAgICAgICBzdGFydFpvb20gPSB0aGlzLmdldFpvb20oKSxcbiAgICAgICAgICAgIHN0YXJ0QmVhcmluZyA9IHRoaXMuZ2V0QmVhcmluZygpLFxuICAgICAgICAgICAgc3RhcnRQaXRjaCA9IHRoaXMuZ2V0UGl0Y2goKSxcblxuICAgICAgICAgICAgem9vbSA9ICd6b29tJyBpbiBvcHRpb25zID8gK29wdGlvbnMuem9vbSA6IHN0YXJ0Wm9vbSxcbiAgICAgICAgICAgIGJlYXJpbmcgPSAnYmVhcmluZycgaW4gb3B0aW9ucyA/IHRoaXMuX25vcm1hbGl6ZUJlYXJpbmcob3B0aW9ucy5iZWFyaW5nLCBzdGFydEJlYXJpbmcpIDogc3RhcnRCZWFyaW5nLFxuICAgICAgICAgICAgcGl0Y2ggPSAncGl0Y2gnIGluIG9wdGlvbnMgPyArb3B0aW9ucy5waXRjaCA6IHN0YXJ0UGl0Y2gsXG5cbiAgICAgICAgICAgIHRvTG5nTGF0LFxuICAgICAgICAgICAgdG9Qb2ludDtcblxuICAgICAgICBpZiAoJ2NlbnRlcicgaW4gb3B0aW9ucykge1xuICAgICAgICAgICAgdG9MbmdMYXQgPSBMbmdMYXQuY29udmVydChvcHRpb25zLmNlbnRlcik7XG4gICAgICAgICAgICB0b1BvaW50ID0gdHIuY2VudGVyUG9pbnQuYWRkKG9mZnNldCk7XG4gICAgICAgIH0gZWxzZSBpZiAoJ2Fyb3VuZCcgaW4gb3B0aW9ucykge1xuICAgICAgICAgICAgdG9MbmdMYXQgPSBMbmdMYXQuY29udmVydChvcHRpb25zLmFyb3VuZCk7XG4gICAgICAgICAgICB0b1BvaW50ID0gdHIubG9jYXRpb25Qb2ludCh0b0xuZ0xhdCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0b1BvaW50ID0gdHIuY2VudGVyUG9pbnQuYWRkKG9mZnNldCk7XG4gICAgICAgICAgICB0b0xuZ0xhdCA9IHRyLnBvaW50TG9jYXRpb24odG9Qb2ludCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZnJvbVBvaW50ID0gdHIubG9jYXRpb25Qb2ludCh0b0xuZ0xhdCk7XG5cbiAgICAgICAgaWYgKG9wdGlvbnMuYW5pbWF0ZSA9PT0gZmFsc2UpIG9wdGlvbnMuZHVyYXRpb24gPSAwO1xuXG4gICAgICAgIHRoaXMuem9vbWluZyA9ICh6b29tICE9PSBzdGFydFpvb20pO1xuICAgICAgICB0aGlzLnJvdGF0aW5nID0gKHN0YXJ0QmVhcmluZyAhPT0gYmVhcmluZyk7XG4gICAgICAgIHRoaXMucGl0Y2hpbmcgPSAocGl0Y2ggIT09IHN0YXJ0UGl0Y2gpO1xuXG4gICAgICAgIGlmICghb3B0aW9ucy5ub01vdmVTdGFydCkge1xuICAgICAgICAgICAgdGhpcy5maXJlKCdtb3Zlc3RhcnQnLCBldmVudERhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnpvb21pbmcpIHtcbiAgICAgICAgICAgIHRoaXMuZmlyZSgnem9vbXN0YXJ0JywgZXZlbnREYXRhKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLl9vbkVhc2VFbmQpO1xuXG4gICAgICAgIHRoaXMuX2Vhc2UoZnVuY3Rpb24gKGspIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnpvb21pbmcpIHtcbiAgICAgICAgICAgICAgICB0ci56b29tID0gaW50ZXJwb2xhdGUoc3RhcnRab29tLCB6b29tLCBrKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRoaXMucm90YXRpbmcpIHtcbiAgICAgICAgICAgICAgICB0ci5iZWFyaW5nID0gaW50ZXJwb2xhdGUoc3RhcnRCZWFyaW5nLCBiZWFyaW5nLCBrKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRoaXMucGl0Y2hpbmcpIHtcbiAgICAgICAgICAgICAgICB0ci5waXRjaCA9IGludGVycG9sYXRlKHN0YXJ0UGl0Y2gsIHBpdGNoLCBrKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdHIuc2V0TG9jYXRpb25BdFBvaW50KHRvTG5nTGF0LCBmcm9tUG9pbnQuYWRkKHRvUG9pbnQuc3ViKGZyb21Qb2ludCkuX211bHQoaykpKTtcblxuICAgICAgICAgICAgdGhpcy5maXJlKCdtb3ZlJywgZXZlbnREYXRhKTtcbiAgICAgICAgICAgIGlmICh0aGlzLnpvb21pbmcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZpcmUoJ3pvb20nLCBldmVudERhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMucm90YXRpbmcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZpcmUoJ3JvdGF0ZScsIGV2ZW50RGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5waXRjaGluZykge1xuICAgICAgICAgICAgICAgIHRoaXMuZmlyZSgncGl0Y2gnLCBldmVudERhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmRlbGF5RW5kRXZlbnRzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fb25FYXNlRW5kID0gc2V0VGltZW91dCh0aGlzLl9lYXNlVG9FbmQuYmluZCh0aGlzLCBldmVudERhdGEpLCBvcHRpb25zLmRlbGF5RW5kRXZlbnRzKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZWFzZVRvRW5kKGV2ZW50RGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0uYmluZCh0aGlzKSwgb3B0aW9ucyk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIF9lYXNlVG9FbmQ6IGZ1bmN0aW9uKGV2ZW50RGF0YSkge1xuICAgICAgICBpZiAodGhpcy56b29taW5nKSB7XG4gICAgICAgICAgICB0aGlzLmZpcmUoJ3pvb21lbmQnLCBldmVudERhdGEpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZmlyZSgnbW92ZWVuZCcsIGV2ZW50RGF0YSk7XG5cbiAgICAgICAgdGhpcy56b29taW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMucm90YXRpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5waXRjaGluZyA9IGZhbHNlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDaGFuZ2UgYW55IGNvbWJpbmF0aW9uIG9mIGNlbnRlciwgem9vbSwgYmVhcmluZywgYW5kIHBpdGNoLCBhbmltYXRlZCBhbG9uZyBhIGN1cnZlIHRoYXRcbiAgICAgKiBldm9rZXMgZmxpZ2h0LiBUaGUgdHJhbnNpdGlvbiBhbmltYXRpb24gc2VhbWxlc3NseSBpbmNvcnBvcmF0ZXMgem9vbWluZyBhbmQgcGFubmluZyB0byBoZWxwXG4gICAgICogdGhlIHVzZXIgZmluZCBoaXMgb3IgaGVyIGJlYXJpbmdzIGV2ZW4gYWZ0ZXIgdHJhdmVyc2luZyBhIGdyZWF0IGRpc3RhbmNlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtDYW1lcmFPcHRpb25zfEFuaW1hdGlvbk9wdGlvbnN9IG9wdGlvbnMgbWFwIHZpZXcgYW5kIGFuaW1hdGlvbiBvcHRpb25zXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLmN1cnZlPTEuNDJdIFJlbGF0aXZlIGFtb3VudCBvZiB6b29taW5nIHRoYXQgdGFrZXMgcGxhY2UgYWxvbmcgdGhlXG4gICAgICogICAgIGZsaWdodCBwYXRoLiBBIGhpZ2ggdmFsdWUgbWF4aW1pemVzIHpvb21pbmcgZm9yIGFuIGV4YWdnZXJhdGVkIGFuaW1hdGlvbiwgd2hpbGUgYSBsb3dcbiAgICAgKiAgICAgdmFsdWUgbWluaW1pemVzIHpvb21pbmcgZm9yIHNvbWV0aGluZyBjbG9zZXIgdG8ge0BsaW5rICNNYXAuZWFzZVRvfS4gMS40MiBpcyB0aGUgYXZlcmFnZVxuICAgICAqICAgICB2YWx1ZSBzZWxlY3RlZCBieSBwYXJ0aWNpcGFudHMgaW4gdGhlIHVzZXIgc3R1ZHkgaW5cbiAgICAgKiAgICAgW3ZhbiBXaWprICgyMDAzKV0oaHR0cHM6Ly93d3cud2luLnR1ZS5ubC9+dmFud2lqay96b29tcGFuLnBkZikuIEEgdmFsdWUgb2ZcbiAgICAgKiAgICAgYE1hdGgucG93KDYsIDAuMjUpYCB3b3VsZCBiZSBlcXVpdmFsZW50IHRvIHRoZSByb290IG1lYW4gc3F1YXJlZCBhdmVyYWdlIHZlbG9jaXR5LiBBXG4gICAgICogICAgIHZhbHVlIG9mIDEgd291bGQgcHJvZHVjZSBhIGNpcmN1bGFyIG1vdGlvbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMubWluWm9vbV0gWmVyby1iYXNlZCB6b29tIGxldmVsIGF0IHRoZSBwZWFrIG9mIHRoZSBmbGlnaHQgcGF0aC4gSWZcbiAgICAgKiAgICAgYG9wdGlvbnMuY3VydmVgIGlzIHNwZWNpZmllZCwgdGhpcyBvcHRpb24gaXMgaWdub3JlZC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMuc3BlZWQ9MS4yXSBBdmVyYWdlIHNwZWVkIG9mIHRoZSBhbmltYXRpb24uIEEgc3BlZWQgb2YgMS4yIG1lYW5zIHRoYXRcbiAgICAgKiAgICAgdGhlIG1hcCBhcHBlYXJzIHRvIG1vdmUgYWxvbmcgdGhlIGZsaWdodCBwYXRoIGJ5IDEuMiB0aW1lcyBgb3B0aW9ucy5jdXJ2ZWAgc2NyZWVuZnVscyBldmVyeVxuICAgICAqICAgICBzZWNvbmQuIEEgX3NjcmVlbmZ1bF8gaXMgdGhlIHZpc2libGUgc3BhbiBpbiBwaXhlbHMuIEl0IGRvZXMgbm90IGNvcnJlc3BvbmQgdG8gYSBmaXhlZFxuICAgICAqICAgICBwaHlzaWNhbCBkaXN0YW5jZSBidXQgcmF0aGVyIHZhcmllcyBieSB6b29tIGxldmVsLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5zY3JlZW5TcGVlZF0gQXZlcmFnZSBzcGVlZCBvZiB0aGUgYW5pbWF0aW9uLCBtZWFzdXJlZCBpbiBzY3JlZW5mdWxzXG4gICAgICogICAgIHBlciBzZWNvbmQsIGFzc3VtaW5nIGEgbGluZWFyIHRpbWluZyBjdXJ2ZS4gSWYgYG9wdGlvbnMuc3BlZWRgIGlzIHNwZWNpZmllZCwgdGhpcyBvcHRpb25cbiAgICAgKiAgICAgaXMgaWdub3JlZC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5lYXNpbmddIFRyYW5zaXRpb24gdGltaW5nIGN1cnZlXG4gICAgICogQHBhcmFtIHtFdmVudERhdGF9IFtldmVudERhdGFdIERhdGEgdG8gcHJvcGFnYXRlIHRvIGFueSBldmVudCByZWNlaXZlcnNcbiAgICAgKiBAZmlyZXMgbW92ZXN0YXJ0XG4gICAgICogQGZpcmVzIHpvb21zdGFydFxuICAgICAqIEBmaXJlcyBtb3ZlXG4gICAgICogQGZpcmVzIHpvb21cbiAgICAgKiBAZmlyZXMgcm90YXRlXG4gICAgICogQGZpcmVzIHBpdGNoXG4gICAgICogQGZpcmVzIHpvb21lbmRcbiAgICAgKiBAZmlyZXMgbW92ZWVuZFxuICAgICAqIEByZXR1cm5zIHt0aGlzfVxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gZmx5IHdpdGggZGVmYXVsdCBvcHRpb25zIHRvIG51bGwgaXNsYW5kXG4gICAgICogbWFwLmZseVRvKHtjZW50ZXI6IFswLCAwXSwgem9vbTogOX0pO1xuICAgICAqIC8vIHVzaW5nIGZseVRvIG9wdGlvbnNcbiAgICAgKiBtYXAuZmx5VG8oe1xuICAgICAqICAgY2VudGVyOiBbMCwgMF0sXG4gICAgICogICB6b29tOiA5LFxuICAgICAqICAgc3BlZWQ6IDAuMixcbiAgICAgKiAgIGN1cnZlOiAxLFxuICAgICAqICAgZWFzaW5nOiBmdW5jdGlvbih0KSB7XG4gICAgICogICAgIHJldHVybiB0O1xuICAgICAqICAgfVxuICAgICAqIH0pO1xuICAgICAqL1xuICAgIGZseVRvOiBmdW5jdGlvbihvcHRpb25zLCBldmVudERhdGEpIHtcbiAgICAgICAgLy8gVGhpcyBtZXRob2QgaW1wbGVtZW50cyBhbiDigJxvcHRpbWFsIHBhdGjigJ0gYW5pbWF0aW9uLCBhcyBkZXRhaWxlZCBpbjpcbiAgICAgICAgLy9cbiAgICAgICAgLy8gVmFuIFdpamssIEphcmtlIEouOyBOdWlqLCBXaW0gQS4gQS4g4oCcU21vb3RoIGFuZCBlZmZpY2llbnQgem9vbWluZyBhbmQgcGFubmluZy7igJ0gSU5GT1ZJU1xuICAgICAgICAvLyAgIOKAmTAzLiBwcC4gMTXigJMyMi4gPGh0dHBzOi8vd3d3Lndpbi50dWUubmwvfnZhbndpamsvem9vbXBhbi5wZGYjcGFnZT01Pi5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gV2hlcmUgYXBwbGljYWJsZSwgbG9jYWwgdmFyaWFibGUgZG9jdW1lbnRhdGlvbiBiZWdpbnMgd2l0aCB0aGUgYXNzb2NpYXRlZCB2YXJpYWJsZSBvclxuICAgICAgICAvLyBmdW5jdGlvbiBpbiB2YW4gV2lqayAoMjAwMykuXG5cbiAgICAgICAgdGhpcy5zdG9wKCk7XG5cbiAgICAgICAgb3B0aW9ucyA9IHV0aWwuZXh0ZW5kKHtcbiAgICAgICAgICAgIG9mZnNldDogWzAsIDBdLFxuICAgICAgICAgICAgc3BlZWQ6IDEuMixcbiAgICAgICAgICAgIGN1cnZlOiAxLjQyLFxuICAgICAgICAgICAgZWFzaW5nOiB1dGlsLmVhc2VcbiAgICAgICAgfSwgb3B0aW9ucyk7XG5cbiAgICAgICAgdmFyIHRyID0gdGhpcy50cmFuc2Zvcm0sXG4gICAgICAgICAgICBvZmZzZXQgPSBQb2ludC5jb252ZXJ0KG9wdGlvbnMub2Zmc2V0KSxcbiAgICAgICAgICAgIHN0YXJ0Wm9vbSA9IHRoaXMuZ2V0Wm9vbSgpLFxuICAgICAgICAgICAgc3RhcnRCZWFyaW5nID0gdGhpcy5nZXRCZWFyaW5nKCksXG4gICAgICAgICAgICBzdGFydFBpdGNoID0gdGhpcy5nZXRQaXRjaCgpO1xuXG4gICAgICAgIHZhciBjZW50ZXIgPSAnY2VudGVyJyBpbiBvcHRpb25zID8gTG5nTGF0LmNvbnZlcnQob3B0aW9ucy5jZW50ZXIpIDogdGhpcy5nZXRDZW50ZXIoKTtcbiAgICAgICAgdmFyIHpvb20gPSAnem9vbScgaW4gb3B0aW9ucyA/ICArb3B0aW9ucy56b29tIDogc3RhcnRab29tO1xuICAgICAgICB2YXIgYmVhcmluZyA9ICdiZWFyaW5nJyBpbiBvcHRpb25zID8gdGhpcy5fbm9ybWFsaXplQmVhcmluZyhvcHRpb25zLmJlYXJpbmcsIHN0YXJ0QmVhcmluZykgOiBzdGFydEJlYXJpbmc7XG4gICAgICAgIHZhciBwaXRjaCA9ICdwaXRjaCcgaW4gb3B0aW9ucyA/ICtvcHRpb25zLnBpdGNoIDogc3RhcnRQaXRjaDtcblxuICAgICAgICAvLyBJZiBhIHBhdGggY3Jvc3NpbmcgdGhlIGFudGltZXJpZGlhbiB3b3VsZCBiZSBzaG9ydGVyLCBleHRlbmQgdGhlIGZpbmFsIGNvb3JkaW5hdGUgc28gdGhhdFxuICAgICAgICAvLyBpbnRlcnBvbGF0aW5nIGJldHdlZW4gdGhlIHR3byBlbmRwb2ludHMgd2lsbCBjcm9zcyBpdC5cbiAgICAgICAgaWYgKE1hdGguYWJzKHRyLmNlbnRlci5sbmcpICsgTWF0aC5hYnMoY2VudGVyLmxuZykgPiAxODApIHtcbiAgICAgICAgICAgIGlmICh0ci5jZW50ZXIubG5nID4gMCAmJiBjZW50ZXIubG5nIDwgMCkge1xuICAgICAgICAgICAgICAgIGNlbnRlci5sbmcgKz0gMzYwO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0ci5jZW50ZXIubG5nIDwgMCAmJiBjZW50ZXIubG5nID4gMCkge1xuICAgICAgICAgICAgICAgIGNlbnRlci5sbmcgLT0gMzYwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHNjYWxlID0gdHIuem9vbVNjYWxlKHpvb20gLSBzdGFydFpvb20pLFxuICAgICAgICAgICAgZnJvbSA9IHRyLnBvaW50LFxuICAgICAgICAgICAgdG8gPSAnY2VudGVyJyBpbiBvcHRpb25zID8gdHIucHJvamVjdChjZW50ZXIpLnN1YihvZmZzZXQuZGl2KHNjYWxlKSkgOiBmcm9tO1xuXG4gICAgICAgIHZhciBzdGFydFdvcmxkU2l6ZSA9IHRyLndvcmxkU2l6ZSxcbiAgICAgICAgICAgIHJobyA9IG9wdGlvbnMuY3VydmUsXG5cbiAgICAgICAgICAgIC8vIHfigoA6IEluaXRpYWwgdmlzaWJsZSBzcGFuLCBtZWFzdXJlZCBpbiBwaXhlbHMgYXQgdGhlIGluaXRpYWwgc2NhbGUuXG4gICAgICAgICAgICB3MCA9IE1hdGgubWF4KHRyLndpZHRoLCB0ci5oZWlnaHQpLFxuICAgICAgICAgICAgLy8gd+KCgTogRmluYWwgdmlzaWJsZSBzcGFuLCBtZWFzdXJlZCBpbiBwaXhlbHMgd2l0aCByZXNwZWN0IHRvIHRoZSBpbml0aWFsIHNjYWxlLlxuICAgICAgICAgICAgdzEgPSB3MCAvIHNjYWxlLFxuICAgICAgICAgICAgLy8gTGVuZ3RoIG9mIHRoZSBmbGlnaHQgcGF0aCBhcyBwcm9qZWN0ZWQgb250byB0aGUgZ3JvdW5kIHBsYW5lLCBtZWFzdXJlZCBpbiBwaXhlbHMgZnJvbVxuICAgICAgICAgICAgLy8gdGhlIHdvcmxkIGltYWdlIG9yaWdpbiBhdCB0aGUgaW5pdGlhbCBzY2FsZS5cbiAgICAgICAgICAgIHUxID0gdG8uc3ViKGZyb20pLm1hZygpO1xuXG4gICAgICAgIGlmICgnbWluWm9vbScgaW4gb3B0aW9ucykge1xuICAgICAgICAgICAgdmFyIG1pblpvb20gPSB1dGlsLmNsYW1wKE1hdGgubWluKG9wdGlvbnMubWluWm9vbSwgc3RhcnRab29tLCB6b29tKSwgdHIubWluWm9vbSwgdHIubWF4Wm9vbSk7XG4gICAgICAgICAgICAvLyB3PHN1Yj5tPC9zdWI+OiBNYXhpbXVtIHZpc2libGUgc3BhbiwgbWVhc3VyZWQgaW4gcGl4ZWxzIHdpdGggcmVzcGVjdCB0byB0aGUgaW5pdGlhbFxuICAgICAgICAgICAgLy8gc2NhbGUuXG4gICAgICAgICAgICB2YXIgd01heCA9IHcwIC8gdHIuem9vbVNjYWxlKG1pblpvb20gLSBzdGFydFpvb20pO1xuICAgICAgICAgICAgcmhvID0gTWF0aC5zcXJ0KHdNYXggLyB1MSAqIDIpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gz4HCslxuICAgICAgICB2YXIgcmhvMiA9IHJobyAqIHJobztcblxuICAgICAgICAvKipcbiAgICAgICAgICogcuG1ojogUmV0dXJucyB0aGUgem9vbS1vdXQgZmFjdG9yIGF0IG9uZSBlbmQgb2YgdGhlIGFuaW1hdGlvbi5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIGkgMCBmb3IgdGhlIGFzY2VudCBvciAxIGZvciB0aGUgZGVzY2VudC5cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIHIoaSkge1xuICAgICAgICAgICAgdmFyIGIgPSAodzEgKiB3MSAtIHcwICogdzAgKyAoaSA/IC0xIDogMSkgKiByaG8yICogcmhvMiAqIHUxICogdTEpIC8gKDIgKiAoaSA/IHcxIDogdzApICogcmhvMiAqIHUxKTtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLmxvZyhNYXRoLnNxcnQoYiAqIGIgKyAxKSAtIGIpO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gc2luaChuKSB7IHJldHVybiAoTWF0aC5leHAobikgLSBNYXRoLmV4cCgtbikpIC8gMjsgfVxuICAgICAgICBmdW5jdGlvbiBjb3NoKG4pIHsgcmV0dXJuIChNYXRoLmV4cChuKSArIE1hdGguZXhwKC1uKSkgLyAyOyB9XG4gICAgICAgIGZ1bmN0aW9uIHRhbmgobikgeyByZXR1cm4gc2luaChuKSAvIGNvc2gobik7IH1cblxuICAgICAgICAvLyBy4oKAOiBab29tLW91dCBmYWN0b3IgZHVyaW5nIGFzY2VudC5cbiAgICAgICAgdmFyIHIwID0gcigwKSxcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogdyhzKTogUmV0dXJucyB0aGUgdmlzaWJsZSBzcGFuIG9uIHRoZSBncm91bmQsIG1lYXN1cmVkIGluIHBpeGVscyB3aXRoIHJlc3BlY3QgdG8gdGhlXG4gICAgICAgICAgICAgKiBpbml0aWFsIHNjYWxlLlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIEFzc3VtZXMgYW4gYW5ndWxhciBmaWVsZCBvZiB2aWV3IG9mIDIgYXJjdGFuIMK9IOKJiCA1M8KwLlxuICAgICAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdyA9IGZ1bmN0aW9uIChzKSB7IHJldHVybiAoY29zaChyMCkgLyBjb3NoKHIwICsgcmhvICogcykpOyB9LFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiB1KHMpOiBSZXR1cm5zIHRoZSBkaXN0YW5jZSBhbG9uZyB0aGUgZmxpZ2h0IHBhdGggYXMgcHJvamVjdGVkIG9udG8gdGhlIGdyb3VuZCBwbGFuZSxcbiAgICAgICAgICAgICAqIG1lYXN1cmVkIGluIHBpeGVscyBmcm9tIHRoZSB3b3JsZCBpbWFnZSBvcmlnaW4gYXQgdGhlIGluaXRpYWwgc2NhbGUuXG4gICAgICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB1ID0gZnVuY3Rpb24gKHMpIHsgcmV0dXJuIHcwICogKChjb3NoKHIwKSAqIHRhbmgocjAgKyByaG8gKiBzKSAtIHNpbmgocjApKSAvIHJobzIpIC8gdTE7IH0sXG4gICAgICAgICAgICAvLyBTOiBUb3RhbCBsZW5ndGggb2YgdGhlIGZsaWdodCBwYXRoLCBtZWFzdXJlZCBpbiDPgS1zY3JlZW5mdWxzLlxuICAgICAgICAgICAgUyA9IChyKDEpIC0gcjApIC8gcmhvO1xuXG4gICAgICAgIC8vIFdoZW4gdeKCgCA9IHXigoEsIHRoZSBvcHRpbWFsIHBhdGggZG9lc27igJl0IHJlcXVpcmUgYm90aCBhc2NlbnQgYW5kIGRlc2NlbnQuXG4gICAgICAgIGlmIChNYXRoLmFicyh1MSkgPCAwLjAwMDAwMSkge1xuICAgICAgICAgICAgLy8gUGVyZm9ybSBhIG1vcmUgb3IgbGVzcyBpbnN0YW50YW5lb3VzIHRyYW5zaXRpb24gaWYgdGhlIHBhdGggaXMgdG9vIHNob3J0LlxuICAgICAgICAgICAgaWYgKE1hdGguYWJzKHcwIC0gdzEpIDwgMC4wMDAwMDEpIHJldHVybiB0aGlzLmVhc2VUbyhvcHRpb25zKTtcblxuICAgICAgICAgICAgdmFyIGsgPSB3MSA8IHcwID8gLTEgOiAxO1xuICAgICAgICAgICAgUyA9IE1hdGguYWJzKE1hdGgubG9nKHcxIC8gdzApKSAvIHJobztcblxuICAgICAgICAgICAgdSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcbiAgICAgICAgICAgIHcgPSBmdW5jdGlvbihzKSB7IHJldHVybiBNYXRoLmV4cChrICogcmhvICogcyk7IH07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoJ2R1cmF0aW9uJyBpbiBvcHRpb25zKSB7XG4gICAgICAgICAgICBvcHRpb25zLmR1cmF0aW9uID0gK29wdGlvbnMuZHVyYXRpb247XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgViA9ICdzY3JlZW5TcGVlZCcgaW4gb3B0aW9ucyA/ICtvcHRpb25zLnNjcmVlblNwZWVkIC8gcmhvIDogK29wdGlvbnMuc3BlZWQ7XG4gICAgICAgICAgICBvcHRpb25zLmR1cmF0aW9uID0gMTAwMCAqIFMgLyBWO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy56b29taW5nID0gdHJ1ZTtcbiAgICAgICAgaWYgKHN0YXJ0QmVhcmluZyAhPT0gYmVhcmluZykgdGhpcy5yb3RhdGluZyA9IHRydWU7XG4gICAgICAgIGlmIChzdGFydFBpdGNoICE9PSBwaXRjaCkgdGhpcy5waXRjaGluZyA9IHRydWU7XG5cbiAgICAgICAgdGhpcy5maXJlKCdtb3Zlc3RhcnQnLCBldmVudERhdGEpO1xuICAgICAgICB0aGlzLmZpcmUoJ3pvb21zdGFydCcsIGV2ZW50RGF0YSk7XG5cbiAgICAgICAgdGhpcy5fZWFzZShmdW5jdGlvbiAoaykge1xuICAgICAgICAgICAgLy8gczogVGhlIGRpc3RhbmNlIHRyYXZlbGVkIGFsb25nIHRoZSBmbGlnaHQgcGF0aCwgbWVhc3VyZWQgaW4gz4Etc2NyZWVuZnVscy5cbiAgICAgICAgICAgIHZhciBzID0gayAqIFMsXG4gICAgICAgICAgICAgICAgdXMgPSB1KHMpO1xuXG4gICAgICAgICAgICB0ci56b29tID0gc3RhcnRab29tICsgdHIuc2NhbGVab29tKDEgLyB3KHMpKTtcbiAgICAgICAgICAgIHRyLmNlbnRlciA9IHRyLnVucHJvamVjdChmcm9tLmFkZCh0by5zdWIoZnJvbSkubXVsdCh1cykpLCBzdGFydFdvcmxkU2l6ZSk7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLnJvdGF0aW5nKSB7XG4gICAgICAgICAgICAgICAgdHIuYmVhcmluZyA9IGludGVycG9sYXRlKHN0YXJ0QmVhcmluZywgYmVhcmluZywgayk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5waXRjaGluZykge1xuICAgICAgICAgICAgICAgIHRyLnBpdGNoID0gaW50ZXJwb2xhdGUoc3RhcnRQaXRjaCwgcGl0Y2gsIGspO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLmZpcmUoJ21vdmUnLCBldmVudERhdGEpO1xuICAgICAgICAgICAgdGhpcy5maXJlKCd6b29tJywgZXZlbnREYXRhKTtcbiAgICAgICAgICAgIGlmICh0aGlzLnJvdGF0aW5nKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5maXJlKCdyb3RhdGUnLCBldmVudERhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMucGl0Y2hpbmcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZpcmUoJ3BpdGNoJywgZXZlbnREYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0aGlzLmZpcmUoJ3pvb21lbmQnLCBldmVudERhdGEpO1xuICAgICAgICAgICAgdGhpcy5maXJlKCdtb3ZlZW5kJywgZXZlbnREYXRhKTtcbiAgICAgICAgICAgIHRoaXMuem9vbWluZyA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5yb3RhdGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5waXRjaGluZyA9IGZhbHNlO1xuICAgICAgICB9LCBvcHRpb25zKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgaXNFYXNpbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gISF0aGlzLl9hYm9ydEZuO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTdG9wIGN1cnJlbnQgYW5pbWF0aW9uXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7TWFwfSBgdGhpc2BcbiAgICAgKi9cbiAgICBzdG9wOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuX2Fib3J0Rm4pIHtcbiAgICAgICAgICAgIHRoaXMuX2Fib3J0Rm4oKTtcbiAgICAgICAgICAgIHRoaXMuX2ZpbmlzaEVhc2UoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgX2Vhc2U6IGZ1bmN0aW9uKGZyYW1lLCBmaW5pc2gsIG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5fZmluaXNoRm4gPSBmaW5pc2g7XG4gICAgICAgIHRoaXMuX2Fib3J0Rm4gPSBicm93c2VyLnRpbWVkKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgICBmcmFtZS5jYWxsKHRoaXMsIG9wdGlvbnMuZWFzaW5nKHQpKTtcbiAgICAgICAgICAgIGlmICh0ID09PSAxKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZmluaXNoRWFzZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCBvcHRpb25zLmFuaW1hdGUgPT09IGZhbHNlID8gMCA6IG9wdGlvbnMuZHVyYXRpb24sIHRoaXMpO1xuICAgIH0sXG5cbiAgICBfZmluaXNoRWFzZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzLl9hYm9ydEZuO1xuICAgICAgICAvLyBUaGUgZmluaXNoIGZ1bmN0aW9uIG1pZ2h0IGVtaXQgZXZlbnRzIHdoaWNoIHRyaWdnZXIgbmV3IGVhc2VzLCB3aGljaFxuICAgICAgICAvLyBzZXQgYSBuZXcgX2ZpbmlzaEZuLiBFbnN1cmUgd2UgZG9uJ3QgZGVsZXRlIGl0IHVuaW50ZW50aW9uYWxseS5cbiAgICAgICAgdmFyIGZpbmlzaCA9IHRoaXMuX2ZpbmlzaEZuO1xuICAgICAgICBkZWxldGUgdGhpcy5fZmluaXNoRm47XG4gICAgICAgIGZpbmlzaC5jYWxsKHRoaXMpO1xuICAgIH0sXG5cbiAgICAvLyBjb252ZXJ0IGJlYXJpbmcgc28gdGhhdCBpdCdzIG51bWVyaWNhbGx5IGNsb3NlIHRvIHRoZSBjdXJyZW50IG9uZSBzbyB0aGF0IGl0IGludGVycG9sYXRlcyBwcm9wZXJseVxuICAgIF9ub3JtYWxpemVCZWFyaW5nOiBmdW5jdGlvbihiZWFyaW5nLCBjdXJyZW50QmVhcmluZykge1xuICAgICAgICBiZWFyaW5nID0gdXRpbC53cmFwKGJlYXJpbmcsIC0xODAsIDE4MCk7XG4gICAgICAgIHZhciBkaWZmID0gTWF0aC5hYnMoYmVhcmluZyAtIGN1cnJlbnRCZWFyaW5nKTtcbiAgICAgICAgaWYgKE1hdGguYWJzKGJlYXJpbmcgLSAzNjAgLSBjdXJyZW50QmVhcmluZykgPCBkaWZmKSBiZWFyaW5nIC09IDM2MDtcbiAgICAgICAgaWYgKE1hdGguYWJzKGJlYXJpbmcgKyAzNjAgLSBjdXJyZW50QmVhcmluZykgPCBkaWZmKSBiZWFyaW5nICs9IDM2MDtcbiAgICAgICAgcmV0dXJuIGJlYXJpbmc7XG4gICAgfSxcblxuICAgIF91cGRhdGVFYXNpbmc6IGZ1bmN0aW9uKGR1cmF0aW9uLCB6b29tLCBiZXppZXIpIHtcbiAgICAgICAgdmFyIGVhc2luZztcblxuICAgICAgICBpZiAodGhpcy5lYXNlKSB7XG4gICAgICAgICAgICB2YXIgZWFzZSA9IHRoaXMuZWFzZSxcbiAgICAgICAgICAgICAgICB0ID0gKERhdGUubm93KCkgLSBlYXNlLnN0YXJ0KSAvIGVhc2UuZHVyYXRpb24sXG4gICAgICAgICAgICAgICAgc3BlZWQgPSBlYXNlLmVhc2luZyh0ICsgMC4wMSkgLSBlYXNlLmVhc2luZyh0KSxcblxuICAgICAgICAgICAgICAgIC8vIFF1aWNrIGhhY2sgdG8gbWFrZSBuZXcgYmV6aWVyIHRoYXQgaXMgY29udGludW91cyB3aXRoIGxhc3RcbiAgICAgICAgICAgICAgICB4ID0gMC4yNyAvIE1hdGguc3FydChzcGVlZCAqIHNwZWVkICsgMC4wMDAxKSAqIDAuMDEsXG4gICAgICAgICAgICAgICAgeSA9IE1hdGguc3FydCgwLjI3ICogMC4yNyAtIHggKiB4KTtcblxuICAgICAgICAgICAgZWFzaW5nID0gdXRpbC5iZXppZXIoeCwgeSwgMC4yNSwgMSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlYXNpbmcgPSBiZXppZXIgPyB1dGlsLmJlemllci5hcHBseSh1dGlsLCBiZXppZXIpIDogdXRpbC5lYXNlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gc3RvcmUgaW5mb3JtYXRpb24gb24gY3VycmVudCBlYXNpbmdcbiAgICAgICAgdGhpcy5lYXNlID0ge1xuICAgICAgICAgICAgc3RhcnQ6IChuZXcgRGF0ZSgpKS5nZXRUaW1lKCksXG4gICAgICAgICAgICB0bzogTWF0aC5wb3coMiwgem9vbSksXG4gICAgICAgICAgICBkdXJhdGlvbjogZHVyYXRpb24sXG4gICAgICAgICAgICBlYXNpbmc6IGVhc2luZ1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBlYXNpbmc7XG4gICAgfVxufSk7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBDb250cm9sID0gcmVxdWlyZSgnLi9jb250cm9sJyk7XG52YXIgRE9NID0gcmVxdWlyZSgnLi4vLi4vdXRpbC9kb20nKTtcbnZhciB1dGlsID0gcmVxdWlyZSgnLi4vLi4vdXRpbC91dGlsJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gQXR0cmlidXRpb247XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhdHRyaWJ1dGlvbiBjb250cm9sXG4gKiBAY2xhc3MgQXR0cmlidXRpb25cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5wb3NpdGlvbj0nYm90dG9tLXJpZ2h0J10gQSBzdHJpbmcgaW5kaWNhdGluZyB0aGUgY29udHJvbCdzIHBvc2l0aW9uIG9uIHRoZSBtYXAuIE9wdGlvbnMgYXJlIGB0b3AtcmlnaHRgLCBgdG9wLWxlZnRgLCBgYm90dG9tLXJpZ2h0YCwgYGJvdHRvbS1sZWZ0YFxuICogQGV4YW1wbGVcbiAqIHZhciBtYXAgPSBuZXcgbWFwYm94Z2wuTWFwKHthdHRyaWJ1dGlvbkNvbnRyb2w6IGZhbHNlfSlcbiAqICAgICAuYWRkQ29udHJvbChuZXcgbWFwYm94Z2wuQXR0cmlidXRpb24oe3Bvc2l0aW9uOiAndG9wLWxlZnQnfSkpO1xuICovXG5mdW5jdGlvbiBBdHRyaWJ1dGlvbihvcHRpb25zKSB7XG4gICAgdXRpbC5zZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xufVxuXG5BdHRyaWJ1dGlvbi5wcm90b3R5cGUgPSB1dGlsLmluaGVyaXQoQ29udHJvbCwge1xuICAgIG9wdGlvbnM6IHtcbiAgICAgICAgcG9zaXRpb246ICdib3R0b20tcmlnaHQnXG4gICAgfSxcblxuICAgIG9uQWRkOiBmdW5jdGlvbihtYXApIHtcbiAgICAgICAgdmFyIGNsYXNzTmFtZSA9ICdtYXBib3hnbC1jdHJsLWF0dHJpYicsXG4gICAgICAgICAgICBjb250YWluZXIgPSB0aGlzLl9jb250YWluZXIgPSBET00uY3JlYXRlKCdkaXYnLCBjbGFzc05hbWUsIG1hcC5nZXRDb250YWluZXIoKSk7XG5cbiAgICAgICAgdGhpcy5fdXBkYXRlKCk7XG4gICAgICAgIG1hcC5vbignc291cmNlLmxvYWQnLCB0aGlzLl91cGRhdGUuYmluZCh0aGlzKSk7XG4gICAgICAgIG1hcC5vbignc291cmNlLmNoYW5nZScsIHRoaXMuX3VwZGF0ZS5iaW5kKHRoaXMpKTtcbiAgICAgICAgbWFwLm9uKCdzb3VyY2UucmVtb3ZlJywgdGhpcy5fdXBkYXRlLmJpbmQodGhpcykpO1xuICAgICAgICBtYXAub24oJ21vdmVlbmQnLCB0aGlzLl91cGRhdGVFZGl0TGluay5iaW5kKHRoaXMpKTtcblxuICAgICAgICByZXR1cm4gY29udGFpbmVyO1xuICAgIH0sXG5cbiAgICBfdXBkYXRlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGF0dHJpYnV0aW9ucyA9IFtdO1xuXG4gICAgICAgIGlmICh0aGlzLl9tYXAuc3R5bGUpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGlkIGluIHRoaXMuX21hcC5zdHlsZS5zb3VyY2VzKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNvdXJjZSA9IHRoaXMuX21hcC5zdHlsZS5zb3VyY2VzW2lkXTtcbiAgICAgICAgICAgICAgICBpZiAoc291cmNlLmF0dHJpYnV0aW9uICYmIGF0dHJpYnV0aW9ucy5pbmRleE9mKHNvdXJjZS5hdHRyaWJ1dGlvbikgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0aW9ucy5wdXNoKHNvdXJjZS5hdHRyaWJ1dGlvbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fY29udGFpbmVyLmlubmVySFRNTCA9IGF0dHJpYnV0aW9ucy5qb2luKCcgfCAnKTtcbiAgICAgICAgdGhpcy5fZWRpdExpbmsgPSB0aGlzLl9jb250YWluZXIuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSgnbWFwYm94LWltcHJvdmUtbWFwJylbMF07XG4gICAgICAgIHRoaXMuX3VwZGF0ZUVkaXRMaW5rKCk7XG4gICAgfSxcblxuICAgIF91cGRhdGVFZGl0TGluazogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLl9lZGl0TGluaykge1xuICAgICAgICAgICAgdmFyIGNlbnRlciA9IHRoaXMuX21hcC5nZXRDZW50ZXIoKTtcbiAgICAgICAgICAgIHRoaXMuX2VkaXRMaW5rLmhyZWYgPSAnaHR0cHM6Ly93d3cubWFwYm94LmNvbS9tYXAtZmVlZGJhY2svIy8nICtcbiAgICAgICAgICAgICAgICAgICAgY2VudGVyLmxuZyArICcvJyArIGNlbnRlci5sYXQgKyAnLycgKyBNYXRoLnJvdW5kKHRoaXMuX21hcC5nZXRab29tKCkgKyAxKTtcbiAgICAgICAgfVxuICAgIH1cbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IENvbnRyb2w7XG5cbi8qKlxuICogQSBiYXNlIGNsYXNzIGZvciBtYXAtcmVsYXRlZCBpbnRlcmZhY2UgZWxlbWVudHMuXG4gKlxuICogQGNsYXNzIENvbnRyb2xcbiAqL1xuZnVuY3Rpb24gQ29udHJvbCgpIHt9XG5cbkNvbnRyb2wucHJvdG90eXBlID0ge1xuICAgIC8qKlxuICAgICAqIEFkZCB0aGlzIGNvbnRyb2wgdG8gdGhlIG1hcCwgcmV0dXJuaW5nIHRoZSBjb250cm9sIGl0c2VsZlxuICAgICAqIGZvciBjaGFpbmluZy4gVGhpcyB3aWxsIGluc2VydCB0aGUgY29udHJvbCdzIERPTSBlbGVtZW50IGludG9cbiAgICAgKiB0aGUgbWFwJ3MgRE9NIGVsZW1lbnQgaWYgdGhlIGNvbnRyb2wgaGFzIGEgYHBvc2l0aW9uYCBzcGVjaWZpZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge01hcH0gbWFwXG4gICAgICogQHJldHVybnMge0NvbnRyb2x9IGB0aGlzYFxuICAgICAqL1xuICAgIGFkZFRvOiBmdW5jdGlvbihtYXApIHtcbiAgICAgICAgdGhpcy5fbWFwID0gbWFwO1xuICAgICAgICB2YXIgY29udGFpbmVyID0gdGhpcy5fY29udGFpbmVyID0gdGhpcy5vbkFkZChtYXApO1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zICYmIHRoaXMub3B0aW9ucy5wb3NpdGlvbikge1xuICAgICAgICAgICAgdmFyIHBvcyA9IHRoaXMub3B0aW9ucy5wb3NpdGlvbjtcbiAgICAgICAgICAgIHZhciBjb3JuZXIgPSBtYXAuX2NvbnRyb2xDb3JuZXJzW3Bvc107XG4gICAgICAgICAgICBjb250YWluZXIuY2xhc3NOYW1lICs9ICcgbWFwYm94Z2wtY3RybCc7XG4gICAgICAgICAgICBpZiAocG9zLmluZGV4T2YoJ2JvdHRvbScpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIGNvcm5lci5pbnNlcnRCZWZvcmUoY29udGFpbmVyLCBjb3JuZXIuZmlyc3RDaGlsZCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvcm5lci5hcHBlbmRDaGlsZChjb250YWluZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlbW92ZSB0aGlzIGNvbnRyb2wgZnJvbSB0aGUgbWFwIGl0IGhhcyBiZWVuIGFkZGVkIHRvLlxuICAgICAqXG4gICAgICogQHJldHVybnMge0NvbnRyb2x9IGB0aGlzYFxuICAgICAqL1xuICAgIHJlbW92ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuX2NvbnRhaW5lci5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuX2NvbnRhaW5lcik7XG4gICAgICAgIGlmICh0aGlzLm9uUmVtb3ZlKSB0aGlzLm9uUmVtb3ZlKHRoaXMuX21hcCk7XG4gICAgICAgIHRoaXMuX21hcCA9IG51bGw7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBDb250cm9sID0gcmVxdWlyZSgnLi9jb250cm9sJyk7XG52YXIgYnJvd3NlciA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvYnJvd3NlcicpO1xudmFyIERPTSA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvZG9tJyk7XG52YXIgdXRpbCA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvdXRpbCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEdlb2xvY2F0ZTtcblxudmFyIGdlb09wdGlvbnMgPSB7IGVuYWJsZUhpZ2hBY2N1cmFjeTogZmFsc2UsIHRpbWVvdXQ6IDYwMDAgLyogNnNlYyAqLyB9O1xuXG5cbi8qKlxuICogQ3JlYXRlcyBhIGdlb2xvY2F0aW9uIGNvbnRyb2xcbiAqIEBjbGFzcyBHZW9sb2NhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5wb3NpdGlvbj0ndG9wLXJpZ2h0J10gQSBzdHJpbmcgaW5kaWNhdGluZyB0aGUgY29udHJvbCdzIHBvc2l0aW9uIG9uIHRoZSBtYXAuIE9wdGlvbnMgYXJlIGB0b3AtcmlnaHRgLCBgdG9wLWxlZnRgLCBgYm90dG9tLXJpZ2h0YCwgYGJvdHRvbS1sZWZ0YFxuICogQGV4YW1wbGVcbiAqIG1hcC5hZGRDb250cm9sKG5ldyBtYXBib3hnbC5HZW9sb2NhdGUoe3Bvc2l0aW9uOiAndG9wLWxlZnQnfSkpOyAvLyBwb3NpdGlvbiBpcyBvcHRpb25hbFxuICovXG5mdW5jdGlvbiBHZW9sb2NhdGUob3B0aW9ucykge1xuICAgIHV0aWwuc2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcbn1cblxuR2VvbG9jYXRlLnByb3RvdHlwZSA9IHV0aWwuaW5oZXJpdChDb250cm9sLCB7XG4gICAgb3B0aW9uczoge1xuICAgICAgICBwb3NpdGlvbjogJ3RvcC1yaWdodCdcbiAgICB9LFxuXG4gICAgb25BZGQ6IGZ1bmN0aW9uKG1hcCkge1xuICAgICAgICB2YXIgY2xhc3NOYW1lID0gJ21hcGJveGdsLWN0cmwnO1xuXG4gICAgICAgIHZhciBjb250YWluZXIgPSB0aGlzLl9jb250YWluZXIgPSBET00uY3JlYXRlKCdkaXYnLCBjbGFzc05hbWUgKyAnLWdyb3VwJywgbWFwLmdldENvbnRhaW5lcigpKTtcbiAgICAgICAgaWYgKCFicm93c2VyLnN1cHBvcnRzR2VvbG9jYXRpb24pIHJldHVybiBjb250YWluZXI7XG5cbiAgICAgICAgdGhpcy5fY29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoJ2NvbnRleHRtZW51JywgdGhpcy5fb25Db250ZXh0TWVudS5iaW5kKHRoaXMpKTtcblxuICAgICAgICB0aGlzLl9nZW9sb2NhdGVCdXR0b24gPSBET00uY3JlYXRlKCdidXR0b24nLCAoY2xhc3NOYW1lICsgJy1pY29uICcgKyBjbGFzc05hbWUgKyAnLWdlb2xvY2F0ZScpLCB0aGlzLl9jb250YWluZXIpO1xuICAgICAgICB0aGlzLl9nZW9sb2NhdGVCdXR0b24uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLl9vbkNsaWNrR2VvbG9jYXRlLmJpbmQodGhpcykpO1xuICAgICAgICByZXR1cm4gY29udGFpbmVyO1xuICAgIH0sXG5cbiAgICBfb25Db250ZXh0TWVudTogZnVuY3Rpb24oZSkge1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgfSxcblxuICAgIF9vbkNsaWNrR2VvbG9jYXRlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgbmF2aWdhdG9yLmdlb2xvY2F0aW9uLmdldEN1cnJlbnRQb3NpdGlvbih0aGlzLl9zdWNjZXNzLmJpbmQodGhpcyksIHRoaXMuX2Vycm9yLmJpbmQodGhpcyksIGdlb09wdGlvbnMpO1xuXG4gICAgICAgIC8vIFRoaXMgdGltZW91dCBlbnN1cmVzIHRoYXQgd2Ugc3RpbGwgY2FsbCBmaW5pc2goKSBldmVuIGlmXG4gICAgICAgIC8vIHRoZSB1c2VyIGRlY2xpbmVzIHRvIHNoYXJlIHRoZWlyIGxvY2F0aW9uIGluIEZpcmVmb3hcbiAgICAgICAgdGhpcy5fdGltZW91dElkID0gc2V0VGltZW91dCh0aGlzLl9maW5pc2guYmluZCh0aGlzKSwgMTAwMDAgLyogMTBzZWMgKi8pO1xuICAgIH0sXG5cbiAgICBfc3VjY2VzczogZnVuY3Rpb24ocG9zaXRpb24pIHtcbiAgICAgICAgdGhpcy5fbWFwLmp1bXBUbyh7XG4gICAgICAgICAgICBjZW50ZXI6IFtwb3NpdGlvbi5jb29yZHMubG9uZ2l0dWRlLCBwb3NpdGlvbi5jb29yZHMubGF0aXR1ZGVdLFxuICAgICAgICAgICAgem9vbTogMTcsXG4gICAgICAgICAgICBiZWFyaW5nOiAwLFxuICAgICAgICAgICAgcGl0Y2g6IDBcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX2ZpbmlzaCgpO1xuICAgIH0sXG5cbiAgICBfZXJyb3I6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLl9maW5pc2goKTtcbiAgICB9LFxuXG4gICAgX2ZpbmlzaDogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLl90aW1lb3V0SWQpIHsgY2xlYXJUaW1lb3V0KHRoaXMuX3RpbWVvdXRJZCk7IH1cbiAgICAgICAgdGhpcy5fdGltZW91dElkID0gdW5kZWZpbmVkO1xuICAgIH1cblxufSk7XG5cbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIENvbnRyb2wgPSByZXF1aXJlKCcuL2NvbnRyb2wnKTtcbnZhciBET00gPSByZXF1aXJlKCcuLi8uLi91dGlsL2RvbScpO1xudmFyIHV0aWwgPSByZXF1aXJlKCcuLi8uLi91dGlsL3V0aWwnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBOYXZpZ2F0aW9uO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuYXZpZ2F0aW9uIGNvbnRyb2wgd2l0aCB6b29tIGJ1dHRvbnMgYW5kIGEgY29tcGFzc1xuICogQGNsYXNzIE5hdmlnYXRpb25cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5wb3NpdGlvbj0ndG9wLXJpZ2h0J10gQSBzdHJpbmcgaW5kaWNhdGluZyB0aGUgY29udHJvbCdzIHBvc2l0aW9uIG9uIHRoZSBtYXAuIE9wdGlvbnMgYXJlIGB0b3AtcmlnaHRgLCBgdG9wLWxlZnRgLCBgYm90dG9tLXJpZ2h0YCwgYGJvdHRvbS1sZWZ0YFxuICogQGV4YW1wbGVcbiAqIG1hcC5hZGRDb250cm9sKG5ldyBtYXBib3hnbC5OYXZpZ2F0aW9uKHtwb3NpdGlvbjogJ3RvcC1sZWZ0J30pKTsgLy8gcG9zaXRpb24gaXMgb3B0aW9uYWxcbiAqL1xuZnVuY3Rpb24gTmF2aWdhdGlvbihvcHRpb25zKSB7XG4gICAgdXRpbC5zZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xufVxuXG5OYXZpZ2F0aW9uLnByb3RvdHlwZSA9IHV0aWwuaW5oZXJpdChDb250cm9sLCB7XG4gICAgb3B0aW9uczoge1xuICAgICAgICBwb3NpdGlvbjogJ3RvcC1yaWdodCdcbiAgICB9LFxuXG4gICAgb25BZGQ6IGZ1bmN0aW9uKG1hcCkge1xuICAgICAgICB2YXIgY2xhc3NOYW1lID0gJ21hcGJveGdsLWN0cmwnO1xuXG4gICAgICAgIHZhciBjb250YWluZXIgPSB0aGlzLl9jb250YWluZXIgPSBET00uY3JlYXRlKCdkaXYnLCBjbGFzc05hbWUgKyAnLWdyb3VwJywgbWFwLmdldENvbnRhaW5lcigpKTtcbiAgICAgICAgdGhpcy5fY29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoJ2NvbnRleHRtZW51JywgdGhpcy5fb25Db250ZXh0TWVudS5iaW5kKHRoaXMpKTtcblxuICAgICAgICB0aGlzLl96b29tSW5CdXR0b24gPSB0aGlzLl9jcmVhdGVCdXR0b24oY2xhc3NOYW1lICsgJy1pY29uICcgKyBjbGFzc05hbWUgKyAnLXpvb20taW4nLCBtYXAuem9vbUluLmJpbmQobWFwKSk7XG4gICAgICAgIHRoaXMuX3pvb21PdXRCdXR0b24gPSB0aGlzLl9jcmVhdGVCdXR0b24oY2xhc3NOYW1lICsgJy1pY29uICcgKyBjbGFzc05hbWUgKyAnLXpvb20tb3V0JywgbWFwLnpvb21PdXQuYmluZChtYXApKTtcbiAgICAgICAgdGhpcy5fY29tcGFzcyA9IHRoaXMuX2NyZWF0ZUJ1dHRvbihjbGFzc05hbWUgKyAnLWljb24gJyArIGNsYXNzTmFtZSArICctY29tcGFzcycsIG1hcC5yZXNldE5vcnRoLmJpbmQobWFwKSk7XG5cbiAgICAgICAgdGhpcy5fY29tcGFzc0Fycm93ID0gRE9NLmNyZWF0ZSgnZGl2JywgJ2Fycm93JywgdGhpcy5fY29tcGFzcyk7XG5cbiAgICAgICAgdGhpcy5fY29tcGFzcy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzLl9vbkNvbXBhc3NEb3duLmJpbmQodGhpcykpO1xuICAgICAgICB0aGlzLl9vbkNvbXBhc3NNb3ZlID0gdGhpcy5fb25Db21wYXNzTW92ZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLl9vbkNvbXBhc3NVcCA9IHRoaXMuX29uQ29tcGFzc1VwLmJpbmQodGhpcyk7XG5cbiAgICAgICAgbWFwLm9uKCdyb3RhdGUnLCB0aGlzLl9yb3RhdGVDb21wYXNzQXJyb3cuYmluZCh0aGlzKSk7XG4gICAgICAgIHRoaXMuX3JvdGF0ZUNvbXBhc3NBcnJvdygpO1xuXG4gICAgICAgIHRoaXMuX2VsID0gbWFwLmdldENhbnZhc0NvbnRhaW5lcigpO1xuXG4gICAgICAgIHJldHVybiBjb250YWluZXI7XG4gICAgfSxcblxuICAgIF9vbkNvbnRleHRNZW51OiBmdW5jdGlvbihlKSB7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICB9LFxuXG4gICAgX29uQ29tcGFzc0Rvd246IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgaWYgKGUuYnV0dG9uICE9PSAwKSByZXR1cm47XG5cbiAgICAgICAgRE9NLmRpc2FibGVEcmFnKCk7XG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHRoaXMuX29uQ29tcGFzc01vdmUpO1xuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgdGhpcy5fb25Db21wYXNzVXApO1xuXG4gICAgICAgIHRoaXMuX2VsLmRpc3BhdGNoRXZlbnQoY29weU1vdXNlRXZlbnQoZSkpO1xuICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIH0sXG5cbiAgICBfb25Db21wYXNzTW92ZTogZnVuY3Rpb24oZSkge1xuICAgICAgICBpZiAoZS5idXR0b24gIT09IDApIHJldHVybjtcblxuICAgICAgICB0aGlzLl9lbC5kaXNwYXRjaEV2ZW50KGNvcHlNb3VzZUV2ZW50KGUpKTtcbiAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICB9LFxuXG4gICAgX29uQ29tcGFzc1VwOiBmdW5jdGlvbihlKSB7XG4gICAgICAgIGlmIChlLmJ1dHRvbiAhPT0gMCkgcmV0dXJuO1xuXG4gICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHRoaXMuX29uQ29tcGFzc01vdmUpO1xuICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgdGhpcy5fb25Db21wYXNzVXApO1xuICAgICAgICBET00uZW5hYmxlRHJhZygpO1xuXG4gICAgICAgIHRoaXMuX2VsLmRpc3BhdGNoRXZlbnQoY29weU1vdXNlRXZlbnQoZSkpO1xuICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIH0sXG5cbiAgICBfY3JlYXRlQnV0dG9uOiBmdW5jdGlvbihjbGFzc05hbWUsIGZuKSB7XG4gICAgICAgIHZhciBhID0gRE9NLmNyZWF0ZSgnYnV0dG9uJywgY2xhc3NOYW1lLCB0aGlzLl9jb250YWluZXIpO1xuICAgICAgICBhLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZnVuY3Rpb24oKSB7IGZuKCk7IH0pO1xuICAgICAgICByZXR1cm4gYTtcbiAgICB9LFxuXG4gICAgX3JvdGF0ZUNvbXBhc3NBcnJvdzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciByb3RhdGUgPSAncm90YXRlKCcgKyAodGhpcy5fbWFwLnRyYW5zZm9ybS5hbmdsZSAqICgxODAgLyBNYXRoLlBJKSkgKyAnZGVnKSc7XG4gICAgICAgIHRoaXMuX2NvbXBhc3NBcnJvdy5zdHlsZS50cmFuc2Zvcm0gPSByb3RhdGU7XG4gICAgfVxufSk7XG5cblxuZnVuY3Rpb24gY29weU1vdXNlRXZlbnQoZSkge1xuICAgIHJldHVybiBuZXcgTW91c2VFdmVudChlLnR5cGUsIHtcbiAgICAgICAgYnV0dG9uOiAyLCAgICAvLyByaWdodCBjbGlja1xuICAgICAgICBidXR0b25zOiAyLCAgIC8vIHJpZ2h0IGNsaWNrXG4gICAgICAgIGJ1YmJsZXM6IHRydWUsXG4gICAgICAgIGNhbmNlbGFibGU6IHRydWUsXG4gICAgICAgIGRldGFpbDogZS5kZXRhaWwsXG4gICAgICAgIHZpZXc6IGUudmlldyxcbiAgICAgICAgc2NyZWVuWDogZS5zY3JlZW5YLFxuICAgICAgICBzY3JlZW5ZOiBlLnNjcmVlblksXG4gICAgICAgIGNsaWVudFg6IGUuY2xpZW50WCxcbiAgICAgICAgY2xpZW50WTogZS5jbGllbnRZLFxuICAgICAgICBtb3ZlbWVudFg6IGUubW92ZW1lbnRYLFxuICAgICAgICBtb3ZlbWVudFk6IGUubW92ZW1lbnRZLFxuICAgICAgICBjdHJsS2V5OiBlLmN0cmxLZXksXG4gICAgICAgIHNoaWZ0S2V5OiBlLnNoaWZ0S2V5LFxuICAgICAgICBhbHRLZXk6IGUuYWx0S2V5LFxuICAgICAgICBtZXRhS2V5OiBlLm1ldGFLZXlcbiAgICB9KTtcbn1cblxuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgRE9NID0gcmVxdWlyZSgnLi4vLi4vdXRpbC9kb20nKSxcbiAgICBMbmdMYXRCb3VuZHMgPSByZXF1aXJlKCcuLi8uLi9nZW8vbG5nX2xhdF9ib3VuZHMnKSxcbiAgICB1dGlsID0gcmVxdWlyZSgnLi4vLi4vdXRpbC91dGlsJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gQm94Wm9vbUhhbmRsZXI7XG5cbi8qKlxuICogVGhlIGBCb3hab29tSGFuZGxlcmAgYWxsb3dzIGEgdXNlciB0byB6b29tIHRoZSBtYXAgdG8gZml0IGEgYm91bmRpbmcgYm94LlxuICogVGhlIGJvdW5kaW5nIGJveCBpcyBkZWZpbmVkIGJ5IGhvbGRpbmcgYHNoaWZ0YCB3aGlsZSBkcmFnZ2luZyB0aGUgY3Vyc29yLlxuICogQGNsYXNzIEJveFpvb21IYW5kbGVyXG4gKi9cbmZ1bmN0aW9uIEJveFpvb21IYW5kbGVyKG1hcCkge1xuICAgIHRoaXMuX21hcCA9IG1hcDtcbiAgICB0aGlzLl9lbCA9IG1hcC5nZXRDYW52YXNDb250YWluZXIoKTtcbiAgICB0aGlzLl9jb250YWluZXIgPSBtYXAuZ2V0Q29udGFpbmVyKCk7XG5cbiAgICB1dGlsLmJpbmRIYW5kbGVycyh0aGlzKTtcbn1cblxuQm94Wm9vbUhhbmRsZXIucHJvdG90eXBlID0ge1xuXG4gICAgX2VuYWJsZWQ6IGZhbHNlLFxuICAgIF9hY3RpdmU6IGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgY3VycmVudCBlbmFibGVkL2Rpc2FibGVkIHN0YXRlIG9mIHRoZSBcImJveCB6b29tXCIgaW50ZXJhY3Rpb24uXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IGVuYWJsZWQgc3RhdGVcbiAgICAgKi9cbiAgICBpc0VuYWJsZWQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2VuYWJsZWQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgXCJib3ggem9vbVwiIGludGVyYWN0aW9uIGlzIGN1cnJlbnRseSBhY3RpdmUsIGkuZS4gY3VycmVudGx5IGJlaW5nIHVzZWQuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IGFjdGl2ZSBzdGF0ZVxuICAgICAqL1xuICAgIGlzQWN0aXZlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hY3RpdmU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEVuYWJsZSB0aGUgXCJib3ggem9vbVwiIGludGVyYWN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICogICBtYXAuYm94Wm9vbS5lbmFibGUoKTtcbiAgICAgKi9cbiAgICBlbmFibGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNFbmFibGVkKCkpIHJldHVybjtcbiAgICAgICAgdGhpcy5fZWwuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdGhpcy5fb25Nb3VzZURvd24sIGZhbHNlKTtcbiAgICAgICAgdGhpcy5fZW5hYmxlZCA9IHRydWU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIERpc2FibGUgdGhlIFwiYm94IHpvb21cIiBpbnRlcmFjdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqICAgbWFwLmJveFpvb20uZGlzYWJsZSgpO1xuICAgICAqL1xuICAgIGRpc2FibGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzRW5hYmxlZCgpKSByZXR1cm47XG4gICAgICAgIHRoaXMuX2VsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXMuX29uTW91c2VEb3duKTtcbiAgICAgICAgdGhpcy5fZW5hYmxlZCA9IGZhbHNlO1xuICAgIH0sXG5cbiAgICBfb25Nb3VzZURvd246IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGlmICghKGUuc2hpZnRLZXkgJiYgZS5idXR0b24gPT09IDApKSByZXR1cm47XG5cbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgdGhpcy5fb25Nb3VzZU1vdmUsIGZhbHNlKTtcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIHRoaXMuX29uS2V5RG93biwgZmFsc2UpO1xuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgdGhpcy5fb25Nb3VzZVVwLCBmYWxzZSk7XG5cbiAgICAgICAgRE9NLmRpc2FibGVEcmFnKCk7XG4gICAgICAgIHRoaXMuX3N0YXJ0UG9zID0gRE9NLm1vdXNlUG9zKHRoaXMuX2VsLCBlKTtcbiAgICAgICAgdGhpcy5fYWN0aXZlID0gdHJ1ZTtcbiAgICB9LFxuXG4gICAgX29uTW91c2VNb3ZlOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICB2YXIgcDAgPSB0aGlzLl9zdGFydFBvcyxcbiAgICAgICAgICAgIHAxID0gRE9NLm1vdXNlUG9zKHRoaXMuX2VsLCBlKTtcblxuICAgICAgICBpZiAoIXRoaXMuX2JveCkge1xuICAgICAgICAgICAgdGhpcy5fYm94ID0gRE9NLmNyZWF0ZSgnZGl2JywgJ21hcGJveGdsLWJveHpvb20nLCB0aGlzLl9jb250YWluZXIpO1xuICAgICAgICAgICAgdGhpcy5fY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoJ21hcGJveGdsLWNyb3NzaGFpcicpO1xuICAgICAgICAgICAgdGhpcy5fZmlyZUV2ZW50KCdib3h6b29tc3RhcnQnLCBlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBtaW5YID0gTWF0aC5taW4ocDAueCwgcDEueCksXG4gICAgICAgICAgICBtYXhYID0gTWF0aC5tYXgocDAueCwgcDEueCksXG4gICAgICAgICAgICBtaW5ZID0gTWF0aC5taW4ocDAueSwgcDEueSksXG4gICAgICAgICAgICBtYXhZID0gTWF0aC5tYXgocDAueSwgcDEueSk7XG5cbiAgICAgICAgRE9NLnNldFRyYW5zZm9ybSh0aGlzLl9ib3gsICd0cmFuc2xhdGUoJyArIG1pblggKyAncHgsJyArIG1pblkgKyAncHgpJyk7XG5cbiAgICAgICAgdGhpcy5fYm94LnN0eWxlLndpZHRoID0gKG1heFggLSBtaW5YKSArICdweCc7XG4gICAgICAgIHRoaXMuX2JveC5zdHlsZS5oZWlnaHQgPSAobWF4WSAtIG1pblkpICsgJ3B4JztcbiAgICB9LFxuXG4gICAgX29uTW91c2VVcDogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgaWYgKGUuYnV0dG9uICE9PSAwKSByZXR1cm47XG5cbiAgICAgICAgdmFyIHAwID0gdGhpcy5fc3RhcnRQb3MsXG4gICAgICAgICAgICBwMSA9IERPTS5tb3VzZVBvcyh0aGlzLl9lbCwgZSksXG4gICAgICAgICAgICBib3VuZHMgPSBuZXcgTG5nTGF0Qm91bmRzKHRoaXMuX21hcC51bnByb2plY3QocDApLCB0aGlzLl9tYXAudW5wcm9qZWN0KHAxKSk7XG5cbiAgICAgICAgdGhpcy5fZmluaXNoKCk7XG5cbiAgICAgICAgaWYgKHAwLnggPT09IHAxLnggJiYgcDAueSA9PT0gcDEueSkge1xuICAgICAgICAgICAgdGhpcy5fZmlyZUV2ZW50KCdib3h6b29tY2FuY2VsJywgZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9tYXBcbiAgICAgICAgICAgICAgICAuZml0Qm91bmRzKGJvdW5kcywge2xpbmVhcjogdHJ1ZX0pXG4gICAgICAgICAgICAgICAgLmZpcmUoJ2JveHpvb21lbmQnLCB7IG9yaWdpbmFsRXZlbnQ6IGUsIGJveFpvb21Cb3VuZHM6IGJvdW5kcyB9KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBfb25LZXlEb3duOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICBpZiAoZS5rZXlDb2RlID09PSAyNykge1xuICAgICAgICAgICAgdGhpcy5fZmluaXNoKCk7XG4gICAgICAgICAgICB0aGlzLl9maXJlRXZlbnQoJ2JveHpvb21jYW5jZWwnLCBlKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBfZmluaXNoOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX2FjdGl2ZSA9IGZhbHNlO1xuXG4gICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHRoaXMuX29uTW91c2VNb3ZlLCBmYWxzZSk7XG4gICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCB0aGlzLl9vbktleURvd24sIGZhbHNlKTtcbiAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHRoaXMuX29uTW91c2VVcCwgZmFsc2UpO1xuXG4gICAgICAgIHRoaXMuX2NvbnRhaW5lci5jbGFzc0xpc3QucmVtb3ZlKCdtYXBib3hnbC1jcm9zc2hhaXInKTtcblxuICAgICAgICBpZiAodGhpcy5fYm94KSB7XG4gICAgICAgICAgICB0aGlzLl9ib3gucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLl9ib3gpO1xuICAgICAgICAgICAgdGhpcy5fYm94ID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIERPTS5lbmFibGVEcmFnKCk7XG4gICAgfSxcblxuICAgIF9maXJlRXZlbnQ6IGZ1bmN0aW9uICh0eXBlLCBlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tYXAuZmlyZSh0eXBlLCB7IG9yaWdpbmFsRXZlbnQ6IGUgfSk7XG4gICAgfVxufTtcblxuXG4vKipcbiAqIEJveHpvb20gc3RhcnQgZXZlbnQuIFRoaXMgZXZlbnQgaXMgZW1pdHRlZCBhdCB0aGUgc3RhcnQgb2YgYSBib3ggem9vbSBpbnRlcmFjdGlvbi5cbiAqXG4gKiBAZXZlbnQgYm94em9vbXN0YXJ0XG4gKiBAbWVtYmVyb2YgTWFwXG4gKiBAaW5zdGFuY2VcbiAqIEBwcm9wZXJ0eSB7RXZlbnREYXRhfSBkYXRhIE9yaWdpbmFsIGV2ZW50IGRhdGFcbiAqL1xuXG4vKipcbiAqIEJveHpvb20gZW5kIGV2ZW50LiBUaGlzIGV2ZW50IGlzIGVtaXR0ZWQgYXQgdGhlIGVuZCBvZiBhIGJveCB6b29tIGludGVyYWN0aW9uXG4gKlxuICogQGV2ZW50IGJveHpvb21lbmRcbiAqIEBtZW1iZXJvZiBNYXBcbiAqIEBpbnN0YW5jZVxuICogQHR5cGUge09iamVjdH1cbiAqIEBwcm9wZXJ0eSB7RXZlbnR9IG9yaWdpbmFsRXZlbnQgdGhlIG9yaWdpbmFsIERPTSBldmVudFxuICogQHByb3BlcnR5IHtMbmdMYXRCb3VuZHN9IGJveFpvb21Cb3VuZHMgdGhlIGJvdW5kcyBvZiB0aGUgYm94IHpvb20gdGFyZ2V0XG4gKi9cblxuLyoqXG4gKiBCb3h6b29tIGNhbmNlbCBldmVudC4gIFRoaXMgZXZlbnQgaXMgZW1pdHRlZCB3aGVuIHRoZSB1c2VyIGNhbmNlbHMgYSBib3ggem9vbSBpbnRlcmFjdGlvbixcbiAqICAgb3Igd2hlbiB0aGUgYm94IHpvb20gZG9lcyBub3QgbWVldCB0aGUgbWluaW11bSBzaXplIHRocmVzaG9sZC5cbiAqXG4gKiBAZXZlbnQgYm94em9vbWNhbmNlbFxuICogQG1lbWJlcm9mIE1hcFxuICogQGluc3RhbmNlXG4gKiBAcHJvcGVydHkge0V2ZW50RGF0YX0gZGF0YSBPcmlnaW5hbCBldmVudCBkYXRhXG4gKi9cbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBEb3VibGVDbGlja1pvb21IYW5kbGVyO1xuXG4vKipcbiAqIFRoZSBgRG91YmxlQ2xpY2tab29tSGFuZGxlcmAgYWxsb3dzIGEgdXNlciB0byB6b29tIHRoZSBtYXAgYXJvdW5kIHBvaW50IGJ5XG4gKiBkb3VibGUgY2xpY2tpbmcuXG4gKiBAY2xhc3MgRG91YmxlQ2xpY2tab29tSGFuZGxlclxuICovXG5mdW5jdGlvbiBEb3VibGVDbGlja1pvb21IYW5kbGVyKG1hcCkge1xuICAgIHRoaXMuX21hcCA9IG1hcDtcbiAgICB0aGlzLl9vbkRibENsaWNrID0gdGhpcy5fb25EYmxDbGljay5iaW5kKHRoaXMpO1xufVxuXG5Eb3VibGVDbGlja1pvb21IYW5kbGVyLnByb3RvdHlwZSA9IHtcblxuICAgIF9lbmFibGVkOiBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGN1cnJlbnQgZW5hYmxlZC9kaXNhYmxlZCBzdGF0ZSBvZiB0aGUgXCJkb3VibGUgY2xpY2sgdG8gem9vbVwiIGludGVyYWN0aW9uLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBlbmFibGVkIHN0YXRlXG4gICAgICovXG4gICAgaXNFbmFibGVkOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9lbmFibGVkO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBFbmFibGUgdGhlIFwiZG91YmxlIGNsaWNrIHRvIHpvb21cIiBpbnRlcmFjdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqICAgbWFwLmRvdWJsZUNsaWNrWm9vbS5lbmFibGUoKTtcbiAgICAgKi9cbiAgICBlbmFibGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNFbmFibGVkKCkpIHJldHVybjtcbiAgICAgICAgdGhpcy5fbWFwLm9uKCdkYmxjbGljaycsIHRoaXMuX29uRGJsQ2xpY2spO1xuICAgICAgICB0aGlzLl9lbmFibGVkID0gdHJ1ZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRGlzYWJsZSB0aGUgXCJkb3VibGUgY2xpY2sgdG8gem9vbVwiIGludGVyYWN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICogICBtYXAuZG91YmxlQ2xpY2tab29tLmRpc2FibGUoKTtcbiAgICAgKi9cbiAgICBkaXNhYmxlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghdGhpcy5pc0VuYWJsZWQoKSkgcmV0dXJuO1xuICAgICAgICB0aGlzLl9tYXAub2ZmKCdkYmxjbGljaycsIHRoaXMuX29uRGJsQ2xpY2spO1xuICAgICAgICB0aGlzLl9lbmFibGVkID0gZmFsc2U7XG4gICAgfSxcblxuICAgIF9vbkRibENsaWNrOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICB0aGlzLl9tYXAuem9vbVRvKHRoaXMuX21hcC5nZXRab29tKCkgK1xuICAgICAgICAgICAgKGUub3JpZ2luYWxFdmVudC5zaGlmdEtleSA/IC0xIDogMSksIHthcm91bmQ6IGUubG5nTGF0fSk7XG4gICAgfVxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIERPTSA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvZG9tJyksXG4gICAgdXRpbCA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvdXRpbCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IERyYWdQYW5IYW5kbGVyO1xuXG52YXIgaW5lcnRpYUxpbmVhcml0eSA9IDAuMyxcbiAgICBpbmVydGlhRWFzaW5nID0gdXRpbC5iZXppZXIoMCwgMCwgaW5lcnRpYUxpbmVhcml0eSwgMSksXG4gICAgaW5lcnRpYU1heFNwZWVkID0gMTQwMCwgLy8gcHgvc1xuICAgIGluZXJ0aWFEZWNlbGVyYXRpb24gPSAyNTAwOyAvLyBweC9zXjJcblxuXG4vKipcbiAqIFRoZSBgRHJhZ1BhbkhhbmRsZXJgIGFsbG93cyBhIHVzZXIgdG8gcGFuIHRoZSBtYXAgYnkgY2xpY2tpbmcgYW5kIGRyYWdnaW5nXG4gKiB0aGUgY3Vyc29yLlxuICogQGNsYXNzIERyYWdQYW5IYW5kbGVyXG4gKi9cbmZ1bmN0aW9uIERyYWdQYW5IYW5kbGVyKG1hcCkge1xuICAgIHRoaXMuX21hcCA9IG1hcDtcbiAgICB0aGlzLl9lbCA9IG1hcC5nZXRDYW52YXNDb250YWluZXIoKTtcblxuICAgIHV0aWwuYmluZEhhbmRsZXJzKHRoaXMpO1xufVxuXG5EcmFnUGFuSGFuZGxlci5wcm90b3R5cGUgPSB7XG5cbiAgICBfZW5hYmxlZDogZmFsc2UsXG4gICAgX2FjdGl2ZTogZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IGVuYWJsZWQvZGlzYWJsZWQgc3RhdGUgb2YgdGhlIFwiZHJhZyB0byBwYW5cIiBpbnRlcmFjdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gZW5hYmxlZCBzdGF0ZVxuICAgICAqL1xuICAgIGlzRW5hYmxlZDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZW5hYmxlZDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBcImRyYWcgdG8gcGFuXCIgaW50ZXJhY3Rpb24gaXMgY3VycmVudGx5IGFjdGl2ZSwgaS5lLiBjdXJyZW50bHkgYmVpbmcgdXNlZC5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gYWN0aXZlIHN0YXRlXG4gICAgICovXG4gICAgaXNBY3RpdmU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FjdGl2ZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRW5hYmxlIHRoZSBcImRyYWcgdG8gcGFuXCIgaW50ZXJhY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAgIG1hcC5kcmFnUGFuLmVuYWJsZSgpO1xuICAgICAqL1xuICAgIGVuYWJsZTogZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5pc0VuYWJsZWQoKSkgcmV0dXJuO1xuICAgICAgICB0aGlzLl9lbC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzLl9vbkRvd24pO1xuICAgICAgICB0aGlzLl9lbC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0JywgdGhpcy5fb25Eb3duKTtcbiAgICAgICAgdGhpcy5fZW5hYmxlZCA9IHRydWU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIERpc2FibGUgdGhlIFwiZHJhZyB0byBwYW5cIiBpbnRlcmFjdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqICAgbWFwLmRyYWdQYW4uZGlzYWJsZSgpO1xuICAgICAqL1xuICAgIGRpc2FibGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzRW5hYmxlZCgpKSByZXR1cm47XG4gICAgICAgIHRoaXMuX2VsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXMuX29uRG93bik7XG4gICAgICAgIHRoaXMuX2VsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCB0aGlzLl9vbkRvd24pO1xuICAgICAgICB0aGlzLl9lbmFibGVkID0gZmFsc2U7XG4gICAgfSxcblxuICAgIF9vbkRvd246IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGlmICh0aGlzLl9pZ25vcmVFdmVudChlKSkgcmV0dXJuO1xuICAgICAgICBpZiAodGhpcy5pc0FjdGl2ZSgpKSByZXR1cm47XG5cbiAgICAgICAgaWYgKGUudG91Y2hlcykge1xuICAgICAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgdGhpcy5fb25Nb3ZlKTtcbiAgICAgICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgdGhpcy5fb25Ub3VjaEVuZCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCB0aGlzLl9vbk1vdmUpO1xuICAgICAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHRoaXMuX29uTW91c2VVcCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9hY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fc3RhcnRQb3MgPSB0aGlzLl9wb3MgPSBET00ubW91c2VQb3ModGhpcy5fZWwsIGUpO1xuICAgICAgICB0aGlzLl9pbmVydGlhID0gW1tEYXRlLm5vdygpLCB0aGlzLl9wb3NdXTtcbiAgICB9LFxuXG4gICAgX29uTW92ZTogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgaWYgKHRoaXMuX2lnbm9yZUV2ZW50KGUpKSByZXR1cm47XG5cbiAgICAgICAgaWYgKCF0aGlzLmlzQWN0aXZlKCkpIHtcbiAgICAgICAgICAgIHRoaXMuX2FjdGl2ZSA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLl9maXJlRXZlbnQoJ2RyYWdzdGFydCcsIGUpO1xuICAgICAgICAgICAgdGhpcy5fZmlyZUV2ZW50KCdtb3Zlc3RhcnQnLCBlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBwb3MgPSBET00ubW91c2VQb3ModGhpcy5fZWwsIGUpLFxuICAgICAgICAgICAgbWFwID0gdGhpcy5fbWFwO1xuXG4gICAgICAgIG1hcC5zdG9wKCk7XG4gICAgICAgIHRoaXMuX2RyYWluSW5lcnRpYUJ1ZmZlcigpO1xuICAgICAgICB0aGlzLl9pbmVydGlhLnB1c2goW0RhdGUubm93KCksIHBvc10pO1xuXG4gICAgICAgIG1hcC50cmFuc2Zvcm0uc2V0TG9jYXRpb25BdFBvaW50KG1hcC50cmFuc2Zvcm0ucG9pbnRMb2NhdGlvbih0aGlzLl9wb3MpLCBwb3MpO1xuXG4gICAgICAgIHRoaXMuX2ZpcmVFdmVudCgnZHJhZycsIGUpO1xuICAgICAgICB0aGlzLl9maXJlRXZlbnQoJ21vdmUnLCBlKTtcblxuICAgICAgICB0aGlzLl9wb3MgPSBwb3M7XG5cbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH0sXG5cbiAgICBfb25VcDogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzQWN0aXZlKCkpIHJldHVybjtcblxuICAgICAgICB0aGlzLl9hY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fZmlyZUV2ZW50KCdkcmFnZW5kJywgZSk7XG4gICAgICAgIHRoaXMuX2RyYWluSW5lcnRpYUJ1ZmZlcigpO1xuXG4gICAgICAgIHZhciBmaW5pc2ggPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHRoaXMuX2ZpcmVFdmVudCgnbW92ZWVuZCcsIGUpO1xuICAgICAgICB9LmJpbmQodGhpcyk7XG5cbiAgICAgICAgdmFyIGluZXJ0aWEgPSB0aGlzLl9pbmVydGlhO1xuICAgICAgICBpZiAoaW5lcnRpYS5sZW5ndGggPCAyKSB7XG4gICAgICAgICAgICBmaW5pc2goKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBsYXN0ID0gaW5lcnRpYVtpbmVydGlhLmxlbmd0aCAtIDFdLFxuICAgICAgICAgICAgZmlyc3QgPSBpbmVydGlhWzBdLFxuICAgICAgICAgICAgZmxpbmdPZmZzZXQgPSBsYXN0WzFdLnN1YihmaXJzdFsxXSksXG4gICAgICAgICAgICBmbGluZ0R1cmF0aW9uID0gKGxhc3RbMF0gLSBmaXJzdFswXSkgLyAxMDAwO1xuXG4gICAgICAgIGlmIChmbGluZ0R1cmF0aW9uID09PSAwIHx8IGxhc3RbMV0uZXF1YWxzKGZpcnN0WzFdKSkge1xuICAgICAgICAgICAgZmluaXNoKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjYWxjdWxhdGUgcHgvcyB2ZWxvY2l0eSAmIGFkanVzdCBmb3IgaW5jcmVhc2VkIGluaXRpYWwgYW5pbWF0aW9uIHNwZWVkIHdoZW4gZWFzaW5nIG91dFxuICAgICAgICB2YXIgdmVsb2NpdHkgPSBmbGluZ09mZnNldC5tdWx0KGluZXJ0aWFMaW5lYXJpdHkgLyBmbGluZ0R1cmF0aW9uKSxcbiAgICAgICAgICAgIHNwZWVkID0gdmVsb2NpdHkubWFnKCk7IC8vIHB4L3NcblxuICAgICAgICBpZiAoc3BlZWQgPiBpbmVydGlhTWF4U3BlZWQpIHtcbiAgICAgICAgICAgIHNwZWVkID0gaW5lcnRpYU1heFNwZWVkO1xuICAgICAgICAgICAgdmVsb2NpdHkuX3VuaXQoKS5fbXVsdChzcGVlZCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZHVyYXRpb24gPSBzcGVlZCAvIChpbmVydGlhRGVjZWxlcmF0aW9uICogaW5lcnRpYUxpbmVhcml0eSksXG4gICAgICAgICAgICBvZmZzZXQgPSB2ZWxvY2l0eS5tdWx0KC1kdXJhdGlvbiAvIDIpO1xuXG4gICAgICAgIHRoaXMuX21hcC5wYW5CeShvZmZzZXQsIHtcbiAgICAgICAgICAgIGR1cmF0aW9uOiBkdXJhdGlvbiAqIDEwMDAsXG4gICAgICAgICAgICBlYXNpbmc6IGluZXJ0aWFFYXNpbmcsXG4gICAgICAgICAgICBub01vdmVTdGFydDogdHJ1ZVxuICAgICAgICB9LCB7IG9yaWdpbmFsRXZlbnQ6IGUgfSk7XG4gICAgfSxcblxuICAgIF9vbk1vdXNlVXA6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGlmICh0aGlzLl9pZ25vcmVFdmVudChlKSkgcmV0dXJuO1xuICAgICAgICB0aGlzLl9vblVwKGUpO1xuICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCB0aGlzLl9vbk1vdmUpO1xuICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgdGhpcy5fb25Nb3VzZVVwKTtcbiAgICB9LFxuXG4gICAgX29uVG91Y2hFbmQ6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGlmICh0aGlzLl9pZ25vcmVFdmVudChlKSkgcmV0dXJuO1xuICAgICAgICB0aGlzLl9vblVwKGUpO1xuICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCB0aGlzLl9vbk1vdmUpO1xuICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIHRoaXMuX29uVG91Y2hFbmQpO1xuICAgIH0sXG5cbiAgICBfZmlyZUV2ZW50OiBmdW5jdGlvbiAodHlwZSwgZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbWFwLmZpcmUodHlwZSwgeyBvcmlnaW5hbEV2ZW50OiBlIH0pO1xuICAgIH0sXG5cbiAgICBfaWdub3JlRXZlbnQ6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHZhciBtYXAgPSB0aGlzLl9tYXA7XG5cbiAgICAgICAgaWYgKG1hcC5ib3hab29tICYmIG1hcC5ib3hab29tLmlzQWN0aXZlKCkpIHJldHVybiB0cnVlO1xuICAgICAgICBpZiAobWFwLmRyYWdSb3RhdGUgJiYgbWFwLmRyYWdSb3RhdGUuaXNBY3RpdmUoKSkgcmV0dXJuIHRydWU7XG4gICAgICAgIGlmIChlLnRvdWNoZXMpIHtcbiAgICAgICAgICAgIHJldHVybiAoZS50b3VjaGVzLmxlbmd0aCA+IDEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKGUuY3RybEtleSkgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB2YXIgYnV0dG9ucyA9IDEsICAvLyBsZWZ0IGJ1dHRvblxuICAgICAgICAgICAgICAgIGJ1dHRvbiA9IDA7ICAgLy8gbGVmdCBidXR0b25cbiAgICAgICAgICAgIHJldHVybiAoZS50eXBlID09PSAnbW91c2Vtb3ZlJyA/IGUuYnV0dG9ucyAmIGJ1dHRvbnMgPT09IDAgOiBlLmJ1dHRvbiAhPT0gYnV0dG9uKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBfZHJhaW5JbmVydGlhQnVmZmVyOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBpbmVydGlhID0gdGhpcy5faW5lcnRpYSxcbiAgICAgICAgICAgIG5vdyA9IERhdGUubm93KCksXG4gICAgICAgICAgICBjdXRvZmYgPSAxNjA7ICAgLy8gbXNlY1xuXG4gICAgICAgIHdoaWxlIChpbmVydGlhLmxlbmd0aCA+IDAgJiYgbm93IC0gaW5lcnRpYVswXVswXSA+IGN1dG9mZikgaW5lcnRpYS5zaGlmdCgpO1xuICAgIH1cbn07XG5cblxuLyoqXG4gKiBEcmFnIHN0YXJ0IGV2ZW50LiBUaGlzIGV2ZW50IGlzIGVtaXR0ZWQgYXQgdGhlIHN0YXJ0IG9mIGEgdXNlci1pbml0aWF0ZWQgcGFuIGludGVyYWN0aW9uLlxuICpcbiAqIEBldmVudCBkcmFnc3RhcnRcbiAqIEBtZW1iZXJvZiBNYXBcbiAqIEBpbnN0YW5jZVxuICogQHByb3BlcnR5IHtFdmVudERhdGF9IGRhdGEgT3JpZ2luYWwgZXZlbnQgZGF0YVxuICovXG5cbi8qKlxuICogRHJhZyBldmVudC4gVGhpcyBldmVudCBpcyBlbWl0dGVkIHJlcGVhdGVkbHkgZHVyaW5nIGEgdXNlci1pbml0aWF0ZWQgcGFuIGludGVyYWN0aW9uLlxuICpcbiAqIEBldmVudCBkcmFnXG4gKiBAbWVtYmVyb2YgTWFwXG4gKiBAaW5zdGFuY2VcbiAqIEBwcm9wZXJ0eSB7RXZlbnREYXRhfSBkYXRhIE9yaWdpbmFsIGV2ZW50IGRhdGFcbiAqL1xuXG4vKipcbiAqIERyYWcgZW5kIGV2ZW50LiBUaGlzIGV2ZW50IGlzIGVtaXR0ZWQgYXQgdGhlIGVuZCBvZiBhIHVzZXItaW5pdGlhdGVkIHBhbiBpbnRlcmFjdGlvbi5cbiAqXG4gKiBAZXZlbnQgZHJhZ2VuZFxuICogQG1lbWJlcm9mIE1hcFxuICogQGluc3RhbmNlXG4gKiBAcHJvcGVydHkge0V2ZW50RGF0YX0gZGF0YSBPcmlnaW5hbCBldmVudCBkYXRhXG4gKi9cbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIERPTSA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvZG9tJyksXG4gICAgUG9pbnQgPSByZXF1aXJlKCdwb2ludC1nZW9tZXRyeScpLFxuICAgIHV0aWwgPSByZXF1aXJlKCcuLi8uLi91dGlsL3V0aWwnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBEcmFnUm90YXRlSGFuZGxlcjtcblxudmFyIGluZXJ0aWFMaW5lYXJpdHkgPSAwLjI1LFxuICAgIGluZXJ0aWFFYXNpbmcgPSB1dGlsLmJlemllcigwLCAwLCBpbmVydGlhTGluZWFyaXR5LCAxKSxcbiAgICBpbmVydGlhTWF4U3BlZWQgPSAxODAsIC8vIGRlZy9zXG4gICAgaW5lcnRpYURlY2VsZXJhdGlvbiA9IDcyMDsgLy8gZGVnL3NeMlxuXG5cbi8qKlxuICogVGhlIGBEcmFnUm90YXRlSGFuZGxlcmAgYWxsb3dzIGEgdXNlciB0byByb3RhdGUgdGhlIG1hcCBieSBjbGlja2luZyBhbmRcbiAqIGRyYWdnaW5nIHRoZSBjdXJzb3Igd2hpbGUgaG9sZGluZyB0aGUgcmlnaHQgbW91c2UgYnV0dG9uIG9yIHRoZSBgY3RybGAga2V5LlxuICogQGNsYXNzIERyYWdSb3RhdGVIYW5kbGVyXG4gKi9cbmZ1bmN0aW9uIERyYWdSb3RhdGVIYW5kbGVyKG1hcCkge1xuICAgIHRoaXMuX21hcCA9IG1hcDtcbiAgICB0aGlzLl9lbCA9IG1hcC5nZXRDYW52YXNDb250YWluZXIoKTtcblxuICAgIHV0aWwuYmluZEhhbmRsZXJzKHRoaXMpO1xufVxuXG5EcmFnUm90YXRlSGFuZGxlci5wcm90b3R5cGUgPSB7XG5cbiAgICBfZW5hYmxlZDogZmFsc2UsXG4gICAgX2FjdGl2ZTogZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IGVuYWJsZWQvZGlzYWJsZWQgc3RhdGUgb2YgdGhlIFwiZHJhZyB0byByb3RhdGVcIiBpbnRlcmFjdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gZW5hYmxlZCBzdGF0ZVxuICAgICAqL1xuICAgIGlzRW5hYmxlZDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZW5hYmxlZDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBcImRyYWcgdG8gcm90YXRlXCIgaW50ZXJhY3Rpb24gaXMgY3VycmVudGx5IGFjdGl2ZSwgaS5lLiBjdXJyZW50bHkgYmVpbmcgdXNlZC5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gYWN0aXZlIHN0YXRlXG4gICAgICovXG4gICAgaXNBY3RpdmU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FjdGl2ZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRW5hYmxlIHRoZSBcImRyYWcgdG8gcm90YXRlXCIgaW50ZXJhY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAgIG1hcC5kcmFnUm90YXRlLmVuYWJsZSgpO1xuICAgICAqL1xuICAgIGVuYWJsZTogZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5pc0VuYWJsZWQoKSkgcmV0dXJuO1xuICAgICAgICB0aGlzLl9lbC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzLl9vbkRvd24pO1xuICAgICAgICB0aGlzLl9lbmFibGVkID0gdHJ1ZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRGlzYWJsZSB0aGUgXCJkcmFnIHRvIHJvdGF0ZVwiIGludGVyYWN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICogICBtYXAuZHJhZ1JvdGF0ZS5kaXNhYmxlKCk7XG4gICAgICovXG4gICAgZGlzYWJsZTogZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXRoaXMuaXNFbmFibGVkKCkpIHJldHVybjtcbiAgICAgICAgdGhpcy5fZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdGhpcy5fb25Eb3duKTtcbiAgICAgICAgdGhpcy5fZW5hYmxlZCA9IGZhbHNlO1xuICAgIH0sXG5cbiAgICBfb25Eb3duOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICBpZiAodGhpcy5faWdub3JlRXZlbnQoZSkpIHJldHVybjtcbiAgICAgICAgaWYgKHRoaXMuaXNBY3RpdmUoKSkgcmV0dXJuO1xuXG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHRoaXMuX29uTW92ZSk7XG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aGlzLl9vblVwKTtcblxuICAgICAgICB0aGlzLl9hY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5faW5lcnRpYSA9IFtbRGF0ZS5ub3coKSwgdGhpcy5fbWFwLmdldEJlYXJpbmcoKV1dO1xuICAgICAgICB0aGlzLl9zdGFydFBvcyA9IHRoaXMuX3BvcyA9IERPTS5tb3VzZVBvcyh0aGlzLl9lbCwgZSk7XG4gICAgICAgIHRoaXMuX2NlbnRlciA9IHRoaXMuX21hcC50cmFuc2Zvcm0uY2VudGVyUG9pbnQ7ICAvLyBDZW50ZXIgb2Ygcm90YXRpb25cblxuICAgICAgICAvLyBJZiB0aGUgZmlyc3QgY2xpY2sgd2FzIHRvbyBjbG9zZSB0byB0aGUgY2VudGVyLCBtb3ZlIHRoZSBjZW50ZXIgb2Ygcm90YXRpb24gYnkgMjAwIHBpeGVsc1xuICAgICAgICAvLyBpbiB0aGUgZGlyZWN0aW9uIG9mIHRoZSBjbGljay5cbiAgICAgICAgdmFyIHN0YXJ0VG9DZW50ZXIgPSB0aGlzLl9zdGFydFBvcy5zdWIodGhpcy5fY2VudGVyKSxcbiAgICAgICAgICAgIHN0YXJ0VG9DZW50ZXJEaXN0ID0gc3RhcnRUb0NlbnRlci5tYWcoKTtcblxuICAgICAgICBpZiAoc3RhcnRUb0NlbnRlckRpc3QgPCAyMDApIHtcbiAgICAgICAgICAgIHRoaXMuX2NlbnRlciA9IHRoaXMuX3N0YXJ0UG9zLmFkZChuZXcgUG9pbnQoLTIwMCwgMCkuX3JvdGF0ZShzdGFydFRvQ2VudGVyLmFuZ2xlKCkpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICB9LFxuXG4gICAgX29uTW92ZTogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgaWYgKHRoaXMuX2lnbm9yZUV2ZW50KGUpKSByZXR1cm47XG5cbiAgICAgICAgaWYgKCF0aGlzLmlzQWN0aXZlKCkpIHtcbiAgICAgICAgICAgIHRoaXMuX2FjdGl2ZSA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLl9maXJlRXZlbnQoJ3JvdGF0ZXN0YXJ0JywgZSk7XG4gICAgICAgICAgICB0aGlzLl9maXJlRXZlbnQoJ21vdmVzdGFydCcsIGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG1hcCA9IHRoaXMuX21hcDtcbiAgICAgICAgbWFwLnN0b3AoKTtcblxuICAgICAgICB2YXIgcDEgPSB0aGlzLl9wb3MsXG4gICAgICAgICAgICBwMiA9IERPTS5tb3VzZVBvcyh0aGlzLl9lbCwgZSksXG4gICAgICAgICAgICBjZW50ZXIgPSB0aGlzLl9jZW50ZXIsXG4gICAgICAgICAgICBiZWFyaW5nRGlmZiA9IHAxLnN1YihjZW50ZXIpLmFuZ2xlV2l0aChwMi5zdWIoY2VudGVyKSkgLyBNYXRoLlBJICogMTgwLFxuICAgICAgICAgICAgYmVhcmluZyA9IG1hcC5nZXRCZWFyaW5nKCkgLSBiZWFyaW5nRGlmZixcbiAgICAgICAgICAgIGluZXJ0aWEgPSB0aGlzLl9pbmVydGlhLFxuICAgICAgICAgICAgbGFzdCA9IGluZXJ0aWFbaW5lcnRpYS5sZW5ndGggLSAxXTtcblxuICAgICAgICB0aGlzLl9kcmFpbkluZXJ0aWFCdWZmZXIoKTtcbiAgICAgICAgaW5lcnRpYS5wdXNoKFtEYXRlLm5vdygpLCBtYXAuX25vcm1hbGl6ZUJlYXJpbmcoYmVhcmluZywgbGFzdFsxXSldKTtcblxuICAgICAgICBtYXAudHJhbnNmb3JtLmJlYXJpbmcgPSBiZWFyaW5nO1xuXG4gICAgICAgIHRoaXMuX2ZpcmVFdmVudCgncm90YXRlJywgZSk7XG4gICAgICAgIHRoaXMuX2ZpcmVFdmVudCgnbW92ZScsIGUpO1xuXG4gICAgICAgIHRoaXMuX3BvcyA9IHAyO1xuICAgIH0sXG5cbiAgICBfb25VcDogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgaWYgKHRoaXMuX2lnbm9yZUV2ZW50KGUpKSByZXR1cm47XG4gICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHRoaXMuX29uTW92ZSk7XG4gICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aGlzLl9vblVwKTtcblxuICAgICAgICBpZiAoIXRoaXMuaXNBY3RpdmUoKSkgcmV0dXJuO1xuXG4gICAgICAgIHRoaXMuX2FjdGl2ZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9maXJlRXZlbnQoJ3JvdGF0ZWVuZCcsIGUpO1xuICAgICAgICB0aGlzLl9kcmFpbkluZXJ0aWFCdWZmZXIoKTtcblxuICAgICAgICB2YXIgbWFwID0gdGhpcy5fbWFwLFxuICAgICAgICAgICAgbWFwQmVhcmluZyA9IG1hcC5nZXRCZWFyaW5nKCksXG4gICAgICAgICAgICBpbmVydGlhID0gdGhpcy5faW5lcnRpYTtcblxuICAgICAgICB2YXIgZmluaXNoID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAoTWF0aC5hYnMobWFwQmVhcmluZykgPCBtYXAub3B0aW9ucy5iZWFyaW5nU25hcCkge1xuICAgICAgICAgICAgICAgIG1hcC5yZXNldE5vcnRoKHtub01vdmVTdGFydDogdHJ1ZX0sIHsgb3JpZ2luYWxFdmVudDogZSB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZmlyZUV2ZW50KCdtb3ZlZW5kJywgZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0uYmluZCh0aGlzKTtcblxuICAgICAgICBpZiAoaW5lcnRpYS5sZW5ndGggPCAyKSB7XG4gICAgICAgICAgICBmaW5pc2goKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBmaXJzdCA9IGluZXJ0aWFbMF0sXG4gICAgICAgICAgICBsYXN0ID0gaW5lcnRpYVtpbmVydGlhLmxlbmd0aCAtIDFdLFxuICAgICAgICAgICAgcHJldmlvdXMgPSBpbmVydGlhW2luZXJ0aWEubGVuZ3RoIC0gMl0sXG4gICAgICAgICAgICBiZWFyaW5nID0gbWFwLl9ub3JtYWxpemVCZWFyaW5nKG1hcEJlYXJpbmcsIHByZXZpb3VzWzFdKSxcbiAgICAgICAgICAgIGZsaW5nRGlmZiA9IGxhc3RbMV0gLSBmaXJzdFsxXSxcbiAgICAgICAgICAgIHNpZ24gPSBmbGluZ0RpZmYgPCAwID8gLTEgOiAxLFxuICAgICAgICAgICAgZmxpbmdEdXJhdGlvbiA9IChsYXN0WzBdIC0gZmlyc3RbMF0pIC8gMTAwMDtcblxuICAgICAgICBpZiAoZmxpbmdEaWZmID09PSAwIHx8IGZsaW5nRHVyYXRpb24gPT09IDApIHtcbiAgICAgICAgICAgIGZpbmlzaCgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHNwZWVkID0gTWF0aC5hYnMoZmxpbmdEaWZmICogKGluZXJ0aWFMaW5lYXJpdHkgLyBmbGluZ0R1cmF0aW9uKSk7ICAvLyBkZWcvc1xuICAgICAgICBpZiAoc3BlZWQgPiBpbmVydGlhTWF4U3BlZWQpIHtcbiAgICAgICAgICAgIHNwZWVkID0gaW5lcnRpYU1heFNwZWVkO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGR1cmF0aW9uID0gc3BlZWQgLyAoaW5lcnRpYURlY2VsZXJhdGlvbiAqIGluZXJ0aWFMaW5lYXJpdHkpLFxuICAgICAgICAgICAgb2Zmc2V0ID0gc2lnbiAqIHNwZWVkICogKGR1cmF0aW9uIC8gMik7XG5cbiAgICAgICAgYmVhcmluZyArPSBvZmZzZXQ7XG5cbiAgICAgICAgaWYgKE1hdGguYWJzKG1hcC5fbm9ybWFsaXplQmVhcmluZyhiZWFyaW5nLCAwKSkgPCBtYXAub3B0aW9ucy5iZWFyaW5nU25hcCkge1xuICAgICAgICAgICAgYmVhcmluZyA9IG1hcC5fbm9ybWFsaXplQmVhcmluZygwLCBiZWFyaW5nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIG1hcC5yb3RhdGVUbyhiZWFyaW5nLCB7XG4gICAgICAgICAgICBkdXJhdGlvbjogZHVyYXRpb24gKiAxMDAwLFxuICAgICAgICAgICAgZWFzaW5nOiBpbmVydGlhRWFzaW5nLFxuICAgICAgICAgICAgbm9Nb3ZlU3RhcnQ6IHRydWVcbiAgICAgICAgfSwgeyBvcmlnaW5hbEV2ZW50OiBlIH0pO1xuICAgIH0sXG5cbiAgICBfZmlyZUV2ZW50OiBmdW5jdGlvbiAodHlwZSwgZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbWFwLmZpcmUodHlwZSwgeyBvcmlnaW5hbEV2ZW50OiBlIH0pO1xuICAgIH0sXG5cbiAgICBfaWdub3JlRXZlbnQ6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHZhciBtYXAgPSB0aGlzLl9tYXA7XG5cbiAgICAgICAgaWYgKG1hcC5ib3hab29tICYmIG1hcC5ib3hab29tLmlzQWN0aXZlKCkpIHJldHVybiB0cnVlO1xuICAgICAgICBpZiAobWFwLmRyYWdQYW4gJiYgbWFwLmRyYWdQYW4uaXNBY3RpdmUoKSkgcmV0dXJuIHRydWU7XG4gICAgICAgIGlmIChlLnRvdWNoZXMpIHtcbiAgICAgICAgICAgIHJldHVybiAoZS50b3VjaGVzLmxlbmd0aCA+IDEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIGJ1dHRvbnMgPSAoZS5jdHJsS2V5ID8gMSA6IDIpLCAgLy8gPyBjdHJsK2xlZnQgYnV0dG9uIDogcmlnaHQgYnV0dG9uXG4gICAgICAgICAgICAgICAgYnV0dG9uID0gKGUuY3RybEtleSA/IDAgOiAyKTsgICAvLyA/IGN0cmwrbGVmdCBidXR0b24gOiByaWdodCBidXR0b25cbiAgICAgICAgICAgIHJldHVybiAoZS50eXBlID09PSAnbW91c2Vtb3ZlJyA/IGUuYnV0dG9ucyAmIGJ1dHRvbnMgPT09IDAgOiBlLmJ1dHRvbiAhPT0gYnV0dG9uKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBfZHJhaW5JbmVydGlhQnVmZmVyOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBpbmVydGlhID0gdGhpcy5faW5lcnRpYSxcbiAgICAgICAgICAgIG5vdyA9IERhdGUubm93KCksXG4gICAgICAgICAgICBjdXRvZmYgPSAxNjA7ICAgLy9tc2VjXG5cbiAgICAgICAgd2hpbGUgKGluZXJ0aWEubGVuZ3RoID4gMCAmJiBub3cgLSBpbmVydGlhWzBdWzBdID4gY3V0b2ZmKVxuICAgICAgICAgICAgaW5lcnRpYS5zaGlmdCgpO1xuICAgIH1cblxufTtcblxuXG4vKipcbiAqIFJvdGF0ZSBzdGFydCBldmVudC4gVGhpcyBldmVudCBpcyBlbWl0dGVkIGF0IHRoZSBzdGFydCBvZiBhIHVzZXItaW5pdGlhdGVkIHJvdGF0ZSBpbnRlcmFjdGlvbi5cbiAqXG4gKiBAZXZlbnQgcm90YXRlc3RhcnRcbiAqIEBtZW1iZXJvZiBNYXBcbiAqIEBpbnN0YW5jZVxuICogQHByb3BlcnR5IHtFdmVudERhdGF9IGRhdGEgT3JpZ2luYWwgZXZlbnQgZGF0YVxuICovXG5cbi8qKlxuICogUm90YXRlIGV2ZW50LiBUaGlzIGV2ZW50IGlzIGVtaXR0ZWQgcmVwZWF0ZWRseSBkdXJpbmcgYSB1c2VyLWluaXRpYXRlZCByb3RhdGUgaW50ZXJhY3Rpb24uXG4gKlxuICogQGV2ZW50IHJvdGF0ZVxuICogQG1lbWJlcm9mIE1hcFxuICogQGluc3RhbmNlXG4gKiBAcHJvcGVydHkge0V2ZW50RGF0YX0gZGF0YSBPcmlnaW5hbCBldmVudCBkYXRhXG4gKi9cblxuLyoqXG4gKiBSb3RhdGUgZW5kIGV2ZW50LiBUaGlzIGV2ZW50IGlzIGVtaXR0ZWQgYXQgdGhlIGVuZCBvZiBhIHVzZXItaW5pdGlhdGVkIHJvdGF0ZSBpbnRlcmFjdGlvbi5cbiAqXG4gKiBAZXZlbnQgcm90YXRlZW5kXG4gKiBAbWVtYmVyb2YgTWFwXG4gKiBAaW5zdGFuY2VcbiAqIEBwcm9wZXJ0eSB7RXZlbnREYXRhfSBkYXRhIE9yaWdpbmFsIGV2ZW50IGRhdGFcbiAqL1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEtleWJvYXJkSGFuZGxlcjtcblxuXG52YXIgcGFuRGVsdGEgPSA4MCxcbiAgICByb3RhdGVEZWx0YSA9IDIsXG4gICAgcGl0Y2hEZWx0YSA9IDU7XG5cbi8qKlxuICogVGhlIGBLZXlib2FyZEhhbmRsZXJgIGFsbG93cyBhIHVzZXIgdG8gem9vbSwgcm90YXRlLCBhbmQgcGFuIHRoZSBtYXAgdXNpbmdcbiAqIGZvbGxvd2luZyBrZXlib2FyZCBzaG9ydGN1dHM6XG4gKiAgKiBgPWAgLyBgK2A6IGluY3JlYXNlIHpvb20gbGV2ZWwgYnkgMVxuICogICogYFNoaWZ0LT1gIC8gYFNoaWZ0LStgOiBpbmNyZWFzZSB6b29tIGxldmVsIGJ5IDJcbiAqICAqIGAtYDogZGVjcmVhc2Ugem9vbSBsZXZlbCBieSAxXG4gKiAgKiBgU2hpZnQtLWA6IGRlY3JlYXNlIHpvb20gbGV2ZWwgYnkgMlxuICogICogQXJyb3cga2V5czogcGFuIGJ5IDgwIHBpeGVsc1xuICogICogYFNoaWZ0K+KHomA6IGluY3JlYXNlIHJvdGF0aW9uIGJ5IDIgZGVncmVlc1xuICogICogYFNoaWZ0K+KHoGA6IGRlY3JlYXNlIHJvdGF0aW9uIGJ5IDIgZGVncmVlc1xuICogICogYFNoaWZ0K+KHoWA6IGluY3JlYXNlIHBpdGNoIGJ5IDUgZGVncmVlc1xuICogICogYFNoaWZ0K+KHo2A6IGRlY3JlYXNlIHBpdGNoIGJ5IDUgZGVncmVlc1xuICogQGNsYXNzIEtleWJvYXJkSGFuZGxlclxuICovXG5mdW5jdGlvbiBLZXlib2FyZEhhbmRsZXIobWFwKSB7XG4gICAgdGhpcy5fbWFwID0gbWFwO1xuICAgIHRoaXMuX2VsID0gbWFwLmdldENhbnZhc0NvbnRhaW5lcigpO1xuXG4gICAgdGhpcy5fb25LZXlEb3duID0gdGhpcy5fb25LZXlEb3duLmJpbmQodGhpcyk7XG59XG5cbktleWJvYXJkSGFuZGxlci5wcm90b3R5cGUgPSB7XG5cbiAgICBfZW5hYmxlZDogZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IGVuYWJsZWQvZGlzYWJsZWQgc3RhdGUgb2Yga2V5Ym9hcmQgaW50ZXJhY3Rpb24uXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IGVuYWJsZWQgc3RhdGVcbiAgICAgKi9cbiAgICBpc0VuYWJsZWQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2VuYWJsZWQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEVuYWJsZSB0aGUgYWJpbGl0eSB0byBpbnRlcmFjdCB3aXRoIHRoZSBtYXAgdXNpbmcga2V5Ym9hcmQgaW5wdXQuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAgIG1hcC5rZXlib2FyZC5lbmFibGUoKTtcbiAgICAgKi9cbiAgICBlbmFibGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNFbmFibGVkKCkpIHJldHVybjtcbiAgICAgICAgdGhpcy5fZWwuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIHRoaXMuX29uS2V5RG93biwgZmFsc2UpO1xuICAgICAgICB0aGlzLl9lbmFibGVkID0gdHJ1ZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRGlzYWJsZSB0aGUgYWJpbGl0eSB0byBpbnRlcmFjdCB3aXRoIHRoZSBtYXAgdXNpbmcga2V5Ym9hcmQgaW5wdXQuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAgIG1hcC5rZXlib2FyZC5kaXNhYmxlKCk7XG4gICAgICovXG4gICAgZGlzYWJsZTogZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXRoaXMuaXNFbmFibGVkKCkpIHJldHVybjtcbiAgICAgICAgdGhpcy5fZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIHRoaXMuX29uS2V5RG93bik7XG4gICAgICAgIHRoaXMuX2VuYWJsZWQgPSBmYWxzZTtcbiAgICB9LFxuXG4gICAgX29uS2V5RG93bjogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgaWYgKGUuYWx0S2V5IHx8IGUuY3RybEtleSB8fCBlLm1ldGFLZXkpIHJldHVybjtcblxuICAgICAgICB2YXIgbWFwID0gdGhpcy5fbWFwLFxuICAgICAgICAgICAgZXZlbnREYXRhID0geyBvcmlnaW5hbEV2ZW50OiBlIH07XG5cbiAgICAgICAgc3dpdGNoIChlLmtleUNvZGUpIHtcbiAgICAgICAgY2FzZSA2MTpcbiAgICAgICAgY2FzZSAxMDc6XG4gICAgICAgIGNhc2UgMTcxOlxuICAgICAgICBjYXNlIDE4NzpcbiAgICAgICAgICAgIG1hcC56b29tVG8oTWF0aC5yb3VuZChtYXAuZ2V0Wm9vbSgpKSArIChlLnNoaWZ0S2V5ID8gMiA6IDEpLCBldmVudERhdGEpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAxODk6XG4gICAgICAgIGNhc2UgMTA5OlxuICAgICAgICBjYXNlIDE3MzpcbiAgICAgICAgICAgIG1hcC56b29tVG8oTWF0aC5yb3VuZChtYXAuZ2V0Wm9vbSgpKSAtIChlLnNoaWZ0S2V5ID8gMiA6IDEpLCBldmVudERhdGEpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAzNzpcbiAgICAgICAgICAgIGlmIChlLnNoaWZ0S2V5KSB7XG4gICAgICAgICAgICAgICAgbWFwLmVhc2VUbyh7IGJlYXJpbmc6IG1hcC5nZXRCZWFyaW5nKCkgLSByb3RhdGVEZWx0YSB9LCBldmVudERhdGEpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgbWFwLnBhbkJ5KFstcGFuRGVsdGEsIDBdLCBldmVudERhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAzOTpcbiAgICAgICAgICAgIGlmIChlLnNoaWZ0S2V5KSB7XG4gICAgICAgICAgICAgICAgbWFwLmVhc2VUbyh7IGJlYXJpbmc6IG1hcC5nZXRCZWFyaW5nKCkgKyByb3RhdGVEZWx0YSB9LCBldmVudERhdGEpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgbWFwLnBhbkJ5KFtwYW5EZWx0YSwgMF0sIGV2ZW50RGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIDM4OlxuICAgICAgICAgICAgaWYgKGUuc2hpZnRLZXkpIHtcbiAgICAgICAgICAgICAgICBtYXAuZWFzZVRvKHsgcGl0Y2g6IG1hcC5nZXRQaXRjaCgpICsgcGl0Y2hEZWx0YSB9LCBldmVudERhdGEpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgbWFwLnBhbkJ5KFswLCAtcGFuRGVsdGFdLCBldmVudERhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSA0MDpcbiAgICAgICAgICAgIGlmIChlLnNoaWZ0S2V5KSB7XG4gICAgICAgICAgICAgICAgbWFwLmVhc2VUbyh7IHBpdGNoOiBNYXRoLm1heChtYXAuZ2V0UGl0Y2goKSAtIHBpdGNoRGVsdGEsIDApIH0sIGV2ZW50RGF0YSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICBtYXAucGFuQnkoWzAsIHBhbkRlbHRhXSwgZXZlbnREYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIERPTSA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvZG9tJyksXG4gICAgYnJvd3NlciA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvYnJvd3NlcicpLFxuICAgIHV0aWwgPSByZXF1aXJlKCcuLi8uLi91dGlsL3V0aWwnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBTY3JvbGxab29tSGFuZGxlcjtcblxuXG52YXIgdWEgPSB0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyA/IG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKSA6ICcnLFxuICAgIGZpcmVmb3ggPSB1YS5pbmRleE9mKCdmaXJlZm94JykgIT09IC0xLFxuICAgIHNhZmFyaSA9IHVhLmluZGV4T2YoJ3NhZmFyaScpICE9PSAtMSAmJiB1YS5pbmRleE9mKCdjaHJvbScpID09PSAtMTtcblxuXG4vKipcbiAqIFRoZSBgU2Nyb2xsWm9vbUhhbmRsZXJgIGFsbG93cyBhIHVzZXIgdG8gem9vbSB0aGUgbWFwIGJ5IHNjcm9sbGluZy5cbiAqIEBjbGFzcyBTY3JvbGxab29tSGFuZGxlclxuICovXG5mdW5jdGlvbiBTY3JvbGxab29tSGFuZGxlcihtYXApIHtcbiAgICB0aGlzLl9tYXAgPSBtYXA7XG4gICAgdGhpcy5fZWwgPSBtYXAuZ2V0Q2FudmFzQ29udGFpbmVyKCk7XG5cbiAgICB1dGlsLmJpbmRIYW5kbGVycyh0aGlzKTtcbn1cblxuU2Nyb2xsWm9vbUhhbmRsZXIucHJvdG90eXBlID0ge1xuXG4gICAgX2VuYWJsZWQ6IGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgY3VycmVudCBlbmFibGVkL2Rpc2FibGVkIHN0YXRlIG9mIHRoZSBcInNjcm9sbCB0byB6b29tXCIgaW50ZXJhY3Rpb24uXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IGVuYWJsZWQgc3RhdGVcbiAgICAgKi9cbiAgICBpc0VuYWJsZWQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2VuYWJsZWQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEVuYWJsZSB0aGUgXCJzY3JvbGwgdG8gem9vbVwiIGludGVyYWN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICogICBtYXAuc2Nyb2xsWm9vbS5lbmFibGUoKTtcbiAgICAgKi9cbiAgICBlbmFibGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNFbmFibGVkKCkpIHJldHVybjtcbiAgICAgICAgdGhpcy5fZWwuYWRkRXZlbnRMaXN0ZW5lcignd2hlZWwnLCB0aGlzLl9vbldoZWVsLCBmYWxzZSk7XG4gICAgICAgIHRoaXMuX2VsLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNld2hlZWwnLCB0aGlzLl9vbldoZWVsLCBmYWxzZSk7XG4gICAgICAgIHRoaXMuX2VuYWJsZWQgPSB0cnVlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBEaXNhYmxlIHRoZSBcInNjcm9sbCB0byB6b29tXCIgaW50ZXJhY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAgIG1hcC5zY3JvbGxab29tLmRpc2FibGUoKTtcbiAgICAgKi9cbiAgICBkaXNhYmxlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghdGhpcy5pc0VuYWJsZWQoKSkgcmV0dXJuO1xuICAgICAgICB0aGlzLl9lbC5yZW1vdmVFdmVudExpc3RlbmVyKCd3aGVlbCcsIHRoaXMuX29uV2hlZWwpO1xuICAgICAgICB0aGlzLl9lbC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZXdoZWVsJywgdGhpcy5fb25XaGVlbCk7XG4gICAgICAgIHRoaXMuX2VuYWJsZWQgPSBmYWxzZTtcbiAgICB9LFxuXG4gICAgX29uV2hlZWw6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHZhciB2YWx1ZTtcblxuICAgICAgICBpZiAoZS50eXBlID09PSAnd2hlZWwnKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IGUuZGVsdGFZO1xuICAgICAgICAgICAgLy8gRmlyZWZveCBkb3VibGVzIHRoZSB2YWx1ZXMgb24gcmV0aW5hIHNjcmVlbnMuLi5cbiAgICAgICAgICAgIGlmIChmaXJlZm94ICYmIGUuZGVsdGFNb2RlID09PSB3aW5kb3cuV2hlZWxFdmVudC5ET01fREVMVEFfUElYRUwpIHZhbHVlIC89IGJyb3dzZXIuZGV2aWNlUGl4ZWxSYXRpbztcbiAgICAgICAgICAgIGlmIChlLmRlbHRhTW9kZSA9PT0gd2luZG93LldoZWVsRXZlbnQuRE9NX0RFTFRBX0xJTkUpIHZhbHVlICo9IDQwO1xuXG4gICAgICAgIH0gZWxzZSBpZiAoZS50eXBlID09PSAnbW91c2V3aGVlbCcpIHtcbiAgICAgICAgICAgIHZhbHVlID0gLWUud2hlZWxEZWx0YVk7XG4gICAgICAgICAgICBpZiAoc2FmYXJpKSB2YWx1ZSA9IHZhbHVlIC8gMztcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBub3cgPSBicm93c2VyLm5vdygpLFxuICAgICAgICAgICAgdGltZURlbHRhID0gbm93IC0gKHRoaXMuX3RpbWUgfHwgMCk7XG5cbiAgICAgICAgdGhpcy5fcG9zID0gRE9NLm1vdXNlUG9zKHRoaXMuX2VsLCBlKTtcbiAgICAgICAgdGhpcy5fdGltZSA9IG5vdztcblxuICAgICAgICBpZiAodmFsdWUgIT09IDAgJiYgKHZhbHVlICUgNC4wMDAyNDQxNDA2MjUpID09PSAwKSB7XG4gICAgICAgICAgICAvLyBUaGlzIG9uZSBpcyBkZWZpbml0ZWx5IGEgbW91c2Ugd2hlZWwgZXZlbnQuXG4gICAgICAgICAgICB0aGlzLl90eXBlID0gJ3doZWVsJztcbiAgICAgICAgICAgIC8vIE5vcm1hbGl6ZSB0aGlzIHZhbHVlIHRvIG1hdGNoIHRyYWNrcGFkLlxuICAgICAgICAgICAgdmFsdWUgPSBNYXRoLmZsb29yKHZhbHVlIC8gNCk7XG5cbiAgICAgICAgfSBlbHNlIGlmICh2YWx1ZSAhPT0gMCAmJiBNYXRoLmFicyh2YWx1ZSkgPCA0KSB7XG4gICAgICAgICAgICAvLyBUaGlzIG9uZSBpcyBkZWZpbml0ZWx5IGEgdHJhY2twYWQgZXZlbnQgYmVjYXVzZSBpdCBpcyBzbyBzbWFsbC5cbiAgICAgICAgICAgIHRoaXMuX3R5cGUgPSAndHJhY2twYWQnO1xuXG4gICAgICAgIH0gZWxzZSBpZiAodGltZURlbHRhID4gNDAwKSB7XG4gICAgICAgICAgICAvLyBUaGlzIGlzIGxpa2VseSBhIG5ldyBzY3JvbGwgYWN0aW9uLlxuICAgICAgICAgICAgdGhpcy5fdHlwZSA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLl9sYXN0VmFsdWUgPSB2YWx1ZTtcblxuICAgICAgICAgICAgLy8gU3RhcnQgYSB0aW1lb3V0IGluIGNhc2UgdGhpcyB3YXMgYSBzaW5ndWxhciBldmVudCwgYW5kIGRlbHkgaXQgYnkgdXAgdG8gNDBtcy5cbiAgICAgICAgICAgIHRoaXMuX3RpbWVvdXQgPSBzZXRUaW1lb3V0KHRoaXMuX29uVGltZW91dCwgNDApO1xuXG4gICAgICAgIH0gZWxzZSBpZiAoIXRoaXMuX3R5cGUpIHtcbiAgICAgICAgICAgIC8vIFRoaXMgaXMgYSByZXBlYXRpbmcgZXZlbnQsIGJ1dCB3ZSBkb24ndCBrbm93IHRoZSB0eXBlIG9mIGV2ZW50IGp1c3QgeWV0LlxuICAgICAgICAgICAgLy8gSWYgdGhlIGRlbHRhIHBlciB0aW1lIGlzIHNtYWxsLCB3ZSBhc3N1bWUgaXQncyBhIGZhc3QgdHJhY2twYWQ7IG90aGVyd2lzZSB3ZSBzd2l0Y2ggaW50byB3aGVlbCBtb2RlLlxuICAgICAgICAgICAgdGhpcy5fdHlwZSA9IChNYXRoLmFicyh0aW1lRGVsdGEgKiB2YWx1ZSkgPCAyMDApID8gJ3RyYWNrcGFkJyA6ICd3aGVlbCc7XG5cbiAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSBvdXIgZGVsYXllZCBldmVudCBpc24ndCBmaXJlZCBhZ2FpbiwgYmVjYXVzZSB3ZSBhY2N1bXVsYXRlXG4gICAgICAgICAgICAvLyB0aGUgcHJldmlvdXMgZXZlbnQgKHdoaWNoIHdhcyBsZXNzIHRoYW4gNDBtcyBhZ28pIGludG8gdGhpcyBldmVudC5cbiAgICAgICAgICAgIGlmICh0aGlzLl90aW1lb3V0KSB7XG4gICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX3RpbWVvdXQpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3RpbWVvdXQgPSBudWxsO1xuICAgICAgICAgICAgICAgIHZhbHVlICs9IHRoaXMuX2xhc3RWYWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFNsb3cgZG93biB6b29tIGlmIHNoaWZ0IGtleSBpcyBoZWxkIGZvciBtb3JlIHByZWNpc2Ugem9vbWluZ1xuICAgICAgICBpZiAoZS5zaGlmdEtleSAmJiB2YWx1ZSkgdmFsdWUgPSB2YWx1ZSAvIDQ7XG5cbiAgICAgICAgLy8gT25seSBmaXJlIHRoZSBjYWxsYmFjayBpZiB3ZSBhY3R1YWxseSBrbm93IHdoYXQgdHlwZSBvZiBzY3JvbGxpbmcgZGV2aWNlIHRoZSB1c2VyIHVzZXMuXG4gICAgICAgIGlmICh0aGlzLl90eXBlKSB0aGlzLl96b29tKC12YWx1ZSwgZSk7XG5cbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH0sXG5cbiAgICBfb25UaW1lb3V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX3R5cGUgPSAnd2hlZWwnO1xuICAgICAgICB0aGlzLl96b29tKC10aGlzLl9sYXN0VmFsdWUpO1xuICAgIH0sXG5cbiAgICBfem9vbTogZnVuY3Rpb24gKGRlbHRhLCBlKSB7XG4gICAgICAgIGlmIChkZWx0YSA9PT0gMCkgcmV0dXJuO1xuICAgICAgICB2YXIgbWFwID0gdGhpcy5fbWFwO1xuXG4gICAgICAgIC8vIFNjYWxlIGJ5IHNpZ21vaWQgb2Ygc2Nyb2xsIHdoZWVsIGRlbHRhLlxuICAgICAgICB2YXIgc2NhbGUgPSAyIC8gKDEgKyBNYXRoLmV4cCgtTWF0aC5hYnMoZGVsdGEgLyAxMDApKSk7XG4gICAgICAgIGlmIChkZWx0YSA8IDAgJiYgc2NhbGUgIT09IDApIHNjYWxlID0gMSAvIHNjYWxlO1xuXG4gICAgICAgIHZhciBmcm9tU2NhbGUgPSBtYXAuZWFzZSA/IG1hcC5lYXNlLnRvIDogbWFwLnRyYW5zZm9ybS5zY2FsZSxcbiAgICAgICAgICAgIHRhcmdldFpvb20gPSBtYXAudHJhbnNmb3JtLnNjYWxlWm9vbShmcm9tU2NhbGUgKiBzY2FsZSk7XG5cbiAgICAgICAgbWFwLnpvb21Ubyh0YXJnZXRab29tLCB7XG4gICAgICAgICAgICBkdXJhdGlvbjogMCxcbiAgICAgICAgICAgIGFyb3VuZDogbWFwLnVucHJvamVjdCh0aGlzLl9wb3MpLFxuICAgICAgICAgICAgZGVsYXlFbmRFdmVudHM6IDIwMFxuICAgICAgICB9LCB7IG9yaWdpbmFsRXZlbnQ6IGUgfSk7XG4gICAgfVxufTtcblxuXG4vKipcbiAqIFpvb20gc3RhcnQgZXZlbnQuIFRoaXMgZXZlbnQgaXMgZW1pdHRlZCBqdXN0IGJlZm9yZSB0aGUgbWFwIGJlZ2lucyBhIHRyYW5zaXRpb24gZnJvbSBvbmVcbiAqIHpvb20gbGV2ZWwgdG8gYW5vdGhlciwgZWl0aGVyIGFzIGEgcmVzdWx0IG9mIHVzZXIgaW50ZXJhY3Rpb24gb3IgdGhlIHVzZSBvZiBtZXRob2RzIHN1Y2ggYXMgYE1hcCNqdW1wVG9gLlxuICpcbiAqIEBldmVudCB6b29tc3RhcnRcbiAqIEBtZW1iZXJvZiBNYXBcbiAqIEBpbnN0YW5jZVxuICogQHByb3BlcnR5IHtFdmVudERhdGF9IGRhdGEgT3JpZ2luYWwgZXZlbnQgZGF0YSwgaWYgZmlyZWQgaW50ZXJhY3RpdmVseVxuICovXG5cbi8qKlxuICogWm9vbSBldmVudC4gVGhpcyBldmVudCBpcyBlbWl0dGVkIHJlcGVhdGVkbHkgZHVyaW5nIGFuaW1hdGVkIHRyYW5zaXRpb25zIGZyb20gb25lIHpvb20gbGV2ZWwgdG9cbiAqIGFub3RoZXIsIGVpdGhlciBhcyBhIHJlc3VsdCBvZiB1c2VyIGludGVyYWN0aW9uIG9yIHRoZSB1c2Ugb2YgbWV0aG9kcyBzdWNoIGFzIGBNYXAjanVtcFRvYC5cbiAqXG4gKiBAZXZlbnQgem9vbVxuICogQG1lbWJlcm9mIE1hcFxuICogQGluc3RhbmNlXG4gKiBAcHJvcGVydHkge0V2ZW50RGF0YX0gZGF0YSBPcmlnaW5hbCBldmVudCBkYXRhLCBpZiBmaXJlZCBpbnRlcmFjdGl2ZWx5XG4gKi9cblxuLyoqXG4gKiBab29tIGVuZCBldmVudC4gVGhpcyBldmVudCBpcyBlbWl0dGVkIGp1c3QgYWZ0ZXIgdGhlIG1hcCBjb21wbGV0ZXMgYSB0cmFuc2l0aW9uIGZyb20gb25lXG4gKiB6b29tIGxldmVsIHRvIGFub3RoZXIsIGVpdGhlciBhcyBhIHJlc3VsdCBvZiB1c2VyIGludGVyYWN0aW9uIG9yIHRoZSB1c2Ugb2YgbWV0aG9kcyBzdWNoIGFzIGBNYXAjanVtcFRvYC5cbiAqXG4gKiBAZXZlbnQgem9vbWVuZFxuICogQG1lbWJlcm9mIE1hcFxuICogQGluc3RhbmNlXG4gKiBAcHJvcGVydHkge0V2ZW50RGF0YX0gZGF0YSBPcmlnaW5hbCBldmVudCBkYXRhLCBpZiBmaXJlZCBpbnRlcmFjdGl2ZWx5XG4gKi9cbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIERPTSA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvZG9tJyksXG4gICAgdXRpbCA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvdXRpbCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFRvdWNoWm9vbVJvdGF0ZUhhbmRsZXI7XG5cbnZhciBpbmVydGlhTGluZWFyaXR5ID0gMC4xNSxcbiAgICBpbmVydGlhRWFzaW5nID0gdXRpbC5iZXppZXIoMCwgMCwgaW5lcnRpYUxpbmVhcml0eSwgMSksXG4gICAgaW5lcnRpYURlY2VsZXJhdGlvbiA9IDEyLCAvLyBzY2FsZSAvIHNeMlxuICAgIGluZXJ0aWFNYXhTcGVlZCA9IDIuNSwgLy8gc2NhbGUgLyBzXG4gICAgc2lnbmlmaWNhbnRTY2FsZVRocmVzaG9sZCA9IDAuMTUsXG4gICAgc2lnbmlmaWNhbnRSb3RhdGVUaHJlc2hvbGQgPSA0O1xuXG5cbi8qKlxuICogVGhlIGBUb3VjaFpvb21Sb3RhdGVIYW5kbGVyYCBhbGxvd3MgYSB1c2VyIHRvIHpvb20gYW5kIHJvdGF0ZSB0aGUgbWFwIGJ5XG4gKiBwaW5jaGluZyBvbiBhIHRvdWNoc2NyZWVuLlxuICogQGNsYXNzIFRvdWNoWm9vbVJvdGF0ZUhhbmRsZXJcbiAqL1xuZnVuY3Rpb24gVG91Y2hab29tUm90YXRlSGFuZGxlcihtYXApIHtcbiAgICB0aGlzLl9tYXAgPSBtYXA7XG4gICAgdGhpcy5fZWwgPSBtYXAuZ2V0Q2FudmFzQ29udGFpbmVyKCk7XG5cbiAgICB1dGlsLmJpbmRIYW5kbGVycyh0aGlzKTtcbn1cblxuVG91Y2hab29tUm90YXRlSGFuZGxlci5wcm90b3R5cGUgPSB7XG5cbiAgICBfZW5hYmxlZDogZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IGVuYWJsZWQvZGlzYWJsZWQgc3RhdGUgb2YgdGhlIFwicGluY2ggdG8gcm90YXRlIGFuZCB6b29tXCIgaW50ZXJhY3Rpb24uXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IGVuYWJsZWQgc3RhdGVcbiAgICAgKi9cbiAgICBpc0VuYWJsZWQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2VuYWJsZWQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEVuYWJsZSB0aGUgXCJwaW5jaCB0byByb3RhdGUgYW5kIHpvb21cIiBpbnRlcmFjdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqICAgbWFwLnRvdWNoWm9vbVJvdGF0ZS5lbmFibGUoKTtcbiAgICAgKi9cbiAgICBlbmFibGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNFbmFibGVkKCkpIHJldHVybjtcbiAgICAgICAgdGhpcy5fZWwuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIHRoaXMuX29uU3RhcnQsIGZhbHNlKTtcbiAgICAgICAgdGhpcy5fZW5hYmxlZCA9IHRydWU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIERpc2FibGUgdGhlIFwicGluY2ggdG8gcm90YXRlIGFuZCB6b29tXCIgaW50ZXJhY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAgIG1hcC50b3VjaFpvb21Sb3RhdGUuZGlzYWJsZSgpO1xuICAgICAqL1xuICAgIGRpc2FibGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzRW5hYmxlZCgpKSByZXR1cm47XG4gICAgICAgIHRoaXMuX2VsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCB0aGlzLl9vblN0YXJ0KTtcbiAgICAgICAgdGhpcy5fZW5hYmxlZCA9IGZhbHNlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBEaXNhYmxlIHRoZSBcInBpbmNoIHRvIHJvdGF0ZVwiIGludGVyYWN0aW9uLCBsZWF2aW5nIHRoZSBcInBpbmNoIHRvIHpvb21cIlxuICAgICAqIGludGVyYWN0aW9uIGVuYWJsZWQuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAgIG1hcC50b3VjaFpvb21Sb3RhdGUuZGlzYWJsZVJvdGF0aW9uKCk7XG4gICAgICovXG4gICAgZGlzYWJsZVJvdGF0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5fcm90YXRpb25EaXNhYmxlZCA9IHRydWU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEVuYWJsZSB0aGUgXCJwaW5jaCB0byByb3RhdGVcIiBpbnRlcmFjdGlvbiwgdW5kb2luZyBhIGNhbGwgdG9cbiAgICAgKiBgZGlzYWJsZVJvdGF0aW9uYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqICAgbWFwLnRvdWNoWm9vbVJvdGF0ZS5lbmFibGUoKTtcbiAgICAgKiAgIG1hcC50b3VjaFpvb21Sb3RhdGUuZW5hYmxlUm90YXRpb24oKTtcbiAgICAgKi9cbiAgICBlbmFibGVSb3RhdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuX3JvdGF0aW9uRGlzYWJsZWQgPSBmYWxzZTtcbiAgICB9LFxuXG4gICAgX29uU3RhcnQ6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGlmIChlLnRvdWNoZXMubGVuZ3RoICE9PSAyKSByZXR1cm47XG5cbiAgICAgICAgdmFyIHAwID0gRE9NLm1vdXNlUG9zKHRoaXMuX2VsLCBlLnRvdWNoZXNbMF0pLFxuICAgICAgICAgICAgcDEgPSBET00ubW91c2VQb3ModGhpcy5fZWwsIGUudG91Y2hlc1sxXSk7XG5cbiAgICAgICAgdGhpcy5fc3RhcnRWZWMgPSBwMC5zdWIocDEpO1xuICAgICAgICB0aGlzLl9zdGFydFNjYWxlID0gdGhpcy5fbWFwLnRyYW5zZm9ybS5zY2FsZTtcbiAgICAgICAgdGhpcy5fc3RhcnRCZWFyaW5nID0gdGhpcy5fbWFwLnRyYW5zZm9ybS5iZWFyaW5nO1xuICAgICAgICB0aGlzLl9nZXN0dXJlSW50ZW50ID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLl9pbmVydGlhID0gW107XG5cbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgdGhpcy5fb25Nb3ZlLCBmYWxzZSk7XG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgdGhpcy5fb25FbmQsIGZhbHNlKTtcbiAgICB9LFxuXG4gICAgX29uTW92ZTogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgaWYgKGUudG91Y2hlcy5sZW5ndGggIT09IDIpIHJldHVybjtcblxuICAgICAgICB2YXIgcDAgPSBET00ubW91c2VQb3ModGhpcy5fZWwsIGUudG91Y2hlc1swXSksXG4gICAgICAgICAgICBwMSA9IERPTS5tb3VzZVBvcyh0aGlzLl9lbCwgZS50b3VjaGVzWzFdKSxcbiAgICAgICAgICAgIHAgPSBwMC5hZGQocDEpLmRpdigyKSxcbiAgICAgICAgICAgIHZlYyA9IHAwLnN1YihwMSksXG4gICAgICAgICAgICBzY2FsZSA9IHZlYy5tYWcoKSAvIHRoaXMuX3N0YXJ0VmVjLm1hZygpLFxuICAgICAgICAgICAgYmVhcmluZyA9IHRoaXMuX3JvdGF0aW9uRGlzYWJsZWQgPyAwIDogdmVjLmFuZ2xlV2l0aCh0aGlzLl9zdGFydFZlYykgKiAxODAgLyBNYXRoLlBJLFxuICAgICAgICAgICAgbWFwID0gdGhpcy5fbWFwO1xuXG4gICAgICAgIC8vIERldGVybWluZSAnaW50ZW50JyBieSB3aGljaGV2ZXIgdGhyZXNob2xkIGlzIHN1cnBhc3NlZCBmaXJzdCxcbiAgICAgICAgLy8gdGhlbiBrZWVwIHRoYXQgc3RhdGUgZm9yIHRoZSBkdXJhdGlvbiBvZiB0aGlzIGdlc3R1cmUuXG4gICAgICAgIGlmICghdGhpcy5fZ2VzdHVyZUludGVudCkge1xuICAgICAgICAgICAgdmFyIHNjYWxpbmdTaWduaWZpY2FudGx5ID0gKE1hdGguYWJzKDEgLSBzY2FsZSkgPiBzaWduaWZpY2FudFNjYWxlVGhyZXNob2xkKSxcbiAgICAgICAgICAgICAgICByb3RhdGluZ1NpZ25pZmljYW50bHkgPSAoTWF0aC5hYnMoYmVhcmluZykgPiBzaWduaWZpY2FudFJvdGF0ZVRocmVzaG9sZCk7XG5cbiAgICAgICAgICAgIGlmIChyb3RhdGluZ1NpZ25pZmljYW50bHkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9nZXN0dXJlSW50ZW50ID0gJ3JvdGF0ZSc7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHNjYWxpbmdTaWduaWZpY2FudGx5KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZ2VzdHVyZUludGVudCA9ICd6b29tJztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRoaXMuX2dlc3R1cmVJbnRlbnQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zdGFydFZlYyA9IHZlYztcbiAgICAgICAgICAgICAgICB0aGlzLl9zdGFydFNjYWxlID0gbWFwLnRyYW5zZm9ybS5zY2FsZTtcbiAgICAgICAgICAgICAgICB0aGlzLl9zdGFydEJlYXJpbmcgPSBtYXAudHJhbnNmb3JtLmJlYXJpbmc7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBwYXJhbSA9IHsgZHVyYXRpb246IDAsIGFyb3VuZDogbWFwLnVucHJvamVjdChwKSB9O1xuXG4gICAgICAgICAgICBpZiAodGhpcy5fZ2VzdHVyZUludGVudCA9PT0gJ3JvdGF0ZScpIHtcbiAgICAgICAgICAgICAgICBwYXJhbS5iZWFyaW5nID0gdGhpcy5fc3RhcnRCZWFyaW5nICsgYmVhcmluZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLl9nZXN0dXJlSW50ZW50ID09PSAnem9vbScgfHwgdGhpcy5fZ2VzdHVyZUludGVudCA9PT0gJ3JvdGF0ZScpIHtcbiAgICAgICAgICAgICAgICBwYXJhbS56b29tID0gbWFwLnRyYW5zZm9ybS5zY2FsZVpvb20odGhpcy5fc3RhcnRTY2FsZSAqIHNjYWxlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbWFwLnN0b3AoKTtcbiAgICAgICAgICAgIHRoaXMuX2RyYWluSW5lcnRpYUJ1ZmZlcigpO1xuICAgICAgICAgICAgdGhpcy5faW5lcnRpYS5wdXNoKFtEYXRlLm5vdygpLCBzY2FsZSwgcF0pO1xuXG4gICAgICAgICAgICBtYXAuZWFzZVRvKHBhcmFtLCB7IG9yaWdpbmFsRXZlbnQ6IGUgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgfSxcblxuICAgIF9vbkVuZDogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgdGhpcy5fb25Nb3ZlKTtcbiAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCB0aGlzLl9vbkVuZCk7XG4gICAgICAgIHRoaXMuX2RyYWluSW5lcnRpYUJ1ZmZlcigpO1xuXG4gICAgICAgIHZhciBpbmVydGlhID0gdGhpcy5faW5lcnRpYSxcbiAgICAgICAgICAgIG1hcCA9IHRoaXMuX21hcDtcblxuICAgICAgICBpZiAoaW5lcnRpYS5sZW5ndGggPCAyKSB7XG4gICAgICAgICAgICBtYXAuc25hcFRvTm9ydGgoe30sIHsgb3JpZ2luYWxFdmVudDogZSB9KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBsYXN0ID0gaW5lcnRpYVtpbmVydGlhLmxlbmd0aCAtIDFdLFxuICAgICAgICAgICAgZmlyc3QgPSBpbmVydGlhWzBdLFxuICAgICAgICAgICAgbGFzdFNjYWxlID0gbWFwLnRyYW5zZm9ybS5zY2FsZVpvb20odGhpcy5fc3RhcnRTY2FsZSAqIGxhc3RbMV0pLFxuICAgICAgICAgICAgZmlyc3RTY2FsZSA9IG1hcC50cmFuc2Zvcm0uc2NhbGVab29tKHRoaXMuX3N0YXJ0U2NhbGUgKiBmaXJzdFsxXSksXG4gICAgICAgICAgICBzY2FsZU9mZnNldCA9IGxhc3RTY2FsZSAtIGZpcnN0U2NhbGUsXG4gICAgICAgICAgICBzY2FsZUR1cmF0aW9uID0gKGxhc3RbMF0gLSBmaXJzdFswXSkgLyAxMDAwLFxuICAgICAgICAgICAgcCA9IGxhc3RbMl07XG5cbiAgICAgICAgaWYgKHNjYWxlRHVyYXRpb24gPT09IDAgfHwgbGFzdFNjYWxlID09PSBmaXJzdFNjYWxlKSB7XG4gICAgICAgICAgICBtYXAuc25hcFRvTm9ydGgoe30sIHsgb3JpZ2luYWxFdmVudDogZSB9KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNhbGN1bGF0ZSBzY2FsZS9zIHNwZWVkIGFuZCBhZGp1c3QgZm9yIGluY3JlYXNlZCBpbml0aWFsIGFuaW1hdGlvbiBzcGVlZCB3aGVuIGVhc2luZ1xuICAgICAgICB2YXIgc3BlZWQgPSBzY2FsZU9mZnNldCAqIGluZXJ0aWFMaW5lYXJpdHkgLyBzY2FsZUR1cmF0aW9uOyAvLyBzY2FsZS9zXG5cbiAgICAgICAgaWYgKE1hdGguYWJzKHNwZWVkKSA+IGluZXJ0aWFNYXhTcGVlZCkge1xuICAgICAgICAgICAgaWYgKHNwZWVkID4gMCkge1xuICAgICAgICAgICAgICAgIHNwZWVkID0gaW5lcnRpYU1heFNwZWVkO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzcGVlZCA9IC1pbmVydGlhTWF4U3BlZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZHVyYXRpb24gPSBNYXRoLmFicyhzcGVlZCAvIChpbmVydGlhRGVjZWxlcmF0aW9uICogaW5lcnRpYUxpbmVhcml0eSkpICogMTAwMCxcbiAgICAgICAgICAgIHRhcmdldFNjYWxlID0gbGFzdFNjYWxlICsgc3BlZWQgKiBkdXJhdGlvbiAvIDIwMDA7XG5cbiAgICAgICAgaWYgKHRhcmdldFNjYWxlIDwgMCkge1xuICAgICAgICAgICAgdGFyZ2V0U2NhbGUgPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgbWFwLmVhc2VUbyh7XG4gICAgICAgICAgICB6b29tOiB0YXJnZXRTY2FsZSxcbiAgICAgICAgICAgIGR1cmF0aW9uOiBkdXJhdGlvbixcbiAgICAgICAgICAgIGVhc2luZzogaW5lcnRpYUVhc2luZyxcbiAgICAgICAgICAgIGFyb3VuZDogbWFwLnVucHJvamVjdChwKVxuICAgICAgICB9LCB7IG9yaWdpbmFsRXZlbnQ6IGUgfSk7XG4gICAgfSxcblxuICAgIF9kcmFpbkluZXJ0aWFCdWZmZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgaW5lcnRpYSA9IHRoaXMuX2luZXJ0aWEsXG4gICAgICAgICAgICBub3cgPSBEYXRlLm5vdygpLFxuICAgICAgICAgICAgY3V0b2ZmID0gMTYwOyAvLyBtc2VjXG5cbiAgICAgICAgd2hpbGUgKGluZXJ0aWEubGVuZ3RoID4gMiAmJiBub3cgLSBpbmVydGlhWzBdWzBdID4gY3V0b2ZmKSBpbmVydGlhLnNoaWZ0KCk7XG4gICAgfVxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLypcbiAqIEFkZHMgcG9zaXRpb25hbCBjb29yZGluYXRlcyB0byBVUkwgaGFzaGVzLiBQYXNzZWQgYXMgYW4gb3B0aW9uIHRvIHRoZSBtYXAgb2JqZWN0XG4gKlxuICogQGNsYXNzIG1hcGJveGdsLkhhc2hcbiAqIEByZXR1cm5zIHtIYXNofSBgdGhpc2BcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBIYXNoO1xuXG52YXIgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwvdXRpbCcpO1xuXG5mdW5jdGlvbiBIYXNoKCkge1xuICAgIHV0aWwuYmluZEFsbChbXG4gICAgICAgICdfb25IYXNoQ2hhbmdlJyxcbiAgICAgICAgJ191cGRhdGVIYXNoJ1xuICAgIF0sIHRoaXMpO1xufVxuXG5IYXNoLnByb3RvdHlwZSA9IHtcbiAgICAvKiBNYXAgZWxlbWVudCB0byBsaXN0ZW4gZm9yIGNvb3JkaW5hdGUgY2hhbmdlc1xuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG1hcFxuICAgICAqIEByZXR1cm5zIHtIYXNofSBgdGhpc2BcbiAgICAgKi9cbiAgICBhZGRUbzogZnVuY3Rpb24obWFwKSB7XG4gICAgICAgIHRoaXMuX21hcCA9IG1hcDtcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2hhc2hjaGFuZ2UnLCB0aGlzLl9vbkhhc2hDaGFuZ2UsIGZhbHNlKTtcbiAgICAgICAgdGhpcy5fbWFwLm9uKCdtb3ZlZW5kJywgdGhpcy5fdXBkYXRlSGFzaCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKiBSZW1vdmVzIGhhc2hcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtQb3B1cH0gYHRoaXNgXG4gICAgICovXG4gICAgcmVtb3ZlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2hhc2hjaGFuZ2UnLCB0aGlzLl9vbkhhc2hDaGFuZ2UsIGZhbHNlKTtcbiAgICAgICAgdGhpcy5fbWFwLm9mZignbW92ZWVuZCcsIHRoaXMuX3VwZGF0ZUhhc2gpO1xuICAgICAgICBkZWxldGUgdGhpcy5fbWFwO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgX29uSGFzaENoYW5nZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBsb2MgPSBsb2NhdGlvbi5oYXNoLnJlcGxhY2UoJyMnLCAnJykuc3BsaXQoJy8nKTtcbiAgICAgICAgaWYgKGxvYy5sZW5ndGggPj0gMykge1xuICAgICAgICAgICAgdGhpcy5fbWFwLmp1bXBUbyh7XG4gICAgICAgICAgICAgICAgY2VudGVyOiBbK2xvY1syXSwgK2xvY1sxXV0sXG4gICAgICAgICAgICAgICAgem9vbTogK2xvY1swXSxcbiAgICAgICAgICAgICAgICBiZWFyaW5nOiArKGxvY1szXSB8fCAwKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcblxuICAgIF91cGRhdGVIYXNoOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGNlbnRlciA9IHRoaXMuX21hcC5nZXRDZW50ZXIoKSxcbiAgICAgICAgICAgIHpvb20gPSB0aGlzLl9tYXAuZ2V0Wm9vbSgpLFxuICAgICAgICAgICAgYmVhcmluZyA9IHRoaXMuX21hcC5nZXRCZWFyaW5nKCksXG4gICAgICAgICAgICBwcmVjaXNpb24gPSBNYXRoLm1heCgwLCBNYXRoLmNlaWwoTWF0aC5sb2coem9vbSkgLyBNYXRoLkxOMikpLFxuXG4gICAgICAgICAgICBoYXNoID0gJyMnICsgKE1hdGgucm91bmQoem9vbSAqIDEwMCkgLyAxMDApICtcbiAgICAgICAgICAgICAgICAnLycgKyBjZW50ZXIubGF0LnRvRml4ZWQocHJlY2lzaW9uKSArXG4gICAgICAgICAgICAgICAgJy8nICsgY2VudGVyLmxuZy50b0ZpeGVkKHByZWNpc2lvbikgK1xuICAgICAgICAgICAgICAgIChiZWFyaW5nID8gJy8nICsgKE1hdGgucm91bmQoYmVhcmluZyAqIDEwKSAvIDEwKSA6ICcnKTtcblxuICAgICAgICB3aW5kb3cuaGlzdG9yeS5yZXBsYWNlU3RhdGUoJycsICcnLCBoYXNoKTtcbiAgICB9XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaGFuZGxlcnMgPSB7XG4gICAgc2Nyb2xsWm9vbTogcmVxdWlyZSgnLi9oYW5kbGVyL3Njcm9sbF96b29tJyksXG4gICAgYm94Wm9vbTogcmVxdWlyZSgnLi9oYW5kbGVyL2JveF96b29tJyksXG4gICAgZHJhZ1JvdGF0ZTogcmVxdWlyZSgnLi9oYW5kbGVyL2RyYWdfcm90YXRlJyksXG4gICAgZHJhZ1BhbjogcmVxdWlyZSgnLi9oYW5kbGVyL2RyYWdfcGFuJyksXG4gICAga2V5Ym9hcmQ6IHJlcXVpcmUoJy4vaGFuZGxlci9rZXlib2FyZCcpLFxuICAgIGRvdWJsZUNsaWNrWm9vbTogcmVxdWlyZSgnLi9oYW5kbGVyL2RibGNsaWNrX3pvb20nKSxcbiAgICB0b3VjaFpvb21Sb3RhdGU6IHJlcXVpcmUoJy4vaGFuZGxlci90b3VjaF96b29tX3JvdGF0ZScpXG59O1xuXG52YXIgRE9NID0gcmVxdWlyZSgnLi4vdXRpbC9kb20nKSxcbiAgICB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbC91dGlsJyksXG4gICAgUG9pbnQgPSByZXF1aXJlKCdwb2ludC1nZW9tZXRyeScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEludGVyYWN0aW9uO1xuXG5mdW5jdGlvbiBJbnRlcmFjdGlvbihtYXApIHtcbiAgICB0aGlzLl9tYXAgPSBtYXA7XG4gICAgdGhpcy5fZWwgPSBtYXAuZ2V0Q2FudmFzQ29udGFpbmVyKCk7XG5cbiAgICBmb3IgKHZhciBuYW1lIGluIGhhbmRsZXJzKSB7XG4gICAgICAgIG1hcFtuYW1lXSA9IG5ldyBoYW5kbGVyc1tuYW1lXShtYXApO1xuICAgIH1cblxuICAgIHV0aWwuYmluZEhhbmRsZXJzKHRoaXMpO1xufVxuXG5JbnRlcmFjdGlvbi5wcm90b3R5cGUgPSB7XG4gICAgZW5hYmxlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBvcHRpb25zID0gdGhpcy5fbWFwLm9wdGlvbnMsXG4gICAgICAgICAgICBlbCA9IHRoaXMuX2VsO1xuXG4gICAgICAgIGZvciAodmFyIG5hbWUgaW4gaGFuZGxlcnMpIHtcbiAgICAgICAgICAgIGlmIChvcHRpb25zW25hbWVdKSB0aGlzLl9tYXBbbmFtZV0uZW5hYmxlKCk7XG4gICAgICAgIH1cblxuICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzLl9vbk1vdXNlRG93biwgZmFsc2UpO1xuICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgdGhpcy5fb25Nb3VzZVVwLCBmYWxzZSk7XG4gICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHRoaXMuX29uTW91c2VNb3ZlLCBmYWxzZSk7XG4gICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCB0aGlzLl9vblRvdWNoU3RhcnQsIGZhbHNlKTtcbiAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCB0aGlzLl9vblRvdWNoRW5kLCBmYWxzZSk7XG4gICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIHRoaXMuX29uVG91Y2hNb3ZlLCBmYWxzZSk7XG4gICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoY2FuY2VsJywgdGhpcy5fb25Ub3VjaENhbmNlbCwgZmFsc2UpO1xuICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMuX29uQ2xpY2ssIGZhbHNlKTtcbiAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcignZGJsY2xpY2snLCB0aGlzLl9vbkRibENsaWNrLCBmYWxzZSk7XG4gICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoJ2NvbnRleHRtZW51JywgdGhpcy5fb25Db250ZXh0TWVudSwgZmFsc2UpO1xuICAgIH0sXG5cbiAgICBkaXNhYmxlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBvcHRpb25zID0gdGhpcy5fbWFwLm9wdGlvbnMsXG4gICAgICAgICAgICBlbCA9IHRoaXMuX2VsO1xuXG4gICAgICAgIGZvciAodmFyIG5hbWUgaW4gaGFuZGxlcnMpIHtcbiAgICAgICAgICAgIGlmIChvcHRpb25zW25hbWVdKSB0aGlzLl9tYXBbbmFtZV0uZGlzYWJsZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdGhpcy5fb25Nb3VzZURvd24pO1xuICAgICAgICBlbC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgdGhpcy5fb25Nb3VzZVVwKTtcbiAgICAgICAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgdGhpcy5fb25Nb3VzZU1vdmUpO1xuICAgICAgICBlbC5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0JywgdGhpcy5fb25Ub3VjaFN0YXJ0KTtcbiAgICAgICAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCB0aGlzLl9vblRvdWNoRW5kKTtcbiAgICAgICAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgdGhpcy5fb25Ub3VjaE1vdmUpO1xuICAgICAgICBlbC5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaGNhbmNlbCcsIHRoaXMuX29uVG91Y2hDYW5jZWwpO1xuICAgICAgICBlbC5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMuX29uQ2xpY2spO1xuICAgICAgICBlbC5yZW1vdmVFdmVudExpc3RlbmVyKCdkYmxjbGljaycsIHRoaXMuX29uRGJsQ2xpY2spO1xuICAgICAgICBlbC5yZW1vdmVFdmVudExpc3RlbmVyKCdjb250ZXh0bWVudScsIHRoaXMuX29uQ29udGV4dE1lbnUpO1xuICAgIH0sXG5cbiAgICBfb25Nb3VzZURvd246IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHRoaXMuX21hcC5zdG9wKCk7XG4gICAgICAgIHRoaXMuX3N0YXJ0UG9zID0gRE9NLm1vdXNlUG9zKHRoaXMuX2VsLCBlKTtcbiAgICAgICAgdGhpcy5fZmlyZU1vdXNlRXZlbnQoJ21vdXNlZG93bicsIGUpO1xuICAgIH0sXG5cbiAgICBfb25Nb3VzZVVwOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICB2YXIgbWFwID0gdGhpcy5fbWFwLFxuICAgICAgICAgICAgcm90YXRpbmcgPSBtYXAuZHJhZ1JvdGF0ZSAmJiBtYXAuZHJhZ1JvdGF0ZS5pc0FjdGl2ZSgpO1xuXG4gICAgICAgIGlmICh0aGlzLl9jb250ZXh0TWVudUV2ZW50ICYmICFyb3RhdGluZykge1xuICAgICAgICAgICAgdGhpcy5fZmlyZU1vdXNlRXZlbnQoJ2NvbnRleHRtZW51JywgdGhpcy5fY29udGV4dE1lbnVFdmVudCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9jb250ZXh0TWVudUV2ZW50ID0gbnVsbDtcbiAgICAgICAgdGhpcy5fZmlyZU1vdXNlRXZlbnQoJ21vdXNldXAnLCBlKTtcbiAgICB9LFxuXG4gICAgX29uTW91c2VNb3ZlOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICB2YXIgbWFwID0gdGhpcy5fbWFwLFxuICAgICAgICAgICAgZWwgPSB0aGlzLl9lbDtcblxuICAgICAgICBpZiAobWFwLmRyYWdQYW4gJiYgbWFwLmRyYWdQYW4uaXNBY3RpdmUoKSkgcmV0dXJuO1xuICAgICAgICBpZiAobWFwLmRyYWdSb3RhdGUgJiYgbWFwLmRyYWdSb3RhdGUuaXNBY3RpdmUoKSkgcmV0dXJuO1xuXG4gICAgICAgIHZhciB0YXJnZXQgPSBlLnRvRWxlbWVudCB8fCBlLnRhcmdldDtcbiAgICAgICAgd2hpbGUgKHRhcmdldCAmJiB0YXJnZXQgIT09IGVsKSB0YXJnZXQgPSB0YXJnZXQucGFyZW50Tm9kZTtcbiAgICAgICAgaWYgKHRhcmdldCAhPT0gZWwpIHJldHVybjtcblxuICAgICAgICB0aGlzLl9maXJlTW91c2VFdmVudCgnbW91c2Vtb3ZlJywgZSk7XG4gICAgfSxcblxuICAgIF9vblRvdWNoU3RhcnQ6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHRoaXMuX21hcC5zdG9wKCk7XG4gICAgICAgIHRoaXMuX2ZpcmVUb3VjaEV2ZW50KCd0b3VjaHN0YXJ0JywgZSk7XG5cbiAgICAgICAgaWYgKCFlLnRvdWNoZXMgfHwgZS50b3VjaGVzLmxlbmd0aCA+IDEpIHJldHVybjtcblxuICAgICAgICBpZiAoIXRoaXMuX3RhcHBlZCkge1xuICAgICAgICAgICAgdGhpcy5fdGFwcGVkID0gc2V0VGltZW91dCh0aGlzLl9vblRvdWNoVGltZW91dCwgMzAwKTtcblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX3RhcHBlZCk7XG4gICAgICAgICAgICB0aGlzLl90YXBwZWQgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5fZmlyZU1vdXNlRXZlbnQoJ2RibGNsaWNrJywgZSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgX29uVG91Y2hNb3ZlOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICB0aGlzLl9maXJlVG91Y2hFdmVudCgndG91Y2htb3ZlJywgZSk7XG4gICAgfSxcblxuICAgIF9vblRvdWNoRW5kOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICB0aGlzLl9maXJlVG91Y2hFdmVudCgndG91Y2hlbmQnLCBlKTtcbiAgICB9LFxuXG4gICAgX29uVG91Y2hDYW5jZWw6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHRoaXMuX2ZpcmVUb3VjaEV2ZW50KCd0b3VjaGNhbmNlbCcsIGUpO1xuICAgIH0sXG5cbiAgICBfb25Ub3VjaFRpbWVvdXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fdGFwcGVkID0gbnVsbDtcbiAgICB9LFxuXG4gICAgX29uQ2xpY2s6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHZhciBwb3MgPSBET00ubW91c2VQb3ModGhpcy5fZWwsIGUpO1xuXG4gICAgICAgIGlmIChwb3MuZXF1YWxzKHRoaXMuX3N0YXJ0UG9zKSkge1xuICAgICAgICAgICAgdGhpcy5fZmlyZU1vdXNlRXZlbnQoJ2NsaWNrJywgZSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgX29uRGJsQ2xpY2s6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHRoaXMuX2ZpcmVNb3VzZUV2ZW50KCdkYmxjbGljaycsIGUpO1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgfSxcblxuICAgIF9vbkNvbnRleHRNZW51OiBmdW5jdGlvbiAoZSkge1xuICAgICAgICB0aGlzLl9jb250ZXh0TWVudUV2ZW50ID0gZTtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH0sXG5cbiAgICBfZmlyZU1vdXNlRXZlbnQ6IGZ1bmN0aW9uICh0eXBlLCBlKSB7XG4gICAgICAgIHZhciBwb3MgPSBET00ubW91c2VQb3ModGhpcy5fZWwsIGUpO1xuXG4gICAgICAgIHJldHVybiB0aGlzLl9tYXAuZmlyZSh0eXBlLCB7XG4gICAgICAgICAgICBsbmdMYXQ6IHRoaXMuX21hcC51bnByb2plY3QocG9zKSxcbiAgICAgICAgICAgIHBvaW50OiBwb3MsXG4gICAgICAgICAgICBvcmlnaW5hbEV2ZW50OiBlXG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICBfZmlyZVRvdWNoRXZlbnQ6IGZ1bmN0aW9uICh0eXBlLCBlKSB7XG4gICAgICAgIHZhciB0b3VjaGVzID0gRE9NLnRvdWNoUG9zKHRoaXMuX2VsLCBlKSxcbiAgICAgICAgICAgIHNpbmd1bGFyID0gdG91Y2hlcy5yZWR1Y2UoZnVuY3Rpb24gKHByZXYsIGN1cnIsIGksIGFycikge1xuICAgICAgICAgICAgICAgIHJldHVybiBwcmV2LmFkZChjdXJyLmRpdihhcnIubGVuZ3RoKSk7XG4gICAgICAgICAgICB9LCBuZXcgUG9pbnQoMCwgMCkpO1xuXG4gICAgICAgIHJldHVybiB0aGlzLl9tYXAuZmlyZSh0eXBlLCB7XG4gICAgICAgICAgICBsbmdMYXQ6IHRoaXMuX21hcC51bnByb2plY3Qoc2luZ3VsYXIpLFxuICAgICAgICAgICAgcG9pbnQ6IHNpbmd1bGFyLFxuICAgICAgICAgICAgbG5nTGF0czogdG91Y2hlcy5tYXAoZnVuY3Rpb24odCkgeyByZXR1cm4gdGhpcy5fbWFwLnVucHJvamVjdCh0KTsgfSwgdGhpcyksXG4gICAgICAgICAgICBwb2ludHM6IHRvdWNoZXMsXG4gICAgICAgICAgICBvcmlnaW5hbEV2ZW50OiBlXG4gICAgICAgIH0pO1xuICAgIH1cbn07XG5cblxuLyoqXG4gKiBXaGVuIGFuIGV2ZW50IFtmaXJlc117QGxpbmsgI0V2ZW50ZWQuZmlyZX0gYXMgYSByZXN1bHQgb2YgYVxuICogdXNlciBpbnRlcmFjdGlvbiwgdGhlIGV2ZW50IHdpbGwgYmUgY2FsbGVkIHdpdGggYW4gRXZlbnREYXRhXG4gKiBvYmplY3QgY29udGFpbmluZyB0aGUgb3JpZ2luYWwgRE9NIGV2ZW50IGFsb25nIHdpdGggY29vcmRpbmF0ZXMgb2ZcbiAqIHRoZSBldmVudCB0YXJnZXQuXG4gKlxuICogQHR5cGVkZWYge09iamVjdH0gRXZlbnREYXRhXG4gKiBAcHJvcGVydHkge0V2ZW50fSBvcmlnaW5hbEV2ZW50IFRoZSBvcmlnaW5hbCBET00gZXZlbnRcbiAqIEBwcm9wZXJ0eSB7UG9pbnR9IHBvaW50IFRoZSBwaXhlbCBsb2NhdGlvbiBvZiB0aGUgZXZlbnRcbiAqIEBwcm9wZXJ0eSB7TG5nTGF0fSBsbmdMYXQgVGhlIGdlb2dyYXBoaWMgbG9jYXRpb24gb2YgdGhlIGV2ZW50XG4gKiBAZXhhbXBsZVxuICogbWFwLm9uKCdjbGljaycsIGZ1bmN0aW9uKGRhdGEpIHtcbiAqICAgdmFyIGUgPSBkYXRhICYmIGRhdGEub3JpZ2luYWxFdmVudDtcbiAqICAgY29uc29sZS5sb2coJ2dvdCBjbGljayAnICsgKGUgPyAnYnV0dG9uID0gJyArIGUuYnV0dG9uIDogJycpKTtcbiAqIH0pO1xuICovXG5cbi8qKlxuICogTW91c2UgZG93biBldmVudC5cbiAqXG4gKiBAZXZlbnQgbW91c2Vkb3duXG4gKiBAbWVtYmVyb2YgTWFwXG4gKiBAaW5zdGFuY2VcbiAqIEBwcm9wZXJ0eSB7RXZlbnREYXRhfSBkYXRhIE9yaWdpbmFsIGV2ZW50IGRhdGFcbiAqL1xuXG4vKipcbiAqIE1vdXNlIHVwIGV2ZW50LlxuICpcbiAqIEBldmVudCBtb3VzZXVwXG4gKiBAbWVtYmVyb2YgTWFwXG4gKiBAaW5zdGFuY2VcbiAqIEBwcm9wZXJ0eSB7RXZlbnREYXRhfSBkYXRhIE9yaWdpbmFsIGV2ZW50IGRhdGFcbiAqL1xuXG4vKipcbiAqIE1vdXNlIG1vdmUgZXZlbnQuXG4gKlxuICogQGV2ZW50IG1vdXNlbW92ZVxuICogQG1lbWJlcm9mIE1hcFxuICogQGluc3RhbmNlXG4gKiBAcHJvcGVydHkge0V2ZW50RGF0YX0gZGF0YSBPcmlnaW5hbCBldmVudCBkYXRhXG4gKi9cblxuLyoqXG4gKiBUb3VjaCBzdGFydCBldmVudC5cbiAqXG4gKiBAZXZlbnQgdG91Y2hzdGFydFxuICogQG1lbWJlcm9mIE1hcFxuICogQGluc3RhbmNlXG4gKiBAcHJvcGVydHkge0V2ZW50RGF0YX0gZGF0YSBPcmlnaW5hbCBldmVudCBkYXRhXG4gKi9cblxuLyoqXG4gKiBUb3VjaCBlbmQgZXZlbnQuXG4gKlxuICogQGV2ZW50IHRvdWNoZW5kXG4gKiBAbWVtYmVyb2YgTWFwXG4gKiBAaW5zdGFuY2VcbiAqIEBwcm9wZXJ0eSB7RXZlbnREYXRhfSBkYXRhIE9yaWdpbmFsIGV2ZW50IGRhdGFcbiAqL1xuXG4vKipcbiAqIFRvdWNoIG1vdmUgZXZlbnQuXG4gKlxuICogQGV2ZW50IHRvdWNobW92ZVxuICogQG1lbWJlcm9mIE1hcFxuICogQGluc3RhbmNlXG4gKiBAcHJvcGVydHkge0V2ZW50RGF0YX0gZGF0YSBPcmlnaW5hbCBldmVudCBkYXRhXG4gKi9cblxuLyoqXG4gKiBUb3VjaCBjYW5jZWwgZXZlbnQuXG4gKlxuICogQGV2ZW50IHRvdWNoY2FuY2VsXG4gKiBAbWVtYmVyb2YgTWFwXG4gKiBAaW5zdGFuY2VcbiAqIEBwcm9wZXJ0eSB7RXZlbnREYXRhfSBkYXRhIE9yaWdpbmFsIGV2ZW50IGRhdGFcbiAqL1xuXG4vKipcbiAqIENsaWNrIGV2ZW50LlxuICpcbiAqIEBldmVudCBjbGlja1xuICogQG1lbWJlcm9mIE1hcFxuICogQGluc3RhbmNlXG4gKiBAcHJvcGVydHkge0V2ZW50RGF0YX0gZGF0YSBPcmlnaW5hbCBldmVudCBkYXRhXG4gKi9cblxuLyoqXG4gKiBEb3VibGUgY2xpY2sgZXZlbnQuXG4gKlxuICogQGV2ZW50IGRibGNsaWNrXG4gKiBAbWVtYmVyb2YgTWFwXG4gKiBAaW5zdGFuY2VcbiAqIEBwcm9wZXJ0eSB7RXZlbnREYXRhfSBkYXRhIE9yaWdpbmFsIGV2ZW50IGRhdGFcbiAqL1xuXG4vKipcbiAqIENvbnRleHQgbWVudSBldmVudC5cbiAqXG4gKiBAZXZlbnQgY29udGV4dG1lbnVcbiAqIEBtZW1iZXJvZiBNYXBcbiAqIEBpbnN0YW5jZVxuICogQHByb3BlcnR5IHtFdmVudERhdGF9IGRhdGEgT3JpZ2luYWwgZXZlbnQgZGF0YSwgaWYgYXZhaWxhYmxlXG4gKi9cblxuLyoqXG4gKiBMb2FkIGV2ZW50LiBUaGlzIGV2ZW50IGlzIGVtaXR0ZWQgaW1tZWRpYXRlbHkgYWZ0ZXIgYWxsIG5lY2Vzc2FyeSByZXNvdXJjZXMgaGF2ZSBiZWVuIGRvd25sb2FkZWRcbiAqIGFuZCB0aGUgZmlyc3QgdmlzdWFsbHkgY29tcGxldGUgcmVuZGVyaW5nIGhhcyBvY2N1cnJlZC5cbiAqXG4gKiBAZXZlbnQgbG9hZFxuICogQG1lbWJlcm9mIE1hcFxuICogQGluc3RhbmNlXG4gKiBAdHlwZSB7T2JqZWN0fVxuICovXG5cbi8qKlxuICogTW92ZSBzdGFydCBldmVudC4gVGhpcyBldmVudCBpcyBlbWl0dGVkIGp1c3QgYmVmb3JlIHRoZSBtYXAgYmVnaW5zIGEgdHJhbnNpdGlvbiBmcm9tIG9uZVxuICogdmlldyB0byBhbm90aGVyLCBlaXRoZXIgYXMgYSByZXN1bHQgb2YgdXNlciBpbnRlcmFjdGlvbiBvciB0aGUgdXNlIG9mIG1ldGhvZHMgc3VjaCBhcyBgTWFwI2p1bXBUb2AuXG4gKlxuICogQGV2ZW50IG1vdmVzdGFydFxuICogQG1lbWJlcm9mIE1hcFxuICogQGluc3RhbmNlXG4gKiBAcHJvcGVydHkge0V2ZW50RGF0YX0gZGF0YSBPcmlnaW5hbCBldmVudCBkYXRhLCBpZiBmaXJlZCBpbnRlcmFjdGl2ZWx5XG4gKi9cblxuLyoqXG4gKiBNb3ZlIGV2ZW50LiBUaGlzIGV2ZW50IGlzIGVtaXR0ZWQgcmVwZWF0ZWRseSBkdXJpbmcgYW5pbWF0ZWQgdHJhbnNpdGlvbnMgZnJvbSBvbmUgdmlldyB0b1xuICogYW5vdGhlciwgZWl0aGVyIGFzIGEgcmVzdWx0IG9mIHVzZXIgaW50ZXJhY3Rpb24gb3IgdGhlIHVzZSBvZiBtZXRob2RzIHN1Y2ggYXMgYE1hcCNqdW1wVG9gLlxuICpcbiAqIEBldmVudCBtb3ZlXG4gKiBAbWVtYmVyb2YgTWFwXG4gKiBAaW5zdGFuY2VcbiAqIEBwcm9wZXJ0eSB7RXZlbnREYXRhfSBkYXRhIE9yaWdpbmFsIGV2ZW50IGRhdGEsIGlmIGZpcmVkIGludGVyYWN0aXZlbHlcbiAqL1xuXG4vKipcbiAqIE1vdmUgZW5kIGV2ZW50LiBUaGlzIGV2ZW50IGlzIGVtaXR0ZWQganVzdCBhZnRlciB0aGUgbWFwIGNvbXBsZXRlcyBhIHRyYW5zaXRpb24gZnJvbSBvbmVcbiAqIHZpZXcgdG8gYW5vdGhlciwgZWl0aGVyIGFzIGEgcmVzdWx0IG9mIHVzZXIgaW50ZXJhY3Rpb24gb3IgdGhlIHVzZSBvZiBtZXRob2RzIHN1Y2ggYXMgYE1hcCNqdW1wVG9gLlxuICpcbiAqIEBldmVudCBtb3ZlZW5kXG4gKiBAbWVtYmVyb2YgTWFwXG4gKiBAaW5zdGFuY2VcbiAqIEBwcm9wZXJ0eSB7RXZlbnREYXRhfSBkYXRhIE9yaWdpbmFsIGV2ZW50IGRhdGEsIGlmIGZpcmVkIGludGVyYWN0aXZlbHlcbiAqL1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgQ2FudmFzID0gcmVxdWlyZSgnLi4vdXRpbC9jYW52YXMnKTtcbnZhciB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbC91dGlsJyk7XG52YXIgYnJvd3NlciA9IHJlcXVpcmUoJy4uL3V0aWwvYnJvd3NlcicpO1xudmFyIEV2ZW50ZWQgPSByZXF1aXJlKCcuLi91dGlsL2V2ZW50ZWQnKTtcbnZhciBET00gPSByZXF1aXJlKCcuLi91dGlsL2RvbScpO1xuXG52YXIgU3R5bGUgPSByZXF1aXJlKCcuLi9zdHlsZS9zdHlsZScpO1xudmFyIEFuaW1hdGlvbkxvb3AgPSByZXF1aXJlKCcuLi9zdHlsZS9hbmltYXRpb25fbG9vcCcpO1xudmFyIFBhaW50ZXIgPSByZXF1aXJlKCcuLi9yZW5kZXIvcGFpbnRlcicpO1xuXG52YXIgVHJhbnNmb3JtID0gcmVxdWlyZSgnLi4vZ2VvL3RyYW5zZm9ybScpO1xudmFyIEhhc2ggPSByZXF1aXJlKCcuL2hhc2gnKTtcblxudmFyIEludGVyYWN0aW9uID0gcmVxdWlyZSgnLi9pbnRlcmFjdGlvbicpO1xuXG52YXIgQ2FtZXJhID0gcmVxdWlyZSgnLi9jYW1lcmEnKTtcbnZhciBMbmdMYXQgPSByZXF1aXJlKCcuLi9nZW8vbG5nX2xhdCcpO1xudmFyIExuZ0xhdEJvdW5kcyA9IHJlcXVpcmUoJy4uL2dlby9sbmdfbGF0X2JvdW5kcycpO1xudmFyIFBvaW50ID0gcmVxdWlyZSgncG9pbnQtZ2VvbWV0cnknKTtcbnZhciBBdHRyaWJ1dGlvbiA9IHJlcXVpcmUoJy4vY29udHJvbC9hdHRyaWJ1dGlvbicpO1xuXG52YXIgZGVmYXVsdE1pblpvb20gPSAwO1xudmFyIGRlZmF1bHRNYXhab29tID0gMjA7XG4vKipcbiAqIE9wdGlvbnMgY29tbW9uIHRvIE1hcCNhZGRDbGFzcywgTWFwI3JlbW92ZUNsYXNzLCBhbmQgTWFwI3NldENsYXNzZXMsIGNvbnRyb2xsaW5nXG4gKiB3aGV0aGVyIG9yIG5vdCB0byBzbW9vdGhseSB0cmFuc2l0aW9uIHByb3BlcnR5IGNoYW5nZXMgdHJpZ2dlcmVkIGJ5IHRoZSBjbGFzcyBjaGFuZ2UuXG4gKlxuICogQHR5cGVkZWYge09iamVjdH0gU3R5bGVPcHRpb25zXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IHRyYW5zaXRpb25cbiAqL1xuXG4vKipcbiAqIENyZWF0ZXMgYSBtYXAgaW5zdGFuY2UuXG4gKiBAY2xhc3MgTWFwXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQHBhcmFtIHtzdHJpbmd8RWxlbWVudH0gb3B0aW9ucy5jb250YWluZXIgSFRNTCBlbGVtZW50IHRvIGluaXRpYWxpemUgdGhlIG1hcCBpbiAob3IgZWxlbWVudCBpZCBhcyBzdHJpbmcpXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMubWluWm9vbT0wXSBNaW5pbXVtIHpvb20gb2YgdGhlIG1hcFxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLm1heFpvb209MjBdIE1heGltdW0gem9vbSBvZiB0aGUgbWFwXG4gKiBAcGFyYW0ge09iamVjdHxzdHJpbmd9IFtvcHRpb25zLnN0eWxlXSBNYXAgc3R5bGUuIFRoaXMgbXVzdCBiZSBhbiBhbiBvYmplY3QgY29uZm9ybWluZyB0byB0aGUgc2NoZW1hIGRlc2NyaWJlZCBpbiB0aGUgW3N0eWxlIHJlZmVyZW5jZV0oaHR0cHM6Ly9tYXBib3guY29tL21hcGJveC1nbC1zdHlsZS1zcGVjLyksIG9yIGEgVVJMIHRvIGEgSlNPTiBzdHlsZS4gVG8gbG9hZCBhIHN0eWxlIGZyb20gdGhlIE1hcGJveCBBUEksIHlvdSBjYW4gdXNlIGEgVVJMIG9mIHRoZSBmb3JtIGBtYXBib3g6Ly9zdHlsZXMvOm93bmVyLzpzdHlsZWAsIHdoZXJlIGA6b3duZXJgIGlzIHlvdXIgTWFwYm94IGFjY291bnQgbmFtZSBhbmQgYDpzdHlsZWAgaXMgdGhlIHN0eWxlIElELiBPciB5b3UgY2FuIHVzZSBvbmUgb2YgdGhlIHByZWRlZmluZWQgTWFwYm94IHN0eWxlczpcbiAqICAgKiBgbWFwYm94Oi8vc3R5bGVzL21hcGJveC9iYXNpYy12OGAgLSBTaW1wbGUgYW5kIGZsZXhpYmxlIHN0YXJ0aW5nIHRlbXBsYXRlLlxuICogICAqIGBtYXBib3g6Ly9zdHlsZXMvbWFwYm94L2JyaWdodC12OGAgLSBUZW1wbGF0ZSBmb3IgY29tcGxleCBjdXN0b20gYmFzZW1hcHMuXG4gKiAgICogYG1hcGJveDovL3N0eWxlcy9tYXBib3gvc3RyZWV0cy12OGAgLSBBIHJlYWR5LXRvLXVzZSBiYXNlbWFwLCBwZXJmZWN0IGZvciBtaW5vciBjdXN0b21pemF0aW9uIG9yIGluY29ycG9yYXRpbmcgeW91ciBvd24gZGF0YS5cbiAqICAgKiBgbWFwYm94Oi8vc3R5bGVzL21hcGJveC9saWdodC12OGAgLSBTdWJ0bGUgbGlnaHQgYmFja2Ryb3AgZm9yIGRhdGEgdml6dWFsaXphdGlvbnMuXG4gKiAgICogYG1hcGJveDovL3N0eWxlcy9tYXBib3gvZGFyay12OGAgLSBTdWJ0bGUgZGFyayBiYWNrZHJvcCBmb3IgZGF0YSB2aXp1YWxpemF0aW9ucy5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuaGFzaD1mYWxzZV0gSWYgYHRydWVgLCB0aGUgbWFwIHdpbGwgdHJhY2sgYW5kIHVwZGF0ZSB0aGUgcGFnZSBVUkwgYWNjb3JkaW5nIHRvIG1hcCBwb3NpdGlvblxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5pbnRlcmFjdGl2ZT10cnVlXSBJZiBgZmFsc2VgLCBubyBtb3VzZSwgdG91Y2gsIG9yIGtleWJvYXJkIGxpc3RlbmVycyBhcmUgYXR0YWNoZWQgdG8gdGhlIG1hcCwgc28gaXQgd2lsbCBub3QgcmVzcG9uZCB0byBpbnB1dFxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLmJlYXJpbmdTbmFwPTddIFNuYXAgdG8gbm9ydGggdGhyZXNob2xkIGluIGRlZ3JlZXMuXG4gKiBAcGFyYW0ge0FycmF5fSBbb3B0aW9ucy5jbGFzc2VzXSBTdHlsZSBjbGFzcyBuYW1lcyB3aXRoIHdoaWNoIHRvIGluaXRpYWxpemUgdGhlIG1hcFxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5hdHRyaWJ1dGlvbkNvbnRyb2w9dHJ1ZV0gSWYgYHRydWVgLCBhbiBhdHRyaWJ1dGlvbiBjb250cm9sIHdpbGwgYmUgYWRkZWQgdG8gdGhlIG1hcC5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuZmFpbElmTWFqb3JQZXJmb3JtYW5jZUNhdmVhdD1mYWxzZV0gSWYgYHRydWVgLCBtYXAgY3JlYXRpb24gd2lsbCBmYWlsIGlmIHRoZSBpbXBsZW1lbnRhdGlvbiBkZXRlcm1pbmVzIHRoYXQgdGhlIHBlcmZvcm1hbmNlIG9mIHRoZSBjcmVhdGVkIFdlYkdMIGNvbnRleHQgd291bGQgYmUgZHJhbWF0aWNhbGx5IGxvd2VyIHRoYW4gZXhwZWN0ZWQuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnByZXNlcnZlRHJhd2luZ0J1ZmZlcj1mYWxzZV0gSWYgYHRydWVgLCBUaGUgbWFwcyBjYW52YXMgY2FuIGJlIGV4cG9ydGVkIHRvIGEgUE5HIHVzaW5nIGBtYXAuZ2V0Q2FudmFzKCkudG9EYXRhVVJMKCk7YC4gVGhpcyBpcyBmYWxzZSBieSBkZWZhdWx0IGFzIGEgcGVyZm9ybWFuY2Ugb3B0aW1pemF0aW9uLlxuICogQHBhcmFtIHtMbmdMYXRCb3VuZHN8QXJyYXk8QXJyYXk8bnVtYmVyPj59IFtvcHRpb25zLm1heEJvdW5kc10gSWYgc2V0LCB0aGUgbWFwIGlzIGNvbnN0cmFpbmVkIHRvIHRoZSBnaXZlbiBib3VuZHMuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnNjcm9sbFpvb209dHJ1ZV0gSWYgYHRydWVgLCBlbmFibGUgdGhlIFwic2Nyb2xsIHRvIHpvb21cIiBpbnRlcmFjdGlvbiAoc2VlIGBTY3JvbGxab29tSGFuZGxlcmApXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmJveFpvb209dHJ1ZV0gSWYgYHRydWVgLCBlbmFibGUgdGhlIFwiYm94IHpvb21cIiBpbnRlcmFjdGlvbiAoc2VlIGBCb3hab29tSGFuZGxlcmApXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmRyYWdSb3RhdGU9dHJ1ZV0gSWYgYHRydWVgLCBlbmFibGUgdGhlIFwiZHJhZyB0byByb3RhdGVcIiBpbnRlcmFjdGlvbiAoc2VlIGBEcmFnUm90YXRlSGFuZGxlcmApLlxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5kcmFnUGFuPXRydWVdIElmIGB0cnVlYCwgZW5hYmxlIHRoZSBcImRyYWcgdG8gcGFuXCIgaW50ZXJhY3Rpb24gKHNlZSBgRHJhZ1BhbkhhbmRsZXJgKS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMua2V5Ym9hcmQ9dHJ1ZV0gSWYgYHRydWVgLCBlbmFibGUga2V5Ym9hcmQgc2hvcnRjdXRzIChzZWUgYEtleWJvYXJkSGFuZGxlcmApLlxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5kb3VibGVDbGlja1pvb209dHJ1ZV0gSWYgYHRydWVgLCBlbmFibGUgdGhlIFwiZG91YmxlIGNsaWNrIHRvIHpvb21cIiBpbnRlcmFjdGlvbiAoc2VlIGBEb3VibGVDbGlja1pvb21IYW5kbGVyYCkuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnRvdWNoWm9vbVJvdGF0ZT10cnVlXSBJZiBgdHJ1ZWAsIGVuYWJsZSB0aGUgXCJwaW5jaCB0byByb3RhdGUgYW5kIHpvb21cIiBpbnRlcmFjdGlvbiAoc2VlIGBUb3VjaFpvb21Sb3RhdGVIYW5kbGVyYCkuXG4gKiBAZXhhbXBsZVxuICogdmFyIG1hcCA9IG5ldyBtYXBib3hnbC5NYXAoe1xuICogICBjb250YWluZXI6ICdtYXAnLFxuICogICBjZW50ZXI6IFstMTIyLjQyMDY3OSwgMzcuNzcyNTM3XSxcbiAqICAgem9vbTogMTMsXG4gKiAgIHN0eWxlOiBzdHlsZV9vYmplY3QsXG4gKiAgIGhhc2g6IHRydWVcbiAqIH0pO1xuICovXG52YXIgTWFwID0gbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihvcHRpb25zKSB7XG5cbiAgICBvcHRpb25zID0gdXRpbC5pbmhlcml0KHRoaXMub3B0aW9ucywgb3B0aW9ucyk7XG4gICAgdGhpcy5faW50ZXJhY3RpdmUgPSBvcHRpb25zLmludGVyYWN0aXZlO1xuICAgIHRoaXMuX2ZhaWxJZk1ham9yUGVyZm9ybWFuY2VDYXZlYXQgPSBvcHRpb25zLmZhaWxJZk1ham9yUGVyZm9ybWFuY2VDYXZlYXQ7XG4gICAgdGhpcy5fcHJlc2VydmVEcmF3aW5nQnVmZmVyID0gb3B0aW9ucy5wcmVzZXJ2ZURyYXdpbmdCdWZmZXI7XG5cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuY29udGFpbmVyID09PSAnc3RyaW5nJykge1xuICAgICAgICB0aGlzLl9jb250YWluZXIgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChvcHRpb25zLmNvbnRhaW5lcik7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fY29udGFpbmVyID0gb3B0aW9ucy5jb250YWluZXI7XG4gICAgfVxuXG4gICAgdGhpcy5hbmltYXRpb25Mb29wID0gbmV3IEFuaW1hdGlvbkxvb3AoKTtcbiAgICB0aGlzLnRyYW5zZm9ybSA9IG5ldyBUcmFuc2Zvcm0ob3B0aW9ucy5taW5ab29tLCBvcHRpb25zLm1heFpvb20pO1xuXG4gICAgaWYgKG9wdGlvbnMubWF4Qm91bmRzKSB7XG4gICAgICAgIHRoaXMuc2V0TWF4Qm91bmRzKG9wdGlvbnMubWF4Qm91bmRzKTtcbiAgICB9XG5cbiAgICB1dGlsLmJpbmRBbGwoW1xuICAgICAgICAnX2ZvcndhcmRTdHlsZUV2ZW50JyxcbiAgICAgICAgJ19mb3J3YXJkU291cmNlRXZlbnQnLFxuICAgICAgICAnX2ZvcndhcmRMYXllckV2ZW50JyxcbiAgICAgICAgJ19mb3J3YXJkVGlsZUV2ZW50JyxcbiAgICAgICAgJ19vblN0eWxlTG9hZCcsXG4gICAgICAgICdfb25TdHlsZUNoYW5nZScsXG4gICAgICAgICdfb25Tb3VyY2VBZGQnLFxuICAgICAgICAnX29uU291cmNlUmVtb3ZlJyxcbiAgICAgICAgJ19vblNvdXJjZVVwZGF0ZScsXG4gICAgICAgICdfb25XaW5kb3dSZXNpemUnLFxuICAgICAgICAnb25FcnJvcicsXG4gICAgICAgICdfdXBkYXRlJyxcbiAgICAgICAgJ19yZW5kZXInXG4gICAgXSwgdGhpcyk7XG5cbiAgICB0aGlzLl9zZXR1cENvbnRhaW5lcigpO1xuICAgIHRoaXMuX3NldHVwUGFpbnRlcigpO1xuXG4gICAgdGhpcy5vbignbW92ZScsIHRoaXMuX3VwZGF0ZS5iaW5kKHRoaXMsIGZhbHNlKSk7XG4gICAgdGhpcy5vbignem9vbScsIHRoaXMuX3VwZGF0ZS5iaW5kKHRoaXMsIHRydWUpKTtcbiAgICB0aGlzLm9uKCdtb3ZlZW5kJywgZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuYW5pbWF0aW9uTG9vcC5zZXQoMzAwKTsgLy8gdGV4dCBmYWRpbmdcbiAgICAgICAgdGhpcy5fcmVyZW5kZXIoKTtcbiAgICB9LmJpbmQodGhpcykpO1xuXG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCB0aGlzLl9vbldpbmRvd1Jlc2l6ZSwgZmFsc2UpO1xuICAgIH1cblxuICAgIHRoaXMuaW50ZXJhY3Rpb24gPSBuZXcgSW50ZXJhY3Rpb24odGhpcyk7XG5cbiAgICBpZiAob3B0aW9ucy5pbnRlcmFjdGl2ZSkge1xuICAgICAgICB0aGlzLmludGVyYWN0aW9uLmVuYWJsZSgpO1xuICAgIH1cblxuICAgIHRoaXMuX2hhc2ggPSBvcHRpb25zLmhhc2ggJiYgKG5ldyBIYXNoKCkpLmFkZFRvKHRoaXMpO1xuICAgIC8vIGRvbid0IHNldCBwb3NpdGlvbiBmcm9tIG9wdGlvbnMgaWYgc2V0IHRocm91Z2ggaGFzaFxuICAgIGlmICghdGhpcy5faGFzaCB8fCAhdGhpcy5faGFzaC5fb25IYXNoQ2hhbmdlKCkpIHtcbiAgICAgICAgdGhpcy5qdW1wVG8ob3B0aW9ucyk7XG4gICAgfVxuXG4gICAgdGhpcy5zdGFja3MgPSB7fTtcbiAgICB0aGlzLl9jbGFzc2VzID0ge307XG5cbiAgICB0aGlzLnJlc2l6ZSgpO1xuXG4gICAgaWYgKG9wdGlvbnMuY2xhc3NlcykgdGhpcy5zZXRDbGFzc2VzKG9wdGlvbnMuY2xhc3Nlcyk7XG4gICAgaWYgKG9wdGlvbnMuc3R5bGUpIHRoaXMuc2V0U3R5bGUob3B0aW9ucy5zdHlsZSk7XG4gICAgaWYgKG9wdGlvbnMuYXR0cmlidXRpb25Db250cm9sKSB0aGlzLmFkZENvbnRyb2wobmV3IEF0dHJpYnV0aW9uKG9wdGlvbnMuYXR0cmlidXRpb25Db250cm9sKSk7XG5cbiAgICB0aGlzLm9uKCdzdHlsZS5lcnJvcicsIHRoaXMub25FcnJvcik7XG4gICAgdGhpcy5vbignc291cmNlLmVycm9yJywgdGhpcy5vbkVycm9yKTtcbiAgICB0aGlzLm9uKCd0aWxlLmVycm9yJywgdGhpcy5vbkVycm9yKTtcbiAgICB0aGlzLm9uKCdsYXllci5lcnJvcicsIHRoaXMub25FcnJvcik7XG59O1xuXG51dGlsLmV4dGVuZChNYXAucHJvdG90eXBlLCBFdmVudGVkKTtcbnV0aWwuZXh0ZW5kKE1hcC5wcm90b3R5cGUsIENhbWVyYS5wcm90b3R5cGUpO1xudXRpbC5leHRlbmQoTWFwLnByb3RvdHlwZSwgLyoqIEBsZW5kcyBNYXAucHJvdG90eXBlICove1xuXG4gICAgb3B0aW9uczoge1xuICAgICAgICBjZW50ZXI6IFswLCAwXSxcbiAgICAgICAgem9vbTogMCxcbiAgICAgICAgYmVhcmluZzogMCxcbiAgICAgICAgcGl0Y2g6IDAsXG5cbiAgICAgICAgbWluWm9vbTogZGVmYXVsdE1pblpvb20sXG4gICAgICAgIG1heFpvb206IGRlZmF1bHRNYXhab29tLFxuXG4gICAgICAgIGludGVyYWN0aXZlOiB0cnVlLFxuXG4gICAgICAgIHNjcm9sbFpvb206IHRydWUsXG4gICAgICAgIGJveFpvb206IHRydWUsXG4gICAgICAgIGRyYWdSb3RhdGU6IHRydWUsXG4gICAgICAgIGRyYWdQYW46IHRydWUsXG4gICAgICAgIGtleWJvYXJkOiB0cnVlLFxuICAgICAgICBkb3VibGVDbGlja1pvb206IHRydWUsXG4gICAgICAgIHRvdWNoWm9vbVJvdGF0ZTogdHJ1ZSxcblxuICAgICAgICBiZWFyaW5nU25hcDogNyxcblxuICAgICAgICBoYXNoOiBmYWxzZSxcblxuICAgICAgICBhdHRyaWJ1dGlvbkNvbnRyb2w6IHRydWUsXG5cbiAgICAgICAgZmFpbElmTWFqb3JQZXJmb3JtYW5jZUNhdmVhdDogZmFsc2UsXG4gICAgICAgIHByZXNlcnZlRHJhd2luZ0J1ZmZlcjogZmFsc2VcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQWRkcyBhIGNvbnRyb2wgdG8gdGhlIG1hcCwgY2FsbGluZyBgY29udHJvbC5hZGRUbyh0aGlzKWAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0NvbnRyb2x9IGNvbnRyb2xcbiAgICAgKiBAcmV0dXJucyB7TWFwfSBgdGhpc2BcbiAgICAgKi9cbiAgICBhZGRDb250cm9sOiBmdW5jdGlvbihjb250cm9sKSB7XG4gICAgICAgIGNvbnRyb2wuYWRkVG8odGhpcyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBZGRzIGEgc3R5bGUgY2xhc3MgdG8gYSBtYXBcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrbGFzcyBuYW1lIG9mIHN0eWxlIGNsYXNzXG4gICAgICogQHBhcmFtIHtTdHlsZU9wdGlvbnN9IFtvcHRpb25zXVxuICAgICAqIEBmaXJlcyBjaGFuZ2VcbiAgICAgKiBAcmV0dXJucyB7TWFwfSBgdGhpc2BcbiAgICAgKi9cbiAgICBhZGRDbGFzczogZnVuY3Rpb24oa2xhc3MsIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKHRoaXMuX2NsYXNzZXNba2xhc3NdKSByZXR1cm47XG4gICAgICAgIHRoaXMuX2NsYXNzZXNba2xhc3NdID0gdHJ1ZTtcbiAgICAgICAgaWYgKHRoaXMuc3R5bGUpIHRoaXMuc3R5bGUuX2Nhc2NhZGUodGhpcy5fY2xhc3Nlcywgb3B0aW9ucyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYSBzdHlsZSBjbGFzcyBmcm9tIGEgbWFwXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2xhc3MgbmFtZSBvZiBzdHlsZSBjbGFzc1xuICAgICAqIEBwYXJhbSB7U3R5bGVPcHRpb25zfSBbb3B0aW9uc11cbiAgICAgKiBAZmlyZXMgY2hhbmdlXG4gICAgICogQHJldHVybnMge01hcH0gYHRoaXNgXG4gICAgICovXG4gICAgcmVtb3ZlQ2xhc3M6IGZ1bmN0aW9uKGtsYXNzLCBvcHRpb25zKSB7XG4gICAgICAgIGlmICghdGhpcy5fY2xhc3Nlc1trbGFzc10pIHJldHVybjtcbiAgICAgICAgZGVsZXRlIHRoaXMuX2NsYXNzZXNba2xhc3NdO1xuICAgICAgICBpZiAodGhpcy5zdHlsZSkgdGhpcy5zdHlsZS5fY2FzY2FkZSh0aGlzLl9jbGFzc2VzLCBvcHRpb25zKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSGVscGVyIG1ldGhvZCB0byBhZGQgbW9yZSB0aGFuIG9uZSBjbGFzc1xuICAgICAqXG4gICAgICogQHBhcmFtIHtBcnJheTxzdHJpbmc+fSBrbGFzc2VzIEFuIGFycmF5IG9mIGNsYXNzIG5hbWVzXG4gICAgICogQHBhcmFtIHtTdHlsZU9wdGlvbnN9IFtvcHRpb25zXVxuICAgICAqIEBmaXJlcyBjaGFuZ2VcbiAgICAgKiBAcmV0dXJucyB7TWFwfSBgdGhpc2BcbiAgICAgKi9cbiAgICBzZXRDbGFzc2VzOiBmdW5jdGlvbihrbGFzc2VzLCBvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuX2NsYXNzZXMgPSB7fTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrbGFzc2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLl9jbGFzc2VzW2tsYXNzZXNbaV1dID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5zdHlsZSkgdGhpcy5zdHlsZS5fY2FzY2FkZSh0aGlzLl9jbGFzc2VzLCBvcHRpb25zKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2hlY2sgd2hldGhlciBhIHN0eWxlIGNsYXNzIGlzIGFjdGl2ZVxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtsYXNzIE5hbWUgb2Ygc3R5bGUgY2xhc3NcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBoYXNDbGFzczogZnVuY3Rpb24oa2xhc3MpIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy5fY2xhc3Nlc1trbGFzc107XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybiBhbiBhcnJheSBvZiB0aGUgY3VycmVudCBhY3RpdmUgc3R5bGUgY2xhc3Nlc1xuICAgICAqXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgZ2V0Q2xhc3NlczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBPYmplY3Qua2V5cyh0aGlzLl9jbGFzc2VzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRGV0ZWN0IHRoZSBtYXAncyBuZXcgd2lkdGggYW5kIGhlaWdodCBhbmQgcmVzaXplIGl0LlxuICAgICAqXG4gICAgICogQHJldHVybnMge01hcH0gYHRoaXNgXG4gICAgICovXG4gICAgcmVzaXplOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHdpZHRoID0gMCwgaGVpZ2h0ID0gMDtcblxuICAgICAgICBpZiAodGhpcy5fY29udGFpbmVyKSB7XG4gICAgICAgICAgICB3aWR0aCA9IHRoaXMuX2NvbnRhaW5lci5vZmZzZXRXaWR0aCB8fCA0MDA7XG4gICAgICAgICAgICBoZWlnaHQgPSB0aGlzLl9jb250YWluZXIub2Zmc2V0SGVpZ2h0IHx8IDMwMDtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2NhbnZhcy5yZXNpemUod2lkdGgsIGhlaWdodCk7XG4gICAgICAgIHRoaXMudHJhbnNmb3JtLnJlc2l6ZSh3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgdGhpcy5wYWludGVyLnJlc2l6ZSh3aWR0aCwgaGVpZ2h0KTtcblxuICAgICAgICByZXR1cm4gdGhpc1xuICAgICAgICAgICAgLmZpcmUoJ21vdmVzdGFydCcpXG4gICAgICAgICAgICAuZmlyZSgnbW92ZScpXG4gICAgICAgICAgICAuZmlyZSgncmVzaXplJylcbiAgICAgICAgICAgIC5maXJlKCdtb3ZlZW5kJyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgbWFwJ3MgZ2VvZ3JhcGhpY2FsIGJvdW5kcy5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtMbmdMYXRCb3VuZHN9XG4gICAgICovXG4gICAgZ2V0Qm91bmRzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGJvdW5kcyA9IG5ldyBMbmdMYXRCb3VuZHMoXG4gICAgICAgICAgICB0aGlzLnRyYW5zZm9ybS5wb2ludExvY2F0aW9uKG5ldyBQb2ludCgwLCAwKSksXG4gICAgICAgICAgICB0aGlzLnRyYW5zZm9ybS5wb2ludExvY2F0aW9uKHRoaXMudHJhbnNmb3JtLnNpemUpKTtcblxuICAgICAgICBpZiAodGhpcy50cmFuc2Zvcm0uYW5nbGUgfHwgdGhpcy50cmFuc2Zvcm0ucGl0Y2gpIHtcbiAgICAgICAgICAgIGJvdW5kcy5leHRlbmQodGhpcy50cmFuc2Zvcm0ucG9pbnRMb2NhdGlvbihuZXcgUG9pbnQodGhpcy50cmFuc2Zvcm0uc2l6ZS54LCAwKSkpO1xuICAgICAgICAgICAgYm91bmRzLmV4dGVuZCh0aGlzLnRyYW5zZm9ybS5wb2ludExvY2F0aW9uKG5ldyBQb2ludCgwLCB0aGlzLnRyYW5zZm9ybS5zaXplLnkpKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYm91bmRzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXQgY29uc3RyYWludCBvbiB0aGUgbWFwJ3MgZ2VvZ3JhcGhpY2FsIGJvdW5kcy4gUGFuIG9yIHpvb20gb3BlcmF0aW9ucyB0aGF0IHdvdWxkIHJlc3VsdCBpblxuICAgICAqIGRpc3BsYXlpbmcgcmVnaW9ucyB0aGF0IGZhbGwgb3V0c2lkZSBvZiB0aGUgYm91bmRzIGluc3RlYWQgcmVzdWx0IGluIGRpc3BsYXlpbmcgdGhlIG1hcCBhdCB0aGVcbiAgICAgKiBjbG9zZXN0IHBvaW50IGFuZC9vciB6b29tIGxldmVsIG9mIHRoZSByZXF1ZXN0ZWQgb3BlcmF0aW9uIHRoYXQgaXMgd2l0aGluIHRoZSBtYXggYm91bmRzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtMbmdMYXRCb3VuZHMgfCBBcnJheTxBcnJheTxudW1iZXI+PiB8IG51bGwgfCB1bmRlZmluZWR9IGxuZ2xhdGJvdW5kcyBEZXNpcmVkIG1heCBib3VuZHMgb2YgdGhlIG1hcC4gSWYgbnVsbCBvciB1bmRlZmluZWQsIGZ1bmN0aW9uIHJlbW92ZXMgYW55IGJvdW5kcyBjb25zdHJhaW50cyBvbiB0aGUgbWFwLlxuICAgICAqIEByZXR1cm5zIHtNYXB9IGB0aGlzYFxuICAgICAqL1xuICAgIHNldE1heEJvdW5kczogZnVuY3Rpb24gKGxuZ2xhdGJvdW5kcykge1xuICAgICAgICBpZiAobG5nbGF0Ym91bmRzKSB7XG4gICAgICAgICAgICB2YXIgYiA9IExuZ0xhdEJvdW5kcy5jb252ZXJ0KGxuZ2xhdGJvdW5kcyk7XG4gICAgICAgICAgICB0aGlzLnRyYW5zZm9ybS5sbmdSYW5nZSA9IFtiLmdldFdlc3QoKSwgYi5nZXRFYXN0KCldO1xuICAgICAgICAgICAgdGhpcy50cmFuc2Zvcm0ubGF0UmFuZ2UgPSBbYi5nZXRTb3V0aCgpLCBiLmdldE5vcnRoKCldO1xuICAgICAgICAgICAgdGhpcy50cmFuc2Zvcm0uX2NvbnN0cmFpbigpO1xuICAgICAgICAgICAgdGhpcy5fdXBkYXRlKCk7XG4gICAgICAgIH0gZWxzZSBpZiAobG5nbGF0Ym91bmRzID09PSBudWxsIHx8IGxuZ2xhdGJvdW5kcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLnRyYW5zZm9ybS5sbmdSYW5nZSA9IFtdO1xuICAgICAgICAgICAgdGhpcy50cmFuc2Zvcm0ubGF0UmFuZ2UgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIG1hcCdzIG1pbmltdW0gem9vbSBsZXZlbCwgYW5kIHpvb21zIG1hcCB0byB0aGF0IGxldmVsIGlmIGl0IGlzIGN1cnJlbnRseSBiZWxvdyBpdC4gSWYgbm8gcGFyYW1ldGVyIHByb3ZpZGVkLCB1bnNldHMgdGhlIGN1cnJlbnQgbWluaW11bSB6b29tIChzZXRzIGl0IHRvIDApXG4gICAgICogQHBhcmFtIHt6b29tfSBhbnkgbnVtYmVyIGJldHdlZW4gMCBhbmQgMjBcbiAgICAgKiBAcmV0dXJucyB7TWFwfSBgdGhpc2BcbiAgICAgKi9cbiAgICBzZXRNaW5ab29tOiBmdW5jdGlvbihtaW5ab29tKSB7XG5cbiAgICAgICAgbWluWm9vbSA9IG1pblpvb20gPT09IG51bGwgfHwgbWluWm9vbSA9PT0gdW5kZWZpbmVkID8gZGVmYXVsdE1pblpvb20gOiBtaW5ab29tO1xuXG4gICAgICAgIGlmIChtaW5ab29tID49IGRlZmF1bHRNaW5ab29tICYmIG1pblpvb20gPD0gdGhpcy50cmFuc2Zvcm0ubWF4Wm9vbSkge1xuICAgICAgICAgICAgdGhpcy50cmFuc2Zvcm0ubWluWm9vbSA9IG1pblpvb207XG4gICAgICAgICAgICB0aGlzLl91cGRhdGUoKTtcblxuICAgICAgICAgICAgaWYgKHRoaXMuZ2V0Wm9vbSgpIDwgbWluWm9vbSkgdGhpcy5zZXRab29tKG1pblpvb20pO1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIGVsc2UgdGhyb3cgbmV3IEVycm9yKCdtaW5ab29tIG11c3QgYmUgYmV0d2VlbiAnICsgZGVmYXVsdE1pblpvb20gKyAnIGFuZCB0aGUgY3VycmVudCBtYXhab29tLCBpbmNsdXNpdmUnKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0IHRoZSBtYXAncyBtYXhpbXVtIHpvb20gbGV2ZWwsIGFuZCB6b29tcyBtYXAgdG8gdGhhdCBsZXZlbCBpZiBpdCBpcyBjdXJyZW50bHkgYWJvdmUgaXQuIElmIG5vIHBhcmFtZXRlciBwcm92aWRlZCwgdW5zZXRzIHRoZSBjdXJyZW50IG1heGltdW0gem9vbSAoc2V0cyBpdCB0byAyMClcbiAgICAgKiBAcGFyYW0ge3pvb219IGFueSBudW1iZXIgYmV0d2VlbiAwIGFuZCAyMFxuICAgICAqIEByZXR1cm5zIHtNYXB9IGB0aGlzYFxuICAgICAqL1xuICAgIHNldE1heFpvb206IGZ1bmN0aW9uKG1heFpvb20pIHtcblxuICAgICAgICBtYXhab29tID0gbWF4Wm9vbSA9PT0gbnVsbCB8fCBtYXhab29tID09PSB1bmRlZmluZWQgPyBkZWZhdWx0TWF4Wm9vbSA6IG1heFpvb207XG5cbiAgICAgICAgaWYgKG1heFpvb20gPj0gdGhpcy50cmFuc2Zvcm0ubWluWm9vbSAmJiBtYXhab29tIDw9IGRlZmF1bHRNYXhab29tKSB7XG4gICAgICAgICAgICB0aGlzLnRyYW5zZm9ybS5tYXhab29tID0gbWF4Wm9vbTtcbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZSgpO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5nZXRab29tKCkgPiBtYXhab29tKSB0aGlzLnNldFpvb20obWF4Wm9vbSk7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgZWxzZSB0aHJvdyBuZXcgRXJyb3IoJ21heFpvb20gbXVzdCBiZSBiZXR3ZWVuIHRoZSBjdXJyZW50IG1pblpvb20gYW5kICcgKyBkZWZhdWx0TWF4Wm9vbSArICcsIGluY2x1c2l2ZScpO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogR2V0IHBpeGVsIGNvb3JkaW5hdGVzIChyZWxhdGl2ZSB0byBtYXAgY29udGFpbmVyKSBnaXZlbiBhIGdlb2dyYXBoaWNhbCBsb2NhdGlvblxuICAgICAqXG4gICAgICogQHBhcmFtIHtMbmdMYXR9IGxuZ2xhdFxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IGB4YCBhbmQgYHlgIGNvb3JkaW5hdGVzXG4gICAgICovXG4gICAgcHJvamVjdDogZnVuY3Rpb24obG5nbGF0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybS5sb2NhdGlvblBvaW50KExuZ0xhdC5jb252ZXJ0KGxuZ2xhdCkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgZ2VvZ3JhcGhpY2FsIGNvb3JkaW5hdGVzIGdpdmVuIHBpeGVsIGNvb3JkaW5hdGVzXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IHBvaW50IFt4LCB5XSBwaXhlbCBjb29yZGluYXRlc1xuICAgICAqIEByZXR1cm5zIHtMbmdMYXR9XG4gICAgICovXG4gICAgdW5wcm9qZWN0OiBmdW5jdGlvbihwb2ludCkge1xuICAgICAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm0ucG9pbnRMb2NhdGlvbihQb2ludC5jb252ZXJ0KHBvaW50KSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFF1ZXJ5IHJlbmRlcmVkIGZlYXR1cmVzIHdpdGhpbiBhIHBvaW50IG9yIHJlY3RhbmdsZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UG9pbnR8QXJyYXk8bnVtYmVyPnxBcnJheTxQb2ludD58QXJyYXk8QXJyYXk8bnVtYmVyPj59IFtwb2ludE9yQm94XSBFaXRoZXIgW3gsIHldIHBpeGVsIGNvb3JkaW5hdGVzIG9mIGEgcG9pbnQsIG9yIFtbeDEsIHkxXSwgW3gyLCB5Ml1dIHBpeGVsIGNvb3JkaW5hdGVzIG9mIG9wcG9zaXRlIGNvcm5lcnMgb2YgYm91bmRpbmcgcmVjdGFuZ2xlLiBPcHRpb25hbDogdXNlIGVudGlyZSB2aWV3cG9ydCBpZiBvbWl0dGVkLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXNcbiAgICAgKiBAcGFyYW0ge0FycmF5PHN0cmluZz59IFtwYXJhbXMubGF5ZXJzXSBPbmx5IHF1ZXJ5IGZlYXR1cmVzIGZyb20gbGF5ZXJzIHdpdGggdGhlc2UgbGF5ZXIgSURzLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtwYXJhbXMuZmlsdGVyXSBBIG1hcGJveC1nbC1zdHlsZS1zcGVjIGZpbHRlci5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtBcnJheTxPYmplY3Q+fSBmZWF0dXJlcyAtIEFuIGFycmF5IG9mIFtHZW9KU09OXShodHRwOi8vZ2VvanNvbi5vcmcvKSBmZWF0dXJlcyBtYXRjaGluZyB0aGUgcXVlcnkgcGFyYW1ldGVycy4gVGhlIEdlb0pTT04gcHJvcGVydGllcyBvZiBlYWNoIGZlYXR1cmUgYXJlIHRha2VuIGZyb20gdGhlIG9yaWdpbmFsIHNvdXJjZS4gRWFjaCBmZWF0dXJlIG9iamVjdCBhbHNvIGNvbnRhaW5zIGEgdG9wLWxldmVsIGBsYXllcmAgcHJvcGVydHkgd2hvc2UgdmFsdWUgaXMgYW4gb2JqZWN0IHJlcHJlc2VudGluZyB0aGUgc3R5bGUgbGF5ZXIgdG8gd2hpY2ggdGhlIGZlYXR1cmUgYmVsb25ncy4gTGF5b3V0IGFuZCBwYWludCBwcm9wZXJ0aWVzIGluIHRoaXMgb2JqZWN0IGNvbnRhaW4gdmFsdWVzIHdoaWNoIGFyZSBmdWxseSBldmFsdWF0ZWQgZm9yIHRoZSBnaXZlbiB6b29tIGxldmVsIGFuZCBmZWF0dXJlLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiB2YXIgZmVhdHVyZXMgPSBtYXAucXVlcnlSZW5kZXJlZEZlYXR1cmVzKFsyMCwgMzVdLCB7IGxheWVyczogWydteS1sYXllci1uYW1lJ10gfSk7XG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIHZhciBmZWF0dXJlcyA9IG1hcC5xdWVyeVJlbmRlcmVkRmVhdHVyZXMoW1sxMCwgMjBdLCBbMzAsIDUwXV0sIHsgbGF5ZXJzOiBbJ215LWxheWVyLW5hbWUnXSB9KTtcbiAgICAgKi9cbiAgICBxdWVyeVJlbmRlcmVkRmVhdHVyZXM6IGZ1bmN0aW9uKHBvaW50T3JCb3gsIHBhcmFtcykge1xuICAgICAgICBpZiAoIShwb2ludE9yQm94IGluc3RhbmNlb2YgUG9pbnQgfHwgQXJyYXkuaXNBcnJheShwb2ludE9yQm94KSkpIHtcbiAgICAgICAgICAgIHBhcmFtcyA9IHBvaW50T3JCb3g7XG4gICAgICAgICAgICBwb2ludE9yQm94ID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHZhciBxdWVyeUdlb21ldHJ5ID0gdGhpcy5fbWFrZVF1ZXJ5R2VvbWV0cnkocG9pbnRPckJveCk7XG4gICAgICAgIHJldHVybiB0aGlzLnN0eWxlLnF1ZXJ5UmVuZGVyZWRGZWF0dXJlcyhxdWVyeUdlb21ldHJ5LCBwYXJhbXMsIHRoaXMuX2NsYXNzZXMsIHRoaXMudHJhbnNmb3JtLnpvb20sIHRoaXMudHJhbnNmb3JtLmFuZ2xlKTtcbiAgICB9LFxuXG4gICAgX21ha2VRdWVyeUdlb21ldHJ5OiBmdW5jdGlvbihwb2ludE9yQm94KSB7XG4gICAgICAgIGlmIChwb2ludE9yQm94ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIC8vIGJvdW5kcyB3YXMgb21pdHRlZDogdXNlIGZ1bGwgdmlld3BvcnRcbiAgICAgICAgICAgIHBvaW50T3JCb3ggPSBbXG4gICAgICAgICAgICAgICAgUG9pbnQuY29udmVydChbMCwgMF0pLFxuICAgICAgICAgICAgICAgIFBvaW50LmNvbnZlcnQoW3RoaXMudHJhbnNmb3JtLndpZHRoLCB0aGlzLnRyYW5zZm9ybS5oZWlnaHRdKVxuICAgICAgICAgICAgXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBxdWVyeUdlb21ldHJ5O1xuICAgICAgICB2YXIgaXNQb2ludCA9IHBvaW50T3JCb3ggaW5zdGFuY2VvZiBQb2ludCB8fCB0eXBlb2YgcG9pbnRPckJveFswXSA9PT0gJ251bWJlcic7XG5cbiAgICAgICAgaWYgKGlzUG9pbnQpIHtcbiAgICAgICAgICAgIHZhciBwb2ludCA9IFBvaW50LmNvbnZlcnQocG9pbnRPckJveCk7XG4gICAgICAgICAgICBxdWVyeUdlb21ldHJ5ID0gW3BvaW50XTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBib3ggPSBbUG9pbnQuY29udmVydChwb2ludE9yQm94WzBdKSwgUG9pbnQuY29udmVydChwb2ludE9yQm94WzFdKV07XG4gICAgICAgICAgICBxdWVyeUdlb21ldHJ5ID0gW1xuICAgICAgICAgICAgICAgIGJveFswXSxcbiAgICAgICAgICAgICAgICBuZXcgUG9pbnQoYm94WzFdLngsIGJveFswXS55KSxcbiAgICAgICAgICAgICAgICBib3hbMV0sXG4gICAgICAgICAgICAgICAgbmV3IFBvaW50KGJveFswXS54LCBib3hbMV0ueSksXG4gICAgICAgICAgICAgICAgYm94WzBdXG4gICAgICAgICAgICBdO1xuICAgICAgICB9XG5cbiAgICAgICAgcXVlcnlHZW9tZXRyeSA9IHF1ZXJ5R2VvbWV0cnkubWFwKGZ1bmN0aW9uKHApIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybS5wb2ludENvb3JkaW5hdGUocCk7XG4gICAgICAgIH0uYmluZCh0aGlzKSk7XG5cbiAgICAgICAgcmV0dXJuIHF1ZXJ5R2VvbWV0cnk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldCBkYXRhIGZyb20gdmVjdG9yIHRpbGVzIGFzIGFuIGFycmF5IG9mIEdlb0pTT04gRmVhdHVyZXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc291cmNlSUQgc291cmNlIElEXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHBhcmFtc1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbcGFyYW1zLnNvdXJjZUxheWVyXSBUaGUgbmFtZSBvZiB0aGUgdmVjdG9yIHRpbGUgbGF5ZXIgdG8gZ2V0IGZlYXR1cmVzIGZyb20uXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3BhcmFtcy5maWx0ZXJdIEEgbWFwYm94LWdsLXN0eWxlLXNwZWMgZmlsdGVyLlxuICAgICAqXG4gICAgICogQHJldHVybnMge0FycmF5PE9iamVjdD59IGZlYXR1cmVzIC0gQW4gYXJyYXkgb2YgW0dlb0pTT05dKGh0dHA6Ly9nZW9qc29uLm9yZy8pIGZlYXR1cmVzIG1hdGNoaW5nIHRoZSBxdWVyeSBwYXJhbWV0ZXJzLiBUaGUgR2VvSlNPTiBwcm9wZXJ0aWVzIG9mIGVhY2ggZmVhdHVyZSBhcmUgdGFrZW4gZnJvbSB0aGUgb3JpZ2luYWwgc291cmNlLiBFYWNoIGZlYXR1cmUgb2JqZWN0IGFsc28gY29udGFpbnMgYSB0b3AtbGV2ZWwgYGxheWVyYCBwcm9wZXJ0eSB3aG9zZSB2YWx1ZSBpcyBhbiBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSBzdHlsZSBsYXllciB0byB3aGljaCB0aGUgZmVhdHVyZSBiZWxvbmdzLiBMYXlvdXQgYW5kIHBhaW50IHByb3BlcnRpZXMgaW4gdGhpcyBvYmplY3QgY29udGFpbiB2YWx1ZXMgd2hpY2ggYXJlIGZ1bGx5IGV2YWx1YXRlZCBmb3IgdGhlIGdpdmVuIHpvb20gbGV2ZWwgYW5kIGZlYXR1cmUuXG4gICAgICovXG4gICAgcXVlcnlTb3VyY2VGZWF0dXJlczogZnVuY3Rpb24oc291cmNlSUQsIHBhcmFtcykge1xuICAgICAgICB2YXIgc291cmNlID0gdGhpcy5nZXRTb3VyY2Uoc291cmNlSUQpO1xuICAgICAgICByZXR1cm4gc291cmNlICYmIHNvdXJjZS5xdWVyeVNvdXJjZUZlYXR1cmVzID9cbiAgICAgICAgICAgIHNvdXJjZS5xdWVyeVNvdXJjZUZlYXR1cmVzKHBhcmFtcykgOlxuICAgICAgICAgICAgW107XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFwcGx5IG11bHRpcGxlIHN0eWxlIG11dGF0aW9ucyBpbiBhIGJhdGNoXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSB3b3JrIEZ1bmN0aW9uIHdoaWNoIGFjY2VwdHMgYSBgU3R5bGVCYXRjaGAgb2JqZWN0LFxuICAgICAqICAgICAgYSBzdWJzZXQgb2YgYE1hcGAsIHdpdGggYGFkZExheWVyYCwgYHJlbW92ZUxheWVyYCxcbiAgICAgKiAgICAgIGBzZXRQYWludFByb3BlcnR5YCwgYHNldExheW91dFByb3BlcnR5YCwgYHNldEZpbHRlcmAsXG4gICAgICogICAgICBgc2V0TGF5ZXJab29tUmFuZ2VgLCBgYWRkU291cmNlYCwgYW5kIGByZW1vdmVTb3VyY2VgXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIG1hcC5iYXRjaChmdW5jdGlvbiAoYmF0Y2gpIHtcbiAgICAgKiAgICAgYmF0Y2guYWRkTGF5ZXIobGF5ZXIxKTtcbiAgICAgKiAgICAgYmF0Y2guYWRkTGF5ZXIobGF5ZXIyKTtcbiAgICAgKiAgICAgLi4uXG4gICAgICogICAgIGJhdGNoLmFkZExheWVyKGxheWVyTik7XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKi9cbiAgICBiYXRjaDogZnVuY3Rpb24od29yaykge1xuICAgICAgICB0aGlzLnN0eWxlLmJhdGNoKHdvcmspO1xuXG4gICAgICAgIHRoaXMuc3R5bGUuX2Nhc2NhZGUodGhpcy5fY2xhc3Nlcyk7XG4gICAgICAgIHRoaXMuX3VwZGF0ZSh0cnVlKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVwbGFjZXMgdGhlIG1hcCdzIHN0eWxlIG9iamVjdFxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHN0eWxlIEEgc3R5bGUgb2JqZWN0IGZvcm1hdHRlZCBhcyBKU09OXG4gICAgICogQHJldHVybnMge01hcH0gYHRoaXNgXG4gICAgICovXG4gICAgc2V0U3R5bGU6IGZ1bmN0aW9uKHN0eWxlKSB7XG4gICAgICAgIGlmICh0aGlzLnN0eWxlKSB7XG4gICAgICAgICAgICB0aGlzLnN0eWxlXG4gICAgICAgICAgICAgICAgLm9mZignbG9hZCcsIHRoaXMuX29uU3R5bGVMb2FkKVxuICAgICAgICAgICAgICAgIC5vZmYoJ2Vycm9yJywgdGhpcy5fZm9yd2FyZFN0eWxlRXZlbnQpXG4gICAgICAgICAgICAgICAgLm9mZignY2hhbmdlJywgdGhpcy5fb25TdHlsZUNoYW5nZSlcbiAgICAgICAgICAgICAgICAub2ZmKCdzb3VyY2UuYWRkJywgdGhpcy5fb25Tb3VyY2VBZGQpXG4gICAgICAgICAgICAgICAgLm9mZignc291cmNlLnJlbW92ZScsIHRoaXMuX29uU291cmNlUmVtb3ZlKVxuICAgICAgICAgICAgICAgIC5vZmYoJ3NvdXJjZS5sb2FkJywgdGhpcy5fb25Tb3VyY2VVcGRhdGUpXG4gICAgICAgICAgICAgICAgLm9mZignc291cmNlLmVycm9yJywgdGhpcy5fZm9yd2FyZFNvdXJjZUV2ZW50KVxuICAgICAgICAgICAgICAgIC5vZmYoJ3NvdXJjZS5jaGFuZ2UnLCB0aGlzLl9vblNvdXJjZVVwZGF0ZSlcbiAgICAgICAgICAgICAgICAub2ZmKCdsYXllci5hZGQnLCB0aGlzLl9mb3J3YXJkTGF5ZXJFdmVudClcbiAgICAgICAgICAgICAgICAub2ZmKCdsYXllci5yZW1vdmUnLCB0aGlzLl9mb3J3YXJkTGF5ZXJFdmVudClcbiAgICAgICAgICAgICAgICAub2ZmKCdsYXllci5lcnJvcicsIHRoaXMuX2ZvcndhcmRMYXllckV2ZW50KVxuICAgICAgICAgICAgICAgIC5vZmYoJ3RpbGUuYWRkJywgdGhpcy5fZm9yd2FyZFRpbGVFdmVudClcbiAgICAgICAgICAgICAgICAub2ZmKCd0aWxlLnJlbW92ZScsIHRoaXMuX2ZvcndhcmRUaWxlRXZlbnQpXG4gICAgICAgICAgICAgICAgLm9mZigndGlsZS5sb2FkJywgdGhpcy5fdXBkYXRlKVxuICAgICAgICAgICAgICAgIC5vZmYoJ3RpbGUuZXJyb3InLCB0aGlzLl9mb3J3YXJkVGlsZUV2ZW50KVxuICAgICAgICAgICAgICAgIC5vZmYoJ3RpbGUuc3RhdHMnLCB0aGlzLl9mb3J3YXJkVGlsZUV2ZW50KVxuICAgICAgICAgICAgICAgIC5fcmVtb3ZlKCk7XG5cbiAgICAgICAgICAgIHRoaXMub2ZmKCdyb3RhdGUnLCB0aGlzLnN0eWxlLl9yZWRvUGxhY2VtZW50KTtcbiAgICAgICAgICAgIHRoaXMub2ZmKCdwaXRjaCcsIHRoaXMuc3R5bGUuX3JlZG9QbGFjZW1lbnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFzdHlsZSkge1xuICAgICAgICAgICAgdGhpcy5zdHlsZSA9IG51bGw7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSBlbHNlIGlmIChzdHlsZSBpbnN0YW5jZW9mIFN0eWxlKSB7XG4gICAgICAgICAgICB0aGlzLnN0eWxlID0gc3R5bGU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnN0eWxlID0gbmV3IFN0eWxlKHN0eWxlLCB0aGlzLmFuaW1hdGlvbkxvb3ApO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5zdHlsZVxuICAgICAgICAgICAgLm9uKCdsb2FkJywgdGhpcy5fb25TdHlsZUxvYWQpXG4gICAgICAgICAgICAub24oJ2Vycm9yJywgdGhpcy5fZm9yd2FyZFN0eWxlRXZlbnQpXG4gICAgICAgICAgICAub24oJ2NoYW5nZScsIHRoaXMuX29uU3R5bGVDaGFuZ2UpXG4gICAgICAgICAgICAub24oJ3NvdXJjZS5hZGQnLCB0aGlzLl9vblNvdXJjZUFkZClcbiAgICAgICAgICAgIC5vbignc291cmNlLnJlbW92ZScsIHRoaXMuX29uU291cmNlUmVtb3ZlKVxuICAgICAgICAgICAgLm9uKCdzb3VyY2UubG9hZCcsIHRoaXMuX29uU291cmNlVXBkYXRlKVxuICAgICAgICAgICAgLm9uKCdzb3VyY2UuZXJyb3InLCB0aGlzLl9mb3J3YXJkU291cmNlRXZlbnQpXG4gICAgICAgICAgICAub24oJ3NvdXJjZS5jaGFuZ2UnLCB0aGlzLl9vblNvdXJjZVVwZGF0ZSlcbiAgICAgICAgICAgIC5vbignbGF5ZXIuYWRkJywgdGhpcy5fZm9yd2FyZExheWVyRXZlbnQpXG4gICAgICAgICAgICAub24oJ2xheWVyLnJlbW92ZScsIHRoaXMuX2ZvcndhcmRMYXllckV2ZW50KVxuICAgICAgICAgICAgLm9uKCdsYXllci5lcnJvcicsIHRoaXMuX2ZvcndhcmRMYXllckV2ZW50KVxuICAgICAgICAgICAgLm9uKCd0aWxlLmFkZCcsIHRoaXMuX2ZvcndhcmRUaWxlRXZlbnQpXG4gICAgICAgICAgICAub24oJ3RpbGUucmVtb3ZlJywgdGhpcy5fZm9yd2FyZFRpbGVFdmVudClcbiAgICAgICAgICAgIC5vbigndGlsZS5sb2FkJywgdGhpcy5fdXBkYXRlKVxuICAgICAgICAgICAgLm9uKCd0aWxlLmVycm9yJywgdGhpcy5fZm9yd2FyZFRpbGVFdmVudClcbiAgICAgICAgICAgIC5vbigndGlsZS5zdGF0cycsIHRoaXMuX2ZvcndhcmRUaWxlRXZlbnQpO1xuXG4gICAgICAgIHRoaXMub24oJ3JvdGF0ZScsIHRoaXMuc3R5bGUuX3JlZG9QbGFjZW1lbnQpO1xuICAgICAgICB0aGlzLm9uKCdwaXRjaCcsIHRoaXMuc3R5bGUuX3JlZG9QbGFjZW1lbnQpO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgYSBzdHlsZSBvYmplY3QgdGhhdCBjYW4gYmUgdXNlZCB0byByZWNyZWF0ZSB0aGUgbWFwJ3Mgc3R5bGVcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IHN0eWxlXG4gICAgICovXG4gICAgZ2V0U3R5bGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdHlsZS5zZXJpYWxpemUoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQWRkIGEgc291cmNlIHRvIHRoZSBtYXAgc3R5bGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gaWQgSUQgb2YgdGhlIHNvdXJjZS4gTXVzdCBub3QgYmUgdXNlZCBieSBhbnkgZXhpc3Rpbmcgc291cmNlLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2Ugc291cmNlIHNwZWNpZmljYXRpb24sIGZvbGxvd2luZyB0aGVcbiAgICAgKiBbTWFwYm94IEdMIFN0eWxlIFJlZmVyZW5jZV0oaHR0cHM6Ly93d3cubWFwYm94LmNvbS9tYXBib3gtZ2wtc3R5bGUtc3BlYy8jc291cmNlcylcbiAgICAgKiBAZmlyZXMgc291cmNlLmFkZFxuICAgICAqIEByZXR1cm5zIHtNYXB9IGB0aGlzYFxuICAgICAqL1xuICAgIGFkZFNvdXJjZTogZnVuY3Rpb24oaWQsIHNvdXJjZSkge1xuICAgICAgICB0aGlzLnN0eWxlLmFkZFNvdXJjZShpZCwgc291cmNlKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlbW92ZSBhbiBleGlzdGluZyBzb3VyY2UgZnJvbSB0aGUgbWFwIHN0eWxlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGlkIElEIG9mIHRoZSBzb3VyY2UgdG8gcmVtb3ZlXG4gICAgICogQGZpcmVzIHNvdXJjZS5yZW1vdmVcbiAgICAgKiBAcmV0dXJucyB7TWFwfSBgdGhpc2BcbiAgICAgKi9cbiAgICByZW1vdmVTb3VyY2U6IGZ1bmN0aW9uKGlkKSB7XG4gICAgICAgIHRoaXMuc3R5bGUucmVtb3ZlU291cmNlKGlkKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybiB0aGUgc3R5bGUgc291cmNlIG9iamVjdCB3aXRoIHRoZSBnaXZlbiBgaWRgLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGlkIHNvdXJjZSBJRFxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgICovXG4gICAgZ2V0U291cmNlOiBmdW5jdGlvbihpZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdHlsZS5nZXRTb3VyY2UoaWQpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBZGQgYSBsYXllciB0byB0aGUgbWFwIHN0eWxlLiBUaGUgbGF5ZXIgd2lsbCBiZSBpbnNlcnRlZCBiZWZvcmUgdGhlIGxheWVyIHdpdGhcbiAgICAgKiBJRCBgYmVmb3JlYCwgb3IgYXBwZW5kZWQgaWYgYGJlZm9yZWAgaXMgb21pdHRlZC5cbiAgICAgKiBAcGFyYW0ge1N0eWxlTGF5ZXJ8T2JqZWN0fSBsYXllclxuICAgICAqIEBwYXJhbSB7c3RyaW5nPX0gYmVmb3JlICBJRCBvZiBhbiBleGlzdGluZyBsYXllciB0byBpbnNlcnQgYmVmb3JlXG4gICAgICogQGZpcmVzIGxheWVyLmFkZFxuICAgICAqIEByZXR1cm5zIHtNYXB9IGB0aGlzYFxuICAgICAqL1xuICAgIGFkZExheWVyOiBmdW5jdGlvbihsYXllciwgYmVmb3JlKSB7XG4gICAgICAgIHRoaXMuc3R5bGUuYWRkTGF5ZXIobGF5ZXIsIGJlZm9yZSk7XG4gICAgICAgIHRoaXMuc3R5bGUuX2Nhc2NhZGUodGhpcy5fY2xhc3Nlcyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmUgdGhlIGxheWVyIHdpdGggdGhlIGdpdmVuIGBpZGAgZnJvbSB0aGUgbWFwLiBBbnkgbGF5ZXJzIHdoaWNoIHJlZmVyIHRvIHRoZVxuICAgICAqIHNwZWNpZmllZCBsYXllciB2aWEgYSBgcmVmYCBwcm9wZXJ0eSBhcmUgYWxzbyByZW1vdmVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGlkIGxheWVyIGlkXG4gICAgICogQHRocm93cyB7RXJyb3J9IGlmIG5vIGxheWVyIHdpdGggdGhlIGdpdmVuIGBpZGAgZXhpc3RzXG4gICAgICogQGZpcmVzIGxheWVyLnJlbW92ZVxuICAgICAqIEByZXR1cm5zIHtNYXB9IGB0aGlzYFxuICAgICAqL1xuICAgIHJlbW92ZUxheWVyOiBmdW5jdGlvbihpZCkge1xuICAgICAgICB0aGlzLnN0eWxlLnJlbW92ZUxheWVyKGlkKTtcbiAgICAgICAgdGhpcy5zdHlsZS5fY2FzY2FkZSh0aGlzLl9jbGFzc2VzKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybiB0aGUgc3R5bGUgbGF5ZXIgb2JqZWN0IHdpdGggdGhlIGdpdmVuIGBpZGAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gaWQgbGF5ZXIgaWRcbiAgICAgKiBAcmV0dXJucyB7P09iamVjdH0gYSBsYXllciwgaWYgb25lIHdpdGggdGhlIGdpdmVuIGBpZGAgZXhpc3RzXG4gICAgICovXG4gICAgZ2V0TGF5ZXI6IGZ1bmN0aW9uKGlkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0eWxlLmdldExheWVyKGlkKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0IHRoZSBmaWx0ZXIgZm9yIGEgZ2l2ZW4gc3R5bGUgbGF5ZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbGF5ZXIgSUQgb2YgYSBsYXllclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGZpbHRlciBmaWx0ZXIgc3BlY2lmaWNhdGlvbiwgYXMgZGVmaW5lZCBpbiB0aGUgW1N0eWxlIFNwZWNpZmljYXRpb25dKGh0dHBzOi8vd3d3Lm1hcGJveC5jb20vbWFwYm94LWdsLXN0eWxlLXNwZWMvI3R5cGVzLWZpbHRlcilcbiAgICAgKiBAcmV0dXJucyB7TWFwfSBgdGhpc2BcbiAgICAgKi9cbiAgICBzZXRGaWx0ZXI6IGZ1bmN0aW9uKGxheWVyLCBmaWx0ZXIpIHtcbiAgICAgICAgdGhpcy5zdHlsZS5zZXRGaWx0ZXIobGF5ZXIsIGZpbHRlcik7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIHpvb20gZXh0ZW50IGZvciBhIGdpdmVuIHN0eWxlIGxheWVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGxheWVySWQgSUQgb2YgYSBsYXllclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBtaW56b29tIG1pbmltdW0gem9vbSBleHRlbnRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbWF4em9vbSBtYXhpbXVtIHpvb20gZXh0ZW50XG4gICAgICogQHJldHVybnMge01hcH0gYHRoaXNgXG4gICAgICovXG4gICAgc2V0TGF5ZXJab29tUmFuZ2U6IGZ1bmN0aW9uKGxheWVySWQsIG1pbnpvb20sIG1heHpvb20pIHtcbiAgICAgICAgdGhpcy5zdHlsZS5zZXRMYXllclpvb21SYW5nZShsYXllcklkLCBtaW56b29tLCBtYXh6b29tKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgZmlsdGVyIGZvciBhIGdpdmVuIHN0eWxlIGxheWVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGxheWVyIElEIG9mIGEgbGF5ZXJcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IGZpbHRlciBzcGVjaWZpY2F0aW9uLCBhcyBkZWZpbmVkIGluIHRoZSBbU3R5bGUgU3BlY2lmaWNhdGlvbl0oaHR0cHM6Ly93d3cubWFwYm94LmNvbS9tYXBib3gtZ2wtc3R5bGUtc3BlYy8jZmlsdGVyKVxuICAgICAqL1xuICAgIGdldEZpbHRlcjogZnVuY3Rpb24obGF5ZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3R5bGUuZ2V0RmlsdGVyKGxheWVyKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0IHRoZSB2YWx1ZSBvZiBhIHBhaW50IHByb3BlcnR5IGluIGEgZ2l2ZW4gc3R5bGUgbGF5ZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbGF5ZXIgSUQgb2YgYSBsYXllclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIG5hbWUgb2YgYSBwYWludCBwcm9wZXJ0eVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgdmFsdWUgZm9yIHRoZSBwYWludCBwcm9wZXJ5OyBtdXN0IGhhdmUgdGhlIHR5cGUgYXBwcm9wcmlhdGUgZm9yIHRoZSBwcm9wZXJ0eSBhcyBkZWZpbmVkIGluIHRoZSBbU3R5bGUgU3BlY2lmaWNhdGlvbl0oaHR0cHM6Ly93d3cubWFwYm94LmNvbS9tYXBib3gtZ2wtc3R5bGUtc3BlYy8pXG4gICAgICogQHBhcmFtIHtzdHJpbmc9fSBrbGFzcyBvcHRpb25hbCBjbGFzcyBzcGVjaWZpZXIgZm9yIHRoZSBwcm9wZXJ0eVxuICAgICAqIEByZXR1cm5zIHtNYXB9IGB0aGlzYFxuICAgICAqL1xuICAgIHNldFBhaW50UHJvcGVydHk6IGZ1bmN0aW9uKGxheWVyLCBuYW1lLCB2YWx1ZSwga2xhc3MpIHtcbiAgICAgICAgdGhpcy5iYXRjaChmdW5jdGlvbihiYXRjaCkge1xuICAgICAgICAgICAgYmF0Y2guc2V0UGFpbnRQcm9wZXJ0eShsYXllciwgbmFtZSwgdmFsdWUsIGtsYXNzKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgdmFsdWUgb2YgYSBwYWludCBwcm9wZXJ0eSBpbiBhIGdpdmVuIHN0eWxlIGxheWVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGxheWVyIElEIG9mIGEgbGF5ZXJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBuYW1lIG9mIGEgcGFpbnQgcHJvcGVydHlcbiAgICAgKiBAcGFyYW0ge3N0cmluZz19IGtsYXNzIG9wdGlvbmFsIGNsYXNzIHNwZWNpZmllciBmb3IgdGhlIHByb3BlcnR5XG4gICAgICogQHJldHVybnMgeyp9IHZhbHVlIGZvciB0aGUgcGFpbnQgcHJvcGVyeVxuICAgICAqL1xuICAgIGdldFBhaW50UHJvcGVydHk6IGZ1bmN0aW9uKGxheWVyLCBuYW1lLCBrbGFzcykge1xuICAgICAgICByZXR1cm4gdGhpcy5zdHlsZS5nZXRQYWludFByb3BlcnR5KGxheWVyLCBuYW1lLCBrbGFzcyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgdmFsdWUgb2YgYSBsYXlvdXQgcHJvcGVydHkgaW4gYSBnaXZlbiBzdHlsZSBsYXllci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBsYXllciBJRCBvZiBhIGxheWVyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgbmFtZSBvZiBhIGxheW91dCBwcm9wZXJ0eVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgdmFsdWUgZm9yIHRoZSBsYXlvdXQgcHJvcGVyeTsgbXVzdCBoYXZlIHRoZSB0eXBlIGFwcHJvcHJpYXRlIGZvciB0aGUgcHJvcGVydHkgYXMgZGVmaW5lZCBpbiB0aGUgW1N0eWxlIFNwZWNpZmljYXRpb25dKGh0dHBzOi8vd3d3Lm1hcGJveC5jb20vbWFwYm94LWdsLXN0eWxlLXNwZWMvKVxuICAgICAqIEByZXR1cm5zIHtNYXB9IGB0aGlzYFxuICAgICAqL1xuICAgIHNldExheW91dFByb3BlcnR5OiBmdW5jdGlvbihsYXllciwgbmFtZSwgdmFsdWUpIHtcbiAgICAgICAgdGhpcy5iYXRjaChmdW5jdGlvbihiYXRjaCkge1xuICAgICAgICAgICAgYmF0Y2guc2V0TGF5b3V0UHJvcGVydHkobGF5ZXIsIG5hbWUsIHZhbHVlKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgdmFsdWUgb2YgYSBsYXlvdXQgcHJvcGVydHkgaW4gYSBnaXZlbiBzdHlsZSBsYXllci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBsYXllciBJRCBvZiBhIGxheWVyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgbmFtZSBvZiBhIGxheW91dCBwcm9wZXJ0eVxuICAgICAqIEBwYXJhbSB7c3RyaW5nPX0ga2xhc3Mgb3B0aW9uYWwgY2xhc3Mgc3BlY2lmaWVyIGZvciB0aGUgcHJvcGVydHlcbiAgICAgKiBAcmV0dXJucyB7Kn0gdmFsdWUgZm9yIHRoZSBsYXlvdXQgcHJvcGVyeVxuICAgICAqL1xuICAgIGdldExheW91dFByb3BlcnR5OiBmdW5jdGlvbihsYXllciwgbmFtZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdHlsZS5nZXRMYXlvdXRQcm9wZXJ0eShsYXllciwgbmFtZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgTWFwJ3MgY29udGFpbmVyIGFzIGFuIEhUTUwgZWxlbWVudFxuICAgICAqIEByZXR1cm5zIHtIVE1MRWxlbWVudH0gY29udGFpbmVyXG4gICAgICovXG4gICAgZ2V0Q29udGFpbmVyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvbnRhaW5lcjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBjb250YWluZXIgZm9yIHRoZSBtYXAgYGNhbnZhc2AgZWxlbWVudC5cbiAgICAgKlxuICAgICAqIElmIHlvdSB3YW50IHRvIGFkZCBub24tR0wgb3ZlcmxheXMgdG8gdGhlIG1hcCwgeW91IHNob3VsZCBhcHBlbmQgdGhlbSB0byB0aGlzIGVsZW1lbnQuIFRoaXNcbiAgICAgKiBpcyB0aGUgZWxlbWVudCB0byB3aGljaCBldmVudCBiaW5kaW5ncyBmb3IgbWFwIGludGVyYWN0aXZpdHkgc3VjaCBhcyBwYW5uaW5nIGFuZCB6b29taW5nIGFyZVxuICAgICAqIGF0dGFjaGVkLiBJdCB3aWxsIHJlY2VpdmUgYnViYmxlZCBldmVudHMgZm9yIGNoaWxkIGVsZW1lbnRzIHN1Y2ggYXMgdGhlIGBjYW52YXNgLCBidXQgbm90IGZvclxuICAgICAqIG1hcCBjb250cm9scy5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtIVE1MRWxlbWVudH0gY29udGFpbmVyXG4gICAgICovXG4gICAgZ2V0Q2FudmFzQ29udGFpbmVyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NhbnZhc0NvbnRhaW5lcjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBNYXAncyBjYW52YXMgYXMgYW4gSFRNTCBjYW52YXNcbiAgICAgKiBAcmV0dXJucyB7SFRNTEVsZW1lbnR9IGNhbnZhc1xuICAgICAqL1xuICAgIGdldENhbnZhczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jYW52YXMuZ2V0RWxlbWVudCgpO1xuICAgIH0sXG5cbiAgICBfc2V0dXBDb250YWluZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgY29udGFpbmVyID0gdGhpcy5fY29udGFpbmVyO1xuICAgICAgICBjb250YWluZXIuY2xhc3NMaXN0LmFkZCgnbWFwYm94Z2wtbWFwJyk7XG5cbiAgICAgICAgdmFyIGNhbnZhc0NvbnRhaW5lciA9IHRoaXMuX2NhbnZhc0NvbnRhaW5lciA9IERPTS5jcmVhdGUoJ2RpdicsICdtYXBib3hnbC1jYW52YXMtY29udGFpbmVyJywgY29udGFpbmVyKTtcbiAgICAgICAgaWYgKHRoaXMuX2ludGVyYWN0aXZlKSB7XG4gICAgICAgICAgICBjYW52YXNDb250YWluZXIuY2xhc3NMaXN0LmFkZCgnbWFwYm94Z2wtaW50ZXJhY3RpdmUnKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9jYW52YXMgPSBuZXcgQ2FudmFzKHRoaXMsIGNhbnZhc0NvbnRhaW5lcik7XG5cbiAgICAgICAgdmFyIGNvbnRyb2xDb250YWluZXIgPSB0aGlzLl9jb250cm9sQ29udGFpbmVyID0gRE9NLmNyZWF0ZSgnZGl2JywgJ21hcGJveGdsLWNvbnRyb2wtY29udGFpbmVyJywgY29udGFpbmVyKTtcbiAgICAgICAgdmFyIGNvcm5lcnMgPSB0aGlzLl9jb250cm9sQ29ybmVycyA9IHt9O1xuICAgICAgICBbJ3RvcC1sZWZ0JywgJ3RvcC1yaWdodCcsICdib3R0b20tbGVmdCcsICdib3R0b20tcmlnaHQnXS5mb3JFYWNoKGZ1bmN0aW9uIChwb3MpIHtcbiAgICAgICAgICAgIGNvcm5lcnNbcG9zXSA9IERPTS5jcmVhdGUoJ2RpdicsICdtYXBib3hnbC1jdHJsLScgKyBwb3MsIGNvbnRyb2xDb250YWluZXIpO1xuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgX3NldHVwUGFpbnRlcjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBnbCA9IHRoaXMuX2NhbnZhcy5nZXRXZWJHTENvbnRleHQoe1xuICAgICAgICAgICAgZmFpbElmTWFqb3JQZXJmb3JtYW5jZUNhdmVhdDogdGhpcy5fZmFpbElmTWFqb3JQZXJmb3JtYW5jZUNhdmVhdCxcbiAgICAgICAgICAgIHByZXNlcnZlRHJhd2luZ0J1ZmZlcjogdGhpcy5fcHJlc2VydmVEcmF3aW5nQnVmZmVyXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmICghZ2wpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBpbml0aWFsaXplIFdlYkdMJyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnBhaW50ZXIgPSBuZXcgUGFpbnRlcihnbCwgdGhpcy50cmFuc2Zvcm0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBXZWJHTCBDb250ZXh0IExvc3QgZXZlbnQuXG4gICAgICpcbiAgICAgKiBAZXZlbnQgd2ViZ2xjb250ZXh0bG9zdFxuICAgICAqIEBtZW1iZXJvZiBNYXBcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqIEBwcm9wZXJ0eSB7RXZlbnR9IG9yaWdpbmFsRXZlbnQgdGhlIG9yaWdpbmFsIERPTSBldmVudFxuICAgICAqL1xuICAgIF9jb250ZXh0TG9zdDogZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgaWYgKHRoaXMuX2ZyYW1lSWQpIHtcbiAgICAgICAgICAgIGJyb3dzZXIuY2FuY2VsRnJhbWUodGhpcy5fZnJhbWVJZCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5maXJlKFwid2ViZ2xjb250ZXh0bG9zdFwiLCB7b3JpZ2luYWxFdmVudDogZXZlbnR9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogV2ViR0wgQ29udGV4dCBSZXN0b3JlZCBldmVudC5cbiAgICAgKlxuICAgICAqIEBldmVudCB3ZWJnbGNvbnRleHRyZXN0b3JlZFxuICAgICAqIEBtZW1iZXJvZiBNYXBcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqL1xuICAgIF9jb250ZXh0UmVzdG9yZWQ6IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgIHRoaXMuX3NldHVwUGFpbnRlcigpO1xuICAgICAgICB0aGlzLnJlc2l6ZSgpO1xuICAgICAgICB0aGlzLl91cGRhdGUoKTtcbiAgICAgICAgdGhpcy5maXJlKFwid2ViZ2xjb250ZXh0cmVzdG9yZWRcIiwge29yaWdpbmFsRXZlbnQ6IGV2ZW50fSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIElzIHRoaXMgbWFwIGZ1bGx5IGxvYWRlZD8gSWYgdGhlIHN0eWxlIGlzbid0IGxvYWRlZFxuICAgICAqIG9yIGl0IGhhcyBhIGNoYW5nZSB0byB0aGUgc291cmNlcyBvciBzdHlsZSB0aGF0IGlzbid0XG4gICAgICogcHJvcGFnYXRlZCB0byBpdHMgc3R5bGUsIHJldHVybiBmYWxzZS5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSB3aGV0aGVyIHRoZSBtYXAgaXMgbG9hZGVkXG4gICAgICovXG4gICAgbG9hZGVkOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuX3N0eWxlRGlydHkgfHwgdGhpcy5fc291cmNlc0RpcnR5KVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAoIXRoaXMuc3R5bGUgfHwgIXRoaXMuc3R5bGUubG9hZGVkKCkpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgdGhpcyBtYXAncyBzdHlsZSBhbmQgc291cmNlcywgYW5kIHJlLXJlbmRlciB0aGUgbWFwLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtib29sZWFufSB1cGRhdGVTdHlsZSBtYXJrIHRoZSBtYXAncyBzdHlsZSBmb3IgcmVwcm9jZXNzaW5nIGFzXG4gICAgICogd2VsbCBhcyBpdHMgc291cmNlc1xuICAgICAqIEByZXR1cm5zIHtNYXB9IHRoaXNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF91cGRhdGU6IGZ1bmN0aW9uKHVwZGF0ZVN0eWxlKSB7XG4gICAgICAgIGlmICghdGhpcy5zdHlsZSkgcmV0dXJuIHRoaXM7XG5cbiAgICAgICAgdGhpcy5fc3R5bGVEaXJ0eSA9IHRoaXMuX3N0eWxlRGlydHkgfHwgdXBkYXRlU3R5bGU7XG4gICAgICAgIHRoaXMuX3NvdXJjZXNEaXJ0eSA9IHRydWU7XG5cbiAgICAgICAgdGhpcy5fcmVyZW5kZXIoKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2FsbCB3aGVuIGEgKHJlLSlyZW5kZXIgb2YgdGhlIG1hcCBpcyByZXF1aXJlZCwgZS5nLiB3aGVuIHRoZVxuICAgICAqIHVzZXIgcGFubmVkIG9yIHpvb21lZCxmIG9yIG5ldyBkYXRhIGlzIGF2YWlsYWJsZS5cbiAgICAgKiBAcmV0dXJucyB7TWFwfSB0aGlzXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfcmVuZGVyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuc3R5bGUgJiYgdGhpcy5fc3R5bGVEaXJ0eSkge1xuICAgICAgICAgICAgdGhpcy5fc3R5bGVEaXJ0eSA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5zdHlsZS5fcmVjYWxjdWxhdGUodGhpcy50cmFuc2Zvcm0uem9vbSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5zdHlsZSAmJiB0aGlzLl9zb3VyY2VzRGlydHkpIHtcbiAgICAgICAgICAgIHRoaXMuX3NvdXJjZXNEaXJ0eSA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5zdHlsZS5fdXBkYXRlU291cmNlcyh0aGlzLnRyYW5zZm9ybSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnBhaW50ZXIucmVuZGVyKHRoaXMuc3R5bGUsIHtcbiAgICAgICAgICAgIGRlYnVnOiB0aGlzLnNob3dUaWxlQm91bmRhcmllcyxcbiAgICAgICAgICAgIHZlcnRpY2VzOiB0aGlzLnZlcnRpY2VzLFxuICAgICAgICAgICAgcm90YXRpbmc6IHRoaXMucm90YXRpbmcsXG4gICAgICAgICAgICB6b29taW5nOiB0aGlzLnpvb21pbmdcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5maXJlKCdyZW5kZXInKTtcblxuICAgICAgICBpZiAodGhpcy5sb2FkZWQoKSAmJiAhdGhpcy5fbG9hZGVkKSB7XG4gICAgICAgICAgICB0aGlzLl9sb2FkZWQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5maXJlKCdsb2FkJyk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9mcmFtZUlkID0gbnVsbDtcblxuICAgICAgICBpZiAoIXRoaXMuYW5pbWF0aW9uTG9vcC5zdG9wcGVkKCkpIHtcbiAgICAgICAgICAgIHRoaXMuX3N0eWxlRGlydHkgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuX3NvdXJjZXNEaXJ0eSB8fCB0aGlzLl9yZXBhaW50IHx8ICF0aGlzLmFuaW1hdGlvbkxvb3Auc3RvcHBlZCgpKSB7XG4gICAgICAgICAgICB0aGlzLl9yZXJlbmRlcigpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIERlc3Ryb3lzIHRoZSBtYXAncyB1bmRlcmx5aW5nIHJlc291cmNlcywgaW5jbHVkaW5nIHdlYiB3b3JrZXJzIGFuZCBET00gZWxlbWVudHMuIEFmdGVyd2FyZHMsXG4gICAgICogeW91IG11c3Qgbm90IGNhbGwgYW55IGZ1cnRoZXIgbWV0aG9kcyBvbiB0aGlzIE1hcCBpbnN0YW5jZS5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gICAgICovXG4gICAgcmVtb3ZlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuX2hhc2gpIHRoaXMuX2hhc2gucmVtb3ZlKCk7XG4gICAgICAgIGJyb3dzZXIuY2FuY2VsRnJhbWUodGhpcy5fZnJhbWVJZCk7XG4gICAgICAgIHRoaXMuc2V0U3R5bGUobnVsbCk7XG4gICAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHRoaXMuX29uV2luZG93UmVzaXplLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmVtb3ZlTm9kZSh0aGlzLl9jYW52YXNDb250YWluZXIpO1xuICAgICAgICByZW1vdmVOb2RlKHRoaXMuX2NvbnRyb2xDb250YWluZXIpO1xuICAgICAgICB0aGlzLl9jb250YWluZXIuY2xhc3NMaXN0LnJlbW92ZSgnbWFwYm94Z2wtbWFwJyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEEgZGVmYXVsdCBlcnJvciBoYW5kbGVyIGZvciBgc3R5bGUuZXJyb3JgLCBgc291cmNlLmVycm9yYCwgYGxheWVyLmVycm9yYCxcbiAgICAgKiBhbmQgYHRpbGUuZXJyb3JgIGV2ZW50cy5cbiAgICAgKiBJdCBsb2dzIHRoZSBlcnJvciB2aWEgYGNvbnNvbGUuZXJyb3JgLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBEaXNhYmxlIHRoZSBkZWZhdWx0IGVycm9yIGhhbmRsZXJcbiAgICAgKiBtYXAub2ZmKCdzdHlsZS5lcnJvcicsIG1hcC5vbkVycm9yKTtcbiAgICAgKiBtYXAub2ZmKCdzb3VyY2UuZXJyb3InLCBtYXAub25FcnJvcik7XG4gICAgICogbWFwLm9mZigndGlsZS5lcnJvcicsIG1hcC5vbkVycm9yKTtcbiAgICAgKiBtYXAub2ZmKCdsYXllci5lcnJvcicsIG1hcC5vbkVycm9yKTtcbiAgICAgKi9cbiAgICBvbkVycm9yOiBmdW5jdGlvbihlKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoZS5lcnJvcik7XG4gICAgfSxcblxuICAgIF9yZXJlbmRlcjogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLnN0eWxlICYmICF0aGlzLl9mcmFtZUlkKSB7XG4gICAgICAgICAgICB0aGlzLl9mcmFtZUlkID0gYnJvd3Nlci5mcmFtZSh0aGlzLl9yZW5kZXIpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIF9mb3J3YXJkU3R5bGVFdmVudDogZnVuY3Rpb24oZSkge1xuICAgICAgICB0aGlzLmZpcmUoJ3N0eWxlLicgKyBlLnR5cGUsIHV0aWwuZXh0ZW5kKHtzdHlsZTogZS50YXJnZXR9LCBlKSk7XG4gICAgfSxcblxuICAgIF9mb3J3YXJkU291cmNlRXZlbnQ6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgdGhpcy5maXJlKGUudHlwZSwgdXRpbC5leHRlbmQoe3N0eWxlOiBlLnRhcmdldH0sIGUpKTtcbiAgICB9LFxuXG4gICAgX2ZvcndhcmRMYXllckV2ZW50OiBmdW5jdGlvbihlKSB7XG4gICAgICAgIHRoaXMuZmlyZShlLnR5cGUsIHV0aWwuZXh0ZW5kKHtzdHlsZTogZS50YXJnZXR9LCBlKSk7XG4gICAgfSxcblxuICAgIF9mb3J3YXJkVGlsZUV2ZW50OiBmdW5jdGlvbihlKSB7XG4gICAgICAgIHRoaXMuZmlyZShlLnR5cGUsIHV0aWwuZXh0ZW5kKHtzdHlsZTogZS50YXJnZXR9LCBlKSk7XG4gICAgfSxcblxuICAgIF9vblN0eWxlTG9hZDogZnVuY3Rpb24oZSkge1xuICAgICAgICBpZiAodGhpcy50cmFuc2Zvcm0udW5tb2RpZmllZCkge1xuICAgICAgICAgICAgdGhpcy5qdW1wVG8odGhpcy5zdHlsZS5zdHlsZXNoZWV0KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN0eWxlLl9jYXNjYWRlKHRoaXMuX2NsYXNzZXMsIHt0cmFuc2l0aW9uOiBmYWxzZX0pO1xuICAgICAgICB0aGlzLl9mb3J3YXJkU3R5bGVFdmVudChlKTtcbiAgICB9LFxuXG4gICAgX29uU3R5bGVDaGFuZ2U6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgdGhpcy5fdXBkYXRlKHRydWUpO1xuICAgICAgICB0aGlzLl9mb3J3YXJkU3R5bGVFdmVudChlKTtcbiAgICB9LFxuXG4gICAgX29uU291cmNlQWRkOiBmdW5jdGlvbihlKSB7XG4gICAgICAgIHZhciBzb3VyY2UgPSBlLnNvdXJjZTtcbiAgICAgICAgaWYgKHNvdXJjZS5vbkFkZClcbiAgICAgICAgICAgIHNvdXJjZS5vbkFkZCh0aGlzKTtcbiAgICAgICAgdGhpcy5fZm9yd2FyZFNvdXJjZUV2ZW50KGUpO1xuICAgIH0sXG5cbiAgICBfb25Tb3VyY2VSZW1vdmU6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgdmFyIHNvdXJjZSA9IGUuc291cmNlO1xuICAgICAgICBpZiAoc291cmNlLm9uUmVtb3ZlKVxuICAgICAgICAgICAgc291cmNlLm9uUmVtb3ZlKHRoaXMpO1xuICAgICAgICB0aGlzLl9mb3J3YXJkU291cmNlRXZlbnQoZSk7XG4gICAgfSxcblxuICAgIF9vblNvdXJjZVVwZGF0ZTogZnVuY3Rpb24oZSkge1xuICAgICAgICB0aGlzLl91cGRhdGUoKTtcbiAgICAgICAgdGhpcy5fZm9yd2FyZFNvdXJjZUV2ZW50KGUpO1xuICAgIH0sXG5cbiAgICBfb25XaW5kb3dSZXNpemU6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLnN0b3AoKS5yZXNpemUoKS5fdXBkYXRlKCk7XG4gICAgfVxufSk7XG5cbnV0aWwuZXh0ZW5kQWxsKE1hcC5wcm90b3R5cGUsIC8qKiBAbGVuZHMgTWFwLnByb3RvdHlwZSAqL3tcblxuICAgIC8qKlxuICAgICAqIERyYXcgYW4gb3V0bGluZSBhcm91bmQgZWFjaCByZW5kZXJlZCB0aWxlIGZvciBkZWJ1Z2dpbmcuXG4gICAgICpcbiAgICAgKiBAbmFtZSBzaG93VGlsZUJvdW5kYXJpZXNcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBfc2hvd1RpbGVCb3VuZGFyaWVzOiBmYWxzZSxcbiAgICBnZXQgc2hvd1RpbGVCb3VuZGFyaWVzKCkgeyByZXR1cm4gdGhpcy5fc2hvd1RpbGVCb3VuZGFyaWVzOyB9LFxuICAgIHNldCBzaG93VGlsZUJvdW5kYXJpZXModmFsdWUpIHtcbiAgICAgICAgaWYgKHRoaXMuX3Nob3dUaWxlQm91bmRhcmllcyA9PT0gdmFsdWUpIHJldHVybjtcbiAgICAgICAgdGhpcy5fc2hvd1RpbGVCb3VuZGFyaWVzID0gdmFsdWU7XG4gICAgICAgIHRoaXMuX3VwZGF0ZSgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBEcmF3IGJveGVzIGFyb3VuZCBhbGwgc3ltYm9scyBpbiB0aGUgZGF0YSBzb3VyY2UsIHNob3dpbmcgd2hpY2ggd2VyZVxuICAgICAqIHJlbmRlcmVkIGFuZCB3aGljaCB3ZXJlIGhpZGRlbiBkdWUgdG8gY29sbGlzaW9ucyB3aXRoIG90aGVyIHN5bWJvbHMgZm9yXG4gICAgICogc3R5bGUgZGVidWdnaW5nLlxuICAgICAqXG4gICAgICogQG5hbWUgc2hvd0NvbGxpc2lvbkJveGVzXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgX3Nob3dDb2xsaXNpb25Cb3hlczogZmFsc2UsXG4gICAgZ2V0IHNob3dDb2xsaXNpb25Cb3hlcygpIHsgcmV0dXJuIHRoaXMuX3Nob3dDb2xsaXNpb25Cb3hlczsgfSxcbiAgICBzZXQgc2hvd0NvbGxpc2lvbkJveGVzKHZhbHVlKSB7XG4gICAgICAgIGlmICh0aGlzLl9zaG93Q29sbGlzaW9uQm94ZXMgPT09IHZhbHVlKSByZXR1cm47XG4gICAgICAgIHRoaXMuX3Nob3dDb2xsaXNpb25Cb3hlcyA9IHZhbHVlO1xuICAgICAgICB0aGlzLnN0eWxlLl9yZWRvUGxhY2VtZW50KCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEVuYWJsZSBjb250aW51b3VzIHJlcGFpbnQgdG8gYW5hbHl6ZSBwZXJmb3JtYW5jZVxuICAgICAqXG4gICAgICogQG5hbWUgcmVwYWludFxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIF9yZXBhaW50OiBmYWxzZSxcbiAgICBnZXQgcmVwYWludCgpIHsgcmV0dXJuIHRoaXMuX3JlcGFpbnQ7IH0sXG4gICAgc2V0IHJlcGFpbnQodmFsdWUpIHsgdGhpcy5fcmVwYWludCA9IHZhbHVlOyB0aGlzLl91cGRhdGUoKTsgfSxcblxuICAgIC8vIHNob3cgdmVydGljZXNcbiAgICBfdmVydGljZXM6IGZhbHNlLFxuICAgIGdldCB2ZXJ0aWNlcygpIHsgcmV0dXJuIHRoaXMuX3ZlcnRpY2VzOyB9LFxuICAgIHNldCB2ZXJ0aWNlcyh2YWx1ZSkgeyB0aGlzLl92ZXJ0aWNlcyA9IHZhbHVlOyB0aGlzLl91cGRhdGUoKTsgfVxufSk7XG5cbmZ1bmN0aW9uIHJlbW92ZU5vZGUobm9kZSkge1xuICAgIGlmIChub2RlLnBhcmVudE5vZGUpIHtcbiAgICAgICAgbm9kZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKG5vZGUpO1xuICAgIH1cbn1cbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBQb3B1cDtcblxudmFyIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsL3V0aWwnKTtcbnZhciBFdmVudGVkID0gcmVxdWlyZSgnLi4vdXRpbC9ldmVudGVkJyk7XG52YXIgRE9NID0gcmVxdWlyZSgnLi4vdXRpbC9kb20nKTtcbnZhciBMbmdMYXQgPSByZXF1aXJlKCcuLi9nZW8vbG5nX2xhdCcpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBwb3B1cCBjb21wb25lbnRcbiAqIEBjbGFzcyBQb3B1cFxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gb3B0aW9ucy5jbG9zZUJ1dHRvblxuICogQHBhcmFtIHtib29sZWFufSBvcHRpb25zLmNsb3NlT25DbGlja1xuICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMuYW5jaG9yIC0gT25lIG9mIFwidG9wXCIsIFwiYm90dG9tXCIsIFwibGVmdFwiLCBcInJpZ2h0XCIsIFwidG9wLWxlZnRcIixcbiAqIFwidG9wLXJpZ2h0XCIsIFwiYm90dG9tLWxlZnRcIiwgb3IgXCJib3R0b20tcmlnaHRcIiwgZGVzY3JpYmluZyB3aGVyZSB0aGUgcG9wdXAncyBhbmNob3JcbiAqIHJlbGF0aXZlIHRvIHRoZSBjb29yZGluYXRlIHNldCB2aWEgYHNldExuZ0xhdGAuXG4gKiBAZXhhbXBsZVxuICogdmFyIHRvb2x0aXAgPSBuZXcgbWFwYm94Z2wuUG9wdXAoKVxuICogICAuc2V0TG5nTGF0KGUubG5nTGF0KVxuICogICAuc2V0SFRNTChcIjxoMT5IZWxsbyBXb3JsZCE8L2gxPlwiKVxuICogICAuYWRkVG8obWFwKTtcbiAqL1xuZnVuY3Rpb24gUG9wdXAob3B0aW9ucykge1xuICAgIHV0aWwuc2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcbiAgICB1dGlsLmJpbmRBbGwoW1xuICAgICAgICAnX3VwZGF0ZScsXG4gICAgICAgICdfb25DbGlja0Nsb3NlJ10sXG4gICAgICAgIHRoaXMpO1xufVxuXG5Qb3B1cC5wcm90b3R5cGUgPSB1dGlsLmluaGVyaXQoRXZlbnRlZCwgLyoqIEBsZW5kcyBQb3B1cC5wcm90b3R5cGUgKi97XG4gICAgb3B0aW9uczoge1xuICAgICAgICBjbG9zZUJ1dHRvbjogdHJ1ZSxcbiAgICAgICAgY2xvc2VPbkNsaWNrOiB0cnVlXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEF0dGFjaGVzIHRoZSBwb3B1cCB0byBhIG1hcFxuICAgICAqIEBwYXJhbSB7TWFwfSBtYXBcbiAgICAgKiBAcmV0dXJucyB7UG9wdXB9IGB0aGlzYFxuICAgICAqL1xuICAgIGFkZFRvOiBmdW5jdGlvbihtYXApIHtcbiAgICAgICAgdGhpcy5fbWFwID0gbWFwO1xuICAgICAgICB0aGlzLl9tYXAub24oJ21vdmUnLCB0aGlzLl91cGRhdGUpO1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmNsb3NlT25DbGljaykge1xuICAgICAgICAgICAgdGhpcy5fbWFwLm9uKCdjbGljaycsIHRoaXMuX29uQ2xpY2tDbG9zZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fdXBkYXRlKCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIHRoZSBwb3B1cCBmcm9tIHRoZSBtYXBcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIHZhciBwb3B1cCA9IG5ldyBtYXBib3hnbC5Qb3B1cCgpLmFkZFRvKG1hcCk7XG4gICAgICogcG9wdXAucmVtb3ZlKCk7XG4gICAgICogQHJldHVybnMge1BvcHVwfSBgdGhpc2BcbiAgICAgKi9cbiAgICByZW1vdmU6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5fY29udGVudCAmJiB0aGlzLl9jb250ZW50LnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgIHRoaXMuX2NvbnRlbnQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLl9jb250ZW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLl9jb250YWluZXIpIHtcbiAgICAgICAgICAgIHRoaXMuX2NvbnRhaW5lci5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuX2NvbnRhaW5lcik7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5fY29udGFpbmVyO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuX21hcCkge1xuICAgICAgICAgICAgdGhpcy5fbWFwLm9mZignbW92ZScsIHRoaXMuX3VwZGF0ZSk7XG4gICAgICAgICAgICB0aGlzLl9tYXAub2ZmKCdjbGljaycsIHRoaXMuX29uQ2xpY2tDbG9zZSk7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5fbWFwO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgY3VycmVudCBjb29yZGluYXRlcyBvZiBwb3B1cCBlbGVtZW50IHJlbGF0aXZlIHRvIG1hcFxuICAgICAqIEByZXR1cm5zIHtMbmdMYXR9XG4gICAgICovXG4gICAgZ2V0TG5nTGF0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xuZ0xhdDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0IHRoZSBjb29yZGluYXRlcyBvZiBhIHBvcHVwIGVsZW1lbnQgdG8gYSBtYXBcbiAgICAgKiBAcGFyYW0ge0xuZ0xhdH0gbG5nbGF0XG4gICAgICogQHJldHVybnMge1BvcHVwfSBgdGhpc2BcbiAgICAgKi9cbiAgICBzZXRMbmdMYXQ6IGZ1bmN0aW9uKGxuZ2xhdCkge1xuICAgICAgICB0aGlzLl9sbmdMYXQgPSBMbmdMYXQuY29udmVydChsbmdsYXQpO1xuICAgICAgICB0aGlzLl91cGRhdGUoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEZpbGwgYSBwb3B1cCBlbGVtZW50IHdpdGggdGV4dCBvbmx5IGNvbnRlbnRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dFxuICAgICAqIEByZXR1cm5zIHtQb3B1cH0gYHRoaXNgXG4gICAgICovXG4gICAgc2V0VGV4dDogZnVuY3Rpb24odGV4dCkge1xuICAgICAgICB0aGlzLl9jcmVhdGVDb250ZW50KCk7XG4gICAgICAgIHRoaXMuX2NvbnRlbnQuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUodGV4dCkpO1xuXG4gICAgICAgIHRoaXMuX3VwZGF0ZSgpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRmlsbCBhIHBvcHVwIGVsZW1lbnQgd2l0aCBIVE1MIGNvbnRlbnRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gaHRtbFxuICAgICAqIEByZXR1cm5zIHtQb3B1cH0gYHRoaXNgXG4gICAgICovXG4gICAgc2V0SFRNTDogZnVuY3Rpb24oaHRtbCkge1xuICAgICAgICB0aGlzLl9jcmVhdGVDb250ZW50KCk7XG5cbiAgICAgICAgdmFyIHRlbXAgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdib2R5JyksIGNoaWxkO1xuICAgICAgICB0ZW1wLmlubmVySFRNTCA9IGh0bWw7XG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICBjaGlsZCA9IHRlbXAuZmlyc3RDaGlsZDtcbiAgICAgICAgICAgIGlmICghY2hpbGQpIGJyZWFrO1xuICAgICAgICAgICAgdGhpcy5fY29udGVudC5hcHBlbmRDaGlsZChjaGlsZCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl91cGRhdGUoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIF9jcmVhdGVDb250ZW50OiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuX2NvbnRlbnQgJiYgdGhpcy5fY29udGVudC5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICB0aGlzLl9jb250ZW50LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5fY29udGVudCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9jb250ZW50ID0gRE9NLmNyZWF0ZSgnZGl2JywgJ21hcGJveGdsLXBvcHVwLWNvbnRlbnQnLCB0aGlzLl9jb250YWluZXIpO1xuXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuY2xvc2VCdXR0b24pIHtcbiAgICAgICAgICAgIHRoaXMuX2Nsb3NlQnV0dG9uID0gRE9NLmNyZWF0ZSgnYnV0dG9uJywgJ21hcGJveGdsLXBvcHVwLWNsb3NlLWJ1dHRvbicsIHRoaXMuX2NvbnRlbnQpO1xuICAgICAgICAgICAgdGhpcy5fY2xvc2VCdXR0b24uaW5uZXJIVE1MID0gJyYjMjE1Oyc7XG4gICAgICAgICAgICB0aGlzLl9jbG9zZUJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMuX29uQ2xpY2tDbG9zZSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgX3VwZGF0ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICghdGhpcy5fbWFwIHx8ICF0aGlzLl9sbmdMYXQgfHwgIXRoaXMuX2NvbnRlbnQpIHsgcmV0dXJuOyB9XG5cbiAgICAgICAgaWYgKCF0aGlzLl9jb250YWluZXIpIHtcbiAgICAgICAgICAgIHRoaXMuX2NvbnRhaW5lciA9IERPTS5jcmVhdGUoJ2RpdicsICdtYXBib3hnbC1wb3B1cCcsIHRoaXMuX21hcC5nZXRDb250YWluZXIoKSk7XG4gICAgICAgICAgICB0aGlzLl90aXAgICAgICAgPSBET00uY3JlYXRlKCdkaXYnLCAnbWFwYm94Z2wtcG9wdXAtdGlwJywgdGhpcy5fY29udGFpbmVyKTtcbiAgICAgICAgICAgIHRoaXMuX2NvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLl9jb250ZW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBwb3MgPSB0aGlzLl9tYXAucHJvamVjdCh0aGlzLl9sbmdMYXQpLnJvdW5kKCksXG4gICAgICAgICAgICBhbmNob3IgPSB0aGlzLm9wdGlvbnMuYW5jaG9yO1xuXG4gICAgICAgIGlmICghYW5jaG9yKSB7XG4gICAgICAgICAgICB2YXIgd2lkdGggPSB0aGlzLl9jb250YWluZXIub2Zmc2V0V2lkdGgsXG4gICAgICAgICAgICAgICAgaGVpZ2h0ID0gdGhpcy5fY29udGFpbmVyLm9mZnNldEhlaWdodDtcblxuICAgICAgICAgICAgaWYgKHBvcy55IDwgaGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgYW5jaG9yID0gWyd0b3AnXTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocG9zLnkgPiB0aGlzLl9tYXAudHJhbnNmb3JtLmhlaWdodCAtIGhlaWdodCkge1xuICAgICAgICAgICAgICAgIGFuY2hvciA9IFsnYm90dG9tJ107XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGFuY2hvciA9IFtdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAocG9zLnggPCB3aWR0aCAvIDIpIHtcbiAgICAgICAgICAgICAgICBhbmNob3IucHVzaCgnbGVmdCcpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChwb3MueCA+IHRoaXMuX21hcC50cmFuc2Zvcm0ud2lkdGggLSB3aWR0aCAvIDIpIHtcbiAgICAgICAgICAgICAgICBhbmNob3IucHVzaCgncmlnaHQnKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGFuY2hvci5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICBhbmNob3IgPSAnYm90dG9tJztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYW5jaG9yID0gYW5jaG9yLmpvaW4oJy0nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBhbmNob3JUcmFuc2xhdGUgPSB7XG4gICAgICAgICAgICAndG9wJzogJ3RyYW5zbGF0ZSgtNTAlLDApJyxcbiAgICAgICAgICAgICd0b3AtbGVmdCc6ICd0cmFuc2xhdGUoMCwwKScsXG4gICAgICAgICAgICAndG9wLXJpZ2h0JzogJ3RyYW5zbGF0ZSgtMTAwJSwwKScsXG4gICAgICAgICAgICAnYm90dG9tJzogJ3RyYW5zbGF0ZSgtNTAlLC0xMDAlKScsXG4gICAgICAgICAgICAnYm90dG9tLWxlZnQnOiAndHJhbnNsYXRlKDAsLTEwMCUpJyxcbiAgICAgICAgICAgICdib3R0b20tcmlnaHQnOiAndHJhbnNsYXRlKC0xMDAlLC0xMDAlKScsXG4gICAgICAgICAgICAnbGVmdCc6ICd0cmFuc2xhdGUoMCwtNTAlKScsXG4gICAgICAgICAgICAncmlnaHQnOiAndHJhbnNsYXRlKC0xMDAlLC01MCUpJ1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBjbGFzc0xpc3QgPSB0aGlzLl9jb250YWluZXIuY2xhc3NMaXN0O1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gYW5jaG9yVHJhbnNsYXRlKSB7XG4gICAgICAgICAgICBjbGFzc0xpc3QucmVtb3ZlKCdtYXBib3hnbC1wb3B1cC1hbmNob3ItJyArIGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgY2xhc3NMaXN0LmFkZCgnbWFwYm94Z2wtcG9wdXAtYW5jaG9yLScgKyBhbmNob3IpO1xuXG4gICAgICAgIERPTS5zZXRUcmFuc2Zvcm0odGhpcy5fY29udGFpbmVyLCBhbmNob3JUcmFuc2xhdGVbYW5jaG9yXSArICcgdHJhbnNsYXRlKCcgKyBwb3MueCArICdweCwnICsgcG9zLnkgKyAncHgpJyk7XG4gICAgfSxcblxuICAgIF9vbkNsaWNrQ2xvc2U6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLnJlbW92ZSgpO1xuICAgIH1cbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEFjdG9yO1xuXG4vKipcbiAqIEFuIGltcGxlbWVudGF0aW9uIG9mIHRoZSBbQWN0b3IgZGVzaWduIHBhdHRlcm5dKGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQWN0b3JfbW9kZWwpXG4gKiB0aGF0IG1haW50YWlucyB0aGUgcmVsYXRpb25zaGlwIGJldHdlZW4gYXN5bmNocm9ub3VzIHRhc2tzIGFuZCB0aGUgb2JqZWN0c1xuICogdGhhdCBzcGluIHRoZW0gb2ZmIC0gaW4gdGhpcyBjYXNlLCB0YXNrcyBsaWtlIHBhcnNpbmcgcGFydHMgb2Ygc3R5bGVzLFxuICogb3duZWQgYnkgdGhlIHN0eWxlc1xuICpcbiAqIEBwYXJhbSB7V2ViV29ya2VyfSB0YXJnZXRcbiAqIEBwYXJhbSB7V2ViV29ya2VyfSBwYXJlbnRcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIEFjdG9yKHRhcmdldCwgcGFyZW50KSB7XG4gICAgdGhpcy50YXJnZXQgPSB0YXJnZXQ7XG4gICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgdGhpcy5jYWxsYmFja3MgPSB7fTtcbiAgICB0aGlzLmNhbGxiYWNrSUQgPSAwO1xuICAgIHRoaXMucmVjZWl2ZSA9IHRoaXMucmVjZWl2ZS5iaW5kKHRoaXMpO1xuICAgIHRoaXMudGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCB0aGlzLnJlY2VpdmUsIGZhbHNlKTtcbn1cblxuQWN0b3IucHJvdG90eXBlLnJlY2VpdmUgPSBmdW5jdGlvbihtZXNzYWdlKSB7XG4gICAgdmFyIGRhdGEgPSBtZXNzYWdlLmRhdGEsXG4gICAgICAgIGNhbGxiYWNrO1xuXG4gICAgaWYgKGRhdGEudHlwZSA9PT0gJzxyZXNwb25zZT4nKSB7XG4gICAgICAgIGNhbGxiYWNrID0gdGhpcy5jYWxsYmFja3NbZGF0YS5pZF07XG4gICAgICAgIGRlbGV0ZSB0aGlzLmNhbGxiYWNrc1tkYXRhLmlkXTtcbiAgICAgICAgY2FsbGJhY2soZGF0YS5lcnJvciB8fCBudWxsLCBkYXRhLmRhdGEpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGRhdGEuaWQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHZhciBpZCA9IGRhdGEuaWQ7XG4gICAgICAgIHRoaXMucGFyZW50W2RhdGEudHlwZV0oZGF0YS5kYXRhLCBmdW5jdGlvbihlcnIsIGRhdGEsIGJ1ZmZlcnMpIHtcbiAgICAgICAgICAgIHRoaXMucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgICAgICAgIHR5cGU6ICc8cmVzcG9uc2U+JyxcbiAgICAgICAgICAgICAgICBpZDogU3RyaW5nKGlkKSxcbiAgICAgICAgICAgICAgICBlcnJvcjogZXJyID8gU3RyaW5nKGVycikgOiBudWxsLFxuICAgICAgICAgICAgICAgIGRhdGE6IGRhdGFcbiAgICAgICAgICAgIH0sIGJ1ZmZlcnMpO1xuICAgICAgICB9LmJpbmQodGhpcykpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucGFyZW50W2RhdGEudHlwZV0oZGF0YS5kYXRhKTtcbiAgICB9XG59O1xuXG5BY3Rvci5wcm90b3R5cGUuc2VuZCA9IGZ1bmN0aW9uKHR5cGUsIGRhdGEsIGNhbGxiYWNrLCBidWZmZXJzKSB7XG4gICAgdmFyIGlkID0gbnVsbDtcbiAgICBpZiAoY2FsbGJhY2spIHRoaXMuY2FsbGJhY2tzW2lkID0gdGhpcy5jYWxsYmFja0lEKytdID0gY2FsbGJhY2s7XG4gICAgdGhpcy5wb3N0TWVzc2FnZSh7IHR5cGU6IHR5cGUsIGlkOiBTdHJpbmcoaWQpLCBkYXRhOiBkYXRhIH0sIGJ1ZmZlcnMpO1xufTtcblxuLyoqXG4gKiBXcmFwcGVkIHBvc3RNZXNzYWdlIEFQSSB0aGF0IGFic3RyYWN0cyBhcm91bmQgSUUncyBsYWNrIG9mXG4gKiBgdHJhbnNmZXJMaXN0YCBzdXBwb3J0LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBtZXNzYWdlXG4gKiBAcGFyYW0ge09iamVjdH0gdHJhbnNmZXJMaXN0XG4gKiBAcHJpdmF0ZVxuICovXG5BY3Rvci5wcm90b3R5cGUucG9zdE1lc3NhZ2UgPSBmdW5jdGlvbihtZXNzYWdlLCB0cmFuc2Zlckxpc3QpIHtcbiAgICB0aGlzLnRhcmdldC5wb3N0TWVzc2FnZShtZXNzYWdlLCB0cmFuc2Zlckxpc3QpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5nZXRKU09OID0gZnVuY3Rpb24odXJsLCBjYWxsYmFjaykge1xuICAgIHZhciB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICB4aHIub3BlbignR0VUJywgdXJsLCB0cnVlKTtcbiAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcignQWNjZXB0JywgJ2FwcGxpY2F0aW9uL2pzb24nKTtcbiAgICB4aHIub25lcnJvciA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgY2FsbGJhY2soZSk7XG4gICAgfTtcbiAgICB4aHIub25sb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh4aHIuc3RhdHVzID49IDIwMCAmJiB4aHIuc3RhdHVzIDwgMzAwICYmIHhoci5yZXNwb25zZSkge1xuICAgICAgICAgICAgdmFyIGRhdGE7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGRhdGEgPSBKU09OLnBhcnNlKHhoci5yZXNwb25zZSk7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIGRhdGEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FsbGJhY2sobmV3IEVycm9yKHhoci5zdGF0dXNUZXh0KSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHhoci5zZW5kKCk7XG4gICAgcmV0dXJuIHhocjtcbn07XG5cbmV4cG9ydHMuZ2V0QXJyYXlCdWZmZXIgPSBmdW5jdGlvbih1cmwsIGNhbGxiYWNrKSB7XG4gICAgdmFyIHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgIHhoci5vcGVuKCdHRVQnLCB1cmwsIHRydWUpO1xuICAgIHhoci5yZXNwb25zZVR5cGUgPSAnYXJyYXlidWZmZXInO1xuICAgIHhoci5vbmVycm9yID0gZnVuY3Rpb24oZSkge1xuICAgICAgICBjYWxsYmFjayhlKTtcbiAgICB9O1xuICAgIHhoci5vbmxvYWQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHhoci5zdGF0dXMgPj0gMjAwICYmIHhoci5zdGF0dXMgPCAzMDAgJiYgeGhyLnJlc3BvbnNlKSB7XG4gICAgICAgICAgICBjYWxsYmFjayhudWxsLCB4aHIucmVzcG9uc2UpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FsbGJhY2sobmV3IEVycm9yKHhoci5zdGF0dXNUZXh0KSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHhoci5zZW5kKCk7XG4gICAgcmV0dXJuIHhocjtcbn07XG5cbmZ1bmN0aW9uIHNhbWVPcmlnaW4odXJsKSB7XG4gICAgdmFyIGEgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdhJyk7XG4gICAgYS5ocmVmID0gdXJsO1xuICAgIHJldHVybiBhLnByb3RvY29sID09PSBkb2N1bWVudC5sb2NhdGlvbi5wcm90b2NvbCAmJiBhLmhvc3QgPT09IGRvY3VtZW50LmxvY2F0aW9uLmhvc3Q7XG59XG5cbmV4cG9ydHMuZ2V0SW1hZ2UgPSBmdW5jdGlvbih1cmwsIGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIGV4cG9ydHMuZ2V0QXJyYXlCdWZmZXIodXJsLCBmdW5jdGlvbihlcnIsIGltZ0RhdGEpIHtcbiAgICAgICAgaWYgKGVycikgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgICAgIHZhciBpbWcgPSBuZXcgSW1hZ2UoKTtcbiAgICAgICAgaW1nLm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgaW1nKTtcbiAgICAgICAgICAgICh3aW5kb3cuVVJMIHx8IHdpbmRvdy53ZWJraXRVUkwpLnJldm9rZU9iamVjdFVSTChpbWcuc3JjKTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGJsb2IgPSBuZXcgQmxvYihbbmV3IFVpbnQ4QXJyYXkoaW1nRGF0YSldLCB7IHR5cGU6ICdpbWFnZS9wbmcnIH0pO1xuICAgICAgICBpbWcuc3JjID0gKHdpbmRvdy5VUkwgfHwgd2luZG93LndlYmtpdFVSTCkuY3JlYXRlT2JqZWN0VVJMKGJsb2IpO1xuICAgICAgICBpbWcuZ2V0RGF0YSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgICAgICAgICAgdmFyIGNvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgICAgICAgIGNhbnZhcy53aWR0aCA9IGltZy53aWR0aDtcbiAgICAgICAgICAgIGNhbnZhcy5oZWlnaHQgPSBpbWcuaGVpZ2h0O1xuICAgICAgICAgICAgY29udGV4dC5kcmF3SW1hZ2UoaW1nLCAwLCAwKTtcbiAgICAgICAgICAgIHJldHVybiBjb250ZXh0LmdldEltYWdlRGF0YSgwLCAwLCBpbWcud2lkdGgsIGltZy5oZWlnaHQpLmRhdGE7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBpbWc7XG4gICAgfSk7XG59O1xuXG5leHBvcnRzLmdldFZpZGVvID0gZnVuY3Rpb24odXJscywgY2FsbGJhY2spIHtcbiAgICB2YXIgdmlkZW8gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd2aWRlbycpO1xuICAgIHZpZGVvLm9ubG9hZHN0YXJ0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGNhbGxiYWNrKG51bGwsIHZpZGVvKTtcbiAgICB9O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdXJscy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NvdXJjZScpO1xuICAgICAgICBpZiAoIXNhbWVPcmlnaW4odXJsc1tpXSkpIHtcbiAgICAgICAgICAgIHZpZGVvLmNyb3NzT3JpZ2luID0gJ0Fub255bW91cyc7XG4gICAgICAgIH1cbiAgICAgICAgcy5zcmMgPSB1cmxzW2ldO1xuICAgICAgICB2aWRlby5hcHBlbmRDaGlsZChzKTtcbiAgICB9XG4gICAgdmlkZW8uZ2V0RGF0YSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdmlkZW87IH07XG4gICAgcmV0dXJuIHZpZGVvO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIENhbnZhcyA9IHJlcXVpcmUoJy4vY2FudmFzJyk7XG5cbi8qKlxuICogVW5saWtlIGpzL3V0aWwvYnJvd3Nlci5qcywgdGhpcyBjb2RlIGlzIHdyaXR0ZW4gd2l0aCB0aGUgZXhwZWN0YXRpb25cbiAqIG9mIGEgYnJvd3NlciBlbnZpcm9ubWVudCB3aXRoIGEgZ2xvYmFsICd3aW5kb3cnIG9iamVjdFxuICogQG1vZHVsZSBicm93c2VyXG4gKiBAcHJpdmF0ZVxuICovXG5cbi8qKlxuICogUHJvdmlkZXMgYSBmdW5jdGlvbiB0aGF0IG91dHB1dHMgbWlsbGlzZWNvbmRzOiBlaXRoZXIgcGVyZm9ybWFuY2Uubm93KClcbiAqIG9yIGEgZmFsbGJhY2sgdG8gRGF0ZS5ub3coKVxuICovXG5tb2R1bGUuZXhwb3J0cy5ub3cgPSAoZnVuY3Rpb24oKSB7XG4gICAgaWYgKHdpbmRvdy5wZXJmb3JtYW5jZSAmJlxuICAgICAgICB3aW5kb3cucGVyZm9ybWFuY2Uubm93KSB7XG4gICAgICAgIHJldHVybiB3aW5kb3cucGVyZm9ybWFuY2Uubm93LmJpbmQod2luZG93LnBlcmZvcm1hbmNlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gRGF0ZS5ub3cuYmluZChEYXRlKTtcbiAgICB9XG59KCkpO1xuXG52YXIgZnJhbWUgPSB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8XG4gICAgd2luZG93Lm1velJlcXVlc3RBbmltYXRpb25GcmFtZSB8fFxuICAgIHdpbmRvdy53ZWJraXRSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHxcbiAgICB3aW5kb3cubXNSZXF1ZXN0QW5pbWF0aW9uRnJhbWU7XG5cbmV4cG9ydHMuZnJhbWUgPSBmdW5jdGlvbihmbikge1xuICAgIHJldHVybiBmcmFtZShmbik7XG59O1xuXG52YXIgY2FuY2VsID0gd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lIHx8XG4gICAgd2luZG93Lm1vekNhbmNlbEFuaW1hdGlvbkZyYW1lIHx8XG4gICAgd2luZG93LndlYmtpdENhbmNlbEFuaW1hdGlvbkZyYW1lIHx8XG4gICAgd2luZG93Lm1zQ2FuY2VsQW5pbWF0aW9uRnJhbWU7XG5cbmV4cG9ydHMuY2FuY2VsRnJhbWUgPSBmdW5jdGlvbihpZCkge1xuICAgIGNhbmNlbChpZCk7XG59O1xuXG5leHBvcnRzLnRpbWVkID0gZnVuY3Rpb24gKGZuLCBkdXIsIGN0eCkge1xuICAgIGlmICghZHVyKSB7XG4gICAgICAgIGZuLmNhbGwoY3R4LCAxKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgdmFyIGFib3J0ID0gZmFsc2UsXG4gICAgICAgIHN0YXJ0ID0gbW9kdWxlLmV4cG9ydHMubm93KCk7XG5cbiAgICBmdW5jdGlvbiB0aWNrKG5vdykge1xuICAgICAgICBpZiAoYWJvcnQpIHJldHVybjtcbiAgICAgICAgbm93ID0gbW9kdWxlLmV4cG9ydHMubm93KCk7XG5cbiAgICAgICAgaWYgKG5vdyA+PSBzdGFydCArIGR1cikge1xuICAgICAgICAgICAgZm4uY2FsbChjdHgsIDEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZm4uY2FsbChjdHgsIChub3cgLSBzdGFydCkgLyBkdXIpO1xuICAgICAgICAgICAgZXhwb3J0cy5mcmFtZSh0aWNrKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGV4cG9ydHMuZnJhbWUodGljayk7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7IGFib3J0ID0gdHJ1ZTsgfTtcbn07XG5cbmV4cG9ydHMuc3VwcG9ydHNXZWJHTCA9IHt9O1xuXG4vKipcbiAqIFRlc3Qgd2hldGhlciB0aGUgYmFzaWMgSmF2YVNjcmlwdCBhbmQgRE9NIGZlYXR1cmVzIHJlcXVpcmVkIGZvciBNYXBib3ggR0wgYXJlIHByZXNlbnQuXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5mYWlsSWZNYWpvclBlcmZvcm1hbmNlQ2F2ZWF0PWZhbHNlXSBJZiBgdHJ1ZWAsIG1hcCBjcmVhdGlvbiB3aWxsIGZhaWwgaWYgdGhlIGltcGxlbWVudGF0aW9uIGRldGVybWluZXMgdGhhdCB0aGUgcGVyZm9ybWFuY2Ugb2YgdGhlIGNyZWF0ZWQgV2ViR0wgY29udGV4dCB3b3VsZCBiZSBkcmFtYXRpY2FsbHkgbG93ZXIgdGhhbiBleHBlY3RlZC5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFJldHVybnMgdHJ1ZSBpZiBNYXBib3ggR0wgc2hvdWxkIGJlIGV4cGVjdGVkIHRvIHdvcmssIGFuZCBmYWxzZSBpZiBub3QuXG4gKiBAbWVtYmVyb2YgbWFwYm94Z2xcbiAqIEBzdGF0aWNcbiAqL1xuZXhwb3J0cy5zdXBwb3J0ZWQgPSBmdW5jdGlvbihvcHRpb25zKSB7XG5cbiAgICB2YXIgc3VwcG9ydHMgPSBbXG5cbiAgICAgICAgZnVuY3Rpb24oKSB7IHJldHVybiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJzsgfSxcblxuICAgICAgICBmdW5jdGlvbigpIHsgcmV0dXJuIHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCc7IH0sXG5cbiAgICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuICEhKEFycmF5LnByb3RvdHlwZSAmJlxuICAgICAgICAgICAgICAgIEFycmF5LnByb3RvdHlwZS5ldmVyeSAmJlxuICAgICAgICAgICAgICAgIEFycmF5LnByb3RvdHlwZS5maWx0ZXIgJiZcbiAgICAgICAgICAgICAgICBBcnJheS5wcm90b3R5cGUuZm9yRWFjaCAmJlxuICAgICAgICAgICAgICAgIEFycmF5LnByb3RvdHlwZS5pbmRleE9mICYmXG4gICAgICAgICAgICAgICAgQXJyYXkucHJvdG90eXBlLmxhc3RJbmRleE9mICYmXG4gICAgICAgICAgICAgICAgQXJyYXkucHJvdG90eXBlLm1hcCAmJlxuICAgICAgICAgICAgICAgIEFycmF5LnByb3RvdHlwZS5zb21lICYmXG4gICAgICAgICAgICAgICAgQXJyYXkucHJvdG90eXBlLnJlZHVjZSAmJlxuICAgICAgICAgICAgICAgIEFycmF5LnByb3RvdHlwZS5yZWR1Y2VSaWdodCAmJlxuICAgICAgICAgICAgICAgIEFycmF5LmlzQXJyYXkpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuICEhKEZ1bmN0aW9uLnByb3RvdHlwZSAmJiBGdW5jdGlvbi5wcm90b3R5cGUuYmluZCkgJiZcbiAgICAgICAgICAgICAgICAhIShPYmplY3Qua2V5cyAmJlxuICAgICAgICAgICAgICAgICAgICBPYmplY3QuY3JlYXRlICYmXG4gICAgICAgICAgICAgICAgICAgIE9iamVjdC5nZXRQcm90b3R5cGVPZiAmJlxuICAgICAgICAgICAgICAgICAgICBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyAmJlxuICAgICAgICAgICAgICAgICAgICBPYmplY3QuaXNTZWFsZWQgJiZcbiAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmlzRnJvemVuICYmXG4gICAgICAgICAgICAgICAgICAgIE9iamVjdC5pc0V4dGVuc2libGUgJiZcbiAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvciAmJlxuICAgICAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkgJiZcbiAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMgJiZcbiAgICAgICAgICAgICAgICAgICAgT2JqZWN0LnNlYWwgJiZcbiAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmZyZWV6ZSAmJlxuICAgICAgICAgICAgICAgICAgICBPYmplY3QucHJldmVudEV4dGVuc2lvbnMpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuICdKU09OJyBpbiB3aW5kb3cgJiYgJ3BhcnNlJyBpbiBKU09OICYmICdzdHJpbmdpZnknIGluIEpTT047XG4gICAgICAgIH0sXG5cbiAgICAgICAgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgb3B0ID0gKG9wdGlvbnMgJiYgb3B0aW9ucy5mYWlsSWZNYWpvclBlcmZvcm1hbmNlQ2F2ZWF0KSB8fCBmYWxzZSxcbiAgICAgICAgICAgICAgICBmaW1wYyA9ICdmaW1wY18nICsgU3RyaW5nKG9wdCk7XG4gICAgICAgICAgICBpZiAoZXhwb3J0cy5zdXBwb3J0c1dlYkdMW2ZpbXBjXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNhbnZhcyA9IG5ldyBDYW52YXMoKTtcbiAgICAgICAgICAgICAgICBleHBvcnRzLnN1cHBvcnRzV2ViR0xbZmltcGNdID0gY2FudmFzLnN1cHBvcnRzV2ViR0xDb250ZXh0KG9wdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZXhwb3J0cy5zdXBwb3J0c1dlYkdMW2ZpbXBjXTtcbiAgICAgICAgfSxcblxuICAgICAgICBmdW5jdGlvbigpIHsgcmV0dXJuICdXb3JrZXInIGluIHdpbmRvdzsgfVxuICAgIF07XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN1cHBvcnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICghc3VwcG9ydHNbaV0oKSkgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5cbmV4cG9ydHMuaGFyZHdhcmVDb25jdXJyZW5jeSA9IG5hdmlnYXRvci5oYXJkd2FyZUNvbmN1cnJlbmN5IHx8IDg7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnZGV2aWNlUGl4ZWxSYXRpbycsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gd2luZG93LmRldmljZVBpeGVsUmF0aW87IH1cbn0pO1xuXG5leHBvcnRzLnN1cHBvcnRzV2VicCA9IGZhbHNlO1xuXG52YXIgd2VicEltZ1Rlc3QgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbWcnKTtcbndlYnBJbWdUZXN0Lm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuICAgIGV4cG9ydHMuc3VwcG9ydHNXZWJwID0gdHJ1ZTtcbn07XG53ZWJwSW1nVGVzdC5zcmMgPSAnZGF0YTppbWFnZS93ZWJwO2Jhc2U2NCxVa2xHUmg0QUFBQlhSVUpRVmxBNFRCRUFBQUF2QVFBQUFBZlEvLzczdi8rQmlPaC9BQUE9JztcblxuZXhwb3J0cy5zdXBwb3J0c0dlb2xvY2F0aW9uID0gISFuYXZpZ2F0b3IuZ2VvbG9jYXRpb247XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IENhbnZhcztcblxuZnVuY3Rpb24gQ2FudmFzKHBhcmVudCwgY29udGFpbmVyKSB7XG4gICAgdGhpcy5jYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcblxuICAgIGlmIChwYXJlbnQgJiYgY29udGFpbmVyKSB7XG4gICAgICAgIHRoaXMuY2FudmFzLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICAgICAgdGhpcy5jYW52YXMuY2xhc3NMaXN0LmFkZCgnbWFwYm94Z2wtY2FudmFzJyk7XG4gICAgICAgIHRoaXMuY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoJ3dlYmdsY29udGV4dGxvc3QnLCBwYXJlbnQuX2NvbnRleHRMb3N0LmJpbmQocGFyZW50KSwgZmFsc2UpO1xuICAgICAgICB0aGlzLmNhbnZhcy5hZGRFdmVudExpc3RlbmVyKCd3ZWJnbGNvbnRleHRyZXN0b3JlZCcsIHBhcmVudC5fY29udGV4dFJlc3RvcmVkLmJpbmQocGFyZW50KSwgZmFsc2UpO1xuICAgICAgICB0aGlzLmNhbnZhcy5zZXRBdHRyaWJ1dGUoJ3RhYmluZGV4JywgMCk7XG4gICAgICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLmNhbnZhcyk7XG4gICAgfVxufVxuXG5DYW52YXMucHJvdG90eXBlLnJlc2l6ZSA9IGZ1bmN0aW9uKHdpZHRoLCBoZWlnaHQpIHtcbiAgICB2YXIgcGl4ZWxSYXRpbyA9IHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvIHx8IDE7XG5cbiAgICAvLyBSZXF1ZXN0IHRoZSByZXF1aXJlZCBjYW52YXMgc2l6ZSB0YWtpbmcgdGhlIHBpeGVscmF0aW8gaW50byBhY2NvdW50LlxuICAgIHRoaXMuY2FudmFzLndpZHRoID0gcGl4ZWxSYXRpbyAqIHdpZHRoO1xuICAgIHRoaXMuY2FudmFzLmhlaWdodCA9IHBpeGVsUmF0aW8gKiBoZWlnaHQ7XG5cbiAgICAvLyBNYWludGFpbiB0aGUgc2FtZSBjYW52YXMgc2l6ZSwgcG90ZW50aWFsbHkgZG93bnNjYWxpbmcgaXQgZm9yIEhpRFBJIGRpc3BsYXlzXG4gICAgdGhpcy5jYW52YXMuc3R5bGUud2lkdGggPSB3aWR0aCArICdweCc7XG4gICAgdGhpcy5jYW52YXMuc3R5bGUuaGVpZ2h0ID0gaGVpZ2h0ICsgJ3B4Jztcbn07XG5cbnZhciByZXF1aXJlZENvbnRleHRBdHRyaWJ1dGVzID0ge1xuICAgIGFudGlhbGlhczogZmFsc2UsXG4gICAgYWxwaGE6IHRydWUsXG4gICAgc3RlbmNpbDogdHJ1ZSxcbiAgICBkZXB0aDogdHJ1ZVxufTtcblxuQ2FudmFzLnByb3RvdHlwZS5nZXRXZWJHTENvbnRleHQgPSBmdW5jdGlvbihhdHRyaWJ1dGVzKSB7XG4gICAgYXR0cmlidXRlcyA9IHV0aWwuZXh0ZW5kKHt9LCBhdHRyaWJ1dGVzLCByZXF1aXJlZENvbnRleHRBdHRyaWJ1dGVzKTtcblxuICAgIHJldHVybiB0aGlzLmNhbnZhcy5nZXRDb250ZXh0KCd3ZWJnbCcsIGF0dHJpYnV0ZXMpIHx8XG4gICAgICAgIHRoaXMuY2FudmFzLmdldENvbnRleHQoJ2V4cGVyaW1lbnRhbC13ZWJnbCcsIGF0dHJpYnV0ZXMpO1xufTtcblxuQ2FudmFzLnByb3RvdHlwZS5zdXBwb3J0c1dlYkdMQ29udGV4dCA9IGZ1bmN0aW9uKGZhaWxJZk1ham9yUGVyZm9ybWFuY2VDYXZlYXQpIHtcbiAgICB2YXIgYXR0cmlidXRlcyA9IHV0aWwuZXh0ZW5kKHtcbiAgICAgICAgZmFpbElmTWFqb3JQZXJmb3JtYW5jZUNhdmVhdDogZmFpbElmTWFqb3JQZXJmb3JtYW5jZUNhdmVhdFxuICAgIH0sIHJlcXVpcmVkQ29udGV4dEF0dHJpYnV0ZXMpO1xuXG4gICAgaWYgKCdwcm9iYWJseVN1cHBvcnRzQ29udGV4dCcgaW4gdGhpcy5jYW52YXMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FudmFzLnByb2JhYmx5U3VwcG9ydHNDb250ZXh0KCd3ZWJnbCcsIGF0dHJpYnV0ZXMpIHx8XG4gICAgICAgICAgICB0aGlzLmNhbnZhcy5wcm9iYWJseVN1cHBvcnRzQ29udGV4dCgnZXhwZXJpbWVudGFsLXdlYmdsJywgYXR0cmlidXRlcyk7XG4gICAgfSBlbHNlIGlmICgnc3VwcG9ydHNDb250ZXh0JyBpbiB0aGlzLmNhbnZhcykge1xuICAgICAgICByZXR1cm4gdGhpcy5jYW52YXMuc3VwcG9ydHNDb250ZXh0KCd3ZWJnbCcsIGF0dHJpYnV0ZXMpIHx8XG4gICAgICAgICAgICB0aGlzLmNhbnZhcy5zdXBwb3J0c0NvbnRleHQoJ2V4cGVyaW1lbnRhbC13ZWJnbCcsIGF0dHJpYnV0ZXMpO1xuICAgIH1cblxuICAgIHJldHVybiAhIXdpbmRvdy5XZWJHTFJlbmRlcmluZ0NvbnRleHQgJiYgISF0aGlzLmdldFdlYkdMQ29udGV4dChmYWlsSWZNYWpvclBlcmZvcm1hbmNlQ2F2ZWF0KTtcbn07XG5cbkNhbnZhcy5wcm90b3R5cGUuZ2V0RWxlbWVudCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmNhbnZhcztcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBBY3RvciA9IHJlcXVpcmUoJy4uL2FjdG9yJyk7XG52YXIgV2ViV29ya2lmeSA9IHJlcXVpcmUoJ3dlYndvcmtpZnknKTtcblxubW9kdWxlLmV4cG9ydHMgPSBEaXNwYXRjaGVyO1xuXG5mdW5jdGlvbiBEaXNwYXRjaGVyKGxlbmd0aCwgcGFyZW50KSB7XG4gICAgdGhpcy5hY3RvcnMgPSBbXTtcbiAgICB0aGlzLmN1cnJlbnRBY3RvciA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgd29ya2VyID0gbmV3IFdlYldvcmtpZnkocmVxdWlyZSgnLi4vLi4vc291cmNlL3dvcmtlcicpKTtcbiAgICAgICAgdmFyIGFjdG9yID0gbmV3IEFjdG9yKHdvcmtlciwgcGFyZW50KTtcbiAgICAgICAgYWN0b3IubmFtZSA9IFwiV29ya2VyIFwiICsgaTtcbiAgICAgICAgdGhpcy5hY3RvcnMucHVzaChhY3Rvcik7XG4gICAgfVxufVxuXG5EaXNwYXRjaGVyLnByb3RvdHlwZSA9IHtcbiAgICBicm9hZGNhc3Q6IGZ1bmN0aW9uKHR5cGUsIGRhdGEpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmFjdG9ycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdGhpcy5hY3RvcnNbaV0uc2VuZCh0eXBlLCBkYXRhKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBzZW5kOiBmdW5jdGlvbih0eXBlLCBkYXRhLCBjYWxsYmFjaywgdGFyZ2V0SUQsIGJ1ZmZlcnMpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB0YXJnZXRJRCAhPT0gJ251bWJlcicgfHwgaXNOYU4odGFyZ2V0SUQpKSB7XG4gICAgICAgICAgICAvLyBVc2Ugcm91bmQgcm9iaW4gdG8gc2VuZCByZXF1ZXN0cyB0byB3ZWIgd29ya2Vycy5cbiAgICAgICAgICAgIHRhcmdldElEID0gdGhpcy5jdXJyZW50QWN0b3IgPSAodGhpcy5jdXJyZW50QWN0b3IgKyAxKSAlIHRoaXMuYWN0b3JzLmxlbmd0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuYWN0b3JzW3RhcmdldElEXS5zZW5kKHR5cGUsIGRhdGEsIGNhbGxiYWNrLCBidWZmZXJzKTtcbiAgICAgICAgcmV0dXJuIHRhcmdldElEO1xuICAgIH0sXG5cbiAgICByZW1vdmU6IGZ1bmN0aW9uKCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuYWN0b3JzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLmFjdG9yc1tpXS50YXJnZXQudGVybWluYXRlKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hY3RvcnMgPSBbXTtcbiAgICB9XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgUG9pbnQgPSByZXF1aXJlKCdwb2ludC1nZW9tZXRyeScpO1xuXG5leHBvcnRzLmNyZWF0ZSA9IGZ1bmN0aW9uICh0YWdOYW1lLCBjbGFzc05hbWUsIGNvbnRhaW5lcikge1xuICAgIHZhciBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnTmFtZSk7XG4gICAgaWYgKGNsYXNzTmFtZSkgZWwuY2xhc3NOYW1lID0gY2xhc3NOYW1lO1xuICAgIGlmIChjb250YWluZXIpIGNvbnRhaW5lci5hcHBlbmRDaGlsZChlbCk7XG4gICAgcmV0dXJuIGVsO1xufTtcblxudmFyIGRvY1N0eWxlID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlO1xuXG5mdW5jdGlvbiB0ZXN0UHJvcChwcm9wcykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHByb3BzW2ldIGluIGRvY1N0eWxlKSB7XG4gICAgICAgICAgICByZXR1cm4gcHJvcHNbaV07XG4gICAgICAgIH1cbiAgICB9XG59XG5cbnZhciBzZWxlY3RQcm9wID0gdGVzdFByb3AoWyd1c2VyU2VsZWN0JywgJ01velVzZXJTZWxlY3QnLCAnV2Via2l0VXNlclNlbGVjdCcsICdtc1VzZXJTZWxlY3QnXSksXG4gICAgdXNlclNlbGVjdDtcbmV4cG9ydHMuZGlzYWJsZURyYWcgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHNlbGVjdFByb3ApIHtcbiAgICAgICAgdXNlclNlbGVjdCA9IGRvY1N0eWxlW3NlbGVjdFByb3BdO1xuICAgICAgICBkb2NTdHlsZVtzZWxlY3RQcm9wXSA9ICdub25lJztcbiAgICB9XG59O1xuZXhwb3J0cy5lbmFibGVEcmFnID0gZnVuY3Rpb24gKCkge1xuICAgIGlmIChzZWxlY3RQcm9wKSB7XG4gICAgICAgIGRvY1N0eWxlW3NlbGVjdFByb3BdID0gdXNlclNlbGVjdDtcbiAgICB9XG59O1xuXG52YXIgdHJhbnNmb3JtUHJvcCA9IHRlc3RQcm9wKFsndHJhbnNmb3JtJywgJ1dlYmtpdFRyYW5zZm9ybSddKTtcbmV4cG9ydHMuc2V0VHJhbnNmb3JtID0gZnVuY3Rpb24oZWwsIHZhbHVlKSB7XG4gICAgZWwuc3R5bGVbdHJhbnNmb3JtUHJvcF0gPSB2YWx1ZTtcbn07XG5cbi8vIFN1cHByZXNzIHRoZSBuZXh0IGNsaWNrLCBidXQgb25seSBpZiBpdCdzIGltbWVkaWF0ZS5cbmZ1bmN0aW9uIHN1cHByZXNzQ2xpY2soZSkge1xuICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIHN1cHByZXNzQ2xpY2ssIHRydWUpO1xufVxuZXhwb3J0cy5zdXBwcmVzc0NsaWNrID0gZnVuY3Rpb24oKSB7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgc3VwcHJlc3NDbGljaywgdHJ1ZSk7XG4gICAgd2luZG93LnNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIHN1cHByZXNzQ2xpY2ssIHRydWUpO1xuICAgIH0sIDApO1xufTtcblxuZXhwb3J0cy5tb3VzZVBvcyA9IGZ1bmN0aW9uIChlbCwgZSkge1xuICAgIHZhciByZWN0ID0gZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgZSA9IGUudG91Y2hlcyA/IGUudG91Y2hlc1swXSA6IGU7XG4gICAgcmV0dXJuIG5ldyBQb2ludChcbiAgICAgICAgZS5jbGllbnRYIC0gcmVjdC5sZWZ0IC0gZWwuY2xpZW50TGVmdCxcbiAgICAgICAgZS5jbGllbnRZIC0gcmVjdC50b3AgLSBlbC5jbGllbnRUb3BcbiAgICApO1xufTtcblxuZXhwb3J0cy50b3VjaFBvcyA9IGZ1bmN0aW9uIChlbCwgZSkge1xuICAgIHZhciByZWN0ID0gZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksXG4gICAgICAgIHBvaW50cyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZS50b3VjaGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHBvaW50cy5wdXNoKG5ldyBQb2ludChcbiAgICAgICAgICAgIGUudG91Y2hlc1tpXS5jbGllbnRYIC0gcmVjdC5sZWZ0IC0gZWwuY2xpZW50TGVmdCxcbiAgICAgICAgICAgIGUudG91Y2hlc1tpXS5jbGllbnRZIC0gcmVjdC50b3AgLSBlbC5jbGllbnRUb3BcbiAgICAgICAgKSk7XG4gICAgfVxuICAgIHJldHVybiBwb2ludHM7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBBUElfVVJMOiAnaHR0cHM6Ly9hcGkubWFwYm94LmNvbScsXG4gICAgUkVRVUlSRV9BQ0NFU1NfVE9LRU46IHRydWVcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gRGljdGlvbmFyeUNvZGVyO1xuXG5mdW5jdGlvbiBEaWN0aW9uYXJ5Q29kZXIoc3RyaW5ncykge1xuICAgIHRoaXMuX3N0cmluZ1RvTnVtYmVyID0ge307XG4gICAgdGhpcy5fbnVtYmVyVG9TdHJpbmcgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0cmluZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHN0cmluZyA9IHN0cmluZ3NbaV07XG4gICAgICAgIHRoaXMuX3N0cmluZ1RvTnVtYmVyW3N0cmluZ10gPSBpO1xuICAgICAgICB0aGlzLl9udW1iZXJUb1N0cmluZ1tpXSA9IHN0cmluZztcbiAgICB9XG59XG5cbkRpY3Rpb25hcnlDb2Rlci5wcm90b3R5cGUuZW5jb2RlID0gZnVuY3Rpb24oc3RyaW5nKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N0cmluZ1RvTnVtYmVyW3N0cmluZ107XG59O1xuXG5EaWN0aW9uYXJ5Q29kZXIucHJvdG90eXBlLmRlY29kZSA9IGZ1bmN0aW9uKG4pIHtcbiAgICByZXR1cm4gdGhpcy5fbnVtYmVyVG9TdHJpbmdbbl07XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xuXG4vKipcbiAqIE1ldGhvZHMgbWl4ZWQgaW4gdG8gb3RoZXIgY2xhc3NlcyBmb3IgZXZlbnQgY2FwYWJpbGl0aWVzLlxuICogQG1peGluIEV2ZW50ZWRcbiAqL1xudmFyIEV2ZW50ZWQgPSB7XG5cbiAgICAvKipcbiAgICAgKiBTdWJzY3JpYmUgdG8gYSBzcGVjaWZpZWQgZXZlbnQgd2l0aCBhIGxpc3RlbmVyIGZ1bmN0aW9uIHRoZSBsYXR0ZXIgZ2V0cyB0aGUgZGF0YSBvYmplY3QgdGhhdCB3YXMgcGFzc2VkIHRvIGBmaXJlYCBhbmQgYWRkaXRpb25hbGx5IGB0YXJnZXRgIGFuZCBgdHlwZWAgcHJvcGVydGllc1xuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgRXZlbnQgdHlwZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGxpc3RlbmVyIEZ1bmN0aW9uIHRvIGJlIGNhbGxlZCB3aGVuIHRoZSBldmVudCBpcyBmaXJlZFxuICAgICAqL1xuICAgIG9uOiBmdW5jdGlvbih0eXBlLCBmbikge1xuICAgICAgICB0aGlzLl9ldmVudHMgPSB0aGlzLl9ldmVudHMgfHwge307XG4gICAgICAgIHRoaXMuX2V2ZW50c1t0eXBlXSA9IHRoaXMuX2V2ZW50c1t0eXBlXSB8fCBbXTtcbiAgICAgICAgdGhpcy5fZXZlbnRzW3R5cGVdLnB1c2goZm4pO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmUgYSBldmVudCBsaXN0ZW5lclxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFt0eXBlXSBFdmVudCB0eXBlLiBJZiBub25lIGlzIHNwZWNpZmllZCwgcmVtb3ZlIGFsbCBsaXN0ZW5lcnNcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbbGlzdGVuZXJdIEZ1bmN0aW9uIHRvIGJlIGNhbGxlZCB3aGVuIHRoZSBldmVudCBpcyBmaXJlZC4gSWYgbm9uZSBpcyBzcGVjaWZpZWQgYWxsIGxpc3RlbmVycyBhcmUgcmVtb3ZlZFxuICAgICAqL1xuICAgIG9mZjogZnVuY3Rpb24odHlwZSwgZm4pIHtcbiAgICAgICAgaWYgKCF0eXBlKSB7XG4gICAgICAgICAgICAvLyBjbGVhciBhbGwgbGlzdGVuZXJzIGlmIG5vIGFyZ3VtZW50cyBzcGVjaWZpZWRcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9ldmVudHM7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdGhpcy5saXN0ZW5zKHR5cGUpKSByZXR1cm4gdGhpcztcblxuICAgICAgICBpZiAoZm4pIHtcbiAgICAgICAgICAgIHZhciBpZHggPSB0aGlzLl9ldmVudHNbdHlwZV0uaW5kZXhPZihmbik7XG4gICAgICAgICAgICBpZiAoaWR4ID49IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9ldmVudHNbdHlwZV0uc3BsaWNlKGlkeCwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXRoaXMuX2V2ZW50c1t0eXBlXS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuX2V2ZW50c1t0eXBlXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDYWxsIGEgZnVuY3Rpb24gb25jZSB3aGVuIGFuIGV2ZW50IGhhcyBmaXJlZFxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgRXZlbnQgdHlwZS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBsaXN0ZW5lciBGdW5jdGlvbiB0byBiZSBjYWxsZWQgb25jZSB3aGVuIHRoZSBldmVudCBpcyBmaXJlZFxuICAgICAqL1xuICAgIG9uY2U6IGZ1bmN0aW9uKHR5cGUsIGZuKSB7XG4gICAgICAgIHZhciB3cmFwcGVyID0gZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICAgICAgdGhpcy5vZmYodHlwZSwgd3JhcHBlcik7XG4gICAgICAgICAgICBmbi5jYWxsKHRoaXMsIGRhdGEpO1xuICAgICAgICB9LmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMub24odHlwZSwgd3JhcHBlcik7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBGaXJlIGV2ZW50IG9mIGEgZ2l2ZW4gc3RyaW5nIHR5cGUgd2l0aCB0aGUgZ2l2ZW4gZGF0YSBvYmplY3RcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIEV2ZW50IHR5cGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2RhdGFdIE9wdGlvbmFsIGRhdGEgcGFzc2VkIHRvIHRoZSBldmVudCByZWNlaXZlciAoZS5nLiB7QGxpbmsgI0V2ZW50RGF0YX0pXG4gICAgICogQHJldHVybnMge09iamVjdH0gYHRoaXNgXG4gICAgICovXG4gICAgZmlyZTogZnVuY3Rpb24odHlwZSwgZGF0YSkge1xuICAgICAgICBpZiAoIXRoaXMubGlzdGVucyh0eXBlKSkgcmV0dXJuIHRoaXM7XG5cbiAgICAgICAgZGF0YSA9IHV0aWwuZXh0ZW5kKHt9LCBkYXRhKTtcbiAgICAgICAgdXRpbC5leHRlbmQoZGF0YSwge3R5cGU6IHR5cGUsIHRhcmdldDogdGhpc30pO1xuXG4gICAgICAgIC8vIG1ha2Ugc3VyZSBhZGRpbmcvcmVtb3ZpbmcgbGlzdGVuZXJzIGluc2lkZSBvdGhlciBsaXN0ZW5lcnMgd29uJ3QgY2F1c2UgaW5maW5pdGUgbG9vcFxuICAgICAgICB2YXIgbGlzdGVuZXJzID0gdGhpcy5fZXZlbnRzW3R5cGVdLnNsaWNlKCk7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0ZW5lcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxpc3RlbmVyc1tpXS5jYWxsKHRoaXMsIGRhdGEpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIGFuIGV2ZW50IGlzIHJlZ2lzdGVyZWQgdG8gYSB0eXBlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgRXZlbnQgdHlwZVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBgdHJ1ZWAgaWYgdGhlcmUgaXMgYXQgbGVhc3Qgb25lIHJlZ2lzdGVyZWQgbGlzdGVuZXIgZm9yIGV2ZW50cyBvZiB0eXBlIGB0eXBlYFxuICAgICAqL1xuICAgIGxpc3RlbnM6IGZ1bmN0aW9uKHR5cGUpIHtcbiAgICAgICAgcmV0dXJuICEhKHRoaXMuX2V2ZW50cyAmJiB0aGlzLl9ldmVudHNbdHlwZV0pO1xuICAgIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRXZlbnRlZDtcbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBHbHlwaHM7XG5cbmZ1bmN0aW9uIEdseXBocyhwYmYsIGVuZCkge1xuICAgIHRoaXMuc3RhY2tzID0gcGJmLnJlYWRGaWVsZHMocmVhZEZvbnRzdGFja3MsIFtdLCBlbmQpO1xufVxuXG5mdW5jdGlvbiByZWFkRm9udHN0YWNrcyh0YWcsIHN0YWNrcywgcGJmKSB7XG4gICAgaWYgKHRhZyA9PT0gMSkge1xuICAgICAgICB2YXIgZm9udHN0YWNrID0gcGJmLnJlYWRNZXNzYWdlKHJlYWRGb250c3RhY2ssIHtnbHlwaHM6IHt9fSk7XG4gICAgICAgIHN0YWNrcy5wdXNoKGZvbnRzdGFjayk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiByZWFkRm9udHN0YWNrKHRhZywgZm9udHN0YWNrLCBwYmYpIHtcbiAgICBpZiAodGFnID09PSAxKSBmb250c3RhY2submFtZSA9IHBiZi5yZWFkU3RyaW5nKCk7XG4gICAgZWxzZSBpZiAodGFnID09PSAyKSBmb250c3RhY2sucmFuZ2UgPSBwYmYucmVhZFN0cmluZygpO1xuICAgIGVsc2UgaWYgKHRhZyA9PT0gMykge1xuICAgICAgICB2YXIgZ2x5cGggPSBwYmYucmVhZE1lc3NhZ2UocmVhZEdseXBoLCB7fSk7XG4gICAgICAgIGZvbnRzdGFjay5nbHlwaHNbZ2x5cGguaWRdID0gZ2x5cGg7XG4gICAgfVxufVxuXG5mdW5jdGlvbiByZWFkR2x5cGgodGFnLCBnbHlwaCwgcGJmKSB7XG4gICAgaWYgKHRhZyA9PT0gMSkgZ2x5cGguaWQgPSBwYmYucmVhZFZhcmludCgpO1xuICAgIGVsc2UgaWYgKHRhZyA9PT0gMikgZ2x5cGguYml0bWFwID0gcGJmLnJlYWRCeXRlcygpO1xuICAgIGVsc2UgaWYgKHRhZyA9PT0gMykgZ2x5cGgud2lkdGggPSBwYmYucmVhZFZhcmludCgpO1xuICAgIGVsc2UgaWYgKHRhZyA9PT0gNCkgZ2x5cGguaGVpZ2h0ID0gcGJmLnJlYWRWYXJpbnQoKTtcbiAgICBlbHNlIGlmICh0YWcgPT09IDUpIGdseXBoLmxlZnQgPSBwYmYucmVhZFNWYXJpbnQoKTtcbiAgICBlbHNlIGlmICh0YWcgPT09IDYpIGdseXBoLnRvcCA9IHBiZi5yZWFkU1ZhcmludCgpO1xuICAgIGVsc2UgaWYgKHRhZyA9PT0gNykgZ2x5cGguYWR2YW5jZSA9IHBiZi5yZWFkVmFyaW50KCk7XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gR3JpZDtcblxudmFyIE5VTV9QQVJBTVMgPSAzO1xuXG5mdW5jdGlvbiBHcmlkKG4sIGV4dGVudCwgcGFkZGluZykge1xuICAgIHZhciBjZWxscyA9IHRoaXMuY2VsbHMgPSBbXTtcblxuICAgIGlmIChuIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICAgICAgdGhpcy5hcnJheUJ1ZmZlciA9IG47XG4gICAgICAgIHZhciBhcnJheSA9IG5ldyBJbnQzMkFycmF5KHRoaXMuYXJyYXlCdWZmZXIpO1xuICAgICAgICBuID0gYXJyYXlbMF07XG4gICAgICAgIGV4dGVudCA9IGFycmF5WzFdO1xuICAgICAgICBwYWRkaW5nID0gYXJyYXlbMl07XG5cbiAgICAgICAgdGhpcy5kID0gbiArIDIgKiBwYWRkaW5nO1xuICAgICAgICBmb3IgKHZhciBrID0gMDsgayA8IHRoaXMuZCAqIHRoaXMuZDsgaysrKSB7XG4gICAgICAgICAgICB2YXIgc3RhcnQgPSBhcnJheVtOVU1fUEFSQU1TICsga107XG4gICAgICAgICAgICB2YXIgZW5kID0gYXJyYXlbTlVNX1BBUkFNUyArIGsgKyAxXTtcbiAgICAgICAgICAgIGNlbGxzLnB1c2goc3RhcnQgPT09IGVuZCA/XG4gICAgICAgICAgICAgICAgICAgIG51bGwgOlxuICAgICAgICAgICAgICAgICAgICBhcnJheS5zdWJhcnJheShzdGFydCwgZW5kKSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGtleXNPZmZzZXQgPSBhcnJheVtOVU1fUEFSQU1TICsgY2VsbHMubGVuZ3RoXTtcbiAgICAgICAgdmFyIGJib3hlc09mZnNldCA9IGFycmF5W05VTV9QQVJBTVMgKyBjZWxscy5sZW5ndGggKyAxXTtcbiAgICAgICAgdGhpcy5rZXlzID0gYXJyYXkuc3ViYXJyYXkoa2V5c09mZnNldCwgYmJveGVzT2Zmc2V0KTtcbiAgICAgICAgdGhpcy5iYm94ZXMgPSBhcnJheS5zdWJhcnJheShiYm94ZXNPZmZzZXQpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZCA9IG4gKyAyICogcGFkZGluZztcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmQgKiB0aGlzLmQ7IGkrKykge1xuICAgICAgICAgICAgY2VsbHMucHVzaChbXSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5rZXlzID0gW107XG4gICAgICAgIHRoaXMuYmJveGVzID0gW107XG4gICAgfVxuXG4gICAgdGhpcy5uID0gbjtcbiAgICB0aGlzLmV4dGVudCA9IGV4dGVudDtcbiAgICB0aGlzLnBhZGRpbmcgPSBwYWRkaW5nO1xuICAgIHRoaXMuc2NhbGUgPSBuIC8gZXh0ZW50O1xuICAgIHRoaXMudWlkID0gMDtcblxuICAgIHZhciBwID0gKHBhZGRpbmcgLyBuKSAqIGV4dGVudDtcbiAgICB0aGlzLm1pbiA9IC1wO1xuICAgIHRoaXMubWF4ID0gZXh0ZW50ICsgcDtcbn1cblxuXG5HcmlkLnByb3RvdHlwZS5pbnNlcnQgPSBmdW5jdGlvbihrZXksIHgxLCB5MSwgeDIsIHkyKSB7XG4gICAgdGhpcy5fZm9yRWFjaENlbGwoeDEsIHkxLCB4MiwgeTIsIHRoaXMuX2luc2VydENlbGwsIHRoaXMudWlkKyspO1xuICAgIHRoaXMua2V5cy5wdXNoKGtleSk7XG4gICAgdGhpcy5iYm94ZXMucHVzaCh4MSk7XG4gICAgdGhpcy5iYm94ZXMucHVzaCh5MSk7XG4gICAgdGhpcy5iYm94ZXMucHVzaCh4Mik7XG4gICAgdGhpcy5iYm94ZXMucHVzaCh5Mik7XG59O1xuXG5HcmlkLnByb3RvdHlwZS5faW5zZXJ0Q2VsbCA9IGZ1bmN0aW9uKHgxLCB5MSwgeDIsIHkyLCBjZWxsSW5kZXgsIHVpZCkge1xuICAgIHRoaXMuY2VsbHNbY2VsbEluZGV4XS5wdXNoKHVpZCk7XG59O1xuXG5HcmlkLnByb3RvdHlwZS5xdWVyeSA9IGZ1bmN0aW9uKHgxLCB5MSwgeDIsIHkyKSB7XG4gICAgdmFyIG1pbiA9IHRoaXMubWluO1xuICAgIHZhciBtYXggPSB0aGlzLm1heDtcbiAgICBpZiAoeDEgPD0gbWluICYmIHkxIDw9IG1pbiAmJiBtYXggPD0geDIgJiYgbWF4IDw9IHkyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmtleXMuc2xpY2UoKTtcblxuICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgICAgdmFyIHNlZW5VaWRzID0ge307XG4gICAgICAgIHRoaXMuX2ZvckVhY2hDZWxsKHgxLCB5MSwgeDIsIHkyLCB0aGlzLl9xdWVyeUNlbGwsIHJlc3VsdCwgc2VlblVpZHMpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbn07XG5cbkdyaWQucHJvdG90eXBlLl9xdWVyeUNlbGwgPSBmdW5jdGlvbih4MSwgeTEsIHgyLCB5MiwgY2VsbEluZGV4LCByZXN1bHQsIHNlZW5VaWRzKSB7XG4gICAgdmFyIGNlbGwgPSB0aGlzLmNlbGxzW2NlbGxJbmRleF07XG4gICAgaWYgKGNlbGwgIT09IG51bGwpIHtcbiAgICAgICAgdmFyIGtleXMgPSB0aGlzLmtleXM7XG4gICAgICAgIHZhciBiYm94ZXMgPSB0aGlzLmJib3hlcztcbiAgICAgICAgZm9yICh2YXIgdSA9IDA7IHUgPCBjZWxsLmxlbmd0aDsgdSsrKSB7XG4gICAgICAgICAgICB2YXIgdWlkID0gY2VsbFt1XTtcbiAgICAgICAgICAgIGlmIChzZWVuVWlkc1t1aWRdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB2YXIgb2Zmc2V0ID0gdWlkICogNDtcbiAgICAgICAgICAgICAgICBpZiAoKHgxIDw9IGJib3hlc1tvZmZzZXQgKyAyXSkgJiZcbiAgICAgICAgICAgICAgICAgICAgKHkxIDw9IGJib3hlc1tvZmZzZXQgKyAzXSkgJiZcbiAgICAgICAgICAgICAgICAgICAgKHgyID49IGJib3hlc1tvZmZzZXQgKyAwXSkgJiZcbiAgICAgICAgICAgICAgICAgICAgKHkyID49IGJib3hlc1tvZmZzZXQgKyAxXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VlblVpZHNbdWlkXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGtleXNbdWlkXSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc2VlblVpZHNbdWlkXSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn07XG5cbkdyaWQucHJvdG90eXBlLl9mb3JFYWNoQ2VsbCA9IGZ1bmN0aW9uKHgxLCB5MSwgeDIsIHkyLCBmbiwgYXJnMSwgYXJnMikge1xuICAgIHZhciBjeDEgPSB0aGlzLl9jb252ZXJ0VG9DZWxsQ29vcmQoeDEpO1xuICAgIHZhciBjeTEgPSB0aGlzLl9jb252ZXJ0VG9DZWxsQ29vcmQoeTEpO1xuICAgIHZhciBjeDIgPSB0aGlzLl9jb252ZXJ0VG9DZWxsQ29vcmQoeDIpO1xuICAgIHZhciBjeTIgPSB0aGlzLl9jb252ZXJ0VG9DZWxsQ29vcmQoeTIpO1xuICAgIGZvciAodmFyIHggPSBjeDE7IHggPD0gY3gyOyB4KyspIHtcbiAgICAgICAgZm9yICh2YXIgeSA9IGN5MTsgeSA8PSBjeTI7IHkrKykge1xuICAgICAgICAgICAgdmFyIGNlbGxJbmRleCA9IHRoaXMuZCAqIHkgKyB4O1xuICAgICAgICAgICAgaWYgKGZuLmNhbGwodGhpcywgeDEsIHkxLCB4MiwgeTIsIGNlbGxJbmRleCwgYXJnMSwgYXJnMikpIHJldHVybjtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbkdyaWQucHJvdG90eXBlLl9jb252ZXJ0VG9DZWxsQ29vcmQgPSBmdW5jdGlvbih4KSB7XG4gICAgcmV0dXJuIE1hdGgubWF4KDAsIE1hdGgubWluKHRoaXMuZCAtIDEsIE1hdGguZmxvb3IoeCAqIHRoaXMuc2NhbGUpICsgdGhpcy5wYWRkaW5nKSk7XG59O1xuXG5HcmlkLnByb3RvdHlwZS50b0FycmF5QnVmZmVyID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuYXJyYXlCdWZmZXIpIHJldHVybiB0aGlzLmFycmF5QnVmZmVyO1xuXG4gICAgdmFyIGNlbGxzID0gdGhpcy5jZWxscztcblxuICAgIHZhciBtZXRhZGF0YUxlbmd0aCA9IE5VTV9QQVJBTVMgKyB0aGlzLmNlbGxzLmxlbmd0aCArIDEgKyAxO1xuICAgIHZhciB0b3RhbENlbGxMZW5ndGggPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5jZWxscy5sZW5ndGg7IGkrKykge1xuICAgICAgICB0b3RhbENlbGxMZW5ndGggKz0gdGhpcy5jZWxsc1tpXS5sZW5ndGg7XG4gICAgfVxuXG4gICAgdmFyIGFycmF5ID0gbmV3IEludDMyQXJyYXkobWV0YWRhdGFMZW5ndGggKyB0b3RhbENlbGxMZW5ndGggKyB0aGlzLmtleXMubGVuZ3RoICsgdGhpcy5iYm94ZXMubGVuZ3RoKTtcbiAgICBhcnJheVswXSA9IHRoaXMubjtcbiAgICBhcnJheVsxXSA9IHRoaXMuZXh0ZW50O1xuICAgIGFycmF5WzJdID0gdGhpcy5wYWRkaW5nO1xuXG4gICAgdmFyIG9mZnNldCA9IG1ldGFkYXRhTGVuZ3RoO1xuICAgIGZvciAodmFyIGsgPSAwOyBrIDwgY2VsbHMubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgdmFyIGNlbGwgPSBjZWxsc1trXTtcbiAgICAgICAgYXJyYXlbTlVNX1BBUkFNUyArIGtdID0gb2Zmc2V0O1xuICAgICAgICBhcnJheS5zZXQoY2VsbCwgb2Zmc2V0KTtcbiAgICAgICAgb2Zmc2V0ICs9IGNlbGwubGVuZ3RoO1xuICAgIH1cblxuICAgIGFycmF5W05VTV9QQVJBTVMgKyBjZWxscy5sZW5ndGhdID0gb2Zmc2V0O1xuICAgIGFycmF5LnNldCh0aGlzLmtleXMsIG9mZnNldCk7XG4gICAgb2Zmc2V0ICs9IHRoaXMua2V5cy5sZW5ndGg7XG5cbiAgICBhcnJheVtOVU1fUEFSQU1TICsgY2VsbHMubGVuZ3RoICsgMV0gPSBvZmZzZXQ7XG4gICAgYXJyYXkuc2V0KHRoaXMuYmJveGVzLCBvZmZzZXQpO1xuICAgIG9mZnNldCArPSB0aGlzLmJib3hlcy5sZW5ndGg7XG5cbiAgICByZXR1cm4gYXJyYXkuYnVmZmVyO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBpbnRlcnBvbGF0ZTtcblxuZnVuY3Rpb24gaW50ZXJwb2xhdGUoYSwgYiwgdCkge1xuICAgIHJldHVybiAoYSAqICgxIC0gdCkpICsgKGIgKiB0KTtcbn1cblxuaW50ZXJwb2xhdGUubnVtYmVyID0gaW50ZXJwb2xhdGU7XG5cbmludGVycG9sYXRlLnZlYzIgPSBmdW5jdGlvbihmcm9tLCB0bywgdCkge1xuICAgIHJldHVybiBbXG4gICAgICAgIGludGVycG9sYXRlKGZyb21bMF0sIHRvWzBdLCB0KSxcbiAgICAgICAgaW50ZXJwb2xhdGUoZnJvbVsxXSwgdG9bMV0sIHQpXG4gICAgXTtcbn07XG5cbi8qXG4gKiBJbnRlcnBvbGF0ZSBiZXR3ZWVuIHR3byBjb2xvcnMgZ2l2ZW4gYXMgNC1lbGVtZW50IGFycmF5cy5cbiAqXG4gKiBAcGFyYW0ge0NvbG9yfSBmcm9tXG4gKiBAcGFyYW0ge0NvbG9yfSB0b1xuICogQHBhcmFtIHtudW1iZXJ9IHQgaW50ZXJwb2xhdGlvbiBmYWN0b3IgYmV0d2VlbiAwIGFuZCAxXG4gKiBAcmV0dXJucyB7Q29sb3J9IGludGVycG9sYXRlZCBjb2xvclxuICovXG5pbnRlcnBvbGF0ZS5jb2xvciA9IGZ1bmN0aW9uKGZyb20sIHRvLCB0KSB7XG4gICAgcmV0dXJuIFtcbiAgICAgICAgaW50ZXJwb2xhdGUoZnJvbVswXSwgdG9bMF0sIHQpLFxuICAgICAgICBpbnRlcnBvbGF0ZShmcm9tWzFdLCB0b1sxXSwgdCksXG4gICAgICAgIGludGVycG9sYXRlKGZyb21bMl0sIHRvWzJdLCB0KSxcbiAgICAgICAgaW50ZXJwb2xhdGUoZnJvbVszXSwgdG9bM10sIHQpXG4gICAgXTtcbn07XG5cbmludGVycG9sYXRlLmFycmF5ID0gZnVuY3Rpb24oZnJvbSwgdG8sIHQpIHtcbiAgICByZXR1cm4gZnJvbS5tYXAoZnVuY3Rpb24oZCwgaSkge1xuICAgICAgICByZXR1cm4gaW50ZXJwb2xhdGUoZCwgdG9baV0sIHQpO1xuICAgIH0pO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgbXVsdGlQb2x5Z29uSW50ZXJzZWN0c0J1ZmZlcmVkTXVsdGlQb2ludDogbXVsdGlQb2x5Z29uSW50ZXJzZWN0c0J1ZmZlcmVkTXVsdGlQb2ludCxcbiAgICBtdWx0aVBvbHlnb25JbnRlcnNlY3RzTXVsdGlQb2x5Z29uOiBtdWx0aVBvbHlnb25JbnRlcnNlY3RzTXVsdGlQb2x5Z29uLFxuICAgIG11bHRpUG9seWdvbkludGVyc2VjdHNCdWZmZXJlZE11bHRpTGluZTogbXVsdGlQb2x5Z29uSW50ZXJzZWN0c0J1ZmZlcmVkTXVsdGlMaW5lXG59O1xuXG5mdW5jdGlvbiBtdWx0aVBvbHlnb25JbnRlcnNlY3RzQnVmZmVyZWRNdWx0aVBvaW50KG11bHRpUG9seWdvbiwgcmluZ3MsIHJhZGl1cykge1xuICAgIGZvciAodmFyIGogPSAwOyBqIDwgbXVsdGlQb2x5Z29uLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIHZhciBwb2x5Z29uID0gbXVsdGlQb2x5Z29uW2pdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJpbmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgcmluZyA9IHJpbmdzW2ldO1xuICAgICAgICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCByaW5nLmxlbmd0aDsgaysrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBvaW50ID0gcmluZ1trXTtcbiAgICAgICAgICAgICAgICBpZiAocG9seWdvbkNvbnRhaW5zUG9pbnQocG9seWdvbiwgcG9pbnQpKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICBpZiAocG9pbnRJbnRlcnNlY3RzQnVmZmVyZWRMaW5lKHBvaW50LCBwb2x5Z29uLCByYWRpdXMpKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIG11bHRpUG9seWdvbkludGVyc2VjdHNNdWx0aVBvbHlnb24obXVsdGlQb2x5Z29uQSwgbXVsdGlQb2x5Z29uQikge1xuXG4gICAgaWYgKG11bHRpUG9seWdvbkEubGVuZ3RoID09PSAxICYmIG11bHRpUG9seWdvbkFbMF0ubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHJldHVybiBtdWx0aVBvbHlnb25Db250YWluc1BvaW50KG11bHRpUG9seWdvbkIsIG11bHRpUG9seWdvbkFbMF1bMF0pO1xuICAgIH1cblxuICAgIGZvciAodmFyIG0gPSAwOyBtIDwgbXVsdGlQb2x5Z29uQi5sZW5ndGg7IG0rKykge1xuICAgICAgICB2YXIgcmluZyA9IG11bHRpUG9seWdvbkJbbV07XG4gICAgICAgIGZvciAodmFyIG4gPSAwOyBuIDwgcmluZy5sZW5ndGg7IG4rKykge1xuICAgICAgICAgICAgaWYgKG11bHRpUG9seWdvbkNvbnRhaW5zUG9pbnQobXVsdGlQb2x5Z29uQSwgcmluZ1tuXSkpIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBtdWx0aVBvbHlnb25BLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIHZhciBwb2x5Z29uID0gbXVsdGlQb2x5Z29uQVtqXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwb2x5Z29uLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAobXVsdGlQb2x5Z29uQ29udGFpbnNQb2ludChtdWx0aVBvbHlnb25CLCBwb2x5Z29uW2ldKSkgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHZhciBrID0gMDsgayA8IG11bHRpUG9seWdvbkIubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgICAgIGlmIChsaW5lSW50ZXJzZWN0c0xpbmUocG9seWdvbiwgbXVsdGlQb2x5Z29uQltrXSkpIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBtdWx0aVBvbHlnb25JbnRlcnNlY3RzQnVmZmVyZWRNdWx0aUxpbmUobXVsdGlQb2x5Z29uLCBtdWx0aUxpbmUsIHJhZGl1cykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbXVsdGlMaW5lLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBsaW5lID0gbXVsdGlMaW5lW2ldO1xuXG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbXVsdGlQb2x5Z29uLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICB2YXIgcG9seWdvbiA9IG11bHRpUG9seWdvbltqXTtcblxuICAgICAgICAgICAgaWYgKHBvbHlnb24ubGVuZ3RoID49IDMpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBrID0gMDsgayA8IGxpbmUubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBvbHlnb25Db250YWluc1BvaW50KHBvbHlnb24sIGxpbmVba10pKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChsaW5lSW50ZXJzZWN0c0J1ZmZlcmVkTGluZShwb2x5Z29uLCBsaW5lLCByYWRpdXMpKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGxpbmVJbnRlcnNlY3RzQnVmZmVyZWRMaW5lKGxpbmVBLCBsaW5lQiwgcmFkaXVzKSB7XG5cbiAgICBpZiAobGluZUEubGVuZ3RoID4gMSkge1xuICAgICAgICBpZiAobGluZUludGVyc2VjdHNMaW5lKGxpbmVBLCBsaW5lQikpIHJldHVybiB0cnVlO1xuXG4gICAgICAgIC8vIENoZWNrIHdoZXRoZXIgYW55IHBvaW50IGluIGVpdGhlciBsaW5lIGlzIHdpdGhpbiByYWRpdXMgb2YgdGhlIG90aGVyIGxpbmVcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBsaW5lQi5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgaWYgKHBvaW50SW50ZXJzZWN0c0J1ZmZlcmVkTGluZShsaW5lQltqXSwgbGluZUEsIHJhZGl1cykpIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZm9yICh2YXIgayA9IDA7IGsgPCBsaW5lQS5sZW5ndGg7IGsrKykge1xuICAgICAgICBpZiAocG9pbnRJbnRlcnNlY3RzQnVmZmVyZWRMaW5lKGxpbmVBW2tdLCBsaW5lQiwgcmFkaXVzKSkgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBsaW5lSW50ZXJzZWN0c0xpbmUobGluZUEsIGxpbmVCKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaW5lQS5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgICAgdmFyIGEwID0gbGluZUFbaV07XG4gICAgICAgIHZhciBhMSA9IGxpbmVBW2kgKyAxXTtcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBsaW5lQi5sZW5ndGggLSAxOyBqKyspIHtcbiAgICAgICAgICAgIHZhciBiMCA9IGxpbmVCW2pdO1xuICAgICAgICAgICAgdmFyIGIxID0gbGluZUJbaiArIDFdO1xuICAgICAgICAgICAgaWYgKGxpbmVTZWdtZW50SW50ZXJzZWN0c0xpbmVTZWdtZW50KGEwLCBhMSwgYjAsIGIxKSkgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuXG5cbi8vIGh0dHA6Ly9icnljZWJvZS5jb20vMjAwNi8xMC8yMy9saW5lLXNlZ21lbnQtaW50ZXJzZWN0aW9uLWFsZ29yaXRobS9cbmZ1bmN0aW9uIGlzQ291bnRlckNsb2Nrd2lzZShhLCBiLCBjKSB7XG4gICAgcmV0dXJuIChjLnkgLSBhLnkpICogKGIueCAtIGEueCkgPiAoYi55IC0gYS55KSAqIChjLnggLSBhLngpO1xufVxuXG5mdW5jdGlvbiBsaW5lU2VnbWVudEludGVyc2VjdHNMaW5lU2VnbWVudChhMCwgYTEsIGIwLCBiMSkge1xuICAgIHJldHVybiBpc0NvdW50ZXJDbG9ja3dpc2UoYTAsIGIwLCBiMSkgIT09IGlzQ291bnRlckNsb2Nrd2lzZShhMSwgYjAsIGIxKSAmJlxuICAgICAgICBpc0NvdW50ZXJDbG9ja3dpc2UoYTAsIGExLCBiMCkgIT09IGlzQ291bnRlckNsb2Nrd2lzZShhMCwgYTEsIGIxKTtcbn1cblxuZnVuY3Rpb24gcG9pbnRJbnRlcnNlY3RzQnVmZmVyZWRMaW5lKHAsIGxpbmUsIHJhZGl1cykge1xuICAgIHZhciByYWRpdXNTcXVhcmVkID0gcmFkaXVzICogcmFkaXVzO1xuXG4gICAgaWYgKGxpbmUubGVuZ3RoID09PSAxKSByZXR1cm4gcC5kaXN0U3FyKGxpbmVbMF0pIDwgcmFkaXVzU3F1YXJlZDtcblxuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgbGluZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAvLyBGaW5kIGxpbmUgc2VnbWVudHMgdGhhdCBoYXZlIGEgZGlzdGFuY2UgPD0gcmFkaXVzXjIgdG8gcFxuICAgICAgICAvLyBJbiB0aGF0IGNhc2UsIHdlIHRyZWF0IHRoZSBsaW5lIGFzIFwiY29udGFpbmluZyBwb2ludCBwXCIuXG4gICAgICAgIHZhciB2ID0gbGluZVtpIC0gMV0sIHcgPSBsaW5lW2ldO1xuICAgICAgICBpZiAoZGlzdFRvU2VnbWVudFNxdWFyZWQocCwgdiwgdykgPCByYWRpdXNTcXVhcmVkKSByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuXG4vLyBDb2RlIGZyb20gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMTUwMTcyNS8zMzEzNzkuXG5mdW5jdGlvbiBkaXN0VG9TZWdtZW50U3F1YXJlZChwLCB2LCB3KSB7XG4gICAgdmFyIGwyID0gdi5kaXN0U3FyKHcpO1xuICAgIGlmIChsMiA9PT0gMCkgcmV0dXJuIHAuZGlzdFNxcih2KTtcbiAgICB2YXIgdCA9ICgocC54IC0gdi54KSAqICh3LnggLSB2LngpICsgKHAueSAtIHYueSkgKiAody55IC0gdi55KSkgLyBsMjtcbiAgICBpZiAodCA8IDApIHJldHVybiBwLmRpc3RTcXIodik7XG4gICAgaWYgKHQgPiAxKSByZXR1cm4gcC5kaXN0U3FyKHcpO1xuICAgIHJldHVybiBwLmRpc3RTcXIody5zdWIodikuX211bHQodCkuX2FkZCh2KSk7XG59XG5cbi8vIHBvaW50IGluIHBvbHlnb24gcmF5IGNhc3RpbmcgYWxnb3JpdGhtXG5mdW5jdGlvbiBtdWx0aVBvbHlnb25Db250YWluc1BvaW50KHJpbmdzLCBwKSB7XG4gICAgdmFyIGMgPSBmYWxzZSxcbiAgICAgICAgcmluZywgcDEsIHAyO1xuXG4gICAgZm9yICh2YXIgayA9IDA7IGsgPCByaW5ncy5sZW5ndGg7IGsrKykge1xuICAgICAgICByaW5nID0gcmluZ3Nba107XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBqID0gcmluZy5sZW5ndGggLSAxOyBpIDwgcmluZy5sZW5ndGg7IGogPSBpKyspIHtcbiAgICAgICAgICAgIHAxID0gcmluZ1tpXTtcbiAgICAgICAgICAgIHAyID0gcmluZ1tqXTtcbiAgICAgICAgICAgIGlmICgoKHAxLnkgPiBwLnkpICE9PSAocDIueSA+IHAueSkpICYmIChwLnggPCAocDIueCAtIHAxLngpICogKHAueSAtIHAxLnkpIC8gKHAyLnkgLSBwMS55KSArIHAxLngpKSB7XG4gICAgICAgICAgICAgICAgYyA9ICFjO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjO1xufVxuXG5mdW5jdGlvbiBwb2x5Z29uQ29udGFpbnNQb2ludChyaW5nLCBwKSB7XG4gICAgdmFyIGMgPSBmYWxzZTtcbiAgICBmb3IgKHZhciBpID0gMCwgaiA9IHJpbmcubGVuZ3RoIC0gMTsgaSA8IHJpbmcubGVuZ3RoOyBqID0gaSsrKSB7XG4gICAgICAgIHZhciBwMSA9IHJpbmdbaV07XG4gICAgICAgIHZhciBwMiA9IHJpbmdbal07XG4gICAgICAgIGlmICgoKHAxLnkgPiBwLnkpICE9PSAocDIueSA+IHAueSkpICYmIChwLnggPCAocDIueCAtIHAxLngpICogKHAueSAtIHAxLnkpIC8gKHAyLnkgLSBwMS55KSArIHAxLngpKSB7XG4gICAgICAgICAgICBjID0gIWM7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGM7XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gTFJVQ2FjaGU7XG5cbi8qKlxuICogQSBbbGVhc3QtcmVjZW50bHktdXNlZCBjYWNoZV0oaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9DYWNoZV9hbGdvcml0aG1zKVxuICogd2l0aCBoYXNoIGxvb2t1cCBtYWRlIHBvc3NpYmxlIGJ5IGtlZXBpbmcgYSBsaXN0IG9mIGtleXMgaW4gcGFyYWxsZWwgdG9cbiAqIGFuIGFycmF5IG9mIGRpY3Rpb25hcnkgb2YgdmFsdWVzXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IG1heCBudW1iZXIgb2YgcGVybWl0dGVkIHZhbHVlc1xuICogQHBhcmFtIHtGdW5jdGlvbn0gb25SZW1vdmUgY2FsbGJhY2sgY2FsbGVkIHdpdGggaXRlbXMgd2hlbiB0aGV5IGV4cGlyZVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gTFJVQ2FjaGUobWF4LCBvblJlbW92ZSkge1xuICAgIHRoaXMubWF4ID0gbWF4O1xuICAgIHRoaXMub25SZW1vdmUgPSBvblJlbW92ZTtcbiAgICB0aGlzLnJlc2V0KCk7XG59XG5cbi8qKlxuICogQ2xlYXIgdGhlIGNhY2hlXG4gKlxuICogQHJldHVybnMge0xSVUNhY2hlfSB0aGlzIGNhY2hlXG4gKiBAcHJpdmF0ZVxuICovXG5MUlVDYWNoZS5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbigpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gdGhpcy5kYXRhKSB7XG4gICAgICAgIHRoaXMub25SZW1vdmUodGhpcy5kYXRhW2tleV0pO1xuICAgIH1cblxuICAgIHRoaXMuZGF0YSA9IHt9O1xuICAgIHRoaXMub3JkZXIgPSBbXTtcblxuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBBZGQgYSBrZXksIHZhbHVlIGNvbWJpbmF0aW9uIHRvIHRoZSBjYWNoZSwgdHJpbW1pbmcgaXRzIHNpemUgaWYgdGhpcyBwdXNoZXNcbiAqIGl0IG92ZXIgbWF4IGxlbmd0aC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IGxvb2t1cCBrZXkgZm9yIHRoZSBpdGVtXG4gKiBAcGFyYW0geyp9IGRhdGEgYW55IHZhbHVlXG4gKlxuICogQHJldHVybnMge0xSVUNhY2hlfSB0aGlzIGNhY2hlXG4gKiBAcHJpdmF0ZVxuICovXG5MUlVDYWNoZS5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24oa2V5LCBkYXRhKSB7XG5cbiAgICBpZiAodGhpcy5oYXMoa2V5KSkge1xuICAgICAgICB0aGlzLm9yZGVyLnNwbGljZSh0aGlzLm9yZGVyLmluZGV4T2Yoa2V5KSwgMSk7XG4gICAgICAgIHRoaXMuZGF0YVtrZXldID0gZGF0YTtcbiAgICAgICAgdGhpcy5vcmRlci5wdXNoKGtleSk7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmRhdGFba2V5XSA9IGRhdGE7XG4gICAgICAgIHRoaXMub3JkZXIucHVzaChrZXkpO1xuXG4gICAgICAgIGlmICh0aGlzLm9yZGVyLmxlbmd0aCA+IHRoaXMubWF4KSB7XG4gICAgICAgICAgICB2YXIgcmVtb3ZlZERhdGEgPSB0aGlzLmdldCh0aGlzLm9yZGVyWzBdKTtcbiAgICAgICAgICAgIGlmIChyZW1vdmVkRGF0YSkgdGhpcy5vblJlbW92ZShyZW1vdmVkRGF0YSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogRGV0ZXJtaW5lIHdoZXRoZXIgdGhlIHZhbHVlIGF0dGFjaGVkIHRvIGBrZXlgIGlzIHByZXNlbnRcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IHRoZSBrZXkgdG8gYmUgbG9va2VkLXVwXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gd2hldGhlciB0aGUgY2FjaGUgaGFzIHRoaXMgdmFsdWVcbiAqIEBwcml2YXRlXG4gKi9cbkxSVUNhY2hlLnByb3RvdHlwZS5oYXMgPSBmdW5jdGlvbihrZXkpIHtcbiAgICByZXR1cm4ga2V5IGluIHRoaXMuZGF0YTtcbn07XG5cbi8qKlxuICogTGlzdCBhbGwga2V5cyBpbiB0aGUgY2FjaGVcbiAqXG4gKiBAcmV0dXJucyB7QXJyYXk8c3RyaW5nPn0gYW4gYXJyYXkgb2Yga2V5cyBpbiB0aGlzIGNhY2hlLlxuICogQHByaXZhdGVcbiAqL1xuTFJVQ2FjaGUucHJvdG90eXBlLmtleXMgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5vcmRlcjtcbn07XG5cbi8qKlxuICogR2V0IHRoZSB2YWx1ZSBhdHRhY2hlZCB0byBhIHNwZWNpZmljIGtleS4gSWYgdGhlIGtleSBpcyBub3QgZm91bmQsXG4gKiByZXR1cm5zIGBudWxsYFxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgdGhlIGtleSB0byBsb29rIHVwXG4gKiBAcmV0dXJucyB7Kn0gdGhlIGRhdGEsIG9yIG51bGwgaWYgaXQgaXNuJ3QgZm91bmRcbiAqIEBwcml2YXRlXG4gKi9cbkxSVUNhY2hlLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbihrZXkpIHtcbiAgICBpZiAoIXRoaXMuaGFzKGtleSkpIHsgcmV0dXJuIG51bGw7IH1cblxuICAgIHZhciBkYXRhID0gdGhpcy5kYXRhW2tleV07XG5cbiAgICBkZWxldGUgdGhpcy5kYXRhW2tleV07XG4gICAgdGhpcy5vcmRlci5zcGxpY2UodGhpcy5vcmRlci5pbmRleE9mKGtleSksIDEpO1xuXG4gICAgcmV0dXJuIGRhdGE7XG59O1xuXG4vKipcbiAqIENoYW5nZSB0aGUgbWF4IHNpemUgb2YgdGhlIGNhY2hlLlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBtYXggdGhlIG1heCBzaXplIG9mIHRoZSBjYWNoZVxuICogQHJldHVybnMge0xSVUNhY2hlfSB0aGlzIGNhY2hlXG4gKiBAcHJpdmF0ZVxuICovXG5MUlVDYWNoZS5wcm90b3R5cGUuc2V0TWF4U2l6ZSA9IGZ1bmN0aW9uKG1heCkge1xuICAgIHRoaXMubWF4ID0gbWF4O1xuXG4gICAgd2hpbGUgKHRoaXMub3JkZXIubGVuZ3RoID4gdGhpcy5tYXgpIHtcbiAgICAgICAgdmFyIHJlbW92ZWREYXRhID0gdGhpcy5nZXQodGhpcy5vcmRlclswXSk7XG4gICAgICAgIGlmIChyZW1vdmVkRGF0YSkgdGhpcy5vblJlbW92ZShyZW1vdmVkRGF0YSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgY29uZmlnID0gcmVxdWlyZSgnLi9jb25maWcnKTtcbnZhciBicm93c2VyID0gcmVxdWlyZSgnLi9icm93c2VyJyk7XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZVVSTCh1cmwsIHBhdGhQcmVmaXgsIGFjY2Vzc1Rva2VuKSB7XG4gICAgYWNjZXNzVG9rZW4gPSBhY2Nlc3NUb2tlbiB8fCBjb25maWcuQUNDRVNTX1RPS0VOO1xuXG4gICAgaWYgKCFhY2Nlc3NUb2tlbiAmJiBjb25maWcuUkVRVUlSRV9BQ0NFU1NfVE9LRU4pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBbiBBUEkgYWNjZXNzIHRva2VuIGlzIHJlcXVpcmVkIHRvIHVzZSBNYXBib3ggR0wuICcgK1xuICAgICAgICAgICAgJ1NlZSBodHRwczovL3d3dy5tYXBib3guY29tL2RldmVsb3BlcnMvYXBpLyNhY2Nlc3MtdG9rZW5zJyk7XG4gICAgfVxuXG4gICAgdXJsID0gdXJsLnJlcGxhY2UoL15tYXBib3g6XFwvXFwvLywgY29uZmlnLkFQSV9VUkwgKyBwYXRoUHJlZml4KTtcbiAgICB1cmwgKz0gdXJsLmluZGV4T2YoJz8nKSAhPT0gLTEgPyAnJmFjY2Vzc190b2tlbj0nIDogJz9hY2Nlc3NfdG9rZW49JztcblxuICAgIGlmIChjb25maWcuUkVRVUlSRV9BQ0NFU1NfVE9LRU4pIHtcbiAgICAgICAgaWYgKGFjY2Vzc1Rva2VuWzBdID09PSAncycpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVXNlIGEgcHVibGljIGFjY2VzcyB0b2tlbiAocGsuKikgd2l0aCBNYXBib3ggR0wgSlMsIG5vdCBhIHNlY3JldCBhY2Nlc3MgdG9rZW4gKHNrLiopLiAnICtcbiAgICAgICAgICAgICAgICAnU2VlIGh0dHBzOi8vd3d3Lm1hcGJveC5jb20vZGV2ZWxvcGVycy9hcGkvI2FjY2Vzcy10b2tlbnMnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHVybCArPSBhY2Nlc3NUb2tlbjtcbiAgICB9XG5cbiAgICByZXR1cm4gdXJsO1xufVxuXG5tb2R1bGUuZXhwb3J0cy5ub3JtYWxpemVTdHlsZVVSTCA9IGZ1bmN0aW9uKHVybCwgYWNjZXNzVG9rZW4pIHtcbiAgICBpZiAoIXVybC5tYXRjaCgvXm1hcGJveDpcXC9cXC9zdHlsZXNcXC8vKSlcbiAgICAgICAgcmV0dXJuIHVybDtcblxuICAgIHZhciBzcGxpdCA9IHVybC5zcGxpdCgnLycpO1xuICAgIHZhciB1c2VyID0gc3BsaXRbM107XG4gICAgdmFyIHN0eWxlID0gc3BsaXRbNF07XG4gICAgdmFyIGRyYWZ0ID0gc3BsaXRbNV0gPyAnL2RyYWZ0JyA6ICcnO1xuICAgIHJldHVybiBub3JtYWxpemVVUkwoJ21hcGJveDovLycgKyB1c2VyICsgJy8nICsgc3R5bGUgKyBkcmFmdCwgJy9zdHlsZXMvdjEvJywgYWNjZXNzVG9rZW4pO1xufTtcblxubW9kdWxlLmV4cG9ydHMubm9ybWFsaXplU291cmNlVVJMID0gZnVuY3Rpb24odXJsLCBhY2Nlc3NUb2tlbikge1xuICAgIGlmICghdXJsLm1hdGNoKC9ebWFwYm94OlxcL1xcLy8pKVxuICAgICAgICByZXR1cm4gdXJsO1xuXG4gICAgLy8gVGlsZUpTT04gcmVxdWVzdHMgbmVlZCBhIHNlY3VyZSBmbGFnIGFwcGVuZGVkIHRvIHRoZWlyIFVSTHMgc29cbiAgICAvLyB0aGF0IHRoZSBzZXJ2ZXIga25vd3MgdG8gc2VuZCBTU0wtaWZpZWQgcmVzb3VyY2UgcmVmZXJlbmNlcy5cbiAgICByZXR1cm4gbm9ybWFsaXplVVJMKHVybCArICcuanNvbicsICcvdjQvJywgYWNjZXNzVG9rZW4pICsgJyZzZWN1cmUnO1xufTtcblxubW9kdWxlLmV4cG9ydHMubm9ybWFsaXplR2x5cGhzVVJMID0gZnVuY3Rpb24odXJsLCBhY2Nlc3NUb2tlbikge1xuICAgIGlmICghdXJsLm1hdGNoKC9ebWFwYm94OlxcL1xcLy8pKVxuICAgICAgICByZXR1cm4gdXJsO1xuXG4gICAgdmFyIHVzZXIgPSB1cmwuc3BsaXQoJy8nKVszXTtcbiAgICByZXR1cm4gbm9ybWFsaXplVVJMKCdtYXBib3g6Ly8nICsgdXNlciArICcve2ZvbnRzdGFja30ve3JhbmdlfS5wYmYnLCAnL2ZvbnRzL3YxLycsIGFjY2Vzc1Rva2VuKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzLm5vcm1hbGl6ZVNwcml0ZVVSTCA9IGZ1bmN0aW9uKHVybCwgZm9ybWF0LCBleHQsIGFjY2Vzc1Rva2VuKSB7XG4gICAgaWYgKCF1cmwubWF0Y2goL15tYXBib3g6XFwvXFwvc3ByaXRlc1xcLy8pKVxuICAgICAgICByZXR1cm4gdXJsICsgZm9ybWF0ICsgZXh0O1xuXG4gICAgdmFyIHNwbGl0ID0gdXJsLnNwbGl0KCcvJyk7XG4gICAgdmFyIHVzZXIgPSBzcGxpdFszXTtcbiAgICB2YXIgc3R5bGUgPSBzcGxpdFs0XTtcbiAgICB2YXIgZHJhZnQgPSBzcGxpdFs1XSA/ICcvZHJhZnQnIDogJyc7XG4gICAgcmV0dXJuIG5vcm1hbGl6ZVVSTCgnbWFwYm94Oi8vJyArIHVzZXIgKyAnLycgKyBzdHlsZSArIGRyYWZ0ICsgJy9zcHJpdGUnICsgZm9ybWF0ICsgZXh0LCAnL3N0eWxlcy92MS8nLCBhY2Nlc3NUb2tlbik7XG59O1xuXG5tb2R1bGUuZXhwb3J0cy5ub3JtYWxpemVUaWxlVVJMID0gZnVuY3Rpb24odXJsLCBzb3VyY2VVcmwsIHRpbGVTaXplKSB7XG4gICAgaWYgKCFzb3VyY2VVcmwgfHwgIXNvdXJjZVVybC5tYXRjaCgvXm1hcGJveDpcXC9cXC8vKSlcbiAgICAgICAgcmV0dXJuIHVybDtcblxuICAgIC8vIFRoZSB2NCBtYXBib3ggdGlsZSBBUEkgc3VwcG9ydHMgNTEyeDUxMiBpbWFnZSB0aWxlcyBvbmx5IHdoZW4gQDJ4XG4gICAgLy8gaXMgYXBwZW5kZWQgdG8gdGhlIHRpbGUgVVJMLiBJZiBgdGlsZVNpemU6IDUxMmAgaXMgc3BlY2lmaWVkIGZvclxuICAgIC8vIGEgTWFwYm94IHJhc3RlciBzb3VyY2UgZm9yY2UgdGhlIEAyeCBzdWZmaXggZXZlbiBpZiBhIG5vbiBoaWRwaVxuICAgIC8vIGRldmljZS5cbiAgICB1cmwgPSB1cmwucmVwbGFjZSgvKFs/Jl1hY2Nlc3NfdG9rZW49KXRrXFwuW14mXSsvLCAnJDEnICsgY29uZmlnLkFDQ0VTU19UT0tFTik7XG4gICAgdmFyIGV4dGVuc2lvbiA9IGJyb3dzZXIuc3VwcG9ydHNXZWJwID8gJ3dlYnAnIDogJyQxJztcbiAgICByZXR1cm4gdXJsLnJlcGxhY2UoL1xcLigoPzpwbmd8anBnKVxcZCopKD89JHxcXD8pLywgYnJvd3Nlci5kZXZpY2VQaXhlbFJhdGlvID49IDIgfHwgdGlsZVNpemUgPT09IDUxMiA/ICdAMnguJyArIGV4dGVuc2lvbiA6ICcuJyArIGV4dGVuc2lvbik7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyBOb3RlOiBhbGwgXCJzaXplc1wiIGFyZSBtZWFzdXJlZCBpbiBieXRlc1xuXG52YXIgYXNzZXJ0ID0gcmVxdWlyZSgnYXNzZXJ0Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0gU3RydWN0QXJyYXlUeXBlO1xuXG52YXIgdmlld1R5cGVzID0ge1xuICAgICdJbnQ4JzogSW50OEFycmF5LFxuICAgICdVaW50OCc6IFVpbnQ4QXJyYXksXG4gICAgJ1VpbnQ4Q2xhbXBlZCc6IFVpbnQ4Q2xhbXBlZEFycmF5LFxuICAgICdJbnQxNic6IEludDE2QXJyYXksXG4gICAgJ1VpbnQxNic6IFVpbnQxNkFycmF5LFxuICAgICdJbnQzMic6IEludDMyQXJyYXksXG4gICAgJ1VpbnQzMic6IFVpbnQzMkFycmF5LFxuICAgICdGbG9hdDMyJzogRmxvYXQzMkFycmF5LFxuICAgICdGbG9hdDY0JzogRmxvYXQ2NEFycmF5XG59O1xuXG4vKipcbiAqIEB0eXBlZGVmIFN0cnVjdE1lbWJlclxuICogQHByaXZhdGVcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBuYW1lXG4gKiBAcHJvcGVydHkge3N0cmluZ30gdHlwZVxuICogQHByb3BlcnR5IHtudW1iZXJ9IGNvbXBvbmVudHNcbiAqL1xuXG52YXIgc3RydWN0QXJyYXlUeXBlQ2FjaGUgPSB7fTtcblxuLyoqXG4gKiBgU3RydWN0QXJyYXlUeXBlYCBpcyB1c2VkIHRvIGNyZWF0ZSBuZXcgYFN0cnVjdEFycmF5YCB0eXBlcy5cbiAqXG4gKiBgU3RydWN0QXJyYXlgIHByb3ZpZGVzIGFuIGFic3RyYWN0aW9uIG92ZXIgYEFycmF5QnVmZmVyYCBhbmQgYFR5cGVkQXJyYXlgIG1ha2luZyBpdCBiZWhhdmUgbGlrZVxuICogYW4gYXJyYXkgb2YgdHlwZWQgc3RydWN0cy4gQSBTdHJ1Y3RBcnJheSBpcyBjb21wcmlzZWQgb2YgZWxlbWVudHMuIEVhY2ggZWxlbWVudCBoYXMgYSBzZXQgb2ZcbiAqIG1lbWJlcnMgdGhhdCBhcmUgZGVmaW5lZCB3aGVuIHRoZSBgU3RydWN0QXJyYXlUeXBlYCBpcyBjcmVhdGVkLlxuICpcbiAqIFN0cnVjdEFycmF5cyB1c2VmdWwgZm9yIGNyZWF0aW5nIGxhcmdlIGFycmF5cyB0aGF0OlxuICogLSBjYW4gYmUgdHJhbnNmZXJyZWQgZnJvbSB3b3JrZXJzIGFzIGEgVHJhbnNmZXJhYmxlIG9iamVjdFxuICogLSBjYW4gYmUgY29waWVkIGNoZWFwbHlcbiAqIC0gdXNlIGxlc3MgbWVtb3J5IGZvciBsb3dlci1wcmVjaXNpb24gbWVtYmVyc1xuICogLSBjYW4gYmUgdXNlZCBhcyBidWZmZXJzIGluIFdlYkdMLlxuICpcbiAqIEBjbGFzcyBTdHJ1Y3RBcnJheVR5cGVcbiAqIEBwYXJhbSB7QXJyYXkuPFN0cnVjdE1lbWJlcj59XG4gKiBAcGFyYW0gb3B0aW9uc1xuICogQHBhcmFtIHtudW1iZXJ9IG9wdGlvbnMuYWxpZ25tZW50IFVzZSBgNGAgdG8gYWxpZ24gbWVtYmVycyB0byA0IGJ5dGUgYm91bmRhcmllcy4gRGVmYXVsdCBpcyAxLlxuICpcbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIFBvaW50QXJyYXlUeXBlID0gbmV3IFN0cnVjdEFycmF5VHlwZSh7XG4gKiAgbWVtYmVyczogW1xuICogICAgICB7IHR5cGU6ICdJbnQxNicsIG5hbWU6ICd4JyB9LFxuICogICAgICB7IHR5cGU6ICdJbnQxNicsIG5hbWU6ICd5JyB9XG4gKiAgXX0pO1xuICpcbiAqICB2YXIgcG9pbnRBcnJheSA9IG5ldyBQb2ludEFycmF5VHlwZSgpO1xuICogIHBvaW50QXJyYXkuZW1wbGFjZUJhY2soMTAsIDE1KTtcbiAqICBwb2ludEFycmF5LmVtcGxhY2VCYWNrKDIwLCAzNSk7XG4gKlxuICogIHBvaW50ID0gcG9pbnRBcnJheS5nZXQoMCk7XG4gKiAgYXNzZXJ0KHBvaW50LnggPT09IDEwKTtcbiAqICBhc3NlcnQocG9pbnQueSA9PT0gMTUpO1xuICpcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIFN0cnVjdEFycmF5VHlwZShvcHRpb25zKSB7XG5cbiAgICB2YXIga2V5ID0gSlNPTi5zdHJpbmdpZnkob3B0aW9ucyk7XG4gICAgaWYgKHN0cnVjdEFycmF5VHlwZUNhY2hlW2tleV0pIHtcbiAgICAgICAgcmV0dXJuIHN0cnVjdEFycmF5VHlwZUNhY2hlW2tleV07XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMuYWxpZ25tZW50ID09PSB1bmRlZmluZWQpIG9wdGlvbnMuYWxpZ25tZW50ID0gMTtcblxuICAgIGZ1bmN0aW9uIFN0cnVjdFR5cGUoKSB7XG4gICAgICAgIFN0cnVjdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cblxuICAgIFN0cnVjdFR5cGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShTdHJ1Y3QucHJvdG90eXBlKTtcblxuICAgIHZhciBvZmZzZXQgPSAwO1xuICAgIHZhciBtYXhTaXplID0gMDtcbiAgICB2YXIgdXNlZFR5cGVzID0gWydVaW50OCddO1xuXG4gICAgU3RydWN0VHlwZS5wcm90b3R5cGUubWVtYmVycyA9IG9wdGlvbnMubWVtYmVycy5tYXAoZnVuY3Rpb24obWVtYmVyKSB7XG4gICAgICAgIG1lbWJlciA9IHtcbiAgICAgICAgICAgIG5hbWU6IG1lbWJlci5uYW1lLFxuICAgICAgICAgICAgdHlwZTogbWVtYmVyLnR5cGUsXG4gICAgICAgICAgICBjb21wb25lbnRzOiBtZW1iZXIuY29tcG9uZW50cyB8fCAxXG4gICAgICAgIH07XG5cbiAgICAgICAgYXNzZXJ0KG1lbWJlci5uYW1lLmxlbmd0aCk7XG4gICAgICAgIGFzc2VydChtZW1iZXIudHlwZSBpbiB2aWV3VHlwZXMpO1xuXG4gICAgICAgIGlmICh1c2VkVHlwZXMuaW5kZXhPZihtZW1iZXIudHlwZSkgPCAwKSB1c2VkVHlwZXMucHVzaChtZW1iZXIudHlwZSk7XG5cbiAgICAgICAgdmFyIHR5cGVTaXplID0gc2l6ZU9mKG1lbWJlci50eXBlKTtcbiAgICAgICAgbWF4U2l6ZSA9IE1hdGgubWF4KG1heFNpemUsIHR5cGVTaXplKTtcbiAgICAgICAgbWVtYmVyLm9mZnNldCA9IG9mZnNldCA9IGFsaWduKG9mZnNldCwgTWF0aC5tYXgob3B0aW9ucy5hbGlnbm1lbnQsIHR5cGVTaXplKSk7XG5cbiAgICAgICAgZm9yICh2YXIgYyA9IDA7IGMgPCBtZW1iZXIuY29tcG9uZW50czsgYysrKSB7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU3RydWN0VHlwZS5wcm90b3R5cGUsIG1lbWJlci5uYW1lICsgKG1lbWJlci5jb21wb25lbnRzID09PSAxID8gJycgOiBjKSwge1xuICAgICAgICAgICAgICAgIGdldDogY3JlYXRlR2V0dGVyKG1lbWJlciwgYyksXG4gICAgICAgICAgICAgICAgc2V0OiBjcmVhdGVTZXR0ZXIobWVtYmVyLCBjKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBvZmZzZXQgKz0gdHlwZVNpemUgKiBtZW1iZXIuY29tcG9uZW50cztcblxuICAgICAgICByZXR1cm4gbWVtYmVyO1xuICAgIH0pO1xuXG4gICAgU3RydWN0VHlwZS5wcm90b3R5cGUuYWxpZ25tZW50ID0gb3B0aW9ucy5hbGlnbm1lbnQ7XG4gICAgU3RydWN0VHlwZS5wcm90b3R5cGUuc2l6ZSA9IGFsaWduKG9mZnNldCwgTWF0aC5tYXgobWF4U2l6ZSwgb3B0aW9ucy5hbGlnbm1lbnQpKTtcblxuICAgIGZ1bmN0aW9uIFN0cnVjdEFycmF5VHlwZSgpIHtcbiAgICAgICAgU3RydWN0QXJyYXkuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG5cbiAgICBTdHJ1Y3RBcnJheVR5cGUuc2VyaWFsaXplID0gc2VyaWFsaXplU3RydWN0QXJyYXlUeXBlO1xuXG4gICAgU3RydWN0QXJyYXlUeXBlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoU3RydWN0QXJyYXkucHJvdG90eXBlKTtcbiAgICBTdHJ1Y3RBcnJheVR5cGUucHJvdG90eXBlLlN0cnVjdFR5cGUgPSBTdHJ1Y3RUeXBlO1xuICAgIFN0cnVjdEFycmF5VHlwZS5wcm90b3R5cGUuYnl0ZXNQZXJFbGVtZW50ID0gU3RydWN0VHlwZS5wcm90b3R5cGUuc2l6ZTtcbiAgICBTdHJ1Y3RBcnJheVR5cGUucHJvdG90eXBlLmVtcGxhY2VCYWNrID0gY3JlYXRlRW1wbGFjZUJhY2soU3RydWN0VHlwZS5wcm90b3R5cGUubWVtYmVycywgU3RydWN0VHlwZS5wcm90b3R5cGUuc2l6ZSk7XG4gICAgU3RydWN0QXJyYXlUeXBlLnByb3RvdHlwZS5fdXNlZFR5cGVzID0gdXNlZFR5cGVzO1xuXG5cbiAgICBzdHJ1Y3RBcnJheVR5cGVDYWNoZVtrZXldID0gU3RydWN0QXJyYXlUeXBlO1xuXG4gICAgcmV0dXJuIFN0cnVjdEFycmF5VHlwZTtcbn1cblxuLyoqXG4gKiBTZXJpYWxpemUgdGhlIFN0cnVjdEFycmF5IHR5cGUuIFRoaXMgc2VyaWFsaXplcyB0aGUgKnR5cGUqIG5vdCBhbiBpbnN0YW5jZSBvZiB0aGUgdHlwZS5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHNlcmlhbGl6ZVN0cnVjdEFycmF5VHlwZSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBtZW1iZXJzOiB0aGlzLnByb3RvdHlwZS5TdHJ1Y3RUeXBlLnByb3RvdHlwZS5tZW1iZXJzLFxuICAgICAgICBhbGlnbm1lbnQ6IHRoaXMucHJvdG90eXBlLlN0cnVjdFR5cGUucHJvdG90eXBlLmFsaWdubWVudCxcbiAgICAgICAgYnl0ZXNQZXJFbGVtZW50OiB0aGlzLnByb3RvdHlwZS5ieXRlc1BlckVsZW1lbnRcbiAgICB9O1xufVxuXG5cbmZ1bmN0aW9uIGFsaWduKG9mZnNldCwgc2l6ZSkge1xuICAgIHJldHVybiBNYXRoLmNlaWwob2Zmc2V0IC8gc2l6ZSkgKiBzaXplO1xufVxuXG5mdW5jdGlvbiBzaXplT2YodHlwZSkge1xuICAgIHJldHVybiB2aWV3VHlwZXNbdHlwZV0uQllURVNfUEVSX0VMRU1FTlQ7XG59XG5cbmZ1bmN0aW9uIGdldEFycmF5Vmlld05hbWUodHlwZSkge1xuICAgIHJldHVybiB0eXBlLnRvTG93ZXJDYXNlKCk7XG59XG5cblxuLypcbiAqID4gSSBzYXcgbWFqb3IgcGVyZiBnYWlucyBieSBzaG9ydGVuaW5nIHRoZSBzb3VyY2Ugb2YgdGhlc2UgZ2VuZXJhdGVkIG1ldGhvZHMgKGkuZS4gcmVuYW1pbmdcbiAqID4gZWxlbWVudEluZGV4IHRvIGkpIChsaWtlbHkgZHVlIHRvIHY4IGlubGluaW5nIGhldXJpc3RpY3MpLlxuICogLSBsdWNhc3dvalxuICovXG5mdW5jdGlvbiBjcmVhdGVFbXBsYWNlQmFjayhtZW1iZXJzLCBieXRlc1BlckVsZW1lbnQpIHtcbiAgICB2YXIgdXNlZFR5cGVTaXplcyA9IFtdO1xuICAgIHZhciBhcmdOYW1lcyA9IFtdO1xuICAgIHZhciBib2R5ID0gJycgK1xuICAgICd2YXIgaSA9IHRoaXMubGVuZ3RoO1xcbicgK1xuICAgICd0aGlzLmxlbmd0aCsrO1xcbicgK1xuICAgICdpZiAodGhpcy5sZW5ndGggPiB0aGlzLmNhcGFjaXR5KSB0aGlzLl9yZXNpemUodGhpcy5sZW5ndGgpO1xcbic7XG5cbiAgICBmb3IgKHZhciBtID0gMDsgbSA8IG1lbWJlcnMubGVuZ3RoOyBtKyspIHtcbiAgICAgICAgdmFyIG1lbWJlciA9IG1lbWJlcnNbbV07XG4gICAgICAgIHZhciBzaXplID0gc2l6ZU9mKG1lbWJlci50eXBlKTtcblxuICAgICAgICBpZiAodXNlZFR5cGVTaXplcy5pbmRleE9mKHNpemUpIDwgMCkge1xuICAgICAgICAgICAgdXNlZFR5cGVTaXplcy5wdXNoKHNpemUpO1xuICAgICAgICAgICAgYm9keSArPSAndmFyIG8nICsgc2l6ZS50b0ZpeGVkKDApICsgJyA9IGkgKiAnICsgKGJ5dGVzUGVyRWxlbWVudCAvIHNpemUpLnRvRml4ZWQoMCkgKyAnO1xcbic7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHZhciBjID0gMDsgYyA8IG1lbWJlci5jb21wb25lbnRzOyBjKyspIHtcbiAgICAgICAgICAgIHZhciBhcmdOYW1lID0gJ3YnICsgYXJnTmFtZXMubGVuZ3RoO1xuICAgICAgICAgICAgdmFyIGluZGV4ID0gJ28nICsgc2l6ZS50b0ZpeGVkKDApICsgJyArICcgKyAobWVtYmVyLm9mZnNldCAvIHNpemUgKyBjKS50b0ZpeGVkKDApO1xuICAgICAgICAgICAgYm9keSArPSAndGhpcy4nICsgZ2V0QXJyYXlWaWV3TmFtZShtZW1iZXIudHlwZSkgKyAnWycgKyBpbmRleCArICddID0gJyArIGFyZ05hbWUgKyAnO1xcbic7XG4gICAgICAgICAgICBhcmdOYW1lcy5wdXNoKGFyZ05hbWUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgYm9keSArPSAncmV0dXJuIGk7JztcblxuICAgIHJldHVybiBuZXcgRnVuY3Rpb24oYXJnTmFtZXMsIGJvZHkpO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVNZW1iZXJDb21wb25lbnRTdHJpbmcobWVtYmVyLCBjb21wb25lbnQpIHtcbiAgICB2YXIgZWxlbWVudE9mZnNldCA9ICd0aGlzLl9wb3MnICsgc2l6ZU9mKG1lbWJlci50eXBlKS50b0ZpeGVkKDApO1xuICAgIHZhciBjb21wb25lbnRPZmZzZXQgPSAobWVtYmVyLm9mZnNldCAvIHNpemVPZihtZW1iZXIudHlwZSkgKyBjb21wb25lbnQpLnRvRml4ZWQoMCk7XG4gICAgdmFyIGluZGV4ID0gZWxlbWVudE9mZnNldCArICcgKyAnICsgY29tcG9uZW50T2Zmc2V0O1xuICAgIHJldHVybiAndGhpcy5fc3RydWN0QXJyYXkuJyArIGdldEFycmF5Vmlld05hbWUobWVtYmVyLnR5cGUpICsgJ1snICsgaW5kZXggKyAnXSc7XG5cbn1cblxuZnVuY3Rpb24gY3JlYXRlR2V0dGVyKG1lbWJlciwgYykge1xuICAgIHJldHVybiBuZXcgRnVuY3Rpb24oW10sICdyZXR1cm4gJyArIGNyZWF0ZU1lbWJlckNvbXBvbmVudFN0cmluZyhtZW1iZXIsIGMpICsgJzsnKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlU2V0dGVyKG1lbWJlciwgYykge1xuICAgIHJldHVybiBuZXcgRnVuY3Rpb24oWyd4J10sIGNyZWF0ZU1lbWJlckNvbXBvbmVudFN0cmluZyhtZW1iZXIsIGMpICsgJyA9IHg7Jyk7XG59XG5cbi8qKlxuICogQGNsYXNzIFN0cnVjdFxuICogQHBhcmFtIHtTdHJ1Y3RBcnJheX0gc3RydWN0QXJyYXkgVGhlIFN0cnVjdEFycmF5IHRoZSBzdHJ1Y3QgaXMgc3RvcmVkIGluXG4gKiBAcGFyYW0ge251bWJlcn0gaW5kZXggVGhlIGluZGV4IG9mIHRoZSBzdHJ1Y3QgaW4gdGhlIFN0cnVjdEFycmF5LlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gU3RydWN0KHN0cnVjdEFycmF5LCBpbmRleCkge1xuICAgIHRoaXMuX3N0cnVjdEFycmF5ID0gc3RydWN0QXJyYXk7XG4gICAgdGhpcy5fcG9zMSA9IGluZGV4ICogdGhpcy5zaXplO1xuICAgIHRoaXMuX3BvczIgPSB0aGlzLl9wb3MxIC8gMjtcbiAgICB0aGlzLl9wb3M0ID0gdGhpcy5fcG9zMSAvIDQ7XG4gICAgdGhpcy5fcG9zOCA9IHRoaXMuX3BvczEgLyA4O1xufVxuXG4vKipcbiAqIEBjbGFzcyBTdHJ1Y3RBcnJheVxuICogVGhlIFN0cnVjdEFycmF5IGNsYXNzIGlzIGluaGVyaXRlZCBieSB0aGUgY3VzdG9tIFN0cnVjdEFycmF5VHlwZSBjbGFzc2VzIGNyZWF0ZWQgd2l0aFxuICogYG5ldyBTdHJ1Y3RBcnJheVR5cGUobWVtYmVycywgb3B0aW9ucylgLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gU3RydWN0QXJyYXkoc2VyaWFsaXplZCkge1xuICAgIGlmIChzZXJpYWxpemVkICE9PSB1bmRlZmluZWQpIHtcbiAgICAvLyBDcmVhdGUgZnJvbSBhbiBzZXJpYWxpemVkIFN0cnVjdEFycmF5XG4gICAgICAgIHRoaXMuYXJyYXlCdWZmZXIgPSBzZXJpYWxpemVkLmFycmF5QnVmZmVyO1xuICAgICAgICB0aGlzLmxlbmd0aCA9IHNlcmlhbGl6ZWQubGVuZ3RoO1xuICAgICAgICB0aGlzLmNhcGFjaXR5ID0gdGhpcy5hcnJheUJ1ZmZlci5ieXRlTGVuZ3RoIC8gdGhpcy5ieXRlc1BlckVsZW1lbnQ7XG4gICAgICAgIHRoaXMuX3JlZnJlc2hWaWV3cygpO1xuXG4gICAgLy8gQ3JlYXRlIGEgbmV3IFN0cnVjdEFycmF5XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5sZW5ndGggPSAwO1xuICAgICAgICB0aGlzLmNhcGFjaXR5ID0gMDtcbiAgICAgICAgdGhpcy5fcmVzaXplKHRoaXMuREVGQVVMVF9DQVBBQ0lUWSk7XG4gICAgfVxufVxuXG4vKipcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfVxuICogQHByaXZhdGVcbiAqIEByZWFkb25seVxuICovXG5TdHJ1Y3RBcnJheS5wcm90b3R5cGUuREVGQVVMVF9DQVBBQ0lUWSA9IDEyODtcblxuLyoqXG4gKiBAcHJvcGVydHkge251bWJlcn1cbiAqIEBwcml2YXRlXG4gKiBAcmVhZG9ubHlcbiAqL1xuU3RydWN0QXJyYXkucHJvdG90eXBlLlJFU0laRV9NVUxUSVBMSUVSID0gNTtcblxuLyoqXG4gKiBTZXJpYWxpemUgdGhpcyBTdHJ1Y3RBcnJheSBpbnN0YW5jZVxuICogQHByaXZhdGVcbiAqL1xuU3RydWN0QXJyYXkucHJvdG90eXBlLnNlcmlhbGl6ZSA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMudHJpbSgpO1xuICAgIHJldHVybiB7XG4gICAgICAgIGxlbmd0aDogdGhpcy5sZW5ndGgsXG4gICAgICAgIGFycmF5QnVmZmVyOiB0aGlzLmFycmF5QnVmZmVyXG4gICAgfTtcbn07XG5cbi8qKlxuICogUmV0dXJuIHRoZSBTdHJ1Y3QgYXQgdGhlIGdpdmVuIGxvY2F0aW9uIGluIHRoZSBhcnJheS5cbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge251bWJlcn0gaW5kZXggVGhlIGluZGV4IG9mIHRoZSBlbGVtZW50LlxuICovXG5TdHJ1Y3RBcnJheS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24oaW5kZXgpIHtcbiAgICByZXR1cm4gbmV3IHRoaXMuU3RydWN0VHlwZSh0aGlzLCBpbmRleCk7XG59O1xuXG4vKipcbiAqIFJlc2l6ZSB0aGUgYXJyYXkgdG8gZGlzY2FyZCB1bnVzZWQgY2FwYWNpdHkuXG4gKiBAcHJpdmF0ZVxuICovXG5TdHJ1Y3RBcnJheS5wcm90b3R5cGUudHJpbSA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLmxlbmd0aCAhPT0gdGhpcy5jYXBhY2l0eSkge1xuICAgICAgICB0aGlzLmNhcGFjaXR5ID0gdGhpcy5sZW5ndGg7XG4gICAgICAgIHRoaXMuYXJyYXlCdWZmZXIgPSB0aGlzLmFycmF5QnVmZmVyLnNsaWNlKDAsIHRoaXMubGVuZ3RoICogdGhpcy5ieXRlc1BlckVsZW1lbnQpO1xuICAgICAgICB0aGlzLl9yZWZyZXNoVmlld3MoKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIFJlc2l6ZSB0aGUgYXJyYXkgc28gdGhhdCBpdCBmaXRzIGF0IGxlYXN0IGBuYCBlbGVtZW50cy5cbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge251bWJlcn0gbiBUaGUgbnVtYmVyIG9mIGVsZW1lbnRzIHRoYXQgbXVzdCBmaXQgaW4gdGhlIGFycmF5IGFmdGVyIHRoZSByZXNpemUuXG4gKi9cblN0cnVjdEFycmF5LnByb3RvdHlwZS5fcmVzaXplID0gZnVuY3Rpb24obikge1xuICAgIHRoaXMuY2FwYWNpdHkgPSBNYXRoLm1heChuLCBNYXRoLmZsb29yKHRoaXMuY2FwYWNpdHkgKiB0aGlzLlJFU0laRV9NVUxUSVBMSUVSKSk7XG4gICAgdGhpcy5hcnJheUJ1ZmZlciA9IG5ldyBBcnJheUJ1ZmZlcih0aGlzLmNhcGFjaXR5ICogdGhpcy5ieXRlc1BlckVsZW1lbnQpO1xuXG4gICAgdmFyIG9sZFVpbnQ4QXJyYXkgPSB0aGlzLnVpbnQ4O1xuICAgIHRoaXMuX3JlZnJlc2hWaWV3cygpO1xuICAgIGlmIChvbGRVaW50OEFycmF5KSB0aGlzLnVpbnQ4LnNldChvbGRVaW50OEFycmF5KTtcbn07XG5cbi8qKlxuICogQ3JlYXRlIFR5cGVkQXJyYXkgdmlld3MgZm9yIHRoZSBjdXJyZW50IEFycmF5QnVmZmVyLlxuICogQHByaXZhdGVcbiAqL1xuU3RydWN0QXJyYXkucHJvdG90eXBlLl9yZWZyZXNoVmlld3MgPSBmdW5jdGlvbigpIHtcbiAgICBmb3IgKHZhciB0ID0gMDsgdCA8IHRoaXMuX3VzZWRUeXBlcy5sZW5ndGg7IHQrKykge1xuICAgICAgICB2YXIgdHlwZSA9IHRoaXMuX3VzZWRUeXBlc1t0XTtcbiAgICAgICAgdGhpc1tnZXRBcnJheVZpZXdOYW1lKHR5cGUpXSA9IG5ldyB2aWV3VHlwZXNbdHlwZV0odGhpcy5hcnJheUJ1ZmZlcik7XG4gICAgfVxufTtcblxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlc29sdmVUb2tlbnM7XG5cbi8qKlxuICogUmVwbGFjZSB0b2tlbnMgaW4gYSBzdHJpbmcgdGVtcGxhdGUgd2l0aCB2YWx1ZXMgaW4gYW4gb2JqZWN0XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHByb3BlcnRpZXMgYSBrZXkvdmFsdWUgcmVsYXRpb25zaGlwIGJldHdlZW4gdG9rZW5zIGFuZCByZXBsYWNlbWVudHNcbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0IHRoZSB0ZW1wbGF0ZSBzdHJpbmdcbiAqIEByZXR1cm5zIHtzdHJpbmd9IHRoZSB0ZW1wbGF0ZSB3aXRoIHRva2VucyByZXBsYWNlZFxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcmVzb2x2ZVRva2Vucyhwcm9wZXJ0aWVzLCB0ZXh0KSB7XG4gICAgcmV0dXJuIHRleHQucmVwbGFjZSgveyhbXnt9KClcXFtcXF08PiQ9OjsuLF5dKyl9L2csIGZ1bmN0aW9uKG1hdGNoLCBrZXkpIHtcbiAgICAgICAgcmV0dXJuIGtleSBpbiBwcm9wZXJ0aWVzID8gcHJvcGVydGllc1trZXldIDogJyc7XG4gICAgfSk7XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBVbml0QmV6aWVyID0gcmVxdWlyZSgndW5pdGJlemllcicpO1xudmFyIENvb3JkaW5hdGUgPSByZXF1aXJlKCcuLi9nZW8vY29vcmRpbmF0ZScpO1xuXG4vKipcbiAqIEdpdmVuIGEgdmFsdWUgYHRgIHRoYXQgdmFyaWVzIGJldHdlZW4gMCBhbmQgMSwgcmV0dXJuXG4gKiBhbiBpbnRlcnBvbGF0aW9uIGZ1bmN0aW9uIHRoYXQgZWFzZXMgYmV0d2VlbiAwIGFuZCAxIGluIGEgcGxlYXNpbmdcbiAqIGN1YmljIGluLW91dCBmYXNoaW9uLlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSB0IGlucHV0XG4gKiBAcmV0dXJucyB7bnVtYmVyfSBpbnB1dFxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0cy5lYXNlQ3ViaWNJbk91dCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgaWYgKHQgPD0gMCkgcmV0dXJuIDA7XG4gICAgaWYgKHQgPj0gMSkgcmV0dXJuIDE7XG4gICAgdmFyIHQyID0gdCAqIHQsXG4gICAgICAgIHQzID0gdDIgKiB0O1xuICAgIHJldHVybiA0ICogKHQgPCAwLjUgPyB0MyA6IDMgKiAodCAtIHQyKSArIHQzIC0gMC43NSk7XG59O1xuXG4vKipcbiAqIEdpdmVuIGdpdmVuICh4LCB5KSwgKHgxLCB5MSkgY29udHJvbCBwb2ludHMgZm9yIGEgYmV6aWVyIGN1cnZlLFxuICogcmV0dXJuIGEgZnVuY3Rpb24gdGhhdCBpbnRlcnBvbGF0ZXMgYWxvbmcgdGhhdCBjdXJ2ZS5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gcDF4IGNvbnRyb2wgcG9pbnQgMSB4IGNvb3JkaW5hdGVcbiAqIEBwYXJhbSB7bnVtYmVyfSBwMXkgY29udHJvbCBwb2ludCAxIHkgY29vcmRpbmF0ZVxuICogQHBhcmFtIHtudW1iZXJ9IHAyeCBjb250cm9sIHBvaW50IDIgeCBjb29yZGluYXRlXG4gKiBAcGFyYW0ge251bWJlcn0gcDJ5IGNvbnRyb2wgcG9pbnQgMiB5IGNvb3JkaW5hdGVcbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gaW50ZXJwb2xhdG9yOiByZWNlaXZlcyBudW1iZXIgdmFsdWUsIHJldHVybnNcbiAqIG51bWJlciB2YWx1ZS5cbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydHMuYmV6aWVyID0gZnVuY3Rpb24ocDF4LCBwMXksIHAyeCwgcDJ5KSB7XG4gICAgdmFyIGJlemllciA9IG5ldyBVbml0QmV6aWVyKHAxeCwgcDF5LCBwMngsIHAyeSk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgcmV0dXJuIGJlemllci5zb2x2ZSh0KTtcbiAgICB9O1xufTtcblxuLyoqXG4gKiBBIGRlZmF1bHQgYmV6aWVyLWN1cnZlIHBvd2VyZWQgZWFzaW5nIGZ1bmN0aW9uIHdpdGhcbiAqIGNvbnRyb2wgcG9pbnRzICgwLjI1LCAwLjEpIGFuZCAoMC4yNSwgMSlcbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gdFxuICogQHJldHVybnMge251bWJlcn0gb3V0cHV0XG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnRzLmVhc2UgPSBleHBvcnRzLmJlemllcigwLjI1LCAwLjEsIDAuMjUsIDEpO1xuXG4vKipcbiAqIEdpdmVuIGEgZm91ci1lbGVtZW50IGFycmF5IG9mIG51bWJlcnMgdGhhdCByZXByZXNlbnRzIGEgY29sb3IgaW5cbiAqIFJHQkEsIHJldHVybiBhIHZlcnNpb24gZm9yIHdoaWNoIHRoZSBSR0IgY29tcG9uZW50cyBhcmUgbXVsdGlwbGllZFxuICogYnkgdGhlIEEgKGFscGhhKSBjb21wb25lbnRcbiAqXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGNvbG9yIGNvbG9yIGFycmF5XG4gKiBAcGFyYW0ge251bWJlcn0gW2FkZGl0aW9uYWxPcGFjaXR5XSBhZGRpdGlvbmFsIG9wYWNpdHkgdG8gYmUgbXVsdGlwbGllZCBpbnRvXG4gKiAgICAgdGhlIGNvbG9yJ3MgYWxwaGEgY29tcG9uZW50LlxuICogQHJldHVybnMge0FycmF5PG51bWJlcj59IHByZW11bHRpcGxpZWQgY29sb3IgYXJyYXlcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydHMucHJlbXVsdGlwbHkgPSBmdW5jdGlvbiAoY29sb3IsIGFkZGl0aW9uYWxPcGFjaXR5KSB7XG4gICAgaWYgKCFjb2xvcikgcmV0dXJuIG51bGw7XG4gICAgdmFyIG9wYWNpdHkgPSBjb2xvclszXSAqIGFkZGl0aW9uYWxPcGFjaXR5O1xuICAgIHJldHVybiBbXG4gICAgICAgIGNvbG9yWzBdICogb3BhY2l0eSxcbiAgICAgICAgY29sb3JbMV0gKiBvcGFjaXR5LFxuICAgICAgICBjb2xvclsyXSAqIG9wYWNpdHksXG4gICAgICAgIG9wYWNpdHlcbiAgICBdO1xufTtcblxuLyoqXG4gKiBjb25zdHJhaW4gbiB0byB0aGUgZ2l2ZW4gcmFuZ2UgdmlhIG1pbiArIG1heFxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBuIHZhbHVlXG4gKiBAcGFyYW0ge251bWJlcn0gbWluIHRoZSBtaW5pbXVtIHZhbHVlIHRvIGJlIHJldHVybmVkXG4gKiBAcGFyYW0ge251bWJlcn0gbWF4IHRoZSBtYXhpbXVtIHZhbHVlIHRvIGJlIHJldHVybmVkXG4gKiBAcmV0dXJucyB7bnVtYmVyfSB0aGUgY2xhbXBlZCB2YWx1ZVxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0cy5jbGFtcCA9IGZ1bmN0aW9uIChuLCBtaW4sIG1heCkge1xuICAgIHJldHVybiBNYXRoLm1pbihtYXgsIE1hdGgubWF4KG1pbiwgbikpO1xufTtcblxuLypcbiAqIGNvbnN0cmFpbiBuIHRvIHRoZSBnaXZlbiByYW5nZSwgZXhjbHVkaW5nIHRoZSBtaW5pbXVtLCB2aWEgbW9kdWxhciBhcml0aG1ldGljXG4gKiBAcGFyYW0ge251bWJlcn0gbiB2YWx1ZVxuICogQHBhcmFtIHtudW1iZXJ9IG1pbiB0aGUgbWluaW11bSB2YWx1ZSB0byBiZSByZXR1cm5lZCwgZXhjbHVzaXZlXG4gKiBAcGFyYW0ge251bWJlcn0gbWF4IHRoZSBtYXhpbXVtIHZhbHVlIHRvIGJlIHJldHVybmVkLCBpbmNsdXNpdmVcbiAqIEByZXR1cm5zIHtudW1iZXJ9IGNvbnN0cmFpbmVkIG51bWJlclxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0cy53cmFwID0gZnVuY3Rpb24gKG4sIG1pbiwgbWF4KSB7XG4gICAgdmFyIGQgPSBtYXggLSBtaW47XG4gICAgdmFyIHcgPSAoKG4gLSBtaW4pICUgZCArIGQpICUgZCArIG1pbjtcbiAgICByZXR1cm4gKHcgPT09IG1pbikgPyBtYXggOiB3O1xufTtcblxuLypcbiAqIHJldHVybiB0aGUgZmlyc3Qgbm9uLW51bGwgYW5kIG5vbi11bmRlZmluZWQgYXJndW1lbnQgdG8gdGhpcyBmdW5jdGlvbi5cbiAqIEByZXR1cm5zIHsqfSBhcmd1bWVudFxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0cy5jb2FsZXNjZSA9IGZ1bmN0aW9uKCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBhcmcgPSBhcmd1bWVudHNbaV07XG4gICAgICAgIGlmIChhcmcgIT09IG51bGwgJiYgYXJnICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZXR1cm4gYXJnO1xuICAgIH1cbn07XG5cbi8qXG4gKiBDYWxsIGFuIGFzeW5jaHJvbm91cyBmdW5jdGlvbiBvbiBhbiBhcnJheSBvZiBhcmd1bWVudHMsXG4gKiBjYWxsaW5nIGBjYWxsYmFja2Agd2l0aCB0aGUgY29tcGxldGVkIHJlc3VsdHMgb2YgYWxsIGNhbGxzLlxuICpcbiAqIEBwYXJhbSB7QXJyYXk8Kj59IGFycmF5IGlucHV0IHRvIGVhY2ggY2FsbCBvZiB0aGUgYXN5bmMgZnVuY3Rpb24uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBhbiBhc3luYyBmdW5jdGlvbiB3aXRoIHNpZ25hdHVyZSAoZGF0YSwgY2FsbGJhY2spXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBhIGNhbGxiYWNrIHJ1biBhZnRlciBhbGwgYXN5bmMgd29yayBpcyBkb25lLlxuICogY2FsbGVkIHdpdGggYW4gYXJyYXksIGNvbnRhaW5pbmcgdGhlIHJlc3VsdHMgb2YgZWFjaCBhc3luYyBjYWxsLlxuICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydHMuYXN5bmNBbGwgPSBmdW5jdGlvbiAoYXJyYXksIGZuLCBjYWxsYmFjaykge1xuICAgIGlmICghYXJyYXkubGVuZ3RoKSB7IHJldHVybiBjYWxsYmFjayhudWxsLCBbXSk7IH1cbiAgICB2YXIgcmVtYWluaW5nID0gYXJyYXkubGVuZ3RoO1xuICAgIHZhciByZXN1bHRzID0gbmV3IEFycmF5KGFycmF5Lmxlbmd0aCk7XG4gICAgdmFyIGVycm9yID0gbnVsbDtcbiAgICBhcnJheS5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtLCBpKSB7XG4gICAgICAgIGZuKGl0ZW0sIGZ1bmN0aW9uIChlcnIsIHJlc3VsdCkge1xuICAgICAgICAgICAgaWYgKGVycikgZXJyb3IgPSBlcnI7XG4gICAgICAgICAgICByZXN1bHRzW2ldID0gcmVzdWx0O1xuICAgICAgICAgICAgaWYgKC0tcmVtYWluaW5nID09PSAwKSBjYWxsYmFjayhlcnJvciwgcmVzdWx0cyk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xufTtcblxuLypcbiAqIENvbXB1dGUgdGhlIGRpZmZlcmVuY2UgYmV0d2VlbiB0aGUga2V5cyBpbiBvbmUgb2JqZWN0IGFuZCB0aGUga2V5c1xuICogaW4gYW5vdGhlciBvYmplY3QuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9ialxuICogQHBhcmFtIHtPYmplY3R9IG90aGVyXG4gKiBAcmV0dXJucyB7QXJyYXk8c3RyaW5nPn0ga2V5cyBkaWZmZXJlbmNlXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnRzLmtleXNEaWZmZXJlbmNlID0gZnVuY3Rpb24gKG9iaiwgb3RoZXIpIHtcbiAgICB2YXIgZGlmZmVyZW5jZSA9IFtdO1xuICAgIGZvciAodmFyIGkgaW4gb2JqKSB7XG4gICAgICAgIGlmICghKGkgaW4gb3RoZXIpKSB7XG4gICAgICAgICAgICBkaWZmZXJlbmNlLnB1c2goaSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGRpZmZlcmVuY2U7XG59O1xuXG4vKipcbiAqIEdpdmVuIGEgZGVzdGluYXRpb24gb2JqZWN0IGFuZCBvcHRpb25hbGx5IG1hbnkgc291cmNlIG9iamVjdHMsXG4gKiBjb3B5IGFsbCBwcm9wZXJ0aWVzIGZyb20gdGhlIHNvdXJjZSBvYmplY3RzIGludG8gdGhlIGRlc3RpbmF0aW9uLlxuICogVGhlIGxhc3Qgc291cmNlIG9iamVjdCBnaXZlbiBvdmVycmlkZXMgcHJvcGVydGllcyBmcm9tIHByZXZpb3VzXG4gKiBzb3VyY2Ugb2JqZWN0cy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBkZXN0IGRlc3RpbmF0aW9uIG9iamVjdFxuICogQHBhcmFtIHsuLi5PYmplY3R9IHNvdXJjZXMgc291cmNlcyBmcm9tIHdoaWNoIHByb3BlcnRpZXMgYXJlIHB1bGxlZFxuICogQHJldHVybnMge09iamVjdH0gZGVzdFxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0cy5leHRlbmQgPSBmdW5jdGlvbiAoZGVzdCkge1xuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBzcmMgPSBhcmd1bWVudHNbaV07XG4gICAgICAgIGZvciAodmFyIGsgaW4gc3JjKSB7XG4gICAgICAgICAgICBkZXN0W2tdID0gc3JjW2tdO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBkZXN0O1xufTtcblxuLyoqXG4gKiBFeHRlbmQgYSBkZXN0aW5hdGlvbiBvYmplY3Qgd2l0aCBhbGwgcHJvcGVydGllcyBvZiB0aGUgc3JjIG9iamVjdCxcbiAqIHVzaW5nIGRlZmluZVByb3BlcnR5IGluc3RlYWQgb2Ygc2ltcGxlIGFzc2lnbm1lbnQuXG4gKiBAcGFyYW0ge09iamVjdH0gZGVzdFxuICogQHBhcmFtIHtPYmplY3R9IHNyY1xuICogQHJldHVybnMge09iamVjdH0gZGVzdFxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0cy5leHRlbmRBbGwgPSBmdW5jdGlvbiAoZGVzdCwgc3JjKSB7XG4gICAgZm9yICh2YXIgaSBpbiBzcmMpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGRlc3QsIGksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc3JjLCBpKSk7XG4gICAgfVxuICAgIHJldHVybiBkZXN0O1xufTtcblxuLyoqXG4gKiBFeHRlbmQgYSBwYXJlbnQncyBwcm90b3R5cGUgd2l0aCBhbGwgcHJvcGVydGllcyBpbiBhIHByb3BlcnRpZXNcbiAqIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gcGFyZW50XG4gKiBAcGFyYW0ge09iamVjdH0gcHJvcHNcbiAqIEByZXR1cm5zIHtPYmplY3R9XG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnRzLmluaGVyaXQgPSBmdW5jdGlvbiAocGFyZW50LCBwcm9wcykge1xuICAgIHZhciBwYXJlbnRQcm90byA9IHR5cGVvZiBwYXJlbnQgPT09ICdmdW5jdGlvbicgPyBwYXJlbnQucHJvdG90eXBlIDogcGFyZW50LFxuICAgICAgICBwcm90byA9IE9iamVjdC5jcmVhdGUocGFyZW50UHJvdG8pO1xuICAgIGV4cG9ydHMuZXh0ZW5kQWxsKHByb3RvLCBwcm9wcyk7XG4gICAgcmV0dXJuIHByb3RvO1xufTtcblxuLyoqXG4gKiBHaXZlbiBhbiBvYmplY3QgYW5kIGEgbnVtYmVyIG9mIHByb3BlcnRpZXMgYXMgc3RyaW5ncywgcmV0dXJuIHZlcnNpb25cbiAqIG9mIHRoYXQgb2JqZWN0IHdpdGggb25seSB0aG9zZSBwcm9wZXJ0aWVzLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBzcmMgdGhlIG9iamVjdFxuICogQHBhcmFtIHtBcnJheTxzdHJpbmc+fSBwcm9wZXJ0aWVzIGFuIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzIGNob3NlblxuICogdG8gYXBwZWFyIG9uIHRoZSByZXN1bHRpbmcgb2JqZWN0LlxuICogQHJldHVybnMge09iamVjdH0gb2JqZWN0IHdpdGggbGltaXRlZCBwcm9wZXJ0aWVzLlxuICogQGV4YW1wbGVcbiAqIHZhciBmb28gPSB7IG5hbWU6ICdDaGFybGllJywgYWdlOiAxMCB9O1xuICogdmFyIGp1c3ROYW1lID0gcGljayhmb28sIFsnbmFtZSddKTtcbiAqIC8vIGp1c3ROYW1lID0geyBuYW1lOiAnQ2hhcmxpZScgfVxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0cy5waWNrID0gZnVuY3Rpb24gKHNyYywgcHJvcGVydGllcykge1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BlcnRpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGsgPSBwcm9wZXJ0aWVzW2ldO1xuICAgICAgICBpZiAoayBpbiBzcmMpIHtcbiAgICAgICAgICAgIHJlc3VsdFtrXSA9IHNyY1trXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufTtcblxudmFyIGlkID0gMTtcblxuLyoqXG4gKiBSZXR1cm4gYSB1bmlxdWUgbnVtZXJpYyBpZCwgc3RhcnRpbmcgYXQgMSBhbmQgaW5jcmVtZW50aW5nIHdpdGhcbiAqIGVhY2ggY2FsbC5cbiAqXG4gKiBAcmV0dXJucyB7bnVtYmVyfSB1bmlxdWUgbnVtZXJpYyBpZC5cbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydHMudW5pcXVlSWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGlkKys7XG59O1xuXG4vKipcbiAqIENyZWF0ZSBhIHZlcnNpb24gb2YgYGZuYCB0aGF0IG9ubHkgZmlyZXMgb25jZSBldmVyeSBgdGltZWAgbWlsbHNlY29uZHMuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gdGhlIGZ1bmN0aW9uIHRvIGJlIHRocm90dGxlZFxuICogQHBhcmFtIHtudW1iZXJ9IHRpbWUgbWlsbHNlY29uZHMgcmVxdWlyZWQgYmV0d2VlbiBmdW5jdGlvbiBjYWxsc1xuICogQHBhcmFtIHsqfSBjb250ZXh0IHRoZSB2YWx1ZSBvZiBgdGhpc2Agd2l0aCB3aGljaCB0aGUgZnVuY3Rpb24gaXMgY2FsbGVkXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IGRlYm91bmNlZCBmdW5jdGlvblxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0cy50aHJvdHRsZSA9IGZ1bmN0aW9uIChmbiwgdGltZSwgY29udGV4dCkge1xuICAgIHZhciBsb2NrLCBhcmdzLCB3cmFwcGVyRm4sIGxhdGVyO1xuXG4gICAgbGF0ZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIHJlc2V0IGxvY2sgYW5kIGNhbGwgaWYgcXVldWVkXG4gICAgICAgIGxvY2sgPSBmYWxzZTtcbiAgICAgICAgaWYgKGFyZ3MpIHtcbiAgICAgICAgICAgIHdyYXBwZXJGbi5hcHBseShjb250ZXh0LCBhcmdzKTtcbiAgICAgICAgICAgIGFyZ3MgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB3cmFwcGVyRm4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChsb2NrKSB7XG4gICAgICAgICAgICAvLyBjYWxsZWQgdG9vIHNvb24sIHF1ZXVlIHRvIGNhbGwgbGF0ZXJcbiAgICAgICAgICAgIGFyZ3MgPSBhcmd1bWVudHM7XG5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIGNhbGwgYW5kIGxvY2sgdW50aWwgbGF0ZXJcbiAgICAgICAgICAgIGZuLmFwcGx5KGNvbnRleHQsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KGxhdGVyLCB0aW1lKTtcbiAgICAgICAgICAgIGxvY2sgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHJldHVybiB3cmFwcGVyRm47XG59O1xuXG4vKipcbiAqIENyZWF0ZSBhIHZlcnNpb24gb2YgYGZuYCB0aGF0IGlzIG9ubHkgY2FsbGVkIGB0aW1lYCBtaWxsaXNlY29uZHNcbiAqIGFmdGVyIGl0cyBsYXN0IGludm9jYXRpb25cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiB0aGUgZnVuY3Rpb24gdG8gYmUgZGVib3VuY2VkXG4gKiBAcGFyYW0ge251bWJlcn0gdGltZSBtaWxsc2Vjb25kcyBhZnRlciB3aGljaCB0aGUgZnVuY3Rpb24gd2lsbCBiZSBpbnZva2VkXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IGRlYm91bmNlZCBmdW5jdGlvblxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0cy5kZWJvdW5jZSA9IGZ1bmN0aW9uKGZuLCB0aW1lKSB7XG4gICAgdmFyIHRpbWVyLCBhcmdzO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICBhcmdzID0gYXJndW1lbnRzO1xuICAgICAgICBjbGVhclRpbWVvdXQodGltZXIpO1xuXG4gICAgICAgIHRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGZuLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgICAgICB9LCB0aW1lKTtcbiAgICB9O1xufTtcblxuLyoqXG4gKiBHaXZlbiBhbiBhcnJheSBvZiBtZW1iZXIgZnVuY3Rpb24gbmFtZXMgYXMgc3RyaW5ncywgcmVwbGFjZSBhbGwgb2YgdGhlbVxuICogd2l0aCBib3VuZCB2ZXJzaW9ucyB0aGF0IHdpbGwgYWx3YXlzIHJlZmVyIHRvIGBjb250ZXh0YCBhcyBgdGhpc2AuIFRoaXNcbiAqIGlzIHVzZWZ1bCBmb3IgY2xhc3NlcyB3aGVyZSBvdGhlcndpc2UgZXZlbnQgYmluZGluZ3Mgd291bGQgcmVhc3NpZ25cbiAqIGB0aGlzYCB0byB0aGUgZXZlbnRlZCBvYmplY3Qgb3Igc29tZSBvdGhlciB2YWx1ZTogdGhpcyBsZXRzIHlvdSBlbnN1cmVcbiAqIHRoZSBgdGhpc2AgdmFsdWUgYWx3YXlzLlxuICpcbiAqIEBwYXJhbSB7QXJyYXk8c3RyaW5nPn0gZm5zIGxpc3Qgb2YgbWVtYmVyIGZ1bmN0aW9uIG5hbWVzXG4gKiBAcGFyYW0geyp9IGNvbnRleHQgdGhlIGNvbnRleHQgdmFsdWVcbiAqIEByZXR1cm5zIHt1bmRlZmluZWR9IGNoYW5nZXMgZnVuY3Rpb25zIGluLXBsYWNlXG4gKiBAZXhhbXBsZVxuICogZnVuY3Rpb24gTXlDbGFzcygpIHtcbiAqICAgYmluZEFsbChbJ29udGltZXInXSwgdGhpcyk7XG4gKiAgIHRoaXMubmFtZSA9ICdUb20nO1xuICogfVxuICogTXlDbGFzcy5wcm90b3R5cGUub250aW1lciA9IGZ1bmN0aW9uKCkge1xuICogICBhbGVydCh0aGlzLm5hbWUpO1xuICogfTtcbiAqIHZhciBteUNsYXNzID0gbmV3IE15Q2xhc3MoKTtcbiAqIHNldFRpbWVvdXQobXlDbGFzcy5vbnRpbWVyLCAxMDApO1xuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0cy5iaW5kQWxsID0gZnVuY3Rpb24oZm5zLCBjb250ZXh0KSB7XG4gICAgZm5zLmZvckVhY2goZnVuY3Rpb24oZm4pIHtcbiAgICAgICAgY29udGV4dFtmbl0gPSBjb250ZXh0W2ZuXS5iaW5kKGNvbnRleHQpO1xuICAgIH0pO1xufTtcblxuLyoqXG4gKiBHaXZlbiBhIGNsYXNzLCBiaW5kIGFsbCBvZiB0aGUgbWV0aG9kcyB0aGF0IGxvb2sgbGlrZSBoYW5kbGVyczogdGhhdFxuICogYmVnaW4gd2l0aCBfb24sIGFuZCBiaW5kIHRoZW0gdG8gdGhlIGNsYXNzLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb250ZXh0IGFuIG9iamVjdCB3aXRoIG1ldGhvZHNcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydHMuYmluZEhhbmRsZXJzID0gZnVuY3Rpb24oY29udGV4dCkge1xuICAgIGZvciAodmFyIGkgaW4gY29udGV4dCkge1xuICAgICAgICBpZiAodHlwZW9mIGNvbnRleHRbaV0gPT09ICdmdW5jdGlvbicgJiYgaS5pbmRleE9mKCdfb24nKSA9PT0gMCkge1xuICAgICAgICAgICAgY29udGV4dFtpXSA9IGNvbnRleHRbaV0uYmluZChjb250ZXh0KTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbi8qKlxuICogU2V0IHRoZSAnb3B0aW9ucycgcHJvcGVydHkgb24gYG9iamAgd2l0aCBwcm9wZXJ0aWVzXG4gKiBmcm9tIHRoZSBgb3B0aW9uc2AgYXJndW1lbnQuIFByb3BlcnRpZXMgaW4gdGhlIGBvcHRpb25zYFxuICogb2JqZWN0IHdpbGwgb3ZlcnJpZGUgZXhpc3RpbmcgcHJvcGVydGllcy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqIGRlc3RpbmF0aW9uIG9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgb2JqZWN0IG9mIG92ZXJyaWRlIG9wdGlvbnNcbiAqIEByZXR1cm5zIHtPYmplY3R9IGRlcml2ZWQgb3B0aW9ucyBvYmplY3QuXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnRzLnNldE9wdGlvbnMgPSBmdW5jdGlvbihvYmosIG9wdGlvbnMpIHtcbiAgICBpZiAoIW9iai5oYXNPd25Qcm9wZXJ0eSgnb3B0aW9ucycpKSB7XG4gICAgICAgIG9iai5vcHRpb25zID0gb2JqLm9wdGlvbnMgPyBPYmplY3QuY3JlYXRlKG9iai5vcHRpb25zKSA6IHt9O1xuICAgIH1cbiAgICBmb3IgKHZhciBpIGluIG9wdGlvbnMpIHtcbiAgICAgICAgb2JqLm9wdGlvbnNbaV0gPSBvcHRpb25zW2ldO1xuICAgIH1cbiAgICByZXR1cm4gb2JqLm9wdGlvbnM7XG59O1xuXG4vKipcbiAqIEdpdmVuIGEgbGlzdCBvZiBjb29yZGluYXRlcywgZ2V0IHRoZWlyIGNlbnRlciBhcyBhIGNvb3JkaW5hdGUuXG4gKiBAcGFyYW0ge0FycmF5PENvb3JkaW5hdGU+fSBjb29yZHNcbiAqIEByZXR1cm5zIHtDb29yZGluYXRlfSBjZW50ZXJwb2ludFxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0cy5nZXRDb29yZGluYXRlc0NlbnRlciA9IGZ1bmN0aW9uKGNvb3Jkcykge1xuICAgIHZhciBtaW5YID0gSW5maW5pdHk7XG4gICAgdmFyIG1pblkgPSBJbmZpbml0eTtcbiAgICB2YXIgbWF4WCA9IC1JbmZpbml0eTtcbiAgICB2YXIgbWF4WSA9IC1JbmZpbml0eTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29vcmRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIG1pblggPSBNYXRoLm1pbihtaW5YLCBjb29yZHNbaV0uY29sdW1uKTtcbiAgICAgICAgbWluWSA9IE1hdGgubWluKG1pblksIGNvb3Jkc1tpXS5yb3cpO1xuICAgICAgICBtYXhYID0gTWF0aC5tYXgobWF4WCwgY29vcmRzW2ldLmNvbHVtbik7XG4gICAgICAgIG1heFkgPSBNYXRoLm1heChtYXhZLCBjb29yZHNbaV0ucm93KTtcbiAgICB9XG5cbiAgICB2YXIgZHggPSBtYXhYIC0gbWluWDtcbiAgICB2YXIgZHkgPSBtYXhZIC0gbWluWTtcbiAgICB2YXIgZE1heCA9IE1hdGgubWF4KGR4LCBkeSk7XG4gICAgcmV0dXJuIG5ldyBDb29yZGluYXRlKChtaW5YICsgbWF4WCkgLyAyLCAobWluWSArIG1heFkpIC8gMiwgMClcbiAgICAgICAgLnpvb21UbyhNYXRoLmZsb29yKC1NYXRoLmxvZyhkTWF4KSAvIE1hdGguTE4yKSk7XG59O1xuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHN0cmluZyBlbmRzIHdpdGggYSBwYXJ0aWN1bGFyIHN1YnN0cmluZ1xuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZ1xuICogQHBhcmFtIHtzdHJpbmd9IHN1ZmZpeFxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnRzLmVuZHNXaXRoID0gZnVuY3Rpb24oc3RyaW5nLCBzdWZmaXgpIHtcbiAgICByZXR1cm4gc3RyaW5nLmluZGV4T2Yoc3VmZml4LCBzdHJpbmcubGVuZ3RoIC0gc3VmZml4Lmxlbmd0aCkgIT09IC0xO1xufTtcblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSBzdHJpbmcgc3RhcnRzIHdpdGggYSBwYXJ0aWN1bGFyIHN1YnN0cmluZ1xuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZ1xuICogQHBhcmFtIHtzdHJpbmd9IHByZWZpeFxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnRzLnN0YXJ0c1dpdGggPSBmdW5jdGlvbihzdHJpbmcsIHByZWZpeCkge1xuICAgIHJldHVybiBzdHJpbmcuaW5kZXhPZihwcmVmaXgpID09PSAwO1xufTtcblxuLyoqXG4gKiBDcmVhdGUgYW4gb2JqZWN0IGJ5IG1hcHBpbmcgYWxsIHRoZSB2YWx1ZXMgb2YgYW4gZXhpc3Rpbmcgb2JqZWN0IHdoaWxlXG4gKiBwcmVzZXJ2aW5nIHRoZWlyIGtleXMuXG4gKiBAcGFyYW0ge09iamVjdH0gaW5wdXRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdG9yXG4gKiBAcmV0dXJucyB7T2JqZWN0fVxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0cy5tYXBPYmplY3QgPSBmdW5jdGlvbihpbnB1dCwgaXRlcmF0b3IsIGNvbnRleHQpIHtcbiAgICB2YXIgb3V0cHV0ID0ge307XG4gICAgZm9yICh2YXIga2V5IGluIGlucHV0KSB7XG4gICAgICAgIG91dHB1dFtrZXldID0gaXRlcmF0b3IuY2FsbChjb250ZXh0IHx8IHRoaXMsIGlucHV0W2tleV0sIGtleSwgaW5wdXQpO1xuICAgIH1cbiAgICByZXR1cm4gb3V0cHV0O1xufTtcblxuLyoqXG4gKiBDcmVhdGUgYW4gb2JqZWN0IGJ5IGZpbHRlcmluZyBvdXQgdmFsdWVzIG9mIGFuIGV4aXN0aW5nIG9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IGlucHV0XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRvclxuICogQHJldHVybnMge09iamVjdH1cbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydHMuZmlsdGVyT2JqZWN0ID0gZnVuY3Rpb24oaW5wdXQsIGl0ZXJhdG9yLCBjb250ZXh0KSB7XG4gICAgdmFyIG91dHB1dCA9IHt9O1xuICAgIGZvciAodmFyIGtleSBpbiBpbnB1dCkge1xuICAgICAgICBpZiAoaXRlcmF0b3IuY2FsbChjb250ZXh0IHx8IHRoaXMsIGlucHV0W2tleV0sIGtleSwgaW5wdXQpKSB7XG4gICAgICAgICAgICBvdXRwdXRba2V5XSA9IGlucHV0W2tleV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG91dHB1dDtcbn07XG5cbi8qKlxuICogRGVlcGx5IGNvbXBhcmVzIHR3byBvYmplY3QgbGl0ZXJhbHMuXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqMVxuICogQHBhcmFtIHtPYmplY3R9IG9iajJcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0cy5kZWVwRXF1YWwgPSBmdW5jdGlvbiBkZWVwRXF1YWwoYSwgYikge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGEpKSB7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShiKSB8fCBhLmxlbmd0aCAhPT0gYi5sZW5ndGgpIHJldHVybiBmYWxzZTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoIWRlZXBFcXVhbChhW2ldLCBiW2ldKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGEgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIGlmICghKHR5cGVvZiBiID09PSAnb2JqZWN0JykpIHJldHVybiBmYWxzZTtcbiAgICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhhKTtcbiAgICAgICAgaWYgKGtleXMubGVuZ3RoICE9PSBPYmplY3Qua2V5cyhiKS5sZW5ndGgpIHJldHVybiBmYWxzZTtcbiAgICAgICAgZm9yICh2YXIga2V5IGluIGEpIHtcbiAgICAgICAgICAgIGlmICghZGVlcEVxdWFsKGFba2V5XSwgYltrZXldKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gYSA9PT0gYjtcbn07XG5cbi8qKlxuICogQ2hlY2sgaWYgdHdvIGFycmF5cyBoYXZlIGF0IGxlYXN0IG9uZSBjb21tb24gZWxlbWVudC5cbiAqIEBwYXJhbSB7QXJyYXl9IGFcbiAqIEBwYXJhbSB7QXJyYXl9IGJcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0cy5hcnJheXNJbnRlcnNlY3QgPSBmdW5jdGlvbihhLCBiKSB7XG4gICAgZm9yICh2YXIgbCA9IDA7IGwgPCBhLmxlbmd0aDsgbCsrKSB7XG4gICAgICAgIGlmIChiLmluZGV4T2YoYVtsXSkgPj0gMCkgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBWZWN0b3JUaWxlRmVhdHVyZSA9IHJlcXVpcmUoJ3ZlY3Rvci10aWxlJykuVmVjdG9yVGlsZUZlYXR1cmU7XG5cbm1vZHVsZS5leHBvcnRzID0gRmVhdHVyZTtcblxuZnVuY3Rpb24gRmVhdHVyZSh2ZWN0b3JUaWxlRmVhdHVyZSwgeiwgeCwgeSkge1xuICAgIHRoaXMuX3ZlY3RvclRpbGVGZWF0dXJlID0gdmVjdG9yVGlsZUZlYXR1cmU7XG4gICAgdmVjdG9yVGlsZUZlYXR1cmUuX3ogPSB6O1xuICAgIHZlY3RvclRpbGVGZWF0dXJlLl94ID0geDtcbiAgICB2ZWN0b3JUaWxlRmVhdHVyZS5feSA9IHk7XG5cbiAgICB0aGlzLnByb3BlcnRpZXMgPSB2ZWN0b3JUaWxlRmVhdHVyZS5wcm9wZXJ0aWVzO1xuXG4gICAgaWYgKHZlY3RvclRpbGVGZWF0dXJlLl9pZCkge1xuICAgICAgICB0aGlzLmlkID0gdmVjdG9yVGlsZUZlYXR1cmUuX2lkO1xuICAgIH1cbn1cblxuRmVhdHVyZS5wcm90b3R5cGUgPSB7XG4gICAgdHlwZTogXCJGZWF0dXJlXCIsXG5cbiAgICBnZXQgZ2VvbWV0cnkoKSB7XG4gICAgICAgIGlmICh0aGlzLl9nZW9tZXRyeSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB2YXIgZmVhdHVyZSA9IHRoaXMuX3ZlY3RvclRpbGVGZWF0dXJlO1xuICAgICAgICAgICAgdmFyIGNvb3JkcyA9IHByb2plY3RDb29yZHMoXG4gICAgICAgICAgICAgICAgZmVhdHVyZS5sb2FkR2VvbWV0cnkoKSxcbiAgICAgICAgICAgICAgICBmZWF0dXJlLmV4dGVudCxcbiAgICAgICAgICAgICAgICBmZWF0dXJlLl96LCBmZWF0dXJlLl94LCBmZWF0dXJlLl95KTtcblxuICAgICAgICAgICAgdmFyIHR5cGUgPSBWZWN0b3JUaWxlRmVhdHVyZS50eXBlc1tmZWF0dXJlLnR5cGVdO1xuXG4gICAgICAgICAgICBpZiAodHlwZSA9PT0gJ1BvaW50JyAmJiBjb29yZHMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgY29vcmRzID0gY29vcmRzWzBdWzBdO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSAnUG9pbnQnKSB7XG4gICAgICAgICAgICAgICAgY29vcmRzID0gY29vcmRzWzBdO1xuICAgICAgICAgICAgICAgIHR5cGUgPSAnTXVsdGlQb2ludCc7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdMaW5lU3RyaW5nJyAmJiBjb29yZHMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgY29vcmRzID0gY29vcmRzWzBdO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSAnTGluZVN0cmluZycpIHtcbiAgICAgICAgICAgICAgICB0eXBlID0gJ011bHRpTGluZVN0cmluZyc7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuX2dlb21ldHJ5ID0ge1xuICAgICAgICAgICAgICAgIHR5cGU6IHR5cGUsXG4gICAgICAgICAgICAgICAgY29vcmRpbmF0ZXM6IGNvb3Jkc1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgdGhpcy5fdmVjdG9yVGlsZUZlYXR1cmUgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9nZW9tZXRyeTtcbiAgICB9LFxuXG4gICAgc2V0IGdlb21ldHJ5KGcpIHtcbiAgICAgICAgdGhpcy5fZ2VvbWV0cnkgPSBnO1xuICAgIH0sXG5cbiAgICB0b0pTT046IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIganNvbiA9IHt9O1xuICAgICAgICBmb3IgKHZhciBpIGluIHRoaXMpIHtcbiAgICAgICAgICAgIGlmIChpID09PSAnX2dlb21ldHJ5JyB8fCBpID09PSAnX3ZlY3RvclRpbGVGZWF0dXJlJykgY29udGludWU7XG4gICAgICAgICAgICBqc29uW2ldID0gdGhpc1tpXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ganNvbjtcbiAgICB9XG59O1xuXG5mdW5jdGlvbiBwcm9qZWN0Q29vcmRzKGNvb3JkcywgZXh0ZW50LCB6LCB4LCB5KSB7XG4gICAgdmFyIHNpemUgPSBleHRlbnQgKiBNYXRoLnBvdygyLCB6KSxcbiAgICAgICAgeDAgPSBleHRlbnQgKiB4LFxuICAgICAgICB5MCA9IGV4dGVudCAqIHk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb29yZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGxpbmUgPSBjb29yZHNbaV07XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbGluZS5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgdmFyIHAgPSBsaW5lW2pdO1xuICAgICAgICAgICAgdmFyIHkyID0gMTgwIC0gKHAueSArIHkwKSAqIDM2MCAvIHNpemU7XG4gICAgICAgICAgICBsaW5lW2pdID0gW1xuICAgICAgICAgICAgICAgIChwLnggKyB4MCkgKiAzNjAgLyBzaXplIC0gMTgwLFxuICAgICAgICAgICAgICAgIDM2MCAvIE1hdGguUEkgKiBNYXRoLmF0YW4oTWF0aC5leHAoeTIgKiBNYXRoLlBJIC8gMTgwKSkgLSA5MFxuICAgICAgICAgICAgXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY29vcmRzO1xufVxuIiwiLy8gaHR0cDovL3dpa2kuY29tbW9uanMub3JnL3dpa2kvVW5pdF9UZXN0aW5nLzEuMFxuLy9cbi8vIFRISVMgSVMgTk9UIFRFU1RFRCBOT1IgTElLRUxZIFRPIFdPUksgT1VUU0lERSBWOCFcbi8vXG4vLyBPcmlnaW5hbGx5IGZyb20gbmFyd2hhbC5qcyAoaHR0cDovL25hcndoYWxqcy5vcmcpXG4vLyBDb3B5cmlnaHQgKGMpIDIwMDkgVGhvbWFzIFJvYmluc29uIDwyODBub3J0aC5jb20+XG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuLy8gb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgJ1NvZnR3YXJlJyksIHRvXG4vLyBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZVxuLy8gcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yXG4vLyBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuLy8gZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuLy8gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEICdBUyBJUycsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1Jcbi8vIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuLy8gRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4vLyBBVVRIT1JTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTlxuLy8gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTlxuLy8gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbi8vIHdoZW4gdXNlZCBpbiBub2RlLCB0aGlzIHdpbGwgYWN0dWFsbHkgbG9hZCB0aGUgdXRpbCBtb2R1bGUgd2UgZGVwZW5kIG9uXG4vLyB2ZXJzdXMgbG9hZGluZyB0aGUgYnVpbHRpbiB1dGlsIG1vZHVsZSBhcyBoYXBwZW5zIG90aGVyd2lzZVxuLy8gdGhpcyBpcyBhIGJ1ZyBpbiBub2RlIG1vZHVsZSBsb2FkaW5nIGFzIGZhciBhcyBJIGFtIGNvbmNlcm5lZFxudmFyIHV0aWwgPSByZXF1aXJlKCd1dGlsLycpO1xuXG52YXIgcFNsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlO1xudmFyIGhhc093biA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbi8vIDEuIFRoZSBhc3NlcnQgbW9kdWxlIHByb3ZpZGVzIGZ1bmN0aW9ucyB0aGF0IHRocm93XG4vLyBBc3NlcnRpb25FcnJvcidzIHdoZW4gcGFydGljdWxhciBjb25kaXRpb25zIGFyZSBub3QgbWV0LiBUaGVcbi8vIGFzc2VydCBtb2R1bGUgbXVzdCBjb25mb3JtIHRvIHRoZSBmb2xsb3dpbmcgaW50ZXJmYWNlLlxuXG52YXIgYXNzZXJ0ID0gbW9kdWxlLmV4cG9ydHMgPSBvaztcblxuLy8gMi4gVGhlIEFzc2VydGlvbkVycm9yIGlzIGRlZmluZWQgaW4gYXNzZXJ0LlxuLy8gbmV3IGFzc2VydC5Bc3NlcnRpb25FcnJvcih7IG1lc3NhZ2U6IG1lc3NhZ2UsXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWN0dWFsOiBhY3R1YWwsXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IGV4cGVjdGVkIH0pXG5cbmFzc2VydC5Bc3NlcnRpb25FcnJvciA9IGZ1bmN0aW9uIEFzc2VydGlvbkVycm9yKG9wdGlvbnMpIHtcbiAgdGhpcy5uYW1lID0gJ0Fzc2VydGlvbkVycm9yJztcbiAgdGhpcy5hY3R1YWwgPSBvcHRpb25zLmFjdHVhbDtcbiAgdGhpcy5leHBlY3RlZCA9IG9wdGlvbnMuZXhwZWN0ZWQ7XG4gIHRoaXMub3BlcmF0b3IgPSBvcHRpb25zLm9wZXJhdG9yO1xuICBpZiAob3B0aW9ucy5tZXNzYWdlKSB7XG4gICAgdGhpcy5tZXNzYWdlID0gb3B0aW9ucy5tZXNzYWdlO1xuICAgIHRoaXMuZ2VuZXJhdGVkTWVzc2FnZSA9IGZhbHNlO1xuICB9IGVsc2Uge1xuICAgIHRoaXMubWVzc2FnZSA9IGdldE1lc3NhZ2UodGhpcyk7XG4gICAgdGhpcy5nZW5lcmF0ZWRNZXNzYWdlID0gdHJ1ZTtcbiAgfVxuICB2YXIgc3RhY2tTdGFydEZ1bmN0aW9uID0gb3B0aW9ucy5zdGFja1N0YXJ0RnVuY3Rpb24gfHwgZmFpbDtcblxuICBpZiAoRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UpIHtcbiAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCBzdGFja1N0YXJ0RnVuY3Rpb24pO1xuICB9XG4gIGVsc2Uge1xuICAgIC8vIG5vbiB2OCBicm93c2VycyBzbyB3ZSBjYW4gaGF2ZSBhIHN0YWNrdHJhY2VcbiAgICB2YXIgZXJyID0gbmV3IEVycm9yKCk7XG4gICAgaWYgKGVyci5zdGFjaykge1xuICAgICAgdmFyIG91dCA9IGVyci5zdGFjaztcblxuICAgICAgLy8gdHJ5IHRvIHN0cmlwIHVzZWxlc3MgZnJhbWVzXG4gICAgICB2YXIgZm5fbmFtZSA9IHN0YWNrU3RhcnRGdW5jdGlvbi5uYW1lO1xuICAgICAgdmFyIGlkeCA9IG91dC5pbmRleE9mKCdcXG4nICsgZm5fbmFtZSk7XG4gICAgICBpZiAoaWR4ID49IDApIHtcbiAgICAgICAgLy8gb25jZSB3ZSBoYXZlIGxvY2F0ZWQgdGhlIGZ1bmN0aW9uIGZyYW1lXG4gICAgICAgIC8vIHdlIG5lZWQgdG8gc3RyaXAgb3V0IGV2ZXJ5dGhpbmcgYmVmb3JlIGl0IChhbmQgaXRzIGxpbmUpXG4gICAgICAgIHZhciBuZXh0X2xpbmUgPSBvdXQuaW5kZXhPZignXFxuJywgaWR4ICsgMSk7XG4gICAgICAgIG91dCA9IG91dC5zdWJzdHJpbmcobmV4dF9saW5lICsgMSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuc3RhY2sgPSBvdXQ7XG4gICAgfVxuICB9XG59O1xuXG4vLyBhc3NlcnQuQXNzZXJ0aW9uRXJyb3IgaW5zdGFuY2VvZiBFcnJvclxudXRpbC5pbmhlcml0cyhhc3NlcnQuQXNzZXJ0aW9uRXJyb3IsIEVycm9yKTtcblxuZnVuY3Rpb24gcmVwbGFjZXIoa2V5LCB2YWx1ZSkge1xuICBpZiAodXRpbC5pc1VuZGVmaW5lZCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gJycgKyB2YWx1ZTtcbiAgfVxuICBpZiAodXRpbC5pc051bWJlcih2YWx1ZSkgJiYgIWlzRmluaXRlKHZhbHVlKSkge1xuICAgIHJldHVybiB2YWx1ZS50b1N0cmluZygpO1xuICB9XG4gIGlmICh1dGlsLmlzRnVuY3Rpb24odmFsdWUpIHx8IHV0aWwuaXNSZWdFeHAodmFsdWUpKSB7XG4gICAgcmV0dXJuIHZhbHVlLnRvU3RyaW5nKCk7XG4gIH1cbiAgcmV0dXJuIHZhbHVlO1xufVxuXG5mdW5jdGlvbiB0cnVuY2F0ZShzLCBuKSB7XG4gIGlmICh1dGlsLmlzU3RyaW5nKHMpKSB7XG4gICAgcmV0dXJuIHMubGVuZ3RoIDwgbiA/IHMgOiBzLnNsaWNlKDAsIG4pO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBzO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldE1lc3NhZ2Uoc2VsZikge1xuICByZXR1cm4gdHJ1bmNhdGUoSlNPTi5zdHJpbmdpZnkoc2VsZi5hY3R1YWwsIHJlcGxhY2VyKSwgMTI4KSArICcgJyArXG4gICAgICAgICBzZWxmLm9wZXJhdG9yICsgJyAnICtcbiAgICAgICAgIHRydW5jYXRlKEpTT04uc3RyaW5naWZ5KHNlbGYuZXhwZWN0ZWQsIHJlcGxhY2VyKSwgMTI4KTtcbn1cblxuLy8gQXQgcHJlc2VudCBvbmx5IHRoZSB0aHJlZSBrZXlzIG1lbnRpb25lZCBhYm92ZSBhcmUgdXNlZCBhbmRcbi8vIHVuZGVyc3Rvb2QgYnkgdGhlIHNwZWMuIEltcGxlbWVudGF0aW9ucyBvciBzdWIgbW9kdWxlcyBjYW4gcGFzc1xuLy8gb3RoZXIga2V5cyB0byB0aGUgQXNzZXJ0aW9uRXJyb3IncyBjb25zdHJ1Y3RvciAtIHRoZXkgd2lsbCBiZVxuLy8gaWdub3JlZC5cblxuLy8gMy4gQWxsIG9mIHRoZSBmb2xsb3dpbmcgZnVuY3Rpb25zIG11c3QgdGhyb3cgYW4gQXNzZXJ0aW9uRXJyb3Jcbi8vIHdoZW4gYSBjb3JyZXNwb25kaW5nIGNvbmRpdGlvbiBpcyBub3QgbWV0LCB3aXRoIGEgbWVzc2FnZSB0aGF0XG4vLyBtYXkgYmUgdW5kZWZpbmVkIGlmIG5vdCBwcm92aWRlZC4gIEFsbCBhc3NlcnRpb24gbWV0aG9kcyBwcm92aWRlXG4vLyBib3RoIHRoZSBhY3R1YWwgYW5kIGV4cGVjdGVkIHZhbHVlcyB0byB0aGUgYXNzZXJ0aW9uIGVycm9yIGZvclxuLy8gZGlzcGxheSBwdXJwb3Nlcy5cblxuZnVuY3Rpb24gZmFpbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlLCBvcGVyYXRvciwgc3RhY2tTdGFydEZ1bmN0aW9uKSB7XG4gIHRocm93IG5ldyBhc3NlcnQuQXNzZXJ0aW9uRXJyb3Ioe1xuICAgIG1lc3NhZ2U6IG1lc3NhZ2UsXG4gICAgYWN0dWFsOiBhY3R1YWwsXG4gICAgZXhwZWN0ZWQ6IGV4cGVjdGVkLFxuICAgIG9wZXJhdG9yOiBvcGVyYXRvcixcbiAgICBzdGFja1N0YXJ0RnVuY3Rpb246IHN0YWNrU3RhcnRGdW5jdGlvblxuICB9KTtcbn1cblxuLy8gRVhURU5TSU9OISBhbGxvd3MgZm9yIHdlbGwgYmVoYXZlZCBlcnJvcnMgZGVmaW5lZCBlbHNld2hlcmUuXG5hc3NlcnQuZmFpbCA9IGZhaWw7XG5cbi8vIDQuIFB1cmUgYXNzZXJ0aW9uIHRlc3RzIHdoZXRoZXIgYSB2YWx1ZSBpcyB0cnV0aHksIGFzIGRldGVybWluZWRcbi8vIGJ5ICEhZ3VhcmQuXG4vLyBhc3NlcnQub2soZ3VhcmQsIG1lc3NhZ2Vfb3B0KTtcbi8vIFRoaXMgc3RhdGVtZW50IGlzIGVxdWl2YWxlbnQgdG8gYXNzZXJ0LmVxdWFsKHRydWUsICEhZ3VhcmQsXG4vLyBtZXNzYWdlX29wdCk7LiBUbyB0ZXN0IHN0cmljdGx5IGZvciB0aGUgdmFsdWUgdHJ1ZSwgdXNlXG4vLyBhc3NlcnQuc3RyaWN0RXF1YWwodHJ1ZSwgZ3VhcmQsIG1lc3NhZ2Vfb3B0KTsuXG5cbmZ1bmN0aW9uIG9rKHZhbHVlLCBtZXNzYWdlKSB7XG4gIGlmICghdmFsdWUpIGZhaWwodmFsdWUsIHRydWUsIG1lc3NhZ2UsICc9PScsIGFzc2VydC5vayk7XG59XG5hc3NlcnQub2sgPSBvaztcblxuLy8gNS4gVGhlIGVxdWFsaXR5IGFzc2VydGlvbiB0ZXN0cyBzaGFsbG93LCBjb2VyY2l2ZSBlcXVhbGl0eSB3aXRoXG4vLyA9PS5cbi8vIGFzc2VydC5lcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlX29wdCk7XG5cbmFzc2VydC5lcXVhbCA9IGZ1bmN0aW9uIGVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UpIHtcbiAgaWYgKGFjdHVhbCAhPSBleHBlY3RlZCkgZmFpbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlLCAnPT0nLCBhc3NlcnQuZXF1YWwpO1xufTtcblxuLy8gNi4gVGhlIG5vbi1lcXVhbGl0eSBhc3NlcnRpb24gdGVzdHMgZm9yIHdoZXRoZXIgdHdvIG9iamVjdHMgYXJlIG5vdCBlcXVhbFxuLy8gd2l0aCAhPSBhc3NlcnQubm90RXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZV9vcHQpO1xuXG5hc3NlcnQubm90RXF1YWwgPSBmdW5jdGlvbiBub3RFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlKSB7XG4gIGlmIChhY3R1YWwgPT0gZXhwZWN0ZWQpIHtcbiAgICBmYWlsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UsICchPScsIGFzc2VydC5ub3RFcXVhbCk7XG4gIH1cbn07XG5cbi8vIDcuIFRoZSBlcXVpdmFsZW5jZSBhc3NlcnRpb24gdGVzdHMgYSBkZWVwIGVxdWFsaXR5IHJlbGF0aW9uLlxuLy8gYXNzZXJ0LmRlZXBFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlX29wdCk7XG5cbmFzc2VydC5kZWVwRXF1YWwgPSBmdW5jdGlvbiBkZWVwRXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSkge1xuICBpZiAoIV9kZWVwRXF1YWwoYWN0dWFsLCBleHBlY3RlZCkpIHtcbiAgICBmYWlsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UsICdkZWVwRXF1YWwnLCBhc3NlcnQuZGVlcEVxdWFsKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gX2RlZXBFcXVhbChhY3R1YWwsIGV4cGVjdGVkKSB7XG4gIC8vIDcuMS4gQWxsIGlkZW50aWNhbCB2YWx1ZXMgYXJlIGVxdWl2YWxlbnQsIGFzIGRldGVybWluZWQgYnkgPT09LlxuICBpZiAoYWN0dWFsID09PSBleHBlY3RlZCkge1xuICAgIHJldHVybiB0cnVlO1xuXG4gIH0gZWxzZSBpZiAodXRpbC5pc0J1ZmZlcihhY3R1YWwpICYmIHV0aWwuaXNCdWZmZXIoZXhwZWN0ZWQpKSB7XG4gICAgaWYgKGFjdHVhbC5sZW5ndGggIT0gZXhwZWN0ZWQubGVuZ3RoKSByZXR1cm4gZmFsc2U7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFjdHVhbC5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGFjdHVhbFtpXSAhPT0gZXhwZWN0ZWRbaV0pIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcblxuICAvLyA3LjIuIElmIHRoZSBleHBlY3RlZCB2YWx1ZSBpcyBhIERhdGUgb2JqZWN0LCB0aGUgYWN0dWFsIHZhbHVlIGlzXG4gIC8vIGVxdWl2YWxlbnQgaWYgaXQgaXMgYWxzbyBhIERhdGUgb2JqZWN0IHRoYXQgcmVmZXJzIHRvIHRoZSBzYW1lIHRpbWUuXG4gIH0gZWxzZSBpZiAodXRpbC5pc0RhdGUoYWN0dWFsKSAmJiB1dGlsLmlzRGF0ZShleHBlY3RlZCkpIHtcbiAgICByZXR1cm4gYWN0dWFsLmdldFRpbWUoKSA9PT0gZXhwZWN0ZWQuZ2V0VGltZSgpO1xuXG4gIC8vIDcuMyBJZiB0aGUgZXhwZWN0ZWQgdmFsdWUgaXMgYSBSZWdFeHAgb2JqZWN0LCB0aGUgYWN0dWFsIHZhbHVlIGlzXG4gIC8vIGVxdWl2YWxlbnQgaWYgaXQgaXMgYWxzbyBhIFJlZ0V4cCBvYmplY3Qgd2l0aCB0aGUgc2FtZSBzb3VyY2UgYW5kXG4gIC8vIHByb3BlcnRpZXMgKGBnbG9iYWxgLCBgbXVsdGlsaW5lYCwgYGxhc3RJbmRleGAsIGBpZ25vcmVDYXNlYCkuXG4gIH0gZWxzZSBpZiAodXRpbC5pc1JlZ0V4cChhY3R1YWwpICYmIHV0aWwuaXNSZWdFeHAoZXhwZWN0ZWQpKSB7XG4gICAgcmV0dXJuIGFjdHVhbC5zb3VyY2UgPT09IGV4cGVjdGVkLnNvdXJjZSAmJlxuICAgICAgICAgICBhY3R1YWwuZ2xvYmFsID09PSBleHBlY3RlZC5nbG9iYWwgJiZcbiAgICAgICAgICAgYWN0dWFsLm11bHRpbGluZSA9PT0gZXhwZWN0ZWQubXVsdGlsaW5lICYmXG4gICAgICAgICAgIGFjdHVhbC5sYXN0SW5kZXggPT09IGV4cGVjdGVkLmxhc3RJbmRleCAmJlxuICAgICAgICAgICBhY3R1YWwuaWdub3JlQ2FzZSA9PT0gZXhwZWN0ZWQuaWdub3JlQ2FzZTtcblxuICAvLyA3LjQuIE90aGVyIHBhaXJzIHRoYXQgZG8gbm90IGJvdGggcGFzcyB0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCcsXG4gIC8vIGVxdWl2YWxlbmNlIGlzIGRldGVybWluZWQgYnkgPT0uXG4gIH0gZWxzZSBpZiAoIXV0aWwuaXNPYmplY3QoYWN0dWFsKSAmJiAhdXRpbC5pc09iamVjdChleHBlY3RlZCkpIHtcbiAgICByZXR1cm4gYWN0dWFsID09IGV4cGVjdGVkO1xuXG4gIC8vIDcuNSBGb3IgYWxsIG90aGVyIE9iamVjdCBwYWlycywgaW5jbHVkaW5nIEFycmF5IG9iamVjdHMsIGVxdWl2YWxlbmNlIGlzXG4gIC8vIGRldGVybWluZWQgYnkgaGF2aW5nIHRoZSBzYW1lIG51bWJlciBvZiBvd25lZCBwcm9wZXJ0aWVzIChhcyB2ZXJpZmllZFxuICAvLyB3aXRoIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCksIHRoZSBzYW1lIHNldCBvZiBrZXlzXG4gIC8vIChhbHRob3VnaCBub3QgbmVjZXNzYXJpbHkgdGhlIHNhbWUgb3JkZXIpLCBlcXVpdmFsZW50IHZhbHVlcyBmb3IgZXZlcnlcbiAgLy8gY29ycmVzcG9uZGluZyBrZXksIGFuZCBhbiBpZGVudGljYWwgJ3Byb3RvdHlwZScgcHJvcGVydHkuIE5vdGU6IHRoaXNcbiAgLy8gYWNjb3VudHMgZm9yIGJvdGggbmFtZWQgYW5kIGluZGV4ZWQgcHJvcGVydGllcyBvbiBBcnJheXMuXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG9iakVxdWl2KGFjdHVhbCwgZXhwZWN0ZWQpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGlzQXJndW1lbnRzKG9iamVjdCkge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iamVjdCkgPT0gJ1tvYmplY3QgQXJndW1lbnRzXSc7XG59XG5cbmZ1bmN0aW9uIG9iakVxdWl2KGEsIGIpIHtcbiAgaWYgKHV0aWwuaXNOdWxsT3JVbmRlZmluZWQoYSkgfHwgdXRpbC5pc051bGxPclVuZGVmaW5lZChiKSlcbiAgICByZXR1cm4gZmFsc2U7XG4gIC8vIGFuIGlkZW50aWNhbCAncHJvdG90eXBlJyBwcm9wZXJ0eS5cbiAgaWYgKGEucHJvdG90eXBlICE9PSBiLnByb3RvdHlwZSkgcmV0dXJuIGZhbHNlO1xuICAvLyBpZiBvbmUgaXMgYSBwcmltaXRpdmUsIHRoZSBvdGhlciBtdXN0IGJlIHNhbWVcbiAgaWYgKHV0aWwuaXNQcmltaXRpdmUoYSkgfHwgdXRpbC5pc1ByaW1pdGl2ZShiKSkge1xuICAgIHJldHVybiBhID09PSBiO1xuICB9XG4gIHZhciBhSXNBcmdzID0gaXNBcmd1bWVudHMoYSksXG4gICAgICBiSXNBcmdzID0gaXNBcmd1bWVudHMoYik7XG4gIGlmICgoYUlzQXJncyAmJiAhYklzQXJncykgfHwgKCFhSXNBcmdzICYmIGJJc0FyZ3MpKVxuICAgIHJldHVybiBmYWxzZTtcbiAgaWYgKGFJc0FyZ3MpIHtcbiAgICBhID0gcFNsaWNlLmNhbGwoYSk7XG4gICAgYiA9IHBTbGljZS5jYWxsKGIpO1xuICAgIHJldHVybiBfZGVlcEVxdWFsKGEsIGIpO1xuICB9XG4gIHZhciBrYSA9IG9iamVjdEtleXMoYSksXG4gICAgICBrYiA9IG9iamVjdEtleXMoYiksXG4gICAgICBrZXksIGk7XG4gIC8vIGhhdmluZyB0aGUgc2FtZSBudW1iZXIgb2Ygb3duZWQgcHJvcGVydGllcyAoa2V5cyBpbmNvcnBvcmF0ZXNcbiAgLy8gaGFzT3duUHJvcGVydHkpXG4gIGlmIChrYS5sZW5ndGggIT0ga2IubGVuZ3RoKVxuICAgIHJldHVybiBmYWxzZTtcbiAgLy90aGUgc2FtZSBzZXQgb2Yga2V5cyAoYWx0aG91Z2ggbm90IG5lY2Vzc2FyaWx5IHRoZSBzYW1lIG9yZGVyKSxcbiAga2Euc29ydCgpO1xuICBrYi5zb3J0KCk7XG4gIC8vfn5+Y2hlYXAga2V5IHRlc3RcbiAgZm9yIChpID0ga2EubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBpZiAoa2FbaV0gIT0ga2JbaV0pXG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgLy9lcXVpdmFsZW50IHZhbHVlcyBmb3IgZXZlcnkgY29ycmVzcG9uZGluZyBrZXksIGFuZFxuICAvL35+fnBvc3NpYmx5IGV4cGVuc2l2ZSBkZWVwIHRlc3RcbiAgZm9yIChpID0ga2EubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBrZXkgPSBrYVtpXTtcbiAgICBpZiAoIV9kZWVwRXF1YWwoYVtrZXldLCBiW2tleV0pKSByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbi8vIDguIFRoZSBub24tZXF1aXZhbGVuY2UgYXNzZXJ0aW9uIHRlc3RzIGZvciBhbnkgZGVlcCBpbmVxdWFsaXR5LlxuLy8gYXNzZXJ0Lm5vdERlZXBFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlX29wdCk7XG5cbmFzc2VydC5ub3REZWVwRXF1YWwgPSBmdW5jdGlvbiBub3REZWVwRXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSkge1xuICBpZiAoX2RlZXBFcXVhbChhY3R1YWwsIGV4cGVjdGVkKSkge1xuICAgIGZhaWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSwgJ25vdERlZXBFcXVhbCcsIGFzc2VydC5ub3REZWVwRXF1YWwpO1xuICB9XG59O1xuXG4vLyA5LiBUaGUgc3RyaWN0IGVxdWFsaXR5IGFzc2VydGlvbiB0ZXN0cyBzdHJpY3QgZXF1YWxpdHksIGFzIGRldGVybWluZWQgYnkgPT09LlxuLy8gYXNzZXJ0LnN0cmljdEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2Vfb3B0KTtcblxuYXNzZXJ0LnN0cmljdEVxdWFsID0gZnVuY3Rpb24gc3RyaWN0RXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSkge1xuICBpZiAoYWN0dWFsICE9PSBleHBlY3RlZCkge1xuICAgIGZhaWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSwgJz09PScsIGFzc2VydC5zdHJpY3RFcXVhbCk7XG4gIH1cbn07XG5cbi8vIDEwLiBUaGUgc3RyaWN0IG5vbi1lcXVhbGl0eSBhc3NlcnRpb24gdGVzdHMgZm9yIHN0cmljdCBpbmVxdWFsaXR5LCBhc1xuLy8gZGV0ZXJtaW5lZCBieSAhPT0uICBhc3NlcnQubm90U3RyaWN0RXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZV9vcHQpO1xuXG5hc3NlcnQubm90U3RyaWN0RXF1YWwgPSBmdW5jdGlvbiBub3RTdHJpY3RFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlKSB7XG4gIGlmIChhY3R1YWwgPT09IGV4cGVjdGVkKSB7XG4gICAgZmFpbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlLCAnIT09JywgYXNzZXJ0Lm5vdFN0cmljdEVxdWFsKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gZXhwZWN0ZWRFeGNlcHRpb24oYWN0dWFsLCBleHBlY3RlZCkge1xuICBpZiAoIWFjdHVhbCB8fCAhZXhwZWN0ZWQpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGV4cGVjdGVkKSA9PSAnW29iamVjdCBSZWdFeHBdJykge1xuICAgIHJldHVybiBleHBlY3RlZC50ZXN0KGFjdHVhbCk7XG4gIH0gZWxzZSBpZiAoYWN0dWFsIGluc3RhbmNlb2YgZXhwZWN0ZWQpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBlbHNlIGlmIChleHBlY3RlZC5jYWxsKHt9LCBhY3R1YWwpID09PSB0cnVlKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIF90aHJvd3Moc2hvdWxkVGhyb3csIGJsb2NrLCBleHBlY3RlZCwgbWVzc2FnZSkge1xuICB2YXIgYWN0dWFsO1xuXG4gIGlmICh1dGlsLmlzU3RyaW5nKGV4cGVjdGVkKSkge1xuICAgIG1lc3NhZ2UgPSBleHBlY3RlZDtcbiAgICBleHBlY3RlZCA9IG51bGw7XG4gIH1cblxuICB0cnkge1xuICAgIGJsb2NrKCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBhY3R1YWwgPSBlO1xuICB9XG5cbiAgbWVzc2FnZSA9IChleHBlY3RlZCAmJiBleHBlY3RlZC5uYW1lID8gJyAoJyArIGV4cGVjdGVkLm5hbWUgKyAnKS4nIDogJy4nKSArXG4gICAgICAgICAgICAobWVzc2FnZSA/ICcgJyArIG1lc3NhZ2UgOiAnLicpO1xuXG4gIGlmIChzaG91bGRUaHJvdyAmJiAhYWN0dWFsKSB7XG4gICAgZmFpbChhY3R1YWwsIGV4cGVjdGVkLCAnTWlzc2luZyBleHBlY3RlZCBleGNlcHRpb24nICsgbWVzc2FnZSk7XG4gIH1cblxuICBpZiAoIXNob3VsZFRocm93ICYmIGV4cGVjdGVkRXhjZXB0aW9uKGFjdHVhbCwgZXhwZWN0ZWQpKSB7XG4gICAgZmFpbChhY3R1YWwsIGV4cGVjdGVkLCAnR290IHVud2FudGVkIGV4Y2VwdGlvbicgKyBtZXNzYWdlKTtcbiAgfVxuXG4gIGlmICgoc2hvdWxkVGhyb3cgJiYgYWN0dWFsICYmIGV4cGVjdGVkICYmXG4gICAgICAhZXhwZWN0ZWRFeGNlcHRpb24oYWN0dWFsLCBleHBlY3RlZCkpIHx8ICghc2hvdWxkVGhyb3cgJiYgYWN0dWFsKSkge1xuICAgIHRocm93IGFjdHVhbDtcbiAgfVxufVxuXG4vLyAxMS4gRXhwZWN0ZWQgdG8gdGhyb3cgYW4gZXJyb3I6XG4vLyBhc3NlcnQudGhyb3dzKGJsb2NrLCBFcnJvcl9vcHQsIG1lc3NhZ2Vfb3B0KTtcblxuYXNzZXJ0LnRocm93cyA9IGZ1bmN0aW9uKGJsb2NrLCAvKm9wdGlvbmFsKi9lcnJvciwgLypvcHRpb25hbCovbWVzc2FnZSkge1xuICBfdGhyb3dzLmFwcGx5KHRoaXMsIFt0cnVlXS5jb25jYXQocFNsaWNlLmNhbGwoYXJndW1lbnRzKSkpO1xufTtcblxuLy8gRVhURU5TSU9OISBUaGlzIGlzIGFubm95aW5nIHRvIHdyaXRlIG91dHNpZGUgdGhpcyBtb2R1bGUuXG5hc3NlcnQuZG9lc05vdFRocm93ID0gZnVuY3Rpb24oYmxvY2ssIC8qb3B0aW9uYWwqL21lc3NhZ2UpIHtcbiAgX3Rocm93cy5hcHBseSh0aGlzLCBbZmFsc2VdLmNvbmNhdChwU2xpY2UuY2FsbChhcmd1bWVudHMpKSk7XG59O1xuXG5hc3NlcnQuaWZFcnJvciA9IGZ1bmN0aW9uKGVycikgeyBpZiAoZXJyKSB7dGhyb3cgZXJyO319O1xuXG52YXIgb2JqZWN0S2V5cyA9IE9iamVjdC5rZXlzIHx8IGZ1bmN0aW9uIChvYmopIHtcbiAgdmFyIGtleXMgPSBbXTtcbiAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgIGlmIChoYXNPd24uY2FsbChvYmosIGtleSkpIGtleXMucHVzaChrZXkpO1xuICB9XG4gIHJldHVybiBrZXlzO1xufTtcbiIsImlmICh0eXBlb2YgT2JqZWN0LmNyZWF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAvLyBpbXBsZW1lbnRhdGlvbiBmcm9tIHN0YW5kYXJkIG5vZGUuanMgJ3V0aWwnIG1vZHVsZVxuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGluaGVyaXRzKGN0b3IsIHN1cGVyQ3Rvcikge1xuICAgIGN0b3Iuc3VwZXJfID0gc3VwZXJDdG9yXG4gICAgY3Rvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ3Rvci5wcm90b3R5cGUsIHtcbiAgICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICAgIHZhbHVlOiBjdG9yLFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgfVxuICAgIH0pO1xuICB9O1xufSBlbHNlIHtcbiAgLy8gb2xkIHNjaG9vbCBzaGltIGZvciBvbGQgYnJvd3NlcnNcbiAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpbmhlcml0cyhjdG9yLCBzdXBlckN0b3IpIHtcbiAgICBjdG9yLnN1cGVyXyA9IHN1cGVyQ3RvclxuICAgIHZhciBUZW1wQ3RvciA9IGZ1bmN0aW9uICgpIHt9XG4gICAgVGVtcEN0b3IucHJvdG90eXBlID0gc3VwZXJDdG9yLnByb3RvdHlwZVxuICAgIGN0b3IucHJvdG90eXBlID0gbmV3IFRlbXBDdG9yKClcbiAgICBjdG9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IGN0b3JcbiAgfVxufVxuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbi8vIHJlc29sdmVzIC4gYW5kIC4uIGVsZW1lbnRzIGluIGEgcGF0aCBhcnJheSB3aXRoIGRpcmVjdG9yeSBuYW1lcyB0aGVyZVxuLy8gbXVzdCBiZSBubyBzbGFzaGVzLCBlbXB0eSBlbGVtZW50cywgb3IgZGV2aWNlIG5hbWVzIChjOlxcKSBpbiB0aGUgYXJyYXlcbi8vIChzbyBhbHNvIG5vIGxlYWRpbmcgYW5kIHRyYWlsaW5nIHNsYXNoZXMgLSBpdCBkb2VzIG5vdCBkaXN0aW5ndWlzaFxuLy8gcmVsYXRpdmUgYW5kIGFic29sdXRlIHBhdGhzKVxuZnVuY3Rpb24gbm9ybWFsaXplQXJyYXkocGFydHMsIGFsbG93QWJvdmVSb290KSB7XG4gIC8vIGlmIHRoZSBwYXRoIHRyaWVzIHRvIGdvIGFib3ZlIHRoZSByb290LCBgdXBgIGVuZHMgdXAgPiAwXG4gIHZhciB1cCA9IDA7XG4gIGZvciAodmFyIGkgPSBwYXJ0cy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIHZhciBsYXN0ID0gcGFydHNbaV07XG4gICAgaWYgKGxhc3QgPT09ICcuJykge1xuICAgICAgcGFydHMuc3BsaWNlKGksIDEpO1xuICAgIH0gZWxzZSBpZiAobGFzdCA9PT0gJy4uJykge1xuICAgICAgcGFydHMuc3BsaWNlKGksIDEpO1xuICAgICAgdXArKztcbiAgICB9IGVsc2UgaWYgKHVwKSB7XG4gICAgICBwYXJ0cy5zcGxpY2UoaSwgMSk7XG4gICAgICB1cC0tO1xuICAgIH1cbiAgfVxuXG4gIC8vIGlmIHRoZSBwYXRoIGlzIGFsbG93ZWQgdG8gZ28gYWJvdmUgdGhlIHJvb3QsIHJlc3RvcmUgbGVhZGluZyAuLnNcbiAgaWYgKGFsbG93QWJvdmVSb290KSB7XG4gICAgZm9yICg7IHVwLS07IHVwKSB7XG4gICAgICBwYXJ0cy51bnNoaWZ0KCcuLicpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBwYXJ0cztcbn1cblxuLy8gU3BsaXQgYSBmaWxlbmFtZSBpbnRvIFtyb290LCBkaXIsIGJhc2VuYW1lLCBleHRdLCB1bml4IHZlcnNpb25cbi8vICdyb290JyBpcyBqdXN0IGEgc2xhc2gsIG9yIG5vdGhpbmcuXG52YXIgc3BsaXRQYXRoUmUgPVxuICAgIC9eKFxcLz98KShbXFxzXFxTXSo/KSgoPzpcXC57MSwyfXxbXlxcL10rP3wpKFxcLlteLlxcL10qfCkpKD86W1xcL10qKSQvO1xudmFyIHNwbGl0UGF0aCA9IGZ1bmN0aW9uKGZpbGVuYW1lKSB7XG4gIHJldHVybiBzcGxpdFBhdGhSZS5leGVjKGZpbGVuYW1lKS5zbGljZSgxKTtcbn07XG5cbi8vIHBhdGgucmVzb2x2ZShbZnJvbSAuLi5dLCB0bylcbi8vIHBvc2l4IHZlcnNpb25cbmV4cG9ydHMucmVzb2x2ZSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgcmVzb2x2ZWRQYXRoID0gJycsXG4gICAgICByZXNvbHZlZEFic29sdXRlID0gZmFsc2U7XG5cbiAgZm9yICh2YXIgaSA9IGFyZ3VtZW50cy5sZW5ndGggLSAxOyBpID49IC0xICYmICFyZXNvbHZlZEFic29sdXRlOyBpLS0pIHtcbiAgICB2YXIgcGF0aCA9IChpID49IDApID8gYXJndW1lbnRzW2ldIDogcHJvY2Vzcy5jd2QoKTtcblxuICAgIC8vIFNraXAgZW1wdHkgYW5kIGludmFsaWQgZW50cmllc1xuICAgIGlmICh0eXBlb2YgcGF0aCAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50cyB0byBwYXRoLnJlc29sdmUgbXVzdCBiZSBzdHJpbmdzJyk7XG4gICAgfSBlbHNlIGlmICghcGF0aCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgcmVzb2x2ZWRQYXRoID0gcGF0aCArICcvJyArIHJlc29sdmVkUGF0aDtcbiAgICByZXNvbHZlZEFic29sdXRlID0gcGF0aC5jaGFyQXQoMCkgPT09ICcvJztcbiAgfVxuXG4gIC8vIEF0IHRoaXMgcG9pbnQgdGhlIHBhdGggc2hvdWxkIGJlIHJlc29sdmVkIHRvIGEgZnVsbCBhYnNvbHV0ZSBwYXRoLCBidXRcbiAgLy8gaGFuZGxlIHJlbGF0aXZlIHBhdGhzIHRvIGJlIHNhZmUgKG1pZ2h0IGhhcHBlbiB3aGVuIHByb2Nlc3MuY3dkKCkgZmFpbHMpXG5cbiAgLy8gTm9ybWFsaXplIHRoZSBwYXRoXG4gIHJlc29sdmVkUGF0aCA9IG5vcm1hbGl6ZUFycmF5KGZpbHRlcihyZXNvbHZlZFBhdGguc3BsaXQoJy8nKSwgZnVuY3Rpb24ocCkge1xuICAgIHJldHVybiAhIXA7XG4gIH0pLCAhcmVzb2x2ZWRBYnNvbHV0ZSkuam9pbignLycpO1xuXG4gIHJldHVybiAoKHJlc29sdmVkQWJzb2x1dGUgPyAnLycgOiAnJykgKyByZXNvbHZlZFBhdGgpIHx8ICcuJztcbn07XG5cbi8vIHBhdGgubm9ybWFsaXplKHBhdGgpXG4vLyBwb3NpeCB2ZXJzaW9uXG5leHBvcnRzLm5vcm1hbGl6ZSA9IGZ1bmN0aW9uKHBhdGgpIHtcbiAgdmFyIGlzQWJzb2x1dGUgPSBleHBvcnRzLmlzQWJzb2x1dGUocGF0aCksXG4gICAgICB0cmFpbGluZ1NsYXNoID0gc3Vic3RyKHBhdGgsIC0xKSA9PT0gJy8nO1xuXG4gIC8vIE5vcm1hbGl6ZSB0aGUgcGF0aFxuICBwYXRoID0gbm9ybWFsaXplQXJyYXkoZmlsdGVyKHBhdGguc3BsaXQoJy8nKSwgZnVuY3Rpb24ocCkge1xuICAgIHJldHVybiAhIXA7XG4gIH0pLCAhaXNBYnNvbHV0ZSkuam9pbignLycpO1xuXG4gIGlmICghcGF0aCAmJiAhaXNBYnNvbHV0ZSkge1xuICAgIHBhdGggPSAnLic7XG4gIH1cbiAgaWYgKHBhdGggJiYgdHJhaWxpbmdTbGFzaCkge1xuICAgIHBhdGggKz0gJy8nO1xuICB9XG5cbiAgcmV0dXJuIChpc0Fic29sdXRlID8gJy8nIDogJycpICsgcGF0aDtcbn07XG5cbi8vIHBvc2l4IHZlcnNpb25cbmV4cG9ydHMuaXNBYnNvbHV0ZSA9IGZ1bmN0aW9uKHBhdGgpIHtcbiAgcmV0dXJuIHBhdGguY2hhckF0KDApID09PSAnLyc7XG59O1xuXG4vLyBwb3NpeCB2ZXJzaW9uXG5leHBvcnRzLmpvaW4gPSBmdW5jdGlvbigpIHtcbiAgdmFyIHBhdGhzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKTtcbiAgcmV0dXJuIGV4cG9ydHMubm9ybWFsaXplKGZpbHRlcihwYXRocywgZnVuY3Rpb24ocCwgaW5kZXgpIHtcbiAgICBpZiAodHlwZW9mIHAgIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudHMgdG8gcGF0aC5qb2luIG11c3QgYmUgc3RyaW5ncycpO1xuICAgIH1cbiAgICByZXR1cm4gcDtcbiAgfSkuam9pbignLycpKTtcbn07XG5cblxuLy8gcGF0aC5yZWxhdGl2ZShmcm9tLCB0bylcbi8vIHBvc2l4IHZlcnNpb25cbmV4cG9ydHMucmVsYXRpdmUgPSBmdW5jdGlvbihmcm9tLCB0bykge1xuICBmcm9tID0gZXhwb3J0cy5yZXNvbHZlKGZyb20pLnN1YnN0cigxKTtcbiAgdG8gPSBleHBvcnRzLnJlc29sdmUodG8pLnN1YnN0cigxKTtcblxuICBmdW5jdGlvbiB0cmltKGFycikge1xuICAgIHZhciBzdGFydCA9IDA7XG4gICAgZm9yICg7IHN0YXJ0IDwgYXJyLmxlbmd0aDsgc3RhcnQrKykge1xuICAgICAgaWYgKGFycltzdGFydF0gIT09ICcnKSBicmVhaztcbiAgICB9XG5cbiAgICB2YXIgZW5kID0gYXJyLmxlbmd0aCAtIDE7XG4gICAgZm9yICg7IGVuZCA+PSAwOyBlbmQtLSkge1xuICAgICAgaWYgKGFycltlbmRdICE9PSAnJykgYnJlYWs7XG4gICAgfVxuXG4gICAgaWYgKHN0YXJ0ID4gZW5kKSByZXR1cm4gW107XG4gICAgcmV0dXJuIGFyci5zbGljZShzdGFydCwgZW5kIC0gc3RhcnQgKyAxKTtcbiAgfVxuXG4gIHZhciBmcm9tUGFydHMgPSB0cmltKGZyb20uc3BsaXQoJy8nKSk7XG4gIHZhciB0b1BhcnRzID0gdHJpbSh0by5zcGxpdCgnLycpKTtcblxuICB2YXIgbGVuZ3RoID0gTWF0aC5taW4oZnJvbVBhcnRzLmxlbmd0aCwgdG9QYXJ0cy5sZW5ndGgpO1xuICB2YXIgc2FtZVBhcnRzTGVuZ3RoID0gbGVuZ3RoO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGZyb21QYXJ0c1tpXSAhPT0gdG9QYXJ0c1tpXSkge1xuICAgICAgc2FtZVBhcnRzTGVuZ3RoID0gaTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHZhciBvdXRwdXRQYXJ0cyA9IFtdO1xuICBmb3IgKHZhciBpID0gc2FtZVBhcnRzTGVuZ3RoOyBpIDwgZnJvbVBhcnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgb3V0cHV0UGFydHMucHVzaCgnLi4nKTtcbiAgfVxuXG4gIG91dHB1dFBhcnRzID0gb3V0cHV0UGFydHMuY29uY2F0KHRvUGFydHMuc2xpY2Uoc2FtZVBhcnRzTGVuZ3RoKSk7XG5cbiAgcmV0dXJuIG91dHB1dFBhcnRzLmpvaW4oJy8nKTtcbn07XG5cbmV4cG9ydHMuc2VwID0gJy8nO1xuZXhwb3J0cy5kZWxpbWl0ZXIgPSAnOic7XG5cbmV4cG9ydHMuZGlybmFtZSA9IGZ1bmN0aW9uKHBhdGgpIHtcbiAgdmFyIHJlc3VsdCA9IHNwbGl0UGF0aChwYXRoKSxcbiAgICAgIHJvb3QgPSByZXN1bHRbMF0sXG4gICAgICBkaXIgPSByZXN1bHRbMV07XG5cbiAgaWYgKCFyb290ICYmICFkaXIpIHtcbiAgICAvLyBObyBkaXJuYW1lIHdoYXRzb2V2ZXJcbiAgICByZXR1cm4gJy4nO1xuICB9XG5cbiAgaWYgKGRpcikge1xuICAgIC8vIEl0IGhhcyBhIGRpcm5hbWUsIHN0cmlwIHRyYWlsaW5nIHNsYXNoXG4gICAgZGlyID0gZGlyLnN1YnN0cigwLCBkaXIubGVuZ3RoIC0gMSk7XG4gIH1cblxuICByZXR1cm4gcm9vdCArIGRpcjtcbn07XG5cblxuZXhwb3J0cy5iYXNlbmFtZSA9IGZ1bmN0aW9uKHBhdGgsIGV4dCkge1xuICB2YXIgZiA9IHNwbGl0UGF0aChwYXRoKVsyXTtcbiAgLy8gVE9ETzogbWFrZSB0aGlzIGNvbXBhcmlzb24gY2FzZS1pbnNlbnNpdGl2ZSBvbiB3aW5kb3dzP1xuICBpZiAoZXh0ICYmIGYuc3Vic3RyKC0xICogZXh0Lmxlbmd0aCkgPT09IGV4dCkge1xuICAgIGYgPSBmLnN1YnN0cigwLCBmLmxlbmd0aCAtIGV4dC5sZW5ndGgpO1xuICB9XG4gIHJldHVybiBmO1xufTtcblxuXG5leHBvcnRzLmV4dG5hbWUgPSBmdW5jdGlvbihwYXRoKSB7XG4gIHJldHVybiBzcGxpdFBhdGgocGF0aClbM107XG59O1xuXG5mdW5jdGlvbiBmaWx0ZXIgKHhzLCBmKSB7XG4gICAgaWYgKHhzLmZpbHRlcikgcmV0dXJuIHhzLmZpbHRlcihmKTtcbiAgICB2YXIgcmVzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB4cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoZih4c1tpXSwgaSwgeHMpKSByZXMucHVzaCh4c1tpXSk7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG59XG5cbi8vIFN0cmluZy5wcm90b3R5cGUuc3Vic3RyIC0gbmVnYXRpdmUgaW5kZXggZG9uJ3Qgd29yayBpbiBJRThcbnZhciBzdWJzdHIgPSAnYWInLnN1YnN0cigtMSkgPT09ICdiJ1xuICAgID8gZnVuY3Rpb24gKHN0ciwgc3RhcnQsIGxlbikgeyByZXR1cm4gc3RyLnN1YnN0cihzdGFydCwgbGVuKSB9XG4gICAgOiBmdW5jdGlvbiAoc3RyLCBzdGFydCwgbGVuKSB7XG4gICAgICAgIGlmIChzdGFydCA8IDApIHN0YXJ0ID0gc3RyLmxlbmd0aCArIHN0YXJ0O1xuICAgICAgICByZXR1cm4gc3RyLnN1YnN0cihzdGFydCwgbGVuKTtcbiAgICB9XG47XG4iLCIvLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXJcblxudmFyIHByb2Nlc3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xudmFyIHF1ZXVlID0gW107XG52YXIgZHJhaW5pbmcgPSBmYWxzZTtcbnZhciBjdXJyZW50UXVldWU7XG52YXIgcXVldWVJbmRleCA9IC0xO1xuXG5mdW5jdGlvbiBjbGVhblVwTmV4dFRpY2soKSB7XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBpZiAoY3VycmVudFF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBxdWV1ZSA9IGN1cnJlbnRRdWV1ZS5jb25jYXQocXVldWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICB9XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBkcmFpblF1ZXVlKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkcmFpblF1ZXVlKCkge1xuICAgIGlmIChkcmFpbmluZykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB0aW1lb3V0ID0gc2V0VGltZW91dChjbGVhblVwTmV4dFRpY2spO1xuICAgIGRyYWluaW5nID0gdHJ1ZTtcblxuICAgIHZhciBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgd2hpbGUobGVuKSB7XG4gICAgICAgIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xuICAgICAgICBxdWV1ZSA9IFtdO1xuICAgICAgICB3aGlsZSAoKytxdWV1ZUluZGV4IDwgbGVuKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudFF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFF1ZXVlW3F1ZXVlSW5kZXhdLnJ1bigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICAgICAgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIH1cbiAgICBjdXJyZW50UXVldWUgPSBudWxsO1xuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xufVxuXG5wcm9jZXNzLm5leHRUaWNrID0gZnVuY3Rpb24gKGZ1bikge1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHF1ZXVlLnB1c2gobmV3IEl0ZW0oZnVuLCBhcmdzKSk7XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMSAmJiAhZHJhaW5pbmcpIHtcbiAgICAgICAgc2V0VGltZW91dChkcmFpblF1ZXVlLCAwKTtcbiAgICB9XG59O1xuXG4vLyB2OCBsaWtlcyBwcmVkaWN0aWJsZSBvYmplY3RzXG5mdW5jdGlvbiBJdGVtKGZ1biwgYXJyYXkpIHtcbiAgICB0aGlzLmZ1biA9IGZ1bjtcbiAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG59XG5JdGVtLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5mdW4uYXBwbHkobnVsbCwgdGhpcy5hcnJheSk7XG59O1xucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XG5wcm9jZXNzLmVudiA9IHt9O1xucHJvY2Vzcy5hcmd2ID0gW107XG5wcm9jZXNzLnZlcnNpb24gPSAnJzsgLy8gZW1wdHkgc3RyaW5nIHRvIGF2b2lkIHJlZ2V4cCBpc3N1ZXNcbnByb2Nlc3MudmVyc2lvbnMgPSB7fTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnByb2Nlc3Mub24gPSBub29wO1xucHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLm9uY2UgPSBub29wO1xucHJvY2Vzcy5vZmYgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XG5wcm9jZXNzLmVtaXQgPSBub29wO1xuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5cbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xucHJvY2Vzcy51bWFzayA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNCdWZmZXIoYXJnKSB7XG4gIHJldHVybiBhcmcgJiYgdHlwZW9mIGFyZyA9PT0gJ29iamVjdCdcbiAgICAmJiB0eXBlb2YgYXJnLmNvcHkgPT09ICdmdW5jdGlvbidcbiAgICAmJiB0eXBlb2YgYXJnLmZpbGwgPT09ICdmdW5jdGlvbidcbiAgICAmJiB0eXBlb2YgYXJnLnJlYWRVSW50OCA9PT0gJ2Z1bmN0aW9uJztcbn0iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxudmFyIGZvcm1hdFJlZ0V4cCA9IC8lW3NkaiVdL2c7XG5leHBvcnRzLmZvcm1hdCA9IGZ1bmN0aW9uKGYpIHtcbiAgaWYgKCFpc1N0cmluZyhmKSkge1xuICAgIHZhciBvYmplY3RzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIG9iamVjdHMucHVzaChpbnNwZWN0KGFyZ3VtZW50c1tpXSkpO1xuICAgIH1cbiAgICByZXR1cm4gb2JqZWN0cy5qb2luKCcgJyk7XG4gIH1cblxuICB2YXIgaSA9IDE7XG4gIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICB2YXIgbGVuID0gYXJncy5sZW5ndGg7XG4gIHZhciBzdHIgPSBTdHJpbmcoZikucmVwbGFjZShmb3JtYXRSZWdFeHAsIGZ1bmN0aW9uKHgpIHtcbiAgICBpZiAoeCA9PT0gJyUlJykgcmV0dXJuICclJztcbiAgICBpZiAoaSA+PSBsZW4pIHJldHVybiB4O1xuICAgIHN3aXRjaCAoeCkge1xuICAgICAgY2FzZSAnJXMnOiByZXR1cm4gU3RyaW5nKGFyZ3NbaSsrXSk7XG4gICAgICBjYXNlICclZCc6IHJldHVybiBOdW1iZXIoYXJnc1tpKytdKTtcbiAgICAgIGNhc2UgJyVqJzpcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoYXJnc1tpKytdKTtcbiAgICAgICAgfSBjYXRjaCAoXykge1xuICAgICAgICAgIHJldHVybiAnW0NpcmN1bGFyXSc7XG4gICAgICAgIH1cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiB4O1xuICAgIH1cbiAgfSk7XG4gIGZvciAodmFyIHggPSBhcmdzW2ldOyBpIDwgbGVuOyB4ID0gYXJnc1srK2ldKSB7XG4gICAgaWYgKGlzTnVsbCh4KSB8fCAhaXNPYmplY3QoeCkpIHtcbiAgICAgIHN0ciArPSAnICcgKyB4O1xuICAgIH0gZWxzZSB7XG4gICAgICBzdHIgKz0gJyAnICsgaW5zcGVjdCh4KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHN0cjtcbn07XG5cblxuLy8gTWFyayB0aGF0IGEgbWV0aG9kIHNob3VsZCBub3QgYmUgdXNlZC5cbi8vIFJldHVybnMgYSBtb2RpZmllZCBmdW5jdGlvbiB3aGljaCB3YXJucyBvbmNlIGJ5IGRlZmF1bHQuXG4vLyBJZiAtLW5vLWRlcHJlY2F0aW9uIGlzIHNldCwgdGhlbiBpdCBpcyBhIG5vLW9wLlxuZXhwb3J0cy5kZXByZWNhdGUgPSBmdW5jdGlvbihmbiwgbXNnKSB7XG4gIC8vIEFsbG93IGZvciBkZXByZWNhdGluZyB0aGluZ3MgaW4gdGhlIHByb2Nlc3Mgb2Ygc3RhcnRpbmcgdXAuXG4gIGlmIChpc1VuZGVmaW5lZChnbG9iYWwucHJvY2VzcykpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZXhwb3J0cy5kZXByZWNhdGUoZm4sIG1zZykuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9O1xuICB9XG5cbiAgaWYgKHByb2Nlc3Mubm9EZXByZWNhdGlvbiA9PT0gdHJ1ZSkge1xuICAgIHJldHVybiBmbjtcbiAgfVxuXG4gIHZhciB3YXJuZWQgPSBmYWxzZTtcbiAgZnVuY3Rpb24gZGVwcmVjYXRlZCgpIHtcbiAgICBpZiAoIXdhcm5lZCkge1xuICAgICAgaWYgKHByb2Nlc3MudGhyb3dEZXByZWNhdGlvbikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbiAgICAgIH0gZWxzZSBpZiAocHJvY2Vzcy50cmFjZURlcHJlY2F0aW9uKSB7XG4gICAgICAgIGNvbnNvbGUudHJhY2UobXNnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IobXNnKTtcbiAgICAgIH1cbiAgICAgIHdhcm5lZCA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgcmV0dXJuIGRlcHJlY2F0ZWQ7XG59O1xuXG5cbnZhciBkZWJ1Z3MgPSB7fTtcbnZhciBkZWJ1Z0Vudmlyb247XG5leHBvcnRzLmRlYnVnbG9nID0gZnVuY3Rpb24oc2V0KSB7XG4gIGlmIChpc1VuZGVmaW5lZChkZWJ1Z0Vudmlyb24pKVxuICAgIGRlYnVnRW52aXJvbiA9IHByb2Nlc3MuZW52Lk5PREVfREVCVUcgfHwgJyc7XG4gIHNldCA9IHNldC50b1VwcGVyQ2FzZSgpO1xuICBpZiAoIWRlYnVnc1tzZXRdKSB7XG4gICAgaWYgKG5ldyBSZWdFeHAoJ1xcXFxiJyArIHNldCArICdcXFxcYicsICdpJykudGVzdChkZWJ1Z0Vudmlyb24pKSB7XG4gICAgICB2YXIgcGlkID0gcHJvY2Vzcy5waWQ7XG4gICAgICBkZWJ1Z3Nbc2V0XSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgbXNnID0gZXhwb3J0cy5mb3JtYXQuYXBwbHkoZXhwb3J0cywgYXJndW1lbnRzKTtcbiAgICAgICAgY29uc29sZS5lcnJvcignJXMgJWQ6ICVzJywgc2V0LCBwaWQsIG1zZyk7XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWJ1Z3Nbc2V0XSA9IGZ1bmN0aW9uKCkge307XG4gICAgfVxuICB9XG4gIHJldHVybiBkZWJ1Z3Nbc2V0XTtcbn07XG5cblxuLyoqXG4gKiBFY2hvcyB0aGUgdmFsdWUgb2YgYSB2YWx1ZS4gVHJ5cyB0byBwcmludCB0aGUgdmFsdWUgb3V0XG4gKiBpbiB0aGUgYmVzdCB3YXkgcG9zc2libGUgZ2l2ZW4gdGhlIGRpZmZlcmVudCB0eXBlcy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqIFRoZSBvYmplY3QgdG8gcHJpbnQgb3V0LlxuICogQHBhcmFtIHtPYmplY3R9IG9wdHMgT3B0aW9uYWwgb3B0aW9ucyBvYmplY3QgdGhhdCBhbHRlcnMgdGhlIG91dHB1dC5cbiAqL1xuLyogbGVnYWN5OiBvYmosIHNob3dIaWRkZW4sIGRlcHRoLCBjb2xvcnMqL1xuZnVuY3Rpb24gaW5zcGVjdChvYmosIG9wdHMpIHtcbiAgLy8gZGVmYXVsdCBvcHRpb25zXG4gIHZhciBjdHggPSB7XG4gICAgc2VlbjogW10sXG4gICAgc3R5bGl6ZTogc3R5bGl6ZU5vQ29sb3JcbiAgfTtcbiAgLy8gbGVnYWN5Li4uXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID49IDMpIGN0eC5kZXB0aCA9IGFyZ3VtZW50c1syXTtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPj0gNCkgY3R4LmNvbG9ycyA9IGFyZ3VtZW50c1szXTtcbiAgaWYgKGlzQm9vbGVhbihvcHRzKSkge1xuICAgIC8vIGxlZ2FjeS4uLlxuICAgIGN0eC5zaG93SGlkZGVuID0gb3B0cztcbiAgfSBlbHNlIGlmIChvcHRzKSB7XG4gICAgLy8gZ290IGFuIFwib3B0aW9uc1wiIG9iamVjdFxuICAgIGV4cG9ydHMuX2V4dGVuZChjdHgsIG9wdHMpO1xuICB9XG4gIC8vIHNldCBkZWZhdWx0IG9wdGlvbnNcbiAgaWYgKGlzVW5kZWZpbmVkKGN0eC5zaG93SGlkZGVuKSkgY3R4LnNob3dIaWRkZW4gPSBmYWxzZTtcbiAgaWYgKGlzVW5kZWZpbmVkKGN0eC5kZXB0aCkpIGN0eC5kZXB0aCA9IDI7XG4gIGlmIChpc1VuZGVmaW5lZChjdHguY29sb3JzKSkgY3R4LmNvbG9ycyA9IGZhbHNlO1xuICBpZiAoaXNVbmRlZmluZWQoY3R4LmN1c3RvbUluc3BlY3QpKSBjdHguY3VzdG9tSW5zcGVjdCA9IHRydWU7XG4gIGlmIChjdHguY29sb3JzKSBjdHguc3R5bGl6ZSA9IHN0eWxpemVXaXRoQ29sb3I7XG4gIHJldHVybiBmb3JtYXRWYWx1ZShjdHgsIG9iaiwgY3R4LmRlcHRoKTtcbn1cbmV4cG9ydHMuaW5zcGVjdCA9IGluc3BlY3Q7XG5cblxuLy8gaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9BTlNJX2VzY2FwZV9jb2RlI2dyYXBoaWNzXG5pbnNwZWN0LmNvbG9ycyA9IHtcbiAgJ2JvbGQnIDogWzEsIDIyXSxcbiAgJ2l0YWxpYycgOiBbMywgMjNdLFxuICAndW5kZXJsaW5lJyA6IFs0LCAyNF0sXG4gICdpbnZlcnNlJyA6IFs3LCAyN10sXG4gICd3aGl0ZScgOiBbMzcsIDM5XSxcbiAgJ2dyZXknIDogWzkwLCAzOV0sXG4gICdibGFjaycgOiBbMzAsIDM5XSxcbiAgJ2JsdWUnIDogWzM0LCAzOV0sXG4gICdjeWFuJyA6IFszNiwgMzldLFxuICAnZ3JlZW4nIDogWzMyLCAzOV0sXG4gICdtYWdlbnRhJyA6IFszNSwgMzldLFxuICAncmVkJyA6IFszMSwgMzldLFxuICAneWVsbG93JyA6IFszMywgMzldXG59O1xuXG4vLyBEb24ndCB1c2UgJ2JsdWUnIG5vdCB2aXNpYmxlIG9uIGNtZC5leGVcbmluc3BlY3Quc3R5bGVzID0ge1xuICAnc3BlY2lhbCc6ICdjeWFuJyxcbiAgJ251bWJlcic6ICd5ZWxsb3cnLFxuICAnYm9vbGVhbic6ICd5ZWxsb3cnLFxuICAndW5kZWZpbmVkJzogJ2dyZXknLFxuICAnbnVsbCc6ICdib2xkJyxcbiAgJ3N0cmluZyc6ICdncmVlbicsXG4gICdkYXRlJzogJ21hZ2VudGEnLFxuICAvLyBcIm5hbWVcIjogaW50ZW50aW9uYWxseSBub3Qgc3R5bGluZ1xuICAncmVnZXhwJzogJ3JlZCdcbn07XG5cblxuZnVuY3Rpb24gc3R5bGl6ZVdpdGhDb2xvcihzdHIsIHN0eWxlVHlwZSkge1xuICB2YXIgc3R5bGUgPSBpbnNwZWN0LnN0eWxlc1tzdHlsZVR5cGVdO1xuXG4gIGlmIChzdHlsZSkge1xuICAgIHJldHVybiAnXFx1MDAxYlsnICsgaW5zcGVjdC5jb2xvcnNbc3R5bGVdWzBdICsgJ20nICsgc3RyICtcbiAgICAgICAgICAgJ1xcdTAwMWJbJyArIGluc3BlY3QuY29sb3JzW3N0eWxlXVsxXSArICdtJztcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gc3RyO1xuICB9XG59XG5cblxuZnVuY3Rpb24gc3R5bGl6ZU5vQ29sb3Ioc3RyLCBzdHlsZVR5cGUpIHtcbiAgcmV0dXJuIHN0cjtcbn1cblxuXG5mdW5jdGlvbiBhcnJheVRvSGFzaChhcnJheSkge1xuICB2YXIgaGFzaCA9IHt9O1xuXG4gIGFycmF5LmZvckVhY2goZnVuY3Rpb24odmFsLCBpZHgpIHtcbiAgICBoYXNoW3ZhbF0gPSB0cnVlO1xuICB9KTtcblxuICByZXR1cm4gaGFzaDtcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRWYWx1ZShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMpIHtcbiAgLy8gUHJvdmlkZSBhIGhvb2sgZm9yIHVzZXItc3BlY2lmaWVkIGluc3BlY3QgZnVuY3Rpb25zLlxuICAvLyBDaGVjayB0aGF0IHZhbHVlIGlzIGFuIG9iamVjdCB3aXRoIGFuIGluc3BlY3QgZnVuY3Rpb24gb24gaXRcbiAgaWYgKGN0eC5jdXN0b21JbnNwZWN0ICYmXG4gICAgICB2YWx1ZSAmJlxuICAgICAgaXNGdW5jdGlvbih2YWx1ZS5pbnNwZWN0KSAmJlxuICAgICAgLy8gRmlsdGVyIG91dCB0aGUgdXRpbCBtb2R1bGUsIGl0J3MgaW5zcGVjdCBmdW5jdGlvbiBpcyBzcGVjaWFsXG4gICAgICB2YWx1ZS5pbnNwZWN0ICE9PSBleHBvcnRzLmluc3BlY3QgJiZcbiAgICAgIC8vIEFsc28gZmlsdGVyIG91dCBhbnkgcHJvdG90eXBlIG9iamVjdHMgdXNpbmcgdGhlIGNpcmN1bGFyIGNoZWNrLlxuICAgICAgISh2YWx1ZS5jb25zdHJ1Y3RvciAmJiB2YWx1ZS5jb25zdHJ1Y3Rvci5wcm90b3R5cGUgPT09IHZhbHVlKSkge1xuICAgIHZhciByZXQgPSB2YWx1ZS5pbnNwZWN0KHJlY3Vyc2VUaW1lcywgY3R4KTtcbiAgICBpZiAoIWlzU3RyaW5nKHJldCkpIHtcbiAgICAgIHJldCA9IGZvcm1hdFZhbHVlKGN0eCwgcmV0LCByZWN1cnNlVGltZXMpO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xuICB9XG5cbiAgLy8gUHJpbWl0aXZlIHR5cGVzIGNhbm5vdCBoYXZlIHByb3BlcnRpZXNcbiAgdmFyIHByaW1pdGl2ZSA9IGZvcm1hdFByaW1pdGl2ZShjdHgsIHZhbHVlKTtcbiAgaWYgKHByaW1pdGl2ZSkge1xuICAgIHJldHVybiBwcmltaXRpdmU7XG4gIH1cblxuICAvLyBMb29rIHVwIHRoZSBrZXlzIG9mIHRoZSBvYmplY3QuXG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXModmFsdWUpO1xuICB2YXIgdmlzaWJsZUtleXMgPSBhcnJheVRvSGFzaChrZXlzKTtcblxuICBpZiAoY3R4LnNob3dIaWRkZW4pIHtcbiAgICBrZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModmFsdWUpO1xuICB9XG5cbiAgLy8gSUUgZG9lc24ndCBtYWtlIGVycm9yIGZpZWxkcyBub24tZW51bWVyYWJsZVxuICAvLyBodHRwOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvaWUvZHd3NTJzYnQodj12cy45NCkuYXNweFxuICBpZiAoaXNFcnJvcih2YWx1ZSlcbiAgICAgICYmIChrZXlzLmluZGV4T2YoJ21lc3NhZ2UnKSA+PSAwIHx8IGtleXMuaW5kZXhPZignZGVzY3JpcHRpb24nKSA+PSAwKSkge1xuICAgIHJldHVybiBmb3JtYXRFcnJvcih2YWx1ZSk7XG4gIH1cblxuICAvLyBTb21lIHR5cGUgb2Ygb2JqZWN0IHdpdGhvdXQgcHJvcGVydGllcyBjYW4gYmUgc2hvcnRjdXR0ZWQuXG4gIGlmIChrZXlzLmxlbmd0aCA9PT0gMCkge1xuICAgIGlmIChpc0Z1bmN0aW9uKHZhbHVlKSkge1xuICAgICAgdmFyIG5hbWUgPSB2YWx1ZS5uYW1lID8gJzogJyArIHZhbHVlLm5hbWUgOiAnJztcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZSgnW0Z1bmN0aW9uJyArIG5hbWUgKyAnXScsICdzcGVjaWFsJyk7XG4gICAgfVxuICAgIGlmIChpc1JlZ0V4cCh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZShSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLCAncmVnZXhwJyk7XG4gICAgfVxuICAgIGlmIChpc0RhdGUodmFsdWUpKSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoRGF0ZS5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSksICdkYXRlJyk7XG4gICAgfVxuICAgIGlmIChpc0Vycm9yKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGZvcm1hdEVycm9yKHZhbHVlKTtcbiAgICB9XG4gIH1cblxuICB2YXIgYmFzZSA9ICcnLCBhcnJheSA9IGZhbHNlLCBicmFjZXMgPSBbJ3snLCAnfSddO1xuXG4gIC8vIE1ha2UgQXJyYXkgc2F5IHRoYXQgdGhleSBhcmUgQXJyYXlcbiAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgYXJyYXkgPSB0cnVlO1xuICAgIGJyYWNlcyA9IFsnWycsICddJ107XG4gIH1cblxuICAvLyBNYWtlIGZ1bmN0aW9ucyBzYXkgdGhhdCB0aGV5IGFyZSBmdW5jdGlvbnNcbiAgaWYgKGlzRnVuY3Rpb24odmFsdWUpKSB7XG4gICAgdmFyIG4gPSB2YWx1ZS5uYW1lID8gJzogJyArIHZhbHVlLm5hbWUgOiAnJztcbiAgICBiYXNlID0gJyBbRnVuY3Rpb24nICsgbiArICddJztcbiAgfVxuXG4gIC8vIE1ha2UgUmVnRXhwcyBzYXkgdGhhdCB0aGV5IGFyZSBSZWdFeHBzXG4gIGlmIChpc1JlZ0V4cCh2YWx1ZSkpIHtcbiAgICBiYXNlID0gJyAnICsgUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKTtcbiAgfVxuXG4gIC8vIE1ha2UgZGF0ZXMgd2l0aCBwcm9wZXJ0aWVzIGZpcnN0IHNheSB0aGUgZGF0ZVxuICBpZiAoaXNEYXRlKHZhbHVlKSkge1xuICAgIGJhc2UgPSAnICcgKyBEYXRlLnByb3RvdHlwZS50b1VUQ1N0cmluZy5jYWxsKHZhbHVlKTtcbiAgfVxuXG4gIC8vIE1ha2UgZXJyb3Igd2l0aCBtZXNzYWdlIGZpcnN0IHNheSB0aGUgZXJyb3JcbiAgaWYgKGlzRXJyb3IodmFsdWUpKSB7XG4gICAgYmFzZSA9ICcgJyArIGZvcm1hdEVycm9yKHZhbHVlKTtcbiAgfVxuXG4gIGlmIChrZXlzLmxlbmd0aCA9PT0gMCAmJiAoIWFycmF5IHx8IHZhbHVlLmxlbmd0aCA9PSAwKSkge1xuICAgIHJldHVybiBicmFjZXNbMF0gKyBiYXNlICsgYnJhY2VzWzFdO1xuICB9XG5cbiAgaWYgKHJlY3Vyc2VUaW1lcyA8IDApIHtcbiAgICBpZiAoaXNSZWdFeHAodmFsdWUpKSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSwgJ3JlZ2V4cCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoJ1tPYmplY3RdJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gIH1cblxuICBjdHguc2Vlbi5wdXNoKHZhbHVlKTtcblxuICB2YXIgb3V0cHV0O1xuICBpZiAoYXJyYXkpIHtcbiAgICBvdXRwdXQgPSBmb3JtYXRBcnJheShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXlzKTtcbiAgfSBlbHNlIHtcbiAgICBvdXRwdXQgPSBrZXlzLm1hcChmdW5jdGlvbihrZXkpIHtcbiAgICAgIHJldHVybiBmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXksIGFycmF5KTtcbiAgICB9KTtcbiAgfVxuXG4gIGN0eC5zZWVuLnBvcCgpO1xuXG4gIHJldHVybiByZWR1Y2VUb1NpbmdsZVN0cmluZyhvdXRwdXQsIGJhc2UsIGJyYWNlcyk7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0UHJpbWl0aXZlKGN0eCwgdmFsdWUpIHtcbiAgaWYgKGlzVW5kZWZpbmVkKHZhbHVlKSlcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoJ3VuZGVmaW5lZCcsICd1bmRlZmluZWQnKTtcbiAgaWYgKGlzU3RyaW5nKHZhbHVlKSkge1xuICAgIHZhciBzaW1wbGUgPSAnXFwnJyArIEpTT04uc3RyaW5naWZ5KHZhbHVlKS5yZXBsYWNlKC9eXCJ8XCIkL2csICcnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoLycvZywgXCJcXFxcJ1wiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcXFxcIi9nLCAnXCInKSArICdcXCcnO1xuICAgIHJldHVybiBjdHguc3R5bGl6ZShzaW1wbGUsICdzdHJpbmcnKTtcbiAgfVxuICBpZiAoaXNOdW1iZXIodmFsdWUpKVxuICAgIHJldHVybiBjdHguc3R5bGl6ZSgnJyArIHZhbHVlLCAnbnVtYmVyJyk7XG4gIGlmIChpc0Jvb2xlYW4odmFsdWUpKVxuICAgIHJldHVybiBjdHguc3R5bGl6ZSgnJyArIHZhbHVlLCAnYm9vbGVhbicpO1xuICAvLyBGb3Igc29tZSByZWFzb24gdHlwZW9mIG51bGwgaXMgXCJvYmplY3RcIiwgc28gc3BlY2lhbCBjYXNlIGhlcmUuXG4gIGlmIChpc051bGwodmFsdWUpKVxuICAgIHJldHVybiBjdHguc3R5bGl6ZSgnbnVsbCcsICdudWxsJyk7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0RXJyb3IodmFsdWUpIHtcbiAgcmV0dXJuICdbJyArIEVycm9yLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSArICddJztcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRBcnJheShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXlzKSB7XG4gIHZhciBvdXRwdXQgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSB2YWx1ZS5sZW5ndGg7IGkgPCBsOyArK2kpIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkodmFsdWUsIFN0cmluZyhpKSkpIHtcbiAgICAgIG91dHB1dC5wdXNoKGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsXG4gICAgICAgICAgU3RyaW5nKGkpLCB0cnVlKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG91dHB1dC5wdXNoKCcnKTtcbiAgICB9XG4gIH1cbiAga2V5cy5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgIGlmICgha2V5Lm1hdGNoKC9eXFxkKyQvKSkge1xuICAgICAgb3V0cHV0LnB1c2goZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cyxcbiAgICAgICAgICBrZXksIHRydWUpKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gb3V0cHV0O1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsIGtleSwgYXJyYXkpIHtcbiAgdmFyIG5hbWUsIHN0ciwgZGVzYztcbiAgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodmFsdWUsIGtleSkgfHwgeyB2YWx1ZTogdmFsdWVba2V5XSB9O1xuICBpZiAoZGVzYy5nZXQpIHtcbiAgICBpZiAoZGVzYy5zZXQpIHtcbiAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbR2V0dGVyL1NldHRlcl0nLCAnc3BlY2lhbCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW0dldHRlcl0nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoZGVzYy5zZXQpIHtcbiAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbU2V0dGVyXScsICdzcGVjaWFsJyk7XG4gICAgfVxuICB9XG4gIGlmICghaGFzT3duUHJvcGVydHkodmlzaWJsZUtleXMsIGtleSkpIHtcbiAgICBuYW1lID0gJ1snICsga2V5ICsgJ10nO1xuICB9XG4gIGlmICghc3RyKSB7XG4gICAgaWYgKGN0eC5zZWVuLmluZGV4T2YoZGVzYy52YWx1ZSkgPCAwKSB7XG4gICAgICBpZiAoaXNOdWxsKHJlY3Vyc2VUaW1lcykpIHtcbiAgICAgICAgc3RyID0gZm9ybWF0VmFsdWUoY3R4LCBkZXNjLnZhbHVlLCBudWxsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0ciA9IGZvcm1hdFZhbHVlKGN0eCwgZGVzYy52YWx1ZSwgcmVjdXJzZVRpbWVzIC0gMSk7XG4gICAgICB9XG4gICAgICBpZiAoc3RyLmluZGV4T2YoJ1xcbicpID4gLTEpIHtcbiAgICAgICAgaWYgKGFycmF5KSB7XG4gICAgICAgICAgc3RyID0gc3RyLnNwbGl0KCdcXG4nKS5tYXAoZnVuY3Rpb24obGluZSkge1xuICAgICAgICAgICAgcmV0dXJuICcgICcgKyBsaW5lO1xuICAgICAgICAgIH0pLmpvaW4oJ1xcbicpLnN1YnN0cigyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdHIgPSAnXFxuJyArIHN0ci5zcGxpdCgnXFxuJykubWFwKGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgICAgICAgIHJldHVybiAnICAgJyArIGxpbmU7XG4gICAgICAgICAgfSkuam9pbignXFxuJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc3RyID0gY3R4LnN0eWxpemUoJ1tDaXJjdWxhcl0nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgfVxuICBpZiAoaXNVbmRlZmluZWQobmFtZSkpIHtcbiAgICBpZiAoYXJyYXkgJiYga2V5Lm1hdGNoKC9eXFxkKyQvKSkge1xuICAgICAgcmV0dXJuIHN0cjtcbiAgICB9XG4gICAgbmFtZSA9IEpTT04uc3RyaW5naWZ5KCcnICsga2V5KTtcbiAgICBpZiAobmFtZS5tYXRjaCgvXlwiKFthLXpBLVpfXVthLXpBLVpfMC05XSopXCIkLykpIHtcbiAgICAgIG5hbWUgPSBuYW1lLnN1YnN0cigxLCBuYW1lLmxlbmd0aCAtIDIpO1xuICAgICAgbmFtZSA9IGN0eC5zdHlsaXplKG5hbWUsICduYW1lJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5hbWUgPSBuYW1lLnJlcGxhY2UoLycvZywgXCJcXFxcJ1wiKVxuICAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFxcXFwiL2csICdcIicpXG4gICAgICAgICAgICAgICAgIC5yZXBsYWNlKC8oXlwifFwiJCkvZywgXCInXCIpO1xuICAgICAgbmFtZSA9IGN0eC5zdHlsaXplKG5hbWUsICdzdHJpbmcnKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmFtZSArICc6ICcgKyBzdHI7XG59XG5cblxuZnVuY3Rpb24gcmVkdWNlVG9TaW5nbGVTdHJpbmcob3V0cHV0LCBiYXNlLCBicmFjZXMpIHtcbiAgdmFyIG51bUxpbmVzRXN0ID0gMDtcbiAgdmFyIGxlbmd0aCA9IG91dHB1dC5yZWR1Y2UoZnVuY3Rpb24ocHJldiwgY3VyKSB7XG4gICAgbnVtTGluZXNFc3QrKztcbiAgICBpZiAoY3VyLmluZGV4T2YoJ1xcbicpID49IDApIG51bUxpbmVzRXN0Kys7XG4gICAgcmV0dXJuIHByZXYgKyBjdXIucmVwbGFjZSgvXFx1MDAxYlxcW1xcZFxcZD9tL2csICcnKS5sZW5ndGggKyAxO1xuICB9LCAwKTtcblxuICBpZiAobGVuZ3RoID4gNjApIHtcbiAgICByZXR1cm4gYnJhY2VzWzBdICtcbiAgICAgICAgICAgKGJhc2UgPT09ICcnID8gJycgOiBiYXNlICsgJ1xcbiAnKSArXG4gICAgICAgICAgICcgJyArXG4gICAgICAgICAgIG91dHB1dC5qb2luKCcsXFxuICAnKSArXG4gICAgICAgICAgICcgJyArXG4gICAgICAgICAgIGJyYWNlc1sxXTtcbiAgfVxuXG4gIHJldHVybiBicmFjZXNbMF0gKyBiYXNlICsgJyAnICsgb3V0cHV0LmpvaW4oJywgJykgKyAnICcgKyBicmFjZXNbMV07XG59XG5cblxuLy8gTk9URTogVGhlc2UgdHlwZSBjaGVja2luZyBmdW5jdGlvbnMgaW50ZW50aW9uYWxseSBkb24ndCB1c2UgYGluc3RhbmNlb2ZgXG4vLyBiZWNhdXNlIGl0IGlzIGZyYWdpbGUgYW5kIGNhbiBiZSBlYXNpbHkgZmFrZWQgd2l0aCBgT2JqZWN0LmNyZWF0ZSgpYC5cbmZ1bmN0aW9uIGlzQXJyYXkoYXIpIHtcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkoYXIpO1xufVxuZXhwb3J0cy5pc0FycmF5ID0gaXNBcnJheTtcblxuZnVuY3Rpb24gaXNCb29sZWFuKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Jvb2xlYW4nO1xufVxuZXhwb3J0cy5pc0Jvb2xlYW4gPSBpc0Jvb2xlYW47XG5cbmZ1bmN0aW9uIGlzTnVsbChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNOdWxsID0gaXNOdWxsO1xuXG5mdW5jdGlvbiBpc051bGxPclVuZGVmaW5lZChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PSBudWxsO1xufVxuZXhwb3J0cy5pc051bGxPclVuZGVmaW5lZCA9IGlzTnVsbE9yVW5kZWZpbmVkO1xuXG5mdW5jdGlvbiBpc051bWJlcihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdudW1iZXInO1xufVxuZXhwb3J0cy5pc051bWJlciA9IGlzTnVtYmVyO1xuXG5mdW5jdGlvbiBpc1N0cmluZyhhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnO1xufVxuZXhwb3J0cy5pc1N0cmluZyA9IGlzU3RyaW5nO1xuXG5mdW5jdGlvbiBpc1N5bWJvbChhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdzeW1ib2wnO1xufVxuZXhwb3J0cy5pc1N5bWJvbCA9IGlzU3ltYm9sO1xuXG5mdW5jdGlvbiBpc1VuZGVmaW5lZChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gdm9pZCAwO1xufVxuZXhwb3J0cy5pc1VuZGVmaW5lZCA9IGlzVW5kZWZpbmVkO1xuXG5mdW5jdGlvbiBpc1JlZ0V4cChyZSkge1xuICByZXR1cm4gaXNPYmplY3QocmUpICYmIG9iamVjdFRvU3RyaW5nKHJlKSA9PT0gJ1tvYmplY3QgUmVnRXhwXSc7XG59XG5leHBvcnRzLmlzUmVnRXhwID0gaXNSZWdFeHA7XG5cbmZ1bmN0aW9uIGlzT2JqZWN0KGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ29iamVjdCcgJiYgYXJnICE9PSBudWxsO1xufVxuZXhwb3J0cy5pc09iamVjdCA9IGlzT2JqZWN0O1xuXG5mdW5jdGlvbiBpc0RhdGUoZCkge1xuICByZXR1cm4gaXNPYmplY3QoZCkgJiYgb2JqZWN0VG9TdHJpbmcoZCkgPT09ICdbb2JqZWN0IERhdGVdJztcbn1cbmV4cG9ydHMuaXNEYXRlID0gaXNEYXRlO1xuXG5mdW5jdGlvbiBpc0Vycm9yKGUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KGUpICYmXG4gICAgICAob2JqZWN0VG9TdHJpbmcoZSkgPT09ICdbb2JqZWN0IEVycm9yXScgfHwgZSBpbnN0YW5jZW9mIEVycm9yKTtcbn1cbmV4cG9ydHMuaXNFcnJvciA9IGlzRXJyb3I7XG5cbmZ1bmN0aW9uIGlzRnVuY3Rpb24oYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnZnVuY3Rpb24nO1xufVxuZXhwb3J0cy5pc0Z1bmN0aW9uID0gaXNGdW5jdGlvbjtcblxuZnVuY3Rpb24gaXNQcmltaXRpdmUoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IG51bGwgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdib29sZWFuJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ251bWJlcicgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnc3ltYm9sJyB8fCAgLy8gRVM2IHN5bWJvbFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3VuZGVmaW5lZCc7XG59XG5leHBvcnRzLmlzUHJpbWl0aXZlID0gaXNQcmltaXRpdmU7XG5cbmV4cG9ydHMuaXNCdWZmZXIgPSByZXF1aXJlKCcuL3N1cHBvcnQvaXNCdWZmZXInKTtcblxuZnVuY3Rpb24gb2JqZWN0VG9TdHJpbmcobykge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pO1xufVxuXG5cbmZ1bmN0aW9uIHBhZChuKSB7XG4gIHJldHVybiBuIDwgMTAgPyAnMCcgKyBuLnRvU3RyaW5nKDEwKSA6IG4udG9TdHJpbmcoMTApO1xufVxuXG5cbnZhciBtb250aHMgPSBbJ0phbicsICdGZWInLCAnTWFyJywgJ0FwcicsICdNYXknLCAnSnVuJywgJ0p1bCcsICdBdWcnLCAnU2VwJyxcbiAgICAgICAgICAgICAgJ09jdCcsICdOb3YnLCAnRGVjJ107XG5cbi8vIDI2IEZlYiAxNjoxOTozNFxuZnVuY3Rpb24gdGltZXN0YW1wKCkge1xuICB2YXIgZCA9IG5ldyBEYXRlKCk7XG4gIHZhciB0aW1lID0gW3BhZChkLmdldEhvdXJzKCkpLFxuICAgICAgICAgICAgICBwYWQoZC5nZXRNaW51dGVzKCkpLFxuICAgICAgICAgICAgICBwYWQoZC5nZXRTZWNvbmRzKCkpXS5qb2luKCc6Jyk7XG4gIHJldHVybiBbZC5nZXREYXRlKCksIG1vbnRoc1tkLmdldE1vbnRoKCldLCB0aW1lXS5qb2luKCcgJyk7XG59XG5cblxuLy8gbG9nIGlzIGp1c3QgYSB0aGluIHdyYXBwZXIgdG8gY29uc29sZS5sb2cgdGhhdCBwcmVwZW5kcyBhIHRpbWVzdGFtcFxuZXhwb3J0cy5sb2cgPSBmdW5jdGlvbigpIHtcbiAgY29uc29sZS5sb2coJyVzIC0gJXMnLCB0aW1lc3RhbXAoKSwgZXhwb3J0cy5mb3JtYXQuYXBwbHkoZXhwb3J0cywgYXJndW1lbnRzKSk7XG59O1xuXG5cbi8qKlxuICogSW5oZXJpdCB0aGUgcHJvdG90eXBlIG1ldGhvZHMgZnJvbSBvbmUgY29uc3RydWN0b3IgaW50byBhbm90aGVyLlxuICpcbiAqIFRoZSBGdW5jdGlvbi5wcm90b3R5cGUuaW5oZXJpdHMgZnJvbSBsYW5nLmpzIHJld3JpdHRlbiBhcyBhIHN0YW5kYWxvbmVcbiAqIGZ1bmN0aW9uIChub3Qgb24gRnVuY3Rpb24ucHJvdG90eXBlKS4gTk9URTogSWYgdGhpcyBmaWxlIGlzIHRvIGJlIGxvYWRlZFxuICogZHVyaW5nIGJvb3RzdHJhcHBpbmcgdGhpcyBmdW5jdGlvbiBuZWVkcyB0byBiZSByZXdyaXR0ZW4gdXNpbmcgc29tZSBuYXRpdmVcbiAqIGZ1bmN0aW9ucyBhcyBwcm90b3R5cGUgc2V0dXAgdXNpbmcgbm9ybWFsIEphdmFTY3JpcHQgZG9lcyBub3Qgd29yayBhc1xuICogZXhwZWN0ZWQgZHVyaW5nIGJvb3RzdHJhcHBpbmcgKHNlZSBtaXJyb3IuanMgaW4gcjExNDkwMykuXG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbn0gY3RvciBDb25zdHJ1Y3RvciBmdW5jdGlvbiB3aGljaCBuZWVkcyB0byBpbmhlcml0IHRoZVxuICogICAgIHByb3RvdHlwZS5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IHN1cGVyQ3RvciBDb25zdHJ1Y3RvciBmdW5jdGlvbiB0byBpbmhlcml0IHByb3RvdHlwZSBmcm9tLlxuICovXG5leHBvcnRzLmluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcblxuZXhwb3J0cy5fZXh0ZW5kID0gZnVuY3Rpb24ob3JpZ2luLCBhZGQpIHtcbiAgLy8gRG9uJ3QgZG8gYW55dGhpbmcgaWYgYWRkIGlzbid0IGFuIG9iamVjdFxuICBpZiAoIWFkZCB8fCAhaXNPYmplY3QoYWRkKSkgcmV0dXJuIG9yaWdpbjtcblxuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGFkZCk7XG4gIHZhciBpID0ga2V5cy5sZW5ndGg7XG4gIHdoaWxlIChpLS0pIHtcbiAgICBvcmlnaW5ba2V5c1tpXV0gPSBhZGRba2V5c1tpXV07XG4gIH1cbiAgcmV0dXJuIG9yaWdpbjtcbn07XG5cbmZ1bmN0aW9uIGhhc093blByb3BlcnR5KG9iaiwgcHJvcCkge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCk7XG59XG4iLCIvLyAoYykgRGVhbiBNY05hbWVlIDxkZWFuQGdtYWlsLmNvbT4sIDIwMTIuXG4vL1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL2RlYW5tL2Nzcy1jb2xvci1wYXJzZXItanNcbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4vLyBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0b1xuLy8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGVcbi8vIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vclxuLy8gc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbi8vIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbi8vIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1Jcbi8vIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuLy8gRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4vLyBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4vLyBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lOR1xuLy8gRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HU1xuLy8gSU4gVEhFIFNPRlRXQVJFLlxuXG4vLyBodHRwOi8vd3d3LnczLm9yZy9UUi9jc3MzLWNvbG9yL1xudmFyIGtDU1NDb2xvclRhYmxlID0ge1xuICBcInRyYW5zcGFyZW50XCI6IFswLDAsMCwwXSwgXCJhbGljZWJsdWVcIjogWzI0MCwyNDgsMjU1LDFdLFxuICBcImFudGlxdWV3aGl0ZVwiOiBbMjUwLDIzNSwyMTUsMV0sIFwiYXF1YVwiOiBbMCwyNTUsMjU1LDFdLFxuICBcImFxdWFtYXJpbmVcIjogWzEyNywyNTUsMjEyLDFdLCBcImF6dXJlXCI6IFsyNDAsMjU1LDI1NSwxXSxcbiAgXCJiZWlnZVwiOiBbMjQ1LDI0NSwyMjAsMV0sIFwiYmlzcXVlXCI6IFsyNTUsMjI4LDE5NiwxXSxcbiAgXCJibGFja1wiOiBbMCwwLDAsMV0sIFwiYmxhbmNoZWRhbG1vbmRcIjogWzI1NSwyMzUsMjA1LDFdLFxuICBcImJsdWVcIjogWzAsMCwyNTUsMV0sIFwiYmx1ZXZpb2xldFwiOiBbMTM4LDQzLDIyNiwxXSxcbiAgXCJicm93blwiOiBbMTY1LDQyLDQyLDFdLCBcImJ1cmx5d29vZFwiOiBbMjIyLDE4NCwxMzUsMV0sXG4gIFwiY2FkZXRibHVlXCI6IFs5NSwxNTgsMTYwLDFdLCBcImNoYXJ0cmV1c2VcIjogWzEyNywyNTUsMCwxXSxcbiAgXCJjaG9jb2xhdGVcIjogWzIxMCwxMDUsMzAsMV0sIFwiY29yYWxcIjogWzI1NSwxMjcsODAsMV0sXG4gIFwiY29ybmZsb3dlcmJsdWVcIjogWzEwMCwxNDksMjM3LDFdLCBcImNvcm5zaWxrXCI6IFsyNTUsMjQ4LDIyMCwxXSxcbiAgXCJjcmltc29uXCI6IFsyMjAsMjAsNjAsMV0sIFwiY3lhblwiOiBbMCwyNTUsMjU1LDFdLFxuICBcImRhcmtibHVlXCI6IFswLDAsMTM5LDFdLCBcImRhcmtjeWFuXCI6IFswLDEzOSwxMzksMV0sXG4gIFwiZGFya2dvbGRlbnJvZFwiOiBbMTg0LDEzNCwxMSwxXSwgXCJkYXJrZ3JheVwiOiBbMTY5LDE2OSwxNjksMV0sXG4gIFwiZGFya2dyZWVuXCI6IFswLDEwMCwwLDFdLCBcImRhcmtncmV5XCI6IFsxNjksMTY5LDE2OSwxXSxcbiAgXCJkYXJra2hha2lcIjogWzE4OSwxODMsMTA3LDFdLCBcImRhcmttYWdlbnRhXCI6IFsxMzksMCwxMzksMV0sXG4gIFwiZGFya29saXZlZ3JlZW5cIjogWzg1LDEwNyw0NywxXSwgXCJkYXJrb3JhbmdlXCI6IFsyNTUsMTQwLDAsMV0sXG4gIFwiZGFya29yY2hpZFwiOiBbMTUzLDUwLDIwNCwxXSwgXCJkYXJrcmVkXCI6IFsxMzksMCwwLDFdLFxuICBcImRhcmtzYWxtb25cIjogWzIzMywxNTAsMTIyLDFdLCBcImRhcmtzZWFncmVlblwiOiBbMTQzLDE4OCwxNDMsMV0sXG4gIFwiZGFya3NsYXRlYmx1ZVwiOiBbNzIsNjEsMTM5LDFdLCBcImRhcmtzbGF0ZWdyYXlcIjogWzQ3LDc5LDc5LDFdLFxuICBcImRhcmtzbGF0ZWdyZXlcIjogWzQ3LDc5LDc5LDFdLCBcImRhcmt0dXJxdW9pc2VcIjogWzAsMjA2LDIwOSwxXSxcbiAgXCJkYXJrdmlvbGV0XCI6IFsxNDgsMCwyMTEsMV0sIFwiZGVlcHBpbmtcIjogWzI1NSwyMCwxNDcsMV0sXG4gIFwiZGVlcHNreWJsdWVcIjogWzAsMTkxLDI1NSwxXSwgXCJkaW1ncmF5XCI6IFsxMDUsMTA1LDEwNSwxXSxcbiAgXCJkaW1ncmV5XCI6IFsxMDUsMTA1LDEwNSwxXSwgXCJkb2RnZXJibHVlXCI6IFszMCwxNDQsMjU1LDFdLFxuICBcImZpcmVicmlja1wiOiBbMTc4LDM0LDM0LDFdLCBcImZsb3JhbHdoaXRlXCI6IFsyNTUsMjUwLDI0MCwxXSxcbiAgXCJmb3Jlc3RncmVlblwiOiBbMzQsMTM5LDM0LDFdLCBcImZ1Y2hzaWFcIjogWzI1NSwwLDI1NSwxXSxcbiAgXCJnYWluc2Jvcm9cIjogWzIyMCwyMjAsMjIwLDFdLCBcImdob3N0d2hpdGVcIjogWzI0OCwyNDgsMjU1LDFdLFxuICBcImdvbGRcIjogWzI1NSwyMTUsMCwxXSwgXCJnb2xkZW5yb2RcIjogWzIxOCwxNjUsMzIsMV0sXG4gIFwiZ3JheVwiOiBbMTI4LDEyOCwxMjgsMV0sIFwiZ3JlZW5cIjogWzAsMTI4LDAsMV0sXG4gIFwiZ3JlZW55ZWxsb3dcIjogWzE3MywyNTUsNDcsMV0sIFwiZ3JleVwiOiBbMTI4LDEyOCwxMjgsMV0sXG4gIFwiaG9uZXlkZXdcIjogWzI0MCwyNTUsMjQwLDFdLCBcImhvdHBpbmtcIjogWzI1NSwxMDUsMTgwLDFdLFxuICBcImluZGlhbnJlZFwiOiBbMjA1LDkyLDkyLDFdLCBcImluZGlnb1wiOiBbNzUsMCwxMzAsMV0sXG4gIFwiaXZvcnlcIjogWzI1NSwyNTUsMjQwLDFdLCBcImtoYWtpXCI6IFsyNDAsMjMwLDE0MCwxXSxcbiAgXCJsYXZlbmRlclwiOiBbMjMwLDIzMCwyNTAsMV0sIFwibGF2ZW5kZXJibHVzaFwiOiBbMjU1LDI0MCwyNDUsMV0sXG4gIFwibGF3bmdyZWVuXCI6IFsxMjQsMjUyLDAsMV0sIFwibGVtb25jaGlmZm9uXCI6IFsyNTUsMjUwLDIwNSwxXSxcbiAgXCJsaWdodGJsdWVcIjogWzE3MywyMTYsMjMwLDFdLCBcImxpZ2h0Y29yYWxcIjogWzI0MCwxMjgsMTI4LDFdLFxuICBcImxpZ2h0Y3lhblwiOiBbMjI0LDI1NSwyNTUsMV0sIFwibGlnaHRnb2xkZW5yb2R5ZWxsb3dcIjogWzI1MCwyNTAsMjEwLDFdLFxuICBcImxpZ2h0Z3JheVwiOiBbMjExLDIxMSwyMTEsMV0sIFwibGlnaHRncmVlblwiOiBbMTQ0LDIzOCwxNDQsMV0sXG4gIFwibGlnaHRncmV5XCI6IFsyMTEsMjExLDIxMSwxXSwgXCJsaWdodHBpbmtcIjogWzI1NSwxODIsMTkzLDFdLFxuICBcImxpZ2h0c2FsbW9uXCI6IFsyNTUsMTYwLDEyMiwxXSwgXCJsaWdodHNlYWdyZWVuXCI6IFszMiwxNzgsMTcwLDFdLFxuICBcImxpZ2h0c2t5Ymx1ZVwiOiBbMTM1LDIwNiwyNTAsMV0sIFwibGlnaHRzbGF0ZWdyYXlcIjogWzExOSwxMzYsMTUzLDFdLFxuICBcImxpZ2h0c2xhdGVncmV5XCI6IFsxMTksMTM2LDE1MywxXSwgXCJsaWdodHN0ZWVsYmx1ZVwiOiBbMTc2LDE5NiwyMjIsMV0sXG4gIFwibGlnaHR5ZWxsb3dcIjogWzI1NSwyNTUsMjI0LDFdLCBcImxpbWVcIjogWzAsMjU1LDAsMV0sXG4gIFwibGltZWdyZWVuXCI6IFs1MCwyMDUsNTAsMV0sIFwibGluZW5cIjogWzI1MCwyNDAsMjMwLDFdLFxuICBcIm1hZ2VudGFcIjogWzI1NSwwLDI1NSwxXSwgXCJtYXJvb25cIjogWzEyOCwwLDAsMV0sXG4gIFwibWVkaXVtYXF1YW1hcmluZVwiOiBbMTAyLDIwNSwxNzAsMV0sIFwibWVkaXVtYmx1ZVwiOiBbMCwwLDIwNSwxXSxcbiAgXCJtZWRpdW1vcmNoaWRcIjogWzE4Niw4NSwyMTEsMV0sIFwibWVkaXVtcHVycGxlXCI6IFsxNDcsMTEyLDIxOSwxXSxcbiAgXCJtZWRpdW1zZWFncmVlblwiOiBbNjAsMTc5LDExMywxXSwgXCJtZWRpdW1zbGF0ZWJsdWVcIjogWzEyMywxMDQsMjM4LDFdLFxuICBcIm1lZGl1bXNwcmluZ2dyZWVuXCI6IFswLDI1MCwxNTQsMV0sIFwibWVkaXVtdHVycXVvaXNlXCI6IFs3MiwyMDksMjA0LDFdLFxuICBcIm1lZGl1bXZpb2xldHJlZFwiOiBbMTk5LDIxLDEzMywxXSwgXCJtaWRuaWdodGJsdWVcIjogWzI1LDI1LDExMiwxXSxcbiAgXCJtaW50Y3JlYW1cIjogWzI0NSwyNTUsMjUwLDFdLCBcIm1pc3R5cm9zZVwiOiBbMjU1LDIyOCwyMjUsMV0sXG4gIFwibW9jY2FzaW5cIjogWzI1NSwyMjgsMTgxLDFdLCBcIm5hdmFqb3doaXRlXCI6IFsyNTUsMjIyLDE3MywxXSxcbiAgXCJuYXZ5XCI6IFswLDAsMTI4LDFdLCBcIm9sZGxhY2VcIjogWzI1MywyNDUsMjMwLDFdLFxuICBcIm9saXZlXCI6IFsxMjgsMTI4LDAsMV0sIFwib2xpdmVkcmFiXCI6IFsxMDcsMTQyLDM1LDFdLFxuICBcIm9yYW5nZVwiOiBbMjU1LDE2NSwwLDFdLCBcIm9yYW5nZXJlZFwiOiBbMjU1LDY5LDAsMV0sXG4gIFwib3JjaGlkXCI6IFsyMTgsMTEyLDIxNCwxXSwgXCJwYWxlZ29sZGVucm9kXCI6IFsyMzgsMjMyLDE3MCwxXSxcbiAgXCJwYWxlZ3JlZW5cIjogWzE1MiwyNTEsMTUyLDFdLCBcInBhbGV0dXJxdW9pc2VcIjogWzE3NSwyMzgsMjM4LDFdLFxuICBcInBhbGV2aW9sZXRyZWRcIjogWzIxOSwxMTIsMTQ3LDFdLCBcInBhcGF5YXdoaXBcIjogWzI1NSwyMzksMjEzLDFdLFxuICBcInBlYWNocHVmZlwiOiBbMjU1LDIxOCwxODUsMV0sIFwicGVydVwiOiBbMjA1LDEzMyw2MywxXSxcbiAgXCJwaW5rXCI6IFsyNTUsMTkyLDIwMywxXSwgXCJwbHVtXCI6IFsyMjEsMTYwLDIyMSwxXSxcbiAgXCJwb3dkZXJibHVlXCI6IFsxNzYsMjI0LDIzMCwxXSwgXCJwdXJwbGVcIjogWzEyOCwwLDEyOCwxXSxcbiAgXCJyZWRcIjogWzI1NSwwLDAsMV0sIFwicm9zeWJyb3duXCI6IFsxODgsMTQzLDE0MywxXSxcbiAgXCJyb3lhbGJsdWVcIjogWzY1LDEwNSwyMjUsMV0sIFwic2FkZGxlYnJvd25cIjogWzEzOSw2OSwxOSwxXSxcbiAgXCJzYWxtb25cIjogWzI1MCwxMjgsMTE0LDFdLCBcInNhbmR5YnJvd25cIjogWzI0NCwxNjQsOTYsMV0sXG4gIFwic2VhZ3JlZW5cIjogWzQ2LDEzOSw4NywxXSwgXCJzZWFzaGVsbFwiOiBbMjU1LDI0NSwyMzgsMV0sXG4gIFwic2llbm5hXCI6IFsxNjAsODIsNDUsMV0sIFwic2lsdmVyXCI6IFsxOTIsMTkyLDE5MiwxXSxcbiAgXCJza3libHVlXCI6IFsxMzUsMjA2LDIzNSwxXSwgXCJzbGF0ZWJsdWVcIjogWzEwNiw5MCwyMDUsMV0sXG4gIFwic2xhdGVncmF5XCI6IFsxMTIsMTI4LDE0NCwxXSwgXCJzbGF0ZWdyZXlcIjogWzExMiwxMjgsMTQ0LDFdLFxuICBcInNub3dcIjogWzI1NSwyNTAsMjUwLDFdLCBcInNwcmluZ2dyZWVuXCI6IFswLDI1NSwxMjcsMV0sXG4gIFwic3RlZWxibHVlXCI6IFs3MCwxMzAsMTgwLDFdLCBcInRhblwiOiBbMjEwLDE4MCwxNDAsMV0sXG4gIFwidGVhbFwiOiBbMCwxMjgsMTI4LDFdLCBcInRoaXN0bGVcIjogWzIxNiwxOTEsMjE2LDFdLFxuICBcInRvbWF0b1wiOiBbMjU1LDk5LDcxLDFdLCBcInR1cnF1b2lzZVwiOiBbNjQsMjI0LDIwOCwxXSxcbiAgXCJ2aW9sZXRcIjogWzIzOCwxMzAsMjM4LDFdLCBcIndoZWF0XCI6IFsyNDUsMjIyLDE3OSwxXSxcbiAgXCJ3aGl0ZVwiOiBbMjU1LDI1NSwyNTUsMV0sIFwid2hpdGVzbW9rZVwiOiBbMjQ1LDI0NSwyNDUsMV0sXG4gIFwieWVsbG93XCI6IFsyNTUsMjU1LDAsMV0sIFwieWVsbG93Z3JlZW5cIjogWzE1NCwyMDUsNTAsMV19XG5cbmZ1bmN0aW9uIGNsYW1wX2Nzc19ieXRlKGkpIHsgIC8vIENsYW1wIHRvIGludGVnZXIgMCAuLiAyNTUuXG4gIGkgPSBNYXRoLnJvdW5kKGkpOyAgLy8gU2VlbXMgdG8gYmUgd2hhdCBDaHJvbWUgZG9lcyAodnMgdHJ1bmNhdGlvbikuXG4gIHJldHVybiBpIDwgMCA/IDAgOiBpID4gMjU1ID8gMjU1IDogaTtcbn1cblxuZnVuY3Rpb24gY2xhbXBfY3NzX2Zsb2F0KGYpIHsgIC8vIENsYW1wIHRvIGZsb2F0IDAuMCAuLiAxLjAuXG4gIHJldHVybiBmIDwgMCA/IDAgOiBmID4gMSA/IDEgOiBmO1xufVxuXG5mdW5jdGlvbiBwYXJzZV9jc3NfaW50KHN0cikgeyAgLy8gaW50IG9yIHBlcmNlbnRhZ2UuXG4gIGlmIChzdHJbc3RyLmxlbmd0aCAtIDFdID09PSAnJScpXG4gICAgcmV0dXJuIGNsYW1wX2Nzc19ieXRlKHBhcnNlRmxvYXQoc3RyKSAvIDEwMCAqIDI1NSk7XG4gIHJldHVybiBjbGFtcF9jc3NfYnl0ZShwYXJzZUludChzdHIpKTtcbn1cblxuZnVuY3Rpb24gcGFyc2VfY3NzX2Zsb2F0KHN0cikgeyAgLy8gZmxvYXQgb3IgcGVyY2VudGFnZS5cbiAgaWYgKHN0cltzdHIubGVuZ3RoIC0gMV0gPT09ICclJylcbiAgICByZXR1cm4gY2xhbXBfY3NzX2Zsb2F0KHBhcnNlRmxvYXQoc3RyKSAvIDEwMCk7XG4gIHJldHVybiBjbGFtcF9jc3NfZmxvYXQocGFyc2VGbG9hdChzdHIpKTtcbn1cblxuZnVuY3Rpb24gY3NzX2h1ZV90b19yZ2IobTEsIG0yLCBoKSB7XG4gIGlmIChoIDwgMCkgaCArPSAxO1xuICBlbHNlIGlmIChoID4gMSkgaCAtPSAxO1xuXG4gIGlmIChoICogNiA8IDEpIHJldHVybiBtMSArIChtMiAtIG0xKSAqIGggKiA2O1xuICBpZiAoaCAqIDIgPCAxKSByZXR1cm4gbTI7XG4gIGlmIChoICogMyA8IDIpIHJldHVybiBtMSArIChtMiAtIG0xKSAqICgyLzMgLSBoKSAqIDY7XG4gIHJldHVybiBtMTtcbn1cblxuZnVuY3Rpb24gcGFyc2VDU1NDb2xvcihjc3Nfc3RyKSB7XG4gIC8vIFJlbW92ZSBhbGwgd2hpdGVzcGFjZSwgbm90IGNvbXBsaWFudCwgYnV0IHNob3VsZCBqdXN0IGJlIG1vcmUgYWNjZXB0aW5nLlxuICB2YXIgc3RyID0gY3NzX3N0ci5yZXBsYWNlKC8gL2csICcnKS50b0xvd2VyQ2FzZSgpO1xuXG4gIC8vIENvbG9yIGtleXdvcmRzIChhbmQgdHJhbnNwYXJlbnQpIGxvb2t1cC5cbiAgaWYgKHN0ciBpbiBrQ1NTQ29sb3JUYWJsZSkgcmV0dXJuIGtDU1NDb2xvclRhYmxlW3N0cl0uc2xpY2UoKTsgIC8vIGR1cC5cblxuICAvLyAjYWJjIGFuZCAjYWJjMTIzIHN5bnRheC5cbiAgaWYgKHN0clswXSA9PT0gJyMnKSB7XG4gICAgaWYgKHN0ci5sZW5ndGggPT09IDQpIHtcbiAgICAgIHZhciBpdiA9IHBhcnNlSW50KHN0ci5zdWJzdHIoMSksIDE2KTsgIC8vIFRPRE8oZGVhbm0pOiBTdHJpY3RlciBwYXJzaW5nLlxuICAgICAgaWYgKCEoaXYgPj0gMCAmJiBpdiA8PSAweGZmZikpIHJldHVybiBudWxsOyAgLy8gQ292ZXJzIE5hTi5cbiAgICAgIHJldHVybiBbKChpdiAmIDB4ZjAwKSA+PiA0KSB8ICgoaXYgJiAweGYwMCkgPj4gOCksXG4gICAgICAgICAgICAgIChpdiAmIDB4ZjApIHwgKChpdiAmIDB4ZjApID4+IDQpLFxuICAgICAgICAgICAgICAoaXYgJiAweGYpIHwgKChpdiAmIDB4ZikgPDwgNCksXG4gICAgICAgICAgICAgIDFdO1xuICAgIH0gZWxzZSBpZiAoc3RyLmxlbmd0aCA9PT0gNykge1xuICAgICAgdmFyIGl2ID0gcGFyc2VJbnQoc3RyLnN1YnN0cigxKSwgMTYpOyAgLy8gVE9ETyhkZWFubSk6IFN0cmljdGVyIHBhcnNpbmcuXG4gICAgICBpZiAoIShpdiA+PSAwICYmIGl2IDw9IDB4ZmZmZmZmKSkgcmV0dXJuIG51bGw7ICAvLyBDb3ZlcnMgTmFOLlxuICAgICAgcmV0dXJuIFsoaXYgJiAweGZmMDAwMCkgPj4gMTYsXG4gICAgICAgICAgICAgIChpdiAmIDB4ZmYwMCkgPj4gOCxcbiAgICAgICAgICAgICAgaXYgJiAweGZmLFxuICAgICAgICAgICAgICAxXTtcbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBvcCA9IHN0ci5pbmRleE9mKCcoJyksIGVwID0gc3RyLmluZGV4T2YoJyknKTtcbiAgaWYgKG9wICE9PSAtMSAmJiBlcCArIDEgPT09IHN0ci5sZW5ndGgpIHtcbiAgICB2YXIgZm5hbWUgPSBzdHIuc3Vic3RyKDAsIG9wKTtcbiAgICB2YXIgcGFyYW1zID0gc3RyLnN1YnN0cihvcCsxLCBlcC0ob3ArMSkpLnNwbGl0KCcsJyk7XG4gICAgdmFyIGFscGhhID0gMTsgIC8vIFRvIGFsbG93IGNhc2UgZmFsbHRocm91Z2guXG4gICAgc3dpdGNoIChmbmFtZSkge1xuICAgICAgY2FzZSAncmdiYSc6XG4gICAgICAgIGlmIChwYXJhbXMubGVuZ3RoICE9PSA0KSByZXR1cm4gbnVsbDtcbiAgICAgICAgYWxwaGEgPSBwYXJzZV9jc3NfZmxvYXQocGFyYW1zLnBvcCgpKTtcbiAgICAgICAgLy8gRmFsbCB0aHJvdWdoLlxuICAgICAgY2FzZSAncmdiJzpcbiAgICAgICAgaWYgKHBhcmFtcy5sZW5ndGggIT09IDMpIHJldHVybiBudWxsO1xuICAgICAgICByZXR1cm4gW3BhcnNlX2Nzc19pbnQocGFyYW1zWzBdKSxcbiAgICAgICAgICAgICAgICBwYXJzZV9jc3NfaW50KHBhcmFtc1sxXSksXG4gICAgICAgICAgICAgICAgcGFyc2VfY3NzX2ludChwYXJhbXNbMl0pLFxuICAgICAgICAgICAgICAgIGFscGhhXTtcbiAgICAgIGNhc2UgJ2hzbGEnOlxuICAgICAgICBpZiAocGFyYW1zLmxlbmd0aCAhPT0gNCkgcmV0dXJuIG51bGw7XG4gICAgICAgIGFscGhhID0gcGFyc2VfY3NzX2Zsb2F0KHBhcmFtcy5wb3AoKSk7XG4gICAgICAgIC8vIEZhbGwgdGhyb3VnaC5cbiAgICAgIGNhc2UgJ2hzbCc6XG4gICAgICAgIGlmIChwYXJhbXMubGVuZ3RoICE9PSAzKSByZXR1cm4gbnVsbDtcbiAgICAgICAgdmFyIGggPSAoKChwYXJzZUZsb2F0KHBhcmFtc1swXSkgJSAzNjApICsgMzYwKSAlIDM2MCkgLyAzNjA7ICAvLyAwIC4uIDFcbiAgICAgICAgLy8gTk9URShkZWFubSk6IEFjY29yZGluZyB0byB0aGUgQ1NTIHNwZWMgcy9sIHNob3VsZCBvbmx5IGJlXG4gICAgICAgIC8vIHBlcmNlbnRhZ2VzLCBidXQgd2UgZG9uJ3QgYm90aGVyIGFuZCBsZXQgZmxvYXQgb3IgcGVyY2VudGFnZS5cbiAgICAgICAgdmFyIHMgPSBwYXJzZV9jc3NfZmxvYXQocGFyYW1zWzFdKTtcbiAgICAgICAgdmFyIGwgPSBwYXJzZV9jc3NfZmxvYXQocGFyYW1zWzJdKTtcbiAgICAgICAgdmFyIG0yID0gbCA8PSAwLjUgPyBsICogKHMgKyAxKSA6IGwgKyBzIC0gbCAqIHM7XG4gICAgICAgIHZhciBtMSA9IGwgKiAyIC0gbTI7XG4gICAgICAgIHJldHVybiBbY2xhbXBfY3NzX2J5dGUoY3NzX2h1ZV90b19yZ2IobTEsIG0yLCBoKzEvMykgKiAyNTUpLFxuICAgICAgICAgICAgICAgIGNsYW1wX2Nzc19ieXRlKGNzc19odWVfdG9fcmdiKG0xLCBtMiwgaCkgKiAyNTUpLFxuICAgICAgICAgICAgICAgIGNsYW1wX2Nzc19ieXRlKGNzc19odWVfdG9fcmdiKG0xLCBtMiwgaC0xLzMpICogMjU1KSxcbiAgICAgICAgICAgICAgICBhbHBoYV07XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxudHJ5IHsgZXhwb3J0cy5wYXJzZUNTU0NvbG9yID0gcGFyc2VDU1NDb2xvciB9IGNhdGNoKGUpIHsgfVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZUZpbHRlcjtcblxudmFyIHR5cGVzID0gWydVbmtub3duJywgJ1BvaW50JywgJ0xpbmVTdHJpbmcnLCAnUG9seWdvbiddO1xuXG4vKipcbiAqIEdpdmVuIGEgZmlsdGVyIGV4cHJlc3NlZCBhcyBuZXN0ZWQgYXJyYXlzLCByZXR1cm4gYSBuZXcgZnVuY3Rpb25cbiAqIHRoYXQgZXZhbHVhdGVzIHdoZXRoZXIgYSBnaXZlbiBmZWF0dXJlICh3aXRoIGEgLnByb3BlcnRpZXMgb3IgLnRhZ3MgcHJvcGVydHkpXG4gKiBwYXNzZXMgaXRzIHRlc3QuXG4gKlxuICogQHBhcmFtIHtBcnJheX0gZmlsdGVyIG1hcGJveCBnbCBmaWx0ZXJcbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gZmlsdGVyLWV2YWx1YXRpbmcgZnVuY3Rpb25cbiAqL1xuZnVuY3Rpb24gY3JlYXRlRmlsdGVyKGZpbHRlcikge1xuICAgIHJldHVybiBuZXcgRnVuY3Rpb24oJ2YnLCAncmV0dXJuICcgKyBjb21waWxlKGZpbHRlcikpO1xufVxuXG5mdW5jdGlvbiBjb21waWxlKGZpbHRlcikge1xuICAgIGlmICghZmlsdGVyKSByZXR1cm4gJ3RydWUnO1xuICAgIHZhciBvcCA9IGZpbHRlclswXTtcbiAgICBpZiAoZmlsdGVyLmxlbmd0aCA8PSAxKSByZXR1cm4gb3AgPT09ICdhbnknID8gJ2ZhbHNlJyA6ICd0cnVlJztcbiAgICB2YXIgc3RyID1cbiAgICAgICAgb3AgPT09ICc9PScgPyBjb21wYXJlKGZpbHRlclsxXSwgZmlsdGVyWzJdLCAnPT09JywgZmFsc2UpIDpcbiAgICAgICAgb3AgPT09ICchPScgPyBjb21wYXJlKGZpbHRlclsxXSwgZmlsdGVyWzJdLCAnIT09JywgZmFsc2UpIDpcbiAgICAgICAgb3AgPT09ICc8JyB8fFxuICAgICAgICBvcCA9PT0gJz4nIHx8XG4gICAgICAgIG9wID09PSAnPD0nIHx8XG4gICAgICAgIG9wID09PSAnPj0nID8gY29tcGFyZShmaWx0ZXJbMV0sIGZpbHRlclsyXSwgb3AsIHRydWUpIDpcbiAgICAgICAgb3AgPT09ICdhbnknID8gZmlsdGVyLnNsaWNlKDEpLm1hcChjb21waWxlKS5qb2luKCd8fCcpIDpcbiAgICAgICAgb3AgPT09ICdhbGwnID8gZmlsdGVyLnNsaWNlKDEpLm1hcChjb21waWxlKS5qb2luKCcmJicpIDpcbiAgICAgICAgb3AgPT09ICdub25lJyA/ICchKCcgKyBmaWx0ZXIuc2xpY2UoMSkubWFwKGNvbXBpbGUpLmpvaW4oJ3x8JykgKyAnKScgOlxuICAgICAgICBvcCA9PT0gJ2luJyA/IGNvbXBpbGVJbihmaWx0ZXJbMV0sIGZpbHRlci5zbGljZSgyKSkgOlxuICAgICAgICBvcCA9PT0gJyFpbicgPyAnISgnICsgY29tcGlsZUluKGZpbHRlclsxXSwgZmlsdGVyLnNsaWNlKDIpKSArICcpJyA6XG4gICAgICAgICd0cnVlJztcbiAgICByZXR1cm4gJygnICsgc3RyICsgJyknO1xufVxuXG5mdW5jdGlvbiB2YWx1ZUV4cHIoa2V5KSB7XG4gICAgcmV0dXJuIGtleSA9PT0gJyR0eXBlJyA/ICdmLnR5cGUnIDogJyhmLnByb3BlcnRpZXMgfHwge30pWycgKyBKU09OLnN0cmluZ2lmeShrZXkpICsgJ10nO1xufVxuZnVuY3Rpb24gY29tcGFyZShrZXksIHZhbCwgb3AsIGNoZWNrVHlwZSkge1xuICAgIHZhciBsZWZ0ID0gdmFsdWVFeHByKGtleSk7XG4gICAgdmFyIHJpZ2h0ID0ga2V5ID09PSAnJHR5cGUnID8gdHlwZXMuaW5kZXhPZih2YWwpIDogSlNPTi5zdHJpbmdpZnkodmFsKTtcbiAgICByZXR1cm4gKGNoZWNrVHlwZSA/ICd0eXBlb2YgJyArIGxlZnQgKyAnPT09IHR5cGVvZiAnICsgcmlnaHQgKyAnJiYnIDogJycpICsgbGVmdCArIG9wICsgcmlnaHQ7XG59XG5mdW5jdGlvbiBjb21waWxlSW4oa2V5LCB2YWx1ZXMpIHtcbiAgICBpZiAoa2V5ID09PSAnJHR5cGUnKSB2YWx1ZXMgPSB2YWx1ZXMubWFwKGZ1bmN0aW9uKHZhbHVlKSB7IHJldHVybiB0eXBlcy5pbmRleE9mKHZhbHVlKTsgfSk7XG4gICAgdmFyIGxlZnQgPSBKU09OLnN0cmluZ2lmeSh2YWx1ZXMuc29ydChjb21wYXJlRm4pKTtcbiAgICB2YXIgcmlnaHQgPSB2YWx1ZUV4cHIoa2V5KTtcblxuICAgIGlmICh2YWx1ZXMubGVuZ3RoIDw9IDIwMCkgcmV0dXJuIGxlZnQgKyAnLmluZGV4T2YoJyArIHJpZ2h0ICsgJykgIT09IC0xJztcblxuICAgIHJldHVybiAnZnVuY3Rpb24odiwgYSwgaSwgaikgeycgK1xuICAgICAgICAnd2hpbGUgKGkgPD0gaikgeyB2YXIgbSA9IChpICsgaikgPj4gMTsnICtcbiAgICAgICAgJyAgICBpZiAoYVttXSA9PT0gdikgcmV0dXJuIHRydWU7IGlmIChhW21dID4gdikgaiA9IG0gLSAxOyBlbHNlIGkgPSBtICsgMTsnICtcbiAgICAgICAgJ30nICtcbiAgICAncmV0dXJuIGZhbHNlOyB9KCcgKyByaWdodCArICcsICcgKyBsZWZ0ICsgJywwLCcgKyAodmFsdWVzLmxlbmd0aCAtIDEpICsgJyknO1xufVxuXG5mdW5jdGlvbiBjb21wYXJlRm4oYSwgYikge1xuICAgIHJldHVybiBhIDwgYiA/IC0xIDogYSA+IGIgPyAxIDogMDtcbn1cbiIsInZhciBnZW9qc29uQXJlYSA9IHJlcXVpcmUoJ2dlb2pzb24tYXJlYScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJld2luZDtcblxuZnVuY3Rpb24gcmV3aW5kKGdqLCBvdXRlcikge1xuICAgIHN3aXRjaCAoKGdqICYmIGdqLnR5cGUpIHx8IG51bGwpIHtcbiAgICAgICAgY2FzZSAnRmVhdHVyZUNvbGxlY3Rpb24nOlxuICAgICAgICAgICAgZ2ouZmVhdHVyZXMgPSBnai5mZWF0dXJlcy5tYXAoY3VycnlPdXRlcihyZXdpbmQsIG91dGVyKSk7XG4gICAgICAgICAgICByZXR1cm4gZ2o7XG4gICAgICAgIGNhc2UgJ0ZlYXR1cmUnOlxuICAgICAgICAgICAgZ2ouZ2VvbWV0cnkgPSByZXdpbmQoZ2ouZ2VvbWV0cnksIG91dGVyKTtcbiAgICAgICAgICAgIHJldHVybiBnajtcbiAgICAgICAgY2FzZSAnUG9seWdvbic6XG4gICAgICAgIGNhc2UgJ011bHRpUG9seWdvbic6XG4gICAgICAgICAgICByZXR1cm4gY29ycmVjdChnaiwgb3V0ZXIpO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIGdqO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gY3VycnlPdXRlcihhLCBiKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKF8pIHsgcmV0dXJuIGEoXywgYik7IH07XG59XG5cbmZ1bmN0aW9uIGNvcnJlY3QoXywgb3V0ZXIpIHtcbiAgICBpZiAoXy50eXBlID09PSAnUG9seWdvbicpIHtcbiAgICAgICAgXy5jb29yZGluYXRlcyA9IGNvcnJlY3RSaW5ncyhfLmNvb3JkaW5hdGVzLCBvdXRlcik7XG4gICAgfSBlbHNlIGlmIChfLnR5cGUgPT09ICdNdWx0aVBvbHlnb24nKSB7XG4gICAgICAgIF8uY29vcmRpbmF0ZXMgPSBfLmNvb3JkaW5hdGVzLm1hcChjdXJyeU91dGVyKGNvcnJlY3RSaW5ncywgb3V0ZXIpKTtcbiAgICB9XG4gICAgcmV0dXJuIF87XG59XG5cbmZ1bmN0aW9uIGNvcnJlY3RSaW5ncyhfLCBvdXRlcikge1xuICAgIG91dGVyID0gISFvdXRlcjtcbiAgICBfWzBdID0gd2luZChfWzBdLCAhb3V0ZXIpO1xuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgXy5sZW5ndGg7IGkrKykge1xuICAgICAgICBfW2ldID0gd2luZChfW2ldLCBvdXRlcik7XG4gICAgfVxuICAgIHJldHVybiBfO1xufVxuXG5mdW5jdGlvbiB3aW5kKF8sIGRpcikge1xuICAgIHJldHVybiBjdyhfKSA9PT0gZGlyID8gXyA6IF8ucmV2ZXJzZSgpO1xufVxuXG5mdW5jdGlvbiBjdyhfKSB7XG4gICAgcmV0dXJuIGdlb2pzb25BcmVhLnJpbmcoXykgPj0gMDtcbn1cbiIsInZhciB3Z3M4NCA9IHJlcXVpcmUoJ3dnczg0Jyk7XG5cbm1vZHVsZS5leHBvcnRzLmdlb21ldHJ5ID0gZ2VvbWV0cnk7XG5tb2R1bGUuZXhwb3J0cy5yaW5nID0gcmluZ0FyZWE7XG5cbmZ1bmN0aW9uIGdlb21ldHJ5KF8pIHtcbiAgICBpZiAoXy50eXBlID09PSAnUG9seWdvbicpIHJldHVybiBwb2x5Z29uQXJlYShfLmNvb3JkaW5hdGVzKTtcbiAgICBlbHNlIGlmIChfLnR5cGUgPT09ICdNdWx0aVBvbHlnb24nKSB7XG4gICAgICAgIHZhciBhcmVhID0gMDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBfLmNvb3JkaW5hdGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhcmVhICs9IHBvbHlnb25BcmVhKF8uY29vcmRpbmF0ZXNbaV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhcmVhO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gcG9seWdvbkFyZWEoY29vcmRzKSB7XG4gICAgdmFyIGFyZWEgPSAwO1xuICAgIGlmIChjb29yZHMgJiYgY29vcmRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgYXJlYSArPSBNYXRoLmFicyhyaW5nQXJlYShjb29yZHNbMF0pKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBjb29yZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFyZWEgLT0gTWF0aC5hYnMocmluZ0FyZWEoY29vcmRzW2ldKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGFyZWE7XG59XG5cbi8qKlxuICogQ2FsY3VsYXRlIHRoZSBhcHByb3hpbWF0ZSBhcmVhIG9mIHRoZSBwb2x5Z29uIHdlcmUgaXQgcHJvamVjdGVkIG9udG9cbiAqICAgICB0aGUgZWFydGguICBOb3RlIHRoYXQgdGhpcyBhcmVhIHdpbGwgYmUgcG9zaXRpdmUgaWYgcmluZyBpcyBvcmllbnRlZFxuICogICAgIGNsb2Nrd2lzZSwgb3RoZXJ3aXNlIGl0IHdpbGwgYmUgbmVnYXRpdmUuXG4gKlxuICogUmVmZXJlbmNlOlxuICogUm9iZXJ0LiBHLiBDaGFtYmVybGFpbiBhbmQgV2lsbGlhbSBILiBEdXF1ZXR0ZSwgXCJTb21lIEFsZ29yaXRobXMgZm9yXG4gKiAgICAgUG9seWdvbnMgb24gYSBTcGhlcmVcIiwgSlBMIFB1YmxpY2F0aW9uIDA3LTAzLCBKZXQgUHJvcHVsc2lvblxuICogICAgIExhYm9yYXRvcnksIFBhc2FkZW5hLCBDQSwgSnVuZSAyMDA3IGh0dHA6Ly90cnMtbmV3LmpwbC5uYXNhLmdvdi9kc3BhY2UvaGFuZGxlLzIwMTQvNDA0MDlcbiAqXG4gKiBSZXR1cm5zOlxuICoge2Zsb2F0fSBUaGUgYXBwcm94aW1hdGUgc2lnbmVkIGdlb2Rlc2ljIGFyZWEgb2YgdGhlIHBvbHlnb24gaW4gc3F1YXJlXG4gKiAgICAgbWV0ZXJzLlxuICovXG5cbmZ1bmN0aW9uIHJpbmdBcmVhKGNvb3Jkcykge1xuICAgIHZhciBhcmVhID0gMDtcblxuICAgIGlmIChjb29yZHMubGVuZ3RoID4gMikge1xuICAgICAgICB2YXIgcDEsIHAyO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvb3Jkcy5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgICAgICAgIHAxID0gY29vcmRzW2ldO1xuICAgICAgICAgICAgcDIgPSBjb29yZHNbaSArIDFdO1xuICAgICAgICAgICAgYXJlYSArPSByYWQocDJbMF0gLSBwMVswXSkgKiAoMiArIE1hdGguc2luKHJhZChwMVsxXSkpICsgTWF0aC5zaW4ocmFkKHAyWzFdKSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgYXJlYSA9IGFyZWEgKiB3Z3M4NC5SQURJVVMgKiB3Z3M4NC5SQURJVVMgLyAyO1xuICAgIH1cblxuICAgIHJldHVybiBhcmVhO1xufVxuXG5mdW5jdGlvbiByYWQoXykge1xuICAgIHJldHVybiBfICogTWF0aC5QSSAvIDE4MDtcbn1cbiIsIm1vZHVsZS5leHBvcnRzLlJBRElVUyA9IDYzNzgxMzc7XG5tb2R1bGUuZXhwb3J0cy5GTEFUVEVOSU5HID0gMS8yOTguMjU3MjIzNTYzO1xubW9kdWxlLmV4cG9ydHMuUE9MQVJfUkFESVVTID0gNjM1Njc1Mi4zMTQyO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGNsaXA7XG5cbi8qIGNsaXAgZmVhdHVyZXMgYmV0d2VlbiB0d28gYXhpcy1wYXJhbGxlbCBsaW5lczpcbiAqICAgICB8ICAgICAgICB8XG4gKiAgX19ffF9fXyAgICAgfCAgICAgL1xuICogLyAgIHwgICBcXF9fX198X19fXy9cbiAqICAgICB8ICAgICAgICB8XG4gKi9cblxuZnVuY3Rpb24gY2xpcChmZWF0dXJlcywgc2NhbGUsIGsxLCBrMiwgYXhpcywgaW50ZXJzZWN0LCBtaW5BbGwsIG1heEFsbCkge1xuXG4gICAgazEgLz0gc2NhbGU7XG4gICAgazIgLz0gc2NhbGU7XG5cbiAgICBpZiAobWluQWxsID49IGsxICYmIG1heEFsbCA8PSBrMikgcmV0dXJuIGZlYXR1cmVzOyAvLyB0cml2aWFsIGFjY2VwdFxuICAgIGVsc2UgaWYgKG1pbkFsbCA+IGsyIHx8IG1heEFsbCA8IGsxKSByZXR1cm4gbnVsbDsgLy8gdHJpdmlhbCByZWplY3RcblxuICAgIHZhciBjbGlwcGVkID0gW107XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZlYXR1cmVzLmxlbmd0aDsgaSsrKSB7XG5cbiAgICAgICAgdmFyIGZlYXR1cmUgPSBmZWF0dXJlc1tpXSxcbiAgICAgICAgICAgIGdlb21ldHJ5ID0gZmVhdHVyZS5nZW9tZXRyeSxcbiAgICAgICAgICAgIHR5cGUgPSBmZWF0dXJlLnR5cGUsXG4gICAgICAgICAgICBtaW4sIG1heDtcblxuICAgICAgICBtaW4gPSBmZWF0dXJlLm1pbltheGlzXTtcbiAgICAgICAgbWF4ID0gZmVhdHVyZS5tYXhbYXhpc107XG5cbiAgICAgICAgaWYgKG1pbiA+PSBrMSAmJiBtYXggPD0gazIpIHsgLy8gdHJpdmlhbCBhY2NlcHRcbiAgICAgICAgICAgIGNsaXBwZWQucHVzaChmZWF0dXJlKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9IGVsc2UgaWYgKG1pbiA+IGsyIHx8IG1heCA8IGsxKSBjb250aW51ZTsgLy8gdHJpdmlhbCByZWplY3RcblxuICAgICAgICB2YXIgc2xpY2VzID0gdHlwZSA9PT0gMSA/XG4gICAgICAgICAgICAgICAgY2xpcFBvaW50cyhnZW9tZXRyeSwgazEsIGsyLCBheGlzKSA6XG4gICAgICAgICAgICAgICAgY2xpcEdlb21ldHJ5KGdlb21ldHJ5LCBrMSwgazIsIGF4aXMsIGludGVyc2VjdCwgdHlwZSA9PT0gMyk7XG5cbiAgICAgICAgaWYgKHNsaWNlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIC8vIGlmIGEgZmVhdHVyZSBnb3QgY2xpcHBlZCwgaXQgd2lsbCBsaWtlbHkgZ2V0IGNsaXBwZWQgb24gdGhlIG5leHQgem9vbSBsZXZlbCBhcyB3ZWxsLFxuICAgICAgICAgICAgLy8gc28gdGhlcmUncyBubyBuZWVkIHRvIHJlY2FsY3VsYXRlIGJib3hlc1xuICAgICAgICAgICAgY2xpcHBlZC5wdXNoKHtcbiAgICAgICAgICAgICAgICBnZW9tZXRyeTogc2xpY2VzLFxuICAgICAgICAgICAgICAgIHR5cGU6IHR5cGUsXG4gICAgICAgICAgICAgICAgdGFnczogZmVhdHVyZXNbaV0udGFncyB8fCBudWxsLFxuICAgICAgICAgICAgICAgIG1pbjogZmVhdHVyZS5taW4sXG4gICAgICAgICAgICAgICAgbWF4OiBmZWF0dXJlLm1heFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gY2xpcHBlZC5sZW5ndGggPyBjbGlwcGVkIDogbnVsbDtcbn1cblxuZnVuY3Rpb24gY2xpcFBvaW50cyhnZW9tZXRyeSwgazEsIGsyLCBheGlzKSB7XG4gICAgdmFyIHNsaWNlID0gW107XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGdlb21ldHJ5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBhID0gZ2VvbWV0cnlbaV0sXG4gICAgICAgICAgICBhayA9IGFbYXhpc107XG5cbiAgICAgICAgaWYgKGFrID49IGsxICYmIGFrIDw9IGsyKSBzbGljZS5wdXNoKGEpO1xuICAgIH1cbiAgICByZXR1cm4gc2xpY2U7XG59XG5cbmZ1bmN0aW9uIGNsaXBHZW9tZXRyeShnZW9tZXRyeSwgazEsIGsyLCBheGlzLCBpbnRlcnNlY3QsIGNsb3NlZCkge1xuXG4gICAgdmFyIHNsaWNlcyA9IFtdO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBnZW9tZXRyeS5sZW5ndGg7IGkrKykge1xuXG4gICAgICAgIHZhciBhayA9IDAsXG4gICAgICAgICAgICBiayA9IDAsXG4gICAgICAgICAgICBiID0gbnVsbCxcbiAgICAgICAgICAgIHBvaW50cyA9IGdlb21ldHJ5W2ldLFxuICAgICAgICAgICAgYXJlYSA9IHBvaW50cy5hcmVhLFxuICAgICAgICAgICAgZGlzdCA9IHBvaW50cy5kaXN0LFxuICAgICAgICAgICAgbGVuID0gcG9pbnRzLmxlbmd0aCxcbiAgICAgICAgICAgIGEsIGosIGxhc3Q7XG5cbiAgICAgICAgdmFyIHNsaWNlID0gW107XG5cbiAgICAgICAgZm9yIChqID0gMDsgaiA8IGxlbiAtIDE7IGorKykge1xuICAgICAgICAgICAgYSA9IGIgfHwgcG9pbnRzW2pdO1xuICAgICAgICAgICAgYiA9IHBvaW50c1tqICsgMV07XG4gICAgICAgICAgICBhayA9IGJrIHx8IGFbYXhpc107XG4gICAgICAgICAgICBiayA9IGJbYXhpc107XG5cbiAgICAgICAgICAgIGlmIChhayA8IGsxKSB7XG5cbiAgICAgICAgICAgICAgICBpZiAoKGJrID4gazIpKSB7IC8vIC0tLXwtLS0tLXwtLT5cbiAgICAgICAgICAgICAgICAgICAgc2xpY2UucHVzaChpbnRlcnNlY3QoYSwgYiwgazEpLCBpbnRlcnNlY3QoYSwgYiwgazIpKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjbG9zZWQpIHNsaWNlID0gbmV3U2xpY2Uoc2xpY2VzLCBzbGljZSwgYXJlYSwgZGlzdCk7XG5cbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGJrID49IGsxKSBzbGljZS5wdXNoKGludGVyc2VjdChhLCBiLCBrMSkpOyAvLyAtLS18LS0+ICB8XG5cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYWsgPiBrMikge1xuXG4gICAgICAgICAgICAgICAgaWYgKChiayA8IGsxKSkgeyAvLyA8LS18LS0tLS18LS0tXG4gICAgICAgICAgICAgICAgICAgIHNsaWNlLnB1c2goaW50ZXJzZWN0KGEsIGIsIGsyKSwgaW50ZXJzZWN0KGEsIGIsIGsxKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghY2xvc2VkKSBzbGljZSA9IG5ld1NsaWNlKHNsaWNlcywgc2xpY2UsIGFyZWEsIGRpc3QpO1xuXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChiayA8PSBrMikgc2xpY2UucHVzaChpbnRlcnNlY3QoYSwgYiwgazIpKTsgLy8gfCAgPC0tfC0tLVxuXG4gICAgICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgc2xpY2UucHVzaChhKTtcblxuICAgICAgICAgICAgICAgIGlmIChiayA8IGsxKSB7IC8vIDwtLXwtLS0gIHxcbiAgICAgICAgICAgICAgICAgICAgc2xpY2UucHVzaChpbnRlcnNlY3QoYSwgYiwgazEpKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjbG9zZWQpIHNsaWNlID0gbmV3U2xpY2Uoc2xpY2VzLCBzbGljZSwgYXJlYSwgZGlzdCk7XG5cbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGJrID4gazIpIHsgLy8gfCAgLS0tfC0tPlxuICAgICAgICAgICAgICAgICAgICBzbGljZS5wdXNoKGludGVyc2VjdChhLCBiLCBrMikpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWNsb3NlZCkgc2xpY2UgPSBuZXdTbGljZShzbGljZXMsIHNsaWNlLCBhcmVhLCBkaXN0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gfCAtLT4gfFxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gYWRkIHRoZSBsYXN0IHBvaW50XG4gICAgICAgIGEgPSBwb2ludHNbbGVuIC0gMV07XG4gICAgICAgIGFrID0gYVtheGlzXTtcbiAgICAgICAgaWYgKGFrID49IGsxICYmIGFrIDw9IGsyKSBzbGljZS5wdXNoKGEpO1xuXG4gICAgICAgIC8vIGNsb3NlIHRoZSBwb2x5Z29uIGlmIGl0cyBlbmRwb2ludHMgYXJlIG5vdCB0aGUgc2FtZSBhZnRlciBjbGlwcGluZ1xuXG4gICAgICAgIGxhc3QgPSBzbGljZVtzbGljZS5sZW5ndGggLSAxXTtcbiAgICAgICAgaWYgKGNsb3NlZCAmJiBsYXN0ICYmIChzbGljZVswXVswXSAhPT0gbGFzdFswXSB8fCBzbGljZVswXVsxXSAhPT0gbGFzdFsxXSkpIHNsaWNlLnB1c2goc2xpY2VbMF0pO1xuXG4gICAgICAgIC8vIGFkZCB0aGUgZmluYWwgc2xpY2VcbiAgICAgICAgbmV3U2xpY2Uoc2xpY2VzLCBzbGljZSwgYXJlYSwgZGlzdCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHNsaWNlcztcbn1cblxuZnVuY3Rpb24gbmV3U2xpY2Uoc2xpY2VzLCBzbGljZSwgYXJlYSwgZGlzdCkge1xuICAgIGlmIChzbGljZS5sZW5ndGgpIHtcbiAgICAgICAgLy8gd2UgZG9uJ3QgcmVjYWxjdWxhdGUgdGhlIGFyZWEvbGVuZ3RoIG9mIHRoZSB1bmNsaXBwZWQgZ2VvbWV0cnkgYmVjYXVzZSB0aGUgY2FzZSB3aGVyZSBpdCBnb2VzXG4gICAgICAgIC8vIGJlbG93IHRoZSB2aXNpYmlsaXR5IHRocmVzaG9sZCBhcyBhIHJlc3VsdCBvZiBjbGlwcGluZyBpcyByYXJlLCBzbyB3ZSBhdm9pZCBkb2luZyB1bm5lY2Vzc2FyeSB3b3JrXG4gICAgICAgIHNsaWNlLmFyZWEgPSBhcmVhO1xuICAgICAgICBzbGljZS5kaXN0ID0gZGlzdDtcblxuICAgICAgICBzbGljZXMucHVzaChzbGljZSk7XG4gICAgfVxuICAgIHJldHVybiBbXTtcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBjb252ZXJ0O1xuXG52YXIgc2ltcGxpZnkgPSByZXF1aXJlKCcuL3NpbXBsaWZ5Jyk7XG5cbi8vIGNvbnZlcnRzIEdlb0pTT04gZmVhdHVyZSBpbnRvIGFuIGludGVybWVkaWF0ZSBwcm9qZWN0ZWQgSlNPTiB2ZWN0b3IgZm9ybWF0IHdpdGggc2ltcGxpZmljYXRpb24gZGF0YVxuXG5mdW5jdGlvbiBjb252ZXJ0KGRhdGEsIHRvbGVyYW5jZSkge1xuICAgIHZhciBmZWF0dXJlcyA9IFtdO1xuXG4gICAgaWYgKGRhdGEudHlwZSA9PT0gJ0ZlYXR1cmVDb2xsZWN0aW9uJykge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGEuZmVhdHVyZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnZlcnRGZWF0dXJlKGZlYXR1cmVzLCBkYXRhLmZlYXR1cmVzW2ldLCB0b2xlcmFuY2UpO1xuICAgICAgICB9XG4gICAgfSBlbHNlIGlmIChkYXRhLnR5cGUgPT09ICdGZWF0dXJlJykge1xuICAgICAgICBjb252ZXJ0RmVhdHVyZShmZWF0dXJlcywgZGF0YSwgdG9sZXJhbmNlKTtcblxuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHNpbmdsZSBnZW9tZXRyeSBvciBhIGdlb21ldHJ5IGNvbGxlY3Rpb25cbiAgICAgICAgY29udmVydEZlYXR1cmUoZmVhdHVyZXMsIHtnZW9tZXRyeTogZGF0YX0sIHRvbGVyYW5jZSk7XG4gICAgfVxuICAgIHJldHVybiBmZWF0dXJlcztcbn1cblxuZnVuY3Rpb24gY29udmVydEZlYXR1cmUoZmVhdHVyZXMsIGZlYXR1cmUsIHRvbGVyYW5jZSkge1xuICAgIHZhciBnZW9tID0gZmVhdHVyZS5nZW9tZXRyeSxcbiAgICAgICAgdHlwZSA9IGdlb20udHlwZSxcbiAgICAgICAgY29vcmRzID0gZ2VvbS5jb29yZGluYXRlcyxcbiAgICAgICAgdGFncyA9IGZlYXR1cmUucHJvcGVydGllcyxcbiAgICAgICAgaSwgaiwgcmluZ3M7XG5cbiAgICBpZiAodHlwZSA9PT0gJ1BvaW50Jykge1xuICAgICAgICBmZWF0dXJlcy5wdXNoKGNyZWF0ZSh0YWdzLCAxLCBbcHJvamVjdFBvaW50KGNvb3JkcyldKSk7XG5cbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdNdWx0aVBvaW50Jykge1xuICAgICAgICBmZWF0dXJlcy5wdXNoKGNyZWF0ZSh0YWdzLCAxLCBwcm9qZWN0KGNvb3JkcykpKTtcblxuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ0xpbmVTdHJpbmcnKSB7XG4gICAgICAgIGZlYXR1cmVzLnB1c2goY3JlYXRlKHRhZ3MsIDIsIFtwcm9qZWN0KGNvb3JkcywgdG9sZXJhbmNlKV0pKTtcblxuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ011bHRpTGluZVN0cmluZycgfHwgdHlwZSA9PT0gJ1BvbHlnb24nKSB7XG4gICAgICAgIHJpbmdzID0gW107XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBjb29yZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHJpbmdzLnB1c2gocHJvamVjdChjb29yZHNbaV0sIHRvbGVyYW5jZSkpO1xuICAgICAgICB9XG4gICAgICAgIGZlYXR1cmVzLnB1c2goY3JlYXRlKHRhZ3MsIHR5cGUgPT09ICdQb2x5Z29uJyA/IDMgOiAyLCByaW5ncykpO1xuXG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAnTXVsdGlQb2x5Z29uJykge1xuICAgICAgICByaW5ncyA9IFtdO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY29vcmRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgY29vcmRzW2ldLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgcmluZ3MucHVzaChwcm9qZWN0KGNvb3Jkc1tpXVtqXSwgdG9sZXJhbmNlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZmVhdHVyZXMucHVzaChjcmVhdGUodGFncywgMywgcmluZ3MpKTtcblxuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ0dlb21ldHJ5Q29sbGVjdGlvbicpIHtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGdlb20uZ2VvbWV0cmllcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29udmVydEZlYXR1cmUoZmVhdHVyZXMsIHtcbiAgICAgICAgICAgICAgICBnZW9tZXRyeTogZ2VvbS5nZW9tZXRyaWVzW2ldLFxuICAgICAgICAgICAgICAgIHByb3BlcnRpZXM6IHRhZ3NcbiAgICAgICAgICAgIH0sIHRvbGVyYW5jZSk7XG4gICAgICAgIH1cblxuICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW5wdXQgZGF0YSBpcyBub3QgYSB2YWxpZCBHZW9KU09OIG9iamVjdC4nKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZSh0YWdzLCB0eXBlLCBnZW9tZXRyeSkge1xuICAgIHZhciBmZWF0dXJlID0ge1xuICAgICAgICBnZW9tZXRyeTogZ2VvbWV0cnksXG4gICAgICAgIHR5cGU6IHR5cGUsXG4gICAgICAgIHRhZ3M6IHRhZ3MgfHwgbnVsbCxcbiAgICAgICAgbWluOiBbMiwgMV0sIC8vIGluaXRpYWwgYmJveCB2YWx1ZXM7XG4gICAgICAgIG1heDogWy0xLCAwXSAgLy8gbm90ZSB0aGF0IGNvb3JkcyBhcmUgdXN1YWxseSBpbiBbMC4uMV0gcmFuZ2VcbiAgICB9O1xuICAgIGNhbGNCQm94KGZlYXR1cmUpO1xuICAgIHJldHVybiBmZWF0dXJlO1xufVxuXG5mdW5jdGlvbiBwcm9qZWN0KGxvbmxhdHMsIHRvbGVyYW5jZSkge1xuICAgIHZhciBwcm9qZWN0ZWQgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxvbmxhdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcHJvamVjdGVkLnB1c2gocHJvamVjdFBvaW50KGxvbmxhdHNbaV0pKTtcbiAgICB9XG4gICAgaWYgKHRvbGVyYW5jZSkge1xuICAgICAgICBzaW1wbGlmeShwcm9qZWN0ZWQsIHRvbGVyYW5jZSk7XG4gICAgICAgIGNhbGNTaXplKHByb2plY3RlZCk7XG4gICAgfVxuICAgIHJldHVybiBwcm9qZWN0ZWQ7XG59XG5cbmZ1bmN0aW9uIHByb2plY3RQb2ludChwKSB7XG4gICAgdmFyIHNpbiA9IE1hdGguc2luKHBbMV0gKiBNYXRoLlBJIC8gMTgwKSxcbiAgICAgICAgeCA9IChwWzBdIC8gMzYwICsgMC41KSxcbiAgICAgICAgeSA9ICgwLjUgLSAwLjI1ICogTWF0aC5sb2coKDEgKyBzaW4pIC8gKDEgLSBzaW4pKSAvIE1hdGguUEkpO1xuXG4gICAgeSA9IHkgPCAtMSA/IC0xIDpcbiAgICAgICAgeSA+IDEgPyAxIDogeTtcblxuICAgIHJldHVybiBbeCwgeSwgMF07XG59XG5cbi8vIGNhbGN1bGF0ZSBhcmVhIGFuZCBsZW5ndGggb2YgdGhlIHBvbHlcbmZ1bmN0aW9uIGNhbGNTaXplKHBvaW50cykge1xuICAgIHZhciBhcmVhID0gMCxcbiAgICAgICAgZGlzdCA9IDA7XG5cbiAgICBmb3IgKHZhciBpID0gMCwgYSwgYjsgaSA8IHBvaW50cy5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgICAgYSA9IGIgfHwgcG9pbnRzW2ldO1xuICAgICAgICBiID0gcG9pbnRzW2kgKyAxXTtcblxuICAgICAgICBhcmVhICs9IGFbMF0gKiBiWzFdIC0gYlswXSAqIGFbMV07XG5cbiAgICAgICAgLy8gdXNlIE1hbmhhdHRhbiBkaXN0YW5jZSBpbnN0ZWFkIG9mIEV1Y2xpZGlhbiBvbmUgdG8gYXZvaWQgZXhwZW5zaXZlIHNxdWFyZSByb290IGNvbXB1dGF0aW9uXG4gICAgICAgIGRpc3QgKz0gTWF0aC5hYnMoYlswXSAtIGFbMF0pICsgTWF0aC5hYnMoYlsxXSAtIGFbMV0pO1xuICAgIH1cbiAgICBwb2ludHMuYXJlYSA9IE1hdGguYWJzKGFyZWEgLyAyKTtcbiAgICBwb2ludHMuZGlzdCA9IGRpc3Q7XG59XG5cbi8vIGNhbGN1bGF0ZSB0aGUgZmVhdHVyZSBib3VuZGluZyBib3ggZm9yIGZhc3RlciBjbGlwcGluZyBsYXRlclxuZnVuY3Rpb24gY2FsY0JCb3goZmVhdHVyZSkge1xuICAgIHZhciBnZW9tZXRyeSA9IGZlYXR1cmUuZ2VvbWV0cnksXG4gICAgICAgIG1pbiA9IGZlYXR1cmUubWluLFxuICAgICAgICBtYXggPSBmZWF0dXJlLm1heDtcblxuICAgIGlmIChmZWF0dXJlLnR5cGUgPT09IDEpIGNhbGNSaW5nQkJveChtaW4sIG1heCwgZ2VvbWV0cnkpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IDA7IGkgPCBnZW9tZXRyeS5sZW5ndGg7IGkrKykgY2FsY1JpbmdCQm94KG1pbiwgbWF4LCBnZW9tZXRyeVtpXSk7XG5cbiAgICByZXR1cm4gZmVhdHVyZTtcbn1cblxuZnVuY3Rpb24gY2FsY1JpbmdCQm94KG1pbiwgbWF4LCBwb2ludHMpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgcDsgaSA8IHBvaW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBwID0gcG9pbnRzW2ldO1xuICAgICAgICBtaW5bMF0gPSBNYXRoLm1pbihwWzBdLCBtaW5bMF0pO1xuICAgICAgICBtYXhbMF0gPSBNYXRoLm1heChwWzBdLCBtYXhbMF0pO1xuICAgICAgICBtaW5bMV0gPSBNYXRoLm1pbihwWzFdLCBtaW5bMV0pO1xuICAgICAgICBtYXhbMV0gPSBNYXRoLm1heChwWzFdLCBtYXhbMV0pO1xuICAgIH1cbn1cbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBnZW9qc29udnQ7XG5cbnZhciBjb252ZXJ0ID0gcmVxdWlyZSgnLi9jb252ZXJ0JyksICAgICAvLyBHZW9KU09OIGNvbnZlcnNpb24gYW5kIHByZXByb2Nlc3NpbmdcbiAgICB0cmFuc2Zvcm0gPSByZXF1aXJlKCcuL3RyYW5zZm9ybScpLCAvLyBjb29yZGluYXRlIHRyYW5zZm9ybWF0aW9uXG4gICAgY2xpcCA9IHJlcXVpcmUoJy4vY2xpcCcpLCAgICAgICAgICAgLy8gc3RyaXBlIGNsaXBwaW5nIGFsZ29yaXRobVxuICAgIHdyYXAgPSByZXF1aXJlKCcuL3dyYXAnKSwgICAgICAgICAgIC8vIGRhdGUgbGluZSBwcm9jZXNzaW5nXG4gICAgY3JlYXRlVGlsZSA9IHJlcXVpcmUoJy4vdGlsZScpOyAgICAgLy8gZmluYWwgc2ltcGxpZmllZCB0aWxlIGdlbmVyYXRpb25cblxuXG5mdW5jdGlvbiBnZW9qc29udnQoZGF0YSwgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgR2VvSlNPTlZUKGRhdGEsIG9wdGlvbnMpO1xufVxuXG5mdW5jdGlvbiBHZW9KU09OVlQoZGF0YSwgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMgPSBleHRlbmQoT2JqZWN0LmNyZWF0ZSh0aGlzLm9wdGlvbnMpLCBvcHRpb25zKTtcblxuICAgIHZhciBkZWJ1ZyA9IG9wdGlvbnMuZGVidWc7XG5cbiAgICBpZiAoZGVidWcpIGNvbnNvbGUudGltZSgncHJlcHJvY2VzcyBkYXRhJyk7XG5cbiAgICB2YXIgejIgPSAxIDw8IG9wdGlvbnMubWF4Wm9vbSwgLy8gMl56XG4gICAgICAgIGZlYXR1cmVzID0gY29udmVydChkYXRhLCBvcHRpb25zLnRvbGVyYW5jZSAvICh6MiAqIG9wdGlvbnMuZXh0ZW50KSk7XG5cbiAgICB0aGlzLnRpbGVzID0ge307XG4gICAgdGhpcy50aWxlQ29vcmRzID0gW107XG5cbiAgICBpZiAoZGVidWcpIHtcbiAgICAgICAgY29uc29sZS50aW1lRW5kKCdwcmVwcm9jZXNzIGRhdGEnKTtcbiAgICAgICAgY29uc29sZS5sb2coJ2luZGV4OiBtYXhab29tOiAlZCwgbWF4UG9pbnRzOiAlZCcsIG9wdGlvbnMuaW5kZXhNYXhab29tLCBvcHRpb25zLmluZGV4TWF4UG9pbnRzKTtcbiAgICAgICAgY29uc29sZS50aW1lKCdnZW5lcmF0ZSB0aWxlcycpO1xuICAgICAgICB0aGlzLnN0YXRzID0ge307XG4gICAgICAgIHRoaXMudG90YWwgPSAwO1xuICAgIH1cblxuICAgIGZlYXR1cmVzID0gd3JhcChmZWF0dXJlcywgb3B0aW9ucy5idWZmZXIgLyBvcHRpb25zLmV4dGVudCwgaW50ZXJzZWN0WCk7XG5cbiAgICAvLyBzdGFydCBzbGljaW5nIGZyb20gdGhlIHRvcCB0aWxlIGRvd25cbiAgICBpZiAoZmVhdHVyZXMubGVuZ3RoKSB0aGlzLnNwbGl0VGlsZShmZWF0dXJlcywgMCwgMCwgMCk7XG5cbiAgICBpZiAoZGVidWcpIHtcbiAgICAgICAgaWYgKGZlYXR1cmVzLmxlbmd0aCkgY29uc29sZS5sb2coJ2ZlYXR1cmVzOiAlZCwgcG9pbnRzOiAlZCcsIHRoaXMudGlsZXNbMF0ubnVtRmVhdHVyZXMsIHRoaXMudGlsZXNbMF0ubnVtUG9pbnRzKTtcbiAgICAgICAgY29uc29sZS50aW1lRW5kKCdnZW5lcmF0ZSB0aWxlcycpO1xuICAgICAgICBjb25zb2xlLmxvZygndGlsZXMgZ2VuZXJhdGVkOicsIHRoaXMudG90YWwsIEpTT04uc3RyaW5naWZ5KHRoaXMuc3RhdHMpKTtcbiAgICB9XG59XG5cbkdlb0pTT05WVC5wcm90b3R5cGUub3B0aW9ucyA9IHtcbiAgICBtYXhab29tOiAxNCwgICAgICAgICAgICAvLyBtYXggem9vbSB0byBwcmVzZXJ2ZSBkZXRhaWwgb25cbiAgICBpbmRleE1heFpvb206IDUsICAgICAgICAvLyBtYXggem9vbSBpbiB0aGUgdGlsZSBpbmRleFxuICAgIGluZGV4TWF4UG9pbnRzOiAxMDAwMDAsIC8vIG1heCBudW1iZXIgb2YgcG9pbnRzIHBlciB0aWxlIGluIHRoZSB0aWxlIGluZGV4XG4gICAgc29saWRDaGlsZHJlbjogZmFsc2UsICAgLy8gd2hldGhlciB0byB0aWxlIHNvbGlkIHNxdWFyZSB0aWxlcyBmdXJ0aGVyXG4gICAgdG9sZXJhbmNlOiAzLCAgICAgICAgICAgLy8gc2ltcGxpZmljYXRpb24gdG9sZXJhbmNlIChoaWdoZXIgbWVhbnMgc2ltcGxlcilcbiAgICBleHRlbnQ6IDQwOTYsICAgICAgICAgICAvLyB0aWxlIGV4dGVudFxuICAgIGJ1ZmZlcjogNjQsICAgICAgICAgICAgIC8vIHRpbGUgYnVmZmVyIG9uIGVhY2ggc2lkZVxuICAgIGRlYnVnOiAwICAgICAgICAgICAgICAgIC8vIGxvZ2dpbmcgbGV2ZWwgKDAsIDEgb3IgMilcbn07XG5cbkdlb0pTT05WVC5wcm90b3R5cGUuc3BsaXRUaWxlID0gZnVuY3Rpb24gKGZlYXR1cmVzLCB6LCB4LCB5LCBjeiwgY3gsIGN5KSB7XG5cbiAgICB2YXIgc3RhY2sgPSBbZmVhdHVyZXMsIHosIHgsIHldLFxuICAgICAgICBvcHRpb25zID0gdGhpcy5vcHRpb25zLFxuICAgICAgICBkZWJ1ZyA9IG9wdGlvbnMuZGVidWcsXG4gICAgICAgIHNvbGlkID0gbnVsbDtcblxuICAgIC8vIGF2b2lkIHJlY3Vyc2lvbiBieSB1c2luZyBhIHByb2Nlc3NpbmcgcXVldWVcbiAgICB3aGlsZSAoc3RhY2subGVuZ3RoKSB7XG4gICAgICAgIHkgPSBzdGFjay5wb3AoKTtcbiAgICAgICAgeCA9IHN0YWNrLnBvcCgpO1xuICAgICAgICB6ID0gc3RhY2sucG9wKCk7XG4gICAgICAgIGZlYXR1cmVzID0gc3RhY2sucG9wKCk7XG5cbiAgICAgICAgdmFyIHoyID0gMSA8PCB6LFxuICAgICAgICAgICAgaWQgPSB0b0lEKHosIHgsIHkpLFxuICAgICAgICAgICAgdGlsZSA9IHRoaXMudGlsZXNbaWRdLFxuICAgICAgICAgICAgdGlsZVRvbGVyYW5jZSA9IHogPT09IG9wdGlvbnMubWF4Wm9vbSA/IDAgOiBvcHRpb25zLnRvbGVyYW5jZSAvICh6MiAqIG9wdGlvbnMuZXh0ZW50KTtcblxuICAgICAgICBpZiAoIXRpbGUpIHtcbiAgICAgICAgICAgIGlmIChkZWJ1ZyA+IDEpIGNvbnNvbGUudGltZSgnY3JlYXRpb24nKTtcblxuICAgICAgICAgICAgdGlsZSA9IHRoaXMudGlsZXNbaWRdID0gY3JlYXRlVGlsZShmZWF0dXJlcywgejIsIHgsIHksIHRpbGVUb2xlcmFuY2UsIHogPT09IG9wdGlvbnMubWF4Wm9vbSk7XG4gICAgICAgICAgICB0aGlzLnRpbGVDb29yZHMucHVzaCh7ejogeiwgeDogeCwgeTogeX0pO1xuXG4gICAgICAgICAgICBpZiAoZGVidWcpIHtcbiAgICAgICAgICAgICAgICBpZiAoZGVidWcgPiAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCd0aWxlIHolZC0lZC0lZCAoZmVhdHVyZXM6ICVkLCBwb2ludHM6ICVkLCBzaW1wbGlmaWVkOiAlZCknLFxuICAgICAgICAgICAgICAgICAgICAgICAgeiwgeCwgeSwgdGlsZS5udW1GZWF0dXJlcywgdGlsZS5udW1Qb2ludHMsIHRpbGUubnVtU2ltcGxpZmllZCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUudGltZUVuZCgnY3JlYXRpb24nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIGtleSA9ICd6JyArIHo7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0c1trZXldID0gKHRoaXMuc3RhdHNba2V5XSB8fCAwKSArIDE7XG4gICAgICAgICAgICAgICAgdGhpcy50b3RhbCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gc2F2ZSByZWZlcmVuY2UgdG8gb3JpZ2luYWwgZ2VvbWV0cnkgaW4gdGlsZSBzbyB0aGF0IHdlIGNhbiBkcmlsbCBkb3duIGxhdGVyIGlmIHdlIHN0b3Agbm93XG4gICAgICAgIHRpbGUuc291cmNlID0gZmVhdHVyZXM7XG5cbiAgICAgICAgLy8gaWYgaXQncyB0aGUgZmlyc3QtcGFzcyB0aWxpbmdcbiAgICAgICAgaWYgKCFjeikge1xuICAgICAgICAgICAgLy8gc3RvcCB0aWxpbmcgaWYgd2UgcmVhY2hlZCBtYXggem9vbSwgb3IgaWYgdGhlIHRpbGUgaXMgdG9vIHNpbXBsZVxuICAgICAgICAgICAgaWYgKHogPT09IG9wdGlvbnMuaW5kZXhNYXhab29tIHx8IHRpbGUubnVtUG9pbnRzIDw9IG9wdGlvbnMuaW5kZXhNYXhQb2ludHMpIGNvbnRpbnVlO1xuXG4gICAgICAgIC8vIGlmIGEgZHJpbGxkb3duIHRvIGEgc3BlY2lmaWMgdGlsZVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gc3RvcCB0aWxpbmcgaWYgd2UgcmVhY2hlZCBiYXNlIHpvb20gb3Igb3VyIHRhcmdldCB0aWxlIHpvb21cbiAgICAgICAgICAgIGlmICh6ID09PSBvcHRpb25zLm1heFpvb20gfHwgeiA9PT0gY3opIGNvbnRpbnVlO1xuXG4gICAgICAgICAgICAvLyBzdG9wIHRpbGluZyBpZiBpdCdzIG5vdCBhbiBhbmNlc3RvciBvZiB0aGUgdGFyZ2V0IHRpbGVcbiAgICAgICAgICAgIHZhciBtID0gMSA8PCAoY3ogLSB6KTtcbiAgICAgICAgICAgIGlmICh4ICE9PSBNYXRoLmZsb29yKGN4IC8gbSkgfHwgeSAhPT0gTWF0aC5mbG9vcihjeSAvIG0pKSBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHN0b3AgdGlsaW5nIGlmIHRoZSB0aWxlIGlzIHNvbGlkIGNsaXBwZWQgc3F1YXJlXG4gICAgICAgIGlmICghb3B0aW9ucy5zb2xpZENoaWxkcmVuICYmIGlzQ2xpcHBlZFNxdWFyZSh0aWxlLCBvcHRpb25zLmV4dGVudCwgb3B0aW9ucy5idWZmZXIpKSB7XG4gICAgICAgICAgICBpZiAoY3opIHNvbGlkID0gejsgLy8gYW5kIHJlbWVtYmVyIHRoZSB6b29tIGlmIHdlJ3JlIGRyaWxsaW5nIGRvd25cbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gaWYgd2Ugc2xpY2UgZnVydGhlciBkb3duLCBubyBuZWVkIHRvIGtlZXAgc291cmNlIGdlb21ldHJ5XG4gICAgICAgIHRpbGUuc291cmNlID0gbnVsbDtcblxuICAgICAgICBpZiAoZGVidWcgPiAxKSBjb25zb2xlLnRpbWUoJ2NsaXBwaW5nJyk7XG5cbiAgICAgICAgLy8gdmFsdWVzIHdlJ2xsIHVzZSBmb3IgY2xpcHBpbmdcbiAgICAgICAgdmFyIGsxID0gMC41ICogb3B0aW9ucy5idWZmZXIgLyBvcHRpb25zLmV4dGVudCxcbiAgICAgICAgICAgIGsyID0gMC41IC0gazEsXG4gICAgICAgICAgICBrMyA9IDAuNSArIGsxLFxuICAgICAgICAgICAgazQgPSAxICsgazEsXG4gICAgICAgICAgICB0bCwgYmwsIHRyLCBiciwgbGVmdCwgcmlnaHQ7XG5cbiAgICAgICAgdGwgPSBibCA9IHRyID0gYnIgPSBudWxsO1xuXG4gICAgICAgIGxlZnQgID0gY2xpcChmZWF0dXJlcywgejIsIHggLSBrMSwgeCArIGszLCAwLCBpbnRlcnNlY3RYLCB0aWxlLm1pblswXSwgdGlsZS5tYXhbMF0pO1xuICAgICAgICByaWdodCA9IGNsaXAoZmVhdHVyZXMsIHoyLCB4ICsgazIsIHggKyBrNCwgMCwgaW50ZXJzZWN0WCwgdGlsZS5taW5bMF0sIHRpbGUubWF4WzBdKTtcblxuICAgICAgICBpZiAobGVmdCkge1xuICAgICAgICAgICAgdGwgPSBjbGlwKGxlZnQsIHoyLCB5IC0gazEsIHkgKyBrMywgMSwgaW50ZXJzZWN0WSwgdGlsZS5taW5bMV0sIHRpbGUubWF4WzFdKTtcbiAgICAgICAgICAgIGJsID0gY2xpcChsZWZ0LCB6MiwgeSArIGsyLCB5ICsgazQsIDEsIGludGVyc2VjdFksIHRpbGUubWluWzFdLCB0aWxlLm1heFsxXSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocmlnaHQpIHtcbiAgICAgICAgICAgIHRyID0gY2xpcChyaWdodCwgejIsIHkgLSBrMSwgeSArIGszLCAxLCBpbnRlcnNlY3RZLCB0aWxlLm1pblsxXSwgdGlsZS5tYXhbMV0pO1xuICAgICAgICAgICAgYnIgPSBjbGlwKHJpZ2h0LCB6MiwgeSArIGsyLCB5ICsgazQsIDEsIGludGVyc2VjdFksIHRpbGUubWluWzFdLCB0aWxlLm1heFsxXSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZGVidWcgPiAxKSBjb25zb2xlLnRpbWVFbmQoJ2NsaXBwaW5nJyk7XG5cbiAgICAgICAgaWYgKHRsKSBzdGFjay5wdXNoKHRsLCB6ICsgMSwgeCAqIDIsICAgICB5ICogMik7XG4gICAgICAgIGlmIChibCkgc3RhY2sucHVzaChibCwgeiArIDEsIHggKiAyLCAgICAgeSAqIDIgKyAxKTtcbiAgICAgICAgaWYgKHRyKSBzdGFjay5wdXNoKHRyLCB6ICsgMSwgeCAqIDIgKyAxLCB5ICogMik7XG4gICAgICAgIGlmIChicikgc3RhY2sucHVzaChiciwgeiArIDEsIHggKiAyICsgMSwgeSAqIDIgKyAxKTtcbiAgICB9XG5cbiAgICByZXR1cm4gc29saWQ7XG59O1xuXG5HZW9KU09OVlQucHJvdG90eXBlLmdldFRpbGUgPSBmdW5jdGlvbiAoeiwgeCwgeSkge1xuICAgIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zLFxuICAgICAgICBleHRlbnQgPSBvcHRpb25zLmV4dGVudCxcbiAgICAgICAgZGVidWcgPSBvcHRpb25zLmRlYnVnO1xuXG4gICAgdmFyIHoyID0gMSA8PCB6O1xuICAgIHggPSAoKHggJSB6MikgKyB6MikgJSB6MjsgLy8gd3JhcCB0aWxlIHggY29vcmRpbmF0ZVxuXG4gICAgdmFyIGlkID0gdG9JRCh6LCB4LCB5KTtcbiAgICBpZiAodGhpcy50aWxlc1tpZF0pIHJldHVybiB0cmFuc2Zvcm0udGlsZSh0aGlzLnRpbGVzW2lkXSwgZXh0ZW50KTtcblxuICAgIGlmIChkZWJ1ZyA+IDEpIGNvbnNvbGUubG9nKCdkcmlsbGluZyBkb3duIHRvIHolZC0lZC0lZCcsIHosIHgsIHkpO1xuXG4gICAgdmFyIHowID0geixcbiAgICAgICAgeDAgPSB4LFxuICAgICAgICB5MCA9IHksXG4gICAgICAgIHBhcmVudDtcblxuICAgIHdoaWxlICghcGFyZW50ICYmIHowID4gMCkge1xuICAgICAgICB6MC0tO1xuICAgICAgICB4MCA9IE1hdGguZmxvb3IoeDAgLyAyKTtcbiAgICAgICAgeTAgPSBNYXRoLmZsb29yKHkwIC8gMik7XG4gICAgICAgIHBhcmVudCA9IHRoaXMudGlsZXNbdG9JRCh6MCwgeDAsIHkwKV07XG4gICAgfVxuXG4gICAgaWYgKCFwYXJlbnQgfHwgIXBhcmVudC5zb3VyY2UpIHJldHVybiBudWxsO1xuXG4gICAgLy8gaWYgd2UgZm91bmQgYSBwYXJlbnQgdGlsZSBjb250YWluaW5nIHRoZSBvcmlnaW5hbCBnZW9tZXRyeSwgd2UgY2FuIGRyaWxsIGRvd24gZnJvbSBpdFxuICAgIGlmIChkZWJ1ZyA+IDEpIGNvbnNvbGUubG9nKCdmb3VuZCBwYXJlbnQgdGlsZSB6JWQtJWQtJWQnLCB6MCwgeDAsIHkwKTtcblxuICAgIC8vIGl0IHBhcmVudCB0aWxlIGlzIGEgc29saWQgY2xpcHBlZCBzcXVhcmUsIHJldHVybiBpdCBpbnN0ZWFkIHNpbmNlIGl0J3MgaWRlbnRpY2FsXG4gICAgaWYgKGlzQ2xpcHBlZFNxdWFyZShwYXJlbnQsIGV4dGVudCwgb3B0aW9ucy5idWZmZXIpKSByZXR1cm4gdHJhbnNmb3JtLnRpbGUocGFyZW50LCBleHRlbnQpO1xuXG4gICAgaWYgKGRlYnVnID4gMSkgY29uc29sZS50aW1lKCdkcmlsbGluZyBkb3duJyk7XG4gICAgdmFyIHNvbGlkID0gdGhpcy5zcGxpdFRpbGUocGFyZW50LnNvdXJjZSwgejAsIHgwLCB5MCwgeiwgeCwgeSk7XG4gICAgaWYgKGRlYnVnID4gMSkgY29uc29sZS50aW1lRW5kKCdkcmlsbGluZyBkb3duJyk7XG5cbiAgICAvLyBvbmUgb2YgdGhlIHBhcmVudCB0aWxlcyB3YXMgYSBzb2xpZCBjbGlwcGVkIHNxdWFyZVxuICAgIGlmIChzb2xpZCAhPT0gbnVsbCkge1xuICAgICAgICB2YXIgbSA9IDEgPDwgKHogLSBzb2xpZCk7XG4gICAgICAgIGlkID0gdG9JRChzb2xpZCwgTWF0aC5mbG9vcih4IC8gbSksIE1hdGguZmxvb3IoeSAvIG0pKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy50aWxlc1tpZF0gPyB0cmFuc2Zvcm0udGlsZSh0aGlzLnRpbGVzW2lkXSwgZXh0ZW50KSA6IG51bGw7XG59O1xuXG5mdW5jdGlvbiB0b0lEKHosIHgsIHkpIHtcbiAgICByZXR1cm4gKCgoMSA8PCB6KSAqIHkgKyB4KSAqIDMyKSArIHo7XG59XG5cbmZ1bmN0aW9uIGludGVyc2VjdFgoYSwgYiwgeCkge1xuICAgIHJldHVybiBbeCwgKHggLSBhWzBdKSAqIChiWzFdIC0gYVsxXSkgLyAoYlswXSAtIGFbMF0pICsgYVsxXSwgMV07XG59XG5mdW5jdGlvbiBpbnRlcnNlY3RZKGEsIGIsIHkpIHtcbiAgICByZXR1cm4gWyh5IC0gYVsxXSkgKiAoYlswXSAtIGFbMF0pIC8gKGJbMV0gLSBhWzFdKSArIGFbMF0sIHksIDFdO1xufVxuXG5mdW5jdGlvbiBleHRlbmQoZGVzdCwgc3JjKSB7XG4gICAgZm9yICh2YXIgaSBpbiBzcmMpIGRlc3RbaV0gPSBzcmNbaV07XG4gICAgcmV0dXJuIGRlc3Q7XG59XG5cbi8vIGNoZWNrcyB3aGV0aGVyIGEgdGlsZSBpcyBhIHdob2xlLWFyZWEgZmlsbCBhZnRlciBjbGlwcGluZzsgaWYgaXQgaXMsIHRoZXJlJ3Mgbm8gc2Vuc2Ugc2xpY2luZyBpdCBmdXJ0aGVyXG5mdW5jdGlvbiBpc0NsaXBwZWRTcXVhcmUodGlsZSwgZXh0ZW50LCBidWZmZXIpIHtcblxuICAgIHZhciBmZWF0dXJlcyA9IHRpbGUuc291cmNlO1xuICAgIGlmIChmZWF0dXJlcy5sZW5ndGggIT09IDEpIHJldHVybiBmYWxzZTtcblxuICAgIHZhciBmZWF0dXJlID0gZmVhdHVyZXNbMF07XG4gICAgaWYgKGZlYXR1cmUudHlwZSAhPT0gMyB8fCBmZWF0dXJlLmdlb21ldHJ5Lmxlbmd0aCA+IDEpIHJldHVybiBmYWxzZTtcblxuICAgIHZhciBsZW4gPSBmZWF0dXJlLmdlb21ldHJ5WzBdLmxlbmd0aDtcbiAgICBpZiAobGVuICE9PSA1KSByZXR1cm4gZmFsc2U7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHZhciBwID0gdHJhbnNmb3JtLnBvaW50KGZlYXR1cmUuZ2VvbWV0cnlbMF1baV0sIGV4dGVudCwgdGlsZS56MiwgdGlsZS54LCB0aWxlLnkpO1xuICAgICAgICBpZiAoKHBbMF0gIT09IC1idWZmZXIgJiYgcFswXSAhPT0gZXh0ZW50ICsgYnVmZmVyKSB8fFxuICAgICAgICAgICAgKHBbMV0gIT09IC1idWZmZXIgJiYgcFsxXSAhPT0gZXh0ZW50ICsgYnVmZmVyKSkgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHNpbXBsaWZ5O1xuXG4vLyBjYWxjdWxhdGUgc2ltcGxpZmljYXRpb24gZGF0YSB1c2luZyBvcHRpbWl6ZWQgRG91Z2xhcy1QZXVja2VyIGFsZ29yaXRobVxuXG5mdW5jdGlvbiBzaW1wbGlmeShwb2ludHMsIHRvbGVyYW5jZSkge1xuXG4gICAgdmFyIHNxVG9sZXJhbmNlID0gdG9sZXJhbmNlICogdG9sZXJhbmNlLFxuICAgICAgICBsZW4gPSBwb2ludHMubGVuZ3RoLFxuICAgICAgICBmaXJzdCA9IDAsXG4gICAgICAgIGxhc3QgPSBsZW4gLSAxLFxuICAgICAgICBzdGFjayA9IFtdLFxuICAgICAgICBpLCBtYXhTcURpc3QsIHNxRGlzdCwgaW5kZXg7XG5cbiAgICAvLyBhbHdheXMgcmV0YWluIHRoZSBlbmRwb2ludHMgKDEgaXMgdGhlIG1heCB2YWx1ZSlcbiAgICBwb2ludHNbZmlyc3RdWzJdID0gMTtcbiAgICBwb2ludHNbbGFzdF1bMl0gPSAxO1xuXG4gICAgLy8gYXZvaWQgcmVjdXJzaW9uIGJ5IHVzaW5nIGEgc3RhY2tcbiAgICB3aGlsZSAobGFzdCkge1xuXG4gICAgICAgIG1heFNxRGlzdCA9IDA7XG5cbiAgICAgICAgZm9yIChpID0gZmlyc3QgKyAxOyBpIDwgbGFzdDsgaSsrKSB7XG4gICAgICAgICAgICBzcURpc3QgPSBnZXRTcVNlZ0Rpc3QocG9pbnRzW2ldLCBwb2ludHNbZmlyc3RdLCBwb2ludHNbbGFzdF0pO1xuXG4gICAgICAgICAgICBpZiAoc3FEaXN0ID4gbWF4U3FEaXN0KSB7XG4gICAgICAgICAgICAgICAgaW5kZXggPSBpO1xuICAgICAgICAgICAgICAgIG1heFNxRGlzdCA9IHNxRGlzdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtYXhTcURpc3QgPiBzcVRvbGVyYW5jZSkge1xuICAgICAgICAgICAgcG9pbnRzW2luZGV4XVsyXSA9IG1heFNxRGlzdDsgLy8gc2F2ZSB0aGUgcG9pbnQgaW1wb3J0YW5jZSBpbiBzcXVhcmVkIHBpeGVscyBhcyBhIHogY29vcmRpbmF0ZVxuICAgICAgICAgICAgc3RhY2sucHVzaChmaXJzdCk7XG4gICAgICAgICAgICBzdGFjay5wdXNoKGluZGV4KTtcbiAgICAgICAgICAgIGZpcnN0ID0gaW5kZXg7XG5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxhc3QgPSBzdGFjay5wb3AoKTtcbiAgICAgICAgICAgIGZpcnN0ID0gc3RhY2sucG9wKCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8vIHNxdWFyZSBkaXN0YW5jZSBmcm9tIGEgcG9pbnQgdG8gYSBzZWdtZW50XG5mdW5jdGlvbiBnZXRTcVNlZ0Rpc3QocCwgYSwgYikge1xuXG4gICAgdmFyIHggPSBhWzBdLCB5ID0gYVsxXSxcbiAgICAgICAgYnggPSBiWzBdLCBieSA9IGJbMV0sXG4gICAgICAgIHB4ID0gcFswXSwgcHkgPSBwWzFdLFxuICAgICAgICBkeCA9IGJ4IC0geCxcbiAgICAgICAgZHkgPSBieSAtIHk7XG5cbiAgICBpZiAoZHggIT09IDAgfHwgZHkgIT09IDApIHtcblxuICAgICAgICB2YXIgdCA9ICgocHggLSB4KSAqIGR4ICsgKHB5IC0geSkgKiBkeSkgLyAoZHggKiBkeCArIGR5ICogZHkpO1xuXG4gICAgICAgIGlmICh0ID4gMSkge1xuICAgICAgICAgICAgeCA9IGJ4O1xuICAgICAgICAgICAgeSA9IGJ5O1xuXG4gICAgICAgIH0gZWxzZSBpZiAodCA+IDApIHtcbiAgICAgICAgICAgIHggKz0gZHggKiB0O1xuICAgICAgICAgICAgeSArPSBkeSAqIHQ7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBkeCA9IHB4IC0geDtcbiAgICBkeSA9IHB5IC0geTtcblxuICAgIHJldHVybiBkeCAqIGR4ICsgZHkgKiBkeTtcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVUaWxlO1xuXG5mdW5jdGlvbiBjcmVhdGVUaWxlKGZlYXR1cmVzLCB6MiwgdHgsIHR5LCB0b2xlcmFuY2UsIG5vU2ltcGxpZnkpIHtcbiAgICB2YXIgdGlsZSA9IHtcbiAgICAgICAgZmVhdHVyZXM6IFtdLFxuICAgICAgICBudW1Qb2ludHM6IDAsXG4gICAgICAgIG51bVNpbXBsaWZpZWQ6IDAsXG4gICAgICAgIG51bUZlYXR1cmVzOiAwLFxuICAgICAgICBzb3VyY2U6IG51bGwsXG4gICAgICAgIHg6IHR4LFxuICAgICAgICB5OiB0eSxcbiAgICAgICAgejI6IHoyLFxuICAgICAgICB0cmFuc2Zvcm1lZDogZmFsc2UsXG4gICAgICAgIG1pbjogWzIsIDFdLFxuICAgICAgICBtYXg6IFstMSwgMF1cbiAgICB9O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZmVhdHVyZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGlsZS5udW1GZWF0dXJlcysrO1xuICAgICAgICBhZGRGZWF0dXJlKHRpbGUsIGZlYXR1cmVzW2ldLCB0b2xlcmFuY2UsIG5vU2ltcGxpZnkpO1xuXG4gICAgICAgIHZhciBtaW4gPSBmZWF0dXJlc1tpXS5taW4sXG4gICAgICAgICAgICBtYXggPSBmZWF0dXJlc1tpXS5tYXg7XG5cbiAgICAgICAgaWYgKG1pblswXSA8IHRpbGUubWluWzBdKSB0aWxlLm1pblswXSA9IG1pblswXTtcbiAgICAgICAgaWYgKG1pblsxXSA8IHRpbGUubWluWzFdKSB0aWxlLm1pblsxXSA9IG1pblsxXTtcbiAgICAgICAgaWYgKG1heFswXSA+IHRpbGUubWF4WzBdKSB0aWxlLm1heFswXSA9IG1heFswXTtcbiAgICAgICAgaWYgKG1heFsxXSA+IHRpbGUubWF4WzFdKSB0aWxlLm1heFsxXSA9IG1heFsxXTtcbiAgICB9XG4gICAgcmV0dXJuIHRpbGU7XG59XG5cbmZ1bmN0aW9uIGFkZEZlYXR1cmUodGlsZSwgZmVhdHVyZSwgdG9sZXJhbmNlLCBub1NpbXBsaWZ5KSB7XG5cbiAgICB2YXIgZ2VvbSA9IGZlYXR1cmUuZ2VvbWV0cnksXG4gICAgICAgIHR5cGUgPSBmZWF0dXJlLnR5cGUsXG4gICAgICAgIHNpbXBsaWZpZWQgPSBbXSxcbiAgICAgICAgc3FUb2xlcmFuY2UgPSB0b2xlcmFuY2UgKiB0b2xlcmFuY2UsXG4gICAgICAgIGksIGosIHJpbmcsIHA7XG5cbiAgICBpZiAodHlwZSA9PT0gMSkge1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgZ2VvbS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgc2ltcGxpZmllZC5wdXNoKGdlb21baV0pO1xuICAgICAgICAgICAgdGlsZS5udW1Qb2ludHMrKztcbiAgICAgICAgICAgIHRpbGUubnVtU2ltcGxpZmllZCsrO1xuICAgICAgICB9XG5cbiAgICB9IGVsc2Uge1xuXG4gICAgICAgIC8vIHNpbXBsaWZ5IGFuZCB0cmFuc2Zvcm0gcHJvamVjdGVkIGNvb3JkaW5hdGVzIGZvciB0aWxlIGdlb21ldHJ5XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBnZW9tLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICByaW5nID0gZ2VvbVtpXTtcblxuICAgICAgICAgICAgLy8gZmlsdGVyIG91dCB0aW55IHBvbHlsaW5lcyAmIHBvbHlnb25zXG4gICAgICAgICAgICBpZiAoIW5vU2ltcGxpZnkgJiYgKCh0eXBlID09PSAyICYmIHJpbmcuZGlzdCA8IHRvbGVyYW5jZSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKHR5cGUgPT09IDMgJiYgcmluZy5hcmVhIDwgc3FUb2xlcmFuY2UpKSkge1xuICAgICAgICAgICAgICAgIHRpbGUubnVtUG9pbnRzICs9IHJpbmcubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgc2ltcGxpZmllZFJpbmcgPSBbXTtcblxuICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IHJpbmcubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICBwID0gcmluZ1tqXTtcbiAgICAgICAgICAgICAgICAvLyBrZWVwIHBvaW50cyB3aXRoIGltcG9ydGFuY2UgPiB0b2xlcmFuY2VcbiAgICAgICAgICAgICAgICBpZiAobm9TaW1wbGlmeSB8fCBwWzJdID4gc3FUb2xlcmFuY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgc2ltcGxpZmllZFJpbmcucHVzaChwKTtcbiAgICAgICAgICAgICAgICAgICAgdGlsZS5udW1TaW1wbGlmaWVkKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRpbGUubnVtUG9pbnRzKys7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHNpbXBsaWZpZWQucHVzaChzaW1wbGlmaWVkUmluZyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoc2ltcGxpZmllZC5sZW5ndGgpIHtcbiAgICAgICAgdGlsZS5mZWF0dXJlcy5wdXNoKHtcbiAgICAgICAgICAgIGdlb21ldHJ5OiBzaW1wbGlmaWVkLFxuICAgICAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAgICAgIHRhZ3M6IGZlYXR1cmUudGFncyB8fCBudWxsXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbiIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy50aWxlID0gdHJhbnNmb3JtVGlsZTtcbmV4cG9ydHMucG9pbnQgPSB0cmFuc2Zvcm1Qb2ludDtcblxuLy8gVHJhbnNmb3JtcyB0aGUgY29vcmRpbmF0ZXMgb2YgZWFjaCBmZWF0dXJlIGluIHRoZSBnaXZlbiB0aWxlIGZyb21cbi8vIG1lcmNhdG9yLXByb2plY3RlZCBzcGFjZSBpbnRvIChleHRlbnQgeCBleHRlbnQpIHRpbGUgc3BhY2UuXG5mdW5jdGlvbiB0cmFuc2Zvcm1UaWxlKHRpbGUsIGV4dGVudCkge1xuICAgIGlmICh0aWxlLnRyYW5zZm9ybWVkKSByZXR1cm4gdGlsZTtcblxuICAgIHZhciB6MiA9IHRpbGUuejIsXG4gICAgICAgIHR4ID0gdGlsZS54LFxuICAgICAgICB0eSA9IHRpbGUueSxcbiAgICAgICAgaSwgaiwgaztcblxuICAgIGZvciAoaSA9IDA7IGkgPCB0aWxlLmZlYXR1cmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBmZWF0dXJlID0gdGlsZS5mZWF0dXJlc1tpXSxcbiAgICAgICAgICAgIGdlb20gPSBmZWF0dXJlLmdlb21ldHJ5LFxuICAgICAgICAgICAgdHlwZSA9IGZlYXR1cmUudHlwZTtcblxuICAgICAgICBpZiAodHlwZSA9PT0gMSkge1xuICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IGdlb20ubGVuZ3RoOyBqKyspIGdlb21bal0gPSB0cmFuc2Zvcm1Qb2ludChnZW9tW2pdLCBleHRlbnQsIHoyLCB0eCwgdHkpO1xuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgZ2VvbS5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgIHZhciByaW5nID0gZ2VvbVtqXTtcbiAgICAgICAgICAgICAgICBmb3IgKGsgPSAwOyBrIDwgcmluZy5sZW5ndGg7IGsrKykgcmluZ1trXSA9IHRyYW5zZm9ybVBvaW50KHJpbmdba10sIGV4dGVudCwgejIsIHR4LCB0eSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB0aWxlLnRyYW5zZm9ybWVkID0gdHJ1ZTtcblxuICAgIHJldHVybiB0aWxlO1xufVxuXG5mdW5jdGlvbiB0cmFuc2Zvcm1Qb2ludChwLCBleHRlbnQsIHoyLCB0eCwgdHkpIHtcbiAgICB2YXIgeCA9IE1hdGgucm91bmQoZXh0ZW50ICogKHBbMF0gKiB6MiAtIHR4KSksXG4gICAgICAgIHkgPSBNYXRoLnJvdW5kKGV4dGVudCAqIChwWzFdICogejIgLSB0eSkpO1xuICAgIHJldHVybiBbeCwgeV07XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBjbGlwID0gcmVxdWlyZSgnLi9jbGlwJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gd3JhcDtcblxuZnVuY3Rpb24gd3JhcChmZWF0dXJlcywgYnVmZmVyLCBpbnRlcnNlY3RYKSB7XG4gICAgdmFyIG1lcmdlZCA9IGZlYXR1cmVzLFxuICAgICAgICBsZWZ0ICA9IGNsaXAoZmVhdHVyZXMsIDEsIC0xIC0gYnVmZmVyLCBidWZmZXIsICAgICAwLCBpbnRlcnNlY3RYLCAtMSwgMiksIC8vIGxlZnQgd29ybGQgY29weVxuICAgICAgICByaWdodCA9IGNsaXAoZmVhdHVyZXMsIDEsICAxIC0gYnVmZmVyLCAyICsgYnVmZmVyLCAwLCBpbnRlcnNlY3RYLCAtMSwgMik7IC8vIHJpZ2h0IHdvcmxkIGNvcHlcblxuICAgIGlmIChsZWZ0IHx8IHJpZ2h0KSB7XG4gICAgICAgIG1lcmdlZCA9IGNsaXAoZmVhdHVyZXMsIDEsIC1idWZmZXIsIDEgKyBidWZmZXIsIDAsIGludGVyc2VjdFgsIC0xLCAyKTsgLy8gY2VudGVyIHdvcmxkIGNvcHlcblxuICAgICAgICBpZiAobGVmdCkgbWVyZ2VkID0gc2hpZnRGZWF0dXJlQ29vcmRzKGxlZnQsIDEpLmNvbmNhdChtZXJnZWQpOyAvLyBtZXJnZSBsZWZ0IGludG8gY2VudGVyXG4gICAgICAgIGlmIChyaWdodCkgbWVyZ2VkID0gbWVyZ2VkLmNvbmNhdChzaGlmdEZlYXR1cmVDb29yZHMocmlnaHQsIC0xKSk7IC8vIG1lcmdlIHJpZ2h0IGludG8gY2VudGVyXG4gICAgfVxuXG4gICAgcmV0dXJuIG1lcmdlZDtcbn1cblxuZnVuY3Rpb24gc2hpZnRGZWF0dXJlQ29vcmRzKGZlYXR1cmVzLCBvZmZzZXQpIHtcbiAgICB2YXIgbmV3RmVhdHVyZXMgPSBbXTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZmVhdHVyZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGZlYXR1cmUgPSBmZWF0dXJlc1tpXSxcbiAgICAgICAgICAgIHR5cGUgPSBmZWF0dXJlLnR5cGU7XG5cbiAgICAgICAgdmFyIG5ld0dlb21ldHJ5O1xuXG4gICAgICAgIGlmICh0eXBlID09PSAxKSB7XG4gICAgICAgICAgICBuZXdHZW9tZXRyeSA9IHNoaWZ0Q29vcmRzKGZlYXR1cmUuZ2VvbWV0cnksIG9mZnNldCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBuZXdHZW9tZXRyeSA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBmZWF0dXJlLmdlb21ldHJ5Lmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgbmV3R2VvbWV0cnkucHVzaChzaGlmdENvb3JkcyhmZWF0dXJlLmdlb21ldHJ5W2pdLCBvZmZzZXQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIG5ld0ZlYXR1cmVzLnB1c2goe1xuICAgICAgICAgICAgZ2VvbWV0cnk6IG5ld0dlb21ldHJ5LFxuICAgICAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAgICAgIHRhZ3M6IGZlYXR1cmUudGFncyxcbiAgICAgICAgICAgIG1pbjogW2ZlYXR1cmUubWluWzBdICsgb2Zmc2V0LCBmZWF0dXJlLm1pblsxXV0sXG4gICAgICAgICAgICBtYXg6IFtmZWF0dXJlLm1heFswXSArIG9mZnNldCwgZmVhdHVyZS5tYXhbMV1dXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBuZXdGZWF0dXJlcztcbn1cblxuZnVuY3Rpb24gc2hpZnRDb29yZHMocG9pbnRzLCBvZmZzZXQpIHtcbiAgICB2YXIgbmV3UG9pbnRzID0gW107XG4gICAgbmV3UG9pbnRzLmFyZWEgPSBwb2ludHMuYXJlYTtcbiAgICBuZXdQb2ludHMuZGlzdCA9IHBvaW50cy5kaXN0O1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwb2ludHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbmV3UG9pbnRzLnB1c2goW3BvaW50c1tpXVswXSArIG9mZnNldCwgcG9pbnRzW2ldWzFdLCBwb2ludHNbaV1bMl1dKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ld1BvaW50cztcbn1cbiIsIi8qKlxuICogQGZpbGVvdmVydmlldyBnbC1tYXRyaXggLSBIaWdoIHBlcmZvcm1hbmNlIG1hdHJpeCBhbmQgdmVjdG9yIG9wZXJhdGlvbnNcbiAqIEBhdXRob3IgQnJhbmRvbiBKb25lc1xuICogQGF1dGhvciBDb2xpbiBNYWNLZW56aWUgSVZcbiAqIEB2ZXJzaW9uIDIuMy4yXG4gKi9cblxuLyogQ29weXJpZ2h0IChjKSAyMDE1LCBCcmFuZG9uIEpvbmVzLCBDb2xpbiBNYWNLZW56aWUgSVYuXG5cblBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbm9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbmluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbnRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbmNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblxuVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbmFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG5JTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbkZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbk9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cblRIRSBTT0ZUV0FSRS4gKi9cbi8vIEVORCBIRUFERVJcblxuZXhwb3J0cy5nbE1hdHJpeCA9IHJlcXVpcmUoXCIuL2dsLW1hdHJpeC9jb21tb24uanNcIik7XG5leHBvcnRzLm1hdDIgPSByZXF1aXJlKFwiLi9nbC1tYXRyaXgvbWF0Mi5qc1wiKTtcbmV4cG9ydHMubWF0MmQgPSByZXF1aXJlKFwiLi9nbC1tYXRyaXgvbWF0MmQuanNcIik7XG5leHBvcnRzLm1hdDMgPSByZXF1aXJlKFwiLi9nbC1tYXRyaXgvbWF0My5qc1wiKTtcbmV4cG9ydHMubWF0NCA9IHJlcXVpcmUoXCIuL2dsLW1hdHJpeC9tYXQ0LmpzXCIpO1xuZXhwb3J0cy5xdWF0ID0gcmVxdWlyZShcIi4vZ2wtbWF0cml4L3F1YXQuanNcIik7XG5leHBvcnRzLnZlYzIgPSByZXF1aXJlKFwiLi9nbC1tYXRyaXgvdmVjMi5qc1wiKTtcbmV4cG9ydHMudmVjMyA9IHJlcXVpcmUoXCIuL2dsLW1hdHJpeC92ZWMzLmpzXCIpO1xuZXhwb3J0cy52ZWM0ID0gcmVxdWlyZShcIi4vZ2wtbWF0cml4L3ZlYzQuanNcIik7IiwiLyogQ29weXJpZ2h0IChjKSAyMDE1LCBCcmFuZG9uIEpvbmVzLCBDb2xpbiBNYWNLZW56aWUgSVYuXG5cblBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbm9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbmluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbnRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbmNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblxuVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbmFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG5JTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbkZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbk9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cblRIRSBTT0ZUV0FSRS4gKi9cblxuLyoqXG4gKiBAY2xhc3MgQ29tbW9uIHV0aWxpdGllc1xuICogQG5hbWUgZ2xNYXRyaXhcbiAqL1xudmFyIGdsTWF0cml4ID0ge307XG5cbi8vIENvbmZpZ3VyYXRpb24gQ29uc3RhbnRzXG5nbE1hdHJpeC5FUFNJTE9OID0gMC4wMDAwMDE7XG5nbE1hdHJpeC5BUlJBWV9UWVBFID0gKHR5cGVvZiBGbG9hdDMyQXJyYXkgIT09ICd1bmRlZmluZWQnKSA/IEZsb2F0MzJBcnJheSA6IEFycmF5O1xuZ2xNYXRyaXguUkFORE9NID0gTWF0aC5yYW5kb207XG5nbE1hdHJpeC5FTkFCTEVfU0lNRCA9IGZhbHNlO1xuXG4vLyBDYXBhYmlsaXR5IGRldGVjdGlvblxuZ2xNYXRyaXguU0lNRF9BVkFJTEFCTEUgPSAoZ2xNYXRyaXguQVJSQVlfVFlQRSA9PT0gRmxvYXQzMkFycmF5KSAmJiAoJ1NJTUQnIGluIHRoaXMpO1xuZ2xNYXRyaXguVVNFX1NJTUQgPSBnbE1hdHJpeC5FTkFCTEVfU0lNRCAmJiBnbE1hdHJpeC5TSU1EX0FWQUlMQUJMRTtcblxuLyoqXG4gKiBTZXRzIHRoZSB0eXBlIG9mIGFycmF5IHVzZWQgd2hlbiBjcmVhdGluZyBuZXcgdmVjdG9ycyBhbmQgbWF0cmljZXNcbiAqXG4gKiBAcGFyYW0ge1R5cGV9IHR5cGUgQXJyYXkgdHlwZSwgc3VjaCBhcyBGbG9hdDMyQXJyYXkgb3IgQXJyYXlcbiAqL1xuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlID0gZnVuY3Rpb24odHlwZSkge1xuICAgIGdsTWF0cml4LkFSUkFZX1RZUEUgPSB0eXBlO1xufVxuXG52YXIgZGVncmVlID0gTWF0aC5QSSAvIDE4MDtcblxuLyoqXG4qIENvbnZlcnQgRGVncmVlIFRvIFJhZGlhblxuKlxuKiBAcGFyYW0ge051bWJlcn0gQW5nbGUgaW4gRGVncmVlc1xuKi9cbmdsTWF0cml4LnRvUmFkaWFuID0gZnVuY3Rpb24oYSl7XG4gICAgIHJldHVybiBhICogZGVncmVlO1xufVxuXG4vKipcbiAqIFRlc3RzIHdoZXRoZXIgb3Igbm90IHRoZSBhcmd1bWVudHMgaGF2ZSBhcHByb3hpbWF0ZWx5IHRoZSBzYW1lIHZhbHVlLCB3aXRoaW4gYW4gYWJzb2x1dGVcbiAqIG9yIHJlbGF0aXZlIHRvbGVyYW5jZSBvZiBnbE1hdHJpeC5FUFNJTE9OIChhbiBhYnNvbHV0ZSB0b2xlcmFuY2UgaXMgdXNlZCBmb3IgdmFsdWVzIGxlc3MgXG4gKiB0aGFuIG9yIGVxdWFsIHRvIDEuMCwgYW5kIGEgcmVsYXRpdmUgdG9sZXJhbmNlIGlzIHVzZWQgZm9yIGxhcmdlciB2YWx1ZXMpXG4gKiBcbiAqIEBwYXJhbSB7TnVtYmVyfSBhIFRoZSBmaXJzdCBudW1iZXIgdG8gdGVzdC5cbiAqIEBwYXJhbSB7TnVtYmVyfSBiIFRoZSBzZWNvbmQgbnVtYmVyIHRvIHRlc3QuXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gVHJ1ZSBpZiB0aGUgbnVtYmVycyBhcmUgYXBwcm94aW1hdGVseSBlcXVhbCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICovXG5nbE1hdHJpeC5lcXVhbHMgPSBmdW5jdGlvbihhLCBiKSB7XG5cdHJldHVybiBNYXRoLmFicyhhIC0gYikgPD0gZ2xNYXRyaXguRVBTSUxPTipNYXRoLm1heCgxLjAsIE1hdGguYWJzKGEpLCBNYXRoLmFicyhiKSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2xNYXRyaXg7XG4iLCIvKiBDb3B5cmlnaHQgKGMpIDIwMTUsIEJyYW5kb24gSm9uZXMsIENvbGluIE1hY0tlbnppZSBJVi5cblxuUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxub2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xudG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG5mdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXG5UaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbklNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG5BVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG5MSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuVEhFIFNPRlRXQVJFLiAqL1xuXG52YXIgZ2xNYXRyaXggPSByZXF1aXJlKFwiLi9jb21tb24uanNcIik7XG5cbi8qKlxuICogQGNsYXNzIDJ4MiBNYXRyaXhcbiAqIEBuYW1lIG1hdDJcbiAqL1xudmFyIG1hdDIgPSB7fTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IGlkZW50aXR5IG1hdDJcbiAqXG4gKiBAcmV0dXJucyB7bWF0Mn0gYSBuZXcgMngyIG1hdHJpeFxuICovXG5tYXQyLmNyZWF0ZSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBvdXQgPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSg0KTtcbiAgICBvdXRbMF0gPSAxO1xuICAgIG91dFsxXSA9IDA7XG4gICAgb3V0WzJdID0gMDtcbiAgICBvdXRbM10gPSAxO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgbWF0MiBpbml0aWFsaXplZCB3aXRoIHZhbHVlcyBmcm9tIGFuIGV4aXN0aW5nIG1hdHJpeFxuICpcbiAqIEBwYXJhbSB7bWF0Mn0gYSBtYXRyaXggdG8gY2xvbmVcbiAqIEByZXR1cm5zIHttYXQyfSBhIG5ldyAyeDIgbWF0cml4XG4gKi9cbm1hdDIuY2xvbmUgPSBmdW5jdGlvbihhKSB7XG4gICAgdmFyIG91dCA9IG5ldyBnbE1hdHJpeC5BUlJBWV9UWVBFKDQpO1xuICAgIG91dFswXSA9IGFbMF07XG4gICAgb3V0WzFdID0gYVsxXTtcbiAgICBvdXRbMl0gPSBhWzJdO1xuICAgIG91dFszXSA9IGFbM107XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ29weSB0aGUgdmFsdWVzIGZyb20gb25lIG1hdDIgdG8gYW5vdGhlclxuICpcbiAqIEBwYXJhbSB7bWF0Mn0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDJ9IGEgdGhlIHNvdXJjZSBtYXRyaXhcbiAqIEByZXR1cm5zIHttYXQyfSBvdXRcbiAqL1xubWF0Mi5jb3B5ID0gZnVuY3Rpb24ob3V0LCBhKSB7XG4gICAgb3V0WzBdID0gYVswXTtcbiAgICBvdXRbMV0gPSBhWzFdO1xuICAgIG91dFsyXSA9IGFbMl07XG4gICAgb3V0WzNdID0gYVszXTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBTZXQgYSBtYXQyIHRvIHRoZSBpZGVudGl0eSBtYXRyaXhcbiAqXG4gKiBAcGFyYW0ge21hdDJ9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHJldHVybnMge21hdDJ9IG91dFxuICovXG5tYXQyLmlkZW50aXR5ID0gZnVuY3Rpb24ob3V0KSB7XG4gICAgb3V0WzBdID0gMTtcbiAgICBvdXRbMV0gPSAwO1xuICAgIG91dFsyXSA9IDA7XG4gICAgb3V0WzNdID0gMTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDcmVhdGUgYSBuZXcgbWF0MiB3aXRoIHRoZSBnaXZlbiB2YWx1ZXNcbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gbTAwIENvbXBvbmVudCBpbiBjb2x1bW4gMCwgcm93IDAgcG9zaXRpb24gKGluZGV4IDApXG4gKiBAcGFyYW0ge051bWJlcn0gbTAxIENvbXBvbmVudCBpbiBjb2x1bW4gMCwgcm93IDEgcG9zaXRpb24gKGluZGV4IDEpXG4gKiBAcGFyYW0ge051bWJlcn0gbTEwIENvbXBvbmVudCBpbiBjb2x1bW4gMSwgcm93IDAgcG9zaXRpb24gKGluZGV4IDIpXG4gKiBAcGFyYW0ge051bWJlcn0gbTExIENvbXBvbmVudCBpbiBjb2x1bW4gMSwgcm93IDEgcG9zaXRpb24gKGluZGV4IDMpXG4gKiBAcmV0dXJucyB7bWF0Mn0gb3V0IEEgbmV3IDJ4MiBtYXRyaXhcbiAqL1xubWF0Mi5mcm9tVmFsdWVzID0gZnVuY3Rpb24obTAwLCBtMDEsIG0xMCwgbTExKSB7XG4gICAgdmFyIG91dCA9IG5ldyBnbE1hdHJpeC5BUlJBWV9UWVBFKDQpO1xuICAgIG91dFswXSA9IG0wMDtcbiAgICBvdXRbMV0gPSBtMDE7XG4gICAgb3V0WzJdID0gbTEwO1xuICAgIG91dFszXSA9IG0xMTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBTZXQgdGhlIGNvbXBvbmVudHMgb2YgYSBtYXQyIHRvIHRoZSBnaXZlbiB2YWx1ZXNcbiAqXG4gKiBAcGFyYW0ge21hdDJ9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHtOdW1iZXJ9IG0wMCBDb21wb25lbnQgaW4gY29sdW1uIDAsIHJvdyAwIHBvc2l0aW9uIChpbmRleCAwKVxuICogQHBhcmFtIHtOdW1iZXJ9IG0wMSBDb21wb25lbnQgaW4gY29sdW1uIDAsIHJvdyAxIHBvc2l0aW9uIChpbmRleCAxKVxuICogQHBhcmFtIHtOdW1iZXJ9IG0xMCBDb21wb25lbnQgaW4gY29sdW1uIDEsIHJvdyAwIHBvc2l0aW9uIChpbmRleCAyKVxuICogQHBhcmFtIHtOdW1iZXJ9IG0xMSBDb21wb25lbnQgaW4gY29sdW1uIDEsIHJvdyAxIHBvc2l0aW9uIChpbmRleCAzKVxuICogQHJldHVybnMge21hdDJ9IG91dFxuICovXG5tYXQyLnNldCA9IGZ1bmN0aW9uKG91dCwgbTAwLCBtMDEsIG0xMCwgbTExKSB7XG4gICAgb3V0WzBdID0gbTAwO1xuICAgIG91dFsxXSA9IG0wMTtcbiAgICBvdXRbMl0gPSBtMTA7XG4gICAgb3V0WzNdID0gbTExO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG5cbi8qKlxuICogVHJhbnNwb3NlIHRoZSB2YWx1ZXMgb2YgYSBtYXQyXG4gKlxuICogQHBhcmFtIHttYXQyfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0Mn0gYSB0aGUgc291cmNlIG1hdHJpeFxuICogQHJldHVybnMge21hdDJ9IG91dFxuICovXG5tYXQyLnRyYW5zcG9zZSA9IGZ1bmN0aW9uKG91dCwgYSkge1xuICAgIC8vIElmIHdlIGFyZSB0cmFuc3Bvc2luZyBvdXJzZWx2ZXMgd2UgY2FuIHNraXAgYSBmZXcgc3RlcHMgYnV0IGhhdmUgdG8gY2FjaGUgc29tZSB2YWx1ZXNcbiAgICBpZiAob3V0ID09PSBhKSB7XG4gICAgICAgIHZhciBhMSA9IGFbMV07XG4gICAgICAgIG91dFsxXSA9IGFbMl07XG4gICAgICAgIG91dFsyXSA9IGExO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIG91dFswXSA9IGFbMF07XG4gICAgICAgIG91dFsxXSA9IGFbMl07XG4gICAgICAgIG91dFsyXSA9IGFbMV07XG4gICAgICAgIG91dFszXSA9IGFbM107XG4gICAgfVxuICAgIFxuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIEludmVydHMgYSBtYXQyXG4gKlxuICogQHBhcmFtIHttYXQyfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0Mn0gYSB0aGUgc291cmNlIG1hdHJpeFxuICogQHJldHVybnMge21hdDJ9IG91dFxuICovXG5tYXQyLmludmVydCA9IGZ1bmN0aW9uKG91dCwgYSkge1xuICAgIHZhciBhMCA9IGFbMF0sIGExID0gYVsxXSwgYTIgPSBhWzJdLCBhMyA9IGFbM10sXG5cbiAgICAgICAgLy8gQ2FsY3VsYXRlIHRoZSBkZXRlcm1pbmFudFxuICAgICAgICBkZXQgPSBhMCAqIGEzIC0gYTIgKiBhMTtcblxuICAgIGlmICghZGV0KSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBkZXQgPSAxLjAgLyBkZXQ7XG4gICAgXG4gICAgb3V0WzBdID0gIGEzICogZGV0O1xuICAgIG91dFsxXSA9IC1hMSAqIGRldDtcbiAgICBvdXRbMl0gPSAtYTIgKiBkZXQ7XG4gICAgb3V0WzNdID0gIGEwICogZGV0O1xuXG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgYWRqdWdhdGUgb2YgYSBtYXQyXG4gKlxuICogQHBhcmFtIHttYXQyfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0Mn0gYSB0aGUgc291cmNlIG1hdHJpeFxuICogQHJldHVybnMge21hdDJ9IG91dFxuICovXG5tYXQyLmFkam9pbnQgPSBmdW5jdGlvbihvdXQsIGEpIHtcbiAgICAvLyBDYWNoaW5nIHRoaXMgdmFsdWUgaXMgbmVzc2VjYXJ5IGlmIG91dCA9PSBhXG4gICAgdmFyIGEwID0gYVswXTtcbiAgICBvdXRbMF0gPSAgYVszXTtcbiAgICBvdXRbMV0gPSAtYVsxXTtcbiAgICBvdXRbMl0gPSAtYVsyXTtcbiAgICBvdXRbM10gPSAgYTA7XG5cbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBkZXRlcm1pbmFudCBvZiBhIG1hdDJcbiAqXG4gKiBAcGFyYW0ge21hdDJ9IGEgdGhlIHNvdXJjZSBtYXRyaXhcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IGRldGVybWluYW50IG9mIGFcbiAqL1xubWF0Mi5kZXRlcm1pbmFudCA9IGZ1bmN0aW9uIChhKSB7XG4gICAgcmV0dXJuIGFbMF0gKiBhWzNdIC0gYVsyXSAqIGFbMV07XG59O1xuXG4vKipcbiAqIE11bHRpcGxpZXMgdHdvIG1hdDInc1xuICpcbiAqIEBwYXJhbSB7bWF0Mn0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7bWF0Mn0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHttYXQyfSBvdXRcbiAqL1xubWF0Mi5tdWx0aXBseSA9IGZ1bmN0aW9uIChvdXQsIGEsIGIpIHtcbiAgICB2YXIgYTAgPSBhWzBdLCBhMSA9IGFbMV0sIGEyID0gYVsyXSwgYTMgPSBhWzNdO1xuICAgIHZhciBiMCA9IGJbMF0sIGIxID0gYlsxXSwgYjIgPSBiWzJdLCBiMyA9IGJbM107XG4gICAgb3V0WzBdID0gYTAgKiBiMCArIGEyICogYjE7XG4gICAgb3V0WzFdID0gYTEgKiBiMCArIGEzICogYjE7XG4gICAgb3V0WzJdID0gYTAgKiBiMiArIGEyICogYjM7XG4gICAgb3V0WzNdID0gYTEgKiBiMiArIGEzICogYjM7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayBtYXQyLm11bHRpcGx5fVxuICogQGZ1bmN0aW9uXG4gKi9cbm1hdDIubXVsID0gbWF0Mi5tdWx0aXBseTtcblxuLyoqXG4gKiBSb3RhdGVzIGEgbWF0MiBieSB0aGUgZ2l2ZW4gYW5nbGVcbiAqXG4gKiBAcGFyYW0ge21hdDJ9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQyfSBhIHRoZSBtYXRyaXggdG8gcm90YXRlXG4gKiBAcGFyYW0ge051bWJlcn0gcmFkIHRoZSBhbmdsZSB0byByb3RhdGUgdGhlIG1hdHJpeCBieVxuICogQHJldHVybnMge21hdDJ9IG91dFxuICovXG5tYXQyLnJvdGF0ZSA9IGZ1bmN0aW9uIChvdXQsIGEsIHJhZCkge1xuICAgIHZhciBhMCA9IGFbMF0sIGExID0gYVsxXSwgYTIgPSBhWzJdLCBhMyA9IGFbM10sXG4gICAgICAgIHMgPSBNYXRoLnNpbihyYWQpLFxuICAgICAgICBjID0gTWF0aC5jb3MocmFkKTtcbiAgICBvdXRbMF0gPSBhMCAqICBjICsgYTIgKiBzO1xuICAgIG91dFsxXSA9IGExICogIGMgKyBhMyAqIHM7XG4gICAgb3V0WzJdID0gYTAgKiAtcyArIGEyICogYztcbiAgICBvdXRbM10gPSBhMSAqIC1zICsgYTMgKiBjO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFNjYWxlcyB0aGUgbWF0MiBieSB0aGUgZGltZW5zaW9ucyBpbiB0aGUgZ2l2ZW4gdmVjMlxuICpcbiAqIEBwYXJhbSB7bWF0Mn0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDJ9IGEgdGhlIG1hdHJpeCB0byByb3RhdGVcbiAqIEBwYXJhbSB7dmVjMn0gdiB0aGUgdmVjMiB0byBzY2FsZSB0aGUgbWF0cml4IGJ5XG4gKiBAcmV0dXJucyB7bWF0Mn0gb3V0XG4gKiovXG5tYXQyLnNjYWxlID0gZnVuY3Rpb24ob3V0LCBhLCB2KSB7XG4gICAgdmFyIGEwID0gYVswXSwgYTEgPSBhWzFdLCBhMiA9IGFbMl0sIGEzID0gYVszXSxcbiAgICAgICAgdjAgPSB2WzBdLCB2MSA9IHZbMV07XG4gICAgb3V0WzBdID0gYTAgKiB2MDtcbiAgICBvdXRbMV0gPSBhMSAqIHYwO1xuICAgIG91dFsyXSA9IGEyICogdjE7XG4gICAgb3V0WzNdID0gYTMgKiB2MTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbWF0cml4IGZyb20gYSBnaXZlbiBhbmdsZVxuICogVGhpcyBpcyBlcXVpdmFsZW50IHRvIChidXQgbXVjaCBmYXN0ZXIgdGhhbik6XG4gKlxuICogICAgIG1hdDIuaWRlbnRpdHkoZGVzdCk7XG4gKiAgICAgbWF0Mi5yb3RhdGUoZGVzdCwgZGVzdCwgcmFkKTtcbiAqXG4gKiBAcGFyYW0ge21hdDJ9IG91dCBtYXQyIHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XG4gKiBAcGFyYW0ge051bWJlcn0gcmFkIHRoZSBhbmdsZSB0byByb3RhdGUgdGhlIG1hdHJpeCBieVxuICogQHJldHVybnMge21hdDJ9IG91dFxuICovXG5tYXQyLmZyb21Sb3RhdGlvbiA9IGZ1bmN0aW9uKG91dCwgcmFkKSB7XG4gICAgdmFyIHMgPSBNYXRoLnNpbihyYWQpLFxuICAgICAgICBjID0gTWF0aC5jb3MocmFkKTtcbiAgICBvdXRbMF0gPSBjO1xuICAgIG91dFsxXSA9IHM7XG4gICAgb3V0WzJdID0gLXM7XG4gICAgb3V0WzNdID0gYztcbiAgICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBtYXRyaXggZnJvbSBhIHZlY3RvciBzY2FsaW5nXG4gKiBUaGlzIGlzIGVxdWl2YWxlbnQgdG8gKGJ1dCBtdWNoIGZhc3RlciB0aGFuKTpcbiAqXG4gKiAgICAgbWF0Mi5pZGVudGl0eShkZXN0KTtcbiAqICAgICBtYXQyLnNjYWxlKGRlc3QsIGRlc3QsIHZlYyk7XG4gKlxuICogQHBhcmFtIHttYXQyfSBvdXQgbWF0MiByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxuICogQHBhcmFtIHt2ZWMyfSB2IFNjYWxpbmcgdmVjdG9yXG4gKiBAcmV0dXJucyB7bWF0Mn0gb3V0XG4gKi9cbm1hdDIuZnJvbVNjYWxpbmcgPSBmdW5jdGlvbihvdXQsIHYpIHtcbiAgICBvdXRbMF0gPSB2WzBdO1xuICAgIG91dFsxXSA9IDA7XG4gICAgb3V0WzJdID0gMDtcbiAgICBvdXRbM10gPSB2WzFdO1xuICAgIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhIG1hdDJcbiAqXG4gKiBAcGFyYW0ge21hdDJ9IG1hdCBtYXRyaXggdG8gcmVwcmVzZW50IGFzIGEgc3RyaW5nXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIG1hdHJpeFxuICovXG5tYXQyLnN0ciA9IGZ1bmN0aW9uIChhKSB7XG4gICAgcmV0dXJuICdtYXQyKCcgKyBhWzBdICsgJywgJyArIGFbMV0gKyAnLCAnICsgYVsyXSArICcsICcgKyBhWzNdICsgJyknO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIEZyb2Jlbml1cyBub3JtIG9mIGEgbWF0MlxuICpcbiAqIEBwYXJhbSB7bWF0Mn0gYSB0aGUgbWF0cml4IHRvIGNhbGN1bGF0ZSBGcm9iZW5pdXMgbm9ybSBvZlxuICogQHJldHVybnMge051bWJlcn0gRnJvYmVuaXVzIG5vcm1cbiAqL1xubWF0Mi5mcm9iID0gZnVuY3Rpb24gKGEpIHtcbiAgICByZXR1cm4oTWF0aC5zcXJ0KE1hdGgucG93KGFbMF0sIDIpICsgTWF0aC5wb3coYVsxXSwgMikgKyBNYXRoLnBvdyhhWzJdLCAyKSArIE1hdGgucG93KGFbM10sIDIpKSlcbn07XG5cbi8qKlxuICogUmV0dXJucyBMLCBEIGFuZCBVIG1hdHJpY2VzIChMb3dlciB0cmlhbmd1bGFyLCBEaWFnb25hbCBhbmQgVXBwZXIgdHJpYW5ndWxhcikgYnkgZmFjdG9yaXppbmcgdGhlIGlucHV0IG1hdHJpeFxuICogQHBhcmFtIHttYXQyfSBMIHRoZSBsb3dlciB0cmlhbmd1bGFyIG1hdHJpeCBcbiAqIEBwYXJhbSB7bWF0Mn0gRCB0aGUgZGlhZ29uYWwgbWF0cml4IFxuICogQHBhcmFtIHttYXQyfSBVIHRoZSB1cHBlciB0cmlhbmd1bGFyIG1hdHJpeCBcbiAqIEBwYXJhbSB7bWF0Mn0gYSB0aGUgaW5wdXQgbWF0cml4IHRvIGZhY3Rvcml6ZVxuICovXG5cbm1hdDIuTERVID0gZnVuY3Rpb24gKEwsIEQsIFUsIGEpIHsgXG4gICAgTFsyXSA9IGFbMl0vYVswXTsgXG4gICAgVVswXSA9IGFbMF07IFxuICAgIFVbMV0gPSBhWzFdOyBcbiAgICBVWzNdID0gYVszXSAtIExbMl0gKiBVWzFdOyBcbiAgICByZXR1cm4gW0wsIEQsIFVdOyAgICAgICBcbn07IFxuXG4vKipcbiAqIEFkZHMgdHdvIG1hdDInc1xuICpcbiAqIEBwYXJhbSB7bWF0Mn0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7bWF0Mn0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHttYXQyfSBvdXRcbiAqL1xubWF0Mi5hZGQgPSBmdW5jdGlvbihvdXQsIGEsIGIpIHtcbiAgICBvdXRbMF0gPSBhWzBdICsgYlswXTtcbiAgICBvdXRbMV0gPSBhWzFdICsgYlsxXTtcbiAgICBvdXRbMl0gPSBhWzJdICsgYlsyXTtcbiAgICBvdXRbM10gPSBhWzNdICsgYlszXTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBTdWJ0cmFjdHMgbWF0cml4IGIgZnJvbSBtYXRyaXggYVxuICpcbiAqIEBwYXJhbSB7bWF0Mn0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7bWF0Mn0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHttYXQyfSBvdXRcbiAqL1xubWF0Mi5zdWJ0cmFjdCA9IGZ1bmN0aW9uKG91dCwgYSwgYikge1xuICAgIG91dFswXSA9IGFbMF0gLSBiWzBdO1xuICAgIG91dFsxXSA9IGFbMV0gLSBiWzFdO1xuICAgIG91dFsyXSA9IGFbMl0gLSBiWzJdO1xuICAgIG91dFszXSA9IGFbM10gLSBiWzNdO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgbWF0Mi5zdWJ0cmFjdH1cbiAqIEBmdW5jdGlvblxuICovXG5tYXQyLnN1YiA9IG1hdDIuc3VidHJhY3Q7XG5cbi8qKlxuICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgbWF0cmljZXMgaGF2ZSBleGFjdGx5IHRoZSBzYW1lIGVsZW1lbnRzIGluIHRoZSBzYW1lIHBvc2l0aW9uICh3aGVuIGNvbXBhcmVkIHdpdGggPT09KVxuICpcbiAqIEBwYXJhbSB7bWF0Mn0gYSBUaGUgZmlyc3QgbWF0cml4LlxuICogQHBhcmFtIHttYXQyfSBiIFRoZSBzZWNvbmQgbWF0cml4LlxuICogQHJldHVybnMge0Jvb2xlYW59IFRydWUgaWYgdGhlIG1hdHJpY2VzIGFyZSBlcXVhbCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICovXG5tYXQyLmV4YWN0RXF1YWxzID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICByZXR1cm4gYVswXSA9PT0gYlswXSAmJiBhWzFdID09PSBiWzFdICYmIGFbMl0gPT09IGJbMl0gJiYgYVszXSA9PT0gYlszXTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgbWF0cmljZXMgaGF2ZSBhcHByb3hpbWF0ZWx5IHRoZSBzYW1lIGVsZW1lbnRzIGluIHRoZSBzYW1lIHBvc2l0aW9uLlxuICpcbiAqIEBwYXJhbSB7bWF0Mn0gYSBUaGUgZmlyc3QgbWF0cml4LlxuICogQHBhcmFtIHttYXQyfSBiIFRoZSBzZWNvbmQgbWF0cml4LlxuICogQHJldHVybnMge0Jvb2xlYW59IFRydWUgaWYgdGhlIG1hdHJpY2VzIGFyZSBlcXVhbCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICovXG5tYXQyLmVxdWFscyA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgdmFyIGEwID0gYVswXSwgYTEgPSBhWzFdLCBhMiA9IGFbMl0sIGEzID0gYVszXTtcbiAgICB2YXIgYjAgPSBiWzBdLCBiMSA9IGJbMV0sIGIyID0gYlsyXSwgYjMgPSBiWzNdO1xuICAgIHJldHVybiAoTWF0aC5hYnMoYTAgLSBiMCkgPD0gZ2xNYXRyaXguRVBTSUxPTipNYXRoLm1heCgxLjAsIE1hdGguYWJzKGEwKSwgTWF0aC5hYnMoYjApKSAmJlxuICAgICAgICAgICAgTWF0aC5hYnMoYTEgLSBiMSkgPD0gZ2xNYXRyaXguRVBTSUxPTipNYXRoLm1heCgxLjAsIE1hdGguYWJzKGExKSwgTWF0aC5hYnMoYjEpKSAmJlxuICAgICAgICAgICAgTWF0aC5hYnMoYTIgLSBiMikgPD0gZ2xNYXRyaXguRVBTSUxPTipNYXRoLm1heCgxLjAsIE1hdGguYWJzKGEyKSwgTWF0aC5hYnMoYjIpKSAmJlxuICAgICAgICAgICAgTWF0aC5hYnMoYTMgLSBiMykgPD0gZ2xNYXRyaXguRVBTSUxPTipNYXRoLm1heCgxLjAsIE1hdGguYWJzKGEzKSwgTWF0aC5hYnMoYjMpKSk7XG59O1xuXG4vKipcbiAqIE11bHRpcGx5IGVhY2ggZWxlbWVudCBvZiB0aGUgbWF0cml4IGJ5IGEgc2NhbGFyLlxuICpcbiAqIEBwYXJhbSB7bWF0Mn0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDJ9IGEgdGhlIG1hdHJpeCB0byBzY2FsZVxuICogQHBhcmFtIHtOdW1iZXJ9IGIgYW1vdW50IHRvIHNjYWxlIHRoZSBtYXRyaXgncyBlbGVtZW50cyBieVxuICogQHJldHVybnMge21hdDJ9IG91dFxuICovXG5tYXQyLm11bHRpcGx5U2NhbGFyID0gZnVuY3Rpb24ob3V0LCBhLCBiKSB7XG4gICAgb3V0WzBdID0gYVswXSAqIGI7XG4gICAgb3V0WzFdID0gYVsxXSAqIGI7XG4gICAgb3V0WzJdID0gYVsyXSAqIGI7XG4gICAgb3V0WzNdID0gYVszXSAqIGI7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQWRkcyB0d28gbWF0MidzIGFmdGVyIG11bHRpcGx5aW5nIGVhY2ggZWxlbWVudCBvZiB0aGUgc2Vjb25kIG9wZXJhbmQgYnkgYSBzY2FsYXIgdmFsdWUuXG4gKlxuICogQHBhcmFtIHttYXQyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7bWF0Mn0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHttYXQyfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHBhcmFtIHtOdW1iZXJ9IHNjYWxlIHRoZSBhbW91bnQgdG8gc2NhbGUgYidzIGVsZW1lbnRzIGJ5IGJlZm9yZSBhZGRpbmdcbiAqIEByZXR1cm5zIHttYXQyfSBvdXRcbiAqL1xubWF0Mi5tdWx0aXBseVNjYWxhckFuZEFkZCA9IGZ1bmN0aW9uKG91dCwgYSwgYiwgc2NhbGUpIHtcbiAgICBvdXRbMF0gPSBhWzBdICsgKGJbMF0gKiBzY2FsZSk7XG4gICAgb3V0WzFdID0gYVsxXSArIChiWzFdICogc2NhbGUpO1xuICAgIG91dFsyXSA9IGFbMl0gKyAoYlsyXSAqIHNjYWxlKTtcbiAgICBvdXRbM10gPSBhWzNdICsgKGJbM10gKiBzY2FsZSk7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gbWF0MjtcbiIsIi8qIENvcHlyaWdodCAoYykgMjAxNSwgQnJhbmRvbiBKb25lcywgQ29saW4gTWFjS2VuemllIElWLlxuXG5QZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG5vZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG5pbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG50byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG5jb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbmZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cblRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG5hbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG5GSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbkFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbkxJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG5PVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG5USEUgU09GVFdBUkUuICovXG5cbnZhciBnbE1hdHJpeCA9IHJlcXVpcmUoXCIuL2NvbW1vbi5qc1wiKTtcblxuLyoqXG4gKiBAY2xhc3MgMngzIE1hdHJpeFxuICogQG5hbWUgbWF0MmRcbiAqIFxuICogQGRlc2NyaXB0aW9uIFxuICogQSBtYXQyZCBjb250YWlucyBzaXggZWxlbWVudHMgZGVmaW5lZCBhczpcbiAqIDxwcmU+XG4gKiBbYSwgYywgdHgsXG4gKiAgYiwgZCwgdHldXG4gKiA8L3ByZT5cbiAqIFRoaXMgaXMgYSBzaG9ydCBmb3JtIGZvciB0aGUgM3gzIG1hdHJpeDpcbiAqIDxwcmU+XG4gKiBbYSwgYywgdHgsXG4gKiAgYiwgZCwgdHksXG4gKiAgMCwgMCwgMV1cbiAqIDwvcHJlPlxuICogVGhlIGxhc3Qgcm93IGlzIGlnbm9yZWQgc28gdGhlIGFycmF5IGlzIHNob3J0ZXIgYW5kIG9wZXJhdGlvbnMgYXJlIGZhc3Rlci5cbiAqL1xudmFyIG1hdDJkID0ge307XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBpZGVudGl0eSBtYXQyZFxuICpcbiAqIEByZXR1cm5zIHttYXQyZH0gYSBuZXcgMngzIG1hdHJpeFxuICovXG5tYXQyZC5jcmVhdGUgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgb3V0ID0gbmV3IGdsTWF0cml4LkFSUkFZX1RZUEUoNik7XG4gICAgb3V0WzBdID0gMTtcbiAgICBvdXRbMV0gPSAwO1xuICAgIG91dFsyXSA9IDA7XG4gICAgb3V0WzNdID0gMTtcbiAgICBvdXRbNF0gPSAwO1xuICAgIG91dFs1XSA9IDA7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBtYXQyZCBpbml0aWFsaXplZCB3aXRoIHZhbHVlcyBmcm9tIGFuIGV4aXN0aW5nIG1hdHJpeFxuICpcbiAqIEBwYXJhbSB7bWF0MmR9IGEgbWF0cml4IHRvIGNsb25lXG4gKiBAcmV0dXJucyB7bWF0MmR9IGEgbmV3IDJ4MyBtYXRyaXhcbiAqL1xubWF0MmQuY2xvbmUgPSBmdW5jdGlvbihhKSB7XG4gICAgdmFyIG91dCA9IG5ldyBnbE1hdHJpeC5BUlJBWV9UWVBFKDYpO1xuICAgIG91dFswXSA9IGFbMF07XG4gICAgb3V0WzFdID0gYVsxXTtcbiAgICBvdXRbMl0gPSBhWzJdO1xuICAgIG91dFszXSA9IGFbM107XG4gICAgb3V0WzRdID0gYVs0XTtcbiAgICBvdXRbNV0gPSBhWzVdO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENvcHkgdGhlIHZhbHVlcyBmcm9tIG9uZSBtYXQyZCB0byBhbm90aGVyXG4gKlxuICogQHBhcmFtIHttYXQyZH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDJkfSBhIHRoZSBzb3VyY2UgbWF0cml4XG4gKiBAcmV0dXJucyB7bWF0MmR9IG91dFxuICovXG5tYXQyZC5jb3B5ID0gZnVuY3Rpb24ob3V0LCBhKSB7XG4gICAgb3V0WzBdID0gYVswXTtcbiAgICBvdXRbMV0gPSBhWzFdO1xuICAgIG91dFsyXSA9IGFbMl07XG4gICAgb3V0WzNdID0gYVszXTtcbiAgICBvdXRbNF0gPSBhWzRdO1xuICAgIG91dFs1XSA9IGFbNV07XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogU2V0IGEgbWF0MmQgdG8gdGhlIGlkZW50aXR5IG1hdHJpeFxuICpcbiAqIEBwYXJhbSB7bWF0MmR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHJldHVybnMge21hdDJkfSBvdXRcbiAqL1xubWF0MmQuaWRlbnRpdHkgPSBmdW5jdGlvbihvdXQpIHtcbiAgICBvdXRbMF0gPSAxO1xuICAgIG91dFsxXSA9IDA7XG4gICAgb3V0WzJdID0gMDtcbiAgICBvdXRbM10gPSAxO1xuICAgIG91dFs0XSA9IDA7XG4gICAgb3V0WzVdID0gMDtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDcmVhdGUgYSBuZXcgbWF0MmQgd2l0aCB0aGUgZ2l2ZW4gdmFsdWVzXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IGEgQ29tcG9uZW50IEEgKGluZGV4IDApXG4gKiBAcGFyYW0ge051bWJlcn0gYiBDb21wb25lbnQgQiAoaW5kZXggMSlcbiAqIEBwYXJhbSB7TnVtYmVyfSBjIENvbXBvbmVudCBDIChpbmRleCAyKVxuICogQHBhcmFtIHtOdW1iZXJ9IGQgQ29tcG9uZW50IEQgKGluZGV4IDMpXG4gKiBAcGFyYW0ge051bWJlcn0gdHggQ29tcG9uZW50IFRYIChpbmRleCA0KVxuICogQHBhcmFtIHtOdW1iZXJ9IHR5IENvbXBvbmVudCBUWSAoaW5kZXggNSlcbiAqIEByZXR1cm5zIHttYXQyZH0gQSBuZXcgbWF0MmRcbiAqL1xubWF0MmQuZnJvbVZhbHVlcyA9IGZ1bmN0aW9uKGEsIGIsIGMsIGQsIHR4LCB0eSkge1xuICAgIHZhciBvdXQgPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSg2KTtcbiAgICBvdXRbMF0gPSBhO1xuICAgIG91dFsxXSA9IGI7XG4gICAgb3V0WzJdID0gYztcbiAgICBvdXRbM10gPSBkO1xuICAgIG91dFs0XSA9IHR4O1xuICAgIG91dFs1XSA9IHR5O1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFNldCB0aGUgY29tcG9uZW50cyBvZiBhIG1hdDJkIHRvIHRoZSBnaXZlbiB2YWx1ZXNcbiAqXG4gKiBAcGFyYW0ge21hdDJkfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7TnVtYmVyfSBhIENvbXBvbmVudCBBIChpbmRleCAwKVxuICogQHBhcmFtIHtOdW1iZXJ9IGIgQ29tcG9uZW50IEIgKGluZGV4IDEpXG4gKiBAcGFyYW0ge051bWJlcn0gYyBDb21wb25lbnQgQyAoaW5kZXggMilcbiAqIEBwYXJhbSB7TnVtYmVyfSBkIENvbXBvbmVudCBEIChpbmRleCAzKVxuICogQHBhcmFtIHtOdW1iZXJ9IHR4IENvbXBvbmVudCBUWCAoaW5kZXggNClcbiAqIEBwYXJhbSB7TnVtYmVyfSB0eSBDb21wb25lbnQgVFkgKGluZGV4IDUpXG4gKiBAcmV0dXJucyB7bWF0MmR9IG91dFxuICovXG5tYXQyZC5zZXQgPSBmdW5jdGlvbihvdXQsIGEsIGIsIGMsIGQsIHR4LCB0eSkge1xuICAgIG91dFswXSA9IGE7XG4gICAgb3V0WzFdID0gYjtcbiAgICBvdXRbMl0gPSBjO1xuICAgIG91dFszXSA9IGQ7XG4gICAgb3V0WzRdID0gdHg7XG4gICAgb3V0WzVdID0gdHk7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogSW52ZXJ0cyBhIG1hdDJkXG4gKlxuICogQHBhcmFtIHttYXQyZH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDJkfSBhIHRoZSBzb3VyY2UgbWF0cml4XG4gKiBAcmV0dXJucyB7bWF0MmR9IG91dFxuICovXG5tYXQyZC5pbnZlcnQgPSBmdW5jdGlvbihvdXQsIGEpIHtcbiAgICB2YXIgYWEgPSBhWzBdLCBhYiA9IGFbMV0sIGFjID0gYVsyXSwgYWQgPSBhWzNdLFxuICAgICAgICBhdHggPSBhWzRdLCBhdHkgPSBhWzVdO1xuXG4gICAgdmFyIGRldCA9IGFhICogYWQgLSBhYiAqIGFjO1xuICAgIGlmKCFkZXQpe1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgZGV0ID0gMS4wIC8gZGV0O1xuXG4gICAgb3V0WzBdID0gYWQgKiBkZXQ7XG4gICAgb3V0WzFdID0gLWFiICogZGV0O1xuICAgIG91dFsyXSA9IC1hYyAqIGRldDtcbiAgICBvdXRbM10gPSBhYSAqIGRldDtcbiAgICBvdXRbNF0gPSAoYWMgKiBhdHkgLSBhZCAqIGF0eCkgKiBkZXQ7XG4gICAgb3V0WzVdID0gKGFiICogYXR4IC0gYWEgKiBhdHkpICogZGV0O1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGRldGVybWluYW50IG9mIGEgbWF0MmRcbiAqXG4gKiBAcGFyYW0ge21hdDJkfSBhIHRoZSBzb3VyY2UgbWF0cml4XG4gKiBAcmV0dXJucyB7TnVtYmVyfSBkZXRlcm1pbmFudCBvZiBhXG4gKi9cbm1hdDJkLmRldGVybWluYW50ID0gZnVuY3Rpb24gKGEpIHtcbiAgICByZXR1cm4gYVswXSAqIGFbM10gLSBhWzFdICogYVsyXTtcbn07XG5cbi8qKlxuICogTXVsdGlwbGllcyB0d28gbWF0MmQnc1xuICpcbiAqIEBwYXJhbSB7bWF0MmR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQyZH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHttYXQyZH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHttYXQyZH0gb3V0XG4gKi9cbm1hdDJkLm11bHRpcGx5ID0gZnVuY3Rpb24gKG91dCwgYSwgYikge1xuICAgIHZhciBhMCA9IGFbMF0sIGExID0gYVsxXSwgYTIgPSBhWzJdLCBhMyA9IGFbM10sIGE0ID0gYVs0XSwgYTUgPSBhWzVdLFxuICAgICAgICBiMCA9IGJbMF0sIGIxID0gYlsxXSwgYjIgPSBiWzJdLCBiMyA9IGJbM10sIGI0ID0gYls0XSwgYjUgPSBiWzVdO1xuICAgIG91dFswXSA9IGEwICogYjAgKyBhMiAqIGIxO1xuICAgIG91dFsxXSA9IGExICogYjAgKyBhMyAqIGIxO1xuICAgIG91dFsyXSA9IGEwICogYjIgKyBhMiAqIGIzO1xuICAgIG91dFszXSA9IGExICogYjIgKyBhMyAqIGIzO1xuICAgIG91dFs0XSA9IGEwICogYjQgKyBhMiAqIGI1ICsgYTQ7XG4gICAgb3V0WzVdID0gYTEgKiBiNCArIGEzICogYjUgKyBhNTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIG1hdDJkLm11bHRpcGx5fVxuICogQGZ1bmN0aW9uXG4gKi9cbm1hdDJkLm11bCA9IG1hdDJkLm11bHRpcGx5O1xuXG4vKipcbiAqIFJvdGF0ZXMgYSBtYXQyZCBieSB0aGUgZ2l2ZW4gYW5nbGVcbiAqXG4gKiBAcGFyYW0ge21hdDJkfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0MmR9IGEgdGhlIG1hdHJpeCB0byByb3RhdGVcbiAqIEBwYXJhbSB7TnVtYmVyfSByYWQgdGhlIGFuZ2xlIHRvIHJvdGF0ZSB0aGUgbWF0cml4IGJ5XG4gKiBAcmV0dXJucyB7bWF0MmR9IG91dFxuICovXG5tYXQyZC5yb3RhdGUgPSBmdW5jdGlvbiAob3V0LCBhLCByYWQpIHtcbiAgICB2YXIgYTAgPSBhWzBdLCBhMSA9IGFbMV0sIGEyID0gYVsyXSwgYTMgPSBhWzNdLCBhNCA9IGFbNF0sIGE1ID0gYVs1XSxcbiAgICAgICAgcyA9IE1hdGguc2luKHJhZCksXG4gICAgICAgIGMgPSBNYXRoLmNvcyhyYWQpO1xuICAgIG91dFswXSA9IGEwICogIGMgKyBhMiAqIHM7XG4gICAgb3V0WzFdID0gYTEgKiAgYyArIGEzICogcztcbiAgICBvdXRbMl0gPSBhMCAqIC1zICsgYTIgKiBjO1xuICAgIG91dFszXSA9IGExICogLXMgKyBhMyAqIGM7XG4gICAgb3V0WzRdID0gYTQ7XG4gICAgb3V0WzVdID0gYTU7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogU2NhbGVzIHRoZSBtYXQyZCBieSB0aGUgZGltZW5zaW9ucyBpbiB0aGUgZ2l2ZW4gdmVjMlxuICpcbiAqIEBwYXJhbSB7bWF0MmR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQyZH0gYSB0aGUgbWF0cml4IHRvIHRyYW5zbGF0ZVxuICogQHBhcmFtIHt2ZWMyfSB2IHRoZSB2ZWMyIHRvIHNjYWxlIHRoZSBtYXRyaXggYnlcbiAqIEByZXR1cm5zIHttYXQyZH0gb3V0XG4gKiovXG5tYXQyZC5zY2FsZSA9IGZ1bmN0aW9uKG91dCwgYSwgdikge1xuICAgIHZhciBhMCA9IGFbMF0sIGExID0gYVsxXSwgYTIgPSBhWzJdLCBhMyA9IGFbM10sIGE0ID0gYVs0XSwgYTUgPSBhWzVdLFxuICAgICAgICB2MCA9IHZbMF0sIHYxID0gdlsxXTtcbiAgICBvdXRbMF0gPSBhMCAqIHYwO1xuICAgIG91dFsxXSA9IGExICogdjA7XG4gICAgb3V0WzJdID0gYTIgKiB2MTtcbiAgICBvdXRbM10gPSBhMyAqIHYxO1xuICAgIG91dFs0XSA9IGE0O1xuICAgIG91dFs1XSA9IGE1O1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFRyYW5zbGF0ZXMgdGhlIG1hdDJkIGJ5IHRoZSBkaW1lbnNpb25zIGluIHRoZSBnaXZlbiB2ZWMyXG4gKlxuICogQHBhcmFtIHttYXQyZH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDJkfSBhIHRoZSBtYXRyaXggdG8gdHJhbnNsYXRlXG4gKiBAcGFyYW0ge3ZlYzJ9IHYgdGhlIHZlYzIgdG8gdHJhbnNsYXRlIHRoZSBtYXRyaXggYnlcbiAqIEByZXR1cm5zIHttYXQyZH0gb3V0XG4gKiovXG5tYXQyZC50cmFuc2xhdGUgPSBmdW5jdGlvbihvdXQsIGEsIHYpIHtcbiAgICB2YXIgYTAgPSBhWzBdLCBhMSA9IGFbMV0sIGEyID0gYVsyXSwgYTMgPSBhWzNdLCBhNCA9IGFbNF0sIGE1ID0gYVs1XSxcbiAgICAgICAgdjAgPSB2WzBdLCB2MSA9IHZbMV07XG4gICAgb3V0WzBdID0gYTA7XG4gICAgb3V0WzFdID0gYTE7XG4gICAgb3V0WzJdID0gYTI7XG4gICAgb3V0WzNdID0gYTM7XG4gICAgb3V0WzRdID0gYTAgKiB2MCArIGEyICogdjEgKyBhNDtcbiAgICBvdXRbNV0gPSBhMSAqIHYwICsgYTMgKiB2MSArIGE1O1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBtYXRyaXggZnJvbSBhIGdpdmVuIGFuZ2xlXG4gKiBUaGlzIGlzIGVxdWl2YWxlbnQgdG8gKGJ1dCBtdWNoIGZhc3RlciB0aGFuKTpcbiAqXG4gKiAgICAgbWF0MmQuaWRlbnRpdHkoZGVzdCk7XG4gKiAgICAgbWF0MmQucm90YXRlKGRlc3QsIGRlc3QsIHJhZCk7XG4gKlxuICogQHBhcmFtIHttYXQyZH0gb3V0IG1hdDJkIHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XG4gKiBAcGFyYW0ge051bWJlcn0gcmFkIHRoZSBhbmdsZSB0byByb3RhdGUgdGhlIG1hdHJpeCBieVxuICogQHJldHVybnMge21hdDJkfSBvdXRcbiAqL1xubWF0MmQuZnJvbVJvdGF0aW9uID0gZnVuY3Rpb24ob3V0LCByYWQpIHtcbiAgICB2YXIgcyA9IE1hdGguc2luKHJhZCksIGMgPSBNYXRoLmNvcyhyYWQpO1xuICAgIG91dFswXSA9IGM7XG4gICAgb3V0WzFdID0gcztcbiAgICBvdXRbMl0gPSAtcztcbiAgICBvdXRbM10gPSBjO1xuICAgIG91dFs0XSA9IDA7XG4gICAgb3V0WzVdID0gMDtcbiAgICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBtYXRyaXggZnJvbSBhIHZlY3RvciBzY2FsaW5nXG4gKiBUaGlzIGlzIGVxdWl2YWxlbnQgdG8gKGJ1dCBtdWNoIGZhc3RlciB0aGFuKTpcbiAqXG4gKiAgICAgbWF0MmQuaWRlbnRpdHkoZGVzdCk7XG4gKiAgICAgbWF0MmQuc2NhbGUoZGVzdCwgZGVzdCwgdmVjKTtcbiAqXG4gKiBAcGFyYW0ge21hdDJkfSBvdXQgbWF0MmQgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcbiAqIEBwYXJhbSB7dmVjMn0gdiBTY2FsaW5nIHZlY3RvclxuICogQHJldHVybnMge21hdDJkfSBvdXRcbiAqL1xubWF0MmQuZnJvbVNjYWxpbmcgPSBmdW5jdGlvbihvdXQsIHYpIHtcbiAgICBvdXRbMF0gPSB2WzBdO1xuICAgIG91dFsxXSA9IDA7XG4gICAgb3V0WzJdID0gMDtcbiAgICBvdXRbM10gPSB2WzFdO1xuICAgIG91dFs0XSA9IDA7XG4gICAgb3V0WzVdID0gMDtcbiAgICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBtYXRyaXggZnJvbSBhIHZlY3RvciB0cmFuc2xhdGlvblxuICogVGhpcyBpcyBlcXVpdmFsZW50IHRvIChidXQgbXVjaCBmYXN0ZXIgdGhhbik6XG4gKlxuICogICAgIG1hdDJkLmlkZW50aXR5KGRlc3QpO1xuICogICAgIG1hdDJkLnRyYW5zbGF0ZShkZXN0LCBkZXN0LCB2ZWMpO1xuICpcbiAqIEBwYXJhbSB7bWF0MmR9IG91dCBtYXQyZCByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxuICogQHBhcmFtIHt2ZWMyfSB2IFRyYW5zbGF0aW9uIHZlY3RvclxuICogQHJldHVybnMge21hdDJkfSBvdXRcbiAqL1xubWF0MmQuZnJvbVRyYW5zbGF0aW9uID0gZnVuY3Rpb24ob3V0LCB2KSB7XG4gICAgb3V0WzBdID0gMTtcbiAgICBvdXRbMV0gPSAwO1xuICAgIG91dFsyXSA9IDA7XG4gICAgb3V0WzNdID0gMTtcbiAgICBvdXRbNF0gPSB2WzBdO1xuICAgIG91dFs1XSA9IHZbMV07XG4gICAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGEgbWF0MmRcbiAqXG4gKiBAcGFyYW0ge21hdDJkfSBhIG1hdHJpeCB0byByZXByZXNlbnQgYXMgYSBzdHJpbmdcbiAqIEByZXR1cm5zIHtTdHJpbmd9IHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgbWF0cml4XG4gKi9cbm1hdDJkLnN0ciA9IGZ1bmN0aW9uIChhKSB7XG4gICAgcmV0dXJuICdtYXQyZCgnICsgYVswXSArICcsICcgKyBhWzFdICsgJywgJyArIGFbMl0gKyAnLCAnICsgXG4gICAgICAgICAgICAgICAgICAgIGFbM10gKyAnLCAnICsgYVs0XSArICcsICcgKyBhWzVdICsgJyknO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIEZyb2Jlbml1cyBub3JtIG9mIGEgbWF0MmRcbiAqXG4gKiBAcGFyYW0ge21hdDJkfSBhIHRoZSBtYXRyaXggdG8gY2FsY3VsYXRlIEZyb2Jlbml1cyBub3JtIG9mXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBGcm9iZW5pdXMgbm9ybVxuICovXG5tYXQyZC5mcm9iID0gZnVuY3Rpb24gKGEpIHsgXG4gICAgcmV0dXJuKE1hdGguc3FydChNYXRoLnBvdyhhWzBdLCAyKSArIE1hdGgucG93KGFbMV0sIDIpICsgTWF0aC5wb3coYVsyXSwgMikgKyBNYXRoLnBvdyhhWzNdLCAyKSArIE1hdGgucG93KGFbNF0sIDIpICsgTWF0aC5wb3coYVs1XSwgMikgKyAxKSlcbn07IFxuXG4vKipcbiAqIEFkZHMgdHdvIG1hdDJkJ3NcbiAqXG4gKiBAcGFyYW0ge21hdDJkfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0MmR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7bWF0MmR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7bWF0MmR9IG91dFxuICovXG5tYXQyZC5hZGQgPSBmdW5jdGlvbihvdXQsIGEsIGIpIHtcbiAgICBvdXRbMF0gPSBhWzBdICsgYlswXTtcbiAgICBvdXRbMV0gPSBhWzFdICsgYlsxXTtcbiAgICBvdXRbMl0gPSBhWzJdICsgYlsyXTtcbiAgICBvdXRbM10gPSBhWzNdICsgYlszXTtcbiAgICBvdXRbNF0gPSBhWzRdICsgYls0XTtcbiAgICBvdXRbNV0gPSBhWzVdICsgYls1XTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBTdWJ0cmFjdHMgbWF0cml4IGIgZnJvbSBtYXRyaXggYVxuICpcbiAqIEBwYXJhbSB7bWF0MmR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQyZH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHttYXQyZH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHttYXQyZH0gb3V0XG4gKi9cbm1hdDJkLnN1YnRyYWN0ID0gZnVuY3Rpb24ob3V0LCBhLCBiKSB7XG4gICAgb3V0WzBdID0gYVswXSAtIGJbMF07XG4gICAgb3V0WzFdID0gYVsxXSAtIGJbMV07XG4gICAgb3V0WzJdID0gYVsyXSAtIGJbMl07XG4gICAgb3V0WzNdID0gYVszXSAtIGJbM107XG4gICAgb3V0WzRdID0gYVs0XSAtIGJbNF07XG4gICAgb3V0WzVdID0gYVs1XSAtIGJbNV07XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayBtYXQyZC5zdWJ0cmFjdH1cbiAqIEBmdW5jdGlvblxuICovXG5tYXQyZC5zdWIgPSBtYXQyZC5zdWJ0cmFjdDtcblxuLyoqXG4gKiBNdWx0aXBseSBlYWNoIGVsZW1lbnQgb2YgdGhlIG1hdHJpeCBieSBhIHNjYWxhci5cbiAqXG4gKiBAcGFyYW0ge21hdDJkfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0MmR9IGEgdGhlIG1hdHJpeCB0byBzY2FsZVxuICogQHBhcmFtIHtOdW1iZXJ9IGIgYW1vdW50IHRvIHNjYWxlIHRoZSBtYXRyaXgncyBlbGVtZW50cyBieVxuICogQHJldHVybnMge21hdDJkfSBvdXRcbiAqL1xubWF0MmQubXVsdGlwbHlTY2FsYXIgPSBmdW5jdGlvbihvdXQsIGEsIGIpIHtcbiAgICBvdXRbMF0gPSBhWzBdICogYjtcbiAgICBvdXRbMV0gPSBhWzFdICogYjtcbiAgICBvdXRbMl0gPSBhWzJdICogYjtcbiAgICBvdXRbM10gPSBhWzNdICogYjtcbiAgICBvdXRbNF0gPSBhWzRdICogYjtcbiAgICBvdXRbNV0gPSBhWzVdICogYjtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBBZGRzIHR3byBtYXQyZCdzIGFmdGVyIG11bHRpcGx5aW5nIGVhY2ggZWxlbWVudCBvZiB0aGUgc2Vjb25kIG9wZXJhbmQgYnkgYSBzY2FsYXIgdmFsdWUuXG4gKlxuICogQHBhcmFtIHttYXQyZH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge21hdDJkfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge21hdDJkfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHBhcmFtIHtOdW1iZXJ9IHNjYWxlIHRoZSBhbW91bnQgdG8gc2NhbGUgYidzIGVsZW1lbnRzIGJ5IGJlZm9yZSBhZGRpbmdcbiAqIEByZXR1cm5zIHttYXQyZH0gb3V0XG4gKi9cbm1hdDJkLm11bHRpcGx5U2NhbGFyQW5kQWRkID0gZnVuY3Rpb24ob3V0LCBhLCBiLCBzY2FsZSkge1xuICAgIG91dFswXSA9IGFbMF0gKyAoYlswXSAqIHNjYWxlKTtcbiAgICBvdXRbMV0gPSBhWzFdICsgKGJbMV0gKiBzY2FsZSk7XG4gICAgb3V0WzJdID0gYVsyXSArIChiWzJdICogc2NhbGUpO1xuICAgIG91dFszXSA9IGFbM10gKyAoYlszXSAqIHNjYWxlKTtcbiAgICBvdXRbNF0gPSBhWzRdICsgKGJbNF0gKiBzY2FsZSk7XG4gICAgb3V0WzVdID0gYVs1XSArIChiWzVdICogc2NhbGUpO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIG1hdHJpY2VzIGhhdmUgZXhhY3RseSB0aGUgc2FtZSBlbGVtZW50cyBpbiB0aGUgc2FtZSBwb3NpdGlvbiAod2hlbiBjb21wYXJlZCB3aXRoID09PSlcbiAqXG4gKiBAcGFyYW0ge21hdDJkfSBhIFRoZSBmaXJzdCBtYXRyaXguXG4gKiBAcGFyYW0ge21hdDJkfSBiIFRoZSBzZWNvbmQgbWF0cml4LlxuICogQHJldHVybnMge0Jvb2xlYW59IFRydWUgaWYgdGhlIG1hdHJpY2VzIGFyZSBlcXVhbCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICovXG5tYXQyZC5leGFjdEVxdWFscyA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgcmV0dXJuIGFbMF0gPT09IGJbMF0gJiYgYVsxXSA9PT0gYlsxXSAmJiBhWzJdID09PSBiWzJdICYmIGFbM10gPT09IGJbM10gJiYgYVs0XSA9PT0gYls0XSAmJiBhWzVdID09PSBiWzVdO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSBtYXRyaWNlcyBoYXZlIGFwcHJveGltYXRlbHkgdGhlIHNhbWUgZWxlbWVudHMgaW4gdGhlIHNhbWUgcG9zaXRpb24uXG4gKlxuICogQHBhcmFtIHttYXQyZH0gYSBUaGUgZmlyc3QgbWF0cml4LlxuICogQHBhcmFtIHttYXQyZH0gYiBUaGUgc2Vjb25kIG1hdHJpeC5cbiAqIEByZXR1cm5zIHtCb29sZWFufSBUcnVlIGlmIHRoZSBtYXRyaWNlcyBhcmUgZXF1YWwsIGZhbHNlIG90aGVyd2lzZS5cbiAqL1xubWF0MmQuZXF1YWxzID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICB2YXIgYTAgPSBhWzBdLCBhMSA9IGFbMV0sIGEyID0gYVsyXSwgYTMgPSBhWzNdLCBhNCA9IGFbNF0sIGE1ID0gYVs1XTtcbiAgICB2YXIgYjAgPSBiWzBdLCBiMSA9IGJbMV0sIGIyID0gYlsyXSwgYjMgPSBiWzNdLCBiNCA9IGJbNF0sIGI1ID0gYls1XTtcbiAgICByZXR1cm4gKE1hdGguYWJzKGEwIC0gYjApIDw9IGdsTWF0cml4LkVQU0lMT04qTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMCksIE1hdGguYWJzKGIwKSkgJiZcbiAgICAgICAgICAgIE1hdGguYWJzKGExIC0gYjEpIDw9IGdsTWF0cml4LkVQU0lMT04qTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMSksIE1hdGguYWJzKGIxKSkgJiZcbiAgICAgICAgICAgIE1hdGguYWJzKGEyIC0gYjIpIDw9IGdsTWF0cml4LkVQU0lMT04qTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMiksIE1hdGguYWJzKGIyKSkgJiZcbiAgICAgICAgICAgIE1hdGguYWJzKGEzIC0gYjMpIDw9IGdsTWF0cml4LkVQU0lMT04qTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMyksIE1hdGguYWJzKGIzKSkgJiZcbiAgICAgICAgICAgIE1hdGguYWJzKGE0IC0gYjQpIDw9IGdsTWF0cml4LkVQU0lMT04qTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhNCksIE1hdGguYWJzKGI0KSkgJiZcbiAgICAgICAgICAgIE1hdGguYWJzKGE1IC0gYjUpIDw9IGdsTWF0cml4LkVQU0lMT04qTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhNSksIE1hdGguYWJzKGI1KSkpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBtYXQyZDtcbiIsIi8qIENvcHlyaWdodCAoYykgMjAxNSwgQnJhbmRvbiBKb25lcywgQ29saW4gTWFjS2VuemllIElWLlxuXG5QZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG5vZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG5pbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG50byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG5jb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbmZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cblRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG5hbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG5GSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbkFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbkxJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG5PVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG5USEUgU09GVFdBUkUuICovXG5cbnZhciBnbE1hdHJpeCA9IHJlcXVpcmUoXCIuL2NvbW1vbi5qc1wiKTtcblxuLyoqXG4gKiBAY2xhc3MgM3gzIE1hdHJpeFxuICogQG5hbWUgbWF0M1xuICovXG52YXIgbWF0MyA9IHt9O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgaWRlbnRpdHkgbWF0M1xuICpcbiAqIEByZXR1cm5zIHttYXQzfSBhIG5ldyAzeDMgbWF0cml4XG4gKi9cbm1hdDMuY3JlYXRlID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIG91dCA9IG5ldyBnbE1hdHJpeC5BUlJBWV9UWVBFKDkpO1xuICAgIG91dFswXSA9IDE7XG4gICAgb3V0WzFdID0gMDtcbiAgICBvdXRbMl0gPSAwO1xuICAgIG91dFszXSA9IDA7XG4gICAgb3V0WzRdID0gMTtcbiAgICBvdXRbNV0gPSAwO1xuICAgIG91dFs2XSA9IDA7XG4gICAgb3V0WzddID0gMDtcbiAgICBvdXRbOF0gPSAxO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENvcGllcyB0aGUgdXBwZXItbGVmdCAzeDMgdmFsdWVzIGludG8gdGhlIGdpdmVuIG1hdDMuXG4gKlxuICogQHBhcmFtIHttYXQzfSBvdXQgdGhlIHJlY2VpdmluZyAzeDMgbWF0cml4XG4gKiBAcGFyYW0ge21hdDR9IGEgICB0aGUgc291cmNlIDR4NCBtYXRyaXhcbiAqIEByZXR1cm5zIHttYXQzfSBvdXRcbiAqL1xubWF0My5mcm9tTWF0NCA9IGZ1bmN0aW9uKG91dCwgYSkge1xuICAgIG91dFswXSA9IGFbMF07XG4gICAgb3V0WzFdID0gYVsxXTtcbiAgICBvdXRbMl0gPSBhWzJdO1xuICAgIG91dFszXSA9IGFbNF07XG4gICAgb3V0WzRdID0gYVs1XTtcbiAgICBvdXRbNV0gPSBhWzZdO1xuICAgIG91dFs2XSA9IGFbOF07XG4gICAgb3V0WzddID0gYVs5XTtcbiAgICBvdXRbOF0gPSBhWzEwXTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IG1hdDMgaW5pdGlhbGl6ZWQgd2l0aCB2YWx1ZXMgZnJvbSBhbiBleGlzdGluZyBtYXRyaXhcbiAqXG4gKiBAcGFyYW0ge21hdDN9IGEgbWF0cml4IHRvIGNsb25lXG4gKiBAcmV0dXJucyB7bWF0M30gYSBuZXcgM3gzIG1hdHJpeFxuICovXG5tYXQzLmNsb25lID0gZnVuY3Rpb24oYSkge1xuICAgIHZhciBvdXQgPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSg5KTtcbiAgICBvdXRbMF0gPSBhWzBdO1xuICAgIG91dFsxXSA9IGFbMV07XG4gICAgb3V0WzJdID0gYVsyXTtcbiAgICBvdXRbM10gPSBhWzNdO1xuICAgIG91dFs0XSA9IGFbNF07XG4gICAgb3V0WzVdID0gYVs1XTtcbiAgICBvdXRbNl0gPSBhWzZdO1xuICAgIG91dFs3XSA9IGFbN107XG4gICAgb3V0WzhdID0gYVs4XTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDb3B5IHRoZSB2YWx1ZXMgZnJvbSBvbmUgbWF0MyB0byBhbm90aGVyXG4gKlxuICogQHBhcmFtIHttYXQzfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0M30gYSB0aGUgc291cmNlIG1hdHJpeFxuICogQHJldHVybnMge21hdDN9IG91dFxuICovXG5tYXQzLmNvcHkgPSBmdW5jdGlvbihvdXQsIGEpIHtcbiAgICBvdXRbMF0gPSBhWzBdO1xuICAgIG91dFsxXSA9IGFbMV07XG4gICAgb3V0WzJdID0gYVsyXTtcbiAgICBvdXRbM10gPSBhWzNdO1xuICAgIG91dFs0XSA9IGFbNF07XG4gICAgb3V0WzVdID0gYVs1XTtcbiAgICBvdXRbNl0gPSBhWzZdO1xuICAgIG91dFs3XSA9IGFbN107XG4gICAgb3V0WzhdID0gYVs4XTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDcmVhdGUgYSBuZXcgbWF0MyB3aXRoIHRoZSBnaXZlbiB2YWx1ZXNcbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gbTAwIENvbXBvbmVudCBpbiBjb2x1bW4gMCwgcm93IDAgcG9zaXRpb24gKGluZGV4IDApXG4gKiBAcGFyYW0ge051bWJlcn0gbTAxIENvbXBvbmVudCBpbiBjb2x1bW4gMCwgcm93IDEgcG9zaXRpb24gKGluZGV4IDEpXG4gKiBAcGFyYW0ge051bWJlcn0gbTAyIENvbXBvbmVudCBpbiBjb2x1bW4gMCwgcm93IDIgcG9zaXRpb24gKGluZGV4IDIpXG4gKiBAcGFyYW0ge051bWJlcn0gbTEwIENvbXBvbmVudCBpbiBjb2x1bW4gMSwgcm93IDAgcG9zaXRpb24gKGluZGV4IDMpXG4gKiBAcGFyYW0ge051bWJlcn0gbTExIENvbXBvbmVudCBpbiBjb2x1bW4gMSwgcm93IDEgcG9zaXRpb24gKGluZGV4IDQpXG4gKiBAcGFyYW0ge051bWJlcn0gbTEyIENvbXBvbmVudCBpbiBjb2x1bW4gMSwgcm93IDIgcG9zaXRpb24gKGluZGV4IDUpXG4gKiBAcGFyYW0ge051bWJlcn0gbTIwIENvbXBvbmVudCBpbiBjb2x1bW4gMiwgcm93IDAgcG9zaXRpb24gKGluZGV4IDYpXG4gKiBAcGFyYW0ge051bWJlcn0gbTIxIENvbXBvbmVudCBpbiBjb2x1bW4gMiwgcm93IDEgcG9zaXRpb24gKGluZGV4IDcpXG4gKiBAcGFyYW0ge051bWJlcn0gbTIyIENvbXBvbmVudCBpbiBjb2x1bW4gMiwgcm93IDIgcG9zaXRpb24gKGluZGV4IDgpXG4gKiBAcmV0dXJucyB7bWF0M30gQSBuZXcgbWF0M1xuICovXG5tYXQzLmZyb21WYWx1ZXMgPSBmdW5jdGlvbihtMDAsIG0wMSwgbTAyLCBtMTAsIG0xMSwgbTEyLCBtMjAsIG0yMSwgbTIyKSB7XG4gICAgdmFyIG91dCA9IG5ldyBnbE1hdHJpeC5BUlJBWV9UWVBFKDkpO1xuICAgIG91dFswXSA9IG0wMDtcbiAgICBvdXRbMV0gPSBtMDE7XG4gICAgb3V0WzJdID0gbTAyO1xuICAgIG91dFszXSA9IG0xMDtcbiAgICBvdXRbNF0gPSBtMTE7XG4gICAgb3V0WzVdID0gbTEyO1xuICAgIG91dFs2XSA9IG0yMDtcbiAgICBvdXRbN10gPSBtMjE7XG4gICAgb3V0WzhdID0gbTIyO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFNldCB0aGUgY29tcG9uZW50cyBvZiBhIG1hdDMgdG8gdGhlIGdpdmVuIHZhbHVlc1xuICpcbiAqIEBwYXJhbSB7bWF0M30gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge051bWJlcn0gbTAwIENvbXBvbmVudCBpbiBjb2x1bW4gMCwgcm93IDAgcG9zaXRpb24gKGluZGV4IDApXG4gKiBAcGFyYW0ge051bWJlcn0gbTAxIENvbXBvbmVudCBpbiBjb2x1bW4gMCwgcm93IDEgcG9zaXRpb24gKGluZGV4IDEpXG4gKiBAcGFyYW0ge051bWJlcn0gbTAyIENvbXBvbmVudCBpbiBjb2x1bW4gMCwgcm93IDIgcG9zaXRpb24gKGluZGV4IDIpXG4gKiBAcGFyYW0ge051bWJlcn0gbTEwIENvbXBvbmVudCBpbiBjb2x1bW4gMSwgcm93IDAgcG9zaXRpb24gKGluZGV4IDMpXG4gKiBAcGFyYW0ge051bWJlcn0gbTExIENvbXBvbmVudCBpbiBjb2x1bW4gMSwgcm93IDEgcG9zaXRpb24gKGluZGV4IDQpXG4gKiBAcGFyYW0ge051bWJlcn0gbTEyIENvbXBvbmVudCBpbiBjb2x1bW4gMSwgcm93IDIgcG9zaXRpb24gKGluZGV4IDUpXG4gKiBAcGFyYW0ge051bWJlcn0gbTIwIENvbXBvbmVudCBpbiBjb2x1bW4gMiwgcm93IDAgcG9zaXRpb24gKGluZGV4IDYpXG4gKiBAcGFyYW0ge051bWJlcn0gbTIxIENvbXBvbmVudCBpbiBjb2x1bW4gMiwgcm93IDEgcG9zaXRpb24gKGluZGV4IDcpXG4gKiBAcGFyYW0ge051bWJlcn0gbTIyIENvbXBvbmVudCBpbiBjb2x1bW4gMiwgcm93IDIgcG9zaXRpb24gKGluZGV4IDgpXG4gKiBAcmV0dXJucyB7bWF0M30gb3V0XG4gKi9cbm1hdDMuc2V0ID0gZnVuY3Rpb24ob3V0LCBtMDAsIG0wMSwgbTAyLCBtMTAsIG0xMSwgbTEyLCBtMjAsIG0yMSwgbTIyKSB7XG4gICAgb3V0WzBdID0gbTAwO1xuICAgIG91dFsxXSA9IG0wMTtcbiAgICBvdXRbMl0gPSBtMDI7XG4gICAgb3V0WzNdID0gbTEwO1xuICAgIG91dFs0XSA9IG0xMTtcbiAgICBvdXRbNV0gPSBtMTI7XG4gICAgb3V0WzZdID0gbTIwO1xuICAgIG91dFs3XSA9IG0yMTtcbiAgICBvdXRbOF0gPSBtMjI7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogU2V0IGEgbWF0MyB0byB0aGUgaWRlbnRpdHkgbWF0cml4XG4gKlxuICogQHBhcmFtIHttYXQzfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEByZXR1cm5zIHttYXQzfSBvdXRcbiAqL1xubWF0My5pZGVudGl0eSA9IGZ1bmN0aW9uKG91dCkge1xuICAgIG91dFswXSA9IDE7XG4gICAgb3V0WzFdID0gMDtcbiAgICBvdXRbMl0gPSAwO1xuICAgIG91dFszXSA9IDA7XG4gICAgb3V0WzRdID0gMTtcbiAgICBvdXRbNV0gPSAwO1xuICAgIG91dFs2XSA9IDA7XG4gICAgb3V0WzddID0gMDtcbiAgICBvdXRbOF0gPSAxO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFRyYW5zcG9zZSB0aGUgdmFsdWVzIG9mIGEgbWF0M1xuICpcbiAqIEBwYXJhbSB7bWF0M30gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDN9IGEgdGhlIHNvdXJjZSBtYXRyaXhcbiAqIEByZXR1cm5zIHttYXQzfSBvdXRcbiAqL1xubWF0My50cmFuc3Bvc2UgPSBmdW5jdGlvbihvdXQsIGEpIHtcbiAgICAvLyBJZiB3ZSBhcmUgdHJhbnNwb3Npbmcgb3Vyc2VsdmVzIHdlIGNhbiBza2lwIGEgZmV3IHN0ZXBzIGJ1dCBoYXZlIHRvIGNhY2hlIHNvbWUgdmFsdWVzXG4gICAgaWYgKG91dCA9PT0gYSkge1xuICAgICAgICB2YXIgYTAxID0gYVsxXSwgYTAyID0gYVsyXSwgYTEyID0gYVs1XTtcbiAgICAgICAgb3V0WzFdID0gYVszXTtcbiAgICAgICAgb3V0WzJdID0gYVs2XTtcbiAgICAgICAgb3V0WzNdID0gYTAxO1xuICAgICAgICBvdXRbNV0gPSBhWzddO1xuICAgICAgICBvdXRbNl0gPSBhMDI7XG4gICAgICAgIG91dFs3XSA9IGExMjtcbiAgICB9IGVsc2Uge1xuICAgICAgICBvdXRbMF0gPSBhWzBdO1xuICAgICAgICBvdXRbMV0gPSBhWzNdO1xuICAgICAgICBvdXRbMl0gPSBhWzZdO1xuICAgICAgICBvdXRbM10gPSBhWzFdO1xuICAgICAgICBvdXRbNF0gPSBhWzRdO1xuICAgICAgICBvdXRbNV0gPSBhWzddO1xuICAgICAgICBvdXRbNl0gPSBhWzJdO1xuICAgICAgICBvdXRbN10gPSBhWzVdO1xuICAgICAgICBvdXRbOF0gPSBhWzhdO1xuICAgIH1cbiAgICBcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBJbnZlcnRzIGEgbWF0M1xuICpcbiAqIEBwYXJhbSB7bWF0M30gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDN9IGEgdGhlIHNvdXJjZSBtYXRyaXhcbiAqIEByZXR1cm5zIHttYXQzfSBvdXRcbiAqL1xubWF0My5pbnZlcnQgPSBmdW5jdGlvbihvdXQsIGEpIHtcbiAgICB2YXIgYTAwID0gYVswXSwgYTAxID0gYVsxXSwgYTAyID0gYVsyXSxcbiAgICAgICAgYTEwID0gYVszXSwgYTExID0gYVs0XSwgYTEyID0gYVs1XSxcbiAgICAgICAgYTIwID0gYVs2XSwgYTIxID0gYVs3XSwgYTIyID0gYVs4XSxcblxuICAgICAgICBiMDEgPSBhMjIgKiBhMTEgLSBhMTIgKiBhMjEsXG4gICAgICAgIGIxMSA9IC1hMjIgKiBhMTAgKyBhMTIgKiBhMjAsXG4gICAgICAgIGIyMSA9IGEyMSAqIGExMCAtIGExMSAqIGEyMCxcblxuICAgICAgICAvLyBDYWxjdWxhdGUgdGhlIGRldGVybWluYW50XG4gICAgICAgIGRldCA9IGEwMCAqIGIwMSArIGEwMSAqIGIxMSArIGEwMiAqIGIyMTtcblxuICAgIGlmICghZGV0KSB7IFxuICAgICAgICByZXR1cm4gbnVsbDsgXG4gICAgfVxuICAgIGRldCA9IDEuMCAvIGRldDtcblxuICAgIG91dFswXSA9IGIwMSAqIGRldDtcbiAgICBvdXRbMV0gPSAoLWEyMiAqIGEwMSArIGEwMiAqIGEyMSkgKiBkZXQ7XG4gICAgb3V0WzJdID0gKGExMiAqIGEwMSAtIGEwMiAqIGExMSkgKiBkZXQ7XG4gICAgb3V0WzNdID0gYjExICogZGV0O1xuICAgIG91dFs0XSA9IChhMjIgKiBhMDAgLSBhMDIgKiBhMjApICogZGV0O1xuICAgIG91dFs1XSA9ICgtYTEyICogYTAwICsgYTAyICogYTEwKSAqIGRldDtcbiAgICBvdXRbNl0gPSBiMjEgKiBkZXQ7XG4gICAgb3V0WzddID0gKC1hMjEgKiBhMDAgKyBhMDEgKiBhMjApICogZGV0O1xuICAgIG91dFs4XSA9IChhMTEgKiBhMDAgLSBhMDEgKiBhMTApICogZGV0O1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGFkanVnYXRlIG9mIGEgbWF0M1xuICpcbiAqIEBwYXJhbSB7bWF0M30gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDN9IGEgdGhlIHNvdXJjZSBtYXRyaXhcbiAqIEByZXR1cm5zIHttYXQzfSBvdXRcbiAqL1xubWF0My5hZGpvaW50ID0gZnVuY3Rpb24ob3V0LCBhKSB7XG4gICAgdmFyIGEwMCA9IGFbMF0sIGEwMSA9IGFbMV0sIGEwMiA9IGFbMl0sXG4gICAgICAgIGExMCA9IGFbM10sIGExMSA9IGFbNF0sIGExMiA9IGFbNV0sXG4gICAgICAgIGEyMCA9IGFbNl0sIGEyMSA9IGFbN10sIGEyMiA9IGFbOF07XG5cbiAgICBvdXRbMF0gPSAoYTExICogYTIyIC0gYTEyICogYTIxKTtcbiAgICBvdXRbMV0gPSAoYTAyICogYTIxIC0gYTAxICogYTIyKTtcbiAgICBvdXRbMl0gPSAoYTAxICogYTEyIC0gYTAyICogYTExKTtcbiAgICBvdXRbM10gPSAoYTEyICogYTIwIC0gYTEwICogYTIyKTtcbiAgICBvdXRbNF0gPSAoYTAwICogYTIyIC0gYTAyICogYTIwKTtcbiAgICBvdXRbNV0gPSAoYTAyICogYTEwIC0gYTAwICogYTEyKTtcbiAgICBvdXRbNl0gPSAoYTEwICogYTIxIC0gYTExICogYTIwKTtcbiAgICBvdXRbN10gPSAoYTAxICogYTIwIC0gYTAwICogYTIxKTtcbiAgICBvdXRbOF0gPSAoYTAwICogYTExIC0gYTAxICogYTEwKTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBkZXRlcm1pbmFudCBvZiBhIG1hdDNcbiAqXG4gKiBAcGFyYW0ge21hdDN9IGEgdGhlIHNvdXJjZSBtYXRyaXhcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IGRldGVybWluYW50IG9mIGFcbiAqL1xubWF0My5kZXRlcm1pbmFudCA9IGZ1bmN0aW9uIChhKSB7XG4gICAgdmFyIGEwMCA9IGFbMF0sIGEwMSA9IGFbMV0sIGEwMiA9IGFbMl0sXG4gICAgICAgIGExMCA9IGFbM10sIGExMSA9IGFbNF0sIGExMiA9IGFbNV0sXG4gICAgICAgIGEyMCA9IGFbNl0sIGEyMSA9IGFbN10sIGEyMiA9IGFbOF07XG5cbiAgICByZXR1cm4gYTAwICogKGEyMiAqIGExMSAtIGExMiAqIGEyMSkgKyBhMDEgKiAoLWEyMiAqIGExMCArIGExMiAqIGEyMCkgKyBhMDIgKiAoYTIxICogYTEwIC0gYTExICogYTIwKTtcbn07XG5cbi8qKlxuICogTXVsdGlwbGllcyB0d28gbWF0MydzXG4gKlxuICogQHBhcmFtIHttYXQzfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0M30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHttYXQzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge21hdDN9IG91dFxuICovXG5tYXQzLm11bHRpcGx5ID0gZnVuY3Rpb24gKG91dCwgYSwgYikge1xuICAgIHZhciBhMDAgPSBhWzBdLCBhMDEgPSBhWzFdLCBhMDIgPSBhWzJdLFxuICAgICAgICBhMTAgPSBhWzNdLCBhMTEgPSBhWzRdLCBhMTIgPSBhWzVdLFxuICAgICAgICBhMjAgPSBhWzZdLCBhMjEgPSBhWzddLCBhMjIgPSBhWzhdLFxuXG4gICAgICAgIGIwMCA9IGJbMF0sIGIwMSA9IGJbMV0sIGIwMiA9IGJbMl0sXG4gICAgICAgIGIxMCA9IGJbM10sIGIxMSA9IGJbNF0sIGIxMiA9IGJbNV0sXG4gICAgICAgIGIyMCA9IGJbNl0sIGIyMSA9IGJbN10sIGIyMiA9IGJbOF07XG5cbiAgICBvdXRbMF0gPSBiMDAgKiBhMDAgKyBiMDEgKiBhMTAgKyBiMDIgKiBhMjA7XG4gICAgb3V0WzFdID0gYjAwICogYTAxICsgYjAxICogYTExICsgYjAyICogYTIxO1xuICAgIG91dFsyXSA9IGIwMCAqIGEwMiArIGIwMSAqIGExMiArIGIwMiAqIGEyMjtcblxuICAgIG91dFszXSA9IGIxMCAqIGEwMCArIGIxMSAqIGExMCArIGIxMiAqIGEyMDtcbiAgICBvdXRbNF0gPSBiMTAgKiBhMDEgKyBiMTEgKiBhMTEgKyBiMTIgKiBhMjE7XG4gICAgb3V0WzVdID0gYjEwICogYTAyICsgYjExICogYTEyICsgYjEyICogYTIyO1xuXG4gICAgb3V0WzZdID0gYjIwICogYTAwICsgYjIxICogYTEwICsgYjIyICogYTIwO1xuICAgIG91dFs3XSA9IGIyMCAqIGEwMSArIGIyMSAqIGExMSArIGIyMiAqIGEyMTtcbiAgICBvdXRbOF0gPSBiMjAgKiBhMDIgKyBiMjEgKiBhMTIgKyBiMjIgKiBhMjI7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayBtYXQzLm11bHRpcGx5fVxuICogQGZ1bmN0aW9uXG4gKi9cbm1hdDMubXVsID0gbWF0My5tdWx0aXBseTtcblxuLyoqXG4gKiBUcmFuc2xhdGUgYSBtYXQzIGJ5IHRoZSBnaXZlbiB2ZWN0b3JcbiAqXG4gKiBAcGFyYW0ge21hdDN9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQzfSBhIHRoZSBtYXRyaXggdG8gdHJhbnNsYXRlXG4gKiBAcGFyYW0ge3ZlYzJ9IHYgdmVjdG9yIHRvIHRyYW5zbGF0ZSBieVxuICogQHJldHVybnMge21hdDN9IG91dFxuICovXG5tYXQzLnRyYW5zbGF0ZSA9IGZ1bmN0aW9uKG91dCwgYSwgdikge1xuICAgIHZhciBhMDAgPSBhWzBdLCBhMDEgPSBhWzFdLCBhMDIgPSBhWzJdLFxuICAgICAgICBhMTAgPSBhWzNdLCBhMTEgPSBhWzRdLCBhMTIgPSBhWzVdLFxuICAgICAgICBhMjAgPSBhWzZdLCBhMjEgPSBhWzddLCBhMjIgPSBhWzhdLFxuICAgICAgICB4ID0gdlswXSwgeSA9IHZbMV07XG5cbiAgICBvdXRbMF0gPSBhMDA7XG4gICAgb3V0WzFdID0gYTAxO1xuICAgIG91dFsyXSA9IGEwMjtcblxuICAgIG91dFszXSA9IGExMDtcbiAgICBvdXRbNF0gPSBhMTE7XG4gICAgb3V0WzVdID0gYTEyO1xuXG4gICAgb3V0WzZdID0geCAqIGEwMCArIHkgKiBhMTAgKyBhMjA7XG4gICAgb3V0WzddID0geCAqIGEwMSArIHkgKiBhMTEgKyBhMjE7XG4gICAgb3V0WzhdID0geCAqIGEwMiArIHkgKiBhMTIgKyBhMjI7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogUm90YXRlcyBhIG1hdDMgYnkgdGhlIGdpdmVuIGFuZ2xlXG4gKlxuICogQHBhcmFtIHttYXQzfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0M30gYSB0aGUgbWF0cml4IHRvIHJvdGF0ZVxuICogQHBhcmFtIHtOdW1iZXJ9IHJhZCB0aGUgYW5nbGUgdG8gcm90YXRlIHRoZSBtYXRyaXggYnlcbiAqIEByZXR1cm5zIHttYXQzfSBvdXRcbiAqL1xubWF0My5yb3RhdGUgPSBmdW5jdGlvbiAob3V0LCBhLCByYWQpIHtcbiAgICB2YXIgYTAwID0gYVswXSwgYTAxID0gYVsxXSwgYTAyID0gYVsyXSxcbiAgICAgICAgYTEwID0gYVszXSwgYTExID0gYVs0XSwgYTEyID0gYVs1XSxcbiAgICAgICAgYTIwID0gYVs2XSwgYTIxID0gYVs3XSwgYTIyID0gYVs4XSxcblxuICAgICAgICBzID0gTWF0aC5zaW4ocmFkKSxcbiAgICAgICAgYyA9IE1hdGguY29zKHJhZCk7XG5cbiAgICBvdXRbMF0gPSBjICogYTAwICsgcyAqIGExMDtcbiAgICBvdXRbMV0gPSBjICogYTAxICsgcyAqIGExMTtcbiAgICBvdXRbMl0gPSBjICogYTAyICsgcyAqIGExMjtcblxuICAgIG91dFszXSA9IGMgKiBhMTAgLSBzICogYTAwO1xuICAgIG91dFs0XSA9IGMgKiBhMTEgLSBzICogYTAxO1xuICAgIG91dFs1XSA9IGMgKiBhMTIgLSBzICogYTAyO1xuXG4gICAgb3V0WzZdID0gYTIwO1xuICAgIG91dFs3XSA9IGEyMTtcbiAgICBvdXRbOF0gPSBhMjI7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogU2NhbGVzIHRoZSBtYXQzIGJ5IHRoZSBkaW1lbnNpb25zIGluIHRoZSBnaXZlbiB2ZWMyXG4gKlxuICogQHBhcmFtIHttYXQzfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0M30gYSB0aGUgbWF0cml4IHRvIHJvdGF0ZVxuICogQHBhcmFtIHt2ZWMyfSB2IHRoZSB2ZWMyIHRvIHNjYWxlIHRoZSBtYXRyaXggYnlcbiAqIEByZXR1cm5zIHttYXQzfSBvdXRcbiAqKi9cbm1hdDMuc2NhbGUgPSBmdW5jdGlvbihvdXQsIGEsIHYpIHtcbiAgICB2YXIgeCA9IHZbMF0sIHkgPSB2WzFdO1xuXG4gICAgb3V0WzBdID0geCAqIGFbMF07XG4gICAgb3V0WzFdID0geCAqIGFbMV07XG4gICAgb3V0WzJdID0geCAqIGFbMl07XG5cbiAgICBvdXRbM10gPSB5ICogYVszXTtcbiAgICBvdXRbNF0gPSB5ICogYVs0XTtcbiAgICBvdXRbNV0gPSB5ICogYVs1XTtcblxuICAgIG91dFs2XSA9IGFbNl07XG4gICAgb3V0WzddID0gYVs3XTtcbiAgICBvdXRbOF0gPSBhWzhdO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBtYXRyaXggZnJvbSBhIHZlY3RvciB0cmFuc2xhdGlvblxuICogVGhpcyBpcyBlcXVpdmFsZW50IHRvIChidXQgbXVjaCBmYXN0ZXIgdGhhbik6XG4gKlxuICogICAgIG1hdDMuaWRlbnRpdHkoZGVzdCk7XG4gKiAgICAgbWF0My50cmFuc2xhdGUoZGVzdCwgZGVzdCwgdmVjKTtcbiAqXG4gKiBAcGFyYW0ge21hdDN9IG91dCBtYXQzIHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XG4gKiBAcGFyYW0ge3ZlYzJ9IHYgVHJhbnNsYXRpb24gdmVjdG9yXG4gKiBAcmV0dXJucyB7bWF0M30gb3V0XG4gKi9cbm1hdDMuZnJvbVRyYW5zbGF0aW9uID0gZnVuY3Rpb24ob3V0LCB2KSB7XG4gICAgb3V0WzBdID0gMTtcbiAgICBvdXRbMV0gPSAwO1xuICAgIG91dFsyXSA9IDA7XG4gICAgb3V0WzNdID0gMDtcbiAgICBvdXRbNF0gPSAxO1xuICAgIG91dFs1XSA9IDA7XG4gICAgb3V0WzZdID0gdlswXTtcbiAgICBvdXRbN10gPSB2WzFdO1xuICAgIG91dFs4XSA9IDE7XG4gICAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbWF0cml4IGZyb20gYSBnaXZlbiBhbmdsZVxuICogVGhpcyBpcyBlcXVpdmFsZW50IHRvIChidXQgbXVjaCBmYXN0ZXIgdGhhbik6XG4gKlxuICogICAgIG1hdDMuaWRlbnRpdHkoZGVzdCk7XG4gKiAgICAgbWF0My5yb3RhdGUoZGVzdCwgZGVzdCwgcmFkKTtcbiAqXG4gKiBAcGFyYW0ge21hdDN9IG91dCBtYXQzIHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XG4gKiBAcGFyYW0ge051bWJlcn0gcmFkIHRoZSBhbmdsZSB0byByb3RhdGUgdGhlIG1hdHJpeCBieVxuICogQHJldHVybnMge21hdDN9IG91dFxuICovXG5tYXQzLmZyb21Sb3RhdGlvbiA9IGZ1bmN0aW9uKG91dCwgcmFkKSB7XG4gICAgdmFyIHMgPSBNYXRoLnNpbihyYWQpLCBjID0gTWF0aC5jb3MocmFkKTtcblxuICAgIG91dFswXSA9IGM7XG4gICAgb3V0WzFdID0gcztcbiAgICBvdXRbMl0gPSAwO1xuXG4gICAgb3V0WzNdID0gLXM7XG4gICAgb3V0WzRdID0gYztcbiAgICBvdXRbNV0gPSAwO1xuXG4gICAgb3V0WzZdID0gMDtcbiAgICBvdXRbN10gPSAwO1xuICAgIG91dFs4XSA9IDE7XG4gICAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbWF0cml4IGZyb20gYSB2ZWN0b3Igc2NhbGluZ1xuICogVGhpcyBpcyBlcXVpdmFsZW50IHRvIChidXQgbXVjaCBmYXN0ZXIgdGhhbik6XG4gKlxuICogICAgIG1hdDMuaWRlbnRpdHkoZGVzdCk7XG4gKiAgICAgbWF0My5zY2FsZShkZXN0LCBkZXN0LCB2ZWMpO1xuICpcbiAqIEBwYXJhbSB7bWF0M30gb3V0IG1hdDMgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcbiAqIEBwYXJhbSB7dmVjMn0gdiBTY2FsaW5nIHZlY3RvclxuICogQHJldHVybnMge21hdDN9IG91dFxuICovXG5tYXQzLmZyb21TY2FsaW5nID0gZnVuY3Rpb24ob3V0LCB2KSB7XG4gICAgb3V0WzBdID0gdlswXTtcbiAgICBvdXRbMV0gPSAwO1xuICAgIG91dFsyXSA9IDA7XG5cbiAgICBvdXRbM10gPSAwO1xuICAgIG91dFs0XSA9IHZbMV07XG4gICAgb3V0WzVdID0gMDtcblxuICAgIG91dFs2XSA9IDA7XG4gICAgb3V0WzddID0gMDtcbiAgICBvdXRbOF0gPSAxO1xuICAgIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogQ29waWVzIHRoZSB2YWx1ZXMgZnJvbSBhIG1hdDJkIGludG8gYSBtYXQzXG4gKlxuICogQHBhcmFtIHttYXQzfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0MmR9IGEgdGhlIG1hdHJpeCB0byBjb3B5XG4gKiBAcmV0dXJucyB7bWF0M30gb3V0XG4gKiovXG5tYXQzLmZyb21NYXQyZCA9IGZ1bmN0aW9uKG91dCwgYSkge1xuICAgIG91dFswXSA9IGFbMF07XG4gICAgb3V0WzFdID0gYVsxXTtcbiAgICBvdXRbMl0gPSAwO1xuXG4gICAgb3V0WzNdID0gYVsyXTtcbiAgICBvdXRbNF0gPSBhWzNdO1xuICAgIG91dFs1XSA9IDA7XG5cbiAgICBvdXRbNl0gPSBhWzRdO1xuICAgIG91dFs3XSA9IGFbNV07XG4gICAgb3V0WzhdID0gMTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4qIENhbGN1bGF0ZXMgYSAzeDMgbWF0cml4IGZyb20gdGhlIGdpdmVuIHF1YXRlcm5pb25cbipcbiogQHBhcmFtIHttYXQzfSBvdXQgbWF0MyByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxuKiBAcGFyYW0ge3F1YXR9IHEgUXVhdGVybmlvbiB0byBjcmVhdGUgbWF0cml4IGZyb21cbipcbiogQHJldHVybnMge21hdDN9IG91dFxuKi9cbm1hdDMuZnJvbVF1YXQgPSBmdW5jdGlvbiAob3V0LCBxKSB7XG4gICAgdmFyIHggPSBxWzBdLCB5ID0gcVsxXSwgeiA9IHFbMl0sIHcgPSBxWzNdLFxuICAgICAgICB4MiA9IHggKyB4LFxuICAgICAgICB5MiA9IHkgKyB5LFxuICAgICAgICB6MiA9IHogKyB6LFxuXG4gICAgICAgIHh4ID0geCAqIHgyLFxuICAgICAgICB5eCA9IHkgKiB4MixcbiAgICAgICAgeXkgPSB5ICogeTIsXG4gICAgICAgIHp4ID0geiAqIHgyLFxuICAgICAgICB6eSA9IHogKiB5MixcbiAgICAgICAgenogPSB6ICogejIsXG4gICAgICAgIHd4ID0gdyAqIHgyLFxuICAgICAgICB3eSA9IHcgKiB5MixcbiAgICAgICAgd3ogPSB3ICogejI7XG5cbiAgICBvdXRbMF0gPSAxIC0geXkgLSB6ejtcbiAgICBvdXRbM10gPSB5eCAtIHd6O1xuICAgIG91dFs2XSA9IHp4ICsgd3k7XG5cbiAgICBvdXRbMV0gPSB5eCArIHd6O1xuICAgIG91dFs0XSA9IDEgLSB4eCAtIHp6O1xuICAgIG91dFs3XSA9IHp5IC0gd3g7XG5cbiAgICBvdXRbMl0gPSB6eCAtIHd5O1xuICAgIG91dFs1XSA9IHp5ICsgd3g7XG4gICAgb3V0WzhdID0gMSAtIHh4IC0geXk7XG5cbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4qIENhbGN1bGF0ZXMgYSAzeDMgbm9ybWFsIG1hdHJpeCAodHJhbnNwb3NlIGludmVyc2UpIGZyb20gdGhlIDR4NCBtYXRyaXhcbipcbiogQHBhcmFtIHttYXQzfSBvdXQgbWF0MyByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxuKiBAcGFyYW0ge21hdDR9IGEgTWF0NCB0byBkZXJpdmUgdGhlIG5vcm1hbCBtYXRyaXggZnJvbVxuKlxuKiBAcmV0dXJucyB7bWF0M30gb3V0XG4qL1xubWF0My5ub3JtYWxGcm9tTWF0NCA9IGZ1bmN0aW9uIChvdXQsIGEpIHtcbiAgICB2YXIgYTAwID0gYVswXSwgYTAxID0gYVsxXSwgYTAyID0gYVsyXSwgYTAzID0gYVszXSxcbiAgICAgICAgYTEwID0gYVs0XSwgYTExID0gYVs1XSwgYTEyID0gYVs2XSwgYTEzID0gYVs3XSxcbiAgICAgICAgYTIwID0gYVs4XSwgYTIxID0gYVs5XSwgYTIyID0gYVsxMF0sIGEyMyA9IGFbMTFdLFxuICAgICAgICBhMzAgPSBhWzEyXSwgYTMxID0gYVsxM10sIGEzMiA9IGFbMTRdLCBhMzMgPSBhWzE1XSxcblxuICAgICAgICBiMDAgPSBhMDAgKiBhMTEgLSBhMDEgKiBhMTAsXG4gICAgICAgIGIwMSA9IGEwMCAqIGExMiAtIGEwMiAqIGExMCxcbiAgICAgICAgYjAyID0gYTAwICogYTEzIC0gYTAzICogYTEwLFxuICAgICAgICBiMDMgPSBhMDEgKiBhMTIgLSBhMDIgKiBhMTEsXG4gICAgICAgIGIwNCA9IGEwMSAqIGExMyAtIGEwMyAqIGExMSxcbiAgICAgICAgYjA1ID0gYTAyICogYTEzIC0gYTAzICogYTEyLFxuICAgICAgICBiMDYgPSBhMjAgKiBhMzEgLSBhMjEgKiBhMzAsXG4gICAgICAgIGIwNyA9IGEyMCAqIGEzMiAtIGEyMiAqIGEzMCxcbiAgICAgICAgYjA4ID0gYTIwICogYTMzIC0gYTIzICogYTMwLFxuICAgICAgICBiMDkgPSBhMjEgKiBhMzIgLSBhMjIgKiBhMzEsXG4gICAgICAgIGIxMCA9IGEyMSAqIGEzMyAtIGEyMyAqIGEzMSxcbiAgICAgICAgYjExID0gYTIyICogYTMzIC0gYTIzICogYTMyLFxuXG4gICAgICAgIC8vIENhbGN1bGF0ZSB0aGUgZGV0ZXJtaW5hbnRcbiAgICAgICAgZGV0ID0gYjAwICogYjExIC0gYjAxICogYjEwICsgYjAyICogYjA5ICsgYjAzICogYjA4IC0gYjA0ICogYjA3ICsgYjA1ICogYjA2O1xuXG4gICAgaWYgKCFkZXQpIHsgXG4gICAgICAgIHJldHVybiBudWxsOyBcbiAgICB9XG4gICAgZGV0ID0gMS4wIC8gZGV0O1xuXG4gICAgb3V0WzBdID0gKGExMSAqIGIxMSAtIGExMiAqIGIxMCArIGExMyAqIGIwOSkgKiBkZXQ7XG4gICAgb3V0WzFdID0gKGExMiAqIGIwOCAtIGExMCAqIGIxMSAtIGExMyAqIGIwNykgKiBkZXQ7XG4gICAgb3V0WzJdID0gKGExMCAqIGIxMCAtIGExMSAqIGIwOCArIGExMyAqIGIwNikgKiBkZXQ7XG5cbiAgICBvdXRbM10gPSAoYTAyICogYjEwIC0gYTAxICogYjExIC0gYTAzICogYjA5KSAqIGRldDtcbiAgICBvdXRbNF0gPSAoYTAwICogYjExIC0gYTAyICogYjA4ICsgYTAzICogYjA3KSAqIGRldDtcbiAgICBvdXRbNV0gPSAoYTAxICogYjA4IC0gYTAwICogYjEwIC0gYTAzICogYjA2KSAqIGRldDtcblxuICAgIG91dFs2XSA9IChhMzEgKiBiMDUgLSBhMzIgKiBiMDQgKyBhMzMgKiBiMDMpICogZGV0O1xuICAgIG91dFs3XSA9IChhMzIgKiBiMDIgLSBhMzAgKiBiMDUgLSBhMzMgKiBiMDEpICogZGV0O1xuICAgIG91dFs4XSA9IChhMzAgKiBiMDQgLSBhMzEgKiBiMDIgKyBhMzMgKiBiMDApICogZGV0O1xuXG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhIG1hdDNcbiAqXG4gKiBAcGFyYW0ge21hdDN9IG1hdCBtYXRyaXggdG8gcmVwcmVzZW50IGFzIGEgc3RyaW5nXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIG1hdHJpeFxuICovXG5tYXQzLnN0ciA9IGZ1bmN0aW9uIChhKSB7XG4gICAgcmV0dXJuICdtYXQzKCcgKyBhWzBdICsgJywgJyArIGFbMV0gKyAnLCAnICsgYVsyXSArICcsICcgKyBcbiAgICAgICAgICAgICAgICAgICAgYVszXSArICcsICcgKyBhWzRdICsgJywgJyArIGFbNV0gKyAnLCAnICsgXG4gICAgICAgICAgICAgICAgICAgIGFbNl0gKyAnLCAnICsgYVs3XSArICcsICcgKyBhWzhdICsgJyknO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIEZyb2Jlbml1cyBub3JtIG9mIGEgbWF0M1xuICpcbiAqIEBwYXJhbSB7bWF0M30gYSB0aGUgbWF0cml4IHRvIGNhbGN1bGF0ZSBGcm9iZW5pdXMgbm9ybSBvZlxuICogQHJldHVybnMge051bWJlcn0gRnJvYmVuaXVzIG5vcm1cbiAqL1xubWF0My5mcm9iID0gZnVuY3Rpb24gKGEpIHtcbiAgICByZXR1cm4oTWF0aC5zcXJ0KE1hdGgucG93KGFbMF0sIDIpICsgTWF0aC5wb3coYVsxXSwgMikgKyBNYXRoLnBvdyhhWzJdLCAyKSArIE1hdGgucG93KGFbM10sIDIpICsgTWF0aC5wb3coYVs0XSwgMikgKyBNYXRoLnBvdyhhWzVdLCAyKSArIE1hdGgucG93KGFbNl0sIDIpICsgTWF0aC5wb3coYVs3XSwgMikgKyBNYXRoLnBvdyhhWzhdLCAyKSkpXG59O1xuXG4vKipcbiAqIEFkZHMgdHdvIG1hdDMnc1xuICpcbiAqIEBwYXJhbSB7bWF0M30gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7bWF0M30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHttYXQzfSBvdXRcbiAqL1xubWF0My5hZGQgPSBmdW5jdGlvbihvdXQsIGEsIGIpIHtcbiAgICBvdXRbMF0gPSBhWzBdICsgYlswXTtcbiAgICBvdXRbMV0gPSBhWzFdICsgYlsxXTtcbiAgICBvdXRbMl0gPSBhWzJdICsgYlsyXTtcbiAgICBvdXRbM10gPSBhWzNdICsgYlszXTtcbiAgICBvdXRbNF0gPSBhWzRdICsgYls0XTtcbiAgICBvdXRbNV0gPSBhWzVdICsgYls1XTtcbiAgICBvdXRbNl0gPSBhWzZdICsgYls2XTtcbiAgICBvdXRbN10gPSBhWzddICsgYls3XTtcbiAgICBvdXRbOF0gPSBhWzhdICsgYls4XTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBTdWJ0cmFjdHMgbWF0cml4IGIgZnJvbSBtYXRyaXggYVxuICpcbiAqIEBwYXJhbSB7bWF0M30gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7bWF0M30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHttYXQzfSBvdXRcbiAqL1xubWF0My5zdWJ0cmFjdCA9IGZ1bmN0aW9uKG91dCwgYSwgYikge1xuICAgIG91dFswXSA9IGFbMF0gLSBiWzBdO1xuICAgIG91dFsxXSA9IGFbMV0gLSBiWzFdO1xuICAgIG91dFsyXSA9IGFbMl0gLSBiWzJdO1xuICAgIG91dFszXSA9IGFbM10gLSBiWzNdO1xuICAgIG91dFs0XSA9IGFbNF0gLSBiWzRdO1xuICAgIG91dFs1XSA9IGFbNV0gLSBiWzVdO1xuICAgIG91dFs2XSA9IGFbNl0gLSBiWzZdO1xuICAgIG91dFs3XSA9IGFbN10gLSBiWzddO1xuICAgIG91dFs4XSA9IGFbOF0gLSBiWzhdO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgbWF0My5zdWJ0cmFjdH1cbiAqIEBmdW5jdGlvblxuICovXG5tYXQzLnN1YiA9IG1hdDMuc3VidHJhY3Q7XG5cbi8qKlxuICogTXVsdGlwbHkgZWFjaCBlbGVtZW50IG9mIHRoZSBtYXRyaXggYnkgYSBzY2FsYXIuXG4gKlxuICogQHBhcmFtIHttYXQzfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0M30gYSB0aGUgbWF0cml4IHRvIHNjYWxlXG4gKiBAcGFyYW0ge051bWJlcn0gYiBhbW91bnQgdG8gc2NhbGUgdGhlIG1hdHJpeCdzIGVsZW1lbnRzIGJ5XG4gKiBAcmV0dXJucyB7bWF0M30gb3V0XG4gKi9cbm1hdDMubXVsdGlwbHlTY2FsYXIgPSBmdW5jdGlvbihvdXQsIGEsIGIpIHtcbiAgICBvdXRbMF0gPSBhWzBdICogYjtcbiAgICBvdXRbMV0gPSBhWzFdICogYjtcbiAgICBvdXRbMl0gPSBhWzJdICogYjtcbiAgICBvdXRbM10gPSBhWzNdICogYjtcbiAgICBvdXRbNF0gPSBhWzRdICogYjtcbiAgICBvdXRbNV0gPSBhWzVdICogYjtcbiAgICBvdXRbNl0gPSBhWzZdICogYjtcbiAgICBvdXRbN10gPSBhWzddICogYjtcbiAgICBvdXRbOF0gPSBhWzhdICogYjtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBBZGRzIHR3byBtYXQzJ3MgYWZ0ZXIgbXVsdGlwbHlpbmcgZWFjaCBlbGVtZW50IG9mIHRoZSBzZWNvbmQgb3BlcmFuZCBieSBhIHNjYWxhciB2YWx1ZS5cbiAqXG4gKiBAcGFyYW0ge21hdDN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHttYXQzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge21hdDN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcGFyYW0ge051bWJlcn0gc2NhbGUgdGhlIGFtb3VudCB0byBzY2FsZSBiJ3MgZWxlbWVudHMgYnkgYmVmb3JlIGFkZGluZ1xuICogQHJldHVybnMge21hdDN9IG91dFxuICovXG5tYXQzLm11bHRpcGx5U2NhbGFyQW5kQWRkID0gZnVuY3Rpb24ob3V0LCBhLCBiLCBzY2FsZSkge1xuICAgIG91dFswXSA9IGFbMF0gKyAoYlswXSAqIHNjYWxlKTtcbiAgICBvdXRbMV0gPSBhWzFdICsgKGJbMV0gKiBzY2FsZSk7XG4gICAgb3V0WzJdID0gYVsyXSArIChiWzJdICogc2NhbGUpO1xuICAgIG91dFszXSA9IGFbM10gKyAoYlszXSAqIHNjYWxlKTtcbiAgICBvdXRbNF0gPSBhWzRdICsgKGJbNF0gKiBzY2FsZSk7XG4gICAgb3V0WzVdID0gYVs1XSArIChiWzVdICogc2NhbGUpO1xuICAgIG91dFs2XSA9IGFbNl0gKyAoYls2XSAqIHNjYWxlKTtcbiAgICBvdXRbN10gPSBhWzddICsgKGJbN10gKiBzY2FsZSk7XG4gICAgb3V0WzhdID0gYVs4XSArIChiWzhdICogc2NhbGUpO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKlxuICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgbWF0cmljZXMgaGF2ZSBleGFjdGx5IHRoZSBzYW1lIGVsZW1lbnRzIGluIHRoZSBzYW1lIHBvc2l0aW9uICh3aGVuIGNvbXBhcmVkIHdpdGggPT09KVxuICpcbiAqIEBwYXJhbSB7bWF0M30gYSBUaGUgZmlyc3QgbWF0cml4LlxuICogQHBhcmFtIHttYXQzfSBiIFRoZSBzZWNvbmQgbWF0cml4LlxuICogQHJldHVybnMge0Jvb2xlYW59IFRydWUgaWYgdGhlIG1hdHJpY2VzIGFyZSBlcXVhbCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICovXG5tYXQzLmV4YWN0RXF1YWxzID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICByZXR1cm4gYVswXSA9PT0gYlswXSAmJiBhWzFdID09PSBiWzFdICYmIGFbMl0gPT09IGJbMl0gJiYgXG4gICAgICAgICAgIGFbM10gPT09IGJbM10gJiYgYVs0XSA9PT0gYls0XSAmJiBhWzVdID09PSBiWzVdICYmXG4gICAgICAgICAgIGFbNl0gPT09IGJbNl0gJiYgYVs3XSA9PT0gYls3XSAmJiBhWzhdID09PSBiWzhdO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSBtYXRyaWNlcyBoYXZlIGFwcHJveGltYXRlbHkgdGhlIHNhbWUgZWxlbWVudHMgaW4gdGhlIHNhbWUgcG9zaXRpb24uXG4gKlxuICogQHBhcmFtIHttYXQzfSBhIFRoZSBmaXJzdCBtYXRyaXguXG4gKiBAcGFyYW0ge21hdDN9IGIgVGhlIHNlY29uZCBtYXRyaXguXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gVHJ1ZSBpZiB0aGUgbWF0cmljZXMgYXJlIGVxdWFsLCBmYWxzZSBvdGhlcndpc2UuXG4gKi9cbm1hdDMuZXF1YWxzID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICB2YXIgYTAgPSBhWzBdLCBhMSA9IGFbMV0sIGEyID0gYVsyXSwgYTMgPSBhWzNdLCBhNCA9IGFbNF0sIGE1ID0gYVs1XSwgYTYgPSBhWzZdLCBhNyA9IGFbN10sIGE4ID0gYVs4XTtcbiAgICB2YXIgYjAgPSBiWzBdLCBiMSA9IGJbMV0sIGIyID0gYlsyXSwgYjMgPSBiWzNdLCBiNCA9IGJbNF0sIGI1ID0gYls1XSwgYjYgPSBhWzZdLCBiNyA9IGJbN10sIGI4ID0gYls4XTtcbiAgICByZXR1cm4gKE1hdGguYWJzKGEwIC0gYjApIDw9IGdsTWF0cml4LkVQU0lMT04qTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMCksIE1hdGguYWJzKGIwKSkgJiZcbiAgICAgICAgICAgIE1hdGguYWJzKGExIC0gYjEpIDw9IGdsTWF0cml4LkVQU0lMT04qTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMSksIE1hdGguYWJzKGIxKSkgJiZcbiAgICAgICAgICAgIE1hdGguYWJzKGEyIC0gYjIpIDw9IGdsTWF0cml4LkVQU0lMT04qTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMiksIE1hdGguYWJzKGIyKSkgJiZcbiAgICAgICAgICAgIE1hdGguYWJzKGEzIC0gYjMpIDw9IGdsTWF0cml4LkVQU0lMT04qTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMyksIE1hdGguYWJzKGIzKSkgJiZcbiAgICAgICAgICAgIE1hdGguYWJzKGE0IC0gYjQpIDw9IGdsTWF0cml4LkVQU0lMT04qTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhNCksIE1hdGguYWJzKGI0KSkgJiZcbiAgICAgICAgICAgIE1hdGguYWJzKGE1IC0gYjUpIDw9IGdsTWF0cml4LkVQU0lMT04qTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhNSksIE1hdGguYWJzKGI1KSkgJiZcbiAgICAgICAgICAgIE1hdGguYWJzKGE2IC0gYjYpIDw9IGdsTWF0cml4LkVQU0lMT04qTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhNiksIE1hdGguYWJzKGI2KSkgJiZcbiAgICAgICAgICAgIE1hdGguYWJzKGE3IC0gYjcpIDw9IGdsTWF0cml4LkVQU0lMT04qTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhNyksIE1hdGguYWJzKGI3KSkgJiZcbiAgICAgICAgICAgIE1hdGguYWJzKGE4IC0gYjgpIDw9IGdsTWF0cml4LkVQU0lMT04qTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhOCksIE1hdGguYWJzKGI4KSkpO1xufTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IG1hdDM7XG4iLCIvKiBDb3B5cmlnaHQgKGMpIDIwMTUsIEJyYW5kb24gSm9uZXMsIENvbGluIE1hY0tlbnppZSBJVi5cblxuUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxub2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xudG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG5mdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXG5UaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbklNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG5BVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG5MSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuVEhFIFNPRlRXQVJFLiAqL1xuXG52YXIgZ2xNYXRyaXggPSByZXF1aXJlKFwiLi9jb21tb24uanNcIik7XG5cbi8qKlxuICogQGNsYXNzIDR4NCBNYXRyaXhcbiAqIEBuYW1lIG1hdDRcbiAqL1xudmFyIG1hdDQgPSB7XG4gIHNjYWxhcjoge30sXG4gIFNJTUQ6IHt9LFxufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IGlkZW50aXR5IG1hdDRcbiAqXG4gKiBAcmV0dXJucyB7bWF0NH0gYSBuZXcgNHg0IG1hdHJpeFxuICovXG5tYXQ0LmNyZWF0ZSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBvdXQgPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSgxNik7XG4gICAgb3V0WzBdID0gMTtcbiAgICBvdXRbMV0gPSAwO1xuICAgIG91dFsyXSA9IDA7XG4gICAgb3V0WzNdID0gMDtcbiAgICBvdXRbNF0gPSAwO1xuICAgIG91dFs1XSA9IDE7XG4gICAgb3V0WzZdID0gMDtcbiAgICBvdXRbN10gPSAwO1xuICAgIG91dFs4XSA9IDA7XG4gICAgb3V0WzldID0gMDtcbiAgICBvdXRbMTBdID0gMTtcbiAgICBvdXRbMTFdID0gMDtcbiAgICBvdXRbMTJdID0gMDtcbiAgICBvdXRbMTNdID0gMDtcbiAgICBvdXRbMTRdID0gMDtcbiAgICBvdXRbMTVdID0gMTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IG1hdDQgaW5pdGlhbGl6ZWQgd2l0aCB2YWx1ZXMgZnJvbSBhbiBleGlzdGluZyBtYXRyaXhcbiAqXG4gKiBAcGFyYW0ge21hdDR9IGEgbWF0cml4IHRvIGNsb25lXG4gKiBAcmV0dXJucyB7bWF0NH0gYSBuZXcgNHg0IG1hdHJpeFxuICovXG5tYXQ0LmNsb25lID0gZnVuY3Rpb24oYSkge1xuICAgIHZhciBvdXQgPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSgxNik7XG4gICAgb3V0WzBdID0gYVswXTtcbiAgICBvdXRbMV0gPSBhWzFdO1xuICAgIG91dFsyXSA9IGFbMl07XG4gICAgb3V0WzNdID0gYVszXTtcbiAgICBvdXRbNF0gPSBhWzRdO1xuICAgIG91dFs1XSA9IGFbNV07XG4gICAgb3V0WzZdID0gYVs2XTtcbiAgICBvdXRbN10gPSBhWzddO1xuICAgIG91dFs4XSA9IGFbOF07XG4gICAgb3V0WzldID0gYVs5XTtcbiAgICBvdXRbMTBdID0gYVsxMF07XG4gICAgb3V0WzExXSA9IGFbMTFdO1xuICAgIG91dFsxMl0gPSBhWzEyXTtcbiAgICBvdXRbMTNdID0gYVsxM107XG4gICAgb3V0WzE0XSA9IGFbMTRdO1xuICAgIG91dFsxNV0gPSBhWzE1XTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDb3B5IHRoZSB2YWx1ZXMgZnJvbSBvbmUgbWF0NCB0byBhbm90aGVyXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0NH0gYSB0aGUgc291cmNlIG1hdHJpeFxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5tYXQ0LmNvcHkgPSBmdW5jdGlvbihvdXQsIGEpIHtcbiAgICBvdXRbMF0gPSBhWzBdO1xuICAgIG91dFsxXSA9IGFbMV07XG4gICAgb3V0WzJdID0gYVsyXTtcbiAgICBvdXRbM10gPSBhWzNdO1xuICAgIG91dFs0XSA9IGFbNF07XG4gICAgb3V0WzVdID0gYVs1XTtcbiAgICBvdXRbNl0gPSBhWzZdO1xuICAgIG91dFs3XSA9IGFbN107XG4gICAgb3V0WzhdID0gYVs4XTtcbiAgICBvdXRbOV0gPSBhWzldO1xuICAgIG91dFsxMF0gPSBhWzEwXTtcbiAgICBvdXRbMTFdID0gYVsxMV07XG4gICAgb3V0WzEyXSA9IGFbMTJdO1xuICAgIG91dFsxM10gPSBhWzEzXTtcbiAgICBvdXRbMTRdID0gYVsxNF07XG4gICAgb3V0WzE1XSA9IGFbMTVdO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENyZWF0ZSBhIG5ldyBtYXQ0IHdpdGggdGhlIGdpdmVuIHZhbHVlc1xuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMDAgQ29tcG9uZW50IGluIGNvbHVtbiAwLCByb3cgMCBwb3NpdGlvbiAoaW5kZXggMClcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMDEgQ29tcG9uZW50IGluIGNvbHVtbiAwLCByb3cgMSBwb3NpdGlvbiAoaW5kZXggMSlcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMDIgQ29tcG9uZW50IGluIGNvbHVtbiAwLCByb3cgMiBwb3NpdGlvbiAoaW5kZXggMilcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMDMgQ29tcG9uZW50IGluIGNvbHVtbiAwLCByb3cgMyBwb3NpdGlvbiAoaW5kZXggMylcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMTAgQ29tcG9uZW50IGluIGNvbHVtbiAxLCByb3cgMCBwb3NpdGlvbiAoaW5kZXggNClcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMTEgQ29tcG9uZW50IGluIGNvbHVtbiAxLCByb3cgMSBwb3NpdGlvbiAoaW5kZXggNSlcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMTIgQ29tcG9uZW50IGluIGNvbHVtbiAxLCByb3cgMiBwb3NpdGlvbiAoaW5kZXggNilcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMTMgQ29tcG9uZW50IGluIGNvbHVtbiAxLCByb3cgMyBwb3NpdGlvbiAoaW5kZXggNylcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMjAgQ29tcG9uZW50IGluIGNvbHVtbiAyLCByb3cgMCBwb3NpdGlvbiAoaW5kZXggOClcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMjEgQ29tcG9uZW50IGluIGNvbHVtbiAyLCByb3cgMSBwb3NpdGlvbiAoaW5kZXggOSlcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMjIgQ29tcG9uZW50IGluIGNvbHVtbiAyLCByb3cgMiBwb3NpdGlvbiAoaW5kZXggMTApXG4gKiBAcGFyYW0ge051bWJlcn0gbTIzIENvbXBvbmVudCBpbiBjb2x1bW4gMiwgcm93IDMgcG9zaXRpb24gKGluZGV4IDExKVxuICogQHBhcmFtIHtOdW1iZXJ9IG0zMCBDb21wb25lbnQgaW4gY29sdW1uIDMsIHJvdyAwIHBvc2l0aW9uIChpbmRleCAxMilcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMzEgQ29tcG9uZW50IGluIGNvbHVtbiAzLCByb3cgMSBwb3NpdGlvbiAoaW5kZXggMTMpXG4gKiBAcGFyYW0ge051bWJlcn0gbTMyIENvbXBvbmVudCBpbiBjb2x1bW4gMywgcm93IDIgcG9zaXRpb24gKGluZGV4IDE0KVxuICogQHBhcmFtIHtOdW1iZXJ9IG0zMyBDb21wb25lbnQgaW4gY29sdW1uIDMsIHJvdyAzIHBvc2l0aW9uIChpbmRleCAxNSlcbiAqIEByZXR1cm5zIHttYXQ0fSBBIG5ldyBtYXQ0XG4gKi9cbm1hdDQuZnJvbVZhbHVlcyA9IGZ1bmN0aW9uKG0wMCwgbTAxLCBtMDIsIG0wMywgbTEwLCBtMTEsIG0xMiwgbTEzLCBtMjAsIG0yMSwgbTIyLCBtMjMsIG0zMCwgbTMxLCBtMzIsIG0zMykge1xuICAgIHZhciBvdXQgPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSgxNik7XG4gICAgb3V0WzBdID0gbTAwO1xuICAgIG91dFsxXSA9IG0wMTtcbiAgICBvdXRbMl0gPSBtMDI7XG4gICAgb3V0WzNdID0gbTAzO1xuICAgIG91dFs0XSA9IG0xMDtcbiAgICBvdXRbNV0gPSBtMTE7XG4gICAgb3V0WzZdID0gbTEyO1xuICAgIG91dFs3XSA9IG0xMztcbiAgICBvdXRbOF0gPSBtMjA7XG4gICAgb3V0WzldID0gbTIxO1xuICAgIG91dFsxMF0gPSBtMjI7XG4gICAgb3V0WzExXSA9IG0yMztcbiAgICBvdXRbMTJdID0gbTMwO1xuICAgIG91dFsxM10gPSBtMzE7XG4gICAgb3V0WzE0XSA9IG0zMjtcbiAgICBvdXRbMTVdID0gbTMzO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFNldCB0aGUgY29tcG9uZW50cyBvZiBhIG1hdDQgdG8gdGhlIGdpdmVuIHZhbHVlc1xuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge051bWJlcn0gbTAwIENvbXBvbmVudCBpbiBjb2x1bW4gMCwgcm93IDAgcG9zaXRpb24gKGluZGV4IDApXG4gKiBAcGFyYW0ge051bWJlcn0gbTAxIENvbXBvbmVudCBpbiBjb2x1bW4gMCwgcm93IDEgcG9zaXRpb24gKGluZGV4IDEpXG4gKiBAcGFyYW0ge051bWJlcn0gbTAyIENvbXBvbmVudCBpbiBjb2x1bW4gMCwgcm93IDIgcG9zaXRpb24gKGluZGV4IDIpXG4gKiBAcGFyYW0ge051bWJlcn0gbTAzIENvbXBvbmVudCBpbiBjb2x1bW4gMCwgcm93IDMgcG9zaXRpb24gKGluZGV4IDMpXG4gKiBAcGFyYW0ge051bWJlcn0gbTEwIENvbXBvbmVudCBpbiBjb2x1bW4gMSwgcm93IDAgcG9zaXRpb24gKGluZGV4IDQpXG4gKiBAcGFyYW0ge051bWJlcn0gbTExIENvbXBvbmVudCBpbiBjb2x1bW4gMSwgcm93IDEgcG9zaXRpb24gKGluZGV4IDUpXG4gKiBAcGFyYW0ge051bWJlcn0gbTEyIENvbXBvbmVudCBpbiBjb2x1bW4gMSwgcm93IDIgcG9zaXRpb24gKGluZGV4IDYpXG4gKiBAcGFyYW0ge051bWJlcn0gbTEzIENvbXBvbmVudCBpbiBjb2x1bW4gMSwgcm93IDMgcG9zaXRpb24gKGluZGV4IDcpXG4gKiBAcGFyYW0ge051bWJlcn0gbTIwIENvbXBvbmVudCBpbiBjb2x1bW4gMiwgcm93IDAgcG9zaXRpb24gKGluZGV4IDgpXG4gKiBAcGFyYW0ge051bWJlcn0gbTIxIENvbXBvbmVudCBpbiBjb2x1bW4gMiwgcm93IDEgcG9zaXRpb24gKGluZGV4IDkpXG4gKiBAcGFyYW0ge051bWJlcn0gbTIyIENvbXBvbmVudCBpbiBjb2x1bW4gMiwgcm93IDIgcG9zaXRpb24gKGluZGV4IDEwKVxuICogQHBhcmFtIHtOdW1iZXJ9IG0yMyBDb21wb25lbnQgaW4gY29sdW1uIDIsIHJvdyAzIHBvc2l0aW9uIChpbmRleCAxMSlcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMzAgQ29tcG9uZW50IGluIGNvbHVtbiAzLCByb3cgMCBwb3NpdGlvbiAoaW5kZXggMTIpXG4gKiBAcGFyYW0ge051bWJlcn0gbTMxIENvbXBvbmVudCBpbiBjb2x1bW4gMywgcm93IDEgcG9zaXRpb24gKGluZGV4IDEzKVxuICogQHBhcmFtIHtOdW1iZXJ9IG0zMiBDb21wb25lbnQgaW4gY29sdW1uIDMsIHJvdyAyIHBvc2l0aW9uIChpbmRleCAxNClcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMzMgQ29tcG9uZW50IGluIGNvbHVtbiAzLCByb3cgMyBwb3NpdGlvbiAoaW5kZXggMTUpXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbm1hdDQuc2V0ID0gZnVuY3Rpb24ob3V0LCBtMDAsIG0wMSwgbTAyLCBtMDMsIG0xMCwgbTExLCBtMTIsIG0xMywgbTIwLCBtMjEsIG0yMiwgbTIzLCBtMzAsIG0zMSwgbTMyLCBtMzMpIHtcbiAgICBvdXRbMF0gPSBtMDA7XG4gICAgb3V0WzFdID0gbTAxO1xuICAgIG91dFsyXSA9IG0wMjtcbiAgICBvdXRbM10gPSBtMDM7XG4gICAgb3V0WzRdID0gbTEwO1xuICAgIG91dFs1XSA9IG0xMTtcbiAgICBvdXRbNl0gPSBtMTI7XG4gICAgb3V0WzddID0gbTEzO1xuICAgIG91dFs4XSA9IG0yMDtcbiAgICBvdXRbOV0gPSBtMjE7XG4gICAgb3V0WzEwXSA9IG0yMjtcbiAgICBvdXRbMTFdID0gbTIzO1xuICAgIG91dFsxMl0gPSBtMzA7XG4gICAgb3V0WzEzXSA9IG0zMTtcbiAgICBvdXRbMTRdID0gbTMyO1xuICAgIG91dFsxNV0gPSBtMzM7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cblxuLyoqXG4gKiBTZXQgYSBtYXQ0IHRvIHRoZSBpZGVudGl0eSBtYXRyaXhcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5tYXQ0LmlkZW50aXR5ID0gZnVuY3Rpb24ob3V0KSB7XG4gICAgb3V0WzBdID0gMTtcbiAgICBvdXRbMV0gPSAwO1xuICAgIG91dFsyXSA9IDA7XG4gICAgb3V0WzNdID0gMDtcbiAgICBvdXRbNF0gPSAwO1xuICAgIG91dFs1XSA9IDE7XG4gICAgb3V0WzZdID0gMDtcbiAgICBvdXRbN10gPSAwO1xuICAgIG91dFs4XSA9IDA7XG4gICAgb3V0WzldID0gMDtcbiAgICBvdXRbMTBdID0gMTtcbiAgICBvdXRbMTFdID0gMDtcbiAgICBvdXRbMTJdID0gMDtcbiAgICBvdXRbMTNdID0gMDtcbiAgICBvdXRbMTRdID0gMDtcbiAgICBvdXRbMTVdID0gMTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBUcmFuc3Bvc2UgdGhlIHZhbHVlcyBvZiBhIG1hdDQgbm90IHVzaW5nIFNJTURcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQ0fSBhIHRoZSBzb3VyY2UgbWF0cml4XG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbm1hdDQuc2NhbGFyLnRyYW5zcG9zZSA9IGZ1bmN0aW9uKG91dCwgYSkge1xuICAgIC8vIElmIHdlIGFyZSB0cmFuc3Bvc2luZyBvdXJzZWx2ZXMgd2UgY2FuIHNraXAgYSBmZXcgc3RlcHMgYnV0IGhhdmUgdG8gY2FjaGUgc29tZSB2YWx1ZXNcbiAgICBpZiAob3V0ID09PSBhKSB7XG4gICAgICAgIHZhciBhMDEgPSBhWzFdLCBhMDIgPSBhWzJdLCBhMDMgPSBhWzNdLFxuICAgICAgICAgICAgYTEyID0gYVs2XSwgYTEzID0gYVs3XSxcbiAgICAgICAgICAgIGEyMyA9IGFbMTFdO1xuXG4gICAgICAgIG91dFsxXSA9IGFbNF07XG4gICAgICAgIG91dFsyXSA9IGFbOF07XG4gICAgICAgIG91dFszXSA9IGFbMTJdO1xuICAgICAgICBvdXRbNF0gPSBhMDE7XG4gICAgICAgIG91dFs2XSA9IGFbOV07XG4gICAgICAgIG91dFs3XSA9IGFbMTNdO1xuICAgICAgICBvdXRbOF0gPSBhMDI7XG4gICAgICAgIG91dFs5XSA9IGExMjtcbiAgICAgICAgb3V0WzExXSA9IGFbMTRdO1xuICAgICAgICBvdXRbMTJdID0gYTAzO1xuICAgICAgICBvdXRbMTNdID0gYTEzO1xuICAgICAgICBvdXRbMTRdID0gYTIzO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIG91dFswXSA9IGFbMF07XG4gICAgICAgIG91dFsxXSA9IGFbNF07XG4gICAgICAgIG91dFsyXSA9IGFbOF07XG4gICAgICAgIG91dFszXSA9IGFbMTJdO1xuICAgICAgICBvdXRbNF0gPSBhWzFdO1xuICAgICAgICBvdXRbNV0gPSBhWzVdO1xuICAgICAgICBvdXRbNl0gPSBhWzldO1xuICAgICAgICBvdXRbN10gPSBhWzEzXTtcbiAgICAgICAgb3V0WzhdID0gYVsyXTtcbiAgICAgICAgb3V0WzldID0gYVs2XTtcbiAgICAgICAgb3V0WzEwXSA9IGFbMTBdO1xuICAgICAgICBvdXRbMTFdID0gYVsxNF07XG4gICAgICAgIG91dFsxMl0gPSBhWzNdO1xuICAgICAgICBvdXRbMTNdID0gYVs3XTtcbiAgICAgICAgb3V0WzE0XSA9IGFbMTFdO1xuICAgICAgICBvdXRbMTVdID0gYVsxNV07XG4gICAgfVxuXG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogVHJhbnNwb3NlIHRoZSB2YWx1ZXMgb2YgYSBtYXQ0IHVzaW5nIFNJTURcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQ0fSBhIHRoZSBzb3VyY2UgbWF0cml4XG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbm1hdDQuU0lNRC50cmFuc3Bvc2UgPSBmdW5jdGlvbihvdXQsIGEpIHtcbiAgICB2YXIgYTAsIGExLCBhMiwgYTMsXG4gICAgICAgIHRtcDAxLCB0bXAyMyxcbiAgICAgICAgb3V0MCwgb3V0MSwgb3V0Miwgb3V0MztcblxuICAgIGEwID0gU0lNRC5GbG9hdDMyeDQubG9hZChhLCAwKTtcbiAgICBhMSA9IFNJTUQuRmxvYXQzMng0LmxvYWQoYSwgNCk7XG4gICAgYTIgPSBTSU1ELkZsb2F0MzJ4NC5sb2FkKGEsIDgpO1xuICAgIGEzID0gU0lNRC5GbG9hdDMyeDQubG9hZChhLCAxMik7XG5cbiAgICB0bXAwMSA9IFNJTUQuRmxvYXQzMng0LnNodWZmbGUoYTAsIGExLCAwLCAxLCA0LCA1KTtcbiAgICB0bXAyMyA9IFNJTUQuRmxvYXQzMng0LnNodWZmbGUoYTIsIGEzLCAwLCAxLCA0LCA1KTtcbiAgICBvdXQwICA9IFNJTUQuRmxvYXQzMng0LnNodWZmbGUodG1wMDEsIHRtcDIzLCAwLCAyLCA0LCA2KTtcbiAgICBvdXQxICA9IFNJTUQuRmxvYXQzMng0LnNodWZmbGUodG1wMDEsIHRtcDIzLCAxLCAzLCA1LCA3KTtcbiAgICBTSU1ELkZsb2F0MzJ4NC5zdG9yZShvdXQsIDAsICBvdXQwKTtcbiAgICBTSU1ELkZsb2F0MzJ4NC5zdG9yZShvdXQsIDQsICBvdXQxKTtcblxuICAgIHRtcDAxID0gU0lNRC5GbG9hdDMyeDQuc2h1ZmZsZShhMCwgYTEsIDIsIDMsIDYsIDcpO1xuICAgIHRtcDIzID0gU0lNRC5GbG9hdDMyeDQuc2h1ZmZsZShhMiwgYTMsIDIsIDMsIDYsIDcpO1xuICAgIG91dDIgID0gU0lNRC5GbG9hdDMyeDQuc2h1ZmZsZSh0bXAwMSwgdG1wMjMsIDAsIDIsIDQsIDYpO1xuICAgIG91dDMgID0gU0lNRC5GbG9hdDMyeDQuc2h1ZmZsZSh0bXAwMSwgdG1wMjMsIDEsIDMsIDUsIDcpO1xuICAgIFNJTUQuRmxvYXQzMng0LnN0b3JlKG91dCwgOCwgIG91dDIpO1xuICAgIFNJTUQuRmxvYXQzMng0LnN0b3JlKG91dCwgMTIsIG91dDMpO1xuXG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogVHJhbnNwc2UgYSBtYXQ0IHVzaW5nIFNJTUQgaWYgYXZhaWxhYmxlIGFuZCBlbmFibGVkXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0NH0gYSB0aGUgc291cmNlIG1hdHJpeFxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5tYXQ0LnRyYW5zcG9zZSA9IGdsTWF0cml4LlVTRV9TSU1EID8gbWF0NC5TSU1ELnRyYW5zcG9zZSA6IG1hdDQuc2NhbGFyLnRyYW5zcG9zZTtcblxuLyoqXG4gKiBJbnZlcnRzIGEgbWF0NCBub3QgdXNpbmcgU0lNRFxuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDR9IGEgdGhlIHNvdXJjZSBtYXRyaXhcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xubWF0NC5zY2FsYXIuaW52ZXJ0ID0gZnVuY3Rpb24ob3V0LCBhKSB7XG4gICAgdmFyIGEwMCA9IGFbMF0sIGEwMSA9IGFbMV0sIGEwMiA9IGFbMl0sIGEwMyA9IGFbM10sXG4gICAgICAgIGExMCA9IGFbNF0sIGExMSA9IGFbNV0sIGExMiA9IGFbNl0sIGExMyA9IGFbN10sXG4gICAgICAgIGEyMCA9IGFbOF0sIGEyMSA9IGFbOV0sIGEyMiA9IGFbMTBdLCBhMjMgPSBhWzExXSxcbiAgICAgICAgYTMwID0gYVsxMl0sIGEzMSA9IGFbMTNdLCBhMzIgPSBhWzE0XSwgYTMzID0gYVsxNV0sXG5cbiAgICAgICAgYjAwID0gYTAwICogYTExIC0gYTAxICogYTEwLFxuICAgICAgICBiMDEgPSBhMDAgKiBhMTIgLSBhMDIgKiBhMTAsXG4gICAgICAgIGIwMiA9IGEwMCAqIGExMyAtIGEwMyAqIGExMCxcbiAgICAgICAgYjAzID0gYTAxICogYTEyIC0gYTAyICogYTExLFxuICAgICAgICBiMDQgPSBhMDEgKiBhMTMgLSBhMDMgKiBhMTEsXG4gICAgICAgIGIwNSA9IGEwMiAqIGExMyAtIGEwMyAqIGExMixcbiAgICAgICAgYjA2ID0gYTIwICogYTMxIC0gYTIxICogYTMwLFxuICAgICAgICBiMDcgPSBhMjAgKiBhMzIgLSBhMjIgKiBhMzAsXG4gICAgICAgIGIwOCA9IGEyMCAqIGEzMyAtIGEyMyAqIGEzMCxcbiAgICAgICAgYjA5ID0gYTIxICogYTMyIC0gYTIyICogYTMxLFxuICAgICAgICBiMTAgPSBhMjEgKiBhMzMgLSBhMjMgKiBhMzEsXG4gICAgICAgIGIxMSA9IGEyMiAqIGEzMyAtIGEyMyAqIGEzMixcblxuICAgICAgICAvLyBDYWxjdWxhdGUgdGhlIGRldGVybWluYW50XG4gICAgICAgIGRldCA9IGIwMCAqIGIxMSAtIGIwMSAqIGIxMCArIGIwMiAqIGIwOSArIGIwMyAqIGIwOCAtIGIwNCAqIGIwNyArIGIwNSAqIGIwNjtcblxuICAgIGlmICghZGV0KSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBkZXQgPSAxLjAgLyBkZXQ7XG5cbiAgICBvdXRbMF0gPSAoYTExICogYjExIC0gYTEyICogYjEwICsgYTEzICogYjA5KSAqIGRldDtcbiAgICBvdXRbMV0gPSAoYTAyICogYjEwIC0gYTAxICogYjExIC0gYTAzICogYjA5KSAqIGRldDtcbiAgICBvdXRbMl0gPSAoYTMxICogYjA1IC0gYTMyICogYjA0ICsgYTMzICogYjAzKSAqIGRldDtcbiAgICBvdXRbM10gPSAoYTIyICogYjA0IC0gYTIxICogYjA1IC0gYTIzICogYjAzKSAqIGRldDtcbiAgICBvdXRbNF0gPSAoYTEyICogYjA4IC0gYTEwICogYjExIC0gYTEzICogYjA3KSAqIGRldDtcbiAgICBvdXRbNV0gPSAoYTAwICogYjExIC0gYTAyICogYjA4ICsgYTAzICogYjA3KSAqIGRldDtcbiAgICBvdXRbNl0gPSAoYTMyICogYjAyIC0gYTMwICogYjA1IC0gYTMzICogYjAxKSAqIGRldDtcbiAgICBvdXRbN10gPSAoYTIwICogYjA1IC0gYTIyICogYjAyICsgYTIzICogYjAxKSAqIGRldDtcbiAgICBvdXRbOF0gPSAoYTEwICogYjEwIC0gYTExICogYjA4ICsgYTEzICogYjA2KSAqIGRldDtcbiAgICBvdXRbOV0gPSAoYTAxICogYjA4IC0gYTAwICogYjEwIC0gYTAzICogYjA2KSAqIGRldDtcbiAgICBvdXRbMTBdID0gKGEzMCAqIGIwNCAtIGEzMSAqIGIwMiArIGEzMyAqIGIwMCkgKiBkZXQ7XG4gICAgb3V0WzExXSA9IChhMjEgKiBiMDIgLSBhMjAgKiBiMDQgLSBhMjMgKiBiMDApICogZGV0O1xuICAgIG91dFsxMl0gPSAoYTExICogYjA3IC0gYTEwICogYjA5IC0gYTEyICogYjA2KSAqIGRldDtcbiAgICBvdXRbMTNdID0gKGEwMCAqIGIwOSAtIGEwMSAqIGIwNyArIGEwMiAqIGIwNikgKiBkZXQ7XG4gICAgb3V0WzE0XSA9IChhMzEgKiBiMDEgLSBhMzAgKiBiMDMgLSBhMzIgKiBiMDApICogZGV0O1xuICAgIG91dFsxNV0gPSAoYTIwICogYjAzIC0gYTIxICogYjAxICsgYTIyICogYjAwKSAqIGRldDtcblxuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIEludmVydHMgYSBtYXQ0IHVzaW5nIFNJTURcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQ0fSBhIHRoZSBzb3VyY2UgbWF0cml4XG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbm1hdDQuU0lNRC5pbnZlcnQgPSBmdW5jdGlvbihvdXQsIGEpIHtcbiAgdmFyIHJvdzAsIHJvdzEsIHJvdzIsIHJvdzMsXG4gICAgICB0bXAxLFxuICAgICAgbWlub3IwLCBtaW5vcjEsIG1pbm9yMiwgbWlub3IzLFxuICAgICAgZGV0LFxuICAgICAgYTAgPSBTSU1ELkZsb2F0MzJ4NC5sb2FkKGEsIDApLFxuICAgICAgYTEgPSBTSU1ELkZsb2F0MzJ4NC5sb2FkKGEsIDQpLFxuICAgICAgYTIgPSBTSU1ELkZsb2F0MzJ4NC5sb2FkKGEsIDgpLFxuICAgICAgYTMgPSBTSU1ELkZsb2F0MzJ4NC5sb2FkKGEsIDEyKTtcblxuICAvLyBDb21wdXRlIG1hdHJpeCBhZGp1Z2F0ZVxuICB0bXAxID0gU0lNRC5GbG9hdDMyeDQuc2h1ZmZsZShhMCwgYTEsIDAsIDEsIDQsIDUpO1xuICByb3cxID0gU0lNRC5GbG9hdDMyeDQuc2h1ZmZsZShhMiwgYTMsIDAsIDEsIDQsIDUpO1xuICByb3cwID0gU0lNRC5GbG9hdDMyeDQuc2h1ZmZsZSh0bXAxLCByb3cxLCAwLCAyLCA0LCA2KTtcbiAgcm93MSA9IFNJTUQuRmxvYXQzMng0LnNodWZmbGUocm93MSwgdG1wMSwgMSwgMywgNSwgNyk7XG4gIHRtcDEgPSBTSU1ELkZsb2F0MzJ4NC5zaHVmZmxlKGEwLCBhMSwgMiwgMywgNiwgNyk7XG4gIHJvdzMgPSBTSU1ELkZsb2F0MzJ4NC5zaHVmZmxlKGEyLCBhMywgMiwgMywgNiwgNyk7XG4gIHJvdzIgPSBTSU1ELkZsb2F0MzJ4NC5zaHVmZmxlKHRtcDEsIHJvdzMsIDAsIDIsIDQsIDYpO1xuICByb3czID0gU0lNRC5GbG9hdDMyeDQuc2h1ZmZsZShyb3czLCB0bXAxLCAxLCAzLCA1LCA3KTtcblxuICB0bXAxICAgPSBTSU1ELkZsb2F0MzJ4NC5tdWwocm93Miwgcm93Myk7XG4gIHRtcDEgICA9IFNJTUQuRmxvYXQzMng0LnN3aXp6bGUodG1wMSwgMSwgMCwgMywgMik7XG4gIG1pbm9yMCA9IFNJTUQuRmxvYXQzMng0Lm11bChyb3cxLCB0bXAxKTtcbiAgbWlub3IxID0gU0lNRC5GbG9hdDMyeDQubXVsKHJvdzAsIHRtcDEpO1xuICB0bXAxICAgPSBTSU1ELkZsb2F0MzJ4NC5zd2l6emxlKHRtcDEsIDIsIDMsIDAsIDEpO1xuICBtaW5vcjAgPSBTSU1ELkZsb2F0MzJ4NC5zdWIoU0lNRC5GbG9hdDMyeDQubXVsKHJvdzEsIHRtcDEpLCBtaW5vcjApO1xuICBtaW5vcjEgPSBTSU1ELkZsb2F0MzJ4NC5zdWIoU0lNRC5GbG9hdDMyeDQubXVsKHJvdzAsIHRtcDEpLCBtaW5vcjEpO1xuICBtaW5vcjEgPSBTSU1ELkZsb2F0MzJ4NC5zd2l6emxlKG1pbm9yMSwgMiwgMywgMCwgMSk7XG5cbiAgdG1wMSAgID0gU0lNRC5GbG9hdDMyeDQubXVsKHJvdzEsIHJvdzIpO1xuICB0bXAxICAgPSBTSU1ELkZsb2F0MzJ4NC5zd2l6emxlKHRtcDEsIDEsIDAsIDMsIDIpO1xuICBtaW5vcjAgPSBTSU1ELkZsb2F0MzJ4NC5hZGQoU0lNRC5GbG9hdDMyeDQubXVsKHJvdzMsIHRtcDEpLCBtaW5vcjApO1xuICBtaW5vcjMgPSBTSU1ELkZsb2F0MzJ4NC5tdWwocm93MCwgdG1wMSk7XG4gIHRtcDEgICA9IFNJTUQuRmxvYXQzMng0LnN3aXp6bGUodG1wMSwgMiwgMywgMCwgMSk7XG4gIG1pbm9yMCA9IFNJTUQuRmxvYXQzMng0LnN1YihtaW5vcjAsIFNJTUQuRmxvYXQzMng0Lm11bChyb3czLCB0bXAxKSk7XG4gIG1pbm9yMyA9IFNJTUQuRmxvYXQzMng0LnN1YihTSU1ELkZsb2F0MzJ4NC5tdWwocm93MCwgdG1wMSksIG1pbm9yMyk7XG4gIG1pbm9yMyA9IFNJTUQuRmxvYXQzMng0LnN3aXp6bGUobWlub3IzLCAyLCAzLCAwLCAxKTtcblxuICB0bXAxICAgPSBTSU1ELkZsb2F0MzJ4NC5tdWwoU0lNRC5GbG9hdDMyeDQuc3dpenpsZShyb3cxLCAyLCAzLCAwLCAxKSwgcm93Myk7XG4gIHRtcDEgICA9IFNJTUQuRmxvYXQzMng0LnN3aXp6bGUodG1wMSwgMSwgMCwgMywgMik7XG4gIHJvdzIgICA9IFNJTUQuRmxvYXQzMng0LnN3aXp6bGUocm93MiwgMiwgMywgMCwgMSk7XG4gIG1pbm9yMCA9IFNJTUQuRmxvYXQzMng0LmFkZChTSU1ELkZsb2F0MzJ4NC5tdWwocm93MiwgdG1wMSksIG1pbm9yMCk7XG4gIG1pbm9yMiA9IFNJTUQuRmxvYXQzMng0Lm11bChyb3cwLCB0bXAxKTtcbiAgdG1wMSAgID0gU0lNRC5GbG9hdDMyeDQuc3dpenpsZSh0bXAxLCAyLCAzLCAwLCAxKTtcbiAgbWlub3IwID0gU0lNRC5GbG9hdDMyeDQuc3ViKG1pbm9yMCwgU0lNRC5GbG9hdDMyeDQubXVsKHJvdzIsIHRtcDEpKTtcbiAgbWlub3IyID0gU0lNRC5GbG9hdDMyeDQuc3ViKFNJTUQuRmxvYXQzMng0Lm11bChyb3cwLCB0bXAxKSwgbWlub3IyKTtcbiAgbWlub3IyID0gU0lNRC5GbG9hdDMyeDQuc3dpenpsZShtaW5vcjIsIDIsIDMsIDAsIDEpO1xuXG4gIHRtcDEgICA9IFNJTUQuRmxvYXQzMng0Lm11bChyb3cwLCByb3cxKTtcbiAgdG1wMSAgID0gU0lNRC5GbG9hdDMyeDQuc3dpenpsZSh0bXAxLCAxLCAwLCAzLCAyKTtcbiAgbWlub3IyID0gU0lNRC5GbG9hdDMyeDQuYWRkKFNJTUQuRmxvYXQzMng0Lm11bChyb3czLCB0bXAxKSwgbWlub3IyKTtcbiAgbWlub3IzID0gU0lNRC5GbG9hdDMyeDQuc3ViKFNJTUQuRmxvYXQzMng0Lm11bChyb3cyLCB0bXAxKSwgbWlub3IzKTtcbiAgdG1wMSAgID0gU0lNRC5GbG9hdDMyeDQuc3dpenpsZSh0bXAxLCAyLCAzLCAwLCAxKTtcbiAgbWlub3IyID0gU0lNRC5GbG9hdDMyeDQuc3ViKFNJTUQuRmxvYXQzMng0Lm11bChyb3czLCB0bXAxKSwgbWlub3IyKTtcbiAgbWlub3IzID0gU0lNRC5GbG9hdDMyeDQuc3ViKG1pbm9yMywgU0lNRC5GbG9hdDMyeDQubXVsKHJvdzIsIHRtcDEpKTtcblxuICB0bXAxICAgPSBTSU1ELkZsb2F0MzJ4NC5tdWwocm93MCwgcm93Myk7XG4gIHRtcDEgICA9IFNJTUQuRmxvYXQzMng0LnN3aXp6bGUodG1wMSwgMSwgMCwgMywgMik7XG4gIG1pbm9yMSA9IFNJTUQuRmxvYXQzMng0LnN1YihtaW5vcjEsIFNJTUQuRmxvYXQzMng0Lm11bChyb3cyLCB0bXAxKSk7XG4gIG1pbm9yMiA9IFNJTUQuRmxvYXQzMng0LmFkZChTSU1ELkZsb2F0MzJ4NC5tdWwocm93MSwgdG1wMSksIG1pbm9yMik7XG4gIHRtcDEgICA9IFNJTUQuRmxvYXQzMng0LnN3aXp6bGUodG1wMSwgMiwgMywgMCwgMSk7XG4gIG1pbm9yMSA9IFNJTUQuRmxvYXQzMng0LmFkZChTSU1ELkZsb2F0MzJ4NC5tdWwocm93MiwgdG1wMSksIG1pbm9yMSk7XG4gIG1pbm9yMiA9IFNJTUQuRmxvYXQzMng0LnN1YihtaW5vcjIsIFNJTUQuRmxvYXQzMng0Lm11bChyb3cxLCB0bXAxKSk7XG5cbiAgdG1wMSAgID0gU0lNRC5GbG9hdDMyeDQubXVsKHJvdzAsIHJvdzIpO1xuICB0bXAxICAgPSBTSU1ELkZsb2F0MzJ4NC5zd2l6emxlKHRtcDEsIDEsIDAsIDMsIDIpO1xuICBtaW5vcjEgPSBTSU1ELkZsb2F0MzJ4NC5hZGQoU0lNRC5GbG9hdDMyeDQubXVsKHJvdzMsIHRtcDEpLCBtaW5vcjEpO1xuICBtaW5vcjMgPSBTSU1ELkZsb2F0MzJ4NC5zdWIobWlub3IzLCBTSU1ELkZsb2F0MzJ4NC5tdWwocm93MSwgdG1wMSkpO1xuICB0bXAxICAgPSBTSU1ELkZsb2F0MzJ4NC5zd2l6emxlKHRtcDEsIDIsIDMsIDAsIDEpO1xuICBtaW5vcjEgPSBTSU1ELkZsb2F0MzJ4NC5zdWIobWlub3IxLCBTSU1ELkZsb2F0MzJ4NC5tdWwocm93MywgdG1wMSkpO1xuICBtaW5vcjMgPSBTSU1ELkZsb2F0MzJ4NC5hZGQoU0lNRC5GbG9hdDMyeDQubXVsKHJvdzEsIHRtcDEpLCBtaW5vcjMpO1xuXG4gIC8vIENvbXB1dGUgbWF0cml4IGRldGVybWluYW50XG4gIGRldCAgID0gU0lNRC5GbG9hdDMyeDQubXVsKHJvdzAsIG1pbm9yMCk7XG4gIGRldCAgID0gU0lNRC5GbG9hdDMyeDQuYWRkKFNJTUQuRmxvYXQzMng0LnN3aXp6bGUoZGV0LCAyLCAzLCAwLCAxKSwgZGV0KTtcbiAgZGV0ICAgPSBTSU1ELkZsb2F0MzJ4NC5hZGQoU0lNRC5GbG9hdDMyeDQuc3dpenpsZShkZXQsIDEsIDAsIDMsIDIpLCBkZXQpO1xuICB0bXAxICA9IFNJTUQuRmxvYXQzMng0LnJlY2lwcm9jYWxBcHByb3hpbWF0aW9uKGRldCk7XG4gIGRldCAgID0gU0lNRC5GbG9hdDMyeDQuc3ViKFxuICAgICAgICAgICAgICAgU0lNRC5GbG9hdDMyeDQuYWRkKHRtcDEsIHRtcDEpLFxuICAgICAgICAgICAgICAgU0lNRC5GbG9hdDMyeDQubXVsKGRldCwgU0lNRC5GbG9hdDMyeDQubXVsKHRtcDEsIHRtcDEpKSk7XG4gIGRldCAgID0gU0lNRC5GbG9hdDMyeDQuc3dpenpsZShkZXQsIDAsIDAsIDAsIDApO1xuICBpZiAoIWRldCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvLyBDb21wdXRlIG1hdHJpeCBpbnZlcnNlXG4gIFNJTUQuRmxvYXQzMng0LnN0b3JlKG91dCwgMCwgIFNJTUQuRmxvYXQzMng0Lm11bChkZXQsIG1pbm9yMCkpO1xuICBTSU1ELkZsb2F0MzJ4NC5zdG9yZShvdXQsIDQsICBTSU1ELkZsb2F0MzJ4NC5tdWwoZGV0LCBtaW5vcjEpKTtcbiAgU0lNRC5GbG9hdDMyeDQuc3RvcmUob3V0LCA4LCAgU0lNRC5GbG9hdDMyeDQubXVsKGRldCwgbWlub3IyKSk7XG4gIFNJTUQuRmxvYXQzMng0LnN0b3JlKG91dCwgMTIsIFNJTUQuRmxvYXQzMng0Lm11bChkZXQsIG1pbm9yMykpO1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIEludmVydHMgYSBtYXQ0IHVzaW5nIFNJTUQgaWYgYXZhaWxhYmxlIGFuZCBlbmFibGVkXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0NH0gYSB0aGUgc291cmNlIG1hdHJpeFxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5tYXQ0LmludmVydCA9IGdsTWF0cml4LlVTRV9TSU1EID8gbWF0NC5TSU1ELmludmVydCA6IG1hdDQuc2NhbGFyLmludmVydDtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBhZGp1Z2F0ZSBvZiBhIG1hdDQgbm90IHVzaW5nIFNJTURcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQ0fSBhIHRoZSBzb3VyY2UgbWF0cml4XG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbm1hdDQuc2NhbGFyLmFkam9pbnQgPSBmdW5jdGlvbihvdXQsIGEpIHtcbiAgICB2YXIgYTAwID0gYVswXSwgYTAxID0gYVsxXSwgYTAyID0gYVsyXSwgYTAzID0gYVszXSxcbiAgICAgICAgYTEwID0gYVs0XSwgYTExID0gYVs1XSwgYTEyID0gYVs2XSwgYTEzID0gYVs3XSxcbiAgICAgICAgYTIwID0gYVs4XSwgYTIxID0gYVs5XSwgYTIyID0gYVsxMF0sIGEyMyA9IGFbMTFdLFxuICAgICAgICBhMzAgPSBhWzEyXSwgYTMxID0gYVsxM10sIGEzMiA9IGFbMTRdLCBhMzMgPSBhWzE1XTtcblxuICAgIG91dFswXSAgPSAgKGExMSAqIChhMjIgKiBhMzMgLSBhMjMgKiBhMzIpIC0gYTIxICogKGExMiAqIGEzMyAtIGExMyAqIGEzMikgKyBhMzEgKiAoYTEyICogYTIzIC0gYTEzICogYTIyKSk7XG4gICAgb3V0WzFdICA9IC0oYTAxICogKGEyMiAqIGEzMyAtIGEyMyAqIGEzMikgLSBhMjEgKiAoYTAyICogYTMzIC0gYTAzICogYTMyKSArIGEzMSAqIChhMDIgKiBhMjMgLSBhMDMgKiBhMjIpKTtcbiAgICBvdXRbMl0gID0gIChhMDEgKiAoYTEyICogYTMzIC0gYTEzICogYTMyKSAtIGExMSAqIChhMDIgKiBhMzMgLSBhMDMgKiBhMzIpICsgYTMxICogKGEwMiAqIGExMyAtIGEwMyAqIGExMikpO1xuICAgIG91dFszXSAgPSAtKGEwMSAqIChhMTIgKiBhMjMgLSBhMTMgKiBhMjIpIC0gYTExICogKGEwMiAqIGEyMyAtIGEwMyAqIGEyMikgKyBhMjEgKiAoYTAyICogYTEzIC0gYTAzICogYTEyKSk7XG4gICAgb3V0WzRdICA9IC0oYTEwICogKGEyMiAqIGEzMyAtIGEyMyAqIGEzMikgLSBhMjAgKiAoYTEyICogYTMzIC0gYTEzICogYTMyKSArIGEzMCAqIChhMTIgKiBhMjMgLSBhMTMgKiBhMjIpKTtcbiAgICBvdXRbNV0gID0gIChhMDAgKiAoYTIyICogYTMzIC0gYTIzICogYTMyKSAtIGEyMCAqIChhMDIgKiBhMzMgLSBhMDMgKiBhMzIpICsgYTMwICogKGEwMiAqIGEyMyAtIGEwMyAqIGEyMikpO1xuICAgIG91dFs2XSAgPSAtKGEwMCAqIChhMTIgKiBhMzMgLSBhMTMgKiBhMzIpIC0gYTEwICogKGEwMiAqIGEzMyAtIGEwMyAqIGEzMikgKyBhMzAgKiAoYTAyICogYTEzIC0gYTAzICogYTEyKSk7XG4gICAgb3V0WzddICA9ICAoYTAwICogKGExMiAqIGEyMyAtIGExMyAqIGEyMikgLSBhMTAgKiAoYTAyICogYTIzIC0gYTAzICogYTIyKSArIGEyMCAqIChhMDIgKiBhMTMgLSBhMDMgKiBhMTIpKTtcbiAgICBvdXRbOF0gID0gIChhMTAgKiAoYTIxICogYTMzIC0gYTIzICogYTMxKSAtIGEyMCAqIChhMTEgKiBhMzMgLSBhMTMgKiBhMzEpICsgYTMwICogKGExMSAqIGEyMyAtIGExMyAqIGEyMSkpO1xuICAgIG91dFs5XSAgPSAtKGEwMCAqIChhMjEgKiBhMzMgLSBhMjMgKiBhMzEpIC0gYTIwICogKGEwMSAqIGEzMyAtIGEwMyAqIGEzMSkgKyBhMzAgKiAoYTAxICogYTIzIC0gYTAzICogYTIxKSk7XG4gICAgb3V0WzEwXSA9ICAoYTAwICogKGExMSAqIGEzMyAtIGExMyAqIGEzMSkgLSBhMTAgKiAoYTAxICogYTMzIC0gYTAzICogYTMxKSArIGEzMCAqIChhMDEgKiBhMTMgLSBhMDMgKiBhMTEpKTtcbiAgICBvdXRbMTFdID0gLShhMDAgKiAoYTExICogYTIzIC0gYTEzICogYTIxKSAtIGExMCAqIChhMDEgKiBhMjMgLSBhMDMgKiBhMjEpICsgYTIwICogKGEwMSAqIGExMyAtIGEwMyAqIGExMSkpO1xuICAgIG91dFsxMl0gPSAtKGExMCAqIChhMjEgKiBhMzIgLSBhMjIgKiBhMzEpIC0gYTIwICogKGExMSAqIGEzMiAtIGExMiAqIGEzMSkgKyBhMzAgKiAoYTExICogYTIyIC0gYTEyICogYTIxKSk7XG4gICAgb3V0WzEzXSA9ICAoYTAwICogKGEyMSAqIGEzMiAtIGEyMiAqIGEzMSkgLSBhMjAgKiAoYTAxICogYTMyIC0gYTAyICogYTMxKSArIGEzMCAqIChhMDEgKiBhMjIgLSBhMDIgKiBhMjEpKTtcbiAgICBvdXRbMTRdID0gLShhMDAgKiAoYTExICogYTMyIC0gYTEyICogYTMxKSAtIGExMCAqIChhMDEgKiBhMzIgLSBhMDIgKiBhMzEpICsgYTMwICogKGEwMSAqIGExMiAtIGEwMiAqIGExMSkpO1xuICAgIG91dFsxNV0gPSAgKGEwMCAqIChhMTEgKiBhMjIgLSBhMTIgKiBhMjEpIC0gYTEwICogKGEwMSAqIGEyMiAtIGEwMiAqIGEyMSkgKyBhMjAgKiAoYTAxICogYTEyIC0gYTAyICogYTExKSk7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgYWRqdWdhdGUgb2YgYSBtYXQ0IHVzaW5nIFNJTURcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQ0fSBhIHRoZSBzb3VyY2UgbWF0cml4XG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbm1hdDQuU0lNRC5hZGpvaW50ID0gZnVuY3Rpb24ob3V0LCBhKSB7XG4gIHZhciBhMCwgYTEsIGEyLCBhMztcbiAgdmFyIHJvdzAsIHJvdzEsIHJvdzIsIHJvdzM7XG4gIHZhciB0bXAxO1xuICB2YXIgbWlub3IwLCBtaW5vcjEsIG1pbm9yMiwgbWlub3IzO1xuXG4gIHZhciBhMCA9IFNJTUQuRmxvYXQzMng0LmxvYWQoYSwgMCk7XG4gIHZhciBhMSA9IFNJTUQuRmxvYXQzMng0LmxvYWQoYSwgNCk7XG4gIHZhciBhMiA9IFNJTUQuRmxvYXQzMng0LmxvYWQoYSwgOCk7XG4gIHZhciBhMyA9IFNJTUQuRmxvYXQzMng0LmxvYWQoYSwgMTIpO1xuXG4gIC8vIFRyYW5zcG9zZSB0aGUgc291cmNlIG1hdHJpeC4gIFNvcnQgb2YuICBOb3QgYSB0cnVlIHRyYW5zcG9zZSBvcGVyYXRpb25cbiAgdG1wMSA9IFNJTUQuRmxvYXQzMng0LnNodWZmbGUoYTAsIGExLCAwLCAxLCA0LCA1KTtcbiAgcm93MSA9IFNJTUQuRmxvYXQzMng0LnNodWZmbGUoYTIsIGEzLCAwLCAxLCA0LCA1KTtcbiAgcm93MCA9IFNJTUQuRmxvYXQzMng0LnNodWZmbGUodG1wMSwgcm93MSwgMCwgMiwgNCwgNik7XG4gIHJvdzEgPSBTSU1ELkZsb2F0MzJ4NC5zaHVmZmxlKHJvdzEsIHRtcDEsIDEsIDMsIDUsIDcpO1xuXG4gIHRtcDEgPSBTSU1ELkZsb2F0MzJ4NC5zaHVmZmxlKGEwLCBhMSwgMiwgMywgNiwgNyk7XG4gIHJvdzMgPSBTSU1ELkZsb2F0MzJ4NC5zaHVmZmxlKGEyLCBhMywgMiwgMywgNiwgNyk7XG4gIHJvdzIgPSBTSU1ELkZsb2F0MzJ4NC5zaHVmZmxlKHRtcDEsIHJvdzMsIDAsIDIsIDQsIDYpO1xuICByb3czID0gU0lNRC5GbG9hdDMyeDQuc2h1ZmZsZShyb3czLCB0bXAxLCAxLCAzLCA1LCA3KTtcblxuICB0bXAxICAgPSBTSU1ELkZsb2F0MzJ4NC5tdWwocm93Miwgcm93Myk7XG4gIHRtcDEgICA9IFNJTUQuRmxvYXQzMng0LnN3aXp6bGUodG1wMSwgMSwgMCwgMywgMik7XG4gIG1pbm9yMCA9IFNJTUQuRmxvYXQzMng0Lm11bChyb3cxLCB0bXAxKTtcbiAgbWlub3IxID0gU0lNRC5GbG9hdDMyeDQubXVsKHJvdzAsIHRtcDEpO1xuICB0bXAxICAgPSBTSU1ELkZsb2F0MzJ4NC5zd2l6emxlKHRtcDEsIDIsIDMsIDAsIDEpO1xuICBtaW5vcjAgPSBTSU1ELkZsb2F0MzJ4NC5zdWIoU0lNRC5GbG9hdDMyeDQubXVsKHJvdzEsIHRtcDEpLCBtaW5vcjApO1xuICBtaW5vcjEgPSBTSU1ELkZsb2F0MzJ4NC5zdWIoU0lNRC5GbG9hdDMyeDQubXVsKHJvdzAsIHRtcDEpLCBtaW5vcjEpO1xuICBtaW5vcjEgPSBTSU1ELkZsb2F0MzJ4NC5zd2l6emxlKG1pbm9yMSwgMiwgMywgMCwgMSk7XG5cbiAgdG1wMSAgID0gU0lNRC5GbG9hdDMyeDQubXVsKHJvdzEsIHJvdzIpO1xuICB0bXAxICAgPSBTSU1ELkZsb2F0MzJ4NC5zd2l6emxlKHRtcDEsIDEsIDAsIDMsIDIpO1xuICBtaW5vcjAgPSBTSU1ELkZsb2F0MzJ4NC5hZGQoU0lNRC5GbG9hdDMyeDQubXVsKHJvdzMsIHRtcDEpLCBtaW5vcjApO1xuICBtaW5vcjMgPSBTSU1ELkZsb2F0MzJ4NC5tdWwocm93MCwgdG1wMSk7XG4gIHRtcDEgICA9IFNJTUQuRmxvYXQzMng0LnN3aXp6bGUodG1wMSwgMiwgMywgMCwgMSk7XG4gIG1pbm9yMCA9IFNJTUQuRmxvYXQzMng0LnN1YihtaW5vcjAsIFNJTUQuRmxvYXQzMng0Lm11bChyb3czLCB0bXAxKSk7XG4gIG1pbm9yMyA9IFNJTUQuRmxvYXQzMng0LnN1YihTSU1ELkZsb2F0MzJ4NC5tdWwocm93MCwgdG1wMSksIG1pbm9yMyk7XG4gIG1pbm9yMyA9IFNJTUQuRmxvYXQzMng0LnN3aXp6bGUobWlub3IzLCAyLCAzLCAwLCAxKTtcblxuICB0bXAxICAgPSBTSU1ELkZsb2F0MzJ4NC5tdWwoU0lNRC5GbG9hdDMyeDQuc3dpenpsZShyb3cxLCAyLCAzLCAwLCAxKSwgcm93Myk7XG4gIHRtcDEgICA9IFNJTUQuRmxvYXQzMng0LnN3aXp6bGUodG1wMSwgMSwgMCwgMywgMik7XG4gIHJvdzIgICA9IFNJTUQuRmxvYXQzMng0LnN3aXp6bGUocm93MiwgMiwgMywgMCwgMSk7XG4gIG1pbm9yMCA9IFNJTUQuRmxvYXQzMng0LmFkZChTSU1ELkZsb2F0MzJ4NC5tdWwocm93MiwgdG1wMSksIG1pbm9yMCk7XG4gIG1pbm9yMiA9IFNJTUQuRmxvYXQzMng0Lm11bChyb3cwLCB0bXAxKTtcbiAgdG1wMSAgID0gU0lNRC5GbG9hdDMyeDQuc3dpenpsZSh0bXAxLCAyLCAzLCAwLCAxKTtcbiAgbWlub3IwID0gU0lNRC5GbG9hdDMyeDQuc3ViKG1pbm9yMCwgU0lNRC5GbG9hdDMyeDQubXVsKHJvdzIsIHRtcDEpKTtcbiAgbWlub3IyID0gU0lNRC5GbG9hdDMyeDQuc3ViKFNJTUQuRmxvYXQzMng0Lm11bChyb3cwLCB0bXAxKSwgbWlub3IyKTtcbiAgbWlub3IyID0gU0lNRC5GbG9hdDMyeDQuc3dpenpsZShtaW5vcjIsIDIsIDMsIDAsIDEpO1xuXG4gIHRtcDEgICA9IFNJTUQuRmxvYXQzMng0Lm11bChyb3cwLCByb3cxKTtcbiAgdG1wMSAgID0gU0lNRC5GbG9hdDMyeDQuc3dpenpsZSh0bXAxLCAxLCAwLCAzLCAyKTtcbiAgbWlub3IyID0gU0lNRC5GbG9hdDMyeDQuYWRkKFNJTUQuRmxvYXQzMng0Lm11bChyb3czLCB0bXAxKSwgbWlub3IyKTtcbiAgbWlub3IzID0gU0lNRC5GbG9hdDMyeDQuc3ViKFNJTUQuRmxvYXQzMng0Lm11bChyb3cyLCB0bXAxKSwgbWlub3IzKTtcbiAgdG1wMSAgID0gU0lNRC5GbG9hdDMyeDQuc3dpenpsZSh0bXAxLCAyLCAzLCAwLCAxKTtcbiAgbWlub3IyID0gU0lNRC5GbG9hdDMyeDQuc3ViKFNJTUQuRmxvYXQzMng0Lm11bChyb3czLCB0bXAxKSwgbWlub3IyKTtcbiAgbWlub3IzID0gU0lNRC5GbG9hdDMyeDQuc3ViKG1pbm9yMywgU0lNRC5GbG9hdDMyeDQubXVsKHJvdzIsIHRtcDEpKTtcblxuICB0bXAxICAgPSBTSU1ELkZsb2F0MzJ4NC5tdWwocm93MCwgcm93Myk7XG4gIHRtcDEgICA9IFNJTUQuRmxvYXQzMng0LnN3aXp6bGUodG1wMSwgMSwgMCwgMywgMik7XG4gIG1pbm9yMSA9IFNJTUQuRmxvYXQzMng0LnN1YihtaW5vcjEsIFNJTUQuRmxvYXQzMng0Lm11bChyb3cyLCB0bXAxKSk7XG4gIG1pbm9yMiA9IFNJTUQuRmxvYXQzMng0LmFkZChTSU1ELkZsb2F0MzJ4NC5tdWwocm93MSwgdG1wMSksIG1pbm9yMik7XG4gIHRtcDEgICA9IFNJTUQuRmxvYXQzMng0LnN3aXp6bGUodG1wMSwgMiwgMywgMCwgMSk7XG4gIG1pbm9yMSA9IFNJTUQuRmxvYXQzMng0LmFkZChTSU1ELkZsb2F0MzJ4NC5tdWwocm93MiwgdG1wMSksIG1pbm9yMSk7XG4gIG1pbm9yMiA9IFNJTUQuRmxvYXQzMng0LnN1YihtaW5vcjIsIFNJTUQuRmxvYXQzMng0Lm11bChyb3cxLCB0bXAxKSk7XG5cbiAgdG1wMSAgID0gU0lNRC5GbG9hdDMyeDQubXVsKHJvdzAsIHJvdzIpO1xuICB0bXAxICAgPSBTSU1ELkZsb2F0MzJ4NC5zd2l6emxlKHRtcDEsIDEsIDAsIDMsIDIpO1xuICBtaW5vcjEgPSBTSU1ELkZsb2F0MzJ4NC5hZGQoU0lNRC5GbG9hdDMyeDQubXVsKHJvdzMsIHRtcDEpLCBtaW5vcjEpO1xuICBtaW5vcjMgPSBTSU1ELkZsb2F0MzJ4NC5zdWIobWlub3IzLCBTSU1ELkZsb2F0MzJ4NC5tdWwocm93MSwgdG1wMSkpO1xuICB0bXAxICAgPSBTSU1ELkZsb2F0MzJ4NC5zd2l6emxlKHRtcDEsIDIsIDMsIDAsIDEpO1xuICBtaW5vcjEgPSBTSU1ELkZsb2F0MzJ4NC5zdWIobWlub3IxLCBTSU1ELkZsb2F0MzJ4NC5tdWwocm93MywgdG1wMSkpO1xuICBtaW5vcjMgPSBTSU1ELkZsb2F0MzJ4NC5hZGQoU0lNRC5GbG9hdDMyeDQubXVsKHJvdzEsIHRtcDEpLCBtaW5vcjMpO1xuXG4gIFNJTUQuRmxvYXQzMng0LnN0b3JlKG91dCwgMCwgIG1pbm9yMCk7XG4gIFNJTUQuRmxvYXQzMng0LnN0b3JlKG91dCwgNCwgIG1pbm9yMSk7XG4gIFNJTUQuRmxvYXQzMng0LnN0b3JlKG91dCwgOCwgIG1pbm9yMik7XG4gIFNJTUQuRmxvYXQzMng0LnN0b3JlKG91dCwgMTIsIG1pbm9yMyk7XG4gIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGFkanVnYXRlIG9mIGEgbWF0NCB1c2luZyBTSU1EIGlmIGF2YWlsYWJsZSBhbmQgZW5hYmxlZFxuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDR9IGEgdGhlIHNvdXJjZSBtYXRyaXhcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xuIG1hdDQuYWRqb2ludCA9IGdsTWF0cml4LlVTRV9TSU1EID8gbWF0NC5TSU1ELmFkam9pbnQgOiBtYXQ0LnNjYWxhci5hZGpvaW50O1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGRldGVybWluYW50IG9mIGEgbWF0NFxuICpcbiAqIEBwYXJhbSB7bWF0NH0gYSB0aGUgc291cmNlIG1hdHJpeFxuICogQHJldHVybnMge051bWJlcn0gZGV0ZXJtaW5hbnQgb2YgYVxuICovXG5tYXQ0LmRldGVybWluYW50ID0gZnVuY3Rpb24gKGEpIHtcbiAgICB2YXIgYTAwID0gYVswXSwgYTAxID0gYVsxXSwgYTAyID0gYVsyXSwgYTAzID0gYVszXSxcbiAgICAgICAgYTEwID0gYVs0XSwgYTExID0gYVs1XSwgYTEyID0gYVs2XSwgYTEzID0gYVs3XSxcbiAgICAgICAgYTIwID0gYVs4XSwgYTIxID0gYVs5XSwgYTIyID0gYVsxMF0sIGEyMyA9IGFbMTFdLFxuICAgICAgICBhMzAgPSBhWzEyXSwgYTMxID0gYVsxM10sIGEzMiA9IGFbMTRdLCBhMzMgPSBhWzE1XSxcblxuICAgICAgICBiMDAgPSBhMDAgKiBhMTEgLSBhMDEgKiBhMTAsXG4gICAgICAgIGIwMSA9IGEwMCAqIGExMiAtIGEwMiAqIGExMCxcbiAgICAgICAgYjAyID0gYTAwICogYTEzIC0gYTAzICogYTEwLFxuICAgICAgICBiMDMgPSBhMDEgKiBhMTIgLSBhMDIgKiBhMTEsXG4gICAgICAgIGIwNCA9IGEwMSAqIGExMyAtIGEwMyAqIGExMSxcbiAgICAgICAgYjA1ID0gYTAyICogYTEzIC0gYTAzICogYTEyLFxuICAgICAgICBiMDYgPSBhMjAgKiBhMzEgLSBhMjEgKiBhMzAsXG4gICAgICAgIGIwNyA9IGEyMCAqIGEzMiAtIGEyMiAqIGEzMCxcbiAgICAgICAgYjA4ID0gYTIwICogYTMzIC0gYTIzICogYTMwLFxuICAgICAgICBiMDkgPSBhMjEgKiBhMzIgLSBhMjIgKiBhMzEsXG4gICAgICAgIGIxMCA9IGEyMSAqIGEzMyAtIGEyMyAqIGEzMSxcbiAgICAgICAgYjExID0gYTIyICogYTMzIC0gYTIzICogYTMyO1xuXG4gICAgLy8gQ2FsY3VsYXRlIHRoZSBkZXRlcm1pbmFudFxuICAgIHJldHVybiBiMDAgKiBiMTEgLSBiMDEgKiBiMTAgKyBiMDIgKiBiMDkgKyBiMDMgKiBiMDggLSBiMDQgKiBiMDcgKyBiMDUgKiBiMDY7XG59O1xuXG4vKipcbiAqIE11bHRpcGxpZXMgdHdvIG1hdDQncyBleHBsaWNpdGx5IHVzaW5nIFNJTURcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQ0fSBhIHRoZSBmaXJzdCBvcGVyYW5kLCBtdXN0IGJlIGEgRmxvYXQzMkFycmF5XG4gKiBAcGFyYW0ge21hdDR9IGIgdGhlIHNlY29uZCBvcGVyYW5kLCBtdXN0IGJlIGEgRmxvYXQzMkFycmF5XG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbm1hdDQuU0lNRC5tdWx0aXBseSA9IGZ1bmN0aW9uIChvdXQsIGEsIGIpIHtcbiAgICB2YXIgYTAgPSBTSU1ELkZsb2F0MzJ4NC5sb2FkKGEsIDApO1xuICAgIHZhciBhMSA9IFNJTUQuRmxvYXQzMng0LmxvYWQoYSwgNCk7XG4gICAgdmFyIGEyID0gU0lNRC5GbG9hdDMyeDQubG9hZChhLCA4KTtcbiAgICB2YXIgYTMgPSBTSU1ELkZsb2F0MzJ4NC5sb2FkKGEsIDEyKTtcblxuICAgIHZhciBiMCA9IFNJTUQuRmxvYXQzMng0LmxvYWQoYiwgMCk7XG4gICAgdmFyIG91dDAgPSBTSU1ELkZsb2F0MzJ4NC5hZGQoXG4gICAgICAgICAgICAgICAgICAgU0lNRC5GbG9hdDMyeDQubXVsKFNJTUQuRmxvYXQzMng0LnN3aXp6bGUoYjAsIDAsIDAsIDAsIDApLCBhMCksXG4gICAgICAgICAgICAgICAgICAgU0lNRC5GbG9hdDMyeDQuYWRkKFxuICAgICAgICAgICAgICAgICAgICAgICBTSU1ELkZsb2F0MzJ4NC5tdWwoU0lNRC5GbG9hdDMyeDQuc3dpenpsZShiMCwgMSwgMSwgMSwgMSksIGExKSxcbiAgICAgICAgICAgICAgICAgICAgICAgU0lNRC5GbG9hdDMyeDQuYWRkKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgU0lNRC5GbG9hdDMyeDQubXVsKFNJTUQuRmxvYXQzMng0LnN3aXp6bGUoYjAsIDIsIDIsIDIsIDIpLCBhMiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBTSU1ELkZsb2F0MzJ4NC5tdWwoU0lNRC5GbG9hdDMyeDQuc3dpenpsZShiMCwgMywgMywgMywgMyksIGEzKSkpKTtcbiAgICBTSU1ELkZsb2F0MzJ4NC5zdG9yZShvdXQsIDAsIG91dDApO1xuXG4gICAgdmFyIGIxID0gU0lNRC5GbG9hdDMyeDQubG9hZChiLCA0KTtcbiAgICB2YXIgb3V0MSA9IFNJTUQuRmxvYXQzMng0LmFkZChcbiAgICAgICAgICAgICAgICAgICBTSU1ELkZsb2F0MzJ4NC5tdWwoU0lNRC5GbG9hdDMyeDQuc3dpenpsZShiMSwgMCwgMCwgMCwgMCksIGEwKSxcbiAgICAgICAgICAgICAgICAgICBTSU1ELkZsb2F0MzJ4NC5hZGQoXG4gICAgICAgICAgICAgICAgICAgICAgIFNJTUQuRmxvYXQzMng0Lm11bChTSU1ELkZsb2F0MzJ4NC5zd2l6emxlKGIxLCAxLCAxLCAxLCAxKSwgYTEpLFxuICAgICAgICAgICAgICAgICAgICAgICBTSU1ELkZsb2F0MzJ4NC5hZGQoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBTSU1ELkZsb2F0MzJ4NC5tdWwoU0lNRC5GbG9hdDMyeDQuc3dpenpsZShiMSwgMiwgMiwgMiwgMiksIGEyKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIFNJTUQuRmxvYXQzMng0Lm11bChTSU1ELkZsb2F0MzJ4NC5zd2l6emxlKGIxLCAzLCAzLCAzLCAzKSwgYTMpKSkpO1xuICAgIFNJTUQuRmxvYXQzMng0LnN0b3JlKG91dCwgNCwgb3V0MSk7XG5cbiAgICB2YXIgYjIgPSBTSU1ELkZsb2F0MzJ4NC5sb2FkKGIsIDgpO1xuICAgIHZhciBvdXQyID0gU0lNRC5GbG9hdDMyeDQuYWRkKFxuICAgICAgICAgICAgICAgICAgIFNJTUQuRmxvYXQzMng0Lm11bChTSU1ELkZsb2F0MzJ4NC5zd2l6emxlKGIyLCAwLCAwLCAwLCAwKSwgYTApLFxuICAgICAgICAgICAgICAgICAgIFNJTUQuRmxvYXQzMng0LmFkZChcbiAgICAgICAgICAgICAgICAgICAgICAgU0lNRC5GbG9hdDMyeDQubXVsKFNJTUQuRmxvYXQzMng0LnN3aXp6bGUoYjIsIDEsIDEsIDEsIDEpLCBhMSksXG4gICAgICAgICAgICAgICAgICAgICAgIFNJTUQuRmxvYXQzMng0LmFkZChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBTSU1ELkZsb2F0MzJ4NC5tdWwoU0lNRC5GbG9hdDMyeDQuc3dpenpsZShiMiwgMiwgMiwgMiwgMiksIGEyKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBTSU1ELkZsb2F0MzJ4NC5tdWwoU0lNRC5GbG9hdDMyeDQuc3dpenpsZShiMiwgMywgMywgMywgMyksIGEzKSkpKTtcbiAgICBTSU1ELkZsb2F0MzJ4NC5zdG9yZShvdXQsIDgsIG91dDIpO1xuXG4gICAgdmFyIGIzID0gU0lNRC5GbG9hdDMyeDQubG9hZChiLCAxMik7XG4gICAgdmFyIG91dDMgPSBTSU1ELkZsb2F0MzJ4NC5hZGQoXG4gICAgICAgICAgICAgICAgICAgU0lNRC5GbG9hdDMyeDQubXVsKFNJTUQuRmxvYXQzMng0LnN3aXp6bGUoYjMsIDAsIDAsIDAsIDApLCBhMCksXG4gICAgICAgICAgICAgICAgICAgU0lNRC5GbG9hdDMyeDQuYWRkKFxuICAgICAgICAgICAgICAgICAgICAgICAgU0lNRC5GbG9hdDMyeDQubXVsKFNJTUQuRmxvYXQzMng0LnN3aXp6bGUoYjMsIDEsIDEsIDEsIDEpLCBhMSksXG4gICAgICAgICAgICAgICAgICAgICAgICBTSU1ELkZsb2F0MzJ4NC5hZGQoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgU0lNRC5GbG9hdDMyeDQubXVsKFNJTUQuRmxvYXQzMng0LnN3aXp6bGUoYjMsIDIsIDIsIDIsIDIpLCBhMiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgU0lNRC5GbG9hdDMyeDQubXVsKFNJTUQuRmxvYXQzMng0LnN3aXp6bGUoYjMsIDMsIDMsIDMsIDMpLCBhMykpKSk7XG4gICAgU0lNRC5GbG9hdDMyeDQuc3RvcmUob3V0LCAxMiwgb3V0Myk7XG5cbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBNdWx0aXBsaWVzIHR3byBtYXQ0J3MgZXhwbGljaXRseSBub3QgdXNpbmcgU0lNRFxuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7bWF0NH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xubWF0NC5zY2FsYXIubXVsdGlwbHkgPSBmdW5jdGlvbiAob3V0LCBhLCBiKSB7XG4gICAgdmFyIGEwMCA9IGFbMF0sIGEwMSA9IGFbMV0sIGEwMiA9IGFbMl0sIGEwMyA9IGFbM10sXG4gICAgICAgIGExMCA9IGFbNF0sIGExMSA9IGFbNV0sIGExMiA9IGFbNl0sIGExMyA9IGFbN10sXG4gICAgICAgIGEyMCA9IGFbOF0sIGEyMSA9IGFbOV0sIGEyMiA9IGFbMTBdLCBhMjMgPSBhWzExXSxcbiAgICAgICAgYTMwID0gYVsxMl0sIGEzMSA9IGFbMTNdLCBhMzIgPSBhWzE0XSwgYTMzID0gYVsxNV07XG5cbiAgICAvLyBDYWNoZSBvbmx5IHRoZSBjdXJyZW50IGxpbmUgb2YgdGhlIHNlY29uZCBtYXRyaXhcbiAgICB2YXIgYjAgID0gYlswXSwgYjEgPSBiWzFdLCBiMiA9IGJbMl0sIGIzID0gYlszXTtcbiAgICBvdXRbMF0gPSBiMCphMDAgKyBiMSphMTAgKyBiMiphMjAgKyBiMyphMzA7XG4gICAgb3V0WzFdID0gYjAqYTAxICsgYjEqYTExICsgYjIqYTIxICsgYjMqYTMxO1xuICAgIG91dFsyXSA9IGIwKmEwMiArIGIxKmExMiArIGIyKmEyMiArIGIzKmEzMjtcbiAgICBvdXRbM10gPSBiMCphMDMgKyBiMSphMTMgKyBiMiphMjMgKyBiMyphMzM7XG5cbiAgICBiMCA9IGJbNF07IGIxID0gYls1XTsgYjIgPSBiWzZdOyBiMyA9IGJbN107XG4gICAgb3V0WzRdID0gYjAqYTAwICsgYjEqYTEwICsgYjIqYTIwICsgYjMqYTMwO1xuICAgIG91dFs1XSA9IGIwKmEwMSArIGIxKmExMSArIGIyKmEyMSArIGIzKmEzMTtcbiAgICBvdXRbNl0gPSBiMCphMDIgKyBiMSphMTIgKyBiMiphMjIgKyBiMyphMzI7XG4gICAgb3V0WzddID0gYjAqYTAzICsgYjEqYTEzICsgYjIqYTIzICsgYjMqYTMzO1xuXG4gICAgYjAgPSBiWzhdOyBiMSA9IGJbOV07IGIyID0gYlsxMF07IGIzID0gYlsxMV07XG4gICAgb3V0WzhdID0gYjAqYTAwICsgYjEqYTEwICsgYjIqYTIwICsgYjMqYTMwO1xuICAgIG91dFs5XSA9IGIwKmEwMSArIGIxKmExMSArIGIyKmEyMSArIGIzKmEzMTtcbiAgICBvdXRbMTBdID0gYjAqYTAyICsgYjEqYTEyICsgYjIqYTIyICsgYjMqYTMyO1xuICAgIG91dFsxMV0gPSBiMCphMDMgKyBiMSphMTMgKyBiMiphMjMgKyBiMyphMzM7XG5cbiAgICBiMCA9IGJbMTJdOyBiMSA9IGJbMTNdOyBiMiA9IGJbMTRdOyBiMyA9IGJbMTVdO1xuICAgIG91dFsxMl0gPSBiMCphMDAgKyBiMSphMTAgKyBiMiphMjAgKyBiMyphMzA7XG4gICAgb3V0WzEzXSA9IGIwKmEwMSArIGIxKmExMSArIGIyKmEyMSArIGIzKmEzMTtcbiAgICBvdXRbMTRdID0gYjAqYTAyICsgYjEqYTEyICsgYjIqYTIyICsgYjMqYTMyO1xuICAgIG91dFsxNV0gPSBiMCphMDMgKyBiMSphMTMgKyBiMiphMjMgKyBiMyphMzM7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogTXVsdGlwbGllcyB0d28gbWF0NCdzIHVzaW5nIFNJTUQgaWYgYXZhaWxhYmxlIGFuZCBlbmFibGVkXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0NH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHttYXQ0fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5tYXQ0Lm11bHRpcGx5ID0gZ2xNYXRyaXguVVNFX1NJTUQgPyBtYXQ0LlNJTUQubXVsdGlwbHkgOiBtYXQ0LnNjYWxhci5tdWx0aXBseTtcblxuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIG1hdDQubXVsdGlwbHl9XG4gKiBAZnVuY3Rpb25cbiAqL1xubWF0NC5tdWwgPSBtYXQ0Lm11bHRpcGx5O1xuXG4vKipcbiAqIFRyYW5zbGF0ZSBhIG1hdDQgYnkgdGhlIGdpdmVuIHZlY3RvciBub3QgdXNpbmcgU0lNRFxuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDR9IGEgdGhlIG1hdHJpeCB0byB0cmFuc2xhdGVcbiAqIEBwYXJhbSB7dmVjM30gdiB2ZWN0b3IgdG8gdHJhbnNsYXRlIGJ5XG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbm1hdDQuc2NhbGFyLnRyYW5zbGF0ZSA9IGZ1bmN0aW9uIChvdXQsIGEsIHYpIHtcbiAgICB2YXIgeCA9IHZbMF0sIHkgPSB2WzFdLCB6ID0gdlsyXSxcbiAgICAgICAgYTAwLCBhMDEsIGEwMiwgYTAzLFxuICAgICAgICBhMTAsIGExMSwgYTEyLCBhMTMsXG4gICAgICAgIGEyMCwgYTIxLCBhMjIsIGEyMztcblxuICAgIGlmIChhID09PSBvdXQpIHtcbiAgICAgICAgb3V0WzEyXSA9IGFbMF0gKiB4ICsgYVs0XSAqIHkgKyBhWzhdICogeiArIGFbMTJdO1xuICAgICAgICBvdXRbMTNdID0gYVsxXSAqIHggKyBhWzVdICogeSArIGFbOV0gKiB6ICsgYVsxM107XG4gICAgICAgIG91dFsxNF0gPSBhWzJdICogeCArIGFbNl0gKiB5ICsgYVsxMF0gKiB6ICsgYVsxNF07XG4gICAgICAgIG91dFsxNV0gPSBhWzNdICogeCArIGFbN10gKiB5ICsgYVsxMV0gKiB6ICsgYVsxNV07XG4gICAgfSBlbHNlIHtcbiAgICAgICAgYTAwID0gYVswXTsgYTAxID0gYVsxXTsgYTAyID0gYVsyXTsgYTAzID0gYVszXTtcbiAgICAgICAgYTEwID0gYVs0XTsgYTExID0gYVs1XTsgYTEyID0gYVs2XTsgYTEzID0gYVs3XTtcbiAgICAgICAgYTIwID0gYVs4XTsgYTIxID0gYVs5XTsgYTIyID0gYVsxMF07IGEyMyA9IGFbMTFdO1xuXG4gICAgICAgIG91dFswXSA9IGEwMDsgb3V0WzFdID0gYTAxOyBvdXRbMl0gPSBhMDI7IG91dFszXSA9IGEwMztcbiAgICAgICAgb3V0WzRdID0gYTEwOyBvdXRbNV0gPSBhMTE7IG91dFs2XSA9IGExMjsgb3V0WzddID0gYTEzO1xuICAgICAgICBvdXRbOF0gPSBhMjA7IG91dFs5XSA9IGEyMTsgb3V0WzEwXSA9IGEyMjsgb3V0WzExXSA9IGEyMztcblxuICAgICAgICBvdXRbMTJdID0gYTAwICogeCArIGExMCAqIHkgKyBhMjAgKiB6ICsgYVsxMl07XG4gICAgICAgIG91dFsxM10gPSBhMDEgKiB4ICsgYTExICogeSArIGEyMSAqIHogKyBhWzEzXTtcbiAgICAgICAgb3V0WzE0XSA9IGEwMiAqIHggKyBhMTIgKiB5ICsgYTIyICogeiArIGFbMTRdO1xuICAgICAgICBvdXRbMTVdID0gYTAzICogeCArIGExMyAqIHkgKyBhMjMgKiB6ICsgYVsxNV07XG4gICAgfVxuXG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogVHJhbnNsYXRlcyBhIG1hdDQgYnkgdGhlIGdpdmVuIHZlY3RvciB1c2luZyBTSU1EXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0NH0gYSB0aGUgbWF0cml4IHRvIHRyYW5zbGF0ZVxuICogQHBhcmFtIHt2ZWMzfSB2IHZlY3RvciB0byB0cmFuc2xhdGUgYnlcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xubWF0NC5TSU1ELnRyYW5zbGF0ZSA9IGZ1bmN0aW9uIChvdXQsIGEsIHYpIHtcbiAgICB2YXIgYTAgPSBTSU1ELkZsb2F0MzJ4NC5sb2FkKGEsIDApLFxuICAgICAgICBhMSA9IFNJTUQuRmxvYXQzMng0LmxvYWQoYSwgNCksXG4gICAgICAgIGEyID0gU0lNRC5GbG9hdDMyeDQubG9hZChhLCA4KSxcbiAgICAgICAgYTMgPSBTSU1ELkZsb2F0MzJ4NC5sb2FkKGEsIDEyKSxcbiAgICAgICAgdmVjID0gU0lNRC5GbG9hdDMyeDQodlswXSwgdlsxXSwgdlsyXSAsIDApO1xuXG4gICAgaWYgKGEgIT09IG91dCkge1xuICAgICAgICBvdXRbMF0gPSBhWzBdOyBvdXRbMV0gPSBhWzFdOyBvdXRbMl0gPSBhWzJdOyBvdXRbM10gPSBhWzNdO1xuICAgICAgICBvdXRbNF0gPSBhWzRdOyBvdXRbNV0gPSBhWzVdOyBvdXRbNl0gPSBhWzZdOyBvdXRbN10gPSBhWzddO1xuICAgICAgICBvdXRbOF0gPSBhWzhdOyBvdXRbOV0gPSBhWzldOyBvdXRbMTBdID0gYVsxMF07IG91dFsxMV0gPSBhWzExXTtcbiAgICB9XG5cbiAgICBhMCA9IFNJTUQuRmxvYXQzMng0Lm11bChhMCwgU0lNRC5GbG9hdDMyeDQuc3dpenpsZSh2ZWMsIDAsIDAsIDAsIDApKTtcbiAgICBhMSA9IFNJTUQuRmxvYXQzMng0Lm11bChhMSwgU0lNRC5GbG9hdDMyeDQuc3dpenpsZSh2ZWMsIDEsIDEsIDEsIDEpKTtcbiAgICBhMiA9IFNJTUQuRmxvYXQzMng0Lm11bChhMiwgU0lNRC5GbG9hdDMyeDQuc3dpenpsZSh2ZWMsIDIsIDIsIDIsIDIpKTtcblxuICAgIHZhciB0MCA9IFNJTUQuRmxvYXQzMng0LmFkZChhMCwgU0lNRC5GbG9hdDMyeDQuYWRkKGExLCBTSU1ELkZsb2F0MzJ4NC5hZGQoYTIsIGEzKSkpO1xuICAgIFNJTUQuRmxvYXQzMng0LnN0b3JlKG91dCwgMTIsIHQwKTtcblxuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFRyYW5zbGF0ZXMgYSBtYXQ0IGJ5IHRoZSBnaXZlbiB2ZWN0b3IgdXNpbmcgU0lNRCBpZiBhdmFpbGFibGUgYW5kIGVuYWJsZWRcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQ0fSBhIHRoZSBtYXRyaXggdG8gdHJhbnNsYXRlXG4gKiBAcGFyYW0ge3ZlYzN9IHYgdmVjdG9yIHRvIHRyYW5zbGF0ZSBieVxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5tYXQ0LnRyYW5zbGF0ZSA9IGdsTWF0cml4LlVTRV9TSU1EID8gbWF0NC5TSU1ELnRyYW5zbGF0ZSA6IG1hdDQuc2NhbGFyLnRyYW5zbGF0ZTtcblxuLyoqXG4gKiBTY2FsZXMgdGhlIG1hdDQgYnkgdGhlIGRpbWVuc2lvbnMgaW4gdGhlIGdpdmVuIHZlYzMgbm90IHVzaW5nIHZlY3Rvcml6YXRpb25cbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQ0fSBhIHRoZSBtYXRyaXggdG8gc2NhbGVcbiAqIEBwYXJhbSB7dmVjM30gdiB0aGUgdmVjMyB0byBzY2FsZSB0aGUgbWF0cml4IGJ5XG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKiovXG5tYXQ0LnNjYWxhci5zY2FsZSA9IGZ1bmN0aW9uKG91dCwgYSwgdikge1xuICAgIHZhciB4ID0gdlswXSwgeSA9IHZbMV0sIHogPSB2WzJdO1xuXG4gICAgb3V0WzBdID0gYVswXSAqIHg7XG4gICAgb3V0WzFdID0gYVsxXSAqIHg7XG4gICAgb3V0WzJdID0gYVsyXSAqIHg7XG4gICAgb3V0WzNdID0gYVszXSAqIHg7XG4gICAgb3V0WzRdID0gYVs0XSAqIHk7XG4gICAgb3V0WzVdID0gYVs1XSAqIHk7XG4gICAgb3V0WzZdID0gYVs2XSAqIHk7XG4gICAgb3V0WzddID0gYVs3XSAqIHk7XG4gICAgb3V0WzhdID0gYVs4XSAqIHo7XG4gICAgb3V0WzldID0gYVs5XSAqIHo7XG4gICAgb3V0WzEwXSA9IGFbMTBdICogejtcbiAgICBvdXRbMTFdID0gYVsxMV0gKiB6O1xuICAgIG91dFsxMl0gPSBhWzEyXTtcbiAgICBvdXRbMTNdID0gYVsxM107XG4gICAgb3V0WzE0XSA9IGFbMTRdO1xuICAgIG91dFsxNV0gPSBhWzE1XTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBTY2FsZXMgdGhlIG1hdDQgYnkgdGhlIGRpbWVuc2lvbnMgaW4gdGhlIGdpdmVuIHZlYzMgdXNpbmcgdmVjdG9yaXphdGlvblxuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDR9IGEgdGhlIG1hdHJpeCB0byBzY2FsZVxuICogQHBhcmFtIHt2ZWMzfSB2IHRoZSB2ZWMzIHRvIHNjYWxlIHRoZSBtYXRyaXggYnlcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqKi9cbm1hdDQuU0lNRC5zY2FsZSA9IGZ1bmN0aW9uKG91dCwgYSwgdikge1xuICAgIHZhciBhMCwgYTEsIGEyO1xuICAgIHZhciB2ZWMgPSBTSU1ELkZsb2F0MzJ4NCh2WzBdLCB2WzFdLCB2WzJdLCAwKTtcblxuICAgIGEwID0gU0lNRC5GbG9hdDMyeDQubG9hZChhLCAwKTtcbiAgICBTSU1ELkZsb2F0MzJ4NC5zdG9yZShcbiAgICAgICAgb3V0LCAwLCBTSU1ELkZsb2F0MzJ4NC5tdWwoYTAsIFNJTUQuRmxvYXQzMng0LnN3aXp6bGUodmVjLCAwLCAwLCAwLCAwKSkpO1xuXG4gICAgYTEgPSBTSU1ELkZsb2F0MzJ4NC5sb2FkKGEsIDQpO1xuICAgIFNJTUQuRmxvYXQzMng0LnN0b3JlKFxuICAgICAgICBvdXQsIDQsIFNJTUQuRmxvYXQzMng0Lm11bChhMSwgU0lNRC5GbG9hdDMyeDQuc3dpenpsZSh2ZWMsIDEsIDEsIDEsIDEpKSk7XG5cbiAgICBhMiA9IFNJTUQuRmxvYXQzMng0LmxvYWQoYSwgOCk7XG4gICAgU0lNRC5GbG9hdDMyeDQuc3RvcmUoXG4gICAgICAgIG91dCwgOCwgU0lNRC5GbG9hdDMyeDQubXVsKGEyLCBTSU1ELkZsb2F0MzJ4NC5zd2l6emxlKHZlYywgMiwgMiwgMiwgMikpKTtcblxuICAgIG91dFsxMl0gPSBhWzEyXTtcbiAgICBvdXRbMTNdID0gYVsxM107XG4gICAgb3V0WzE0XSA9IGFbMTRdO1xuICAgIG91dFsxNV0gPSBhWzE1XTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBTY2FsZXMgdGhlIG1hdDQgYnkgdGhlIGRpbWVuc2lvbnMgaW4gdGhlIGdpdmVuIHZlYzMgdXNpbmcgU0lNRCBpZiBhdmFpbGFibGUgYW5kIGVuYWJsZWRcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQ0fSBhIHRoZSBtYXRyaXggdG8gc2NhbGVcbiAqIEBwYXJhbSB7dmVjM30gdiB0aGUgdmVjMyB0byBzY2FsZSB0aGUgbWF0cml4IGJ5XG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbm1hdDQuc2NhbGUgPSBnbE1hdHJpeC5VU0VfU0lNRCA/IG1hdDQuU0lNRC5zY2FsZSA6IG1hdDQuc2NhbGFyLnNjYWxlO1xuXG4vKipcbiAqIFJvdGF0ZXMgYSBtYXQ0IGJ5IHRoZSBnaXZlbiBhbmdsZSBhcm91bmQgdGhlIGdpdmVuIGF4aXNcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQ0fSBhIHRoZSBtYXRyaXggdG8gcm90YXRlXG4gKiBAcGFyYW0ge051bWJlcn0gcmFkIHRoZSBhbmdsZSB0byByb3RhdGUgdGhlIG1hdHJpeCBieVxuICogQHBhcmFtIHt2ZWMzfSBheGlzIHRoZSBheGlzIHRvIHJvdGF0ZSBhcm91bmRcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xubWF0NC5yb3RhdGUgPSBmdW5jdGlvbiAob3V0LCBhLCByYWQsIGF4aXMpIHtcbiAgICB2YXIgeCA9IGF4aXNbMF0sIHkgPSBheGlzWzFdLCB6ID0gYXhpc1syXSxcbiAgICAgICAgbGVuID0gTWF0aC5zcXJ0KHggKiB4ICsgeSAqIHkgKyB6ICogeiksXG4gICAgICAgIHMsIGMsIHQsXG4gICAgICAgIGEwMCwgYTAxLCBhMDIsIGEwMyxcbiAgICAgICAgYTEwLCBhMTEsIGExMiwgYTEzLFxuICAgICAgICBhMjAsIGEyMSwgYTIyLCBhMjMsXG4gICAgICAgIGIwMCwgYjAxLCBiMDIsXG4gICAgICAgIGIxMCwgYjExLCBiMTIsXG4gICAgICAgIGIyMCwgYjIxLCBiMjI7XG5cbiAgICBpZiAoTWF0aC5hYnMobGVuKSA8IGdsTWF0cml4LkVQU0lMT04pIHsgcmV0dXJuIG51bGw7IH1cblxuICAgIGxlbiA9IDEgLyBsZW47XG4gICAgeCAqPSBsZW47XG4gICAgeSAqPSBsZW47XG4gICAgeiAqPSBsZW47XG5cbiAgICBzID0gTWF0aC5zaW4ocmFkKTtcbiAgICBjID0gTWF0aC5jb3MocmFkKTtcbiAgICB0ID0gMSAtIGM7XG5cbiAgICBhMDAgPSBhWzBdOyBhMDEgPSBhWzFdOyBhMDIgPSBhWzJdOyBhMDMgPSBhWzNdO1xuICAgIGExMCA9IGFbNF07IGExMSA9IGFbNV07IGExMiA9IGFbNl07IGExMyA9IGFbN107XG4gICAgYTIwID0gYVs4XTsgYTIxID0gYVs5XTsgYTIyID0gYVsxMF07IGEyMyA9IGFbMTFdO1xuXG4gICAgLy8gQ29uc3RydWN0IHRoZSBlbGVtZW50cyBvZiB0aGUgcm90YXRpb24gbWF0cml4XG4gICAgYjAwID0geCAqIHggKiB0ICsgYzsgYjAxID0geSAqIHggKiB0ICsgeiAqIHM7IGIwMiA9IHogKiB4ICogdCAtIHkgKiBzO1xuICAgIGIxMCA9IHggKiB5ICogdCAtIHogKiBzOyBiMTEgPSB5ICogeSAqIHQgKyBjOyBiMTIgPSB6ICogeSAqIHQgKyB4ICogcztcbiAgICBiMjAgPSB4ICogeiAqIHQgKyB5ICogczsgYjIxID0geSAqIHogKiB0IC0geCAqIHM7IGIyMiA9IHogKiB6ICogdCArIGM7XG5cbiAgICAvLyBQZXJmb3JtIHJvdGF0aW9uLXNwZWNpZmljIG1hdHJpeCBtdWx0aXBsaWNhdGlvblxuICAgIG91dFswXSA9IGEwMCAqIGIwMCArIGExMCAqIGIwMSArIGEyMCAqIGIwMjtcbiAgICBvdXRbMV0gPSBhMDEgKiBiMDAgKyBhMTEgKiBiMDEgKyBhMjEgKiBiMDI7XG4gICAgb3V0WzJdID0gYTAyICogYjAwICsgYTEyICogYjAxICsgYTIyICogYjAyO1xuICAgIG91dFszXSA9IGEwMyAqIGIwMCArIGExMyAqIGIwMSArIGEyMyAqIGIwMjtcbiAgICBvdXRbNF0gPSBhMDAgKiBiMTAgKyBhMTAgKiBiMTEgKyBhMjAgKiBiMTI7XG4gICAgb3V0WzVdID0gYTAxICogYjEwICsgYTExICogYjExICsgYTIxICogYjEyO1xuICAgIG91dFs2XSA9IGEwMiAqIGIxMCArIGExMiAqIGIxMSArIGEyMiAqIGIxMjtcbiAgICBvdXRbN10gPSBhMDMgKiBiMTAgKyBhMTMgKiBiMTEgKyBhMjMgKiBiMTI7XG4gICAgb3V0WzhdID0gYTAwICogYjIwICsgYTEwICogYjIxICsgYTIwICogYjIyO1xuICAgIG91dFs5XSA9IGEwMSAqIGIyMCArIGExMSAqIGIyMSArIGEyMSAqIGIyMjtcbiAgICBvdXRbMTBdID0gYTAyICogYjIwICsgYTEyICogYjIxICsgYTIyICogYjIyO1xuICAgIG91dFsxMV0gPSBhMDMgKiBiMjAgKyBhMTMgKiBiMjEgKyBhMjMgKiBiMjI7XG5cbiAgICBpZiAoYSAhPT0gb3V0KSB7IC8vIElmIHRoZSBzb3VyY2UgYW5kIGRlc3RpbmF0aW9uIGRpZmZlciwgY29weSB0aGUgdW5jaGFuZ2VkIGxhc3Qgcm93XG4gICAgICAgIG91dFsxMl0gPSBhWzEyXTtcbiAgICAgICAgb3V0WzEzXSA9IGFbMTNdO1xuICAgICAgICBvdXRbMTRdID0gYVsxNF07XG4gICAgICAgIG91dFsxNV0gPSBhWzE1XTtcbiAgICB9XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogUm90YXRlcyBhIG1hdHJpeCBieSB0aGUgZ2l2ZW4gYW5nbGUgYXJvdW5kIHRoZSBYIGF4aXMgbm90IHVzaW5nIFNJTURcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQ0fSBhIHRoZSBtYXRyaXggdG8gcm90YXRlXG4gKiBAcGFyYW0ge051bWJlcn0gcmFkIHRoZSBhbmdsZSB0byByb3RhdGUgdGhlIG1hdHJpeCBieVxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5tYXQ0LnNjYWxhci5yb3RhdGVYID0gZnVuY3Rpb24gKG91dCwgYSwgcmFkKSB7XG4gICAgdmFyIHMgPSBNYXRoLnNpbihyYWQpLFxuICAgICAgICBjID0gTWF0aC5jb3MocmFkKSxcbiAgICAgICAgYTEwID0gYVs0XSxcbiAgICAgICAgYTExID0gYVs1XSxcbiAgICAgICAgYTEyID0gYVs2XSxcbiAgICAgICAgYTEzID0gYVs3XSxcbiAgICAgICAgYTIwID0gYVs4XSxcbiAgICAgICAgYTIxID0gYVs5XSxcbiAgICAgICAgYTIyID0gYVsxMF0sXG4gICAgICAgIGEyMyA9IGFbMTFdO1xuXG4gICAgaWYgKGEgIT09IG91dCkgeyAvLyBJZiB0aGUgc291cmNlIGFuZCBkZXN0aW5hdGlvbiBkaWZmZXIsIGNvcHkgdGhlIHVuY2hhbmdlZCByb3dzXG4gICAgICAgIG91dFswXSAgPSBhWzBdO1xuICAgICAgICBvdXRbMV0gID0gYVsxXTtcbiAgICAgICAgb3V0WzJdICA9IGFbMl07XG4gICAgICAgIG91dFszXSAgPSBhWzNdO1xuICAgICAgICBvdXRbMTJdID0gYVsxMl07XG4gICAgICAgIG91dFsxM10gPSBhWzEzXTtcbiAgICAgICAgb3V0WzE0XSA9IGFbMTRdO1xuICAgICAgICBvdXRbMTVdID0gYVsxNV07XG4gICAgfVxuXG4gICAgLy8gUGVyZm9ybSBheGlzLXNwZWNpZmljIG1hdHJpeCBtdWx0aXBsaWNhdGlvblxuICAgIG91dFs0XSA9IGExMCAqIGMgKyBhMjAgKiBzO1xuICAgIG91dFs1XSA9IGExMSAqIGMgKyBhMjEgKiBzO1xuICAgIG91dFs2XSA9IGExMiAqIGMgKyBhMjIgKiBzO1xuICAgIG91dFs3XSA9IGExMyAqIGMgKyBhMjMgKiBzO1xuICAgIG91dFs4XSA9IGEyMCAqIGMgLSBhMTAgKiBzO1xuICAgIG91dFs5XSA9IGEyMSAqIGMgLSBhMTEgKiBzO1xuICAgIG91dFsxMF0gPSBhMjIgKiBjIC0gYTEyICogcztcbiAgICBvdXRbMTFdID0gYTIzICogYyAtIGExMyAqIHM7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogUm90YXRlcyBhIG1hdHJpeCBieSB0aGUgZ2l2ZW4gYW5nbGUgYXJvdW5kIHRoZSBYIGF4aXMgdXNpbmcgU0lNRFxuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDR9IGEgdGhlIG1hdHJpeCB0byByb3RhdGVcbiAqIEBwYXJhbSB7TnVtYmVyfSByYWQgdGhlIGFuZ2xlIHRvIHJvdGF0ZSB0aGUgbWF0cml4IGJ5XG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbm1hdDQuU0lNRC5yb3RhdGVYID0gZnVuY3Rpb24gKG91dCwgYSwgcmFkKSB7XG4gICAgdmFyIHMgPSBTSU1ELkZsb2F0MzJ4NC5zcGxhdChNYXRoLnNpbihyYWQpKSxcbiAgICAgICAgYyA9IFNJTUQuRmxvYXQzMng0LnNwbGF0KE1hdGguY29zKHJhZCkpO1xuXG4gICAgaWYgKGEgIT09IG91dCkgeyAvLyBJZiB0aGUgc291cmNlIGFuZCBkZXN0aW5hdGlvbiBkaWZmZXIsIGNvcHkgdGhlIHVuY2hhbmdlZCByb3dzXG4gICAgICBvdXRbMF0gID0gYVswXTtcbiAgICAgIG91dFsxXSAgPSBhWzFdO1xuICAgICAgb3V0WzJdICA9IGFbMl07XG4gICAgICBvdXRbM10gID0gYVszXTtcbiAgICAgIG91dFsxMl0gPSBhWzEyXTtcbiAgICAgIG91dFsxM10gPSBhWzEzXTtcbiAgICAgIG91dFsxNF0gPSBhWzE0XTtcbiAgICAgIG91dFsxNV0gPSBhWzE1XTtcbiAgICB9XG5cbiAgICAvLyBQZXJmb3JtIGF4aXMtc3BlY2lmaWMgbWF0cml4IG11bHRpcGxpY2F0aW9uXG4gICAgdmFyIGFfMSA9IFNJTUQuRmxvYXQzMng0LmxvYWQoYSwgNCk7XG4gICAgdmFyIGFfMiA9IFNJTUQuRmxvYXQzMng0LmxvYWQoYSwgOCk7XG4gICAgU0lNRC5GbG9hdDMyeDQuc3RvcmUob3V0LCA0LFxuICAgICAgICAgICAgICAgICAgICAgICAgIFNJTUQuRmxvYXQzMng0LmFkZChTSU1ELkZsb2F0MzJ4NC5tdWwoYV8xLCBjKSwgU0lNRC5GbG9hdDMyeDQubXVsKGFfMiwgcykpKTtcbiAgICBTSU1ELkZsb2F0MzJ4NC5zdG9yZShvdXQsIDgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgU0lNRC5GbG9hdDMyeDQuc3ViKFNJTUQuRmxvYXQzMng0Lm11bChhXzIsIGMpLCBTSU1ELkZsb2F0MzJ4NC5tdWwoYV8xLCBzKSkpO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFJvdGF0ZXMgYSBtYXRyaXggYnkgdGhlIGdpdmVuIGFuZ2xlIGFyb3VuZCB0aGUgWCBheGlzIHVzaW5nIFNJTUQgaWYgYXZhaWxhYmUgYW5kIGVuYWJsZWRcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQ0fSBhIHRoZSBtYXRyaXggdG8gcm90YXRlXG4gKiBAcGFyYW0ge051bWJlcn0gcmFkIHRoZSBhbmdsZSB0byByb3RhdGUgdGhlIG1hdHJpeCBieVxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5tYXQ0LnJvdGF0ZVggPSBnbE1hdHJpeC5VU0VfU0lNRCA/IG1hdDQuU0lNRC5yb3RhdGVYIDogbWF0NC5zY2FsYXIucm90YXRlWDtcblxuLyoqXG4gKiBSb3RhdGVzIGEgbWF0cml4IGJ5IHRoZSBnaXZlbiBhbmdsZSBhcm91bmQgdGhlIFkgYXhpcyBub3QgdXNpbmcgU0lNRFxuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDR9IGEgdGhlIG1hdHJpeCB0byByb3RhdGVcbiAqIEBwYXJhbSB7TnVtYmVyfSByYWQgdGhlIGFuZ2xlIHRvIHJvdGF0ZSB0aGUgbWF0cml4IGJ5XG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbm1hdDQuc2NhbGFyLnJvdGF0ZVkgPSBmdW5jdGlvbiAob3V0LCBhLCByYWQpIHtcbiAgICB2YXIgcyA9IE1hdGguc2luKHJhZCksXG4gICAgICAgIGMgPSBNYXRoLmNvcyhyYWQpLFxuICAgICAgICBhMDAgPSBhWzBdLFxuICAgICAgICBhMDEgPSBhWzFdLFxuICAgICAgICBhMDIgPSBhWzJdLFxuICAgICAgICBhMDMgPSBhWzNdLFxuICAgICAgICBhMjAgPSBhWzhdLFxuICAgICAgICBhMjEgPSBhWzldLFxuICAgICAgICBhMjIgPSBhWzEwXSxcbiAgICAgICAgYTIzID0gYVsxMV07XG5cbiAgICBpZiAoYSAhPT0gb3V0KSB7IC8vIElmIHRoZSBzb3VyY2UgYW5kIGRlc3RpbmF0aW9uIGRpZmZlciwgY29weSB0aGUgdW5jaGFuZ2VkIHJvd3NcbiAgICAgICAgb3V0WzRdICA9IGFbNF07XG4gICAgICAgIG91dFs1XSAgPSBhWzVdO1xuICAgICAgICBvdXRbNl0gID0gYVs2XTtcbiAgICAgICAgb3V0WzddICA9IGFbN107XG4gICAgICAgIG91dFsxMl0gPSBhWzEyXTtcbiAgICAgICAgb3V0WzEzXSA9IGFbMTNdO1xuICAgICAgICBvdXRbMTRdID0gYVsxNF07XG4gICAgICAgIG91dFsxNV0gPSBhWzE1XTtcbiAgICB9XG5cbiAgICAvLyBQZXJmb3JtIGF4aXMtc3BlY2lmaWMgbWF0cml4IG11bHRpcGxpY2F0aW9uXG4gICAgb3V0WzBdID0gYTAwICogYyAtIGEyMCAqIHM7XG4gICAgb3V0WzFdID0gYTAxICogYyAtIGEyMSAqIHM7XG4gICAgb3V0WzJdID0gYTAyICogYyAtIGEyMiAqIHM7XG4gICAgb3V0WzNdID0gYTAzICogYyAtIGEyMyAqIHM7XG4gICAgb3V0WzhdID0gYTAwICogcyArIGEyMCAqIGM7XG4gICAgb3V0WzldID0gYTAxICogcyArIGEyMSAqIGM7XG4gICAgb3V0WzEwXSA9IGEwMiAqIHMgKyBhMjIgKiBjO1xuICAgIG91dFsxMV0gPSBhMDMgKiBzICsgYTIzICogYztcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBSb3RhdGVzIGEgbWF0cml4IGJ5IHRoZSBnaXZlbiBhbmdsZSBhcm91bmQgdGhlIFkgYXhpcyB1c2luZyBTSU1EXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0NH0gYSB0aGUgbWF0cml4IHRvIHJvdGF0ZVxuICogQHBhcmFtIHtOdW1iZXJ9IHJhZCB0aGUgYW5nbGUgdG8gcm90YXRlIHRoZSBtYXRyaXggYnlcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xubWF0NC5TSU1ELnJvdGF0ZVkgPSBmdW5jdGlvbiAob3V0LCBhLCByYWQpIHtcbiAgICB2YXIgcyA9IFNJTUQuRmxvYXQzMng0LnNwbGF0KE1hdGguc2luKHJhZCkpLFxuICAgICAgICBjID0gU0lNRC5GbG9hdDMyeDQuc3BsYXQoTWF0aC5jb3MocmFkKSk7XG5cbiAgICBpZiAoYSAhPT0gb3V0KSB7IC8vIElmIHRoZSBzb3VyY2UgYW5kIGRlc3RpbmF0aW9uIGRpZmZlciwgY29weSB0aGUgdW5jaGFuZ2VkIHJvd3NcbiAgICAgICAgb3V0WzRdICA9IGFbNF07XG4gICAgICAgIG91dFs1XSAgPSBhWzVdO1xuICAgICAgICBvdXRbNl0gID0gYVs2XTtcbiAgICAgICAgb3V0WzddICA9IGFbN107XG4gICAgICAgIG91dFsxMl0gPSBhWzEyXTtcbiAgICAgICAgb3V0WzEzXSA9IGFbMTNdO1xuICAgICAgICBvdXRbMTRdID0gYVsxNF07XG4gICAgICAgIG91dFsxNV0gPSBhWzE1XTtcbiAgICB9XG5cbiAgICAvLyBQZXJmb3JtIGF4aXMtc3BlY2lmaWMgbWF0cml4IG11bHRpcGxpY2F0aW9uXG4gICAgdmFyIGFfMCA9IFNJTUQuRmxvYXQzMng0LmxvYWQoYSwgMCk7XG4gICAgdmFyIGFfMiA9IFNJTUQuRmxvYXQzMng0LmxvYWQoYSwgOCk7XG4gICAgU0lNRC5GbG9hdDMyeDQuc3RvcmUob3V0LCAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgIFNJTUQuRmxvYXQzMng0LnN1YihTSU1ELkZsb2F0MzJ4NC5tdWwoYV8wLCBjKSwgU0lNRC5GbG9hdDMyeDQubXVsKGFfMiwgcykpKTtcbiAgICBTSU1ELkZsb2F0MzJ4NC5zdG9yZShvdXQsIDgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgU0lNRC5GbG9hdDMyeDQuYWRkKFNJTUQuRmxvYXQzMng0Lm11bChhXzAsIHMpLCBTSU1ELkZsb2F0MzJ4NC5tdWwoYV8yLCBjKSkpO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFJvdGF0ZXMgYSBtYXRyaXggYnkgdGhlIGdpdmVuIGFuZ2xlIGFyb3VuZCB0aGUgWSBheGlzIGlmIFNJTUQgYXZhaWxhYmxlIGFuZCBlbmFibGVkXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0NH0gYSB0aGUgbWF0cml4IHRvIHJvdGF0ZVxuICogQHBhcmFtIHtOdW1iZXJ9IHJhZCB0aGUgYW5nbGUgdG8gcm90YXRlIHRoZSBtYXRyaXggYnlcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xuIG1hdDQucm90YXRlWSA9IGdsTWF0cml4LlVTRV9TSU1EID8gbWF0NC5TSU1ELnJvdGF0ZVkgOiBtYXQ0LnNjYWxhci5yb3RhdGVZO1xuXG4vKipcbiAqIFJvdGF0ZXMgYSBtYXRyaXggYnkgdGhlIGdpdmVuIGFuZ2xlIGFyb3VuZCB0aGUgWiBheGlzIG5vdCB1c2luZyBTSU1EXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0NH0gYSB0aGUgbWF0cml4IHRvIHJvdGF0ZVxuICogQHBhcmFtIHtOdW1iZXJ9IHJhZCB0aGUgYW5nbGUgdG8gcm90YXRlIHRoZSBtYXRyaXggYnlcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xubWF0NC5zY2FsYXIucm90YXRlWiA9IGZ1bmN0aW9uIChvdXQsIGEsIHJhZCkge1xuICAgIHZhciBzID0gTWF0aC5zaW4ocmFkKSxcbiAgICAgICAgYyA9IE1hdGguY29zKHJhZCksXG4gICAgICAgIGEwMCA9IGFbMF0sXG4gICAgICAgIGEwMSA9IGFbMV0sXG4gICAgICAgIGEwMiA9IGFbMl0sXG4gICAgICAgIGEwMyA9IGFbM10sXG4gICAgICAgIGExMCA9IGFbNF0sXG4gICAgICAgIGExMSA9IGFbNV0sXG4gICAgICAgIGExMiA9IGFbNl0sXG4gICAgICAgIGExMyA9IGFbN107XG5cbiAgICBpZiAoYSAhPT0gb3V0KSB7IC8vIElmIHRoZSBzb3VyY2UgYW5kIGRlc3RpbmF0aW9uIGRpZmZlciwgY29weSB0aGUgdW5jaGFuZ2VkIGxhc3Qgcm93XG4gICAgICAgIG91dFs4XSAgPSBhWzhdO1xuICAgICAgICBvdXRbOV0gID0gYVs5XTtcbiAgICAgICAgb3V0WzEwXSA9IGFbMTBdO1xuICAgICAgICBvdXRbMTFdID0gYVsxMV07XG4gICAgICAgIG91dFsxMl0gPSBhWzEyXTtcbiAgICAgICAgb3V0WzEzXSA9IGFbMTNdO1xuICAgICAgICBvdXRbMTRdID0gYVsxNF07XG4gICAgICAgIG91dFsxNV0gPSBhWzE1XTtcbiAgICB9XG5cbiAgICAvLyBQZXJmb3JtIGF4aXMtc3BlY2lmaWMgbWF0cml4IG11bHRpcGxpY2F0aW9uXG4gICAgb3V0WzBdID0gYTAwICogYyArIGExMCAqIHM7XG4gICAgb3V0WzFdID0gYTAxICogYyArIGExMSAqIHM7XG4gICAgb3V0WzJdID0gYTAyICogYyArIGExMiAqIHM7XG4gICAgb3V0WzNdID0gYTAzICogYyArIGExMyAqIHM7XG4gICAgb3V0WzRdID0gYTEwICogYyAtIGEwMCAqIHM7XG4gICAgb3V0WzVdID0gYTExICogYyAtIGEwMSAqIHM7XG4gICAgb3V0WzZdID0gYTEyICogYyAtIGEwMiAqIHM7XG4gICAgb3V0WzddID0gYTEzICogYyAtIGEwMyAqIHM7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogUm90YXRlcyBhIG1hdHJpeCBieSB0aGUgZ2l2ZW4gYW5nbGUgYXJvdW5kIHRoZSBaIGF4aXMgdXNpbmcgU0lNRFxuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDR9IGEgdGhlIG1hdHJpeCB0byByb3RhdGVcbiAqIEBwYXJhbSB7TnVtYmVyfSByYWQgdGhlIGFuZ2xlIHRvIHJvdGF0ZSB0aGUgbWF0cml4IGJ5XG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbm1hdDQuU0lNRC5yb3RhdGVaID0gZnVuY3Rpb24gKG91dCwgYSwgcmFkKSB7XG4gICAgdmFyIHMgPSBTSU1ELkZsb2F0MzJ4NC5zcGxhdChNYXRoLnNpbihyYWQpKSxcbiAgICAgICAgYyA9IFNJTUQuRmxvYXQzMng0LnNwbGF0KE1hdGguY29zKHJhZCkpO1xuXG4gICAgaWYgKGEgIT09IG91dCkgeyAvLyBJZiB0aGUgc291cmNlIGFuZCBkZXN0aW5hdGlvbiBkaWZmZXIsIGNvcHkgdGhlIHVuY2hhbmdlZCBsYXN0IHJvd1xuICAgICAgICBvdXRbOF0gID0gYVs4XTtcbiAgICAgICAgb3V0WzldICA9IGFbOV07XG4gICAgICAgIG91dFsxMF0gPSBhWzEwXTtcbiAgICAgICAgb3V0WzExXSA9IGFbMTFdO1xuICAgICAgICBvdXRbMTJdID0gYVsxMl07XG4gICAgICAgIG91dFsxM10gPSBhWzEzXTtcbiAgICAgICAgb3V0WzE0XSA9IGFbMTRdO1xuICAgICAgICBvdXRbMTVdID0gYVsxNV07XG4gICAgfVxuXG4gICAgLy8gUGVyZm9ybSBheGlzLXNwZWNpZmljIG1hdHJpeCBtdWx0aXBsaWNhdGlvblxuICAgIHZhciBhXzAgPSBTSU1ELkZsb2F0MzJ4NC5sb2FkKGEsIDApO1xuICAgIHZhciBhXzEgPSBTSU1ELkZsb2F0MzJ4NC5sb2FkKGEsIDQpO1xuICAgIFNJTUQuRmxvYXQzMng0LnN0b3JlKG91dCwgMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICBTSU1ELkZsb2F0MzJ4NC5hZGQoU0lNRC5GbG9hdDMyeDQubXVsKGFfMCwgYyksIFNJTUQuRmxvYXQzMng0Lm11bChhXzEsIHMpKSk7XG4gICAgU0lNRC5GbG9hdDMyeDQuc3RvcmUob3V0LCA0LFxuICAgICAgICAgICAgICAgICAgICAgICAgIFNJTUQuRmxvYXQzMng0LnN1YihTSU1ELkZsb2F0MzJ4NC5tdWwoYV8xLCBjKSwgU0lNRC5GbG9hdDMyeDQubXVsKGFfMCwgcykpKTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBSb3RhdGVzIGEgbWF0cml4IGJ5IHRoZSBnaXZlbiBhbmdsZSBhcm91bmQgdGhlIFogYXhpcyBpZiBTSU1EIGF2YWlsYWJsZSBhbmQgZW5hYmxlZFxuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDR9IGEgdGhlIG1hdHJpeCB0byByb3RhdGVcbiAqIEBwYXJhbSB7TnVtYmVyfSByYWQgdGhlIGFuZ2xlIHRvIHJvdGF0ZSB0aGUgbWF0cml4IGJ5XG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbiBtYXQ0LnJvdGF0ZVogPSBnbE1hdHJpeC5VU0VfU0lNRCA/IG1hdDQuU0lNRC5yb3RhdGVaIDogbWF0NC5zY2FsYXIucm90YXRlWjtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbWF0cml4IGZyb20gYSB2ZWN0b3IgdHJhbnNsYXRpb25cbiAqIFRoaXMgaXMgZXF1aXZhbGVudCB0byAoYnV0IG11Y2ggZmFzdGVyIHRoYW4pOlxuICpcbiAqICAgICBtYXQ0LmlkZW50aXR5KGRlc3QpO1xuICogICAgIG1hdDQudHJhbnNsYXRlKGRlc3QsIGRlc3QsIHZlYyk7XG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgbWF0NCByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxuICogQHBhcmFtIHt2ZWMzfSB2IFRyYW5zbGF0aW9uIHZlY3RvclxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5tYXQ0LmZyb21UcmFuc2xhdGlvbiA9IGZ1bmN0aW9uKG91dCwgdikge1xuICAgIG91dFswXSA9IDE7XG4gICAgb3V0WzFdID0gMDtcbiAgICBvdXRbMl0gPSAwO1xuICAgIG91dFszXSA9IDA7XG4gICAgb3V0WzRdID0gMDtcbiAgICBvdXRbNV0gPSAxO1xuICAgIG91dFs2XSA9IDA7XG4gICAgb3V0WzddID0gMDtcbiAgICBvdXRbOF0gPSAwO1xuICAgIG91dFs5XSA9IDA7XG4gICAgb3V0WzEwXSA9IDE7XG4gICAgb3V0WzExXSA9IDA7XG4gICAgb3V0WzEyXSA9IHZbMF07XG4gICAgb3V0WzEzXSA9IHZbMV07XG4gICAgb3V0WzE0XSA9IHZbMl07XG4gICAgb3V0WzE1XSA9IDE7XG4gICAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbWF0cml4IGZyb20gYSB2ZWN0b3Igc2NhbGluZ1xuICogVGhpcyBpcyBlcXVpdmFsZW50IHRvIChidXQgbXVjaCBmYXN0ZXIgdGhhbik6XG4gKlxuICogICAgIG1hdDQuaWRlbnRpdHkoZGVzdCk7XG4gKiAgICAgbWF0NC5zY2FsZShkZXN0LCBkZXN0LCB2ZWMpO1xuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IG1hdDQgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcbiAqIEBwYXJhbSB7dmVjM30gdiBTY2FsaW5nIHZlY3RvclxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5tYXQ0LmZyb21TY2FsaW5nID0gZnVuY3Rpb24ob3V0LCB2KSB7XG4gICAgb3V0WzBdID0gdlswXTtcbiAgICBvdXRbMV0gPSAwO1xuICAgIG91dFsyXSA9IDA7XG4gICAgb3V0WzNdID0gMDtcbiAgICBvdXRbNF0gPSAwO1xuICAgIG91dFs1XSA9IHZbMV07XG4gICAgb3V0WzZdID0gMDtcbiAgICBvdXRbN10gPSAwO1xuICAgIG91dFs4XSA9IDA7XG4gICAgb3V0WzldID0gMDtcbiAgICBvdXRbMTBdID0gdlsyXTtcbiAgICBvdXRbMTFdID0gMDtcbiAgICBvdXRbMTJdID0gMDtcbiAgICBvdXRbMTNdID0gMDtcbiAgICBvdXRbMTRdID0gMDtcbiAgICBvdXRbMTVdID0gMTtcbiAgICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBtYXRyaXggZnJvbSBhIGdpdmVuIGFuZ2xlIGFyb3VuZCBhIGdpdmVuIGF4aXNcbiAqIFRoaXMgaXMgZXF1aXZhbGVudCB0byAoYnV0IG11Y2ggZmFzdGVyIHRoYW4pOlxuICpcbiAqICAgICBtYXQ0LmlkZW50aXR5KGRlc3QpO1xuICogICAgIG1hdDQucm90YXRlKGRlc3QsIGRlc3QsIHJhZCwgYXhpcyk7XG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgbWF0NCByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxuICogQHBhcmFtIHtOdW1iZXJ9IHJhZCB0aGUgYW5nbGUgdG8gcm90YXRlIHRoZSBtYXRyaXggYnlcbiAqIEBwYXJhbSB7dmVjM30gYXhpcyB0aGUgYXhpcyB0byByb3RhdGUgYXJvdW5kXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbm1hdDQuZnJvbVJvdGF0aW9uID0gZnVuY3Rpb24ob3V0LCByYWQsIGF4aXMpIHtcbiAgICB2YXIgeCA9IGF4aXNbMF0sIHkgPSBheGlzWzFdLCB6ID0gYXhpc1syXSxcbiAgICAgICAgbGVuID0gTWF0aC5zcXJ0KHggKiB4ICsgeSAqIHkgKyB6ICogeiksXG4gICAgICAgIHMsIGMsIHQ7XG5cbiAgICBpZiAoTWF0aC5hYnMobGVuKSA8IGdsTWF0cml4LkVQU0lMT04pIHsgcmV0dXJuIG51bGw7IH1cblxuICAgIGxlbiA9IDEgLyBsZW47XG4gICAgeCAqPSBsZW47XG4gICAgeSAqPSBsZW47XG4gICAgeiAqPSBsZW47XG5cbiAgICBzID0gTWF0aC5zaW4ocmFkKTtcbiAgICBjID0gTWF0aC5jb3MocmFkKTtcbiAgICB0ID0gMSAtIGM7XG5cbiAgICAvLyBQZXJmb3JtIHJvdGF0aW9uLXNwZWNpZmljIG1hdHJpeCBtdWx0aXBsaWNhdGlvblxuICAgIG91dFswXSA9IHggKiB4ICogdCArIGM7XG4gICAgb3V0WzFdID0geSAqIHggKiB0ICsgeiAqIHM7XG4gICAgb3V0WzJdID0geiAqIHggKiB0IC0geSAqIHM7XG4gICAgb3V0WzNdID0gMDtcbiAgICBvdXRbNF0gPSB4ICogeSAqIHQgLSB6ICogcztcbiAgICBvdXRbNV0gPSB5ICogeSAqIHQgKyBjO1xuICAgIG91dFs2XSA9IHogKiB5ICogdCArIHggKiBzO1xuICAgIG91dFs3XSA9IDA7XG4gICAgb3V0WzhdID0geCAqIHogKiB0ICsgeSAqIHM7XG4gICAgb3V0WzldID0geSAqIHogKiB0IC0geCAqIHM7XG4gICAgb3V0WzEwXSA9IHogKiB6ICogdCArIGM7XG4gICAgb3V0WzExXSA9IDA7XG4gICAgb3V0WzEyXSA9IDA7XG4gICAgb3V0WzEzXSA9IDA7XG4gICAgb3V0WzE0XSA9IDA7XG4gICAgb3V0WzE1XSA9IDE7XG4gICAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbWF0cml4IGZyb20gdGhlIGdpdmVuIGFuZ2xlIGFyb3VuZCB0aGUgWCBheGlzXG4gKiBUaGlzIGlzIGVxdWl2YWxlbnQgdG8gKGJ1dCBtdWNoIGZhc3RlciB0aGFuKTpcbiAqXG4gKiAgICAgbWF0NC5pZGVudGl0eShkZXN0KTtcbiAqICAgICBtYXQ0LnJvdGF0ZVgoZGVzdCwgZGVzdCwgcmFkKTtcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCBtYXQ0IHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XG4gKiBAcGFyYW0ge051bWJlcn0gcmFkIHRoZSBhbmdsZSB0byByb3RhdGUgdGhlIG1hdHJpeCBieVxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5tYXQ0LmZyb21YUm90YXRpb24gPSBmdW5jdGlvbihvdXQsIHJhZCkge1xuICAgIHZhciBzID0gTWF0aC5zaW4ocmFkKSxcbiAgICAgICAgYyA9IE1hdGguY29zKHJhZCk7XG5cbiAgICAvLyBQZXJmb3JtIGF4aXMtc3BlY2lmaWMgbWF0cml4IG11bHRpcGxpY2F0aW9uXG4gICAgb3V0WzBdICA9IDE7XG4gICAgb3V0WzFdICA9IDA7XG4gICAgb3V0WzJdICA9IDA7XG4gICAgb3V0WzNdICA9IDA7XG4gICAgb3V0WzRdID0gMDtcbiAgICBvdXRbNV0gPSBjO1xuICAgIG91dFs2XSA9IHM7XG4gICAgb3V0WzddID0gMDtcbiAgICBvdXRbOF0gPSAwO1xuICAgIG91dFs5XSA9IC1zO1xuICAgIG91dFsxMF0gPSBjO1xuICAgIG91dFsxMV0gPSAwO1xuICAgIG91dFsxMl0gPSAwO1xuICAgIG91dFsxM10gPSAwO1xuICAgIG91dFsxNF0gPSAwO1xuICAgIG91dFsxNV0gPSAxO1xuICAgIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG1hdHJpeCBmcm9tIHRoZSBnaXZlbiBhbmdsZSBhcm91bmQgdGhlIFkgYXhpc1xuICogVGhpcyBpcyBlcXVpdmFsZW50IHRvIChidXQgbXVjaCBmYXN0ZXIgdGhhbik6XG4gKlxuICogICAgIG1hdDQuaWRlbnRpdHkoZGVzdCk7XG4gKiAgICAgbWF0NC5yb3RhdGVZKGRlc3QsIGRlc3QsIHJhZCk7XG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgbWF0NCByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxuICogQHBhcmFtIHtOdW1iZXJ9IHJhZCB0aGUgYW5nbGUgdG8gcm90YXRlIHRoZSBtYXRyaXggYnlcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xubWF0NC5mcm9tWVJvdGF0aW9uID0gZnVuY3Rpb24ob3V0LCByYWQpIHtcbiAgICB2YXIgcyA9IE1hdGguc2luKHJhZCksXG4gICAgICAgIGMgPSBNYXRoLmNvcyhyYWQpO1xuXG4gICAgLy8gUGVyZm9ybSBheGlzLXNwZWNpZmljIG1hdHJpeCBtdWx0aXBsaWNhdGlvblxuICAgIG91dFswXSAgPSBjO1xuICAgIG91dFsxXSAgPSAwO1xuICAgIG91dFsyXSAgPSAtcztcbiAgICBvdXRbM10gID0gMDtcbiAgICBvdXRbNF0gPSAwO1xuICAgIG91dFs1XSA9IDE7XG4gICAgb3V0WzZdID0gMDtcbiAgICBvdXRbN10gPSAwO1xuICAgIG91dFs4XSA9IHM7XG4gICAgb3V0WzldID0gMDtcbiAgICBvdXRbMTBdID0gYztcbiAgICBvdXRbMTFdID0gMDtcbiAgICBvdXRbMTJdID0gMDtcbiAgICBvdXRbMTNdID0gMDtcbiAgICBvdXRbMTRdID0gMDtcbiAgICBvdXRbMTVdID0gMTtcbiAgICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBtYXRyaXggZnJvbSB0aGUgZ2l2ZW4gYW5nbGUgYXJvdW5kIHRoZSBaIGF4aXNcbiAqIFRoaXMgaXMgZXF1aXZhbGVudCB0byAoYnV0IG11Y2ggZmFzdGVyIHRoYW4pOlxuICpcbiAqICAgICBtYXQ0LmlkZW50aXR5KGRlc3QpO1xuICogICAgIG1hdDQucm90YXRlWihkZXN0LCBkZXN0LCByYWQpO1xuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IG1hdDQgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcbiAqIEBwYXJhbSB7TnVtYmVyfSByYWQgdGhlIGFuZ2xlIHRvIHJvdGF0ZSB0aGUgbWF0cml4IGJ5XG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbm1hdDQuZnJvbVpSb3RhdGlvbiA9IGZ1bmN0aW9uKG91dCwgcmFkKSB7XG4gICAgdmFyIHMgPSBNYXRoLnNpbihyYWQpLFxuICAgICAgICBjID0gTWF0aC5jb3MocmFkKTtcblxuICAgIC8vIFBlcmZvcm0gYXhpcy1zcGVjaWZpYyBtYXRyaXggbXVsdGlwbGljYXRpb25cbiAgICBvdXRbMF0gID0gYztcbiAgICBvdXRbMV0gID0gcztcbiAgICBvdXRbMl0gID0gMDtcbiAgICBvdXRbM10gID0gMDtcbiAgICBvdXRbNF0gPSAtcztcbiAgICBvdXRbNV0gPSBjO1xuICAgIG91dFs2XSA9IDA7XG4gICAgb3V0WzddID0gMDtcbiAgICBvdXRbOF0gPSAwO1xuICAgIG91dFs5XSA9IDA7XG4gICAgb3V0WzEwXSA9IDE7XG4gICAgb3V0WzExXSA9IDA7XG4gICAgb3V0WzEyXSA9IDA7XG4gICAgb3V0WzEzXSA9IDA7XG4gICAgb3V0WzE0XSA9IDA7XG4gICAgb3V0WzE1XSA9IDE7XG4gICAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbWF0cml4IGZyb20gYSBxdWF0ZXJuaW9uIHJvdGF0aW9uIGFuZCB2ZWN0b3IgdHJhbnNsYXRpb25cbiAqIFRoaXMgaXMgZXF1aXZhbGVudCB0byAoYnV0IG11Y2ggZmFzdGVyIHRoYW4pOlxuICpcbiAqICAgICBtYXQ0LmlkZW50aXR5KGRlc3QpO1xuICogICAgIG1hdDQudHJhbnNsYXRlKGRlc3QsIHZlYyk7XG4gKiAgICAgdmFyIHF1YXRNYXQgPSBtYXQ0LmNyZWF0ZSgpO1xuICogICAgIHF1YXQ0LnRvTWF0NChxdWF0LCBxdWF0TWF0KTtcbiAqICAgICBtYXQ0Lm11bHRpcGx5KGRlc3QsIHF1YXRNYXQpO1xuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IG1hdDQgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcbiAqIEBwYXJhbSB7cXVhdDR9IHEgUm90YXRpb24gcXVhdGVybmlvblxuICogQHBhcmFtIHt2ZWMzfSB2IFRyYW5zbGF0aW9uIHZlY3RvclxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5tYXQ0LmZyb21Sb3RhdGlvblRyYW5zbGF0aW9uID0gZnVuY3Rpb24gKG91dCwgcSwgdikge1xuICAgIC8vIFF1YXRlcm5pb24gbWF0aFxuICAgIHZhciB4ID0gcVswXSwgeSA9IHFbMV0sIHogPSBxWzJdLCB3ID0gcVszXSxcbiAgICAgICAgeDIgPSB4ICsgeCxcbiAgICAgICAgeTIgPSB5ICsgeSxcbiAgICAgICAgejIgPSB6ICsgeixcblxuICAgICAgICB4eCA9IHggKiB4MixcbiAgICAgICAgeHkgPSB4ICogeTIsXG4gICAgICAgIHh6ID0geCAqIHoyLFxuICAgICAgICB5eSA9IHkgKiB5MixcbiAgICAgICAgeXogPSB5ICogejIsXG4gICAgICAgIHp6ID0geiAqIHoyLFxuICAgICAgICB3eCA9IHcgKiB4MixcbiAgICAgICAgd3kgPSB3ICogeTIsXG4gICAgICAgIHd6ID0gdyAqIHoyO1xuXG4gICAgb3V0WzBdID0gMSAtICh5eSArIHp6KTtcbiAgICBvdXRbMV0gPSB4eSArIHd6O1xuICAgIG91dFsyXSA9IHh6IC0gd3k7XG4gICAgb3V0WzNdID0gMDtcbiAgICBvdXRbNF0gPSB4eSAtIHd6O1xuICAgIG91dFs1XSA9IDEgLSAoeHggKyB6eik7XG4gICAgb3V0WzZdID0geXogKyB3eDtcbiAgICBvdXRbN10gPSAwO1xuICAgIG91dFs4XSA9IHh6ICsgd3k7XG4gICAgb3V0WzldID0geXogLSB3eDtcbiAgICBvdXRbMTBdID0gMSAtICh4eCArIHl5KTtcbiAgICBvdXRbMTFdID0gMDtcbiAgICBvdXRbMTJdID0gdlswXTtcbiAgICBvdXRbMTNdID0gdlsxXTtcbiAgICBvdXRbMTRdID0gdlsyXTtcbiAgICBvdXRbMTVdID0gMTtcblxuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIHRyYW5zbGF0aW9uIHZlY3RvciBjb21wb25lbnQgb2YgYSB0cmFuc2Zvcm1hdGlvblxuICogIG1hdHJpeC4gSWYgYSBtYXRyaXggaXMgYnVpbHQgd2l0aCBmcm9tUm90YXRpb25UcmFuc2xhdGlvbixcbiAqICB0aGUgcmV0dXJuZWQgdmVjdG9yIHdpbGwgYmUgdGhlIHNhbWUgYXMgdGhlIHRyYW5zbGF0aW9uIHZlY3RvclxuICogIG9yaWdpbmFsbHkgc3VwcGxpZWQuXG4gKiBAcGFyYW0gIHt2ZWMzfSBvdXQgVmVjdG9yIHRvIHJlY2VpdmUgdHJhbnNsYXRpb24gY29tcG9uZW50XG4gKiBAcGFyYW0gIHttYXQ0fSBtYXQgTWF0cml4IHRvIGJlIGRlY29tcG9zZWQgKGlucHV0KVxuICogQHJldHVybiB7dmVjM30gb3V0XG4gKi9cbm1hdDQuZ2V0VHJhbnNsYXRpb24gPSBmdW5jdGlvbiAob3V0LCBtYXQpIHtcbiAgb3V0WzBdID0gbWF0WzEyXTtcbiAgb3V0WzFdID0gbWF0WzEzXTtcbiAgb3V0WzJdID0gbWF0WzE0XTtcblxuICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIGEgcXVhdGVybmlvbiByZXByZXNlbnRpbmcgdGhlIHJvdGF0aW9uYWwgY29tcG9uZW50XG4gKiAgb2YgYSB0cmFuc2Zvcm1hdGlvbiBtYXRyaXguIElmIGEgbWF0cml4IGlzIGJ1aWx0IHdpdGhcbiAqICBmcm9tUm90YXRpb25UcmFuc2xhdGlvbiwgdGhlIHJldHVybmVkIHF1YXRlcm5pb24gd2lsbCBiZSB0aGVcbiAqICBzYW1lIGFzIHRoZSBxdWF0ZXJuaW9uIG9yaWdpbmFsbHkgc3VwcGxpZWQuXG4gKiBAcGFyYW0ge3F1YXR9IG91dCBRdWF0ZXJuaW9uIHRvIHJlY2VpdmUgdGhlIHJvdGF0aW9uIGNvbXBvbmVudFxuICogQHBhcmFtIHttYXQ0fSBtYXQgTWF0cml4IHRvIGJlIGRlY29tcG9zZWQgKGlucHV0KVxuICogQHJldHVybiB7cXVhdH0gb3V0XG4gKi9cbm1hdDQuZ2V0Um90YXRpb24gPSBmdW5jdGlvbiAob3V0LCBtYXQpIHtcbiAgLy8gQWxnb3JpdGhtIHRha2VuIGZyb20gaHR0cDovL3d3dy5ldWNsaWRlYW5zcGFjZS5jb20vbWF0aHMvZ2VvbWV0cnkvcm90YXRpb25zL2NvbnZlcnNpb25zL21hdHJpeFRvUXVhdGVybmlvbi9pbmRleC5odG1cbiAgdmFyIHRyYWNlID0gbWF0WzBdICsgbWF0WzVdICsgbWF0WzEwXTtcbiAgdmFyIFMgPSAwO1xuXG4gIGlmICh0cmFjZSA+IDApIHsgXG4gICAgUyA9IE1hdGguc3FydCh0cmFjZSArIDEuMCkgKiAyO1xuICAgIG91dFszXSA9IDAuMjUgKiBTO1xuICAgIG91dFswXSA9IChtYXRbNl0gLSBtYXRbOV0pIC8gUztcbiAgICBvdXRbMV0gPSAobWF0WzhdIC0gbWF0WzJdKSAvIFM7IFxuICAgIG91dFsyXSA9IChtYXRbMV0gLSBtYXRbNF0pIC8gUzsgXG4gIH0gZWxzZSBpZiAoKG1hdFswXSA+IG1hdFs1XSkmKG1hdFswXSA+IG1hdFsxMF0pKSB7IFxuICAgIFMgPSBNYXRoLnNxcnQoMS4wICsgbWF0WzBdIC0gbWF0WzVdIC0gbWF0WzEwXSkgKiAyO1xuICAgIG91dFszXSA9IChtYXRbNl0gLSBtYXRbOV0pIC8gUztcbiAgICBvdXRbMF0gPSAwLjI1ICogUztcbiAgICBvdXRbMV0gPSAobWF0WzFdICsgbWF0WzRdKSAvIFM7IFxuICAgIG91dFsyXSA9IChtYXRbOF0gKyBtYXRbMl0pIC8gUzsgXG4gIH0gZWxzZSBpZiAobWF0WzVdID4gbWF0WzEwXSkgeyBcbiAgICBTID0gTWF0aC5zcXJ0KDEuMCArIG1hdFs1XSAtIG1hdFswXSAtIG1hdFsxMF0pICogMjtcbiAgICBvdXRbM10gPSAobWF0WzhdIC0gbWF0WzJdKSAvIFM7XG4gICAgb3V0WzBdID0gKG1hdFsxXSArIG1hdFs0XSkgLyBTOyBcbiAgICBvdXRbMV0gPSAwLjI1ICogUztcbiAgICBvdXRbMl0gPSAobWF0WzZdICsgbWF0WzldKSAvIFM7IFxuICB9IGVsc2UgeyBcbiAgICBTID0gTWF0aC5zcXJ0KDEuMCArIG1hdFsxMF0gLSBtYXRbMF0gLSBtYXRbNV0pICogMjtcbiAgICBvdXRbM10gPSAobWF0WzFdIC0gbWF0WzRdKSAvIFM7XG4gICAgb3V0WzBdID0gKG1hdFs4XSArIG1hdFsyXSkgLyBTO1xuICAgIG91dFsxXSA9IChtYXRbNl0gKyBtYXRbOV0pIC8gUztcbiAgICBvdXRbMl0gPSAwLjI1ICogUztcbiAgfVxuXG4gIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBtYXRyaXggZnJvbSBhIHF1YXRlcm5pb24gcm90YXRpb24sIHZlY3RvciB0cmFuc2xhdGlvbiBhbmQgdmVjdG9yIHNjYWxlXG4gKiBUaGlzIGlzIGVxdWl2YWxlbnQgdG8gKGJ1dCBtdWNoIGZhc3RlciB0aGFuKTpcbiAqXG4gKiAgICAgbWF0NC5pZGVudGl0eShkZXN0KTtcbiAqICAgICBtYXQ0LnRyYW5zbGF0ZShkZXN0LCB2ZWMpO1xuICogICAgIHZhciBxdWF0TWF0ID0gbWF0NC5jcmVhdGUoKTtcbiAqICAgICBxdWF0NC50b01hdDQocXVhdCwgcXVhdE1hdCk7XG4gKiAgICAgbWF0NC5tdWx0aXBseShkZXN0LCBxdWF0TWF0KTtcbiAqICAgICBtYXQ0LnNjYWxlKGRlc3QsIHNjYWxlKVxuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IG1hdDQgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcbiAqIEBwYXJhbSB7cXVhdDR9IHEgUm90YXRpb24gcXVhdGVybmlvblxuICogQHBhcmFtIHt2ZWMzfSB2IFRyYW5zbGF0aW9uIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBzIFNjYWxpbmcgdmVjdG9yXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbm1hdDQuZnJvbVJvdGF0aW9uVHJhbnNsYXRpb25TY2FsZSA9IGZ1bmN0aW9uIChvdXQsIHEsIHYsIHMpIHtcbiAgICAvLyBRdWF0ZXJuaW9uIG1hdGhcbiAgICB2YXIgeCA9IHFbMF0sIHkgPSBxWzFdLCB6ID0gcVsyXSwgdyA9IHFbM10sXG4gICAgICAgIHgyID0geCArIHgsXG4gICAgICAgIHkyID0geSArIHksXG4gICAgICAgIHoyID0geiArIHosXG5cbiAgICAgICAgeHggPSB4ICogeDIsXG4gICAgICAgIHh5ID0geCAqIHkyLFxuICAgICAgICB4eiA9IHggKiB6MixcbiAgICAgICAgeXkgPSB5ICogeTIsXG4gICAgICAgIHl6ID0geSAqIHoyLFxuICAgICAgICB6eiA9IHogKiB6MixcbiAgICAgICAgd3ggPSB3ICogeDIsXG4gICAgICAgIHd5ID0gdyAqIHkyLFxuICAgICAgICB3eiA9IHcgKiB6MixcbiAgICAgICAgc3ggPSBzWzBdLFxuICAgICAgICBzeSA9IHNbMV0sXG4gICAgICAgIHN6ID0gc1syXTtcblxuICAgIG91dFswXSA9ICgxIC0gKHl5ICsgenopKSAqIHN4O1xuICAgIG91dFsxXSA9ICh4eSArIHd6KSAqIHN4O1xuICAgIG91dFsyXSA9ICh4eiAtIHd5KSAqIHN4O1xuICAgIG91dFszXSA9IDA7XG4gICAgb3V0WzRdID0gKHh5IC0gd3opICogc3k7XG4gICAgb3V0WzVdID0gKDEgLSAoeHggKyB6eikpICogc3k7XG4gICAgb3V0WzZdID0gKHl6ICsgd3gpICogc3k7XG4gICAgb3V0WzddID0gMDtcbiAgICBvdXRbOF0gPSAoeHogKyB3eSkgKiBzejtcbiAgICBvdXRbOV0gPSAoeXogLSB3eCkgKiBzejtcbiAgICBvdXRbMTBdID0gKDEgLSAoeHggKyB5eSkpICogc3o7XG4gICAgb3V0WzExXSA9IDA7XG4gICAgb3V0WzEyXSA9IHZbMF07XG4gICAgb3V0WzEzXSA9IHZbMV07XG4gICAgb3V0WzE0XSA9IHZbMl07XG4gICAgb3V0WzE1XSA9IDE7XG5cbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbWF0cml4IGZyb20gYSBxdWF0ZXJuaW9uIHJvdGF0aW9uLCB2ZWN0b3IgdHJhbnNsYXRpb24gYW5kIHZlY3RvciBzY2FsZSwgcm90YXRpbmcgYW5kIHNjYWxpbmcgYXJvdW5kIHRoZSBnaXZlbiBvcmlnaW5cbiAqIFRoaXMgaXMgZXF1aXZhbGVudCB0byAoYnV0IG11Y2ggZmFzdGVyIHRoYW4pOlxuICpcbiAqICAgICBtYXQ0LmlkZW50aXR5KGRlc3QpO1xuICogICAgIG1hdDQudHJhbnNsYXRlKGRlc3QsIHZlYyk7XG4gKiAgICAgbWF0NC50cmFuc2xhdGUoZGVzdCwgb3JpZ2luKTtcbiAqICAgICB2YXIgcXVhdE1hdCA9IG1hdDQuY3JlYXRlKCk7XG4gKiAgICAgcXVhdDQudG9NYXQ0KHF1YXQsIHF1YXRNYXQpO1xuICogICAgIG1hdDQubXVsdGlwbHkoZGVzdCwgcXVhdE1hdCk7XG4gKiAgICAgbWF0NC5zY2FsZShkZXN0LCBzY2FsZSlcbiAqICAgICBtYXQ0LnRyYW5zbGF0ZShkZXN0LCBuZWdhdGl2ZU9yaWdpbik7XG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgbWF0NCByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxuICogQHBhcmFtIHtxdWF0NH0gcSBSb3RhdGlvbiBxdWF0ZXJuaW9uXG4gKiBAcGFyYW0ge3ZlYzN9IHYgVHJhbnNsYXRpb24gdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IHMgU2NhbGluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gbyBUaGUgb3JpZ2luIHZlY3RvciBhcm91bmQgd2hpY2ggdG8gc2NhbGUgYW5kIHJvdGF0ZVxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5tYXQ0LmZyb21Sb3RhdGlvblRyYW5zbGF0aW9uU2NhbGVPcmlnaW4gPSBmdW5jdGlvbiAob3V0LCBxLCB2LCBzLCBvKSB7XG4gIC8vIFF1YXRlcm5pb24gbWF0aFxuICB2YXIgeCA9IHFbMF0sIHkgPSBxWzFdLCB6ID0gcVsyXSwgdyA9IHFbM10sXG4gICAgICB4MiA9IHggKyB4LFxuICAgICAgeTIgPSB5ICsgeSxcbiAgICAgIHoyID0geiArIHosXG5cbiAgICAgIHh4ID0geCAqIHgyLFxuICAgICAgeHkgPSB4ICogeTIsXG4gICAgICB4eiA9IHggKiB6MixcbiAgICAgIHl5ID0geSAqIHkyLFxuICAgICAgeXogPSB5ICogejIsXG4gICAgICB6eiA9IHogKiB6MixcbiAgICAgIHd4ID0gdyAqIHgyLFxuICAgICAgd3kgPSB3ICogeTIsXG4gICAgICB3eiA9IHcgKiB6MixcblxuICAgICAgc3ggPSBzWzBdLFxuICAgICAgc3kgPSBzWzFdLFxuICAgICAgc3ogPSBzWzJdLFxuXG4gICAgICBveCA9IG9bMF0sXG4gICAgICBveSA9IG9bMV0sXG4gICAgICBveiA9IG9bMl07XG5cbiAgb3V0WzBdID0gKDEgLSAoeXkgKyB6eikpICogc3g7XG4gIG91dFsxXSA9ICh4eSArIHd6KSAqIHN4O1xuICBvdXRbMl0gPSAoeHogLSB3eSkgKiBzeDtcbiAgb3V0WzNdID0gMDtcbiAgb3V0WzRdID0gKHh5IC0gd3opICogc3k7XG4gIG91dFs1XSA9ICgxIC0gKHh4ICsgenopKSAqIHN5O1xuICBvdXRbNl0gPSAoeXogKyB3eCkgKiBzeTtcbiAgb3V0WzddID0gMDtcbiAgb3V0WzhdID0gKHh6ICsgd3kpICogc3o7XG4gIG91dFs5XSA9ICh5eiAtIHd4KSAqIHN6O1xuICBvdXRbMTBdID0gKDEgLSAoeHggKyB5eSkpICogc3o7XG4gIG91dFsxMV0gPSAwO1xuICBvdXRbMTJdID0gdlswXSArIG94IC0gKG91dFswXSAqIG94ICsgb3V0WzRdICogb3kgKyBvdXRbOF0gKiBveik7XG4gIG91dFsxM10gPSB2WzFdICsgb3kgLSAob3V0WzFdICogb3ggKyBvdXRbNV0gKiBveSArIG91dFs5XSAqIG96KTtcbiAgb3V0WzE0XSA9IHZbMl0gKyBveiAtIChvdXRbMl0gKiBveCArIG91dFs2XSAqIG95ICsgb3V0WzEwXSAqIG96KTtcbiAgb3V0WzE1XSA9IDE7XG5cbiAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ2FsY3VsYXRlcyBhIDR4NCBtYXRyaXggZnJvbSB0aGUgZ2l2ZW4gcXVhdGVybmlvblxuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IG1hdDQgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcbiAqIEBwYXJhbSB7cXVhdH0gcSBRdWF0ZXJuaW9uIHRvIGNyZWF0ZSBtYXRyaXggZnJvbVxuICpcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xubWF0NC5mcm9tUXVhdCA9IGZ1bmN0aW9uIChvdXQsIHEpIHtcbiAgICB2YXIgeCA9IHFbMF0sIHkgPSBxWzFdLCB6ID0gcVsyXSwgdyA9IHFbM10sXG4gICAgICAgIHgyID0geCArIHgsXG4gICAgICAgIHkyID0geSArIHksXG4gICAgICAgIHoyID0geiArIHosXG5cbiAgICAgICAgeHggPSB4ICogeDIsXG4gICAgICAgIHl4ID0geSAqIHgyLFxuICAgICAgICB5eSA9IHkgKiB5MixcbiAgICAgICAgenggPSB6ICogeDIsXG4gICAgICAgIHp5ID0geiAqIHkyLFxuICAgICAgICB6eiA9IHogKiB6MixcbiAgICAgICAgd3ggPSB3ICogeDIsXG4gICAgICAgIHd5ID0gdyAqIHkyLFxuICAgICAgICB3eiA9IHcgKiB6MjtcblxuICAgIG91dFswXSA9IDEgLSB5eSAtIHp6O1xuICAgIG91dFsxXSA9IHl4ICsgd3o7XG4gICAgb3V0WzJdID0genggLSB3eTtcbiAgICBvdXRbM10gPSAwO1xuXG4gICAgb3V0WzRdID0geXggLSB3ejtcbiAgICBvdXRbNV0gPSAxIC0geHggLSB6ejtcbiAgICBvdXRbNl0gPSB6eSArIHd4O1xuICAgIG91dFs3XSA9IDA7XG5cbiAgICBvdXRbOF0gPSB6eCArIHd5O1xuICAgIG91dFs5XSA9IHp5IC0gd3g7XG4gICAgb3V0WzEwXSA9IDEgLSB4eCAtIHl5O1xuICAgIG91dFsxMV0gPSAwO1xuXG4gICAgb3V0WzEyXSA9IDA7XG4gICAgb3V0WzEzXSA9IDA7XG4gICAgb3V0WzE0XSA9IDA7XG4gICAgb3V0WzE1XSA9IDE7XG5cbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBHZW5lcmF0ZXMgYSBmcnVzdHVtIG1hdHJpeCB3aXRoIHRoZSBnaXZlbiBib3VuZHNcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCBtYXQ0IGZydXN0dW0gbWF0cml4IHdpbGwgYmUgd3JpdHRlbiBpbnRvXG4gKiBAcGFyYW0ge051bWJlcn0gbGVmdCBMZWZ0IGJvdW5kIG9mIHRoZSBmcnVzdHVtXG4gKiBAcGFyYW0ge051bWJlcn0gcmlnaHQgUmlnaHQgYm91bmQgb2YgdGhlIGZydXN0dW1cbiAqIEBwYXJhbSB7TnVtYmVyfSBib3R0b20gQm90dG9tIGJvdW5kIG9mIHRoZSBmcnVzdHVtXG4gKiBAcGFyYW0ge051bWJlcn0gdG9wIFRvcCBib3VuZCBvZiB0aGUgZnJ1c3R1bVxuICogQHBhcmFtIHtOdW1iZXJ9IG5lYXIgTmVhciBib3VuZCBvZiB0aGUgZnJ1c3R1bVxuICogQHBhcmFtIHtOdW1iZXJ9IGZhciBGYXIgYm91bmQgb2YgdGhlIGZydXN0dW1cbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xubWF0NC5mcnVzdHVtID0gZnVuY3Rpb24gKG91dCwgbGVmdCwgcmlnaHQsIGJvdHRvbSwgdG9wLCBuZWFyLCBmYXIpIHtcbiAgICB2YXIgcmwgPSAxIC8gKHJpZ2h0IC0gbGVmdCksXG4gICAgICAgIHRiID0gMSAvICh0b3AgLSBib3R0b20pLFxuICAgICAgICBuZiA9IDEgLyAobmVhciAtIGZhcik7XG4gICAgb3V0WzBdID0gKG5lYXIgKiAyKSAqIHJsO1xuICAgIG91dFsxXSA9IDA7XG4gICAgb3V0WzJdID0gMDtcbiAgICBvdXRbM10gPSAwO1xuICAgIG91dFs0XSA9IDA7XG4gICAgb3V0WzVdID0gKG5lYXIgKiAyKSAqIHRiO1xuICAgIG91dFs2XSA9IDA7XG4gICAgb3V0WzddID0gMDtcbiAgICBvdXRbOF0gPSAocmlnaHQgKyBsZWZ0KSAqIHJsO1xuICAgIG91dFs5XSA9ICh0b3AgKyBib3R0b20pICogdGI7XG4gICAgb3V0WzEwXSA9IChmYXIgKyBuZWFyKSAqIG5mO1xuICAgIG91dFsxMV0gPSAtMTtcbiAgICBvdXRbMTJdID0gMDtcbiAgICBvdXRbMTNdID0gMDtcbiAgICBvdXRbMTRdID0gKGZhciAqIG5lYXIgKiAyKSAqIG5mO1xuICAgIG91dFsxNV0gPSAwO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIEdlbmVyYXRlcyBhIHBlcnNwZWN0aXZlIHByb2plY3Rpb24gbWF0cml4IHdpdGggdGhlIGdpdmVuIGJvdW5kc1xuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IG1hdDQgZnJ1c3R1bSBtYXRyaXggd2lsbCBiZSB3cml0dGVuIGludG9cbiAqIEBwYXJhbSB7bnVtYmVyfSBmb3Z5IFZlcnRpY2FsIGZpZWxkIG9mIHZpZXcgaW4gcmFkaWFuc1xuICogQHBhcmFtIHtudW1iZXJ9IGFzcGVjdCBBc3BlY3QgcmF0aW8uIHR5cGljYWxseSB2aWV3cG9ydCB3aWR0aC9oZWlnaHRcbiAqIEBwYXJhbSB7bnVtYmVyfSBuZWFyIE5lYXIgYm91bmQgb2YgdGhlIGZydXN0dW1cbiAqIEBwYXJhbSB7bnVtYmVyfSBmYXIgRmFyIGJvdW5kIG9mIHRoZSBmcnVzdHVtXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbm1hdDQucGVyc3BlY3RpdmUgPSBmdW5jdGlvbiAob3V0LCBmb3Z5LCBhc3BlY3QsIG5lYXIsIGZhcikge1xuICAgIHZhciBmID0gMS4wIC8gTWF0aC50YW4oZm92eSAvIDIpLFxuICAgICAgICBuZiA9IDEgLyAobmVhciAtIGZhcik7XG4gICAgb3V0WzBdID0gZiAvIGFzcGVjdDtcbiAgICBvdXRbMV0gPSAwO1xuICAgIG91dFsyXSA9IDA7XG4gICAgb3V0WzNdID0gMDtcbiAgICBvdXRbNF0gPSAwO1xuICAgIG91dFs1XSA9IGY7XG4gICAgb3V0WzZdID0gMDtcbiAgICBvdXRbN10gPSAwO1xuICAgIG91dFs4XSA9IDA7XG4gICAgb3V0WzldID0gMDtcbiAgICBvdXRbMTBdID0gKGZhciArIG5lYXIpICogbmY7XG4gICAgb3V0WzExXSA9IC0xO1xuICAgIG91dFsxMl0gPSAwO1xuICAgIG91dFsxM10gPSAwO1xuICAgIG91dFsxNF0gPSAoMiAqIGZhciAqIG5lYXIpICogbmY7XG4gICAgb3V0WzE1XSA9IDA7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogR2VuZXJhdGVzIGEgcGVyc3BlY3RpdmUgcHJvamVjdGlvbiBtYXRyaXggd2l0aCB0aGUgZ2l2ZW4gZmllbGQgb2Ygdmlldy5cbiAqIFRoaXMgaXMgcHJpbWFyaWx5IHVzZWZ1bCBmb3IgZ2VuZXJhdGluZyBwcm9qZWN0aW9uIG1hdHJpY2VzIHRvIGJlIHVzZWRcbiAqIHdpdGggdGhlIHN0aWxsIGV4cGVyaWVtZW50YWwgV2ViVlIgQVBJLlxuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IG1hdDQgZnJ1c3R1bSBtYXRyaXggd2lsbCBiZSB3cml0dGVuIGludG9cbiAqIEBwYXJhbSB7T2JqZWN0fSBmb3YgT2JqZWN0IGNvbnRhaW5pbmcgdGhlIGZvbGxvd2luZyB2YWx1ZXM6IHVwRGVncmVlcywgZG93bkRlZ3JlZXMsIGxlZnREZWdyZWVzLCByaWdodERlZ3JlZXNcbiAqIEBwYXJhbSB7bnVtYmVyfSBuZWFyIE5lYXIgYm91bmQgb2YgdGhlIGZydXN0dW1cbiAqIEBwYXJhbSB7bnVtYmVyfSBmYXIgRmFyIGJvdW5kIG9mIHRoZSBmcnVzdHVtXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbm1hdDQucGVyc3BlY3RpdmVGcm9tRmllbGRPZlZpZXcgPSBmdW5jdGlvbiAob3V0LCBmb3YsIG5lYXIsIGZhcikge1xuICAgIHZhciB1cFRhbiA9IE1hdGgudGFuKGZvdi51cERlZ3JlZXMgKiBNYXRoLlBJLzE4MC4wKSxcbiAgICAgICAgZG93blRhbiA9IE1hdGgudGFuKGZvdi5kb3duRGVncmVlcyAqIE1hdGguUEkvMTgwLjApLFxuICAgICAgICBsZWZ0VGFuID0gTWF0aC50YW4oZm92LmxlZnREZWdyZWVzICogTWF0aC5QSS8xODAuMCksXG4gICAgICAgIHJpZ2h0VGFuID0gTWF0aC50YW4oZm92LnJpZ2h0RGVncmVlcyAqIE1hdGguUEkvMTgwLjApLFxuICAgICAgICB4U2NhbGUgPSAyLjAgLyAobGVmdFRhbiArIHJpZ2h0VGFuKSxcbiAgICAgICAgeVNjYWxlID0gMi4wIC8gKHVwVGFuICsgZG93blRhbik7XG5cbiAgICBvdXRbMF0gPSB4U2NhbGU7XG4gICAgb3V0WzFdID0gMC4wO1xuICAgIG91dFsyXSA9IDAuMDtcbiAgICBvdXRbM10gPSAwLjA7XG4gICAgb3V0WzRdID0gMC4wO1xuICAgIG91dFs1XSA9IHlTY2FsZTtcbiAgICBvdXRbNl0gPSAwLjA7XG4gICAgb3V0WzddID0gMC4wO1xuICAgIG91dFs4XSA9IC0oKGxlZnRUYW4gLSByaWdodFRhbikgKiB4U2NhbGUgKiAwLjUpO1xuICAgIG91dFs5XSA9ICgodXBUYW4gLSBkb3duVGFuKSAqIHlTY2FsZSAqIDAuNSk7XG4gICAgb3V0WzEwXSA9IGZhciAvIChuZWFyIC0gZmFyKTtcbiAgICBvdXRbMTFdID0gLTEuMDtcbiAgICBvdXRbMTJdID0gMC4wO1xuICAgIG91dFsxM10gPSAwLjA7XG4gICAgb3V0WzE0XSA9IChmYXIgKiBuZWFyKSAvIChuZWFyIC0gZmFyKTtcbiAgICBvdXRbMTVdID0gMC4wO1xuICAgIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogR2VuZXJhdGVzIGEgb3J0aG9nb25hbCBwcm9qZWN0aW9uIG1hdHJpeCB3aXRoIHRoZSBnaXZlbiBib3VuZHNcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCBtYXQ0IGZydXN0dW0gbWF0cml4IHdpbGwgYmUgd3JpdHRlbiBpbnRvXG4gKiBAcGFyYW0ge251bWJlcn0gbGVmdCBMZWZ0IGJvdW5kIG9mIHRoZSBmcnVzdHVtXG4gKiBAcGFyYW0ge251bWJlcn0gcmlnaHQgUmlnaHQgYm91bmQgb2YgdGhlIGZydXN0dW1cbiAqIEBwYXJhbSB7bnVtYmVyfSBib3R0b20gQm90dG9tIGJvdW5kIG9mIHRoZSBmcnVzdHVtXG4gKiBAcGFyYW0ge251bWJlcn0gdG9wIFRvcCBib3VuZCBvZiB0aGUgZnJ1c3R1bVxuICogQHBhcmFtIHtudW1iZXJ9IG5lYXIgTmVhciBib3VuZCBvZiB0aGUgZnJ1c3R1bVxuICogQHBhcmFtIHtudW1iZXJ9IGZhciBGYXIgYm91bmQgb2YgdGhlIGZydXN0dW1cbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xubWF0NC5vcnRobyA9IGZ1bmN0aW9uIChvdXQsIGxlZnQsIHJpZ2h0LCBib3R0b20sIHRvcCwgbmVhciwgZmFyKSB7XG4gICAgdmFyIGxyID0gMSAvIChsZWZ0IC0gcmlnaHQpLFxuICAgICAgICBidCA9IDEgLyAoYm90dG9tIC0gdG9wKSxcbiAgICAgICAgbmYgPSAxIC8gKG5lYXIgLSBmYXIpO1xuICAgIG91dFswXSA9IC0yICogbHI7XG4gICAgb3V0WzFdID0gMDtcbiAgICBvdXRbMl0gPSAwO1xuICAgIG91dFszXSA9IDA7XG4gICAgb3V0WzRdID0gMDtcbiAgICBvdXRbNV0gPSAtMiAqIGJ0O1xuICAgIG91dFs2XSA9IDA7XG4gICAgb3V0WzddID0gMDtcbiAgICBvdXRbOF0gPSAwO1xuICAgIG91dFs5XSA9IDA7XG4gICAgb3V0WzEwXSA9IDIgKiBuZjtcbiAgICBvdXRbMTFdID0gMDtcbiAgICBvdXRbMTJdID0gKGxlZnQgKyByaWdodCkgKiBscjtcbiAgICBvdXRbMTNdID0gKHRvcCArIGJvdHRvbSkgKiBidDtcbiAgICBvdXRbMTRdID0gKGZhciArIG5lYXIpICogbmY7XG4gICAgb3V0WzE1XSA9IDE7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogR2VuZXJhdGVzIGEgbG9vay1hdCBtYXRyaXggd2l0aCB0aGUgZ2l2ZW4gZXllIHBvc2l0aW9uLCBmb2NhbCBwb2ludCwgYW5kIHVwIGF4aXNcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCBtYXQ0IGZydXN0dW0gbWF0cml4IHdpbGwgYmUgd3JpdHRlbiBpbnRvXG4gKiBAcGFyYW0ge3ZlYzN9IGV5ZSBQb3NpdGlvbiBvZiB0aGUgdmlld2VyXG4gKiBAcGFyYW0ge3ZlYzN9IGNlbnRlciBQb2ludCB0aGUgdmlld2VyIGlzIGxvb2tpbmcgYXRcbiAqIEBwYXJhbSB7dmVjM30gdXAgdmVjMyBwb2ludGluZyB1cFxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5tYXQ0Lmxvb2tBdCA9IGZ1bmN0aW9uIChvdXQsIGV5ZSwgY2VudGVyLCB1cCkge1xuICAgIHZhciB4MCwgeDEsIHgyLCB5MCwgeTEsIHkyLCB6MCwgejEsIHoyLCBsZW4sXG4gICAgICAgIGV5ZXggPSBleWVbMF0sXG4gICAgICAgIGV5ZXkgPSBleWVbMV0sXG4gICAgICAgIGV5ZXogPSBleWVbMl0sXG4gICAgICAgIHVweCA9IHVwWzBdLFxuICAgICAgICB1cHkgPSB1cFsxXSxcbiAgICAgICAgdXB6ID0gdXBbMl0sXG4gICAgICAgIGNlbnRlcnggPSBjZW50ZXJbMF0sXG4gICAgICAgIGNlbnRlcnkgPSBjZW50ZXJbMV0sXG4gICAgICAgIGNlbnRlcnogPSBjZW50ZXJbMl07XG5cbiAgICBpZiAoTWF0aC5hYnMoZXlleCAtIGNlbnRlcngpIDwgZ2xNYXRyaXguRVBTSUxPTiAmJlxuICAgICAgICBNYXRoLmFicyhleWV5IC0gY2VudGVyeSkgPCBnbE1hdHJpeC5FUFNJTE9OICYmXG4gICAgICAgIE1hdGguYWJzKGV5ZXogLSBjZW50ZXJ6KSA8IGdsTWF0cml4LkVQU0lMT04pIHtcbiAgICAgICAgcmV0dXJuIG1hdDQuaWRlbnRpdHkob3V0KTtcbiAgICB9XG5cbiAgICB6MCA9IGV5ZXggLSBjZW50ZXJ4O1xuICAgIHoxID0gZXlleSAtIGNlbnRlcnk7XG4gICAgejIgPSBleWV6IC0gY2VudGVyejtcblxuICAgIGxlbiA9IDEgLyBNYXRoLnNxcnQoejAgKiB6MCArIHoxICogejEgKyB6MiAqIHoyKTtcbiAgICB6MCAqPSBsZW47XG4gICAgejEgKj0gbGVuO1xuICAgIHoyICo9IGxlbjtcblxuICAgIHgwID0gdXB5ICogejIgLSB1cHogKiB6MTtcbiAgICB4MSA9IHVweiAqIHowIC0gdXB4ICogejI7XG4gICAgeDIgPSB1cHggKiB6MSAtIHVweSAqIHowO1xuICAgIGxlbiA9IE1hdGguc3FydCh4MCAqIHgwICsgeDEgKiB4MSArIHgyICogeDIpO1xuICAgIGlmICghbGVuKSB7XG4gICAgICAgIHgwID0gMDtcbiAgICAgICAgeDEgPSAwO1xuICAgICAgICB4MiA9IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgbGVuID0gMSAvIGxlbjtcbiAgICAgICAgeDAgKj0gbGVuO1xuICAgICAgICB4MSAqPSBsZW47XG4gICAgICAgIHgyICo9IGxlbjtcbiAgICB9XG5cbiAgICB5MCA9IHoxICogeDIgLSB6MiAqIHgxO1xuICAgIHkxID0gejIgKiB4MCAtIHowICogeDI7XG4gICAgeTIgPSB6MCAqIHgxIC0gejEgKiB4MDtcblxuICAgIGxlbiA9IE1hdGguc3FydCh5MCAqIHkwICsgeTEgKiB5MSArIHkyICogeTIpO1xuICAgIGlmICghbGVuKSB7XG4gICAgICAgIHkwID0gMDtcbiAgICAgICAgeTEgPSAwO1xuICAgICAgICB5MiA9IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgbGVuID0gMSAvIGxlbjtcbiAgICAgICAgeTAgKj0gbGVuO1xuICAgICAgICB5MSAqPSBsZW47XG4gICAgICAgIHkyICo9IGxlbjtcbiAgICB9XG5cbiAgICBvdXRbMF0gPSB4MDtcbiAgICBvdXRbMV0gPSB5MDtcbiAgICBvdXRbMl0gPSB6MDtcbiAgICBvdXRbM10gPSAwO1xuICAgIG91dFs0XSA9IHgxO1xuICAgIG91dFs1XSA9IHkxO1xuICAgIG91dFs2XSA9IHoxO1xuICAgIG91dFs3XSA9IDA7XG4gICAgb3V0WzhdID0geDI7XG4gICAgb3V0WzldID0geTI7XG4gICAgb3V0WzEwXSA9IHoyO1xuICAgIG91dFsxMV0gPSAwO1xuICAgIG91dFsxMl0gPSAtKHgwICogZXlleCArIHgxICogZXlleSArIHgyICogZXlleik7XG4gICAgb3V0WzEzXSA9IC0oeTAgKiBleWV4ICsgeTEgKiBleWV5ICsgeTIgKiBleWV6KTtcbiAgICBvdXRbMTRdID0gLSh6MCAqIGV5ZXggKyB6MSAqIGV5ZXkgKyB6MiAqIGV5ZXopO1xuICAgIG91dFsxNV0gPSAxO1xuXG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhIG1hdDRcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG1hdCBtYXRyaXggdG8gcmVwcmVzZW50IGFzIGEgc3RyaW5nXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIG1hdHJpeFxuICovXG5tYXQ0LnN0ciA9IGZ1bmN0aW9uIChhKSB7XG4gICAgcmV0dXJuICdtYXQ0KCcgKyBhWzBdICsgJywgJyArIGFbMV0gKyAnLCAnICsgYVsyXSArICcsICcgKyBhWzNdICsgJywgJyArXG4gICAgICAgICAgICAgICAgICAgIGFbNF0gKyAnLCAnICsgYVs1XSArICcsICcgKyBhWzZdICsgJywgJyArIGFbN10gKyAnLCAnICtcbiAgICAgICAgICAgICAgICAgICAgYVs4XSArICcsICcgKyBhWzldICsgJywgJyArIGFbMTBdICsgJywgJyArIGFbMTFdICsgJywgJyArXG4gICAgICAgICAgICAgICAgICAgIGFbMTJdICsgJywgJyArIGFbMTNdICsgJywgJyArIGFbMTRdICsgJywgJyArIGFbMTVdICsgJyknO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIEZyb2Jlbml1cyBub3JtIG9mIGEgbWF0NFxuICpcbiAqIEBwYXJhbSB7bWF0NH0gYSB0aGUgbWF0cml4IHRvIGNhbGN1bGF0ZSBGcm9iZW5pdXMgbm9ybSBvZlxuICogQHJldHVybnMge051bWJlcn0gRnJvYmVuaXVzIG5vcm1cbiAqL1xubWF0NC5mcm9iID0gZnVuY3Rpb24gKGEpIHtcbiAgICByZXR1cm4oTWF0aC5zcXJ0KE1hdGgucG93KGFbMF0sIDIpICsgTWF0aC5wb3coYVsxXSwgMikgKyBNYXRoLnBvdyhhWzJdLCAyKSArIE1hdGgucG93KGFbM10sIDIpICsgTWF0aC5wb3coYVs0XSwgMikgKyBNYXRoLnBvdyhhWzVdLCAyKSArIE1hdGgucG93KGFbNl0sIDIpICsgTWF0aC5wb3coYVs3XSwgMikgKyBNYXRoLnBvdyhhWzhdLCAyKSArIE1hdGgucG93KGFbOV0sIDIpICsgTWF0aC5wb3coYVsxMF0sIDIpICsgTWF0aC5wb3coYVsxMV0sIDIpICsgTWF0aC5wb3coYVsxMl0sIDIpICsgTWF0aC5wb3coYVsxM10sIDIpICsgTWF0aC5wb3coYVsxNF0sIDIpICsgTWF0aC5wb3coYVsxNV0sIDIpICkpXG59O1xuXG4vKipcbiAqIEFkZHMgdHdvIG1hdDQnc1xuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7bWF0NH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xubWF0NC5hZGQgPSBmdW5jdGlvbihvdXQsIGEsIGIpIHtcbiAgICBvdXRbMF0gPSBhWzBdICsgYlswXTtcbiAgICBvdXRbMV0gPSBhWzFdICsgYlsxXTtcbiAgICBvdXRbMl0gPSBhWzJdICsgYlsyXTtcbiAgICBvdXRbM10gPSBhWzNdICsgYlszXTtcbiAgICBvdXRbNF0gPSBhWzRdICsgYls0XTtcbiAgICBvdXRbNV0gPSBhWzVdICsgYls1XTtcbiAgICBvdXRbNl0gPSBhWzZdICsgYls2XTtcbiAgICBvdXRbN10gPSBhWzddICsgYls3XTtcbiAgICBvdXRbOF0gPSBhWzhdICsgYls4XTtcbiAgICBvdXRbOV0gPSBhWzldICsgYls5XTtcbiAgICBvdXRbMTBdID0gYVsxMF0gKyBiWzEwXTtcbiAgICBvdXRbMTFdID0gYVsxMV0gKyBiWzExXTtcbiAgICBvdXRbMTJdID0gYVsxMl0gKyBiWzEyXTtcbiAgICBvdXRbMTNdID0gYVsxM10gKyBiWzEzXTtcbiAgICBvdXRbMTRdID0gYVsxNF0gKyBiWzE0XTtcbiAgICBvdXRbMTVdID0gYVsxNV0gKyBiWzE1XTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBTdWJ0cmFjdHMgbWF0cml4IGIgZnJvbSBtYXRyaXggYVxuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7bWF0NH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xubWF0NC5zdWJ0cmFjdCA9IGZ1bmN0aW9uKG91dCwgYSwgYikge1xuICAgIG91dFswXSA9IGFbMF0gLSBiWzBdO1xuICAgIG91dFsxXSA9IGFbMV0gLSBiWzFdO1xuICAgIG91dFsyXSA9IGFbMl0gLSBiWzJdO1xuICAgIG91dFszXSA9IGFbM10gLSBiWzNdO1xuICAgIG91dFs0XSA9IGFbNF0gLSBiWzRdO1xuICAgIG91dFs1XSA9IGFbNV0gLSBiWzVdO1xuICAgIG91dFs2XSA9IGFbNl0gLSBiWzZdO1xuICAgIG91dFs3XSA9IGFbN10gLSBiWzddO1xuICAgIG91dFs4XSA9IGFbOF0gLSBiWzhdO1xuICAgIG91dFs5XSA9IGFbOV0gLSBiWzldO1xuICAgIG91dFsxMF0gPSBhWzEwXSAtIGJbMTBdO1xuICAgIG91dFsxMV0gPSBhWzExXSAtIGJbMTFdO1xuICAgIG91dFsxMl0gPSBhWzEyXSAtIGJbMTJdO1xuICAgIG91dFsxM10gPSBhWzEzXSAtIGJbMTNdO1xuICAgIG91dFsxNF0gPSBhWzE0XSAtIGJbMTRdO1xuICAgIG91dFsxNV0gPSBhWzE1XSAtIGJbMTVdO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgbWF0NC5zdWJ0cmFjdH1cbiAqIEBmdW5jdGlvblxuICovXG5tYXQ0LnN1YiA9IG1hdDQuc3VidHJhY3Q7XG5cbi8qKlxuICogTXVsdGlwbHkgZWFjaCBlbGVtZW50IG9mIHRoZSBtYXRyaXggYnkgYSBzY2FsYXIuXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0NH0gYSB0aGUgbWF0cml4IHRvIHNjYWxlXG4gKiBAcGFyYW0ge051bWJlcn0gYiBhbW91bnQgdG8gc2NhbGUgdGhlIG1hdHJpeCdzIGVsZW1lbnRzIGJ5XG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbm1hdDQubXVsdGlwbHlTY2FsYXIgPSBmdW5jdGlvbihvdXQsIGEsIGIpIHtcbiAgICBvdXRbMF0gPSBhWzBdICogYjtcbiAgICBvdXRbMV0gPSBhWzFdICogYjtcbiAgICBvdXRbMl0gPSBhWzJdICogYjtcbiAgICBvdXRbM10gPSBhWzNdICogYjtcbiAgICBvdXRbNF0gPSBhWzRdICogYjtcbiAgICBvdXRbNV0gPSBhWzVdICogYjtcbiAgICBvdXRbNl0gPSBhWzZdICogYjtcbiAgICBvdXRbN10gPSBhWzddICogYjtcbiAgICBvdXRbOF0gPSBhWzhdICogYjtcbiAgICBvdXRbOV0gPSBhWzldICogYjtcbiAgICBvdXRbMTBdID0gYVsxMF0gKiBiO1xuICAgIG91dFsxMV0gPSBhWzExXSAqIGI7XG4gICAgb3V0WzEyXSA9IGFbMTJdICogYjtcbiAgICBvdXRbMTNdID0gYVsxM10gKiBiO1xuICAgIG91dFsxNF0gPSBhWzE0XSAqIGI7XG4gICAgb3V0WzE1XSA9IGFbMTVdICogYjtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBBZGRzIHR3byBtYXQ0J3MgYWZ0ZXIgbXVsdGlwbHlpbmcgZWFjaCBlbGVtZW50IG9mIHRoZSBzZWNvbmQgb3BlcmFuZCBieSBhIHNjYWxhciB2YWx1ZS5cbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHttYXQ0fSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge21hdDR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcGFyYW0ge051bWJlcn0gc2NhbGUgdGhlIGFtb3VudCB0byBzY2FsZSBiJ3MgZWxlbWVudHMgYnkgYmVmb3JlIGFkZGluZ1xuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5tYXQ0Lm11bHRpcGx5U2NhbGFyQW5kQWRkID0gZnVuY3Rpb24ob3V0LCBhLCBiLCBzY2FsZSkge1xuICAgIG91dFswXSA9IGFbMF0gKyAoYlswXSAqIHNjYWxlKTtcbiAgICBvdXRbMV0gPSBhWzFdICsgKGJbMV0gKiBzY2FsZSk7XG4gICAgb3V0WzJdID0gYVsyXSArIChiWzJdICogc2NhbGUpO1xuICAgIG91dFszXSA9IGFbM10gKyAoYlszXSAqIHNjYWxlKTtcbiAgICBvdXRbNF0gPSBhWzRdICsgKGJbNF0gKiBzY2FsZSk7XG4gICAgb3V0WzVdID0gYVs1XSArIChiWzVdICogc2NhbGUpO1xuICAgIG91dFs2XSA9IGFbNl0gKyAoYls2XSAqIHNjYWxlKTtcbiAgICBvdXRbN10gPSBhWzddICsgKGJbN10gKiBzY2FsZSk7XG4gICAgb3V0WzhdID0gYVs4XSArIChiWzhdICogc2NhbGUpO1xuICAgIG91dFs5XSA9IGFbOV0gKyAoYls5XSAqIHNjYWxlKTtcbiAgICBvdXRbMTBdID0gYVsxMF0gKyAoYlsxMF0gKiBzY2FsZSk7XG4gICAgb3V0WzExXSA9IGFbMTFdICsgKGJbMTFdICogc2NhbGUpO1xuICAgIG91dFsxMl0gPSBhWzEyXSArIChiWzEyXSAqIHNjYWxlKTtcbiAgICBvdXRbMTNdID0gYVsxM10gKyAoYlsxM10gKiBzY2FsZSk7XG4gICAgb3V0WzE0XSA9IGFbMTRdICsgKGJbMTRdICogc2NhbGUpO1xuICAgIG91dFsxNV0gPSBhWzE1XSArIChiWzE1XSAqIHNjYWxlKTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSBtYXRyaWNlcyBoYXZlIGV4YWN0bHkgdGhlIHNhbWUgZWxlbWVudHMgaW4gdGhlIHNhbWUgcG9zaXRpb24gKHdoZW4gY29tcGFyZWQgd2l0aCA9PT0pXG4gKlxuICogQHBhcmFtIHttYXQ0fSBhIFRoZSBmaXJzdCBtYXRyaXguXG4gKiBAcGFyYW0ge21hdDR9IGIgVGhlIHNlY29uZCBtYXRyaXguXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gVHJ1ZSBpZiB0aGUgbWF0cmljZXMgYXJlIGVxdWFsLCBmYWxzZSBvdGhlcndpc2UuXG4gKi9cbm1hdDQuZXhhY3RFcXVhbHMgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgIHJldHVybiBhWzBdID09PSBiWzBdICYmIGFbMV0gPT09IGJbMV0gJiYgYVsyXSA9PT0gYlsyXSAmJiBhWzNdID09PSBiWzNdICYmIFxuICAgICAgICAgICBhWzRdID09PSBiWzRdICYmIGFbNV0gPT09IGJbNV0gJiYgYVs2XSA9PT0gYls2XSAmJiBhWzddID09PSBiWzddICYmIFxuICAgICAgICAgICBhWzhdID09PSBiWzhdICYmIGFbOV0gPT09IGJbOV0gJiYgYVsxMF0gPT09IGJbMTBdICYmIGFbMTFdID09PSBiWzExXSAmJlxuICAgICAgICAgICBhWzEyXSA9PT0gYlsxMl0gJiYgYVsxM10gPT09IGJbMTNdICYmIGFbMTRdID09PSBiWzE0XSAmJiBhWzE1XSA9PT0gYlsxNV07XG59O1xuXG4vKipcbiAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIG1hdHJpY2VzIGhhdmUgYXBwcm94aW1hdGVseSB0aGUgc2FtZSBlbGVtZW50cyBpbiB0aGUgc2FtZSBwb3NpdGlvbi5cbiAqXG4gKiBAcGFyYW0ge21hdDR9IGEgVGhlIGZpcnN0IG1hdHJpeC5cbiAqIEBwYXJhbSB7bWF0NH0gYiBUaGUgc2Vjb25kIG1hdHJpeC5cbiAqIEByZXR1cm5zIHtCb29sZWFufSBUcnVlIGlmIHRoZSBtYXRyaWNlcyBhcmUgZXF1YWwsIGZhbHNlIG90aGVyd2lzZS5cbiAqL1xubWF0NC5lcXVhbHMgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgIHZhciBhMCAgPSBhWzBdLCAgYTEgID0gYVsxXSwgIGEyICA9IGFbMl0sICBhMyAgPSBhWzNdLFxuICAgICAgICBhNCAgPSBhWzRdLCAgYTUgID0gYVs1XSwgIGE2ICA9IGFbNl0sICBhNyAgPSBhWzddLCBcbiAgICAgICAgYTggID0gYVs4XSwgIGE5ICA9IGFbOV0sICBhMTAgPSBhWzEwXSwgYTExID0gYVsxMV0sIFxuICAgICAgICBhMTIgPSBhWzEyXSwgYTEzID0gYVsxM10sIGExNCA9IGFbMTRdLCBhMTUgPSBhWzE1XTtcblxuICAgIHZhciBiMCAgPSBiWzBdLCAgYjEgID0gYlsxXSwgIGIyICA9IGJbMl0sICBiMyAgPSBiWzNdLFxuICAgICAgICBiNCAgPSBiWzRdLCAgYjUgID0gYls1XSwgIGI2ICA9IGJbNl0sICBiNyAgPSBiWzddLCBcbiAgICAgICAgYjggID0gYls4XSwgIGI5ICA9IGJbOV0sICBiMTAgPSBiWzEwXSwgYjExID0gYlsxMV0sIFxuICAgICAgICBiMTIgPSBiWzEyXSwgYjEzID0gYlsxM10sIGIxNCA9IGJbMTRdLCBiMTUgPSBiWzE1XTtcblxuICAgIHJldHVybiAoTWF0aC5hYnMoYTAgLSBiMCkgPD0gZ2xNYXRyaXguRVBTSUxPTipNYXRoLm1heCgxLjAsIE1hdGguYWJzKGEwKSwgTWF0aC5hYnMoYjApKSAmJlxuICAgICAgICAgICAgTWF0aC5hYnMoYTEgLSBiMSkgPD0gZ2xNYXRyaXguRVBTSUxPTipNYXRoLm1heCgxLjAsIE1hdGguYWJzKGExKSwgTWF0aC5hYnMoYjEpKSAmJlxuICAgICAgICAgICAgTWF0aC5hYnMoYTIgLSBiMikgPD0gZ2xNYXRyaXguRVBTSUxPTipNYXRoLm1heCgxLjAsIE1hdGguYWJzKGEyKSwgTWF0aC5hYnMoYjIpKSAmJlxuICAgICAgICAgICAgTWF0aC5hYnMoYTMgLSBiMykgPD0gZ2xNYXRyaXguRVBTSUxPTipNYXRoLm1heCgxLjAsIE1hdGguYWJzKGEzKSwgTWF0aC5hYnMoYjMpKSAmJlxuICAgICAgICAgICAgTWF0aC5hYnMoYTQgLSBiNCkgPD0gZ2xNYXRyaXguRVBTSUxPTipNYXRoLm1heCgxLjAsIE1hdGguYWJzKGE0KSwgTWF0aC5hYnMoYjQpKSAmJlxuICAgICAgICAgICAgTWF0aC5hYnMoYTUgLSBiNSkgPD0gZ2xNYXRyaXguRVBTSUxPTipNYXRoLm1heCgxLjAsIE1hdGguYWJzKGE1KSwgTWF0aC5hYnMoYjUpKSAmJlxuICAgICAgICAgICAgTWF0aC5hYnMoYTYgLSBiNikgPD0gZ2xNYXRyaXguRVBTSUxPTipNYXRoLm1heCgxLjAsIE1hdGguYWJzKGE2KSwgTWF0aC5hYnMoYjYpKSAmJlxuICAgICAgICAgICAgTWF0aC5hYnMoYTcgLSBiNykgPD0gZ2xNYXRyaXguRVBTSUxPTipNYXRoLm1heCgxLjAsIE1hdGguYWJzKGE3KSwgTWF0aC5hYnMoYjcpKSAmJlxuICAgICAgICAgICAgTWF0aC5hYnMoYTggLSBiOCkgPD0gZ2xNYXRyaXguRVBTSUxPTipNYXRoLm1heCgxLjAsIE1hdGguYWJzKGE4KSwgTWF0aC5hYnMoYjgpKSAmJlxuICAgICAgICAgICAgTWF0aC5hYnMoYTkgLSBiOSkgPD0gZ2xNYXRyaXguRVBTSUxPTipNYXRoLm1heCgxLjAsIE1hdGguYWJzKGE5KSwgTWF0aC5hYnMoYjkpKSAmJlxuICAgICAgICAgICAgTWF0aC5hYnMoYTEwIC0gYjEwKSA8PSBnbE1hdHJpeC5FUFNJTE9OKk1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTEwKSwgTWF0aC5hYnMoYjEwKSkgJiZcbiAgICAgICAgICAgIE1hdGguYWJzKGExMSAtIGIxMSkgPD0gZ2xNYXRyaXguRVBTSUxPTipNYXRoLm1heCgxLjAsIE1hdGguYWJzKGExMSksIE1hdGguYWJzKGIxMSkpICYmXG4gICAgICAgICAgICBNYXRoLmFicyhhMTIgLSBiMTIpIDw9IGdsTWF0cml4LkVQU0lMT04qTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMTIpLCBNYXRoLmFicyhiMTIpKSAmJlxuICAgICAgICAgICAgTWF0aC5hYnMoYTEzIC0gYjEzKSA8PSBnbE1hdHJpeC5FUFNJTE9OKk1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTEzKSwgTWF0aC5hYnMoYjEzKSkgJiZcbiAgICAgICAgICAgIE1hdGguYWJzKGExNCAtIGIxNCkgPD0gZ2xNYXRyaXguRVBTSUxPTipNYXRoLm1heCgxLjAsIE1hdGguYWJzKGExNCksIE1hdGguYWJzKGIxNCkpICYmXG4gICAgICAgICAgICBNYXRoLmFicyhhMTUgLSBiMTUpIDw9IGdsTWF0cml4LkVQU0lMT04qTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMTUpLCBNYXRoLmFicyhiMTUpKSk7XG59O1xuXG5cblxubW9kdWxlLmV4cG9ydHMgPSBtYXQ0O1xuIiwiLyogQ29weXJpZ2h0IChjKSAyMDE1LCBCcmFuZG9uIEpvbmVzLCBDb2xpbiBNYWNLZW56aWUgSVYuXG5cblBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbm9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbmluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbnRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbmNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblxuVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbmFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG5JTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbkZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbk9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cblRIRSBTT0ZUV0FSRS4gKi9cblxudmFyIGdsTWF0cml4ID0gcmVxdWlyZShcIi4vY29tbW9uLmpzXCIpO1xudmFyIG1hdDMgPSByZXF1aXJlKFwiLi9tYXQzLmpzXCIpO1xudmFyIHZlYzMgPSByZXF1aXJlKFwiLi92ZWMzLmpzXCIpO1xudmFyIHZlYzQgPSByZXF1aXJlKFwiLi92ZWM0LmpzXCIpO1xuXG4vKipcbiAqIEBjbGFzcyBRdWF0ZXJuaW9uXG4gKiBAbmFtZSBxdWF0XG4gKi9cbnZhciBxdWF0ID0ge307XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBpZGVudGl0eSBxdWF0XG4gKlxuICogQHJldHVybnMge3F1YXR9IGEgbmV3IHF1YXRlcm5pb25cbiAqL1xucXVhdC5jcmVhdGUgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgb3V0ID0gbmV3IGdsTWF0cml4LkFSUkFZX1RZUEUoNCk7XG4gICAgb3V0WzBdID0gMDtcbiAgICBvdXRbMV0gPSAwO1xuICAgIG91dFsyXSA9IDA7XG4gICAgb3V0WzNdID0gMTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBTZXRzIGEgcXVhdGVybmlvbiB0byByZXByZXNlbnQgdGhlIHNob3J0ZXN0IHJvdGF0aW9uIGZyb20gb25lXG4gKiB2ZWN0b3IgdG8gYW5vdGhlci5cbiAqXG4gKiBCb3RoIHZlY3RvcnMgYXJlIGFzc3VtZWQgdG8gYmUgdW5pdCBsZW5ndGguXG4gKlxuICogQHBhcmFtIHtxdWF0fSBvdXQgdGhlIHJlY2VpdmluZyBxdWF0ZXJuaW9uLlxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSBpbml0aWFsIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBiIHRoZSBkZXN0aW5hdGlvbiB2ZWN0b3JcbiAqIEByZXR1cm5zIHtxdWF0fSBvdXRcbiAqL1xucXVhdC5yb3RhdGlvblRvID0gKGZ1bmN0aW9uKCkge1xuICAgIHZhciB0bXB2ZWMzID0gdmVjMy5jcmVhdGUoKTtcbiAgICB2YXIgeFVuaXRWZWMzID0gdmVjMy5mcm9tVmFsdWVzKDEsMCwwKTtcbiAgICB2YXIgeVVuaXRWZWMzID0gdmVjMy5mcm9tVmFsdWVzKDAsMSwwKTtcblxuICAgIHJldHVybiBmdW5jdGlvbihvdXQsIGEsIGIpIHtcbiAgICAgICAgdmFyIGRvdCA9IHZlYzMuZG90KGEsIGIpO1xuICAgICAgICBpZiAoZG90IDwgLTAuOTk5OTk5KSB7XG4gICAgICAgICAgICB2ZWMzLmNyb3NzKHRtcHZlYzMsIHhVbml0VmVjMywgYSk7XG4gICAgICAgICAgICBpZiAodmVjMy5sZW5ndGgodG1wdmVjMykgPCAwLjAwMDAwMSlcbiAgICAgICAgICAgICAgICB2ZWMzLmNyb3NzKHRtcHZlYzMsIHlVbml0VmVjMywgYSk7XG4gICAgICAgICAgICB2ZWMzLm5vcm1hbGl6ZSh0bXB2ZWMzLCB0bXB2ZWMzKTtcbiAgICAgICAgICAgIHF1YXQuc2V0QXhpc0FuZ2xlKG91dCwgdG1wdmVjMywgTWF0aC5QSSk7XG4gICAgICAgICAgICByZXR1cm4gb3V0O1xuICAgICAgICB9IGVsc2UgaWYgKGRvdCA+IDAuOTk5OTk5KSB7XG4gICAgICAgICAgICBvdXRbMF0gPSAwO1xuICAgICAgICAgICAgb3V0WzFdID0gMDtcbiAgICAgICAgICAgIG91dFsyXSA9IDA7XG4gICAgICAgICAgICBvdXRbM10gPSAxO1xuICAgICAgICAgICAgcmV0dXJuIG91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZlYzMuY3Jvc3ModG1wdmVjMywgYSwgYik7XG4gICAgICAgICAgICBvdXRbMF0gPSB0bXB2ZWMzWzBdO1xuICAgICAgICAgICAgb3V0WzFdID0gdG1wdmVjM1sxXTtcbiAgICAgICAgICAgIG91dFsyXSA9IHRtcHZlYzNbMl07XG4gICAgICAgICAgICBvdXRbM10gPSAxICsgZG90O1xuICAgICAgICAgICAgcmV0dXJuIHF1YXQubm9ybWFsaXplKG91dCwgb3V0KTtcbiAgICAgICAgfVxuICAgIH07XG59KSgpO1xuXG4vKipcbiAqIFNldHMgdGhlIHNwZWNpZmllZCBxdWF0ZXJuaW9uIHdpdGggdmFsdWVzIGNvcnJlc3BvbmRpbmcgdG8gdGhlIGdpdmVuXG4gKiBheGVzLiBFYWNoIGF4aXMgaXMgYSB2ZWMzIGFuZCBpcyBleHBlY3RlZCB0byBiZSB1bml0IGxlbmd0aCBhbmRcbiAqIHBlcnBlbmRpY3VsYXIgdG8gYWxsIG90aGVyIHNwZWNpZmllZCBheGVzLlxuICpcbiAqIEBwYXJhbSB7dmVjM30gdmlldyAgdGhlIHZlY3RvciByZXByZXNlbnRpbmcgdGhlIHZpZXdpbmcgZGlyZWN0aW9uXG4gKiBAcGFyYW0ge3ZlYzN9IHJpZ2h0IHRoZSB2ZWN0b3IgcmVwcmVzZW50aW5nIHRoZSBsb2NhbCBcInJpZ2h0XCIgZGlyZWN0aW9uXG4gKiBAcGFyYW0ge3ZlYzN9IHVwICAgIHRoZSB2ZWN0b3IgcmVwcmVzZW50aW5nIHRoZSBsb2NhbCBcInVwXCIgZGlyZWN0aW9uXG4gKiBAcmV0dXJucyB7cXVhdH0gb3V0XG4gKi9cbnF1YXQuc2V0QXhlcyA9IChmdW5jdGlvbigpIHtcbiAgICB2YXIgbWF0ciA9IG1hdDMuY3JlYXRlKCk7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24ob3V0LCB2aWV3LCByaWdodCwgdXApIHtcbiAgICAgICAgbWF0clswXSA9IHJpZ2h0WzBdO1xuICAgICAgICBtYXRyWzNdID0gcmlnaHRbMV07XG4gICAgICAgIG1hdHJbNl0gPSByaWdodFsyXTtcblxuICAgICAgICBtYXRyWzFdID0gdXBbMF07XG4gICAgICAgIG1hdHJbNF0gPSB1cFsxXTtcbiAgICAgICAgbWF0cls3XSA9IHVwWzJdO1xuXG4gICAgICAgIG1hdHJbMl0gPSAtdmlld1swXTtcbiAgICAgICAgbWF0cls1XSA9IC12aWV3WzFdO1xuICAgICAgICBtYXRyWzhdID0gLXZpZXdbMl07XG5cbiAgICAgICAgcmV0dXJuIHF1YXQubm9ybWFsaXplKG91dCwgcXVhdC5mcm9tTWF0MyhvdXQsIG1hdHIpKTtcbiAgICB9O1xufSkoKTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IHF1YXQgaW5pdGlhbGl6ZWQgd2l0aCB2YWx1ZXMgZnJvbSBhbiBleGlzdGluZyBxdWF0ZXJuaW9uXG4gKlxuICogQHBhcmFtIHtxdWF0fSBhIHF1YXRlcm5pb24gdG8gY2xvbmVcbiAqIEByZXR1cm5zIHtxdWF0fSBhIG5ldyBxdWF0ZXJuaW9uXG4gKiBAZnVuY3Rpb25cbiAqL1xucXVhdC5jbG9uZSA9IHZlYzQuY2xvbmU7XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBxdWF0IGluaXRpYWxpemVkIHdpdGggdGhlIGdpdmVuIHZhbHVlc1xuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSB4IFggY29tcG9uZW50XG4gKiBAcGFyYW0ge051bWJlcn0geSBZIGNvbXBvbmVudFxuICogQHBhcmFtIHtOdW1iZXJ9IHogWiBjb21wb25lbnRcbiAqIEBwYXJhbSB7TnVtYmVyfSB3IFcgY29tcG9uZW50XG4gKiBAcmV0dXJucyB7cXVhdH0gYSBuZXcgcXVhdGVybmlvblxuICogQGZ1bmN0aW9uXG4gKi9cbnF1YXQuZnJvbVZhbHVlcyA9IHZlYzQuZnJvbVZhbHVlcztcblxuLyoqXG4gKiBDb3B5IHRoZSB2YWx1ZXMgZnJvbSBvbmUgcXVhdCB0byBhbm90aGVyXG4gKlxuICogQHBhcmFtIHtxdWF0fSBvdXQgdGhlIHJlY2VpdmluZyBxdWF0ZXJuaW9uXG4gKiBAcGFyYW0ge3F1YXR9IGEgdGhlIHNvdXJjZSBxdWF0ZXJuaW9uXG4gKiBAcmV0dXJucyB7cXVhdH0gb3V0XG4gKiBAZnVuY3Rpb25cbiAqL1xucXVhdC5jb3B5ID0gdmVjNC5jb3B5O1xuXG4vKipcbiAqIFNldCB0aGUgY29tcG9uZW50cyBvZiBhIHF1YXQgdG8gdGhlIGdpdmVuIHZhbHVlc1xuICpcbiAqIEBwYXJhbSB7cXVhdH0gb3V0IHRoZSByZWNlaXZpbmcgcXVhdGVybmlvblxuICogQHBhcmFtIHtOdW1iZXJ9IHggWCBjb21wb25lbnRcbiAqIEBwYXJhbSB7TnVtYmVyfSB5IFkgY29tcG9uZW50XG4gKiBAcGFyYW0ge051bWJlcn0geiBaIGNvbXBvbmVudFxuICogQHBhcmFtIHtOdW1iZXJ9IHcgVyBjb21wb25lbnRcbiAqIEByZXR1cm5zIHtxdWF0fSBvdXRcbiAqIEBmdW5jdGlvblxuICovXG5xdWF0LnNldCA9IHZlYzQuc2V0O1xuXG4vKipcbiAqIFNldCBhIHF1YXQgdG8gdGhlIGlkZW50aXR5IHF1YXRlcm5pb25cbiAqXG4gKiBAcGFyYW0ge3F1YXR9IG91dCB0aGUgcmVjZWl2aW5nIHF1YXRlcm5pb25cbiAqIEByZXR1cm5zIHtxdWF0fSBvdXRcbiAqL1xucXVhdC5pZGVudGl0eSA9IGZ1bmN0aW9uKG91dCkge1xuICAgIG91dFswXSA9IDA7XG4gICAgb3V0WzFdID0gMDtcbiAgICBvdXRbMl0gPSAwO1xuICAgIG91dFszXSA9IDE7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogU2V0cyBhIHF1YXQgZnJvbSB0aGUgZ2l2ZW4gYW5nbGUgYW5kIHJvdGF0aW9uIGF4aXMsXG4gKiB0aGVuIHJldHVybnMgaXQuXG4gKlxuICogQHBhcmFtIHtxdWF0fSBvdXQgdGhlIHJlY2VpdmluZyBxdWF0ZXJuaW9uXG4gKiBAcGFyYW0ge3ZlYzN9IGF4aXMgdGhlIGF4aXMgYXJvdW5kIHdoaWNoIHRvIHJvdGF0ZVxuICogQHBhcmFtIHtOdW1iZXJ9IHJhZCB0aGUgYW5nbGUgaW4gcmFkaWFuc1xuICogQHJldHVybnMge3F1YXR9IG91dFxuICoqL1xucXVhdC5zZXRBeGlzQW5nbGUgPSBmdW5jdGlvbihvdXQsIGF4aXMsIHJhZCkge1xuICAgIHJhZCA9IHJhZCAqIDAuNTtcbiAgICB2YXIgcyA9IE1hdGguc2luKHJhZCk7XG4gICAgb3V0WzBdID0gcyAqIGF4aXNbMF07XG4gICAgb3V0WzFdID0gcyAqIGF4aXNbMV07XG4gICAgb3V0WzJdID0gcyAqIGF4aXNbMl07XG4gICAgb3V0WzNdID0gTWF0aC5jb3MocmFkKTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBHZXRzIHRoZSByb3RhdGlvbiBheGlzIGFuZCBhbmdsZSBmb3IgYSBnaXZlblxuICogIHF1YXRlcm5pb24uIElmIGEgcXVhdGVybmlvbiBpcyBjcmVhdGVkIHdpdGhcbiAqICBzZXRBeGlzQW5nbGUsIHRoaXMgbWV0aG9kIHdpbGwgcmV0dXJuIHRoZSBzYW1lXG4gKiAgdmFsdWVzIGFzIHByb3ZpZGllZCBpbiB0aGUgb3JpZ2luYWwgcGFyYW1ldGVyIGxpc3RcbiAqICBPUiBmdW5jdGlvbmFsbHkgZXF1aXZhbGVudCB2YWx1ZXMuXG4gKiBFeGFtcGxlOiBUaGUgcXVhdGVybmlvbiBmb3JtZWQgYnkgYXhpcyBbMCwgMCwgMV0gYW5kXG4gKiAgYW5nbGUgLTkwIGlzIHRoZSBzYW1lIGFzIHRoZSBxdWF0ZXJuaW9uIGZvcm1lZCBieVxuICogIFswLCAwLCAxXSBhbmQgMjcwLiBUaGlzIG1ldGhvZCBmYXZvcnMgdGhlIGxhdHRlci5cbiAqIEBwYXJhbSAge3ZlYzN9IG91dF9heGlzICBWZWN0b3IgcmVjZWl2aW5nIHRoZSBheGlzIG9mIHJvdGF0aW9uXG4gKiBAcGFyYW0gIHtxdWF0fSBxICAgICBRdWF0ZXJuaW9uIHRvIGJlIGRlY29tcG9zZWRcbiAqIEByZXR1cm4ge051bWJlcn0gICAgIEFuZ2xlLCBpbiByYWRpYW5zLCBvZiB0aGUgcm90YXRpb25cbiAqL1xucXVhdC5nZXRBeGlzQW5nbGUgPSBmdW5jdGlvbihvdXRfYXhpcywgcSkge1xuICAgIHZhciByYWQgPSBNYXRoLmFjb3MocVszXSkgKiAyLjA7XG4gICAgdmFyIHMgPSBNYXRoLnNpbihyYWQgLyAyLjApO1xuICAgIGlmIChzICE9IDAuMCkge1xuICAgICAgICBvdXRfYXhpc1swXSA9IHFbMF0gLyBzO1xuICAgICAgICBvdXRfYXhpc1sxXSA9IHFbMV0gLyBzO1xuICAgICAgICBvdXRfYXhpc1syXSA9IHFbMl0gLyBzO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIElmIHMgaXMgemVybywgcmV0dXJuIGFueSBheGlzIChubyByb3RhdGlvbiAtIGF4aXMgZG9lcyBub3QgbWF0dGVyKVxuICAgICAgICBvdXRfYXhpc1swXSA9IDE7XG4gICAgICAgIG91dF9heGlzWzFdID0gMDtcbiAgICAgICAgb3V0X2F4aXNbMl0gPSAwO1xuICAgIH1cbiAgICByZXR1cm4gcmFkO1xufTtcblxuLyoqXG4gKiBBZGRzIHR3byBxdWF0J3NcbiAqXG4gKiBAcGFyYW0ge3F1YXR9IG91dCB0aGUgcmVjZWl2aW5nIHF1YXRlcm5pb25cbiAqIEBwYXJhbSB7cXVhdH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHtxdWF0fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3F1YXR9IG91dFxuICogQGZ1bmN0aW9uXG4gKi9cbnF1YXQuYWRkID0gdmVjNC5hZGQ7XG5cbi8qKlxuICogTXVsdGlwbGllcyB0d28gcXVhdCdzXG4gKlxuICogQHBhcmFtIHtxdWF0fSBvdXQgdGhlIHJlY2VpdmluZyBxdWF0ZXJuaW9uXG4gKiBAcGFyYW0ge3F1YXR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7cXVhdH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHtxdWF0fSBvdXRcbiAqL1xucXVhdC5tdWx0aXBseSA9IGZ1bmN0aW9uKG91dCwgYSwgYikge1xuICAgIHZhciBheCA9IGFbMF0sIGF5ID0gYVsxXSwgYXogPSBhWzJdLCBhdyA9IGFbM10sXG4gICAgICAgIGJ4ID0gYlswXSwgYnkgPSBiWzFdLCBieiA9IGJbMl0sIGJ3ID0gYlszXTtcblxuICAgIG91dFswXSA9IGF4ICogYncgKyBhdyAqIGJ4ICsgYXkgKiBieiAtIGF6ICogYnk7XG4gICAgb3V0WzFdID0gYXkgKiBidyArIGF3ICogYnkgKyBheiAqIGJ4IC0gYXggKiBiejtcbiAgICBvdXRbMl0gPSBheiAqIGJ3ICsgYXcgKiBieiArIGF4ICogYnkgLSBheSAqIGJ4O1xuICAgIG91dFszXSA9IGF3ICogYncgLSBheCAqIGJ4IC0gYXkgKiBieSAtIGF6ICogYno7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayBxdWF0Lm11bHRpcGx5fVxuICogQGZ1bmN0aW9uXG4gKi9cbnF1YXQubXVsID0gcXVhdC5tdWx0aXBseTtcblxuLyoqXG4gKiBTY2FsZXMgYSBxdWF0IGJ5IGEgc2NhbGFyIG51bWJlclxuICpcbiAqIEBwYXJhbSB7cXVhdH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3F1YXR9IGEgdGhlIHZlY3RvciB0byBzY2FsZVxuICogQHBhcmFtIHtOdW1iZXJ9IGIgYW1vdW50IHRvIHNjYWxlIHRoZSB2ZWN0b3IgYnlcbiAqIEByZXR1cm5zIHtxdWF0fSBvdXRcbiAqIEBmdW5jdGlvblxuICovXG5xdWF0LnNjYWxlID0gdmVjNC5zY2FsZTtcblxuLyoqXG4gKiBSb3RhdGVzIGEgcXVhdGVybmlvbiBieSB0aGUgZ2l2ZW4gYW5nbGUgYWJvdXQgdGhlIFggYXhpc1xuICpcbiAqIEBwYXJhbSB7cXVhdH0gb3V0IHF1YXQgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcbiAqIEBwYXJhbSB7cXVhdH0gYSBxdWF0IHRvIHJvdGF0ZVxuICogQHBhcmFtIHtudW1iZXJ9IHJhZCBhbmdsZSAoaW4gcmFkaWFucykgdG8gcm90YXRlXG4gKiBAcmV0dXJucyB7cXVhdH0gb3V0XG4gKi9cbnF1YXQucm90YXRlWCA9IGZ1bmN0aW9uIChvdXQsIGEsIHJhZCkge1xuICAgIHJhZCAqPSAwLjU7IFxuXG4gICAgdmFyIGF4ID0gYVswXSwgYXkgPSBhWzFdLCBheiA9IGFbMl0sIGF3ID0gYVszXSxcbiAgICAgICAgYnggPSBNYXRoLnNpbihyYWQpLCBidyA9IE1hdGguY29zKHJhZCk7XG5cbiAgICBvdXRbMF0gPSBheCAqIGJ3ICsgYXcgKiBieDtcbiAgICBvdXRbMV0gPSBheSAqIGJ3ICsgYXogKiBieDtcbiAgICBvdXRbMl0gPSBheiAqIGJ3IC0gYXkgKiBieDtcbiAgICBvdXRbM10gPSBhdyAqIGJ3IC0gYXggKiBieDtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBSb3RhdGVzIGEgcXVhdGVybmlvbiBieSB0aGUgZ2l2ZW4gYW5nbGUgYWJvdXQgdGhlIFkgYXhpc1xuICpcbiAqIEBwYXJhbSB7cXVhdH0gb3V0IHF1YXQgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcbiAqIEBwYXJhbSB7cXVhdH0gYSBxdWF0IHRvIHJvdGF0ZVxuICogQHBhcmFtIHtudW1iZXJ9IHJhZCBhbmdsZSAoaW4gcmFkaWFucykgdG8gcm90YXRlXG4gKiBAcmV0dXJucyB7cXVhdH0gb3V0XG4gKi9cbnF1YXQucm90YXRlWSA9IGZ1bmN0aW9uIChvdXQsIGEsIHJhZCkge1xuICAgIHJhZCAqPSAwLjU7IFxuXG4gICAgdmFyIGF4ID0gYVswXSwgYXkgPSBhWzFdLCBheiA9IGFbMl0sIGF3ID0gYVszXSxcbiAgICAgICAgYnkgPSBNYXRoLnNpbihyYWQpLCBidyA9IE1hdGguY29zKHJhZCk7XG5cbiAgICBvdXRbMF0gPSBheCAqIGJ3IC0gYXogKiBieTtcbiAgICBvdXRbMV0gPSBheSAqIGJ3ICsgYXcgKiBieTtcbiAgICBvdXRbMl0gPSBheiAqIGJ3ICsgYXggKiBieTtcbiAgICBvdXRbM10gPSBhdyAqIGJ3IC0gYXkgKiBieTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBSb3RhdGVzIGEgcXVhdGVybmlvbiBieSB0aGUgZ2l2ZW4gYW5nbGUgYWJvdXQgdGhlIFogYXhpc1xuICpcbiAqIEBwYXJhbSB7cXVhdH0gb3V0IHF1YXQgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcbiAqIEBwYXJhbSB7cXVhdH0gYSBxdWF0IHRvIHJvdGF0ZVxuICogQHBhcmFtIHtudW1iZXJ9IHJhZCBhbmdsZSAoaW4gcmFkaWFucykgdG8gcm90YXRlXG4gKiBAcmV0dXJucyB7cXVhdH0gb3V0XG4gKi9cbnF1YXQucm90YXRlWiA9IGZ1bmN0aW9uIChvdXQsIGEsIHJhZCkge1xuICAgIHJhZCAqPSAwLjU7IFxuXG4gICAgdmFyIGF4ID0gYVswXSwgYXkgPSBhWzFdLCBheiA9IGFbMl0sIGF3ID0gYVszXSxcbiAgICAgICAgYnogPSBNYXRoLnNpbihyYWQpLCBidyA9IE1hdGguY29zKHJhZCk7XG5cbiAgICBvdXRbMF0gPSBheCAqIGJ3ICsgYXkgKiBiejtcbiAgICBvdXRbMV0gPSBheSAqIGJ3IC0gYXggKiBiejtcbiAgICBvdXRbMl0gPSBheiAqIGJ3ICsgYXcgKiBiejtcbiAgICBvdXRbM10gPSBhdyAqIGJ3IC0gYXogKiBiejtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBXIGNvbXBvbmVudCBvZiBhIHF1YXQgZnJvbSB0aGUgWCwgWSwgYW5kIFogY29tcG9uZW50cy5cbiAqIEFzc3VtZXMgdGhhdCBxdWF0ZXJuaW9uIGlzIDEgdW5pdCBpbiBsZW5ndGguXG4gKiBBbnkgZXhpc3RpbmcgVyBjb21wb25lbnQgd2lsbCBiZSBpZ25vcmVkLlxuICpcbiAqIEBwYXJhbSB7cXVhdH0gb3V0IHRoZSByZWNlaXZpbmcgcXVhdGVybmlvblxuICogQHBhcmFtIHtxdWF0fSBhIHF1YXQgdG8gY2FsY3VsYXRlIFcgY29tcG9uZW50IG9mXG4gKiBAcmV0dXJucyB7cXVhdH0gb3V0XG4gKi9cbnF1YXQuY2FsY3VsYXRlVyA9IGZ1bmN0aW9uIChvdXQsIGEpIHtcbiAgICB2YXIgeCA9IGFbMF0sIHkgPSBhWzFdLCB6ID0gYVsyXTtcblxuICAgIG91dFswXSA9IHg7XG4gICAgb3V0WzFdID0geTtcbiAgICBvdXRbMl0gPSB6O1xuICAgIG91dFszXSA9IE1hdGguc3FydChNYXRoLmFicygxLjAgLSB4ICogeCAtIHkgKiB5IC0geiAqIHopKTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBkb3QgcHJvZHVjdCBvZiB0d28gcXVhdCdzXG4gKlxuICogQHBhcmFtIHtxdWF0fSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3F1YXR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBkb3QgcHJvZHVjdCBvZiBhIGFuZCBiXG4gKiBAZnVuY3Rpb25cbiAqL1xucXVhdC5kb3QgPSB2ZWM0LmRvdDtcblxuLyoqXG4gKiBQZXJmb3JtcyBhIGxpbmVhciBpbnRlcnBvbGF0aW9uIGJldHdlZW4gdHdvIHF1YXQnc1xuICpcbiAqIEBwYXJhbSB7cXVhdH0gb3V0IHRoZSByZWNlaXZpbmcgcXVhdGVybmlvblxuICogQHBhcmFtIHtxdWF0fSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3F1YXR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcGFyYW0ge051bWJlcn0gdCBpbnRlcnBvbGF0aW9uIGFtb3VudCBiZXR3ZWVuIHRoZSB0d28gaW5wdXRzXG4gKiBAcmV0dXJucyB7cXVhdH0gb3V0XG4gKiBAZnVuY3Rpb25cbiAqL1xucXVhdC5sZXJwID0gdmVjNC5sZXJwO1xuXG4vKipcbiAqIFBlcmZvcm1zIGEgc3BoZXJpY2FsIGxpbmVhciBpbnRlcnBvbGF0aW9uIGJldHdlZW4gdHdvIHF1YXRcbiAqXG4gKiBAcGFyYW0ge3F1YXR9IG91dCB0aGUgcmVjZWl2aW5nIHF1YXRlcm5pb25cbiAqIEBwYXJhbSB7cXVhdH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHtxdWF0fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHBhcmFtIHtOdW1iZXJ9IHQgaW50ZXJwb2xhdGlvbiBhbW91bnQgYmV0d2VlbiB0aGUgdHdvIGlucHV0c1xuICogQHJldHVybnMge3F1YXR9IG91dFxuICovXG5xdWF0LnNsZXJwID0gZnVuY3Rpb24gKG91dCwgYSwgYiwgdCkge1xuICAgIC8vIGJlbmNobWFya3M6XG4gICAgLy8gICAgaHR0cDovL2pzcGVyZi5jb20vcXVhdGVybmlvbi1zbGVycC1pbXBsZW1lbnRhdGlvbnNcblxuICAgIHZhciBheCA9IGFbMF0sIGF5ID0gYVsxXSwgYXogPSBhWzJdLCBhdyA9IGFbM10sXG4gICAgICAgIGJ4ID0gYlswXSwgYnkgPSBiWzFdLCBieiA9IGJbMl0sIGJ3ID0gYlszXTtcblxuICAgIHZhciAgICAgICAgb21lZ2EsIGNvc29tLCBzaW5vbSwgc2NhbGUwLCBzY2FsZTE7XG5cbiAgICAvLyBjYWxjIGNvc2luZVxuICAgIGNvc29tID0gYXggKiBieCArIGF5ICogYnkgKyBheiAqIGJ6ICsgYXcgKiBidztcbiAgICAvLyBhZGp1c3Qgc2lnbnMgKGlmIG5lY2Vzc2FyeSlcbiAgICBpZiAoIGNvc29tIDwgMC4wICkge1xuICAgICAgICBjb3NvbSA9IC1jb3NvbTtcbiAgICAgICAgYnggPSAtIGJ4O1xuICAgICAgICBieSA9IC0gYnk7XG4gICAgICAgIGJ6ID0gLSBiejtcbiAgICAgICAgYncgPSAtIGJ3O1xuICAgIH1cbiAgICAvLyBjYWxjdWxhdGUgY29lZmZpY2llbnRzXG4gICAgaWYgKCAoMS4wIC0gY29zb20pID4gMC4wMDAwMDEgKSB7XG4gICAgICAgIC8vIHN0YW5kYXJkIGNhc2UgKHNsZXJwKVxuICAgICAgICBvbWVnYSAgPSBNYXRoLmFjb3MoY29zb20pO1xuICAgICAgICBzaW5vbSAgPSBNYXRoLnNpbihvbWVnYSk7XG4gICAgICAgIHNjYWxlMCA9IE1hdGguc2luKCgxLjAgLSB0KSAqIG9tZWdhKSAvIHNpbm9tO1xuICAgICAgICBzY2FsZTEgPSBNYXRoLnNpbih0ICogb21lZ2EpIC8gc2lub207XG4gICAgfSBlbHNlIHsgICAgICAgIFxuICAgICAgICAvLyBcImZyb21cIiBhbmQgXCJ0b1wiIHF1YXRlcm5pb25zIGFyZSB2ZXJ5IGNsb3NlIFxuICAgICAgICAvLyAgLi4uIHNvIHdlIGNhbiBkbyBhIGxpbmVhciBpbnRlcnBvbGF0aW9uXG4gICAgICAgIHNjYWxlMCA9IDEuMCAtIHQ7XG4gICAgICAgIHNjYWxlMSA9IHQ7XG4gICAgfVxuICAgIC8vIGNhbGN1bGF0ZSBmaW5hbCB2YWx1ZXNcbiAgICBvdXRbMF0gPSBzY2FsZTAgKiBheCArIHNjYWxlMSAqIGJ4O1xuICAgIG91dFsxXSA9IHNjYWxlMCAqIGF5ICsgc2NhbGUxICogYnk7XG4gICAgb3V0WzJdID0gc2NhbGUwICogYXogKyBzY2FsZTEgKiBiejtcbiAgICBvdXRbM10gPSBzY2FsZTAgKiBhdyArIHNjYWxlMSAqIGJ3O1xuICAgIFxuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFBlcmZvcm1zIGEgc3BoZXJpY2FsIGxpbmVhciBpbnRlcnBvbGF0aW9uIHdpdGggdHdvIGNvbnRyb2wgcG9pbnRzXG4gKlxuICogQHBhcmFtIHtxdWF0fSBvdXQgdGhlIHJlY2VpdmluZyBxdWF0ZXJuaW9uXG4gKiBAcGFyYW0ge3F1YXR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7cXVhdH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEBwYXJhbSB7cXVhdH0gYyB0aGUgdGhpcmQgb3BlcmFuZFxuICogQHBhcmFtIHtxdWF0fSBkIHRoZSBmb3VydGggb3BlcmFuZFxuICogQHBhcmFtIHtOdW1iZXJ9IHQgaW50ZXJwb2xhdGlvbiBhbW91bnRcbiAqIEByZXR1cm5zIHtxdWF0fSBvdXRcbiAqL1xucXVhdC5zcWxlcnAgPSAoZnVuY3Rpb24gKCkge1xuICB2YXIgdGVtcDEgPSBxdWF0LmNyZWF0ZSgpO1xuICB2YXIgdGVtcDIgPSBxdWF0LmNyZWF0ZSgpO1xuICBcbiAgcmV0dXJuIGZ1bmN0aW9uIChvdXQsIGEsIGIsIGMsIGQsIHQpIHtcbiAgICBxdWF0LnNsZXJwKHRlbXAxLCBhLCBkLCB0KTtcbiAgICBxdWF0LnNsZXJwKHRlbXAyLCBiLCBjLCB0KTtcbiAgICBxdWF0LnNsZXJwKG91dCwgdGVtcDEsIHRlbXAyLCAyICogdCAqICgxIC0gdCkpO1xuICAgIFxuICAgIHJldHVybiBvdXQ7XG4gIH07XG59KCkpO1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGludmVyc2Ugb2YgYSBxdWF0XG4gKlxuICogQHBhcmFtIHtxdWF0fSBvdXQgdGhlIHJlY2VpdmluZyBxdWF0ZXJuaW9uXG4gKiBAcGFyYW0ge3F1YXR9IGEgcXVhdCB0byBjYWxjdWxhdGUgaW52ZXJzZSBvZlxuICogQHJldHVybnMge3F1YXR9IG91dFxuICovXG5xdWF0LmludmVydCA9IGZ1bmN0aW9uKG91dCwgYSkge1xuICAgIHZhciBhMCA9IGFbMF0sIGExID0gYVsxXSwgYTIgPSBhWzJdLCBhMyA9IGFbM10sXG4gICAgICAgIGRvdCA9IGEwKmEwICsgYTEqYTEgKyBhMiphMiArIGEzKmEzLFxuICAgICAgICBpbnZEb3QgPSBkb3QgPyAxLjAvZG90IDogMDtcbiAgICBcbiAgICAvLyBUT0RPOiBXb3VsZCBiZSBmYXN0ZXIgdG8gcmV0dXJuIFswLDAsMCwwXSBpbW1lZGlhdGVseSBpZiBkb3QgPT0gMFxuXG4gICAgb3V0WzBdID0gLWEwKmludkRvdDtcbiAgICBvdXRbMV0gPSAtYTEqaW52RG90O1xuICAgIG91dFsyXSA9IC1hMippbnZEb3Q7XG4gICAgb3V0WzNdID0gYTMqaW52RG90O1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGNvbmp1Z2F0ZSBvZiBhIHF1YXRcbiAqIElmIHRoZSBxdWF0ZXJuaW9uIGlzIG5vcm1hbGl6ZWQsIHRoaXMgZnVuY3Rpb24gaXMgZmFzdGVyIHRoYW4gcXVhdC5pbnZlcnNlIGFuZCBwcm9kdWNlcyB0aGUgc2FtZSByZXN1bHQuXG4gKlxuICogQHBhcmFtIHtxdWF0fSBvdXQgdGhlIHJlY2VpdmluZyBxdWF0ZXJuaW9uXG4gKiBAcGFyYW0ge3F1YXR9IGEgcXVhdCB0byBjYWxjdWxhdGUgY29uanVnYXRlIG9mXG4gKiBAcmV0dXJucyB7cXVhdH0gb3V0XG4gKi9cbnF1YXQuY29uanVnYXRlID0gZnVuY3Rpb24gKG91dCwgYSkge1xuICAgIG91dFswXSA9IC1hWzBdO1xuICAgIG91dFsxXSA9IC1hWzFdO1xuICAgIG91dFsyXSA9IC1hWzJdO1xuICAgIG91dFszXSA9IGFbM107XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgbGVuZ3RoIG9mIGEgcXVhdFxuICpcbiAqIEBwYXJhbSB7cXVhdH0gYSB2ZWN0b3IgdG8gY2FsY3VsYXRlIGxlbmd0aCBvZlxuICogQHJldHVybnMge051bWJlcn0gbGVuZ3RoIG9mIGFcbiAqIEBmdW5jdGlvblxuICovXG5xdWF0Lmxlbmd0aCA9IHZlYzQubGVuZ3RoO1xuXG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgcXVhdC5sZW5ndGh9XG4gKiBAZnVuY3Rpb25cbiAqL1xucXVhdC5sZW4gPSBxdWF0Lmxlbmd0aDtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBzcXVhcmVkIGxlbmd0aCBvZiBhIHF1YXRcbiAqXG4gKiBAcGFyYW0ge3F1YXR9IGEgdmVjdG9yIHRvIGNhbGN1bGF0ZSBzcXVhcmVkIGxlbmd0aCBvZlxuICogQHJldHVybnMge051bWJlcn0gc3F1YXJlZCBsZW5ndGggb2YgYVxuICogQGZ1bmN0aW9uXG4gKi9cbnF1YXQuc3F1YXJlZExlbmd0aCA9IHZlYzQuc3F1YXJlZExlbmd0aDtcblxuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHF1YXQuc3F1YXJlZExlbmd0aH1cbiAqIEBmdW5jdGlvblxuICovXG5xdWF0LnNxckxlbiA9IHF1YXQuc3F1YXJlZExlbmd0aDtcblxuLyoqXG4gKiBOb3JtYWxpemUgYSBxdWF0XG4gKlxuICogQHBhcmFtIHtxdWF0fSBvdXQgdGhlIHJlY2VpdmluZyBxdWF0ZXJuaW9uXG4gKiBAcGFyYW0ge3F1YXR9IGEgcXVhdGVybmlvbiB0byBub3JtYWxpemVcbiAqIEByZXR1cm5zIHtxdWF0fSBvdXRcbiAqIEBmdW5jdGlvblxuICovXG5xdWF0Lm5vcm1hbGl6ZSA9IHZlYzQubm9ybWFsaXplO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBxdWF0ZXJuaW9uIGZyb20gdGhlIGdpdmVuIDN4MyByb3RhdGlvbiBtYXRyaXguXG4gKlxuICogTk9URTogVGhlIHJlc3VsdGFudCBxdWF0ZXJuaW9uIGlzIG5vdCBub3JtYWxpemVkLCBzbyB5b3Ugc2hvdWxkIGJlIHN1cmVcbiAqIHRvIHJlbm9ybWFsaXplIHRoZSBxdWF0ZXJuaW9uIHlvdXJzZWxmIHdoZXJlIG5lY2Vzc2FyeS5cbiAqXG4gKiBAcGFyYW0ge3F1YXR9IG91dCB0aGUgcmVjZWl2aW5nIHF1YXRlcm5pb25cbiAqIEBwYXJhbSB7bWF0M30gbSByb3RhdGlvbiBtYXRyaXhcbiAqIEByZXR1cm5zIHtxdWF0fSBvdXRcbiAqIEBmdW5jdGlvblxuICovXG5xdWF0LmZyb21NYXQzID0gZnVuY3Rpb24ob3V0LCBtKSB7XG4gICAgLy8gQWxnb3JpdGhtIGluIEtlbiBTaG9lbWFrZSdzIGFydGljbGUgaW4gMTk4NyBTSUdHUkFQSCBjb3Vyc2Ugbm90ZXNcbiAgICAvLyBhcnRpY2xlIFwiUXVhdGVybmlvbiBDYWxjdWx1cyBhbmQgRmFzdCBBbmltYXRpb25cIi5cbiAgICB2YXIgZlRyYWNlID0gbVswXSArIG1bNF0gKyBtWzhdO1xuICAgIHZhciBmUm9vdDtcblxuICAgIGlmICggZlRyYWNlID4gMC4wICkge1xuICAgICAgICAvLyB8d3wgPiAxLzIsIG1heSBhcyB3ZWxsIGNob29zZSB3ID4gMS8yXG4gICAgICAgIGZSb290ID0gTWF0aC5zcXJ0KGZUcmFjZSArIDEuMCk7ICAvLyAyd1xuICAgICAgICBvdXRbM10gPSAwLjUgKiBmUm9vdDtcbiAgICAgICAgZlJvb3QgPSAwLjUvZlJvb3Q7ICAvLyAxLyg0dylcbiAgICAgICAgb3V0WzBdID0gKG1bNV0tbVs3XSkqZlJvb3Q7XG4gICAgICAgIG91dFsxXSA9IChtWzZdLW1bMl0pKmZSb290O1xuICAgICAgICBvdXRbMl0gPSAobVsxXS1tWzNdKSpmUm9vdDtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyB8d3wgPD0gMS8yXG4gICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgaWYgKCBtWzRdID4gbVswXSApXG4gICAgICAgICAgaSA9IDE7XG4gICAgICAgIGlmICggbVs4XSA+IG1baSozK2ldIClcbiAgICAgICAgICBpID0gMjtcbiAgICAgICAgdmFyIGogPSAoaSsxKSUzO1xuICAgICAgICB2YXIgayA9IChpKzIpJTM7XG4gICAgICAgIFxuICAgICAgICBmUm9vdCA9IE1hdGguc3FydChtW2kqMytpXS1tW2oqMytqXS1tW2sqMytrXSArIDEuMCk7XG4gICAgICAgIG91dFtpXSA9IDAuNSAqIGZSb290O1xuICAgICAgICBmUm9vdCA9IDAuNSAvIGZSb290O1xuICAgICAgICBvdXRbM10gPSAobVtqKjMra10gLSBtW2sqMytqXSkgKiBmUm9vdDtcbiAgICAgICAgb3V0W2pdID0gKG1baiozK2ldICsgbVtpKjMral0pICogZlJvb3Q7XG4gICAgICAgIG91dFtrXSA9IChtW2sqMytpXSArIG1baSozK2tdKSAqIGZSb290O1xuICAgIH1cbiAgICBcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGEgcXVhdGVuaW9uXG4gKlxuICogQHBhcmFtIHtxdWF0fSB2ZWMgdmVjdG9yIHRvIHJlcHJlc2VudCBhcyBhIHN0cmluZ1xuICogQHJldHVybnMge1N0cmluZ30gc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSB2ZWN0b3JcbiAqL1xucXVhdC5zdHIgPSBmdW5jdGlvbiAoYSkge1xuICAgIHJldHVybiAncXVhdCgnICsgYVswXSArICcsICcgKyBhWzFdICsgJywgJyArIGFbMl0gKyAnLCAnICsgYVszXSArICcpJztcbn07XG5cbi8qKlxuICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgcXVhdGVybmlvbnMgaGF2ZSBleGFjdGx5IHRoZSBzYW1lIGVsZW1lbnRzIGluIHRoZSBzYW1lIHBvc2l0aW9uICh3aGVuIGNvbXBhcmVkIHdpdGggPT09KVxuICpcbiAqIEBwYXJhbSB7cXVhdH0gYSBUaGUgZmlyc3QgcXVhdGVybmlvbi5cbiAqIEBwYXJhbSB7cXVhdH0gYiBUaGUgc2Vjb25kIHF1YXRlcm5pb24uXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gVHJ1ZSBpZiB0aGUgdmVjdG9ycyBhcmUgZXF1YWwsIGZhbHNlIG90aGVyd2lzZS5cbiAqL1xucXVhdC5leGFjdEVxdWFscyA9IHZlYzQuZXhhY3RFcXVhbHM7XG5cbi8qKlxuICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgcXVhdGVybmlvbnMgaGF2ZSBhcHByb3hpbWF0ZWx5IHRoZSBzYW1lIGVsZW1lbnRzIGluIHRoZSBzYW1lIHBvc2l0aW9uLlxuICpcbiAqIEBwYXJhbSB7cXVhdH0gYSBUaGUgZmlyc3QgdmVjdG9yLlxuICogQHBhcmFtIHtxdWF0fSBiIFRoZSBzZWNvbmQgdmVjdG9yLlxuICogQHJldHVybnMge0Jvb2xlYW59IFRydWUgaWYgdGhlIHZlY3RvcnMgYXJlIGVxdWFsLCBmYWxzZSBvdGhlcndpc2UuXG4gKi9cbnF1YXQuZXF1YWxzID0gdmVjNC5lcXVhbHM7XG5cbm1vZHVsZS5leHBvcnRzID0gcXVhdDtcbiIsIi8qIENvcHlyaWdodCAoYykgMjAxNSwgQnJhbmRvbiBKb25lcywgQ29saW4gTWFjS2VuemllIElWLlxuXG5QZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG5vZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG5pbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG50byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG5jb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbmZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cblRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG5hbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG5GSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbkFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbkxJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG5PVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG5USEUgU09GVFdBUkUuICovXG5cbnZhciBnbE1hdHJpeCA9IHJlcXVpcmUoXCIuL2NvbW1vbi5qc1wiKTtcblxuLyoqXG4gKiBAY2xhc3MgMiBEaW1lbnNpb25hbCBWZWN0b3JcbiAqIEBuYW1lIHZlYzJcbiAqL1xudmFyIHZlYzIgPSB7fTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3LCBlbXB0eSB2ZWMyXG4gKlxuICogQHJldHVybnMge3ZlYzJ9IGEgbmV3IDJEIHZlY3RvclxuICovXG52ZWMyLmNyZWF0ZSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBvdXQgPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSgyKTtcbiAgICBvdXRbMF0gPSAwO1xuICAgIG91dFsxXSA9IDA7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyB2ZWMyIGluaXRpYWxpemVkIHdpdGggdmFsdWVzIGZyb20gYW4gZXhpc3RpbmcgdmVjdG9yXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBhIHZlY3RvciB0byBjbG9uZVxuICogQHJldHVybnMge3ZlYzJ9IGEgbmV3IDJEIHZlY3RvclxuICovXG52ZWMyLmNsb25lID0gZnVuY3Rpb24oYSkge1xuICAgIHZhciBvdXQgPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSgyKTtcbiAgICBvdXRbMF0gPSBhWzBdO1xuICAgIG91dFsxXSA9IGFbMV07XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyB2ZWMyIGluaXRpYWxpemVkIHdpdGggdGhlIGdpdmVuIHZhbHVlc1xuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSB4IFggY29tcG9uZW50XG4gKiBAcGFyYW0ge051bWJlcn0geSBZIGNvbXBvbmVudFxuICogQHJldHVybnMge3ZlYzJ9IGEgbmV3IDJEIHZlY3RvclxuICovXG52ZWMyLmZyb21WYWx1ZXMgPSBmdW5jdGlvbih4LCB5KSB7XG4gICAgdmFyIG91dCA9IG5ldyBnbE1hdHJpeC5BUlJBWV9UWVBFKDIpO1xuICAgIG91dFswXSA9IHg7XG4gICAgb3V0WzFdID0geTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDb3B5IHRoZSB2YWx1ZXMgZnJvbSBvbmUgdmVjMiB0byBhbm90aGVyXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjMn0gYSB0aGUgc291cmNlIHZlY3RvclxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG52ZWMyLmNvcHkgPSBmdW5jdGlvbihvdXQsIGEpIHtcbiAgICBvdXRbMF0gPSBhWzBdO1xuICAgIG91dFsxXSA9IGFbMV07XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogU2V0IHRoZSBjb21wb25lbnRzIG9mIGEgdmVjMiB0byB0aGUgZ2l2ZW4gdmFsdWVzXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7TnVtYmVyfSB4IFggY29tcG9uZW50XG4gKiBAcGFyYW0ge051bWJlcn0geSBZIGNvbXBvbmVudFxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG52ZWMyLnNldCA9IGZ1bmN0aW9uKG91dCwgeCwgeSkge1xuICAgIG91dFswXSA9IHg7XG4gICAgb3V0WzFdID0geTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBBZGRzIHR3byB2ZWMyJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMyfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbnZlYzIuYWRkID0gZnVuY3Rpb24ob3V0LCBhLCBiKSB7XG4gICAgb3V0WzBdID0gYVswXSArIGJbMF07XG4gICAgb3V0WzFdID0gYVsxXSArIGJbMV07XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogU3VidHJhY3RzIHZlY3RvciBiIGZyb20gdmVjdG9yIGFcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMyfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbnZlYzIuc3VidHJhY3QgPSBmdW5jdGlvbihvdXQsIGEsIGIpIHtcbiAgICBvdXRbMF0gPSBhWzBdIC0gYlswXTtcbiAgICBvdXRbMV0gPSBhWzFdIC0gYlsxXTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzIuc3VidHJhY3R9XG4gKiBAZnVuY3Rpb25cbiAqL1xudmVjMi5zdWIgPSB2ZWMyLnN1YnRyYWN0O1xuXG4vKipcbiAqIE11bHRpcGxpZXMgdHdvIHZlYzInc1xuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjMn0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xudmVjMi5tdWx0aXBseSA9IGZ1bmN0aW9uKG91dCwgYSwgYikge1xuICAgIG91dFswXSA9IGFbMF0gKiBiWzBdO1xuICAgIG91dFsxXSA9IGFbMV0gKiBiWzFdO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjMi5tdWx0aXBseX1cbiAqIEBmdW5jdGlvblxuICovXG52ZWMyLm11bCA9IHZlYzIubXVsdGlwbHk7XG5cbi8qKlxuICogRGl2aWRlcyB0d28gdmVjMidzXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjMn0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMyfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG52ZWMyLmRpdmlkZSA9IGZ1bmN0aW9uKG91dCwgYSwgYikge1xuICAgIG91dFswXSA9IGFbMF0gLyBiWzBdO1xuICAgIG91dFsxXSA9IGFbMV0gLyBiWzFdO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjMi5kaXZpZGV9XG4gKiBAZnVuY3Rpb25cbiAqL1xudmVjMi5kaXYgPSB2ZWMyLmRpdmlkZTtcblxuLyoqXG4gKiBNYXRoLmNlaWwgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWMyXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjMn0gYSB2ZWN0b3IgdG8gY2VpbFxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG52ZWMyLmNlaWwgPSBmdW5jdGlvbiAob3V0LCBhKSB7XG4gICAgb3V0WzBdID0gTWF0aC5jZWlsKGFbMF0pO1xuICAgIG91dFsxXSA9IE1hdGguY2VpbChhWzFdKTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBNYXRoLmZsb29yIHRoZSBjb21wb25lbnRzIG9mIGEgdmVjMlxuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdmVjdG9yIHRvIGZsb29yXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbnZlYzIuZmxvb3IgPSBmdW5jdGlvbiAob3V0LCBhKSB7XG4gICAgb3V0WzBdID0gTWF0aC5mbG9vcihhWzBdKTtcbiAgICBvdXRbMV0gPSBNYXRoLmZsb29yKGFbMV0pO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIG1pbmltdW0gb2YgdHdvIHZlYzInc1xuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjMn0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xudmVjMi5taW4gPSBmdW5jdGlvbihvdXQsIGEsIGIpIHtcbiAgICBvdXRbMF0gPSBNYXRoLm1pbihhWzBdLCBiWzBdKTtcbiAgICBvdXRbMV0gPSBNYXRoLm1pbihhWzFdLCBiWzFdKTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBtYXhpbXVtIG9mIHR3byB2ZWMyJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMyfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbnZlYzIubWF4ID0gZnVuY3Rpb24ob3V0LCBhLCBiKSB7XG4gICAgb3V0WzBdID0gTWF0aC5tYXgoYVswXSwgYlswXSk7XG4gICAgb3V0WzFdID0gTWF0aC5tYXgoYVsxXSwgYlsxXSk7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogTWF0aC5yb3VuZCB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzJcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMyfSBhIHZlY3RvciB0byByb3VuZFxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG52ZWMyLnJvdW5kID0gZnVuY3Rpb24gKG91dCwgYSkge1xuICAgIG91dFswXSA9IE1hdGgucm91bmQoYVswXSk7XG4gICAgb3V0WzFdID0gTWF0aC5yb3VuZChhWzFdKTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBTY2FsZXMgYSB2ZWMyIGJ5IGEgc2NhbGFyIG51bWJlclxuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdGhlIHZlY3RvciB0byBzY2FsZVxuICogQHBhcmFtIHtOdW1iZXJ9IGIgYW1vdW50IHRvIHNjYWxlIHRoZSB2ZWN0b3IgYnlcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xudmVjMi5zY2FsZSA9IGZ1bmN0aW9uKG91dCwgYSwgYikge1xuICAgIG91dFswXSA9IGFbMF0gKiBiO1xuICAgIG91dFsxXSA9IGFbMV0gKiBiO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIEFkZHMgdHdvIHZlYzIncyBhZnRlciBzY2FsaW5nIHRoZSBzZWNvbmQgb3BlcmFuZCBieSBhIHNjYWxhciB2YWx1ZVxuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjMn0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEBwYXJhbSB7TnVtYmVyfSBzY2FsZSB0aGUgYW1vdW50IHRvIHNjYWxlIGIgYnkgYmVmb3JlIGFkZGluZ1xuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG52ZWMyLnNjYWxlQW5kQWRkID0gZnVuY3Rpb24ob3V0LCBhLCBiLCBzY2FsZSkge1xuICAgIG91dFswXSA9IGFbMF0gKyAoYlswXSAqIHNjYWxlKTtcbiAgICBvdXRbMV0gPSBhWzFdICsgKGJbMV0gKiBzY2FsZSk7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgZXVjbGlkaWFuIGRpc3RhbmNlIGJldHdlZW4gdHdvIHZlYzInc1xuICpcbiAqIEBwYXJhbSB7dmVjMn0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMyfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge051bWJlcn0gZGlzdGFuY2UgYmV0d2VlbiBhIGFuZCBiXG4gKi9cbnZlYzIuZGlzdGFuY2UgPSBmdW5jdGlvbihhLCBiKSB7XG4gICAgdmFyIHggPSBiWzBdIC0gYVswXSxcbiAgICAgICAgeSA9IGJbMV0gLSBhWzFdO1xuICAgIHJldHVybiBNYXRoLnNxcnQoeCp4ICsgeSp5KTtcbn07XG5cbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayB2ZWMyLmRpc3RhbmNlfVxuICogQGZ1bmN0aW9uXG4gKi9cbnZlYzIuZGlzdCA9IHZlYzIuZGlzdGFuY2U7XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgc3F1YXJlZCBldWNsaWRpYW4gZGlzdGFuY2UgYmV0d2VlbiB0d28gdmVjMidzXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBzcXVhcmVkIGRpc3RhbmNlIGJldHdlZW4gYSBhbmQgYlxuICovXG52ZWMyLnNxdWFyZWREaXN0YW5jZSA9IGZ1bmN0aW9uKGEsIGIpIHtcbiAgICB2YXIgeCA9IGJbMF0gLSBhWzBdLFxuICAgICAgICB5ID0gYlsxXSAtIGFbMV07XG4gICAgcmV0dXJuIHgqeCArIHkqeTtcbn07XG5cbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayB2ZWMyLnNxdWFyZWREaXN0YW5jZX1cbiAqIEBmdW5jdGlvblxuICovXG52ZWMyLnNxckRpc3QgPSB2ZWMyLnNxdWFyZWREaXN0YW5jZTtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBsZW5ndGggb2YgYSB2ZWMyXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBhIHZlY3RvciB0byBjYWxjdWxhdGUgbGVuZ3RoIG9mXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBsZW5ndGggb2YgYVxuICovXG52ZWMyLmxlbmd0aCA9IGZ1bmN0aW9uIChhKSB7XG4gICAgdmFyIHggPSBhWzBdLFxuICAgICAgICB5ID0gYVsxXTtcbiAgICByZXR1cm4gTWF0aC5zcXJ0KHgqeCArIHkqeSk7XG59O1xuXG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjMi5sZW5ndGh9XG4gKiBAZnVuY3Rpb25cbiAqL1xudmVjMi5sZW4gPSB2ZWMyLmxlbmd0aDtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBzcXVhcmVkIGxlbmd0aCBvZiBhIHZlYzJcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdmVjdG9yIHRvIGNhbGN1bGF0ZSBzcXVhcmVkIGxlbmd0aCBvZlxuICogQHJldHVybnMge051bWJlcn0gc3F1YXJlZCBsZW5ndGggb2YgYVxuICovXG52ZWMyLnNxdWFyZWRMZW5ndGggPSBmdW5jdGlvbiAoYSkge1xuICAgIHZhciB4ID0gYVswXSxcbiAgICAgICAgeSA9IGFbMV07XG4gICAgcmV0dXJuIHgqeCArIHkqeTtcbn07XG5cbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayB2ZWMyLnNxdWFyZWRMZW5ndGh9XG4gKiBAZnVuY3Rpb25cbiAqL1xudmVjMi5zcXJMZW4gPSB2ZWMyLnNxdWFyZWRMZW5ndGg7XG5cbi8qKlxuICogTmVnYXRlcyB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzJcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMyfSBhIHZlY3RvciB0byBuZWdhdGVcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xudmVjMi5uZWdhdGUgPSBmdW5jdGlvbihvdXQsIGEpIHtcbiAgICBvdXRbMF0gPSAtYVswXTtcbiAgICBvdXRbMV0gPSAtYVsxXTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBpbnZlcnNlIG9mIHRoZSBjb21wb25lbnRzIG9mIGEgdmVjMlxuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdmVjdG9yIHRvIGludmVydFxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG52ZWMyLmludmVyc2UgPSBmdW5jdGlvbihvdXQsIGEpIHtcbiAgb3V0WzBdID0gMS4wIC8gYVswXTtcbiAgb3V0WzFdID0gMS4wIC8gYVsxXTtcbiAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogTm9ybWFsaXplIGEgdmVjMlxuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdmVjdG9yIHRvIG5vcm1hbGl6ZVxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG52ZWMyLm5vcm1hbGl6ZSA9IGZ1bmN0aW9uKG91dCwgYSkge1xuICAgIHZhciB4ID0gYVswXSxcbiAgICAgICAgeSA9IGFbMV07XG4gICAgdmFyIGxlbiA9IHgqeCArIHkqeTtcbiAgICBpZiAobGVuID4gMCkge1xuICAgICAgICAvL1RPRE86IGV2YWx1YXRlIHVzZSBvZiBnbG1faW52c3FydCBoZXJlP1xuICAgICAgICBsZW4gPSAxIC8gTWF0aC5zcXJ0KGxlbik7XG4gICAgICAgIG91dFswXSA9IGFbMF0gKiBsZW47XG4gICAgICAgIG91dFsxXSA9IGFbMV0gKiBsZW47XG4gICAgfVxuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGRvdCBwcm9kdWN0IG9mIHR3byB2ZWMyJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjMn0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IGRvdCBwcm9kdWN0IG9mIGEgYW5kIGJcbiAqL1xudmVjMi5kb3QgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgIHJldHVybiBhWzBdICogYlswXSArIGFbMV0gKiBiWzFdO1xufTtcblxuLyoqXG4gKiBDb21wdXRlcyB0aGUgY3Jvc3MgcHJvZHVjdCBvZiB0d28gdmVjMidzXG4gKiBOb3RlIHRoYXQgdGhlIGNyb3NzIHByb2R1Y3QgbXVzdCBieSBkZWZpbml0aW9uIHByb2R1Y2UgYSAzRCB2ZWN0b3JcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMyfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbnZlYzIuY3Jvc3MgPSBmdW5jdGlvbihvdXQsIGEsIGIpIHtcbiAgICB2YXIgeiA9IGFbMF0gKiBiWzFdIC0gYVsxXSAqIGJbMF07XG4gICAgb3V0WzBdID0gb3V0WzFdID0gMDtcbiAgICBvdXRbMl0gPSB6O1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFBlcmZvcm1zIGEgbGluZWFyIGludGVycG9sYXRpb24gYmV0d2VlbiB0d28gdmVjMidzXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjMn0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMyfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHBhcmFtIHtOdW1iZXJ9IHQgaW50ZXJwb2xhdGlvbiBhbW91bnQgYmV0d2VlbiB0aGUgdHdvIGlucHV0c1xuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG52ZWMyLmxlcnAgPSBmdW5jdGlvbiAob3V0LCBhLCBiLCB0KSB7XG4gICAgdmFyIGF4ID0gYVswXSxcbiAgICAgICAgYXkgPSBhWzFdO1xuICAgIG91dFswXSA9IGF4ICsgdCAqIChiWzBdIC0gYXgpO1xuICAgIG91dFsxXSA9IGF5ICsgdCAqIChiWzFdIC0gYXkpO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIEdlbmVyYXRlcyBhIHJhbmRvbSB2ZWN0b3Igd2l0aCB0aGUgZ2l2ZW4gc2NhbGVcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHtOdW1iZXJ9IFtzY2FsZV0gTGVuZ3RoIG9mIHRoZSByZXN1bHRpbmcgdmVjdG9yLiBJZiBvbW1pdHRlZCwgYSB1bml0IHZlY3RvciB3aWxsIGJlIHJldHVybmVkXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbnZlYzIucmFuZG9tID0gZnVuY3Rpb24gKG91dCwgc2NhbGUpIHtcbiAgICBzY2FsZSA9IHNjYWxlIHx8IDEuMDtcbiAgICB2YXIgciA9IGdsTWF0cml4LlJBTkRPTSgpICogMi4wICogTWF0aC5QSTtcbiAgICBvdXRbMF0gPSBNYXRoLmNvcyhyKSAqIHNjYWxlO1xuICAgIG91dFsxXSA9IE1hdGguc2luKHIpICogc2NhbGU7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogVHJhbnNmb3JtcyB0aGUgdmVjMiB3aXRoIGEgbWF0MlxuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdGhlIHZlY3RvciB0byB0cmFuc2Zvcm1cbiAqIEBwYXJhbSB7bWF0Mn0gbSBtYXRyaXggdG8gdHJhbnNmb3JtIHdpdGhcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xudmVjMi50cmFuc2Zvcm1NYXQyID0gZnVuY3Rpb24ob3V0LCBhLCBtKSB7XG4gICAgdmFyIHggPSBhWzBdLFxuICAgICAgICB5ID0gYVsxXTtcbiAgICBvdXRbMF0gPSBtWzBdICogeCArIG1bMl0gKiB5O1xuICAgIG91dFsxXSA9IG1bMV0gKiB4ICsgbVszXSAqIHk7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogVHJhbnNmb3JtcyB0aGUgdmVjMiB3aXRoIGEgbWF0MmRcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMyfSBhIHRoZSB2ZWN0b3IgdG8gdHJhbnNmb3JtXG4gKiBAcGFyYW0ge21hdDJkfSBtIG1hdHJpeCB0byB0cmFuc2Zvcm0gd2l0aFxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG52ZWMyLnRyYW5zZm9ybU1hdDJkID0gZnVuY3Rpb24ob3V0LCBhLCBtKSB7XG4gICAgdmFyIHggPSBhWzBdLFxuICAgICAgICB5ID0gYVsxXTtcbiAgICBvdXRbMF0gPSBtWzBdICogeCArIG1bMl0gKiB5ICsgbVs0XTtcbiAgICBvdXRbMV0gPSBtWzFdICogeCArIG1bM10gKiB5ICsgbVs1XTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBUcmFuc2Zvcm1zIHRoZSB2ZWMyIHdpdGggYSBtYXQzXG4gKiAzcmQgdmVjdG9yIGNvbXBvbmVudCBpcyBpbXBsaWNpdGx5ICcxJ1xuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdGhlIHZlY3RvciB0byB0cmFuc2Zvcm1cbiAqIEBwYXJhbSB7bWF0M30gbSBtYXRyaXggdG8gdHJhbnNmb3JtIHdpdGhcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xudmVjMi50cmFuc2Zvcm1NYXQzID0gZnVuY3Rpb24ob3V0LCBhLCBtKSB7XG4gICAgdmFyIHggPSBhWzBdLFxuICAgICAgICB5ID0gYVsxXTtcbiAgICBvdXRbMF0gPSBtWzBdICogeCArIG1bM10gKiB5ICsgbVs2XTtcbiAgICBvdXRbMV0gPSBtWzFdICogeCArIG1bNF0gKiB5ICsgbVs3XTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBUcmFuc2Zvcm1zIHRoZSB2ZWMyIHdpdGggYSBtYXQ0XG4gKiAzcmQgdmVjdG9yIGNvbXBvbmVudCBpcyBpbXBsaWNpdGx5ICcwJ1xuICogNHRoIHZlY3RvciBjb21wb25lbnQgaXMgaW1wbGljaXRseSAnMSdcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMyfSBhIHRoZSB2ZWN0b3IgdG8gdHJhbnNmb3JtXG4gKiBAcGFyYW0ge21hdDR9IG0gbWF0cml4IHRvIHRyYW5zZm9ybSB3aXRoXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbnZlYzIudHJhbnNmb3JtTWF0NCA9IGZ1bmN0aW9uKG91dCwgYSwgbSkge1xuICAgIHZhciB4ID0gYVswXSwgXG4gICAgICAgIHkgPSBhWzFdO1xuICAgIG91dFswXSA9IG1bMF0gKiB4ICsgbVs0XSAqIHkgKyBtWzEyXTtcbiAgICBvdXRbMV0gPSBtWzFdICogeCArIG1bNV0gKiB5ICsgbVsxM107XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogUGVyZm9ybSBzb21lIG9wZXJhdGlvbiBvdmVyIGFuIGFycmF5IG9mIHZlYzJzLlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IGEgdGhlIGFycmF5IG9mIHZlY3RvcnMgdG8gaXRlcmF0ZSBvdmVyXG4gKiBAcGFyYW0ge051bWJlcn0gc3RyaWRlIE51bWJlciBvZiBlbGVtZW50cyBiZXR3ZWVuIHRoZSBzdGFydCBvZiBlYWNoIHZlYzIuIElmIDAgYXNzdW1lcyB0aWdodGx5IHBhY2tlZFxuICogQHBhcmFtIHtOdW1iZXJ9IG9mZnNldCBOdW1iZXIgb2YgZWxlbWVudHMgdG8gc2tpcCBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoZSBhcnJheVxuICogQHBhcmFtIHtOdW1iZXJ9IGNvdW50IE51bWJlciBvZiB2ZWMycyB0byBpdGVyYXRlIG92ZXIuIElmIDAgaXRlcmF0ZXMgb3ZlciBlbnRpcmUgYXJyYXlcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIEZ1bmN0aW9uIHRvIGNhbGwgZm9yIGVhY2ggdmVjdG9yIGluIHRoZSBhcnJheVxuICogQHBhcmFtIHtPYmplY3R9IFthcmddIGFkZGl0aW9uYWwgYXJndW1lbnQgdG8gcGFzcyB0byBmblxuICogQHJldHVybnMge0FycmF5fSBhXG4gKiBAZnVuY3Rpb25cbiAqL1xudmVjMi5mb3JFYWNoID0gKGZ1bmN0aW9uKCkge1xuICAgIHZhciB2ZWMgPSB2ZWMyLmNyZWF0ZSgpO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uKGEsIHN0cmlkZSwgb2Zmc2V0LCBjb3VudCwgZm4sIGFyZykge1xuICAgICAgICB2YXIgaSwgbDtcbiAgICAgICAgaWYoIXN0cmlkZSkge1xuICAgICAgICAgICAgc3RyaWRlID0gMjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKCFvZmZzZXQpIHtcbiAgICAgICAgICAgIG9mZnNldCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGlmKGNvdW50KSB7XG4gICAgICAgICAgICBsID0gTWF0aC5taW4oKGNvdW50ICogc3RyaWRlKSArIG9mZnNldCwgYS5sZW5ndGgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbCA9IGEubGVuZ3RoO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yKGkgPSBvZmZzZXQ7IGkgPCBsOyBpICs9IHN0cmlkZSkge1xuICAgICAgICAgICAgdmVjWzBdID0gYVtpXTsgdmVjWzFdID0gYVtpKzFdO1xuICAgICAgICAgICAgZm4odmVjLCB2ZWMsIGFyZyk7XG4gICAgICAgICAgICBhW2ldID0gdmVjWzBdOyBhW2krMV0gPSB2ZWNbMV07XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHJldHVybiBhO1xuICAgIH07XG59KSgpO1xuXG4vKipcbiAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYSB2ZWN0b3JcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IHZlYyB2ZWN0b3IgdG8gcmVwcmVzZW50IGFzIGEgc3RyaW5nXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIHZlY3RvclxuICovXG52ZWMyLnN0ciA9IGZ1bmN0aW9uIChhKSB7XG4gICAgcmV0dXJuICd2ZWMyKCcgKyBhWzBdICsgJywgJyArIGFbMV0gKyAnKSc7XG59O1xuXG4vKipcbiAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIHZlY3RvcnMgZXhhY3RseSBoYXZlIHRoZSBzYW1lIGVsZW1lbnRzIGluIHRoZSBzYW1lIHBvc2l0aW9uICh3aGVuIGNvbXBhcmVkIHdpdGggPT09KVxuICpcbiAqIEBwYXJhbSB7dmVjMn0gYSBUaGUgZmlyc3QgdmVjdG9yLlxuICogQHBhcmFtIHt2ZWMyfSBiIFRoZSBzZWNvbmQgdmVjdG9yLlxuICogQHJldHVybnMge0Jvb2xlYW59IFRydWUgaWYgdGhlIHZlY3RvcnMgYXJlIGVxdWFsLCBmYWxzZSBvdGhlcndpc2UuXG4gKi9cbnZlYzIuZXhhY3RFcXVhbHMgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgIHJldHVybiBhWzBdID09PSBiWzBdICYmIGFbMV0gPT09IGJbMV07XG59O1xuXG4vKipcbiAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIHZlY3RvcnMgaGF2ZSBhcHByb3hpbWF0ZWx5IHRoZSBzYW1lIGVsZW1lbnRzIGluIHRoZSBzYW1lIHBvc2l0aW9uLlxuICpcbiAqIEBwYXJhbSB7dmVjMn0gYSBUaGUgZmlyc3QgdmVjdG9yLlxuICogQHBhcmFtIHt2ZWMyfSBiIFRoZSBzZWNvbmQgdmVjdG9yLlxuICogQHJldHVybnMge0Jvb2xlYW59IFRydWUgaWYgdGhlIHZlY3RvcnMgYXJlIGVxdWFsLCBmYWxzZSBvdGhlcndpc2UuXG4gKi9cbnZlYzIuZXF1YWxzID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICB2YXIgYTAgPSBhWzBdLCBhMSA9IGFbMV07XG4gICAgdmFyIGIwID0gYlswXSwgYjEgPSBiWzFdO1xuICAgIHJldHVybiAoTWF0aC5hYnMoYTAgLSBiMCkgPD0gZ2xNYXRyaXguRVBTSUxPTipNYXRoLm1heCgxLjAsIE1hdGguYWJzKGEwKSwgTWF0aC5hYnMoYjApKSAmJlxuICAgICAgICAgICAgTWF0aC5hYnMoYTEgLSBiMSkgPD0gZ2xNYXRyaXguRVBTSUxPTipNYXRoLm1heCgxLjAsIE1hdGguYWJzKGExKSwgTWF0aC5hYnMoYjEpKSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHZlYzI7XG4iLCIvKiBDb3B5cmlnaHQgKGMpIDIwMTUsIEJyYW5kb24gSm9uZXMsIENvbGluIE1hY0tlbnppZSBJVi5cblxuUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxub2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xudG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG5mdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXG5UaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbklNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG5BVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG5MSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuVEhFIFNPRlRXQVJFLiAqL1xuXG52YXIgZ2xNYXRyaXggPSByZXF1aXJlKFwiLi9jb21tb24uanNcIik7XG5cbi8qKlxuICogQGNsYXNzIDMgRGltZW5zaW9uYWwgVmVjdG9yXG4gKiBAbmFtZSB2ZWMzXG4gKi9cbnZhciB2ZWMzID0ge307XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldywgZW1wdHkgdmVjM1xuICpcbiAqIEByZXR1cm5zIHt2ZWMzfSBhIG5ldyAzRCB2ZWN0b3JcbiAqL1xudmVjMy5jcmVhdGUgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgb3V0ID0gbmV3IGdsTWF0cml4LkFSUkFZX1RZUEUoMyk7XG4gICAgb3V0WzBdID0gMDtcbiAgICBvdXRbMV0gPSAwO1xuICAgIG91dFsyXSA9IDA7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyB2ZWMzIGluaXRpYWxpemVkIHdpdGggdmFsdWVzIGZyb20gYW4gZXhpc3RpbmcgdmVjdG9yXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBhIHZlY3RvciB0byBjbG9uZVxuICogQHJldHVybnMge3ZlYzN9IGEgbmV3IDNEIHZlY3RvclxuICovXG52ZWMzLmNsb25lID0gZnVuY3Rpb24oYSkge1xuICAgIHZhciBvdXQgPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSgzKTtcbiAgICBvdXRbMF0gPSBhWzBdO1xuICAgIG91dFsxXSA9IGFbMV07XG4gICAgb3V0WzJdID0gYVsyXTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IHZlYzMgaW5pdGlhbGl6ZWQgd2l0aCB0aGUgZ2l2ZW4gdmFsdWVzXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IHggWCBjb21wb25lbnRcbiAqIEBwYXJhbSB7TnVtYmVyfSB5IFkgY29tcG9uZW50XG4gKiBAcGFyYW0ge051bWJlcn0geiBaIGNvbXBvbmVudFxuICogQHJldHVybnMge3ZlYzN9IGEgbmV3IDNEIHZlY3RvclxuICovXG52ZWMzLmZyb21WYWx1ZXMgPSBmdW5jdGlvbih4LCB5LCB6KSB7XG4gICAgdmFyIG91dCA9IG5ldyBnbE1hdHJpeC5BUlJBWV9UWVBFKDMpO1xuICAgIG91dFswXSA9IHg7XG4gICAgb3V0WzFdID0geTtcbiAgICBvdXRbMl0gPSB6O1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENvcHkgdGhlIHZhbHVlcyBmcm9tIG9uZSB2ZWMzIHRvIGFub3RoZXJcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSBzb3VyY2UgdmVjdG9yXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbnZlYzMuY29weSA9IGZ1bmN0aW9uKG91dCwgYSkge1xuICAgIG91dFswXSA9IGFbMF07XG4gICAgb3V0WzFdID0gYVsxXTtcbiAgICBvdXRbMl0gPSBhWzJdO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFNldCB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzMgdG8gdGhlIGdpdmVuIHZhbHVlc1xuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge051bWJlcn0geCBYIGNvbXBvbmVudFxuICogQHBhcmFtIHtOdW1iZXJ9IHkgWSBjb21wb25lbnRcbiAqIEBwYXJhbSB7TnVtYmVyfSB6IFogY29tcG9uZW50XG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbnZlYzMuc2V0ID0gZnVuY3Rpb24ob3V0LCB4LCB5LCB6KSB7XG4gICAgb3V0WzBdID0geDtcbiAgICBvdXRbMV0gPSB5O1xuICAgIG91dFsyXSA9IHo7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQWRkcyB0d28gdmVjMydzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG52ZWMzLmFkZCA9IGZ1bmN0aW9uKG91dCwgYSwgYikge1xuICAgIG91dFswXSA9IGFbMF0gKyBiWzBdO1xuICAgIG91dFsxXSA9IGFbMV0gKyBiWzFdO1xuICAgIG91dFsyXSA9IGFbMl0gKyBiWzJdO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFN1YnRyYWN0cyB2ZWN0b3IgYiBmcm9tIHZlY3RvciBhXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG52ZWMzLnN1YnRyYWN0ID0gZnVuY3Rpb24ob3V0LCBhLCBiKSB7XG4gICAgb3V0WzBdID0gYVswXSAtIGJbMF07XG4gICAgb3V0WzFdID0gYVsxXSAtIGJbMV07XG4gICAgb3V0WzJdID0gYVsyXSAtIGJbMl07XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayB2ZWMzLnN1YnRyYWN0fVxuICogQGZ1bmN0aW9uXG4gKi9cbnZlYzMuc3ViID0gdmVjMy5zdWJ0cmFjdDtcblxuLyoqXG4gKiBNdWx0aXBsaWVzIHR3byB2ZWMzJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbnZlYzMubXVsdGlwbHkgPSBmdW5jdGlvbihvdXQsIGEsIGIpIHtcbiAgICBvdXRbMF0gPSBhWzBdICogYlswXTtcbiAgICBvdXRbMV0gPSBhWzFdICogYlsxXTtcbiAgICBvdXRbMl0gPSBhWzJdICogYlsyXTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzMubXVsdGlwbHl9XG4gKiBAZnVuY3Rpb25cbiAqL1xudmVjMy5tdWwgPSB2ZWMzLm11bHRpcGx5O1xuXG4vKipcbiAqIERpdmlkZXMgdHdvIHZlYzMnc1xuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjM30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xudmVjMy5kaXZpZGUgPSBmdW5jdGlvbihvdXQsIGEsIGIpIHtcbiAgICBvdXRbMF0gPSBhWzBdIC8gYlswXTtcbiAgICBvdXRbMV0gPSBhWzFdIC8gYlsxXTtcbiAgICBvdXRbMl0gPSBhWzJdIC8gYlsyXTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzMuZGl2aWRlfVxuICogQGZ1bmN0aW9uXG4gKi9cbnZlYzMuZGl2ID0gdmVjMy5kaXZpZGU7XG5cbi8qKlxuICogTWF0aC5jZWlsIHRoZSBjb21wb25lbnRzIG9mIGEgdmVjM1xuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdmVjdG9yIHRvIGNlaWxcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xudmVjMy5jZWlsID0gZnVuY3Rpb24gKG91dCwgYSkge1xuICAgIG91dFswXSA9IE1hdGguY2VpbChhWzBdKTtcbiAgICBvdXRbMV0gPSBNYXRoLmNlaWwoYVsxXSk7XG4gICAgb3V0WzJdID0gTWF0aC5jZWlsKGFbMl0pO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIE1hdGguZmxvb3IgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWMzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSB2ZWN0b3IgdG8gZmxvb3JcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xudmVjMy5mbG9vciA9IGZ1bmN0aW9uIChvdXQsIGEpIHtcbiAgICBvdXRbMF0gPSBNYXRoLmZsb29yKGFbMF0pO1xuICAgIG91dFsxXSA9IE1hdGguZmxvb3IoYVsxXSk7XG4gICAgb3V0WzJdID0gTWF0aC5mbG9vcihhWzJdKTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBtaW5pbXVtIG9mIHR3byB2ZWMzJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbnZlYzMubWluID0gZnVuY3Rpb24ob3V0LCBhLCBiKSB7XG4gICAgb3V0WzBdID0gTWF0aC5taW4oYVswXSwgYlswXSk7XG4gICAgb3V0WzFdID0gTWF0aC5taW4oYVsxXSwgYlsxXSk7XG4gICAgb3V0WzJdID0gTWF0aC5taW4oYVsyXSwgYlsyXSk7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgbWF4aW11bSBvZiB0d28gdmVjMydzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG52ZWMzLm1heCA9IGZ1bmN0aW9uKG91dCwgYSwgYikge1xuICAgIG91dFswXSA9IE1hdGgubWF4KGFbMF0sIGJbMF0pO1xuICAgIG91dFsxXSA9IE1hdGgubWF4KGFbMV0sIGJbMV0pO1xuICAgIG91dFsyXSA9IE1hdGgubWF4KGFbMl0sIGJbMl0pO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIE1hdGgucm91bmQgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWMzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSB2ZWN0b3IgdG8gcm91bmRcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xudmVjMy5yb3VuZCA9IGZ1bmN0aW9uIChvdXQsIGEpIHtcbiAgICBvdXRbMF0gPSBNYXRoLnJvdW5kKGFbMF0pO1xuICAgIG91dFsxXSA9IE1hdGgucm91bmQoYVsxXSk7XG4gICAgb3V0WzJdID0gTWF0aC5yb3VuZChhWzJdKTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBTY2FsZXMgYSB2ZWMzIGJ5IGEgc2NhbGFyIG51bWJlclxuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdGhlIHZlY3RvciB0byBzY2FsZVxuICogQHBhcmFtIHtOdW1iZXJ9IGIgYW1vdW50IHRvIHNjYWxlIHRoZSB2ZWN0b3IgYnlcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xudmVjMy5zY2FsZSA9IGZ1bmN0aW9uKG91dCwgYSwgYikge1xuICAgIG91dFswXSA9IGFbMF0gKiBiO1xuICAgIG91dFsxXSA9IGFbMV0gKiBiO1xuICAgIG91dFsyXSA9IGFbMl0gKiBiO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIEFkZHMgdHdvIHZlYzMncyBhZnRlciBzY2FsaW5nIHRoZSBzZWNvbmQgb3BlcmFuZCBieSBhIHNjYWxhciB2YWx1ZVxuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjM30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEBwYXJhbSB7TnVtYmVyfSBzY2FsZSB0aGUgYW1vdW50IHRvIHNjYWxlIGIgYnkgYmVmb3JlIGFkZGluZ1xuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG52ZWMzLnNjYWxlQW5kQWRkID0gZnVuY3Rpb24ob3V0LCBhLCBiLCBzY2FsZSkge1xuICAgIG91dFswXSA9IGFbMF0gKyAoYlswXSAqIHNjYWxlKTtcbiAgICBvdXRbMV0gPSBhWzFdICsgKGJbMV0gKiBzY2FsZSk7XG4gICAgb3V0WzJdID0gYVsyXSArIChiWzJdICogc2NhbGUpO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGV1Y2xpZGlhbiBkaXN0YW5jZSBiZXR3ZWVuIHR3byB2ZWMzJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjM30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IGRpc3RhbmNlIGJldHdlZW4gYSBhbmQgYlxuICovXG52ZWMzLmRpc3RhbmNlID0gZnVuY3Rpb24oYSwgYikge1xuICAgIHZhciB4ID0gYlswXSAtIGFbMF0sXG4gICAgICAgIHkgPSBiWzFdIC0gYVsxXSxcbiAgICAgICAgeiA9IGJbMl0gLSBhWzJdO1xuICAgIHJldHVybiBNYXRoLnNxcnQoeCp4ICsgeSp5ICsgeip6KTtcbn07XG5cbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayB2ZWMzLmRpc3RhbmNlfVxuICogQGZ1bmN0aW9uXG4gKi9cbnZlYzMuZGlzdCA9IHZlYzMuZGlzdGFuY2U7XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgc3F1YXJlZCBldWNsaWRpYW4gZGlzdGFuY2UgYmV0d2VlbiB0d28gdmVjMydzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBzcXVhcmVkIGRpc3RhbmNlIGJldHdlZW4gYSBhbmQgYlxuICovXG52ZWMzLnNxdWFyZWREaXN0YW5jZSA9IGZ1bmN0aW9uKGEsIGIpIHtcbiAgICB2YXIgeCA9IGJbMF0gLSBhWzBdLFxuICAgICAgICB5ID0gYlsxXSAtIGFbMV0sXG4gICAgICAgIHogPSBiWzJdIC0gYVsyXTtcbiAgICByZXR1cm4geCp4ICsgeSp5ICsgeip6O1xufTtcblxuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzMuc3F1YXJlZERpc3RhbmNlfVxuICogQGZ1bmN0aW9uXG4gKi9cbnZlYzMuc3FyRGlzdCA9IHZlYzMuc3F1YXJlZERpc3RhbmNlO1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGxlbmd0aCBvZiBhIHZlYzNcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdmVjdG9yIHRvIGNhbGN1bGF0ZSBsZW5ndGggb2ZcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IGxlbmd0aCBvZiBhXG4gKi9cbnZlYzMubGVuZ3RoID0gZnVuY3Rpb24gKGEpIHtcbiAgICB2YXIgeCA9IGFbMF0sXG4gICAgICAgIHkgPSBhWzFdLFxuICAgICAgICB6ID0gYVsyXTtcbiAgICByZXR1cm4gTWF0aC5zcXJ0KHgqeCArIHkqeSArIHoqeik7XG59O1xuXG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjMy5sZW5ndGh9XG4gKiBAZnVuY3Rpb25cbiAqL1xudmVjMy5sZW4gPSB2ZWMzLmxlbmd0aDtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBzcXVhcmVkIGxlbmd0aCBvZiBhIHZlYzNcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdmVjdG9yIHRvIGNhbGN1bGF0ZSBzcXVhcmVkIGxlbmd0aCBvZlxuICogQHJldHVybnMge051bWJlcn0gc3F1YXJlZCBsZW5ndGggb2YgYVxuICovXG52ZWMzLnNxdWFyZWRMZW5ndGggPSBmdW5jdGlvbiAoYSkge1xuICAgIHZhciB4ID0gYVswXSxcbiAgICAgICAgeSA9IGFbMV0sXG4gICAgICAgIHogPSBhWzJdO1xuICAgIHJldHVybiB4KnggKyB5KnkgKyB6Kno7XG59O1xuXG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjMy5zcXVhcmVkTGVuZ3RofVxuICogQGZ1bmN0aW9uXG4gKi9cbnZlYzMuc3FyTGVuID0gdmVjMy5zcXVhcmVkTGVuZ3RoO1xuXG4vKipcbiAqIE5lZ2F0ZXMgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWMzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSB2ZWN0b3IgdG8gbmVnYXRlXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbnZlYzMubmVnYXRlID0gZnVuY3Rpb24ob3V0LCBhKSB7XG4gICAgb3V0WzBdID0gLWFbMF07XG4gICAgb3V0WzFdID0gLWFbMV07XG4gICAgb3V0WzJdID0gLWFbMl07XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgaW52ZXJzZSBvZiB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzNcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHZlY3RvciB0byBpbnZlcnRcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xudmVjMy5pbnZlcnNlID0gZnVuY3Rpb24ob3V0LCBhKSB7XG4gIG91dFswXSA9IDEuMCAvIGFbMF07XG4gIG91dFsxXSA9IDEuMCAvIGFbMV07XG4gIG91dFsyXSA9IDEuMCAvIGFbMl07XG4gIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIE5vcm1hbGl6ZSBhIHZlYzNcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHZlY3RvciB0byBub3JtYWxpemVcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xudmVjMy5ub3JtYWxpemUgPSBmdW5jdGlvbihvdXQsIGEpIHtcbiAgICB2YXIgeCA9IGFbMF0sXG4gICAgICAgIHkgPSBhWzFdLFxuICAgICAgICB6ID0gYVsyXTtcbiAgICB2YXIgbGVuID0geCp4ICsgeSp5ICsgeip6O1xuICAgIGlmIChsZW4gPiAwKSB7XG4gICAgICAgIC8vVE9ETzogZXZhbHVhdGUgdXNlIG9mIGdsbV9pbnZzcXJ0IGhlcmU/XG4gICAgICAgIGxlbiA9IDEgLyBNYXRoLnNxcnQobGVuKTtcbiAgICAgICAgb3V0WzBdID0gYVswXSAqIGxlbjtcbiAgICAgICAgb3V0WzFdID0gYVsxXSAqIGxlbjtcbiAgICAgICAgb3V0WzJdID0gYVsyXSAqIGxlbjtcbiAgICB9XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgZG90IHByb2R1Y3Qgb2YgdHdvIHZlYzMnc1xuICpcbiAqIEBwYXJhbSB7dmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge051bWJlcn0gZG90IHByb2R1Y3Qgb2YgYSBhbmQgYlxuICovXG52ZWMzLmRvdCA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgcmV0dXJuIGFbMF0gKiBiWzBdICsgYVsxXSAqIGJbMV0gKyBhWzJdICogYlsyXTtcbn07XG5cbi8qKlxuICogQ29tcHV0ZXMgdGhlIGNyb3NzIHByb2R1Y3Qgb2YgdHdvIHZlYzMnc1xuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjM30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xudmVjMy5jcm9zcyA9IGZ1bmN0aW9uKG91dCwgYSwgYikge1xuICAgIHZhciBheCA9IGFbMF0sIGF5ID0gYVsxXSwgYXogPSBhWzJdLFxuICAgICAgICBieCA9IGJbMF0sIGJ5ID0gYlsxXSwgYnogPSBiWzJdO1xuXG4gICAgb3V0WzBdID0gYXkgKiBieiAtIGF6ICogYnk7XG4gICAgb3V0WzFdID0gYXogKiBieCAtIGF4ICogYno7XG4gICAgb3V0WzJdID0gYXggKiBieSAtIGF5ICogYng7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogUGVyZm9ybXMgYSBsaW5lYXIgaW50ZXJwb2xhdGlvbiBiZXR3ZWVuIHR3byB2ZWMzJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcGFyYW0ge051bWJlcn0gdCBpbnRlcnBvbGF0aW9uIGFtb3VudCBiZXR3ZWVuIHRoZSB0d28gaW5wdXRzXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbnZlYzMubGVycCA9IGZ1bmN0aW9uIChvdXQsIGEsIGIsIHQpIHtcbiAgICB2YXIgYXggPSBhWzBdLFxuICAgICAgICBheSA9IGFbMV0sXG4gICAgICAgIGF6ID0gYVsyXTtcbiAgICBvdXRbMF0gPSBheCArIHQgKiAoYlswXSAtIGF4KTtcbiAgICBvdXRbMV0gPSBheSArIHQgKiAoYlsxXSAtIGF5KTtcbiAgICBvdXRbMl0gPSBheiArIHQgKiAoYlsyXSAtIGF6KTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBQZXJmb3JtcyBhIGhlcm1pdGUgaW50ZXJwb2xhdGlvbiB3aXRoIHR3byBjb250cm9sIHBvaW50c1xuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjM30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjM30gYyB0aGUgdGhpcmQgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMzfSBkIHRoZSBmb3VydGggb3BlcmFuZFxuICogQHBhcmFtIHtOdW1iZXJ9IHQgaW50ZXJwb2xhdGlvbiBhbW91bnQgYmV0d2VlbiB0aGUgdHdvIGlucHV0c1xuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG52ZWMzLmhlcm1pdGUgPSBmdW5jdGlvbiAob3V0LCBhLCBiLCBjLCBkLCB0KSB7XG4gIHZhciBmYWN0b3JUaW1lczIgPSB0ICogdCxcbiAgICAgIGZhY3RvcjEgPSBmYWN0b3JUaW1lczIgKiAoMiAqIHQgLSAzKSArIDEsXG4gICAgICBmYWN0b3IyID0gZmFjdG9yVGltZXMyICogKHQgLSAyKSArIHQsXG4gICAgICBmYWN0b3IzID0gZmFjdG9yVGltZXMyICogKHQgLSAxKSxcbiAgICAgIGZhY3RvcjQgPSBmYWN0b3JUaW1lczIgKiAoMyAtIDIgKiB0KTtcbiAgXG4gIG91dFswXSA9IGFbMF0gKiBmYWN0b3IxICsgYlswXSAqIGZhY3RvcjIgKyBjWzBdICogZmFjdG9yMyArIGRbMF0gKiBmYWN0b3I0O1xuICBvdXRbMV0gPSBhWzFdICogZmFjdG9yMSArIGJbMV0gKiBmYWN0b3IyICsgY1sxXSAqIGZhY3RvcjMgKyBkWzFdICogZmFjdG9yNDtcbiAgb3V0WzJdID0gYVsyXSAqIGZhY3RvcjEgKyBiWzJdICogZmFjdG9yMiArIGNbMl0gKiBmYWN0b3IzICsgZFsyXSAqIGZhY3RvcjQ7XG4gIFxuICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBQZXJmb3JtcyBhIGJlemllciBpbnRlcnBvbGF0aW9uIHdpdGggdHdvIGNvbnRyb2wgcG9pbnRzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMzfSBjIHRoZSB0aGlyZCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzN9IGQgdGhlIGZvdXJ0aCBvcGVyYW5kXG4gKiBAcGFyYW0ge051bWJlcn0gdCBpbnRlcnBvbGF0aW9uIGFtb3VudCBiZXR3ZWVuIHRoZSB0d28gaW5wdXRzXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbnZlYzMuYmV6aWVyID0gZnVuY3Rpb24gKG91dCwgYSwgYiwgYywgZCwgdCkge1xuICB2YXIgaW52ZXJzZUZhY3RvciA9IDEgLSB0LFxuICAgICAgaW52ZXJzZUZhY3RvclRpbWVzVHdvID0gaW52ZXJzZUZhY3RvciAqIGludmVyc2VGYWN0b3IsXG4gICAgICBmYWN0b3JUaW1lczIgPSB0ICogdCxcbiAgICAgIGZhY3RvcjEgPSBpbnZlcnNlRmFjdG9yVGltZXNUd28gKiBpbnZlcnNlRmFjdG9yLFxuICAgICAgZmFjdG9yMiA9IDMgKiB0ICogaW52ZXJzZUZhY3RvclRpbWVzVHdvLFxuICAgICAgZmFjdG9yMyA9IDMgKiBmYWN0b3JUaW1lczIgKiBpbnZlcnNlRmFjdG9yLFxuICAgICAgZmFjdG9yNCA9IGZhY3RvclRpbWVzMiAqIHQ7XG4gIFxuICBvdXRbMF0gPSBhWzBdICogZmFjdG9yMSArIGJbMF0gKiBmYWN0b3IyICsgY1swXSAqIGZhY3RvcjMgKyBkWzBdICogZmFjdG9yNDtcbiAgb3V0WzFdID0gYVsxXSAqIGZhY3RvcjEgKyBiWzFdICogZmFjdG9yMiArIGNbMV0gKiBmYWN0b3IzICsgZFsxXSAqIGZhY3RvcjQ7XG4gIG91dFsyXSA9IGFbMl0gKiBmYWN0b3IxICsgYlsyXSAqIGZhY3RvcjIgKyBjWzJdICogZmFjdG9yMyArIGRbMl0gKiBmYWN0b3I0O1xuICBcbiAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogR2VuZXJhdGVzIGEgcmFuZG9tIHZlY3RvciB3aXRoIHRoZSBnaXZlbiBzY2FsZVxuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge051bWJlcn0gW3NjYWxlXSBMZW5ndGggb2YgdGhlIHJlc3VsdGluZyB2ZWN0b3IuIElmIG9tbWl0dGVkLCBhIHVuaXQgdmVjdG9yIHdpbGwgYmUgcmV0dXJuZWRcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xudmVjMy5yYW5kb20gPSBmdW5jdGlvbiAob3V0LCBzY2FsZSkge1xuICAgIHNjYWxlID0gc2NhbGUgfHwgMS4wO1xuXG4gICAgdmFyIHIgPSBnbE1hdHJpeC5SQU5ET00oKSAqIDIuMCAqIE1hdGguUEk7XG4gICAgdmFyIHogPSAoZ2xNYXRyaXguUkFORE9NKCkgKiAyLjApIC0gMS4wO1xuICAgIHZhciB6U2NhbGUgPSBNYXRoLnNxcnQoMS4wLXoqeikgKiBzY2FsZTtcblxuICAgIG91dFswXSA9IE1hdGguY29zKHIpICogelNjYWxlO1xuICAgIG91dFsxXSA9IE1hdGguc2luKHIpICogelNjYWxlO1xuICAgIG91dFsyXSA9IHogKiBzY2FsZTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBUcmFuc2Zvcm1zIHRoZSB2ZWMzIHdpdGggYSBtYXQ0LlxuICogNHRoIHZlY3RvciBjb21wb25lbnQgaXMgaW1wbGljaXRseSAnMSdcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSB2ZWN0b3IgdG8gdHJhbnNmb3JtXG4gKiBAcGFyYW0ge21hdDR9IG0gbWF0cml4IHRvIHRyYW5zZm9ybSB3aXRoXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbnZlYzMudHJhbnNmb3JtTWF0NCA9IGZ1bmN0aW9uKG91dCwgYSwgbSkge1xuICAgIHZhciB4ID0gYVswXSwgeSA9IGFbMV0sIHogPSBhWzJdLFxuICAgICAgICB3ID0gbVszXSAqIHggKyBtWzddICogeSArIG1bMTFdICogeiArIG1bMTVdO1xuICAgIHcgPSB3IHx8IDEuMDtcbiAgICBvdXRbMF0gPSAobVswXSAqIHggKyBtWzRdICogeSArIG1bOF0gKiB6ICsgbVsxMl0pIC8gdztcbiAgICBvdXRbMV0gPSAobVsxXSAqIHggKyBtWzVdICogeSArIG1bOV0gKiB6ICsgbVsxM10pIC8gdztcbiAgICBvdXRbMl0gPSAobVsyXSAqIHggKyBtWzZdICogeSArIG1bMTBdICogeiArIG1bMTRdKSAvIHc7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogVHJhbnNmb3JtcyB0aGUgdmVjMyB3aXRoIGEgbWF0My5cbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSB2ZWN0b3IgdG8gdHJhbnNmb3JtXG4gKiBAcGFyYW0ge21hdDR9IG0gdGhlIDN4MyBtYXRyaXggdG8gdHJhbnNmb3JtIHdpdGhcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xudmVjMy50cmFuc2Zvcm1NYXQzID0gZnVuY3Rpb24ob3V0LCBhLCBtKSB7XG4gICAgdmFyIHggPSBhWzBdLCB5ID0gYVsxXSwgeiA9IGFbMl07XG4gICAgb3V0WzBdID0geCAqIG1bMF0gKyB5ICogbVszXSArIHogKiBtWzZdO1xuICAgIG91dFsxXSA9IHggKiBtWzFdICsgeSAqIG1bNF0gKyB6ICogbVs3XTtcbiAgICBvdXRbMl0gPSB4ICogbVsyXSArIHkgKiBtWzVdICsgeiAqIG1bOF07XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogVHJhbnNmb3JtcyB0aGUgdmVjMyB3aXRoIGEgcXVhdFxuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdGhlIHZlY3RvciB0byB0cmFuc2Zvcm1cbiAqIEBwYXJhbSB7cXVhdH0gcSBxdWF0ZXJuaW9uIHRvIHRyYW5zZm9ybSB3aXRoXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbnZlYzMudHJhbnNmb3JtUXVhdCA9IGZ1bmN0aW9uKG91dCwgYSwgcSkge1xuICAgIC8vIGJlbmNobWFya3M6IGh0dHA6Ly9qc3BlcmYuY29tL3F1YXRlcm5pb24tdHJhbnNmb3JtLXZlYzMtaW1wbGVtZW50YXRpb25zXG5cbiAgICB2YXIgeCA9IGFbMF0sIHkgPSBhWzFdLCB6ID0gYVsyXSxcbiAgICAgICAgcXggPSBxWzBdLCBxeSA9IHFbMV0sIHF6ID0gcVsyXSwgcXcgPSBxWzNdLFxuXG4gICAgICAgIC8vIGNhbGN1bGF0ZSBxdWF0ICogdmVjXG4gICAgICAgIGl4ID0gcXcgKiB4ICsgcXkgKiB6IC0gcXogKiB5LFxuICAgICAgICBpeSA9IHF3ICogeSArIHF6ICogeCAtIHF4ICogeixcbiAgICAgICAgaXogPSBxdyAqIHogKyBxeCAqIHkgLSBxeSAqIHgsXG4gICAgICAgIGl3ID0gLXF4ICogeCAtIHF5ICogeSAtIHF6ICogejtcblxuICAgIC8vIGNhbGN1bGF0ZSByZXN1bHQgKiBpbnZlcnNlIHF1YXRcbiAgICBvdXRbMF0gPSBpeCAqIHF3ICsgaXcgKiAtcXggKyBpeSAqIC1xeiAtIGl6ICogLXF5O1xuICAgIG91dFsxXSA9IGl5ICogcXcgKyBpdyAqIC1xeSArIGl6ICogLXF4IC0gaXggKiAtcXo7XG4gICAgb3V0WzJdID0gaXogKiBxdyArIGl3ICogLXF6ICsgaXggKiAtcXkgLSBpeSAqIC1xeDtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBSb3RhdGUgYSAzRCB2ZWN0b3IgYXJvdW5kIHRoZSB4LWF4aXNcbiAqIEBwYXJhbSB7dmVjM30gb3V0IFRoZSByZWNlaXZpbmcgdmVjM1xuICogQHBhcmFtIHt2ZWMzfSBhIFRoZSB2ZWMzIHBvaW50IHRvIHJvdGF0ZVxuICogQHBhcmFtIHt2ZWMzfSBiIFRoZSBvcmlnaW4gb2YgdGhlIHJvdGF0aW9uXG4gKiBAcGFyYW0ge051bWJlcn0gYyBUaGUgYW5nbGUgb2Ygcm90YXRpb25cbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xudmVjMy5yb3RhdGVYID0gZnVuY3Rpb24ob3V0LCBhLCBiLCBjKXtcbiAgIHZhciBwID0gW10sIHI9W107XG5cdCAgLy9UcmFuc2xhdGUgcG9pbnQgdG8gdGhlIG9yaWdpblxuXHQgIHBbMF0gPSBhWzBdIC0gYlswXTtcblx0ICBwWzFdID0gYVsxXSAtIGJbMV07XG4gIFx0cFsyXSA9IGFbMl0gLSBiWzJdO1xuXG5cdCAgLy9wZXJmb3JtIHJvdGF0aW9uXG5cdCAgclswXSA9IHBbMF07XG5cdCAgclsxXSA9IHBbMV0qTWF0aC5jb3MoYykgLSBwWzJdKk1hdGguc2luKGMpO1xuXHQgIHJbMl0gPSBwWzFdKk1hdGguc2luKGMpICsgcFsyXSpNYXRoLmNvcyhjKTtcblxuXHQgIC8vdHJhbnNsYXRlIHRvIGNvcnJlY3QgcG9zaXRpb25cblx0ICBvdXRbMF0gPSByWzBdICsgYlswXTtcblx0ICBvdXRbMV0gPSByWzFdICsgYlsxXTtcblx0ICBvdXRbMl0gPSByWzJdICsgYlsyXTtcblxuICBcdHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFJvdGF0ZSBhIDNEIHZlY3RvciBhcm91bmQgdGhlIHktYXhpc1xuICogQHBhcmFtIHt2ZWMzfSBvdXQgVGhlIHJlY2VpdmluZyB2ZWMzXG4gKiBAcGFyYW0ge3ZlYzN9IGEgVGhlIHZlYzMgcG9pbnQgdG8gcm90YXRlXG4gKiBAcGFyYW0ge3ZlYzN9IGIgVGhlIG9yaWdpbiBvZiB0aGUgcm90YXRpb25cbiAqIEBwYXJhbSB7TnVtYmVyfSBjIFRoZSBhbmdsZSBvZiByb3RhdGlvblxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG52ZWMzLnJvdGF0ZVkgPSBmdW5jdGlvbihvdXQsIGEsIGIsIGMpe1xuICBcdHZhciBwID0gW10sIHI9W107XG4gIFx0Ly9UcmFuc2xhdGUgcG9pbnQgdG8gdGhlIG9yaWdpblxuICBcdHBbMF0gPSBhWzBdIC0gYlswXTtcbiAgXHRwWzFdID0gYVsxXSAtIGJbMV07XG4gIFx0cFsyXSA9IGFbMl0gLSBiWzJdO1xuICBcbiAgXHQvL3BlcmZvcm0gcm90YXRpb25cbiAgXHRyWzBdID0gcFsyXSpNYXRoLnNpbihjKSArIHBbMF0qTWF0aC5jb3MoYyk7XG4gIFx0clsxXSA9IHBbMV07XG4gIFx0clsyXSA9IHBbMl0qTWF0aC5jb3MoYykgLSBwWzBdKk1hdGguc2luKGMpO1xuICBcbiAgXHQvL3RyYW5zbGF0ZSB0byBjb3JyZWN0IHBvc2l0aW9uXG4gIFx0b3V0WzBdID0gclswXSArIGJbMF07XG4gIFx0b3V0WzFdID0gclsxXSArIGJbMV07XG4gIFx0b3V0WzJdID0gclsyXSArIGJbMl07XG4gIFxuICBcdHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFJvdGF0ZSBhIDNEIHZlY3RvciBhcm91bmQgdGhlIHotYXhpc1xuICogQHBhcmFtIHt2ZWMzfSBvdXQgVGhlIHJlY2VpdmluZyB2ZWMzXG4gKiBAcGFyYW0ge3ZlYzN9IGEgVGhlIHZlYzMgcG9pbnQgdG8gcm90YXRlXG4gKiBAcGFyYW0ge3ZlYzN9IGIgVGhlIG9yaWdpbiBvZiB0aGUgcm90YXRpb25cbiAqIEBwYXJhbSB7TnVtYmVyfSBjIFRoZSBhbmdsZSBvZiByb3RhdGlvblxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG52ZWMzLnJvdGF0ZVogPSBmdW5jdGlvbihvdXQsIGEsIGIsIGMpe1xuICBcdHZhciBwID0gW10sIHI9W107XG4gIFx0Ly9UcmFuc2xhdGUgcG9pbnQgdG8gdGhlIG9yaWdpblxuICBcdHBbMF0gPSBhWzBdIC0gYlswXTtcbiAgXHRwWzFdID0gYVsxXSAtIGJbMV07XG4gIFx0cFsyXSA9IGFbMl0gLSBiWzJdO1xuICBcbiAgXHQvL3BlcmZvcm0gcm90YXRpb25cbiAgXHRyWzBdID0gcFswXSpNYXRoLmNvcyhjKSAtIHBbMV0qTWF0aC5zaW4oYyk7XG4gIFx0clsxXSA9IHBbMF0qTWF0aC5zaW4oYykgKyBwWzFdKk1hdGguY29zKGMpO1xuICBcdHJbMl0gPSBwWzJdO1xuICBcbiAgXHQvL3RyYW5zbGF0ZSB0byBjb3JyZWN0IHBvc2l0aW9uXG4gIFx0b3V0WzBdID0gclswXSArIGJbMF07XG4gIFx0b3V0WzFdID0gclsxXSArIGJbMV07XG4gIFx0b3V0WzJdID0gclsyXSArIGJbMl07XG4gIFxuICBcdHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFBlcmZvcm0gc29tZSBvcGVyYXRpb24gb3ZlciBhbiBhcnJheSBvZiB2ZWMzcy5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBhIHRoZSBhcnJheSBvZiB2ZWN0b3JzIHRvIGl0ZXJhdGUgb3ZlclxuICogQHBhcmFtIHtOdW1iZXJ9IHN0cmlkZSBOdW1iZXIgb2YgZWxlbWVudHMgYmV0d2VlbiB0aGUgc3RhcnQgb2YgZWFjaCB2ZWMzLiBJZiAwIGFzc3VtZXMgdGlnaHRseSBwYWNrZWRcbiAqIEBwYXJhbSB7TnVtYmVyfSBvZmZzZXQgTnVtYmVyIG9mIGVsZW1lbnRzIHRvIHNraXAgYXQgdGhlIGJlZ2lubmluZyBvZiB0aGUgYXJyYXlcbiAqIEBwYXJhbSB7TnVtYmVyfSBjb3VudCBOdW1iZXIgb2YgdmVjM3MgdG8gaXRlcmF0ZSBvdmVyLiBJZiAwIGl0ZXJhdGVzIG92ZXIgZW50aXJlIGFycmF5XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBGdW5jdGlvbiB0byBjYWxsIGZvciBlYWNoIHZlY3RvciBpbiB0aGUgYXJyYXlcbiAqIEBwYXJhbSB7T2JqZWN0fSBbYXJnXSBhZGRpdGlvbmFsIGFyZ3VtZW50IHRvIHBhc3MgdG8gZm5cbiAqIEByZXR1cm5zIHtBcnJheX0gYVxuICogQGZ1bmN0aW9uXG4gKi9cbnZlYzMuZm9yRWFjaCA9IChmdW5jdGlvbigpIHtcbiAgICB2YXIgdmVjID0gdmVjMy5jcmVhdGUoKTtcblxuICAgIHJldHVybiBmdW5jdGlvbihhLCBzdHJpZGUsIG9mZnNldCwgY291bnQsIGZuLCBhcmcpIHtcbiAgICAgICAgdmFyIGksIGw7XG4gICAgICAgIGlmKCFzdHJpZGUpIHtcbiAgICAgICAgICAgIHN0cmlkZSA9IDM7XG4gICAgICAgIH1cblxuICAgICAgICBpZighb2Zmc2V0KSB7XG4gICAgICAgICAgICBvZmZzZXQgPSAwO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBpZihjb3VudCkge1xuICAgICAgICAgICAgbCA9IE1hdGgubWluKChjb3VudCAqIHN0cmlkZSkgKyBvZmZzZXQsIGEubGVuZ3RoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGwgPSBhLmxlbmd0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvcihpID0gb2Zmc2V0OyBpIDwgbDsgaSArPSBzdHJpZGUpIHtcbiAgICAgICAgICAgIHZlY1swXSA9IGFbaV07IHZlY1sxXSA9IGFbaSsxXTsgdmVjWzJdID0gYVtpKzJdO1xuICAgICAgICAgICAgZm4odmVjLCB2ZWMsIGFyZyk7XG4gICAgICAgICAgICBhW2ldID0gdmVjWzBdOyBhW2krMV0gPSB2ZWNbMV07IGFbaSsyXSA9IHZlY1syXTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgcmV0dXJuIGE7XG4gICAgfTtcbn0pKCk7XG5cbi8qKlxuICogR2V0IHRoZSBhbmdsZSBiZXR3ZWVuIHR3byAzRCB2ZWN0b3JzXG4gKiBAcGFyYW0ge3ZlYzN9IGEgVGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjM30gYiBUaGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IFRoZSBhbmdsZSBpbiByYWRpYW5zXG4gKi9cbnZlYzMuYW5nbGUgPSBmdW5jdGlvbihhLCBiKSB7XG4gICBcbiAgICB2YXIgdGVtcEEgPSB2ZWMzLmZyb21WYWx1ZXMoYVswXSwgYVsxXSwgYVsyXSk7XG4gICAgdmFyIHRlbXBCID0gdmVjMy5mcm9tVmFsdWVzKGJbMF0sIGJbMV0sIGJbMl0pO1xuIFxuICAgIHZlYzMubm9ybWFsaXplKHRlbXBBLCB0ZW1wQSk7XG4gICAgdmVjMy5ub3JtYWxpemUodGVtcEIsIHRlbXBCKTtcbiBcbiAgICB2YXIgY29zaW5lID0gdmVjMy5kb3QodGVtcEEsIHRlbXBCKTtcblxuICAgIGlmKGNvc2luZSA+IDEuMCl7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBNYXRoLmFjb3MoY29zaW5lKTtcbiAgICB9ICAgICBcbn07XG5cbi8qKlxuICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhIHZlY3RvclxuICpcbiAqIEBwYXJhbSB7dmVjM30gdmVjIHZlY3RvciB0byByZXByZXNlbnQgYXMgYSBzdHJpbmdcbiAqIEByZXR1cm5zIHtTdHJpbmd9IHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgdmVjdG9yXG4gKi9cbnZlYzMuc3RyID0gZnVuY3Rpb24gKGEpIHtcbiAgICByZXR1cm4gJ3ZlYzMoJyArIGFbMF0gKyAnLCAnICsgYVsxXSArICcsICcgKyBhWzJdICsgJyknO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSB2ZWN0b3JzIGhhdmUgZXhhY3RseSB0aGUgc2FtZSBlbGVtZW50cyBpbiB0aGUgc2FtZSBwb3NpdGlvbiAod2hlbiBjb21wYXJlZCB3aXRoID09PSlcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IGEgVGhlIGZpcnN0IHZlY3Rvci5cbiAqIEBwYXJhbSB7dmVjM30gYiBUaGUgc2Vjb25kIHZlY3Rvci5cbiAqIEByZXR1cm5zIHtCb29sZWFufSBUcnVlIGlmIHRoZSB2ZWN0b3JzIGFyZSBlcXVhbCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICovXG52ZWMzLmV4YWN0RXF1YWxzID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICByZXR1cm4gYVswXSA9PT0gYlswXSAmJiBhWzFdID09PSBiWzFdICYmIGFbMl0gPT09IGJbMl07XG59O1xuXG4vKipcbiAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIHZlY3RvcnMgaGF2ZSBhcHByb3hpbWF0ZWx5IHRoZSBzYW1lIGVsZW1lbnRzIGluIHRoZSBzYW1lIHBvc2l0aW9uLlxuICpcbiAqIEBwYXJhbSB7dmVjM30gYSBUaGUgZmlyc3QgdmVjdG9yLlxuICogQHBhcmFtIHt2ZWMzfSBiIFRoZSBzZWNvbmQgdmVjdG9yLlxuICogQHJldHVybnMge0Jvb2xlYW59IFRydWUgaWYgdGhlIHZlY3RvcnMgYXJlIGVxdWFsLCBmYWxzZSBvdGhlcndpc2UuXG4gKi9cbnZlYzMuZXF1YWxzID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICB2YXIgYTAgPSBhWzBdLCBhMSA9IGFbMV0sIGEyID0gYVsyXTtcbiAgICB2YXIgYjAgPSBiWzBdLCBiMSA9IGJbMV0sIGIyID0gYlsyXTtcbiAgICByZXR1cm4gKE1hdGguYWJzKGEwIC0gYjApIDw9IGdsTWF0cml4LkVQU0lMT04qTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMCksIE1hdGguYWJzKGIwKSkgJiZcbiAgICAgICAgICAgIE1hdGguYWJzKGExIC0gYjEpIDw9IGdsTWF0cml4LkVQU0lMT04qTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMSksIE1hdGguYWJzKGIxKSkgJiZcbiAgICAgICAgICAgIE1hdGguYWJzKGEyIC0gYjIpIDw9IGdsTWF0cml4LkVQU0lMT04qTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMiksIE1hdGguYWJzKGIyKSkpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSB2ZWMzO1xuIiwiLyogQ29weXJpZ2h0IChjKSAyMDE1LCBCcmFuZG9uIEpvbmVzLCBDb2xpbiBNYWNLZW56aWUgSVYuXG5cblBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbm9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbmluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbnRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbmNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblxuVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbmFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG5JTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbkZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbk9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cblRIRSBTT0ZUV0FSRS4gKi9cblxudmFyIGdsTWF0cml4ID0gcmVxdWlyZShcIi4vY29tbW9uLmpzXCIpO1xuXG4vKipcbiAqIEBjbGFzcyA0IERpbWVuc2lvbmFsIFZlY3RvclxuICogQG5hbWUgdmVjNFxuICovXG52YXIgdmVjNCA9IHt9O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcsIGVtcHR5IHZlYzRcbiAqXG4gKiBAcmV0dXJucyB7dmVjNH0gYSBuZXcgNEQgdmVjdG9yXG4gKi9cbnZlYzQuY3JlYXRlID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIG91dCA9IG5ldyBnbE1hdHJpeC5BUlJBWV9UWVBFKDQpO1xuICAgIG91dFswXSA9IDA7XG4gICAgb3V0WzFdID0gMDtcbiAgICBvdXRbMl0gPSAwO1xuICAgIG91dFszXSA9IDA7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyB2ZWM0IGluaXRpYWxpemVkIHdpdGggdmFsdWVzIGZyb20gYW4gZXhpc3RpbmcgdmVjdG9yXG4gKlxuICogQHBhcmFtIHt2ZWM0fSBhIHZlY3RvciB0byBjbG9uZVxuICogQHJldHVybnMge3ZlYzR9IGEgbmV3IDREIHZlY3RvclxuICovXG52ZWM0LmNsb25lID0gZnVuY3Rpb24oYSkge1xuICAgIHZhciBvdXQgPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSg0KTtcbiAgICBvdXRbMF0gPSBhWzBdO1xuICAgIG91dFsxXSA9IGFbMV07XG4gICAgb3V0WzJdID0gYVsyXTtcbiAgICBvdXRbM10gPSBhWzNdO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgdmVjNCBpbml0aWFsaXplZCB3aXRoIHRoZSBnaXZlbiB2YWx1ZXNcbiAqXG4gKiBAcGFyYW0ge051bWJlcn0geCBYIGNvbXBvbmVudFxuICogQHBhcmFtIHtOdW1iZXJ9IHkgWSBjb21wb25lbnRcbiAqIEBwYXJhbSB7TnVtYmVyfSB6IFogY29tcG9uZW50XG4gKiBAcGFyYW0ge051bWJlcn0gdyBXIGNvbXBvbmVudFxuICogQHJldHVybnMge3ZlYzR9IGEgbmV3IDREIHZlY3RvclxuICovXG52ZWM0LmZyb21WYWx1ZXMgPSBmdW5jdGlvbih4LCB5LCB6LCB3KSB7XG4gICAgdmFyIG91dCA9IG5ldyBnbE1hdHJpeC5BUlJBWV9UWVBFKDQpO1xuICAgIG91dFswXSA9IHg7XG4gICAgb3V0WzFdID0geTtcbiAgICBvdXRbMl0gPSB6O1xuICAgIG91dFszXSA9IHc7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ29weSB0aGUgdmFsdWVzIGZyb20gb25lIHZlYzQgdG8gYW5vdGhlclxuICpcbiAqIEBwYXJhbSB7dmVjNH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzR9IGEgdGhlIHNvdXJjZSB2ZWN0b3JcbiAqIEByZXR1cm5zIHt2ZWM0fSBvdXRcbiAqL1xudmVjNC5jb3B5ID0gZnVuY3Rpb24ob3V0LCBhKSB7XG4gICAgb3V0WzBdID0gYVswXTtcbiAgICBvdXRbMV0gPSBhWzFdO1xuICAgIG91dFsyXSA9IGFbMl07XG4gICAgb3V0WzNdID0gYVszXTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBTZXQgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWM0IHRvIHRoZSBnaXZlbiB2YWx1ZXNcbiAqXG4gKiBAcGFyYW0ge3ZlYzR9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHtOdW1iZXJ9IHggWCBjb21wb25lbnRcbiAqIEBwYXJhbSB7TnVtYmVyfSB5IFkgY29tcG9uZW50XG4gKiBAcGFyYW0ge051bWJlcn0geiBaIGNvbXBvbmVudFxuICogQHBhcmFtIHtOdW1iZXJ9IHcgVyBjb21wb25lbnRcbiAqIEByZXR1cm5zIHt2ZWM0fSBvdXRcbiAqL1xudmVjNC5zZXQgPSBmdW5jdGlvbihvdXQsIHgsIHksIHosIHcpIHtcbiAgICBvdXRbMF0gPSB4O1xuICAgIG91dFsxXSA9IHk7XG4gICAgb3V0WzJdID0gejtcbiAgICBvdXRbM10gPSB3O1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIEFkZHMgdHdvIHZlYzQnc1xuICpcbiAqIEBwYXJhbSB7dmVjNH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjNH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWM0fSBvdXRcbiAqL1xudmVjNC5hZGQgPSBmdW5jdGlvbihvdXQsIGEsIGIpIHtcbiAgICBvdXRbMF0gPSBhWzBdICsgYlswXTtcbiAgICBvdXRbMV0gPSBhWzFdICsgYlsxXTtcbiAgICBvdXRbMl0gPSBhWzJdICsgYlsyXTtcbiAgICBvdXRbM10gPSBhWzNdICsgYlszXTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBTdWJ0cmFjdHMgdmVjdG9yIGIgZnJvbSB2ZWN0b3IgYVxuICpcbiAqIEBwYXJhbSB7dmVjNH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjNH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWM0fSBvdXRcbiAqL1xudmVjNC5zdWJ0cmFjdCA9IGZ1bmN0aW9uKG91dCwgYSwgYikge1xuICAgIG91dFswXSA9IGFbMF0gLSBiWzBdO1xuICAgIG91dFsxXSA9IGFbMV0gLSBiWzFdO1xuICAgIG91dFsyXSA9IGFbMl0gLSBiWzJdO1xuICAgIG91dFszXSA9IGFbM10gLSBiWzNdO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjNC5zdWJ0cmFjdH1cbiAqIEBmdW5jdGlvblxuICovXG52ZWM0LnN1YiA9IHZlYzQuc3VidHJhY3Q7XG5cbi8qKlxuICogTXVsdGlwbGllcyB0d28gdmVjNCdzXG4gKlxuICogQHBhcmFtIHt2ZWM0fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjNH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWM0fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3ZlYzR9IG91dFxuICovXG52ZWM0Lm11bHRpcGx5ID0gZnVuY3Rpb24ob3V0LCBhLCBiKSB7XG4gICAgb3V0WzBdID0gYVswXSAqIGJbMF07XG4gICAgb3V0WzFdID0gYVsxXSAqIGJbMV07XG4gICAgb3V0WzJdID0gYVsyXSAqIGJbMl07XG4gICAgb3V0WzNdID0gYVszXSAqIGJbM107XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayB2ZWM0Lm11bHRpcGx5fVxuICogQGZ1bmN0aW9uXG4gKi9cbnZlYzQubXVsID0gdmVjNC5tdWx0aXBseTtcblxuLyoqXG4gKiBEaXZpZGVzIHR3byB2ZWM0J3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzR9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWM0fSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjNH0gb3V0XG4gKi9cbnZlYzQuZGl2aWRlID0gZnVuY3Rpb24ob3V0LCBhLCBiKSB7XG4gICAgb3V0WzBdID0gYVswXSAvIGJbMF07XG4gICAgb3V0WzFdID0gYVsxXSAvIGJbMV07XG4gICAgb3V0WzJdID0gYVsyXSAvIGJbMl07XG4gICAgb3V0WzNdID0gYVszXSAvIGJbM107XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayB2ZWM0LmRpdmlkZX1cbiAqIEBmdW5jdGlvblxuICovXG52ZWM0LmRpdiA9IHZlYzQuZGl2aWRlO1xuXG4vKipcbiAqIE1hdGguY2VpbCB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzRcbiAqXG4gKiBAcGFyYW0ge3ZlYzR9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWM0fSBhIHZlY3RvciB0byBjZWlsXG4gKiBAcmV0dXJucyB7dmVjNH0gb3V0XG4gKi9cbnZlYzQuY2VpbCA9IGZ1bmN0aW9uIChvdXQsIGEpIHtcbiAgICBvdXRbMF0gPSBNYXRoLmNlaWwoYVswXSk7XG4gICAgb3V0WzFdID0gTWF0aC5jZWlsKGFbMV0pO1xuICAgIG91dFsyXSA9IE1hdGguY2VpbChhWzJdKTtcbiAgICBvdXRbM10gPSBNYXRoLmNlaWwoYVszXSk7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogTWF0aC5mbG9vciB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzRcbiAqXG4gKiBAcGFyYW0ge3ZlYzR9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWM0fSBhIHZlY3RvciB0byBmbG9vclxuICogQHJldHVybnMge3ZlYzR9IG91dFxuICovXG52ZWM0LmZsb29yID0gZnVuY3Rpb24gKG91dCwgYSkge1xuICAgIG91dFswXSA9IE1hdGguZmxvb3IoYVswXSk7XG4gICAgb3V0WzFdID0gTWF0aC5mbG9vcihhWzFdKTtcbiAgICBvdXRbMl0gPSBNYXRoLmZsb29yKGFbMl0pO1xuICAgIG91dFszXSA9IE1hdGguZmxvb3IoYVszXSk7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgbWluaW11bSBvZiB0d28gdmVjNCdzXG4gKlxuICogQHBhcmFtIHt2ZWM0fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjNH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWM0fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3ZlYzR9IG91dFxuICovXG52ZWM0Lm1pbiA9IGZ1bmN0aW9uKG91dCwgYSwgYikge1xuICAgIG91dFswXSA9IE1hdGgubWluKGFbMF0sIGJbMF0pO1xuICAgIG91dFsxXSA9IE1hdGgubWluKGFbMV0sIGJbMV0pO1xuICAgIG91dFsyXSA9IE1hdGgubWluKGFbMl0sIGJbMl0pO1xuICAgIG91dFszXSA9IE1hdGgubWluKGFbM10sIGJbM10pO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIG1heGltdW0gb2YgdHdvIHZlYzQnc1xuICpcbiAqIEBwYXJhbSB7dmVjNH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjNH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWM0fSBvdXRcbiAqL1xudmVjNC5tYXggPSBmdW5jdGlvbihvdXQsIGEsIGIpIHtcbiAgICBvdXRbMF0gPSBNYXRoLm1heChhWzBdLCBiWzBdKTtcbiAgICBvdXRbMV0gPSBNYXRoLm1heChhWzFdLCBiWzFdKTtcbiAgICBvdXRbMl0gPSBNYXRoLm1heChhWzJdLCBiWzJdKTtcbiAgICBvdXRbM10gPSBNYXRoLm1heChhWzNdLCBiWzNdKTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBNYXRoLnJvdW5kIHRoZSBjb21wb25lbnRzIG9mIGEgdmVjNFxuICpcbiAqIEBwYXJhbSB7dmVjNH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzR9IGEgdmVjdG9yIHRvIHJvdW5kXG4gKiBAcmV0dXJucyB7dmVjNH0gb3V0XG4gKi9cbnZlYzQucm91bmQgPSBmdW5jdGlvbiAob3V0LCBhKSB7XG4gICAgb3V0WzBdID0gTWF0aC5yb3VuZChhWzBdKTtcbiAgICBvdXRbMV0gPSBNYXRoLnJvdW5kKGFbMV0pO1xuICAgIG91dFsyXSA9IE1hdGgucm91bmQoYVsyXSk7XG4gICAgb3V0WzNdID0gTWF0aC5yb3VuZChhWzNdKTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBTY2FsZXMgYSB2ZWM0IGJ5IGEgc2NhbGFyIG51bWJlclxuICpcbiAqIEBwYXJhbSB7dmVjNH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzR9IGEgdGhlIHZlY3RvciB0byBzY2FsZVxuICogQHBhcmFtIHtOdW1iZXJ9IGIgYW1vdW50IHRvIHNjYWxlIHRoZSB2ZWN0b3IgYnlcbiAqIEByZXR1cm5zIHt2ZWM0fSBvdXRcbiAqL1xudmVjNC5zY2FsZSA9IGZ1bmN0aW9uKG91dCwgYSwgYikge1xuICAgIG91dFswXSA9IGFbMF0gKiBiO1xuICAgIG91dFsxXSA9IGFbMV0gKiBiO1xuICAgIG91dFsyXSA9IGFbMl0gKiBiO1xuICAgIG91dFszXSA9IGFbM10gKiBiO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIEFkZHMgdHdvIHZlYzQncyBhZnRlciBzY2FsaW5nIHRoZSBzZWNvbmQgb3BlcmFuZCBieSBhIHNjYWxhciB2YWx1ZVxuICpcbiAqIEBwYXJhbSB7dmVjNH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjNH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEBwYXJhbSB7TnVtYmVyfSBzY2FsZSB0aGUgYW1vdW50IHRvIHNjYWxlIGIgYnkgYmVmb3JlIGFkZGluZ1xuICogQHJldHVybnMge3ZlYzR9IG91dFxuICovXG52ZWM0LnNjYWxlQW5kQWRkID0gZnVuY3Rpb24ob3V0LCBhLCBiLCBzY2FsZSkge1xuICAgIG91dFswXSA9IGFbMF0gKyAoYlswXSAqIHNjYWxlKTtcbiAgICBvdXRbMV0gPSBhWzFdICsgKGJbMV0gKiBzY2FsZSk7XG4gICAgb3V0WzJdID0gYVsyXSArIChiWzJdICogc2NhbGUpO1xuICAgIG91dFszXSA9IGFbM10gKyAoYlszXSAqIHNjYWxlKTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBldWNsaWRpYW4gZGlzdGFuY2UgYmV0d2VlbiB0d28gdmVjNCdzXG4gKlxuICogQHBhcmFtIHt2ZWM0fSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBkaXN0YW5jZSBiZXR3ZWVuIGEgYW5kIGJcbiAqL1xudmVjNC5kaXN0YW5jZSA9IGZ1bmN0aW9uKGEsIGIpIHtcbiAgICB2YXIgeCA9IGJbMF0gLSBhWzBdLFxuICAgICAgICB5ID0gYlsxXSAtIGFbMV0sXG4gICAgICAgIHogPSBiWzJdIC0gYVsyXSxcbiAgICAgICAgdyA9IGJbM10gLSBhWzNdO1xuICAgIHJldHVybiBNYXRoLnNxcnQoeCp4ICsgeSp5ICsgeip6ICsgdyp3KTtcbn07XG5cbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayB2ZWM0LmRpc3RhbmNlfVxuICogQGZ1bmN0aW9uXG4gKi9cbnZlYzQuZGlzdCA9IHZlYzQuZGlzdGFuY2U7XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgc3F1YXJlZCBldWNsaWRpYW4gZGlzdGFuY2UgYmV0d2VlbiB0d28gdmVjNCdzXG4gKlxuICogQHBhcmFtIHt2ZWM0fSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBzcXVhcmVkIGRpc3RhbmNlIGJldHdlZW4gYSBhbmQgYlxuICovXG52ZWM0LnNxdWFyZWREaXN0YW5jZSA9IGZ1bmN0aW9uKGEsIGIpIHtcbiAgICB2YXIgeCA9IGJbMF0gLSBhWzBdLFxuICAgICAgICB5ID0gYlsxXSAtIGFbMV0sXG4gICAgICAgIHogPSBiWzJdIC0gYVsyXSxcbiAgICAgICAgdyA9IGJbM10gLSBhWzNdO1xuICAgIHJldHVybiB4KnggKyB5KnkgKyB6KnogKyB3Knc7XG59O1xuXG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjNC5zcXVhcmVkRGlzdGFuY2V9XG4gKiBAZnVuY3Rpb25cbiAqL1xudmVjNC5zcXJEaXN0ID0gdmVjNC5zcXVhcmVkRGlzdGFuY2U7XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgbGVuZ3RoIG9mIGEgdmVjNFxuICpcbiAqIEBwYXJhbSB7dmVjNH0gYSB2ZWN0b3IgdG8gY2FsY3VsYXRlIGxlbmd0aCBvZlxuICogQHJldHVybnMge051bWJlcn0gbGVuZ3RoIG9mIGFcbiAqL1xudmVjNC5sZW5ndGggPSBmdW5jdGlvbiAoYSkge1xuICAgIHZhciB4ID0gYVswXSxcbiAgICAgICAgeSA9IGFbMV0sXG4gICAgICAgIHogPSBhWzJdLFxuICAgICAgICB3ID0gYVszXTtcbiAgICByZXR1cm4gTWF0aC5zcXJ0KHgqeCArIHkqeSArIHoqeiArIHcqdyk7XG59O1xuXG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjNC5sZW5ndGh9XG4gKiBAZnVuY3Rpb25cbiAqL1xudmVjNC5sZW4gPSB2ZWM0Lmxlbmd0aDtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBzcXVhcmVkIGxlbmd0aCBvZiBhIHZlYzRcbiAqXG4gKiBAcGFyYW0ge3ZlYzR9IGEgdmVjdG9yIHRvIGNhbGN1bGF0ZSBzcXVhcmVkIGxlbmd0aCBvZlxuICogQHJldHVybnMge051bWJlcn0gc3F1YXJlZCBsZW5ndGggb2YgYVxuICovXG52ZWM0LnNxdWFyZWRMZW5ndGggPSBmdW5jdGlvbiAoYSkge1xuICAgIHZhciB4ID0gYVswXSxcbiAgICAgICAgeSA9IGFbMV0sXG4gICAgICAgIHogPSBhWzJdLFxuICAgICAgICB3ID0gYVszXTtcbiAgICByZXR1cm4geCp4ICsgeSp5ICsgeip6ICsgdyp3O1xufTtcblxuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzQuc3F1YXJlZExlbmd0aH1cbiAqIEBmdW5jdGlvblxuICovXG52ZWM0LnNxckxlbiA9IHZlYzQuc3F1YXJlZExlbmd0aDtcblxuLyoqXG4gKiBOZWdhdGVzIHRoZSBjb21wb25lbnRzIG9mIGEgdmVjNFxuICpcbiAqIEBwYXJhbSB7dmVjNH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzR9IGEgdmVjdG9yIHRvIG5lZ2F0ZVxuICogQHJldHVybnMge3ZlYzR9IG91dFxuICovXG52ZWM0Lm5lZ2F0ZSA9IGZ1bmN0aW9uKG91dCwgYSkge1xuICAgIG91dFswXSA9IC1hWzBdO1xuICAgIG91dFsxXSA9IC1hWzFdO1xuICAgIG91dFsyXSA9IC1hWzJdO1xuICAgIG91dFszXSA9IC1hWzNdO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGludmVyc2Ugb2YgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWM0XG4gKlxuICogQHBhcmFtIHt2ZWM0fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjNH0gYSB2ZWN0b3IgdG8gaW52ZXJ0XG4gKiBAcmV0dXJucyB7dmVjNH0gb3V0XG4gKi9cbnZlYzQuaW52ZXJzZSA9IGZ1bmN0aW9uKG91dCwgYSkge1xuICBvdXRbMF0gPSAxLjAgLyBhWzBdO1xuICBvdXRbMV0gPSAxLjAgLyBhWzFdO1xuICBvdXRbMl0gPSAxLjAgLyBhWzJdO1xuICBvdXRbM10gPSAxLjAgLyBhWzNdO1xuICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBOb3JtYWxpemUgYSB2ZWM0XG4gKlxuICogQHBhcmFtIHt2ZWM0fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjNH0gYSB2ZWN0b3IgdG8gbm9ybWFsaXplXG4gKiBAcmV0dXJucyB7dmVjNH0gb3V0XG4gKi9cbnZlYzQubm9ybWFsaXplID0gZnVuY3Rpb24ob3V0LCBhKSB7XG4gICAgdmFyIHggPSBhWzBdLFxuICAgICAgICB5ID0gYVsxXSxcbiAgICAgICAgeiA9IGFbMl0sXG4gICAgICAgIHcgPSBhWzNdO1xuICAgIHZhciBsZW4gPSB4KnggKyB5KnkgKyB6KnogKyB3Knc7XG4gICAgaWYgKGxlbiA+IDApIHtcbiAgICAgICAgbGVuID0gMSAvIE1hdGguc3FydChsZW4pO1xuICAgICAgICBvdXRbMF0gPSB4ICogbGVuO1xuICAgICAgICBvdXRbMV0gPSB5ICogbGVuO1xuICAgICAgICBvdXRbMl0gPSB6ICogbGVuO1xuICAgICAgICBvdXRbM10gPSB3ICogbGVuO1xuICAgIH1cbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBkb3QgcHJvZHVjdCBvZiB0d28gdmVjNCdzXG4gKlxuICogQHBhcmFtIHt2ZWM0fSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBkb3QgcHJvZHVjdCBvZiBhIGFuZCBiXG4gKi9cbnZlYzQuZG90ID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICByZXR1cm4gYVswXSAqIGJbMF0gKyBhWzFdICogYlsxXSArIGFbMl0gKiBiWzJdICsgYVszXSAqIGJbM107XG59O1xuXG4vKipcbiAqIFBlcmZvcm1zIGEgbGluZWFyIGludGVycG9sYXRpb24gYmV0d2VlbiB0d28gdmVjNCdzXG4gKlxuICogQHBhcmFtIHt2ZWM0fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjNH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWM0fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHBhcmFtIHtOdW1iZXJ9IHQgaW50ZXJwb2xhdGlvbiBhbW91bnQgYmV0d2VlbiB0aGUgdHdvIGlucHV0c1xuICogQHJldHVybnMge3ZlYzR9IG91dFxuICovXG52ZWM0LmxlcnAgPSBmdW5jdGlvbiAob3V0LCBhLCBiLCB0KSB7XG4gICAgdmFyIGF4ID0gYVswXSxcbiAgICAgICAgYXkgPSBhWzFdLFxuICAgICAgICBheiA9IGFbMl0sXG4gICAgICAgIGF3ID0gYVszXTtcbiAgICBvdXRbMF0gPSBheCArIHQgKiAoYlswXSAtIGF4KTtcbiAgICBvdXRbMV0gPSBheSArIHQgKiAoYlsxXSAtIGF5KTtcbiAgICBvdXRbMl0gPSBheiArIHQgKiAoYlsyXSAtIGF6KTtcbiAgICBvdXRbM10gPSBhdyArIHQgKiAoYlszXSAtIGF3KTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBHZW5lcmF0ZXMgYSByYW5kb20gdmVjdG9yIHdpdGggdGhlIGdpdmVuIHNjYWxlXG4gKlxuICogQHBhcmFtIHt2ZWM0fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7TnVtYmVyfSBbc2NhbGVdIExlbmd0aCBvZiB0aGUgcmVzdWx0aW5nIHZlY3Rvci4gSWYgb21taXR0ZWQsIGEgdW5pdCB2ZWN0b3Igd2lsbCBiZSByZXR1cm5lZFxuICogQHJldHVybnMge3ZlYzR9IG91dFxuICovXG52ZWM0LnJhbmRvbSA9IGZ1bmN0aW9uIChvdXQsIHNjYWxlKSB7XG4gICAgc2NhbGUgPSBzY2FsZSB8fCAxLjA7XG5cbiAgICAvL1RPRE86IFRoaXMgaXMgYSBwcmV0dHkgYXdmdWwgd2F5IG9mIGRvaW5nIHRoaXMuIEZpbmQgc29tZXRoaW5nIGJldHRlci5cbiAgICBvdXRbMF0gPSBnbE1hdHJpeC5SQU5ET00oKTtcbiAgICBvdXRbMV0gPSBnbE1hdHJpeC5SQU5ET00oKTtcbiAgICBvdXRbMl0gPSBnbE1hdHJpeC5SQU5ET00oKTtcbiAgICBvdXRbM10gPSBnbE1hdHJpeC5SQU5ET00oKTtcbiAgICB2ZWM0Lm5vcm1hbGl6ZShvdXQsIG91dCk7XG4gICAgdmVjNC5zY2FsZShvdXQsIG91dCwgc2NhbGUpO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFRyYW5zZm9ybXMgdGhlIHZlYzQgd2l0aCBhIG1hdDQuXG4gKlxuICogQHBhcmFtIHt2ZWM0fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjNH0gYSB0aGUgdmVjdG9yIHRvIHRyYW5zZm9ybVxuICogQHBhcmFtIHttYXQ0fSBtIG1hdHJpeCB0byB0cmFuc2Zvcm0gd2l0aFxuICogQHJldHVybnMge3ZlYzR9IG91dFxuICovXG52ZWM0LnRyYW5zZm9ybU1hdDQgPSBmdW5jdGlvbihvdXQsIGEsIG0pIHtcbiAgICB2YXIgeCA9IGFbMF0sIHkgPSBhWzFdLCB6ID0gYVsyXSwgdyA9IGFbM107XG4gICAgb3V0WzBdID0gbVswXSAqIHggKyBtWzRdICogeSArIG1bOF0gKiB6ICsgbVsxMl0gKiB3O1xuICAgIG91dFsxXSA9IG1bMV0gKiB4ICsgbVs1XSAqIHkgKyBtWzldICogeiArIG1bMTNdICogdztcbiAgICBvdXRbMl0gPSBtWzJdICogeCArIG1bNl0gKiB5ICsgbVsxMF0gKiB6ICsgbVsxNF0gKiB3O1xuICAgIG91dFszXSA9IG1bM10gKiB4ICsgbVs3XSAqIHkgKyBtWzExXSAqIHogKyBtWzE1XSAqIHc7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogVHJhbnNmb3JtcyB0aGUgdmVjNCB3aXRoIGEgcXVhdFxuICpcbiAqIEBwYXJhbSB7dmVjNH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzR9IGEgdGhlIHZlY3RvciB0byB0cmFuc2Zvcm1cbiAqIEBwYXJhbSB7cXVhdH0gcSBxdWF0ZXJuaW9uIHRvIHRyYW5zZm9ybSB3aXRoXG4gKiBAcmV0dXJucyB7dmVjNH0gb3V0XG4gKi9cbnZlYzQudHJhbnNmb3JtUXVhdCA9IGZ1bmN0aW9uKG91dCwgYSwgcSkge1xuICAgIHZhciB4ID0gYVswXSwgeSA9IGFbMV0sIHogPSBhWzJdLFxuICAgICAgICBxeCA9IHFbMF0sIHF5ID0gcVsxXSwgcXogPSBxWzJdLCBxdyA9IHFbM10sXG5cbiAgICAgICAgLy8gY2FsY3VsYXRlIHF1YXQgKiB2ZWNcbiAgICAgICAgaXggPSBxdyAqIHggKyBxeSAqIHogLSBxeiAqIHksXG4gICAgICAgIGl5ID0gcXcgKiB5ICsgcXogKiB4IC0gcXggKiB6LFxuICAgICAgICBpeiA9IHF3ICogeiArIHF4ICogeSAtIHF5ICogeCxcbiAgICAgICAgaXcgPSAtcXggKiB4IC0gcXkgKiB5IC0gcXogKiB6O1xuXG4gICAgLy8gY2FsY3VsYXRlIHJlc3VsdCAqIGludmVyc2UgcXVhdFxuICAgIG91dFswXSA9IGl4ICogcXcgKyBpdyAqIC1xeCArIGl5ICogLXF6IC0gaXogKiAtcXk7XG4gICAgb3V0WzFdID0gaXkgKiBxdyArIGl3ICogLXF5ICsgaXogKiAtcXggLSBpeCAqIC1xejtcbiAgICBvdXRbMl0gPSBpeiAqIHF3ICsgaXcgKiAtcXogKyBpeCAqIC1xeSAtIGl5ICogLXF4O1xuICAgIG91dFszXSA9IGFbM107XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogUGVyZm9ybSBzb21lIG9wZXJhdGlvbiBvdmVyIGFuIGFycmF5IG9mIHZlYzRzLlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IGEgdGhlIGFycmF5IG9mIHZlY3RvcnMgdG8gaXRlcmF0ZSBvdmVyXG4gKiBAcGFyYW0ge051bWJlcn0gc3RyaWRlIE51bWJlciBvZiBlbGVtZW50cyBiZXR3ZWVuIHRoZSBzdGFydCBvZiBlYWNoIHZlYzQuIElmIDAgYXNzdW1lcyB0aWdodGx5IHBhY2tlZFxuICogQHBhcmFtIHtOdW1iZXJ9IG9mZnNldCBOdW1iZXIgb2YgZWxlbWVudHMgdG8gc2tpcCBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoZSBhcnJheVxuICogQHBhcmFtIHtOdW1iZXJ9IGNvdW50IE51bWJlciBvZiB2ZWM0cyB0byBpdGVyYXRlIG92ZXIuIElmIDAgaXRlcmF0ZXMgb3ZlciBlbnRpcmUgYXJyYXlcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIEZ1bmN0aW9uIHRvIGNhbGwgZm9yIGVhY2ggdmVjdG9yIGluIHRoZSBhcnJheVxuICogQHBhcmFtIHtPYmplY3R9IFthcmddIGFkZGl0aW9uYWwgYXJndW1lbnQgdG8gcGFzcyB0byBmblxuICogQHJldHVybnMge0FycmF5fSBhXG4gKiBAZnVuY3Rpb25cbiAqL1xudmVjNC5mb3JFYWNoID0gKGZ1bmN0aW9uKCkge1xuICAgIHZhciB2ZWMgPSB2ZWM0LmNyZWF0ZSgpO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uKGEsIHN0cmlkZSwgb2Zmc2V0LCBjb3VudCwgZm4sIGFyZykge1xuICAgICAgICB2YXIgaSwgbDtcbiAgICAgICAgaWYoIXN0cmlkZSkge1xuICAgICAgICAgICAgc3RyaWRlID0gNDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKCFvZmZzZXQpIHtcbiAgICAgICAgICAgIG9mZnNldCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGlmKGNvdW50KSB7XG4gICAgICAgICAgICBsID0gTWF0aC5taW4oKGNvdW50ICogc3RyaWRlKSArIG9mZnNldCwgYS5sZW5ndGgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbCA9IGEubGVuZ3RoO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yKGkgPSBvZmZzZXQ7IGkgPCBsOyBpICs9IHN0cmlkZSkge1xuICAgICAgICAgICAgdmVjWzBdID0gYVtpXTsgdmVjWzFdID0gYVtpKzFdOyB2ZWNbMl0gPSBhW2krMl07IHZlY1szXSA9IGFbaSszXTtcbiAgICAgICAgICAgIGZuKHZlYywgdmVjLCBhcmcpO1xuICAgICAgICAgICAgYVtpXSA9IHZlY1swXTsgYVtpKzFdID0gdmVjWzFdOyBhW2krMl0gPSB2ZWNbMl07IGFbaSszXSA9IHZlY1szXTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgcmV0dXJuIGE7XG4gICAgfTtcbn0pKCk7XG5cbi8qKlxuICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhIHZlY3RvclxuICpcbiAqIEBwYXJhbSB7dmVjNH0gdmVjIHZlY3RvciB0byByZXByZXNlbnQgYXMgYSBzdHJpbmdcbiAqIEByZXR1cm5zIHtTdHJpbmd9IHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgdmVjdG9yXG4gKi9cbnZlYzQuc3RyID0gZnVuY3Rpb24gKGEpIHtcbiAgICByZXR1cm4gJ3ZlYzQoJyArIGFbMF0gKyAnLCAnICsgYVsxXSArICcsICcgKyBhWzJdICsgJywgJyArIGFbM10gKyAnKSc7XG59O1xuXG4vKipcbiAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIHZlY3RvcnMgaGF2ZSBleGFjdGx5IHRoZSBzYW1lIGVsZW1lbnRzIGluIHRoZSBzYW1lIHBvc2l0aW9uICh3aGVuIGNvbXBhcmVkIHdpdGggPT09KVxuICpcbiAqIEBwYXJhbSB7dmVjNH0gYSBUaGUgZmlyc3QgdmVjdG9yLlxuICogQHBhcmFtIHt2ZWM0fSBiIFRoZSBzZWNvbmQgdmVjdG9yLlxuICogQHJldHVybnMge0Jvb2xlYW59IFRydWUgaWYgdGhlIHZlY3RvcnMgYXJlIGVxdWFsLCBmYWxzZSBvdGhlcndpc2UuXG4gKi9cbnZlYzQuZXhhY3RFcXVhbHMgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgIHJldHVybiBhWzBdID09PSBiWzBdICYmIGFbMV0gPT09IGJbMV0gJiYgYVsyXSA9PT0gYlsyXSAmJiBhWzNdID09PSBiWzNdO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSB2ZWN0b3JzIGhhdmUgYXBwcm94aW1hdGVseSB0aGUgc2FtZSBlbGVtZW50cyBpbiB0aGUgc2FtZSBwb3NpdGlvbi5cbiAqXG4gKiBAcGFyYW0ge3ZlYzR9IGEgVGhlIGZpcnN0IHZlY3Rvci5cbiAqIEBwYXJhbSB7dmVjNH0gYiBUaGUgc2Vjb25kIHZlY3Rvci5cbiAqIEByZXR1cm5zIHtCb29sZWFufSBUcnVlIGlmIHRoZSB2ZWN0b3JzIGFyZSBlcXVhbCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICovXG52ZWM0LmVxdWFscyA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgdmFyIGEwID0gYVswXSwgYTEgPSBhWzFdLCBhMiA9IGFbMl0sIGEzID0gYVszXTtcbiAgICB2YXIgYjAgPSBiWzBdLCBiMSA9IGJbMV0sIGIyID0gYlsyXSwgYjMgPSBiWzNdO1xuICAgIHJldHVybiAoTWF0aC5hYnMoYTAgLSBiMCkgPD0gZ2xNYXRyaXguRVBTSUxPTipNYXRoLm1heCgxLjAsIE1hdGguYWJzKGEwKSwgTWF0aC5hYnMoYjApKSAmJlxuICAgICAgICAgICAgTWF0aC5hYnMoYTEgLSBiMSkgPD0gZ2xNYXRyaXguRVBTSUxPTipNYXRoLm1heCgxLjAsIE1hdGguYWJzKGExKSwgTWF0aC5hYnMoYjEpKSAmJlxuICAgICAgICAgICAgTWF0aC5hYnMoYTIgLSBiMikgPD0gZ2xNYXRyaXguRVBTSUxPTipNYXRoLm1heCgxLjAsIE1hdGguYWJzKGEyKSwgTWF0aC5hYnMoYjIpKSAmJlxuICAgICAgICAgICAgTWF0aC5hYnMoYTMgLSBiMykgPD0gZ2xNYXRyaXguRVBTSUxPTipNYXRoLm1heCgxLjAsIE1hdGguYWJzKGEzKSwgTWF0aC5hYnMoYjMpKSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHZlYzQ7XG4iLCIndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIGNvbnN0YW50KHZhbHVlKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBpbnRlcnBvbGF0ZU51bWJlcihhLCBiLCB0KSB7XG4gICAgcmV0dXJuIChhICogKDEgLSB0KSkgKyAoYiAqIHQpO1xufVxuXG5mdW5jdGlvbiBpbnRlcnBvbGF0ZUFycmF5KGEsIGIsIHQpIHtcbiAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHJlc3VsdFtpXSA9IGludGVycG9sYXRlTnVtYmVyKGFbaV0sIGJbaV0sIHQpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnRzWydpbnRlcnBvbGF0ZWQnXSA9IGZ1bmN0aW9uKGYpIHtcbiAgICBpZiAoIWYuc3RvcHMpIHtcbiAgICAgICAgcmV0dXJuIGNvbnN0YW50KGYpO1xuICAgIH1cblxuICAgIHZhciBzdG9wcyA9IGYuc3RvcHMsXG4gICAgICAgIGJhc2UgPSBmLmJhc2UgfHwgMSxcbiAgICAgICAgaW50ZXJwb2xhdGUgPSBBcnJheS5pc0FycmF5KHN0b3BzWzBdWzFdKSA/IGludGVycG9sYXRlQXJyYXkgOiBpbnRlcnBvbGF0ZU51bWJlcjtcblxuICAgIHJldHVybiBmdW5jdGlvbih6KSB7XG4gICAgICAgIC8vIGZpbmQgdGhlIHR3byBzdG9wcyB3aGljaCB0aGUgY3VycmVudCB6IGlzIGJldHdlZW5cbiAgICAgICAgdmFyIGxvdywgaGlnaDtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0b3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgc3RvcCA9IHN0b3BzW2ldO1xuXG4gICAgICAgICAgICBpZiAoc3RvcFswXSA8PSB6KSB7XG4gICAgICAgICAgICAgICAgbG93ID0gc3RvcDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHN0b3BbMF0gPiB6KSB7XG4gICAgICAgICAgICAgICAgaGlnaCA9IHN0b3A7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobG93ICYmIGhpZ2gpIHtcbiAgICAgICAgICAgIHZhciB6b29tRGlmZiA9IGhpZ2hbMF0gLSBsb3dbMF0sXG4gICAgICAgICAgICAgICAgem9vbVByb2dyZXNzID0geiAtIGxvd1swXSxcblxuICAgICAgICAgICAgICAgIHQgPSBiYXNlID09PSAxID9cbiAgICAgICAgICAgICAgICB6b29tUHJvZ3Jlc3MgLyB6b29tRGlmZiA6XG4gICAgICAgICAgICAgICAgKE1hdGgucG93KGJhc2UsIHpvb21Qcm9ncmVzcykgLSAxKSAvIChNYXRoLnBvdyhiYXNlLCB6b29tRGlmZikgLSAxKTtcblxuICAgICAgICAgICAgcmV0dXJuIGludGVycG9sYXRlKGxvd1sxXSwgaGlnaFsxXSwgdCk7XG5cbiAgICAgICAgfSBlbHNlIGlmIChsb3cpIHtcbiAgICAgICAgICAgIHJldHVybiBsb3dbMV07XG5cbiAgICAgICAgfSBlbHNlIGlmIChoaWdoKSB7XG4gICAgICAgICAgICByZXR1cm4gaGlnaFsxXTtcbiAgICAgICAgfVxuICAgIH07XG59O1xuXG5leHBvcnRzWydwaWVjZXdpc2UtY29uc3RhbnQnXSA9IGZ1bmN0aW9uKGYpIHtcbiAgICBpZiAoIWYuc3RvcHMpIHtcbiAgICAgICAgcmV0dXJuIGNvbnN0YW50KGYpO1xuICAgIH1cblxuICAgIHZhciBzdG9wcyA9IGYuc3RvcHM7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24oeikge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0b3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoc3RvcHNbaV1bMF0gPiB6KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0b3BzW2kgPT09IDAgPyAwIDogaSAtIDFdWzFdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHN0b3BzW3N0b3BzLmxlbmd0aCAtIDFdWzFdO1xuICAgIH1cbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBmb3JtYXQgPSByZXF1aXJlKCd1dGlsJykuZm9ybWF0O1xuXG5mdW5jdGlvbiBWYWxpZGF0aW9uRXJyb3Ioa2V5LCB2YWx1ZSAvKiwgbWVzc2FnZSwgLi4uKi8pIHtcbiAgICB0aGlzLm1lc3NhZ2UgPSAoXG4gICAgICAgIChrZXkgPyBrZXkgKyAnOiAnIDogJycpICtcbiAgICAgICAgZm9ybWF0LmFwcGx5KGZvcm1hdCwgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAyKSlcbiAgICApO1xuXG4gICAgaWYgKHZhbHVlICE9PSBudWxsICYmIHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUuX19saW5lX18pIHtcbiAgICAgICAgdGhpcy5saW5lID0gdmFsdWUuX19saW5lX187XG4gICAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFZhbGlkYXRpb25FcnJvcjtcbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob3V0cHV0KSB7XG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGlucHV0ID0gYXJndW1lbnRzW2ldO1xuICAgICAgICBmb3IgKHZhciBrIGluIGlucHV0KSB7XG4gICAgICAgICAgICBvdXRwdXRba10gPSBpbnB1dFtrXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb3V0cHV0O1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBnZXRUeXBlKHZhbCkge1xuICAgIGlmICh2YWwgaW5zdGFuY2VvZiBOdW1iZXIpIHtcbiAgICAgICAgcmV0dXJuICdudW1iZXInO1xuICAgIH0gZWxzZSBpZiAodmFsIGluc3RhbmNlb2YgU3RyaW5nKSB7XG4gICAgICAgIHJldHVybiAnc3RyaW5nJztcbiAgICB9IGVsc2UgaWYgKHZhbCBpbnN0YW5jZW9mIEJvb2xlYW4pIHtcbiAgICAgICAgcmV0dXJuICdib29sZWFuJztcbiAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodmFsKSkge1xuICAgICAgICByZXR1cm4gJ2FycmF5JztcbiAgICB9IGVsc2UgaWYgKHZhbCA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gJ251bGwnO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgdmFsO1xuICAgIH1cbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogVHVybiBqc29ubGludC1saW5lcy1wcmltaXRpdmVzIG9iamVjdHMgaW50byBwcmltaXRpdmUgb2JqZWN0c1xuICogQHBhcmFtIHZhbHVlIGEgcG90ZW50aWFsbHktYnVuZGxlZCB2YWx1ZVxuICogQHJldHVybnMgYW4gdW5idW5kbGVkIHZhbHVlXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gdW5idW5kbGUodmFsdWUpIHtcbiAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBOdW1iZXIgfHwgdmFsdWUgaW5zdGFuY2VvZiBTdHJpbmcgfHwgdmFsdWUgaW5zdGFuY2VvZiBCb29sZWFuKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZS52YWx1ZU9mKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBWYWxpZGF0aW9uRXJyb3IgPSByZXF1aXJlKCcuLi9lcnJvci92YWxpZGF0aW9uX2Vycm9yJyk7XG52YXIgZ2V0VHlwZSA9IHJlcXVpcmUoJy4uL3V0aWwvZ2V0X3R5cGUnKTtcbnZhciBleHRlbmQgPSByZXF1aXJlKCcuLi91dGlsL2V4dGVuZCcpO1xuXG4vLyBNYWluIHJlY3Vyc2l2ZSB2YWxpZGF0aW9uIGZ1bmN0aW9uLiBUcmFja3M6XG4vL1xuLy8gLSBrZXk6IHN0cmluZyByZXByZXNlbnRpbmcgbG9jYXRpb24gb2YgdmFsaWRhdGlvbiBpbiBzdHlsZSB0cmVlLiBVc2VkIG9ubHlcbi8vICAgZm9yIG1vcmUgaW5mb3JtYXRpdmUgZXJyb3IgcmVwb3J0aW5nLlxuLy8gLSB2YWx1ZTogY3VycmVudCB2YWx1ZSBmcm9tIHN0eWxlIGJlaW5nIGV2YWx1YXRlZC4gTWF5IGJlIGFueXRoaW5nIGZyb20gYVxuLy8gICBoaWdoIGxldmVsIG9iamVjdCB0aGF0IG5lZWRzIHRvIGJlIGRlc2NlbmRlZCBpbnRvIGRlZXBlciBvciBhIHNpbXBsZVxuLy8gICBzY2FsYXIgdmFsdWUuXG4vLyAtIHZhbHVlU3BlYzogY3VycmVudCBzcGVjIGJlaW5nIGV2YWx1YXRlZC4gVHJhY2tzIHZhbHVlLlxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHZhbGlkYXRlKG9wdGlvbnMpIHtcblxuICAgIHZhciB2YWxpZGF0ZUZ1bmN0aW9uID0gcmVxdWlyZSgnLi92YWxpZGF0ZV9mdW5jdGlvbicpO1xuICAgIHZhciB2YWxpZGF0ZU9iamVjdCA9IHJlcXVpcmUoJy4vdmFsaWRhdGVfb2JqZWN0Jyk7XG4gICAgdmFyIFZBTElEQVRPUlMgPSB7XG4gICAgICAgICcqJzogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH0sXG4gICAgICAgICdhcnJheSc6IHJlcXVpcmUoJy4vdmFsaWRhdGVfYXJyYXknKSxcbiAgICAgICAgJ2Jvb2xlYW4nOiByZXF1aXJlKCcuL3ZhbGlkYXRlX2Jvb2xlYW4nKSxcbiAgICAgICAgJ251bWJlcic6IHJlcXVpcmUoJy4vdmFsaWRhdGVfbnVtYmVyJyksXG4gICAgICAgICdjb2xvcic6IHJlcXVpcmUoJy4vdmFsaWRhdGVfY29sb3InKSxcbiAgICAgICAgJ2NvbnN0YW50cyc6IHJlcXVpcmUoJy4vdmFsaWRhdGVfY29uc3RhbnRzJyksXG4gICAgICAgICdlbnVtJzogcmVxdWlyZSgnLi92YWxpZGF0ZV9lbnVtJyksXG4gICAgICAgICdmaWx0ZXInOiByZXF1aXJlKCcuL3ZhbGlkYXRlX2ZpbHRlcicpLFxuICAgICAgICAnZnVuY3Rpb24nOiByZXF1aXJlKCcuL3ZhbGlkYXRlX2Z1bmN0aW9uJyksXG4gICAgICAgICdsYXllcic6IHJlcXVpcmUoJy4vdmFsaWRhdGVfbGF5ZXInKSxcbiAgICAgICAgJ29iamVjdCc6IHJlcXVpcmUoJy4vdmFsaWRhdGVfb2JqZWN0JyksXG4gICAgICAgICdzb3VyY2UnOiByZXF1aXJlKCcuL3ZhbGlkYXRlX3NvdXJjZScpLFxuICAgICAgICAnc3RyaW5nJzogcmVxdWlyZSgnLi92YWxpZGF0ZV9zdHJpbmcnKVxuICAgIH07XG5cbiAgICB2YXIgdmFsdWUgPSBvcHRpb25zLnZhbHVlO1xuICAgIHZhciB2YWx1ZVNwZWMgPSBvcHRpb25zLnZhbHVlU3BlYztcbiAgICB2YXIga2V5ID0gb3B0aW9ucy5rZXk7XG4gICAgdmFyIHN0eWxlU3BlYyA9IG9wdGlvbnMuc3R5bGVTcGVjO1xuICAgIHZhciBzdHlsZSA9IG9wdGlvbnMuc3R5bGU7XG5cbiAgICBpZiAoZ2V0VHlwZSh2YWx1ZSkgPT09ICdzdHJpbmcnICYmIHZhbHVlWzBdID09PSAnQCcpIHtcbiAgICAgICAgaWYgKHN0eWxlU3BlYy4kdmVyc2lvbiA+IDcpIHtcbiAgICAgICAgICAgIHJldHVybiBbbmV3IFZhbGlkYXRpb25FcnJvcihrZXksIHZhbHVlLCAnY29uc3RhbnRzIGhhdmUgYmVlbiBkZXByZWNhdGVkIGFzIG9mIHY4JyldO1xuICAgICAgICB9XG4gICAgICAgIGlmICghKHZhbHVlIGluIHN0eWxlLmNvbnN0YW50cykpIHtcbiAgICAgICAgICAgIHJldHVybiBbbmV3IFZhbGlkYXRpb25FcnJvcihrZXksIHZhbHVlLCAnY29uc3RhbnQgXCIlc1wiIG5vdCBmb3VuZCcsIHZhbHVlKV07XG4gICAgICAgIH1cbiAgICAgICAgb3B0aW9ucyA9IGV4dGVuZCh7fSwgb3B0aW9ucywgeyB2YWx1ZTogc3R5bGUuY29uc3RhbnRzW3ZhbHVlXSB9KTtcbiAgICB9XG5cbiAgICBpZiAodmFsdWVTcGVjLmZ1bmN0aW9uICYmIGdldFR5cGUodmFsdWUpID09PSAnb2JqZWN0Jykge1xuICAgICAgICByZXR1cm4gdmFsaWRhdGVGdW5jdGlvbihvcHRpb25zKTtcblxuICAgIH0gZWxzZSBpZiAodmFsdWVTcGVjLnR5cGUgJiYgVkFMSURBVE9SU1t2YWx1ZVNwZWMudHlwZV0pIHtcbiAgICAgICAgcmV0dXJuIFZBTElEQVRPUlNbdmFsdWVTcGVjLnR5cGVdKG9wdGlvbnMpO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHZhbGlkYXRlT2JqZWN0KGV4dGVuZCh7fSwgb3B0aW9ucywge1xuICAgICAgICAgICAgdmFsdWVTcGVjOiB2YWx1ZVNwZWMudHlwZSA/IHN0eWxlU3BlY1t2YWx1ZVNwZWMudHlwZV0gOiB2YWx1ZVNwZWNcbiAgICAgICAgfSkpO1xuICAgIH1cbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBnZXRUeXBlID0gcmVxdWlyZSgnLi4vdXRpbC9nZXRfdHlwZScpO1xudmFyIHZhbGlkYXRlID0gcmVxdWlyZSgnLi92YWxpZGF0ZScpO1xudmFyIFZhbGlkYXRpb25FcnJvciA9IHJlcXVpcmUoJy4uL2Vycm9yL3ZhbGlkYXRpb25fZXJyb3InKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiB2YWxpZGF0ZUFycmF5KG9wdGlvbnMpIHtcbiAgICB2YXIgYXJyYXkgPSBvcHRpb25zLnZhbHVlO1xuICAgIHZhciBhcnJheVNwZWMgPSBvcHRpb25zLnZhbHVlU3BlYztcbiAgICB2YXIgc3R5bGUgPSBvcHRpb25zLnN0eWxlO1xuICAgIHZhciBzdHlsZVNwZWMgPSBvcHRpb25zLnN0eWxlU3BlYztcbiAgICB2YXIga2V5ID0gb3B0aW9ucy5rZXk7XG4gICAgdmFyIHZhbGlkYXRlQXJyYXlFbGVtZW50ID0gb3B0aW9ucy5hcnJheUVsZW1lbnRWYWxpZGF0b3IgfHwgdmFsaWRhdGU7XG5cbiAgICBpZiAoZ2V0VHlwZShhcnJheSkgIT09ICdhcnJheScpIHtcbiAgICAgICAgcmV0dXJuIFtuZXcgVmFsaWRhdGlvbkVycm9yKGtleSwgYXJyYXksICdhcnJheSBleHBlY3RlZCwgJXMgZm91bmQnLCBnZXRUeXBlKGFycmF5KSldO1xuICAgIH1cblxuICAgIGlmIChhcnJheVNwZWMubGVuZ3RoICYmIGFycmF5Lmxlbmd0aCAhPT0gYXJyYXlTcGVjLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gW25ldyBWYWxpZGF0aW9uRXJyb3Ioa2V5LCBhcnJheSwgJ2FycmF5IGxlbmd0aCAlZCBleHBlY3RlZCwgbGVuZ3RoICVkIGZvdW5kJywgYXJyYXlTcGVjLmxlbmd0aCwgYXJyYXkubGVuZ3RoKV07XG4gICAgfVxuXG4gICAgaWYgKGFycmF5U3BlY1snbWluLWxlbmd0aCddICYmIGFycmF5Lmxlbmd0aCA8IGFycmF5U3BlY1snbWluLWxlbmd0aCddKSB7XG4gICAgICAgIHJldHVybiBbbmV3IFZhbGlkYXRpb25FcnJvcihrZXksIGFycmF5LCAnYXJyYXkgbGVuZ3RoIGF0IGxlYXN0ICVkIGV4cGVjdGVkLCBsZW5ndGggJWQgZm91bmQnLCBhcnJheVNwZWNbJ21pbi1sZW5ndGgnXSwgYXJyYXkubGVuZ3RoKV07XG4gICAgfVxuXG4gICAgdmFyIGFycmF5RWxlbWVudFNwZWMgPSB7XG4gICAgICAgIFwidHlwZVwiOiBhcnJheVNwZWMudmFsdWVcbiAgICB9O1xuXG4gICAgaWYgKHN0eWxlU3BlYy4kdmVyc2lvbiA8IDcpIHtcbiAgICAgICAgYXJyYXlFbGVtZW50U3BlYy5mdW5jdGlvbiA9IGFycmF5U3BlYy5mdW5jdGlvbjtcbiAgICB9XG5cbiAgICBpZiAoZ2V0VHlwZShhcnJheVNwZWMudmFsdWUpID09PSAnb2JqZWN0Jykge1xuICAgICAgICBhcnJheUVsZW1lbnRTcGVjID0gYXJyYXlTcGVjLnZhbHVlO1xuICAgIH1cblxuICAgIHZhciBlcnJvcnMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGVycm9ycyA9IGVycm9ycy5jb25jYXQodmFsaWRhdGVBcnJheUVsZW1lbnQoe1xuICAgICAgICAgICAgYXJyYXk6IGFycmF5LFxuICAgICAgICAgICAgYXJyYXlJbmRleDogaSxcbiAgICAgICAgICAgIHZhbHVlOiBhcnJheVtpXSxcbiAgICAgICAgICAgIHZhbHVlU3BlYzogYXJyYXlFbGVtZW50U3BlYyxcbiAgICAgICAgICAgIHN0eWxlOiBzdHlsZSxcbiAgICAgICAgICAgIHN0eWxlU3BlYzogc3R5bGVTcGVjLFxuICAgICAgICAgICAga2V5OiBrZXkgKyAnWycgKyBpICsgJ10nXG4gICAgICAgIH0pKTtcbiAgICB9XG4gICAgcmV0dXJuIGVycm9ycztcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBnZXRUeXBlID0gcmVxdWlyZSgnLi4vdXRpbC9nZXRfdHlwZScpO1xudmFyIFZhbGlkYXRpb25FcnJvciA9IHJlcXVpcmUoJy4uL2Vycm9yL3ZhbGlkYXRpb25fZXJyb3InKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiB2YWxpZGF0ZUJvb2xlYW4ob3B0aW9ucykge1xuICAgIHZhciB2YWx1ZSA9IG9wdGlvbnMudmFsdWU7XG4gICAgdmFyIGtleSA9IG9wdGlvbnMua2V5O1xuICAgIHZhciB0eXBlID0gZ2V0VHlwZSh2YWx1ZSk7XG5cbiAgICBpZiAodHlwZSAhPT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgIHJldHVybiBbbmV3IFZhbGlkYXRpb25FcnJvcihrZXksIHZhbHVlLCAnYm9vbGVhbiBleHBlY3RlZCwgJXMgZm91bmQnLCB0eXBlKV07XG4gICAgfVxuXG4gICAgcmV0dXJuIFtdO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIFZhbGlkYXRpb25FcnJvciA9IHJlcXVpcmUoJy4uL2Vycm9yL3ZhbGlkYXRpb25fZXJyb3InKTtcbnZhciBnZXRUeXBlID0gcmVxdWlyZSgnLi4vdXRpbC9nZXRfdHlwZScpO1xudmFyIHBhcnNlQ1NTQ29sb3IgPSByZXF1aXJlKCdjc3Njb2xvcnBhcnNlcicpLnBhcnNlQ1NTQ29sb3I7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gdmFsaWRhdGVDb2xvcihvcHRpb25zKSB7XG4gICAgdmFyIGtleSA9IG9wdGlvbnMua2V5O1xuICAgIHZhciB2YWx1ZSA9IG9wdGlvbnMudmFsdWU7XG4gICAgdmFyIHR5cGUgPSBnZXRUeXBlKHZhbHVlKTtcblxuICAgIGlmICh0eXBlICE9PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gW25ldyBWYWxpZGF0aW9uRXJyb3Ioa2V5LCB2YWx1ZSwgJ2NvbG9yIGV4cGVjdGVkLCAlcyBmb3VuZCcsIHR5cGUpXTtcbiAgICB9XG5cbiAgICBpZiAocGFyc2VDU1NDb2xvcih2YWx1ZSkgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIFtuZXcgVmFsaWRhdGlvbkVycm9yKGtleSwgdmFsdWUsICdjb2xvciBleHBlY3RlZCwgXCIlc1wiIGZvdW5kJywgdmFsdWUpXTtcbiAgICB9XG5cbiAgICByZXR1cm4gW107XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgVmFsaWRhdGlvbkVycm9yID0gcmVxdWlyZSgnLi4vZXJyb3IvdmFsaWRhdGlvbl9lcnJvcicpO1xudmFyIGdldFR5cGUgPSByZXF1aXJlKCcuLi91dGlsL2dldF90eXBlJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gdmFsaWRhdGVDb25zdGFudHMob3B0aW9ucykge1xuICAgIHZhciBrZXkgPSBvcHRpb25zLmtleTtcbiAgICB2YXIgY29uc3RhbnRzID0gb3B0aW9ucy52YWx1ZTtcbiAgICB2YXIgc3R5bGVTcGVjID0gb3B0aW9ucy5zdHlsZVNwZWM7XG5cbiAgICBpZiAoc3R5bGVTcGVjLiR2ZXJzaW9uID4gNykge1xuICAgICAgICBpZiAoY29uc3RhbnRzKSB7XG4gICAgICAgICAgICByZXR1cm4gW25ldyBWYWxpZGF0aW9uRXJyb3Ioa2V5LCBjb25zdGFudHMsICdjb25zdGFudHMgaGF2ZSBiZWVuIGRlcHJlY2F0ZWQgYXMgb2YgdjgnKV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgdHlwZSA9IGdldFR5cGUoY29uc3RhbnRzKTtcbiAgICAgICAgaWYgKHR5cGUgIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICByZXR1cm4gW25ldyBWYWxpZGF0aW9uRXJyb3Ioa2V5LCBjb25zdGFudHMsICdvYmplY3QgZXhwZWN0ZWQsICVzIGZvdW5kJywgdHlwZSldO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGVycm9ycyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBjb25zdGFudE5hbWUgaW4gY29uc3RhbnRzKSB7XG4gICAgICAgICAgICBpZiAoY29uc3RhbnROYW1lWzBdICE9PSAnQCcpIHtcbiAgICAgICAgICAgICAgICBlcnJvcnMucHVzaChuZXcgVmFsaWRhdGlvbkVycm9yKGtleSArICcuJyArIGNvbnN0YW50TmFtZSwgY29uc3RhbnRzW2NvbnN0YW50TmFtZV0sICdjb25zdGFudHMgbXVzdCBzdGFydCB3aXRoIFwiQFwiJykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlcnJvcnM7XG4gICAgfVxuXG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgVmFsaWRhdGlvbkVycm9yID0gcmVxdWlyZSgnLi4vZXJyb3IvdmFsaWRhdGlvbl9lcnJvcicpO1xudmFyIHVuYnVuZGxlID0gcmVxdWlyZSgnLi4vdXRpbC91bmJ1bmRsZV9qc29ubGludCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHZhbGlkYXRlRW51bShvcHRpb25zKSB7XG4gICAgdmFyIGtleSA9IG9wdGlvbnMua2V5O1xuICAgIHZhciB2YWx1ZSA9IG9wdGlvbnMudmFsdWU7XG4gICAgdmFyIHZhbHVlU3BlYyA9IG9wdGlvbnMudmFsdWVTcGVjO1xuICAgIHZhciBlcnJvcnMgPSBbXTtcblxuICAgIGlmICh2YWx1ZVNwZWMudmFsdWVzLmluZGV4T2YodW5idW5kbGUodmFsdWUpKSA9PT0gLTEpIHtcbiAgICAgICAgZXJyb3JzLnB1c2gobmV3IFZhbGlkYXRpb25FcnJvcihrZXksIHZhbHVlLCAnZXhwZWN0ZWQgb25lIG9mIFslc10sICVzIGZvdW5kJywgdmFsdWVTcGVjLnZhbHVlcy5qb2luKCcsICcpLCB2YWx1ZSkpO1xuICAgIH1cbiAgICByZXR1cm4gZXJyb3JzO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIFZhbGlkYXRpb25FcnJvciA9IHJlcXVpcmUoJy4uL2Vycm9yL3ZhbGlkYXRpb25fZXJyb3InKTtcbnZhciB2YWxpZGF0ZUVudW0gPSByZXF1aXJlKCcuL3ZhbGlkYXRlX2VudW0nKTtcbnZhciBnZXRUeXBlID0gcmVxdWlyZSgnLi4vdXRpbC9nZXRfdHlwZScpO1xudmFyIHVuYnVuZGxlID0gcmVxdWlyZSgnLi4vdXRpbC91bmJ1bmRsZV9qc29ubGludCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHZhbGlkYXRlRmlsdGVyKG9wdGlvbnMpIHtcbiAgICB2YXIgdmFsdWUgPSBvcHRpb25zLnZhbHVlO1xuICAgIHZhciBrZXkgPSBvcHRpb25zLmtleTtcbiAgICB2YXIgc3R5bGVTcGVjID0gb3B0aW9ucy5zdHlsZVNwZWM7XG4gICAgdmFyIHR5cGU7XG5cbiAgICB2YXIgZXJyb3JzID0gW107XG5cbiAgICBpZiAoZ2V0VHlwZSh2YWx1ZSkgIT09ICdhcnJheScpIHtcbiAgICAgICAgcmV0dXJuIFtuZXcgVmFsaWRhdGlvbkVycm9yKGtleSwgdmFsdWUsICdhcnJheSBleHBlY3RlZCwgJXMgZm91bmQnLCBnZXRUeXBlKHZhbHVlKSldO1xuICAgIH1cblxuICAgIGlmICh2YWx1ZS5sZW5ndGggPCAxKSB7XG4gICAgICAgIHJldHVybiBbbmV3IFZhbGlkYXRpb25FcnJvcihrZXksIHZhbHVlLCAnZmlsdGVyIGFycmF5IG11c3QgaGF2ZSBhdCBsZWFzdCAxIGVsZW1lbnQnKV07XG4gICAgfVxuXG4gICAgZXJyb3JzID0gZXJyb3JzLmNvbmNhdCh2YWxpZGF0ZUVudW0oe1xuICAgICAgICBrZXk6IGtleSArICdbMF0nLFxuICAgICAgICB2YWx1ZTogdmFsdWVbMF0sXG4gICAgICAgIHZhbHVlU3BlYzogc3R5bGVTcGVjLmZpbHRlcl9vcGVyYXRvcixcbiAgICAgICAgc3R5bGU6IG9wdGlvbnMuc3R5bGUsXG4gICAgICAgIHN0eWxlU3BlYzogb3B0aW9ucy5zdHlsZVNwZWNcbiAgICB9KSk7XG5cbiAgICBzd2l0Y2ggKHVuYnVuZGxlKHZhbHVlWzBdKSkge1xuICAgICAgICBjYXNlICc8JzpcbiAgICAgICAgY2FzZSAnPD0nOlxuICAgICAgICBjYXNlICc+JzpcbiAgICAgICAgY2FzZSAnPj0nOlxuICAgICAgICAgICAgaWYgKHZhbHVlLmxlbmd0aCA+PSAyICYmIHZhbHVlWzFdID09ICckdHlwZScpIHtcbiAgICAgICAgICAgICAgICBlcnJvcnMucHVzaChuZXcgVmFsaWRhdGlvbkVycm9yKGtleSwgdmFsdWUsICdcIiR0eXBlXCIgY2Fubm90IGJlIHVzZSB3aXRoIG9wZXJhdG9yIFwiJXNcIicsIHZhbHVlWzBdKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgICAgY2FzZSAnPT0nOlxuICAgICAgICBjYXNlICchPSc6XG4gICAgICAgICAgICBpZiAodmFsdWUubGVuZ3RoICE9IDMpIHtcbiAgICAgICAgICAgICAgICBlcnJvcnMucHVzaChuZXcgVmFsaWRhdGlvbkVycm9yKGtleSwgdmFsdWUsICdmaWx0ZXIgYXJyYXkgZm9yIG9wZXJhdG9yIFwiJXNcIiBtdXN0IGhhdmUgMyBlbGVtZW50cycsIHZhbHVlWzBdKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgICAgY2FzZSAnaW4nOlxuICAgICAgICBjYXNlICchaW4nOlxuICAgICAgICAgICAgaWYgKHZhbHVlLmxlbmd0aCA+PSAyKSB7XG4gICAgICAgICAgICAgICAgdHlwZSA9IGdldFR5cGUodmFsdWVbMV0pO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICBlcnJvcnMucHVzaChuZXcgVmFsaWRhdGlvbkVycm9yKGtleSArICdbMV0nLCB2YWx1ZVsxXSwgJ3N0cmluZyBleHBlY3RlZCwgJXMgZm91bmQnLCB0eXBlKSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh2YWx1ZVsxXVswXSA9PT0gJ0AnKSB7XG4gICAgICAgICAgICAgICAgICAgIGVycm9ycy5wdXNoKG5ldyBWYWxpZGF0aW9uRXJyb3Ioa2V5ICsgJ1sxXScsIHZhbHVlWzFdLCAnZmlsdGVyIGtleSBjYW5ub3QgYmUgYSBjb25zdGFudCcpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMjsgaSA8IHZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdHlwZSA9IGdldFR5cGUodmFsdWVbaV0pO1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZVsxXSA9PSAnJHR5cGUnKSB7XG4gICAgICAgICAgICAgICAgICAgIGVycm9ycyA9IGVycm9ycy5jb25jYXQodmFsaWRhdGVFbnVtKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleToga2V5ICsgJ1snICsgaSArICddJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZVtpXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlU3BlYzogc3R5bGVTcGVjLmdlb21ldHJ5X3R5cGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHlsZTogb3B0aW9ucy5zdHlsZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlU3BlYzogb3B0aW9ucy5zdHlsZVNwZWNcbiAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ3N0cmluZycgJiYgdmFsdWVbaV1bMF0gPT09ICdAJykge1xuICAgICAgICAgICAgICAgICAgICBlcnJvcnMucHVzaChuZXcgVmFsaWRhdGlvbkVycm9yKGtleSArICdbJyArIGkgKyAnXScsIHZhbHVlW2ldLCAnZmlsdGVyIHZhbHVlIGNhbm5vdCBiZSBhIGNvbnN0YW50JykpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZSAhPT0gJ3N0cmluZycgJiYgdHlwZSAhPT0gJ251bWJlcicgJiYgdHlwZSAhPT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICAgICAgICAgIGVycm9ycy5wdXNoKG5ldyBWYWxpZGF0aW9uRXJyb3Ioa2V5ICsgJ1snICsgaSArICddJywgdmFsdWVbaV0sICdzdHJpbmcsIG51bWJlciwgb3IgYm9vbGVhbiBleHBlY3RlZCwgJXMgZm91bmQnLCB0eXBlKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnYW55JzpcbiAgICAgICAgY2FzZSAnYWxsJzpcbiAgICAgICAgY2FzZSAnbm9uZSc6XG4gICAgICAgICAgICBmb3IgKGkgPSAxOyBpIDwgdmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBlcnJvcnMgPSBlcnJvcnMuY29uY2F0KHZhbGlkYXRlRmlsdGVyKHtcbiAgICAgICAgICAgICAgICAgICAga2V5OiBrZXkgKyAnWycgKyBpICsgJ10nLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWVbaV0sXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlOiBvcHRpb25zLnN0eWxlLFxuICAgICAgICAgICAgICAgICAgICBzdHlsZVNwZWM6IG9wdGlvbnMuc3R5bGVTcGVjXG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgcmV0dXJuIGVycm9ycztcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBWYWxpZGF0aW9uRXJyb3IgPSByZXF1aXJlKCcuLi9lcnJvci92YWxpZGF0aW9uX2Vycm9yJyk7XG52YXIgZ2V0VHlwZSA9IHJlcXVpcmUoJy4uL3V0aWwvZ2V0X3R5cGUnKTtcbnZhciB2YWxpZGF0ZSA9IHJlcXVpcmUoJy4vdmFsaWRhdGUnKTtcbnZhciB2YWxpZGF0ZU9iamVjdCA9IHJlcXVpcmUoJy4vdmFsaWRhdGVfb2JqZWN0Jyk7XG52YXIgdmFsaWRhdGVBcnJheSA9IHJlcXVpcmUoJy4vdmFsaWRhdGVfYXJyYXknKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiB2YWxpZGF0ZUZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICB2YXIgb3JpZ2luYWxWYWx1ZVNwZWMgPSBvcHRpb25zLnZhbHVlU3BlYztcblxuICAgIHJldHVybiB2YWxpZGF0ZU9iamVjdCh7XG4gICAgICAgIGtleTogb3B0aW9ucy5rZXksXG4gICAgICAgIHZhbHVlOiBvcHRpb25zLnZhbHVlLFxuICAgICAgICB2YWx1ZVNwZWM6IG9wdGlvbnMuc3R5bGVTcGVjLmZ1bmN0aW9uLFxuICAgICAgICBzdHlsZTogb3B0aW9ucy5zdHlsZSxcbiAgICAgICAgc3R5bGVTcGVjOiBvcHRpb25zLnN0eWxlU3BlYyxcbiAgICAgICAgb2JqZWN0RWxlbWVudFZhbGlkYXRvcnM6IHsgc3RvcHM6IHZhbGlkYXRlRnVuY3Rpb25TdG9wcyB9XG4gICAgfSk7XG5cbiAgICBmdW5jdGlvbiB2YWxpZGF0ZUZ1bmN0aW9uU3RvcHMob3B0aW9ucykge1xuICAgICAgICB2YXIgZXJyb3JzID0gW107XG4gICAgICAgIHZhciB2YWx1ZSA9IG9wdGlvbnMudmFsdWU7XG5cbiAgICAgICAgZXJyb3JzID0gZXJyb3JzLmNvbmNhdCh2YWxpZGF0ZUFycmF5KHtcbiAgICAgICAgICAgIGtleTogb3B0aW9ucy5rZXksXG4gICAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgICB2YWx1ZVNwZWM6IG9wdGlvbnMudmFsdWVTcGVjLFxuICAgICAgICAgICAgc3R5bGU6IG9wdGlvbnMuc3R5bGUsXG4gICAgICAgICAgICBzdHlsZVNwZWM6IG9wdGlvbnMuc3R5bGVTcGVjLFxuICAgICAgICAgICAgYXJyYXlFbGVtZW50VmFsaWRhdG9yOiB2YWxpZGF0ZUZ1bmN0aW9uU3RvcFxuICAgICAgICB9KSk7XG5cbiAgICAgICAgaWYgKGdldFR5cGUodmFsdWUpID09PSAnYXJyYXknICYmIHZhbHVlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgZXJyb3JzLnB1c2gobmV3IFZhbGlkYXRpb25FcnJvcihvcHRpb25zLmtleSwgdmFsdWUsICdhcnJheSBtdXN0IGhhdmUgYXQgbGVhc3Qgb25lIHN0b3AnKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZXJyb3JzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHZhbGlkYXRlRnVuY3Rpb25TdG9wKG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIGVycm9ycyA9IFtdO1xuICAgICAgICB2YXIgdmFsdWUgPSBvcHRpb25zLnZhbHVlO1xuICAgICAgICB2YXIga2V5ID0gb3B0aW9ucy5rZXk7XG5cbiAgICAgICAgaWYgKGdldFR5cGUodmFsdWUpICE9PSAnYXJyYXknKSB7XG4gICAgICAgICAgICByZXR1cm4gW25ldyBWYWxpZGF0aW9uRXJyb3Ioa2V5LCB2YWx1ZSwgJ2FycmF5IGV4cGVjdGVkLCAlcyBmb3VuZCcsIGdldFR5cGUodmFsdWUpKV07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodmFsdWUubGVuZ3RoICE9PSAyKSB7XG4gICAgICAgICAgICByZXR1cm4gW25ldyBWYWxpZGF0aW9uRXJyb3Ioa2V5LCB2YWx1ZSwgJ2FycmF5IGxlbmd0aCAlZCBleHBlY3RlZCwgbGVuZ3RoICVkIGZvdW5kJywgMiwgdmFsdWUubGVuZ3RoKV07XG4gICAgICAgIH1cblxuICAgICAgICBlcnJvcnMgPSBlcnJvcnMuY29uY2F0KHZhbGlkYXRlKHtcbiAgICAgICAgICAgIGtleToga2V5ICsgJ1swXScsXG4gICAgICAgICAgICB2YWx1ZTogdmFsdWVbMF0sXG4gICAgICAgICAgICB2YWx1ZVNwZWM6IHt0eXBlOiAnbnVtYmVyJ30sXG4gICAgICAgICAgICBzdHlsZTogb3B0aW9ucy5zdHlsZSxcbiAgICAgICAgICAgIHN0eWxlU3BlYzogb3B0aW9ucy5zdHlsZVNwZWNcbiAgICAgICAgfSkpO1xuXG4gICAgICAgIGVycm9ycyA9IGVycm9ycy5jb25jYXQodmFsaWRhdGUoe1xuICAgICAgICAgICAga2V5OiBrZXkgKyAnWzFdJyxcbiAgICAgICAgICAgIHZhbHVlOiB2YWx1ZVsxXSxcbiAgICAgICAgICAgIHZhbHVlU3BlYzogb3JpZ2luYWxWYWx1ZVNwZWMsXG4gICAgICAgICAgICBzdHlsZTogb3B0aW9ucy5zdHlsZSxcbiAgICAgICAgICAgIHN0eWxlU3BlYzogb3B0aW9ucy5zdHlsZVNwZWNcbiAgICAgICAgfSkpO1xuXG4gICAgICAgIGlmIChnZXRUeXBlKHZhbHVlWzBdKSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIGlmIChvcmlnaW5hbFZhbHVlU3BlYy5mdW5jdGlvbiA9PT0gJ3BpZWNld2lzZS1jb25zdGFudCcgJiYgdmFsdWVbMF0gJSAxICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgZXJyb3JzLnB1c2gobmV3IFZhbGlkYXRpb25FcnJvcihrZXkgKyAnWzBdJywgdmFsdWVbMF0sICd6b29tIGxldmVsIGZvciBwaWVjZXdpc2UtY29uc3RhbnQgZnVuY3Rpb25zIG11c3QgYmUgYW4gaW50ZWdlcicpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG9wdGlvbnMuYXJyYXlJbmRleCAhPT0gMCkge1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZVswXSA8IG9wdGlvbnMuYXJyYXlbb3B0aW9ucy5hcnJheUluZGV4IC0gMV1bMF0pIHtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JzLnB1c2gobmV3IFZhbGlkYXRpb25FcnJvcihrZXkgKyAnWzBdJywgdmFsdWVbMF0sICdhcnJheSBzdG9wcyBtdXN0IGFwcGVhciBpbiBhc2NlbmRpbmcgb3JkZXInKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGVycm9ycztcbiAgICB9XG5cbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBWYWxpZGF0aW9uRXJyb3IgPSByZXF1aXJlKCcuLi9lcnJvci92YWxpZGF0aW9uX2Vycm9yJyk7XG52YXIgdW5idW5kbGUgPSByZXF1aXJlKCcuLi91dGlsL3VuYnVuZGxlX2pzb25saW50Jyk7XG52YXIgdmFsaWRhdGVPYmplY3QgPSByZXF1aXJlKCcuL3ZhbGlkYXRlX29iamVjdCcpO1xudmFyIHZhbGlkYXRlRmlsdGVyID0gcmVxdWlyZSgnLi92YWxpZGF0ZV9maWx0ZXInKTtcbnZhciB2YWxpZGF0ZVBhaW50UHJvcGVydHkgPSByZXF1aXJlKCcuL3ZhbGlkYXRlX3BhaW50X3Byb3BlcnR5Jyk7XG52YXIgdmFsaWRhdGVMYXlvdXRQcm9wZXJ0eSA9IHJlcXVpcmUoJy4vdmFsaWRhdGVfbGF5b3V0X3Byb3BlcnR5Jyk7XG52YXIgZXh0ZW5kID0gcmVxdWlyZSgnLi4vdXRpbC9leHRlbmQnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiB2YWxpZGF0ZUxheWVyKG9wdGlvbnMpIHtcbiAgICB2YXIgZXJyb3JzID0gW107XG5cbiAgICB2YXIgbGF5ZXIgPSBvcHRpb25zLnZhbHVlO1xuICAgIHZhciBrZXkgPSBvcHRpb25zLmtleTtcbiAgICB2YXIgc3R5bGUgPSBvcHRpb25zLnN0eWxlO1xuICAgIHZhciBzdHlsZVNwZWMgPSBvcHRpb25zLnN0eWxlU3BlYztcblxuICAgIGlmICghbGF5ZXIudHlwZSAmJiAhbGF5ZXIucmVmKSB7XG4gICAgICAgIGVycm9ycy5wdXNoKG5ldyBWYWxpZGF0aW9uRXJyb3Ioa2V5LCBsYXllciwgJ2VpdGhlciBcInR5cGVcIiBvciBcInJlZlwiIGlzIHJlcXVpcmVkJykpO1xuICAgIH1cbiAgICB2YXIgdHlwZSA9IHVuYnVuZGxlKGxheWVyLnR5cGUpO1xuICAgIHZhciByZWYgPSB1bmJ1bmRsZShsYXllci5yZWYpO1xuXG4gICAgaWYgKGxheWVyLmlkKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb3B0aW9ucy5hcnJheUluZGV4OyBpKyspIHtcbiAgICAgICAgICAgIHZhciBvdGhlckxheWVyID0gc3R5bGUubGF5ZXJzW2ldO1xuICAgICAgICAgICAgaWYgKHVuYnVuZGxlKG90aGVyTGF5ZXIuaWQpID09PSB1bmJ1bmRsZShsYXllci5pZCkpIHtcbiAgICAgICAgICAgICAgICBlcnJvcnMucHVzaChuZXcgVmFsaWRhdGlvbkVycm9yKGtleSwgbGF5ZXIuaWQsICdkdXBsaWNhdGUgbGF5ZXIgaWQgXCIlc1wiLCBwcmV2aW91c2x5IHVzZWQgYXQgbGluZSAlZCcsIGxheWVyLmlkLCBvdGhlckxheWVyLmlkLl9fbGluZV9fKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoJ3JlZicgaW4gbGF5ZXIpIHtcbiAgICAgICAgWyd0eXBlJywgJ3NvdXJjZScsICdzb3VyY2UtbGF5ZXInLCAnZmlsdGVyJywgJ2xheW91dCddLmZvckVhY2goZnVuY3Rpb24gKHApIHtcbiAgICAgICAgICAgIGlmIChwIGluIGxheWVyKSB7XG4gICAgICAgICAgICAgICAgZXJyb3JzLnB1c2gobmV3IFZhbGlkYXRpb25FcnJvcihrZXksIGxheWVyW3BdLCAnXCIlc1wiIGlzIHByb2hpYml0ZWQgZm9yIHJlZiBsYXllcnMnLCBwKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHZhciBwYXJlbnQ7XG5cbiAgICAgICAgc3R5bGUubGF5ZXJzLmZvckVhY2goZnVuY3Rpb24obGF5ZXIpIHtcbiAgICAgICAgICAgIGlmIChsYXllci5pZCA9PSByZWYpIHBhcmVudCA9IGxheWVyO1xuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoIXBhcmVudCkge1xuICAgICAgICAgICAgZXJyb3JzLnB1c2gobmV3IFZhbGlkYXRpb25FcnJvcihrZXksIGxheWVyLnJlZiwgJ3JlZiBsYXllciBcIiVzXCIgbm90IGZvdW5kJywgcmVmKSk7XG4gICAgICAgIH0gZWxzZSBpZiAocGFyZW50LnJlZikge1xuICAgICAgICAgICAgZXJyb3JzLnB1c2gobmV3IFZhbGlkYXRpb25FcnJvcihrZXksIGxheWVyLnJlZiwgJ3JlZiBjYW5ub3QgcmVmZXJlbmNlIGFub3RoZXIgcmVmIGxheWVyJykpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdHlwZSA9IHVuYnVuZGxlKHBhcmVudC50eXBlKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSBpZiAodHlwZSAhPT0gJ2JhY2tncm91bmQnKSB7XG4gICAgICAgIGlmICghbGF5ZXIuc291cmNlKSB7XG4gICAgICAgICAgICBlcnJvcnMucHVzaChuZXcgVmFsaWRhdGlvbkVycm9yKGtleSwgbGF5ZXIsICdtaXNzaW5nIHJlcXVpcmVkIHByb3BlcnR5IFwic291cmNlXCInKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgc291cmNlID0gc3R5bGUuc291cmNlc1tsYXllci5zb3VyY2VdO1xuICAgICAgICAgICAgaWYgKCFzb3VyY2UpIHtcbiAgICAgICAgICAgICAgICBlcnJvcnMucHVzaChuZXcgVmFsaWRhdGlvbkVycm9yKGtleSwgbGF5ZXIuc291cmNlLCAnc291cmNlIFwiJXNcIiBub3QgZm91bmQnLCBsYXllci5zb3VyY2UpKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc291cmNlLnR5cGUgPT0gJ3ZlY3RvcicgJiYgdHlwZSA9PSAncmFzdGVyJykge1xuICAgICAgICAgICAgICAgIGVycm9ycy5wdXNoKG5ldyBWYWxpZGF0aW9uRXJyb3Ioa2V5LCBsYXllci5zb3VyY2UsICdsYXllciBcIiVzXCIgcmVxdWlyZXMgYSByYXN0ZXIgc291cmNlJywgbGF5ZXIuaWQpKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc291cmNlLnR5cGUgPT0gJ3Jhc3RlcicgJiYgdHlwZSAhPSAncmFzdGVyJykge1xuICAgICAgICAgICAgICAgIGVycm9ycy5wdXNoKG5ldyBWYWxpZGF0aW9uRXJyb3Ioa2V5LCBsYXllci5zb3VyY2UsICdsYXllciBcIiVzXCIgcmVxdWlyZXMgYSB2ZWN0b3Igc291cmNlJywgbGF5ZXIuaWQpKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc291cmNlLnR5cGUgPT0gJ3ZlY3RvcicgJiYgIWxheWVyWydzb3VyY2UtbGF5ZXInXSkge1xuICAgICAgICAgICAgICAgIGVycm9ycy5wdXNoKG5ldyBWYWxpZGF0aW9uRXJyb3Ioa2V5LCBsYXllciwgJ2xheWVyIFwiJXNcIiBtdXN0IHNwZWNpZnkgYSBcInNvdXJjZS1sYXllclwiJywgbGF5ZXIuaWQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGVycm9ycyA9IGVycm9ycy5jb25jYXQodmFsaWRhdGVPYmplY3Qoe1xuICAgICAgICBrZXk6IGtleSxcbiAgICAgICAgdmFsdWU6IGxheWVyLFxuICAgICAgICB2YWx1ZVNwZWM6IHN0eWxlU3BlYy5sYXllcixcbiAgICAgICAgc3R5bGU6IG9wdGlvbnMuc3R5bGUsXG4gICAgICAgIHN0eWxlU3BlYzogb3B0aW9ucy5zdHlsZVNwZWMsXG4gICAgICAgIG9iamVjdEVsZW1lbnRWYWxpZGF0b3JzOiB7XG4gICAgICAgICAgICBmaWx0ZXI6IHZhbGlkYXRlRmlsdGVyLFxuICAgICAgICAgICAgbGF5b3V0OiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbGlkYXRlT2JqZWN0KHtcbiAgICAgICAgICAgICAgICAgICAgbGF5ZXI6IGxheWVyLFxuICAgICAgICAgICAgICAgICAgICBrZXk6IG9wdGlvbnMua2V5LFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogb3B0aW9ucy52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgc3R5bGU6IG9wdGlvbnMuc3R5bGUsXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlU3BlYzogb3B0aW9ucy5zdHlsZVNwZWMsXG4gICAgICAgICAgICAgICAgICAgIG9iamVjdEVsZW1lbnRWYWxpZGF0b3JzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAnKic6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsaWRhdGVMYXlvdXRQcm9wZXJ0eShleHRlbmQoe2xheWVyVHlwZTogdHlwZX0sIG9wdGlvbnMpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHBhaW50OiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbGlkYXRlT2JqZWN0KHtcbiAgICAgICAgICAgICAgICAgICAgbGF5ZXI6IGxheWVyLFxuICAgICAgICAgICAgICAgICAgICBrZXk6IG9wdGlvbnMua2V5LFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogb3B0aW9ucy52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgc3R5bGU6IG9wdGlvbnMuc3R5bGUsXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlU3BlYzogb3B0aW9ucy5zdHlsZVNwZWMsXG4gICAgICAgICAgICAgICAgICAgIG9iamVjdEVsZW1lbnRWYWxpZGF0b3JzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAnKic6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsaWRhdGVQYWludFByb3BlcnR5KGV4dGVuZCh7bGF5ZXJUeXBlOiB0eXBlfSwgb3B0aW9ucykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KSk7XG5cbiAgICByZXR1cm4gZXJyb3JzO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHZhbGlkYXRlID0gcmVxdWlyZSgnLi92YWxpZGF0ZScpO1xudmFyIFZhbGlkYXRpb25FcnJvciA9IHJlcXVpcmUoJy4uL2Vycm9yL3ZhbGlkYXRpb25fZXJyb3InKTtcblxuLyoqXG4gKiBAcGFyYW0gb3B0aW9uc1xuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmtleV1cbiAqIEBwYXJhbSBvcHRpb25zLnZhbHVlXG4gKiBAcGFyYW0gW29wdGlvbnMudmFsdWVTcGVjXVxuICogQHBhcmFtIFtvcHRpb25zLnN0eWxlXVxuICogQHBhcmFtIFtvcHRpb25zLnN0eWxlU3BlY11cbiAqIEBwYXJhbSBbb3B0aW9ucy5sYXllcl1cbiAqIEBwYXJhbSBvcHRpb25zLm9iamVjdEtleVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHZhbGlkYXRlTGF5b3V0UHJvcGVydHkob3B0aW9ucykge1xuICAgIHZhciBrZXkgPSBvcHRpb25zLmtleTtcbiAgICB2YXIgc3R5bGUgPSBvcHRpb25zLnN0eWxlO1xuICAgIHZhciBzdHlsZVNwZWMgPSBvcHRpb25zLnN0eWxlU3BlYztcbiAgICB2YXIgdmFsdWUgPSBvcHRpb25zLnZhbHVlO1xuICAgIHZhciBwcm9wZXJ0eUtleSA9IG9wdGlvbnMub2JqZWN0S2V5O1xuICAgIHZhciBsYXllclNwZWMgPSBzdHlsZVNwZWNbJ2xheW91dF8nICsgb3B0aW9ucy5sYXllclR5cGVdO1xuXG4gICAgaWYgKG9wdGlvbnMudmFsdWVTcGVjIHx8IGxheWVyU3BlY1twcm9wZXJ0eUtleV0pIHtcbiAgICAgICAgcmV0dXJuIHZhbGlkYXRlKHtcbiAgICAgICAgICAgIGtleTogb3B0aW9ucy5rZXksXG4gICAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgICB2YWx1ZVNwZWM6IG9wdGlvbnMudmFsdWVTcGVjIHx8IGxheWVyU3BlY1twcm9wZXJ0eUtleV0sXG4gICAgICAgICAgICBzdHlsZTogc3R5bGUsXG4gICAgICAgICAgICBzdHlsZVNwZWM6IHN0eWxlU3BlY1xuICAgICAgICB9KTtcblxuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBbbmV3IFZhbGlkYXRpb25FcnJvcihrZXksIHZhbHVlLCAndW5rbm93biBwcm9wZXJ0eSBcIiVzXCInLCBwcm9wZXJ0eUtleSldO1xuICAgIH1cblxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGdldFR5cGUgPSByZXF1aXJlKCcuLi91dGlsL2dldF90eXBlJyk7XG52YXIgVmFsaWRhdGlvbkVycm9yID0gcmVxdWlyZSgnLi4vZXJyb3IvdmFsaWRhdGlvbl9lcnJvcicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHZhbGlkYXRlTnVtYmVyKG9wdGlvbnMpIHtcbiAgICB2YXIga2V5ID0gb3B0aW9ucy5rZXk7XG4gICAgdmFyIHZhbHVlID0gb3B0aW9ucy52YWx1ZTtcbiAgICB2YXIgdmFsdWVTcGVjID0gb3B0aW9ucy52YWx1ZVNwZWM7XG4gICAgdmFyIHR5cGUgPSBnZXRUeXBlKHZhbHVlKTtcblxuICAgIGlmICh0eXBlICE9PSAnbnVtYmVyJykge1xuICAgICAgICByZXR1cm4gW25ldyBWYWxpZGF0aW9uRXJyb3Ioa2V5LCB2YWx1ZSwgJ251bWJlciBleHBlY3RlZCwgJXMgZm91bmQnLCB0eXBlKV07XG4gICAgfVxuXG4gICAgaWYgKCdtaW5pbXVtJyBpbiB2YWx1ZVNwZWMgJiYgdmFsdWUgPCB2YWx1ZVNwZWMubWluaW11bSkge1xuICAgICAgICByZXR1cm4gW25ldyBWYWxpZGF0aW9uRXJyb3Ioa2V5LCB2YWx1ZSwgJyVzIGlzIGxlc3MgdGhhbiB0aGUgbWluaW11bSB2YWx1ZSAlcycsIHZhbHVlLCB2YWx1ZVNwZWMubWluaW11bSldO1xuICAgIH1cblxuICAgIGlmICgnbWF4aW11bScgaW4gdmFsdWVTcGVjICYmIHZhbHVlID4gdmFsdWVTcGVjLm1heGltdW0pIHtcbiAgICAgICAgcmV0dXJuIFtuZXcgVmFsaWRhdGlvbkVycm9yKGtleSwgdmFsdWUsICclcyBpcyBncmVhdGVyIHRoYW4gdGhlIG1heGltdW0gdmFsdWUgJXMnLCB2YWx1ZSwgdmFsdWVTcGVjLm1heGltdW0pXTtcbiAgICB9XG5cbiAgICByZXR1cm4gW107XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgVmFsaWRhdGlvbkVycm9yID0gcmVxdWlyZSgnLi4vZXJyb3IvdmFsaWRhdGlvbl9lcnJvcicpO1xudmFyIGdldFR5cGUgPSByZXF1aXJlKCcuLi91dGlsL2dldF90eXBlJyk7XG52YXIgdmFsaWRhdGUgPSByZXF1aXJlKCcuL3ZhbGlkYXRlJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gdmFsaWRhdGVPYmplY3Qob3B0aW9ucykge1xuICAgIHZhciBrZXkgPSBvcHRpb25zLmtleTtcbiAgICB2YXIgb2JqZWN0ID0gb3B0aW9ucy52YWx1ZTtcbiAgICB2YXIgdmFsdWVTcGVjID0gb3B0aW9ucy52YWx1ZVNwZWM7XG4gICAgdmFyIG9iamVjdEVsZW1lbnRWYWxpZGF0b3JzID0gb3B0aW9ucy5vYmplY3RFbGVtZW50VmFsaWRhdG9ycyB8fCB7fTtcbiAgICB2YXIgc3R5bGUgPSBvcHRpb25zLnN0eWxlO1xuICAgIHZhciBzdHlsZVNwZWMgPSBvcHRpb25zLnN0eWxlU3BlYztcbiAgICB2YXIgZXJyb3JzID0gW107XG5cbiAgICB2YXIgdHlwZSA9IGdldFR5cGUob2JqZWN0KTtcbiAgICBpZiAodHlwZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIFtuZXcgVmFsaWRhdGlvbkVycm9yKGtleSwgb2JqZWN0LCAnb2JqZWN0IGV4cGVjdGVkLCAlcyBmb3VuZCcsIHR5cGUpXTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBvYmplY3RLZXkgaW4gb2JqZWN0KSB7XG4gICAgICAgIHZhciB2YWx1ZVNwZWNLZXkgPSBvYmplY3RLZXkuc3BsaXQoJy4nKVswXTsgLy8gdHJlYXQgJ3BhaW50LionIGFzICdwYWludCdcbiAgICAgICAgdmFyIG9iamVjdEVsZW1lbnRTcGVjID0gdmFsdWVTcGVjICYmICh2YWx1ZVNwZWNbdmFsdWVTcGVjS2V5XSB8fCB2YWx1ZVNwZWNbJyonXSk7XG4gICAgICAgIHZhciBvYmplY3RFbGVtZW50VmFsaWRhdG9yID0gb2JqZWN0RWxlbWVudFZhbGlkYXRvcnNbdmFsdWVTcGVjS2V5XSB8fCBvYmplY3RFbGVtZW50VmFsaWRhdG9yc1snKiddO1xuXG4gICAgICAgIGlmIChvYmplY3RFbGVtZW50U3BlYyB8fCBvYmplY3RFbGVtZW50VmFsaWRhdG9yKSB7XG4gICAgICAgICAgICBlcnJvcnMgPSBlcnJvcnMuY29uY2F0KChvYmplY3RFbGVtZW50VmFsaWRhdG9yIHx8IHZhbGlkYXRlKSh7XG4gICAgICAgICAgICAgICAga2V5OiAoa2V5ID8ga2V5ICsgJy4nIDoga2V5KSArIG9iamVjdEtleSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogb2JqZWN0W29iamVjdEtleV0sXG4gICAgICAgICAgICAgICAgdmFsdWVTcGVjOiBvYmplY3RFbGVtZW50U3BlYyxcbiAgICAgICAgICAgICAgICBzdHlsZTogc3R5bGUsXG4gICAgICAgICAgICAgICAgc3R5bGVTcGVjOiBzdHlsZVNwZWMsXG4gICAgICAgICAgICAgICAgb2JqZWN0OiBvYmplY3QsXG4gICAgICAgICAgICAgICAgb2JqZWN0S2V5OiBvYmplY3RLZXlcbiAgICAgICAgICAgIH0pKTtcblxuICAgICAgICAvLyB0b2xlcmF0ZSByb290LWxldmVsIGV4dHJhIGtleXMgJiBhcmJpdHJhcnkgbGF5ZXIgcHJvcGVydGllc1xuICAgICAgICAvLyBUT0RPIHJlbW92ZSB0aGlzIGxheWVyLXNwZWNpZmljIGxvZ2ljXG4gICAgICAgIH0gZWxzZSBpZiAoa2V5ICE9PSAnJyAmJiBrZXkuc3BsaXQoJy4nKS5sZW5ndGggIT09IDEpIHtcbiAgICAgICAgICAgIGVycm9ycy5wdXNoKG5ldyBWYWxpZGF0aW9uRXJyb3Ioa2V5LCBvYmplY3Rbb2JqZWN0S2V5XSwgJ3Vua25vd24gcHJvcGVydHkgXCIlc1wiJywgb2JqZWN0S2V5KSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKHZhbHVlU3BlY0tleSBpbiB2YWx1ZVNwZWMpIHtcbiAgICAgICAgaWYgKHZhbHVlU3BlY1t2YWx1ZVNwZWNLZXldLnJlcXVpcmVkICYmIHZhbHVlU3BlY1t2YWx1ZVNwZWNLZXldWydkZWZhdWx0J10gPT09IHVuZGVmaW5lZCAmJiBvYmplY3RbdmFsdWVTcGVjS2V5XSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBlcnJvcnMucHVzaChuZXcgVmFsaWRhdGlvbkVycm9yKGtleSwgb2JqZWN0LCAnbWlzc2luZyByZXF1aXJlZCBwcm9wZXJ0eSBcIiVzXCInLCB2YWx1ZVNwZWNLZXkpKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBlcnJvcnM7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdmFsaWRhdGUgPSByZXF1aXJlKCcuL3ZhbGlkYXRlJyk7XG52YXIgVmFsaWRhdGlvbkVycm9yID0gcmVxdWlyZSgnLi4vZXJyb3IvdmFsaWRhdGlvbl9lcnJvcicpO1xuXG4vKipcbiAqIEBwYXJhbSBvcHRpb25zXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMua2V5XVxuICogQHBhcmFtIG9wdGlvbnMudmFsdWVcbiAqIEBwYXJhbSBbb3B0aW9ucy52YWx1ZVNwZWNdXG4gKiBAcGFyYW0gW29wdGlvbnMuc3R5bGVdXG4gKiBAcGFyYW0gW29wdGlvbnMuc3R5bGVTcGVjXVxuICogQHBhcmFtIFtvcHRpb25zLmxheWVyXVxuICogQHBhcmFtIG9wdGlvbnMub2JqZWN0S2V5XG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gdmFsaWRhdGVQYWludFByb3BlcnR5KG9wdGlvbnMpIHtcbiAgICB2YXIga2V5ID0gb3B0aW9ucy5rZXk7XG4gICAgdmFyIHN0eWxlID0gb3B0aW9ucy5zdHlsZTtcbiAgICB2YXIgc3R5bGVTcGVjID0gb3B0aW9ucy5zdHlsZVNwZWM7XG4gICAgdmFyIHZhbHVlID0gb3B0aW9ucy52YWx1ZTtcbiAgICB2YXIgcHJvcGVydHlLZXkgPSBvcHRpb25zLm9iamVjdEtleTtcbiAgICB2YXIgbGF5ZXJTcGVjID0gc3R5bGVTcGVjWydwYWludF8nICsgb3B0aW9ucy5sYXllclR5cGVdO1xuXG4gICAgdmFyIHRyYW5zaXRpb25NYXRjaCA9IHByb3BlcnR5S2V5Lm1hdGNoKC9eKC4qKS10cmFuc2l0aW9uJC8pO1xuXG4gICAgaWYgKHRyYW5zaXRpb25NYXRjaCAmJiBsYXllclNwZWNbdHJhbnNpdGlvbk1hdGNoWzFdXSAmJiBsYXllclNwZWNbdHJhbnNpdGlvbk1hdGNoWzFdXS50cmFuc2l0aW9uKSB7XG4gICAgICAgIHJldHVybiB2YWxpZGF0ZSh7XG4gICAgICAgICAgICBrZXk6IGtleSxcbiAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgICAgIHZhbHVlU3BlYzogc3R5bGVTcGVjLnRyYW5zaXRpb24sXG4gICAgICAgICAgICBzdHlsZTogc3R5bGUsXG4gICAgICAgICAgICBzdHlsZVNwZWM6IHN0eWxlU3BlY1xuICAgICAgICB9KTtcblxuICAgIH0gZWxzZSBpZiAob3B0aW9ucy52YWx1ZVNwZWMgfHwgbGF5ZXJTcGVjW3Byb3BlcnR5S2V5XSkge1xuICAgICAgICByZXR1cm4gdmFsaWRhdGUoe1xuICAgICAgICAgICAga2V5OiBvcHRpb25zLmtleSxcbiAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgICAgIHZhbHVlU3BlYzogb3B0aW9ucy52YWx1ZVNwZWMgfHwgbGF5ZXJTcGVjW3Byb3BlcnR5S2V5XSxcbiAgICAgICAgICAgIHN0eWxlOiBzdHlsZSxcbiAgICAgICAgICAgIHN0eWxlU3BlYzogc3R5bGVTcGVjXG4gICAgICAgIH0pO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFtuZXcgVmFsaWRhdGlvbkVycm9yKGtleSwgdmFsdWUsICd1bmtub3duIHByb3BlcnR5IFwiJXNcIicsIHByb3BlcnR5S2V5KV07XG4gICAgfVxuXG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgVmFsaWRhdGlvbkVycm9yID0gcmVxdWlyZSgnLi4vZXJyb3IvdmFsaWRhdGlvbl9lcnJvcicpO1xudmFyIHVuYnVuZGxlID0gcmVxdWlyZSgnLi4vdXRpbC91bmJ1bmRsZV9qc29ubGludCcpO1xudmFyIHZhbGlkYXRlT2JqZWN0ID0gcmVxdWlyZSgnLi92YWxpZGF0ZV9vYmplY3QnKTtcbnZhciB2YWxpZGF0ZUVudW0gPSByZXF1aXJlKCcuL3ZhbGlkYXRlX2VudW0nKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiB2YWxpZGF0ZVNvdXJjZShvcHRpb25zKSB7XG4gICAgdmFyIHZhbHVlID0gb3B0aW9ucy52YWx1ZTtcbiAgICB2YXIga2V5ID0gb3B0aW9ucy5rZXk7XG4gICAgdmFyIHN0eWxlU3BlYyA9IG9wdGlvbnMuc3R5bGVTcGVjO1xuICAgIHZhciBzdHlsZSA9IG9wdGlvbnMuc3R5bGU7XG5cbiAgICBpZiAoIXZhbHVlLnR5cGUpIHtcbiAgICAgICAgcmV0dXJuIFtuZXcgVmFsaWRhdGlvbkVycm9yKGtleSwgdmFsdWUsICdcInR5cGVcIiBpcyByZXF1aXJlZCcpXTtcbiAgICB9XG5cbiAgICB2YXIgdHlwZSA9IHVuYnVuZGxlKHZhbHVlLnR5cGUpO1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlICd2ZWN0b3InOlxuICAgICAgICBjYXNlICdyYXN0ZXInOlxuICAgICAgICAgICAgdmFyIGVycm9ycyA9IFtdO1xuICAgICAgICAgICAgZXJyb3JzID0gZXJyb3JzLmNvbmNhdCh2YWxpZGF0ZU9iamVjdCh7XG4gICAgICAgICAgICAgICAga2V5OiBrZXksXG4gICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgICAgICAgIHZhbHVlU3BlYzogc3R5bGVTcGVjLnNvdXJjZV90aWxlLFxuICAgICAgICAgICAgICAgIHN0eWxlOiBvcHRpb25zLnN0eWxlLFxuICAgICAgICAgICAgICAgIHN0eWxlU3BlYzogc3R5bGVTcGVjXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICBpZiAoJ3VybCcgaW4gdmFsdWUpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBwcm9wIGluIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChbJ3R5cGUnLCAndXJsJywgJ3RpbGVTaXplJ10uaW5kZXhPZihwcm9wKSA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9ycy5wdXNoKG5ldyBWYWxpZGF0aW9uRXJyb3Ioa2V5ICsgJy4nICsgcHJvcCwgdmFsdWVbcHJvcF0sICdhIHNvdXJjZSB3aXRoIGEgXCJ1cmxcIiBwcm9wZXJ0eSBtYXkgbm90IGluY2x1ZGUgYSBcIiVzXCIgcHJvcGVydHknLCBwcm9wKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZXJyb3JzO1xuXG4gICAgICAgIGNhc2UgJ2dlb2pzb24nOlxuICAgICAgICAgICAgcmV0dXJuIHZhbGlkYXRlT2JqZWN0KHtcbiAgICAgICAgICAgICAgICBrZXk6IGtleSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgICAgICAgdmFsdWVTcGVjOiBzdHlsZVNwZWMuc291cmNlX2dlb2pzb24sXG4gICAgICAgICAgICAgICAgc3R5bGU6IHN0eWxlLFxuICAgICAgICAgICAgICAgIHN0eWxlU3BlYzogc3R5bGVTcGVjXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICBjYXNlICd2aWRlbyc6XG4gICAgICAgICAgICByZXR1cm4gdmFsaWRhdGVPYmplY3Qoe1xuICAgICAgICAgICAgICAgIGtleToga2V5LFxuICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgICAgICAgICB2YWx1ZVNwZWM6IHN0eWxlU3BlYy5zb3VyY2VfdmlkZW8sXG4gICAgICAgICAgICAgICAgc3R5bGU6IHN0eWxlLFxuICAgICAgICAgICAgICAgIHN0eWxlU3BlYzogc3R5bGVTcGVjXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICBjYXNlICdpbWFnZSc6XG4gICAgICAgICAgICByZXR1cm4gdmFsaWRhdGVPYmplY3Qoe1xuICAgICAgICAgICAgICAgIGtleToga2V5LFxuICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgICAgICAgICB2YWx1ZVNwZWM6IHN0eWxlU3BlYy5zb3VyY2VfaW1hZ2UsXG4gICAgICAgICAgICAgICAgc3R5bGU6IHN0eWxlLFxuICAgICAgICAgICAgICAgIHN0eWxlU3BlYzogc3R5bGVTcGVjXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIHZhbGlkYXRlRW51bSh7XG4gICAgICAgICAgICAgICAga2V5OiBrZXkgKyAnLnR5cGUnLFxuICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZS50eXBlLFxuICAgICAgICAgICAgICAgIHZhbHVlU3BlYzoge3ZhbHVlczogWyd2ZWN0b3InLCAncmFzdGVyJywgJ2dlb2pzb24nLCAndmlkZW8nLCAnaW1hZ2UnXX0sXG4gICAgICAgICAgICAgICAgc3R5bGU6IHN0eWxlLFxuICAgICAgICAgICAgICAgIHN0eWxlU3BlYzogc3R5bGVTcGVjXG4gICAgICAgICAgICB9KTtcbiAgICB9XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZ2V0VHlwZSA9IHJlcXVpcmUoJy4uL3V0aWwvZ2V0X3R5cGUnKTtcbnZhciBWYWxpZGF0aW9uRXJyb3IgPSByZXF1aXJlKCcuLi9lcnJvci92YWxpZGF0aW9uX2Vycm9yJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gdmFsaWRhdGVTdHJpbmcob3B0aW9ucykge1xuICAgIHZhciB2YWx1ZSA9IG9wdGlvbnMudmFsdWU7XG4gICAgdmFyIGtleSA9IG9wdGlvbnMua2V5O1xuICAgIHZhciB0eXBlID0gZ2V0VHlwZSh2YWx1ZSk7XG5cbiAgICBpZiAodHlwZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIFtuZXcgVmFsaWRhdGlvbkVycm9yKGtleSwgdmFsdWUsICdzdHJpbmcgZXhwZWN0ZWQsICVzIGZvdW5kJywgdHlwZSldO1xuICAgIH1cblxuICAgIHJldHVybiBbXTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB2YWxpZGF0ZUNvbnN0YW50cyA9IHJlcXVpcmUoJy4vdmFsaWRhdGUvdmFsaWRhdGVfY29uc3RhbnRzJyk7XG52YXIgdmFsaWRhdGUgPSByZXF1aXJlKCcuL3ZhbGlkYXRlL3ZhbGlkYXRlJyk7XG52YXIgbGF0ZXN0U3R5bGVTcGVjID0gcmVxdWlyZSgnLi4vcmVmZXJlbmNlL2xhdGVzdC5taW4nKTtcblxuLyoqXG4gKiBWYWxpZGF0ZSBhIE1hcGJveCBHTCBzdHlsZSBhZ2FpbnN0IHRoZSBzdHlsZSBzcGVjaWZpY2F0aW9uLiBUaGlzIGVudHJ5cG9pbnQsXG4gKiBgbWFwYm94LWdsLXN0eWxlLXNwZWMvbGliL3ZhbGlkYXRlX3N0eWxlLm1pbmAsIGlzIGRlc2lnbmVkIHRvIHByb2R1Y2UgYXNcbiAqIHNtYWxsIGEgYnJvd3NlcmlmeSBidW5kbGUgYXMgcG9zc2libGUgYnkgb21pdHRpbmcgdW5uZWNlc3NhcnkgZnVuY3Rpb25hbGl0eVxuICogYW5kIGxlZ2FjeSBzdHlsZSBzcGVjaWZpY2F0aW9ucy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gc3R5bGUgVGhlIHN0eWxlIHRvIGJlIHZhbGlkYXRlZC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbc3R5bGVTcGVjXSBUaGUgc3R5bGUgc3BlY2lmaWNhdGlvbiB0byB2YWxpZGF0ZSBhZ2FpbnN0LlxuICogICAgIElmIG9taXR0ZWQsIHRoZSBsYXRlc3Qgc3R5bGUgc3BlYyBpcyB1c2VkLlxuICogQHJldHVybnMge0FycmF5PFZhbGlkYXRpb25FcnJvcj59XG4gKiBAZXhhbXBsZVxuICogICB2YXIgdmFsaWRhdGUgPSByZXF1aXJlKCdtYXBib3gtZ2wtc3R5bGUtc3BlYy9saWIvdmFsaWRhdGVfc3R5bGUubWluJyk7XG4gKiAgIHZhciBlcnJvcnMgPSB2YWxpZGF0ZShzdHlsZSk7XG4gKi9cbmZ1bmN0aW9uIHZhbGlkYXRlU3R5bGVNaW4oc3R5bGUsIHN0eWxlU3BlYykge1xuICAgIHN0eWxlU3BlYyA9IHN0eWxlU3BlYyB8fCBsYXRlc3RTdHlsZVNwZWM7XG5cbiAgICB2YXIgZXJyb3JzID0gW107XG5cbiAgICBlcnJvcnMgPSBlcnJvcnMuY29uY2F0KHZhbGlkYXRlKHtcbiAgICAgICAga2V5OiAnJyxcbiAgICAgICAgdmFsdWU6IHN0eWxlLFxuICAgICAgICB2YWx1ZVNwZWM6IHN0eWxlU3BlYy4kcm9vdCxcbiAgICAgICAgc3R5bGVTcGVjOiBzdHlsZVNwZWMsXG4gICAgICAgIHN0eWxlOiBzdHlsZVxuICAgIH0pKTtcblxuICAgIGlmIChzdHlsZVNwZWMuJHZlcnNpb24gPiA3ICYmIHN0eWxlLmNvbnN0YW50cykge1xuICAgICAgICBlcnJvcnMgPSBlcnJvcnMuY29uY2F0KHZhbGlkYXRlQ29uc3RhbnRzKHtcbiAgICAgICAgICAgIGtleTogJ2NvbnN0YW50cycsXG4gICAgICAgICAgICB2YWx1ZTogc3R5bGUuY29uc3RhbnRzLFxuICAgICAgICAgICAgc3R5bGU6IHN0eWxlLFxuICAgICAgICAgICAgc3R5bGVTcGVjOiBzdHlsZVNwZWNcbiAgICAgICAgfSkpO1xuICAgIH1cblxuICAgIHJldHVybiBzb3J0RXJyb3JzKGVycm9ycyk7XG59XG5cbnZhbGlkYXRlU3R5bGVNaW4uc291cmNlID0gd3JhcENsZWFuRXJyb3JzKHJlcXVpcmUoJy4vdmFsaWRhdGUvdmFsaWRhdGVfc291cmNlJykpO1xudmFsaWRhdGVTdHlsZU1pbi5sYXllciA9IHdyYXBDbGVhbkVycm9ycyhyZXF1aXJlKCcuL3ZhbGlkYXRlL3ZhbGlkYXRlX2xheWVyJykpO1xudmFsaWRhdGVTdHlsZU1pbi5maWx0ZXIgPSB3cmFwQ2xlYW5FcnJvcnMocmVxdWlyZSgnLi92YWxpZGF0ZS92YWxpZGF0ZV9maWx0ZXInKSk7XG52YWxpZGF0ZVN0eWxlTWluLnBhaW50UHJvcGVydHkgPSB3cmFwQ2xlYW5FcnJvcnMocmVxdWlyZSgnLi92YWxpZGF0ZS92YWxpZGF0ZV9wYWludF9wcm9wZXJ0eScpKTtcbnZhbGlkYXRlU3R5bGVNaW4ubGF5b3V0UHJvcGVydHkgPSB3cmFwQ2xlYW5FcnJvcnMocmVxdWlyZSgnLi92YWxpZGF0ZS92YWxpZGF0ZV9sYXlvdXRfcHJvcGVydHknKSk7XG5cbmZ1bmN0aW9uIHNvcnRFcnJvcnMoZXJyb3JzKSB7XG4gICAgcmV0dXJuIFtdLmNvbmNhdChlcnJvcnMpLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIGEubGluZSAtIGIubGluZTtcbiAgICB9KTtcbn1cblxuZnVuY3Rpb24gd3JhcENsZWFuRXJyb3JzKGlubmVyKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gc29ydEVycm9ycyhpbm5lci5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHZhbGlkYXRlU3R5bGVNaW47XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vdjguanNvbicpO1xuIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL3Y4Lm1pbi5qc29uJyk7XG4iLCJtb2R1bGUuZXhwb3J0cz17XG4gIFwiJHZlcnNpb25cIjogOCxcbiAgXCIkcm9vdFwiOiB7XG4gICAgXCJ2ZXJzaW9uXCI6IHtcbiAgICAgIFwicmVxdWlyZWRcIjogdHJ1ZSxcbiAgICAgIFwidHlwZVwiOiBcImVudW1cIixcbiAgICAgIFwidmFsdWVzXCI6IFs4XSxcbiAgICAgIFwiZG9jXCI6IFwiU3R5bGVzaGVldCB2ZXJzaW9uIG51bWJlci4gTXVzdCBiZSA4LlwiLFxuICAgICAgXCJleGFtcGxlXCI6IDhcbiAgICB9LFxuICAgIFwibmFtZVwiOiB7XG4gICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgIFwiZG9jXCI6IFwiQSBodW1hbi1yZWFkYWJsZSBuYW1lIGZvciB0aGUgc3R5bGUuXCIsXG4gICAgICBcImV4YW1wbGVcIjogXCJCcmlnaHRcIlxuICAgIH0sXG4gICAgXCJtZXRhZGF0YVwiOiB7XG4gICAgICBcInR5cGVcIjogXCIqXCIsXG4gICAgICBcImRvY1wiOiBcIkFyYml0cmFyeSBwcm9wZXJ0aWVzIHVzZWZ1bCB0byB0cmFjayB3aXRoIHRoZSBzdHlsZXNoZWV0LCBidXQgZG8gbm90IGluZmx1ZW5jZSByZW5kZXJpbmcuIFByb3BlcnRpZXMgc2hvdWxkIGJlIHByZWZpeGVkIHRvIGF2b2lkIGNvbGxpc2lvbnMsIGxpa2UgJ21hcGJveDonLlwiXG4gICAgfSxcbiAgICBcImNlbnRlclwiOiB7XG4gICAgICBcInR5cGVcIjogXCJhcnJheVwiLFxuICAgICAgXCJ2YWx1ZVwiOiBcIm51bWJlclwiLFxuICAgICAgXCJkb2NcIjogXCJEZWZhdWx0IG1hcCBjZW50ZXIgaW4gbG9uZ2l0dWRlIGFuZCBsYXRpdHVkZS4gIFRoZSBzdHlsZSBjZW50ZXIgd2lsbCBiZSB1c2VkIG9ubHkgaWYgdGhlIG1hcCBoYXMgbm90IGJlZW4gcG9zaXRpb25lZCBieSBvdGhlciBtZWFucyAoZS5nLiBtYXAgb3B0aW9ucyBvciB1c2VyIGludGVyYWN0aW9uKS5cIixcbiAgICAgIFwiZXhhbXBsZVwiOiBbLTczLjk3NDksIDQwLjc3MzZdXG4gICAgfSxcbiAgICBcInpvb21cIjoge1xuICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgICBcImRvY1wiOiBcIkRlZmF1bHQgem9vbSBsZXZlbC4gIFRoZSBzdHlsZSB6b29tIHdpbGwgYmUgdXNlZCBvbmx5IGlmIHRoZSBtYXAgaGFzIG5vdCBiZWVuIHBvc2l0aW9uZWQgYnkgb3RoZXIgbWVhbnMgKGUuZy4gbWFwIG9wdGlvbnMgb3IgdXNlciBpbnRlcmFjdGlvbikuXCIsXG4gICAgICBcImV4YW1wbGVcIjogMTIuNVxuICAgIH0sXG4gICAgXCJiZWFyaW5nXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgXCJkZWZhdWx0XCI6IDAsXG4gICAgICBcInBlcmlvZFwiOiAzNjAsXG4gICAgICBcInVuaXRzXCI6IFwiZGVncmVlc1wiLFxuICAgICAgXCJkb2NcIjogXCJEZWZhdWx0IGJlYXJpbmcsIGluIGRlZ3JlZXMuICBUaGUgc3R5bGUgYmVhcmluZyB3aWxsIGJlIHVzZWQgb25seSBpZiB0aGUgbWFwIGhhcyBub3QgYmVlbiBwb3NpdGlvbmVkIGJ5IG90aGVyIG1lYW5zIChlLmcuIG1hcCBvcHRpb25zIG9yIHVzZXIgaW50ZXJhY3Rpb24pLlwiLFxuICAgICAgXCJleGFtcGxlXCI6IDI5XG4gICAgfSxcbiAgICBcInBpdGNoXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgXCJkZWZhdWx0XCI6IDAsXG4gICAgICBcInVuaXRzXCI6IFwiZGVncmVlc1wiLFxuICAgICAgXCJkb2NcIjogXCJEZWZhdWx0IHBpdGNoLCBpbiBkZWdyZWVzLiBaZXJvIGlzIHBlcnBlbmRpY3VsYXIgdG8gdGhlIHN1cmZhY2UuICBUaGUgc3R5bGUgcGl0Y2ggd2lsbCBiZSB1c2VkIG9ubHkgaWYgdGhlIG1hcCBoYXMgbm90IGJlZW4gcG9zaXRpb25lZCBieSBvdGhlciBtZWFucyAoZS5nLiBtYXAgb3B0aW9ucyBvciB1c2VyIGludGVyYWN0aW9uKS5cIixcbiAgICAgIFwiZXhhbXBsZVwiOiA1MFxuICAgIH0sXG4gICAgXCJzb3VyY2VzXCI6IHtcbiAgICAgIFwicmVxdWlyZWRcIjogdHJ1ZSxcbiAgICAgIFwidHlwZVwiOiBcInNvdXJjZXNcIixcbiAgICAgIFwiZG9jXCI6IFwiRGF0YSBzb3VyY2Ugc3BlY2lmaWNhdGlvbnMuXCIsXG4gICAgICBcImV4YW1wbGVcIjoge1xuICAgICAgICBcIm1hcGJveC1zdHJlZXRzXCI6IHtcbiAgICAgICAgICBcInR5cGVcIjogXCJ2ZWN0b3JcIixcbiAgICAgICAgICBcInVybFwiOiBcIm1hcGJveDovL21hcGJveC5tYXBib3gtc3RyZWV0cy12NlwiXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIFwic3ByaXRlXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgXCJkb2NcIjogXCJBIGJhc2UgVVJMIGZvciByZXRyaWV2aW5nIHRoZSBzcHJpdGUgaW1hZ2UgYW5kIG1ldGFkYXRhLiBUaGUgZXh0ZW5zaW9ucyBgLnBuZ2AsIGAuanNvbmAgYW5kIHNjYWxlIGZhY3RvciBgQDJ4LnBuZ2Agd2lsbCBiZSBhdXRvbWF0aWNhbGx5IGFwcGVuZGVkLlwiLFxuICAgICAgXCJleGFtcGxlXCI6IFwibWFwYm94Oi8vc3ByaXRlcy9tYXBib3gvYnJpZ2h0LXY4XCJcbiAgICB9LFxuICAgIFwiZ2x5cGhzXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgXCJkb2NcIjogXCJBIFVSTCB0ZW1wbGF0ZSBmb3IgbG9hZGluZyBzaWduZWQtZGlzdGFuY2UtZmllbGQgZ2x5cGggc2V0cyBpbiBQQkYgZm9ybWF0LiBWYWxpZCB0b2tlbnMgYXJlIHtmb250c3RhY2t9IGFuZCB7cmFuZ2V9LlwiLFxuICAgICAgXCJleGFtcGxlXCI6IFwibWFwYm94Oi8vZm9udHMvbWFwYm94L3tmb250c3RhY2t9L3tyYW5nZX0ucGJmXCJcbiAgICB9LFxuICAgIFwidHJhbnNpdGlvblwiOiB7XG4gICAgICBcInR5cGVcIjogXCJ0cmFuc2l0aW9uXCIsXG4gICAgICBcImRvY1wiOiBcIkEgZ2xvYmFsIHRyYW5zaXRpb24gZGVmaW5pdGlvbiB0byB1c2UgYXMgYSBkZWZhdWx0IGFjcm9zcyBwcm9wZXJ0aWVzLlwiLFxuICAgICAgXCJleGFtcGxlXCI6IHtcbiAgICAgICAgXCJkdXJhdGlvblwiOiAzMDAsXG4gICAgICAgIFwiZGVsYXlcIjogMFxuICAgICAgfVxuICAgIH0sXG4gICAgXCJsYXllcnNcIjoge1xuICAgICAgXCJyZXF1aXJlZFwiOiB0cnVlLFxuICAgICAgXCJ0eXBlXCI6IFwiYXJyYXlcIixcbiAgICAgIFwidmFsdWVcIjogXCJsYXllclwiLFxuICAgICAgXCJkb2NcIjogXCJMYXllcnMgd2lsbCBiZSBkcmF3biBpbiB0aGUgb3JkZXIgb2YgdGhpcyBhcnJheS5cIixcbiAgICAgIFwiZXhhbXBsZVwiOiBbXG4gICAgICAgIHtcbiAgICAgICAgICBcImlkXCI6IFwid2F0ZXJcIixcbiAgICAgICAgICBcInNvdXJjZVwiOiBcIm1hcGJveC1zdHJlZXRzXCIsXG4gICAgICAgICAgXCJzb3VyY2UtbGF5ZXJcIjogXCJ3YXRlclwiLFxuICAgICAgICAgIFwidHlwZVwiOiBcImZpbGxcIixcbiAgICAgICAgICBcInBhaW50XCI6IHtcbiAgICAgICAgICAgIFwiZmlsbC1jb2xvclwiOiBcIiMwMGZmZmZcIlxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgXVxuICAgIH1cbiAgfSxcbiAgXCJzb3VyY2VzXCI6IHtcbiAgICBcIipcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwic291cmNlXCIsXG4gICAgICBcImRvY1wiOiBcIlNwZWNpZmljYXRpb24gb2YgYSBkYXRhIHNvdXJjZS4gRm9yIHZlY3RvciBhbmQgcmFzdGVyIHNvdXJjZXMsIGVpdGhlciBUaWxlSlNPTiBvciBhIFVSTCB0byBhIFRpbGVKU09OIG11c3QgYmUgcHJvdmlkZWQuIEZvciBHZW9KU09OIGFuZCB2aWRlbyBzb3VyY2VzLCBhIFVSTCBtdXN0IGJlIHByb3ZpZGVkLlwiXG4gICAgfVxuICB9LFxuICBcInNvdXJjZVwiOiBbXG4gICAgXCJzb3VyY2VfdGlsZVwiLFxuICAgIFwic291cmNlX2dlb2pzb25cIixcbiAgICBcInNvdXJjZV92aWRlb1wiLFxuICAgIFwic291cmNlX2ltYWdlXCJcbiAgXSxcbiAgXCJzb3VyY2VfdGlsZVwiOiB7XG4gICAgXCJ0eXBlXCI6IHtcbiAgICAgIFwicmVxdWlyZWRcIjogdHJ1ZSxcbiAgICAgIFwidHlwZVwiOiBcImVudW1cIixcbiAgICAgIFwidmFsdWVzXCI6IFtcbiAgICAgICAgXCJ2ZWN0b3JcIixcbiAgICAgICAgXCJyYXN0ZXJcIlxuICAgICAgXSxcbiAgICAgIFwiZG9jXCI6IFwiVGhlIGRhdGEgdHlwZSBvZiB0aGUgdGlsZSBzb3VyY2UuXCJcbiAgICB9LFxuICAgIFwidXJsXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgXCJkb2NcIjogXCJBIFVSTCB0byBhIFRpbGVKU09OIHJlc291cmNlLiBTdXBwb3J0ZWQgcHJvdG9jb2xzIGFyZSBgaHR0cDpgLCBgaHR0cHM6YCwgYW5kIGBtYXBib3g6Ly88bWFwaWQ+YC5cIlxuICAgIH0sXG4gICAgXCJ0aWxlc1wiOiB7XG4gICAgICBcInR5cGVcIjogXCJhcnJheVwiLFxuICAgICAgXCJ2YWx1ZVwiOiBcInN0cmluZ1wiLFxuICAgICAgXCJkb2NcIjogXCJBbiBhcnJheSBvZiBvbmUgb3IgbW9yZSB0aWxlIHNvdXJjZSBVUkxzLCBhcyBpbiB0aGUgVGlsZUpTT04gc3BlYy5cIlxuICAgIH0sXG4gICAgXCJtaW56b29tXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgXCJkZWZhdWx0XCI6IDAsXG4gICAgICBcImRvY1wiOiBcIk1pbmltdW0gem9vbSBsZXZlbCBmb3Igd2hpY2ggdGlsZXMgYXJlIGF2YWlsYWJsZSwgYXMgaW4gdGhlIFRpbGVKU09OIHNwZWMuXCJcbiAgICB9LFxuICAgIFwibWF4em9vbVwiOiB7XG4gICAgICBcInR5cGVcIjogXCJudW1iZXJcIixcbiAgICAgIFwiZGVmYXVsdFwiOiAyMixcbiAgICAgIFwiZG9jXCI6IFwiTWF4aW11bSB6b29tIGxldmVsIGZvciB3aGljaCB0aWxlcyBhcmUgYXZhaWxhYmxlLCBhcyBpbiB0aGUgVGlsZUpTT04gc3BlYy4gRGF0YSBmcm9tIHRpbGVzIGF0IHRoZSBtYXh6b29tIGFyZSB1c2VkIHdoZW4gZGlzcGxheWluZyB0aGUgbWFwIGF0IGhpZ2hlciB6b29tIGxldmVscy5cIlxuICAgIH0sXG4gICAgXCJ0aWxlU2l6ZVwiOiB7XG4gICAgICBcInR5cGVcIjogXCJudW1iZXJcIixcbiAgICAgIFwiZGVmYXVsdFwiOiA1MTIsXG4gICAgICBcInVuaXRzXCI6IFwicGl4ZWxzXCIsXG4gICAgICBcImRvY1wiOiBcIlRoZSBtaW5pbXVtIHZpc3VhbCBzaXplIHRvIGRpc3BsYXkgdGlsZXMgZm9yIHRoaXMgbGF5ZXIuIE9ubHkgY29uZmlndXJhYmxlIGZvciByYXN0ZXIgbGF5ZXJzLlwiXG4gICAgfSxcbiAgICBcIipcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwiKlwiLFxuICAgICAgXCJkb2NcIjogXCJPdGhlciBrZXlzIHRvIGNvbmZpZ3VyZSB0aGUgZGF0YSBzb3VyY2UuXCJcbiAgICB9XG4gIH0sXG4gIFwic291cmNlX2dlb2pzb25cIjoge1xuICAgIFwidHlwZVwiOiB7XG4gICAgICBcInJlcXVpcmVkXCI6IHRydWUsXG4gICAgICBcInR5cGVcIjogXCJlbnVtXCIsXG4gICAgICBcInZhbHVlc1wiOiBbXG4gICAgICAgIFwiZ2VvanNvblwiXG4gICAgICBdLFxuICAgICAgXCJkb2NcIjogXCJUaGUgZGF0YSB0eXBlIG9mIHRoZSBHZW9KU09OIHNvdXJjZS5cIlxuICAgIH0sXG4gICAgXCJkYXRhXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcIipcIixcbiAgICAgIFwiZG9jXCI6IFwiQSBVUkwgdG8gYSBHZW9KU09OIGZpbGUsIG9yIGlubGluZSBHZW9KU09OLlwiXG4gICAgfSxcbiAgICBcIm1heHpvb21cIjoge1xuICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgICBcImRlZmF1bHRcIjogMTQsXG4gICAgICBcImRvY1wiOiBcIk1heGltdW0gem9vbSBsZXZlbCBhdCB3aGljaCB0byBjcmVhdGUgdmVjdG9yIHRpbGVzIChoaWdoZXIgbWVhbnMgZ3JlYXRlciBkZXRhaWwgYXQgaGlnaCB6b29tIGxldmVscykuXCJcbiAgICB9LFxuICAgIFwiYnVmZmVyXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgXCJkZWZhdWx0XCI6IDY0LFxuICAgICAgXCJkb2NcIjogXCJUaWxlIGJ1ZmZlciBzaXplIG9uIGVhY2ggc2lkZSAoaGlnaGVyIG1lYW5zIGZld2VyIHJlbmRlcmluZyBhcnRpZmFjdHMgbmVhciB0aWxlIGVkZ2VzIGJ1dCBzbG93ZXIgcGVyZm9ybWFuY2UpLlwiXG4gICAgfSxcbiAgICBcInRvbGVyYW5jZVwiOiB7XG4gICAgICBcInR5cGVcIjogXCJudW1iZXJcIixcbiAgICAgIFwiZGVmYXVsdFwiOiAzLFxuICAgICAgXCJkb2NcIjogXCJEb3VnbGFzLVBldWNrZXIgc2ltcGxpZmljYXRpb24gdG9sZXJhbmNlIChoaWdoZXIgbWVhbnMgc2ltcGxlciBnZW9tZXRyaWVzIGFuZCBmYXN0ZXIgcGVyZm9ybWFuY2UpLlwiXG4gICAgfSxcbiAgICBcImNsdXN0ZXJcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwiYm9vbGVhblwiLFxuICAgICAgXCJkZWZhdWx0XCI6IGZhbHNlLFxuICAgICAgXCJkb2NcIjogXCJJZiB0aGUgZGF0YSBpcyBhIGNvbGxlY3Rpb24gb2YgcG9pbnQgZmVhdHVyZXMsIHNldHRpbmcgdGhpcyB0byB0cnVlIGNsdXN0ZXJzIHRoZSBwb2ludHMgYnkgcmFkaXVzIGludG8gZ3JvdXBzLlwiXG4gICAgfSxcbiAgICBcImNsdXN0ZXJSYWRpdXNcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgICBcImRlZmF1bHRcIjogNDAwLFxuICAgICAgXCJkb2NcIjogXCJSYWRpdXMgb2YgZWFjaCBjbHVzdGVyIHdoZW4gY2x1c3RlcmluZyBwb2ludHMsIHJlbGF0aXZlIHRvIDQwOTYgdGlsZS5cIlxuICAgIH0sXG4gICAgXCJjbHVzdGVyTWF4Wm9vbVwiOiB7XG4gICAgICBcInR5cGVcIjogXCJudW1iZXJcIixcbiAgICAgIFwiZG9jXCI6IFwiTWF4IHpvb20gdG8gY2x1c3RlciBwb2ludHMgb24uIERlZmF1bHRzIHRvIG9uZSB6b29tIGxlc3MgdGhhbiBtYXh6b29tIChzbyB0aGF0IGxhc3Qgem9vbSBmZWF0dXJlcyBhcmUgbm90IGNsdXN0ZXJlZCkuXCJcbiAgICB9XG4gIH0sXG4gIFwic291cmNlX3ZpZGVvXCI6IHtcbiAgICBcInR5cGVcIjoge1xuICAgICAgXCJyZXF1aXJlZFwiOiB0cnVlLFxuICAgICAgXCJ0eXBlXCI6IFwiZW51bVwiLFxuICAgICAgXCJ2YWx1ZXNcIjogW1xuICAgICAgICBcInZpZGVvXCJcbiAgICAgIF0sXG4gICAgICBcImRvY1wiOiBcIlRoZSBkYXRhIHR5cGUgb2YgdGhlIHZpZGVvIHNvdXJjZS5cIlxuICAgIH0sXG4gICAgXCJ1cmxzXCI6IHtcbiAgICAgIFwicmVxdWlyZWRcIjogdHJ1ZSxcbiAgICAgIFwidHlwZVwiOiBcImFycmF5XCIsXG4gICAgICBcInZhbHVlXCI6IFwic3RyaW5nXCIsXG4gICAgICBcImRvY1wiOiBcIlVSTHMgdG8gdmlkZW8gY29udGVudCBpbiBvcmRlciBvZiBwcmVmZXJyZWQgZm9ybWF0LlwiXG4gICAgfSxcbiAgICBcImNvb3JkaW5hdGVzXCI6IHtcbiAgICAgIFwicmVxdWlyZWRcIjogdHJ1ZSxcbiAgICAgIFwiZG9jXCI6IFwiQ29ybmVycyBvZiB2aWRlbyBzcGVjaWZpZWQgaW4gbG9uZ2l0dWRlLCBsYXRpdHVkZSBwYWlycy5cIixcbiAgICAgIFwidHlwZVwiOiBcImFycmF5XCIsXG4gICAgICBcImxlbmd0aFwiOiA0LFxuICAgICAgXCJ2YWx1ZVwiOiB7XG4gICAgICAgIFwidHlwZVwiOiBcImFycmF5XCIsXG4gICAgICAgIFwibGVuZ3RoXCI6IDIsXG4gICAgICAgIFwidmFsdWVcIjogXCJudW1iZXJcIixcbiAgICAgICAgXCJkb2NcIjogXCJBIHNpbmdsZSBsb25naXR1ZGUsIGxhdGl0dWRlIHBhaXIuXCJcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIFwic291cmNlX2ltYWdlXCI6IHtcbiAgICBcInR5cGVcIjoge1xuICAgICAgXCJyZXF1aXJlZFwiOiB0cnVlLFxuICAgICAgXCJ0eXBlXCI6IFwiZW51bVwiLFxuICAgICAgXCJ2YWx1ZXNcIjogW1xuICAgICAgICBcImltYWdlXCJcbiAgICAgIF0sXG4gICAgICBcImRvY1wiOiBcIlRoZSBkYXRhIHR5cGUgb2YgdGhlIGltYWdlIHNvdXJjZS5cIlxuICAgIH0sXG4gICAgXCJ1cmxcIjoge1xuICAgICAgXCJyZXF1aXJlZFwiOiB0cnVlLFxuICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICBcImRvY1wiOiBcIlVSTCB0aGF0IHBvaW50cyB0byBhbiBpbWFnZVwiXG4gICAgfSxcbiAgICBcImNvb3JkaW5hdGVzXCI6IHtcbiAgICAgIFwicmVxdWlyZWRcIjogdHJ1ZSxcbiAgICAgIFwiZG9jXCI6IFwiQ29ybmVycyBvZiBpbWFnZSBzcGVjaWZpZWQgaW4gbG9uZ2l0dWRlLCBsYXRpdHVkZSBwYWlycy5cIixcbiAgICAgIFwidHlwZVwiOiBcImFycmF5XCIsXG4gICAgICBcImxlbmd0aFwiOiA0LFxuICAgICAgXCJ2YWx1ZVwiOiB7XG4gICAgICAgIFwidHlwZVwiOiBcImFycmF5XCIsXG4gICAgICAgIFwibGVuZ3RoXCI6IDIsXG4gICAgICAgIFwidmFsdWVcIjogXCJudW1iZXJcIixcbiAgICAgICAgXCJkb2NcIjogXCJBIHNpbmdsZSBsb25naXR1ZGUsIGxhdGl0dWRlIHBhaXIuXCJcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIFwibGF5ZXJcIjoge1xuICAgIFwiaWRcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICBcImRvY1wiOiBcIlVuaXF1ZSBsYXllciBuYW1lLlwiLFxuICAgICAgXCJyZXF1aXJlZFwiOiB0cnVlXG4gICAgfSxcbiAgICBcInR5cGVcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwiZW51bVwiLFxuICAgICAgXCJ2YWx1ZXNcIjogW1xuICAgICAgICBcImZpbGxcIixcbiAgICAgICAgXCJsaW5lXCIsXG4gICAgICAgIFwic3ltYm9sXCIsXG4gICAgICAgIFwiY2lyY2xlXCIsXG4gICAgICAgIFwicmFzdGVyXCIsXG4gICAgICAgIFwiYmFja2dyb3VuZFwiXG4gICAgICBdLFxuICAgICAgXCJkb2NcIjogXCJSZW5kZXJpbmcgdHlwZSBvZiB0aGlzIGxheWVyLlwiXG4gICAgfSxcbiAgICBcIm1ldGFkYXRhXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcIipcIixcbiAgICAgIFwiZG9jXCI6IFwiQXJiaXRyYXJ5IHByb3BlcnRpZXMgdXNlZnVsIHRvIHRyYWNrIHdpdGggdGhlIGxheWVyLCBidXQgZG8gbm90IGluZmx1ZW5jZSByZW5kZXJpbmcuIFByb3BlcnRpZXMgc2hvdWxkIGJlIHByZWZpeGVkIHRvIGF2b2lkIGNvbGxpc2lvbnMsIGxpa2UgJ21hcGJveDonLlwiXG4gICAgfSxcbiAgICBcInJlZlwiOiB7XG4gICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgIFwiZG9jXCI6IFwiUmVmZXJlbmNlcyBhbm90aGVyIGxheWVyIHRvIGNvcHkgYHR5cGVgLCBgc291cmNlYCwgYHNvdXJjZS1sYXllcmAsIGBtaW56b29tYCwgYG1heHpvb21gLCBgZmlsdGVyYCwgYW5kIGBsYXlvdXRgIHByb3BlcnRpZXMgZnJvbS4gVGhpcyBhbGxvd3MgdGhlIGxheWVycyB0byBzaGFyZSBwcm9jZXNzaW5nIGFuZCBiZSBtb3JlIGVmZmljaWVudC5cIlxuICAgIH0sXG4gICAgXCJzb3VyY2VcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICBcImRvY1wiOiBcIk5hbWUgb2YgYSBzb3VyY2UgZGVzY3JpcHRpb24gdG8gYmUgdXNlZCBmb3IgdGhpcyBsYXllci5cIlxuICAgIH0sXG4gICAgXCJzb3VyY2UtbGF5ZXJcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICBcImRvY1wiOiBcIkxheWVyIHRvIHVzZSBmcm9tIGEgdmVjdG9yIHRpbGUgc291cmNlLiBSZXF1aXJlZCBpZiB0aGUgc291cmNlIHN1cHBvcnRzIG11bHRpcGxlIGxheWVycy5cIlxuICAgIH0sXG4gICAgXCJtaW56b29tXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgXCJtaW5pbXVtXCI6IDAsXG4gICAgICBcIm1heGltdW1cIjogMjIsXG4gICAgICBcImRvY1wiOiBcIlRoZSBtaW5pbXVtIHpvb20gbGV2ZWwgb24gd2hpY2ggdGhlIGxheWVyIGdldHMgcGFyc2VkIGFuZCBhcHBlYXJzIG9uLlwiXG4gICAgfSxcbiAgICBcIm1heHpvb21cIjoge1xuICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgICBcIm1pbmltdW1cIjogMCxcbiAgICAgIFwibWF4aW11bVwiOiAyMixcbiAgICAgIFwiZG9jXCI6IFwiVGhlIG1heGltdW0gem9vbSBsZXZlbCBvbiB3aGljaCB0aGUgbGF5ZXIgZ2V0cyBwYXJzZWQgYW5kIGFwcGVhcnMgb24uXCJcbiAgICB9LFxuICAgIFwiaW50ZXJhY3RpdmVcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwiYm9vbGVhblwiLFxuICAgICAgXCJkb2NcIjogXCJFbmFibGUgcXVlcnlpbmcgb2YgZmVhdHVyZSBkYXRhIGZyb20gdGhpcyBsYXllciBmb3IgaW50ZXJhY3Rpdml0eS5cIixcbiAgICAgIFwiZGVmYXVsdFwiOiBmYWxzZVxuICAgIH0sXG4gICAgXCJmaWx0ZXJcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwiZmlsdGVyXCIsXG4gICAgICBcImRvY1wiOiBcIkEgZXhwcmVzc2lvbiBzcGVjaWZ5aW5nIGNvbmRpdGlvbnMgb24gc291cmNlIGZlYXR1cmVzLiBPbmx5IGZlYXR1cmVzIHRoYXQgbWF0Y2ggdGhlIGZpbHRlciBhcmUgZGlzcGxheWVkLlwiXG4gICAgfSxcbiAgICBcImxheW91dFwiOiB7XG4gICAgICBcInR5cGVcIjogXCJsYXlvdXRcIixcbiAgICAgIFwiZG9jXCI6IFwiTGF5b3V0IHByb3BlcnRpZXMgZm9yIHRoZSBsYXllci5cIlxuICAgIH0sXG4gICAgXCJwYWludFwiOiB7XG4gICAgICBcInR5cGVcIjogXCJwYWludFwiLFxuICAgICAgXCJkb2NcIjogXCJEZWZhdWx0IHBhaW50IHByb3BlcnRpZXMgZm9yIHRoaXMgbGF5ZXIuXCJcbiAgICB9LFxuICAgIFwicGFpbnQuKlwiOiB7XG4gICAgICBcInR5cGVcIjogXCJwYWludFwiLFxuICAgICAgXCJkb2NcIjogXCJDbGFzcy1zcGVjaWZpYyBwYWludCBwcm9wZXJ0aWVzIGZvciB0aGlzIGxheWVyLiBUaGUgY2xhc3MgbmFtZSBpcyB0aGUgcGFydCBhZnRlciB0aGUgZmlyc3QgZG90LlwiXG4gICAgfVxuICB9LFxuICBcImxheW91dFwiOiBbXG4gICAgXCJsYXlvdXRfZmlsbFwiLFxuICAgIFwibGF5b3V0X2xpbmVcIixcbiAgICBcImxheW91dF9jaXJjbGVcIixcbiAgICBcImxheW91dF9zeW1ib2xcIixcbiAgICBcImxheW91dF9yYXN0ZXJcIixcbiAgICBcImxheW91dF9iYWNrZ3JvdW5kXCJcbiAgXSxcbiAgXCJsYXlvdXRfYmFja2dyb3VuZFwiOiB7XG4gICAgXCJ2aXNpYmlsaXR5XCI6IHtcbiAgICAgIFwidHlwZVwiOiBcImVudW1cIixcbiAgICAgIFwiZnVuY3Rpb25cIjogXCJwaWVjZXdpc2UtY29uc3RhbnRcIixcbiAgICAgIFwidmFsdWVzXCI6IFtcbiAgICAgICAgXCJ2aXNpYmxlXCIsXG4gICAgICAgIFwibm9uZVwiXG4gICAgICBdLFxuICAgICAgXCJkZWZhdWx0XCI6IFwidmlzaWJsZVwiLFxuICAgICAgXCJkb2NcIjogXCJUaGUgZGlzcGxheSBvZiB0aGlzIGxheWVyLiBgbm9uZWAgaGlkZXMgdGhpcyBsYXllci5cIlxuICAgIH1cbiAgfSxcbiAgXCJsYXlvdXRfZmlsbFwiOiB7XG4gICAgXCJ2aXNpYmlsaXR5XCI6IHtcbiAgICAgIFwidHlwZVwiOiBcImVudW1cIixcbiAgICAgIFwiZnVuY3Rpb25cIjogXCJwaWVjZXdpc2UtY29uc3RhbnRcIixcbiAgICAgIFwidmFsdWVzXCI6IFtcbiAgICAgICAgXCJ2aXNpYmxlXCIsXG4gICAgICAgIFwibm9uZVwiXG4gICAgICBdLFxuICAgICAgXCJkZWZhdWx0XCI6IFwidmlzaWJsZVwiLFxuICAgICAgXCJkb2NcIjogXCJUaGUgZGlzcGxheSBvZiB0aGlzIGxheWVyLiBgbm9uZWAgaGlkZXMgdGhpcyBsYXllci5cIlxuICAgIH1cbiAgfSxcbiAgXCJsYXlvdXRfY2lyY2xlXCI6IHtcbiAgICBcInZpc2liaWxpdHlcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwiZW51bVwiLFxuICAgICAgXCJmdW5jdGlvblwiOiBcInBpZWNld2lzZS1jb25zdGFudFwiLFxuICAgICAgXCJ2YWx1ZXNcIjogW1xuICAgICAgICBcInZpc2libGVcIixcbiAgICAgICAgXCJub25lXCJcbiAgICAgIF0sXG4gICAgICBcImRlZmF1bHRcIjogXCJ2aXNpYmxlXCIsXG4gICAgICBcImRvY1wiOiBcIlRoZSBkaXNwbGF5IG9mIHRoaXMgbGF5ZXIuIGBub25lYCBoaWRlcyB0aGlzIGxheWVyLlwiXG4gICAgfVxuICB9LFxuICBcImxheW91dF9saW5lXCI6IHtcbiAgICBcImxpbmUtY2FwXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcImVudW1cIixcbiAgICAgIFwiZnVuY3Rpb25cIjogXCJwaWVjZXdpc2UtY29uc3RhbnRcIixcbiAgICAgIFwidmFsdWVzXCI6IFtcbiAgICAgICAgXCJidXR0XCIsXG4gICAgICAgIFwicm91bmRcIixcbiAgICAgICAgXCJzcXVhcmVcIlxuICAgICAgXSxcbiAgICAgIFwiZGVmYXVsdFwiOiBcImJ1dHRcIixcbiAgICAgIFwiZG9jXCI6IFwiVGhlIGRpc3BsYXkgb2YgbGluZSBlbmRpbmdzLlwiXG4gICAgfSxcbiAgICBcImxpbmUtam9pblwiOiB7XG4gICAgICBcInR5cGVcIjogXCJlbnVtXCIsXG4gICAgICBcImZ1bmN0aW9uXCI6IFwicGllY2V3aXNlLWNvbnN0YW50XCIsXG4gICAgICBcInZhbHVlc1wiOiBbXG4gICAgICAgIFwiYmV2ZWxcIixcbiAgICAgICAgXCJyb3VuZFwiLFxuICAgICAgICBcIm1pdGVyXCJcbiAgICAgIF0sXG4gICAgICBcImRlZmF1bHRcIjogXCJtaXRlclwiLFxuICAgICAgXCJkb2NcIjogXCJUaGUgZGlzcGxheSBvZiBsaW5lcyB3aGVuIGpvaW5pbmcuXCJcbiAgICB9LFxuICAgIFwibGluZS1taXRlci1saW1pdFwiOiB7XG4gICAgICBcInR5cGVcIjogXCJudW1iZXJcIixcbiAgICAgIFwiZGVmYXVsdFwiOiAyLFxuICAgICAgXCJmdW5jdGlvblwiOiBcImludGVycG9sYXRlZFwiLFxuICAgICAgXCJkb2NcIjogXCJVc2VkIHRvIGF1dG9tYXRpY2FsbHkgY29udmVydCBtaXRlciBqb2lucyB0byBiZXZlbCBqb2lucyBmb3Igc2hhcnAgYW5nbGVzLlwiLFxuICAgICAgXCJyZXF1aXJlc1wiOiBbXG4gICAgICAgIHtcbiAgICAgICAgICBcImxpbmUtam9pblwiOiBcIm1pdGVyXCJcbiAgICAgICAgfVxuICAgICAgXVxuICAgIH0sXG4gICAgXCJsaW5lLXJvdW5kLWxpbWl0XCI6IHtcbiAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgXCJkZWZhdWx0XCI6IDEuMDUsXG4gICAgICBcImZ1bmN0aW9uXCI6IFwiaW50ZXJwb2xhdGVkXCIsXG4gICAgICBcImRvY1wiOiBcIlVzZWQgdG8gYXV0b21hdGljYWxseSBjb252ZXJ0IHJvdW5kIGpvaW5zIHRvIG1pdGVyIGpvaW5zIGZvciBzaGFsbG93IGFuZ2xlcy5cIixcbiAgICAgIFwicmVxdWlyZXNcIjogW1xuICAgICAgICB7XG4gICAgICAgICAgXCJsaW5lLWpvaW5cIjogXCJyb3VuZFwiXG4gICAgICAgIH1cbiAgICAgIF1cbiAgICB9LFxuICAgIFwidmlzaWJpbGl0eVwiOiB7XG4gICAgICBcInR5cGVcIjogXCJlbnVtXCIsXG4gICAgICBcImZ1bmN0aW9uXCI6IFwicGllY2V3aXNlLWNvbnN0YW50XCIsXG4gICAgICBcInZhbHVlc1wiOiBbXG4gICAgICAgIFwidmlzaWJsZVwiLFxuICAgICAgICBcIm5vbmVcIlxuICAgICAgXSxcbiAgICAgIFwiZGVmYXVsdFwiOiBcInZpc2libGVcIixcbiAgICAgIFwiZG9jXCI6IFwiVGhlIGRpc3BsYXkgb2YgdGhpcyBsYXllci4gYG5vbmVgIGhpZGVzIHRoaXMgbGF5ZXIuXCJcbiAgICB9XG4gIH0sXG4gIFwibGF5b3V0X3N5bWJvbFwiOiB7XG4gICAgXCJzeW1ib2wtcGxhY2VtZW50XCI6IHtcbiAgICAgIFwidHlwZVwiOiBcImVudW1cIixcbiAgICAgIFwiZnVuY3Rpb25cIjogXCJwaWVjZXdpc2UtY29uc3RhbnRcIixcbiAgICAgIFwidmFsdWVzXCI6IFtcbiAgICAgICAgICBcInBvaW50XCIsXG4gICAgICAgICAgXCJsaW5lXCJcbiAgICAgIF0sXG4gICAgICBcImRlZmF1bHRcIjogXCJwb2ludFwiLFxuICAgICAgXCJkb2NcIjogXCJMYWJlbCBwbGFjZW1lbnQgcmVsYXRpdmUgdG8gaXRzIGdlb21ldHJ5LiBgbGluZWAgY2FuIG9ubHkgYmUgdXNlZCBvbiBMaW5lU3RyaW5ncyBhbmQgUG9seWdvbnMuXCJcbiAgICB9LFxuICAgIFwic3ltYm9sLXNwYWNpbmdcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgICBcImRlZmF1bHRcIjogMjUwLFxuICAgICAgXCJtaW5pbXVtXCI6IDEsXG4gICAgICBcImZ1bmN0aW9uXCI6IFwiaW50ZXJwb2xhdGVkXCIsXG4gICAgICBcInVuaXRzXCI6IFwicGl4ZWxzXCIsXG4gICAgICBcImRvY1wiOiBcIkRpc3RhbmNlIGJldHdlZW4gdHdvIHN5bWJvbCBhbmNob3JzLlwiLFxuICAgICAgXCJyZXF1aXJlc1wiOiBbXG4gICAgICAgIHtcbiAgICAgICAgICBcInN5bWJvbC1wbGFjZW1lbnRcIjogXCJsaW5lXCJcbiAgICAgICAgfVxuICAgICAgXVxuICAgIH0sXG4gICAgXCJzeW1ib2wtYXZvaWQtZWRnZXNcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwiYm9vbGVhblwiLFxuICAgICAgXCJmdW5jdGlvblwiOiBcInBpZWNld2lzZS1jb25zdGFudFwiLFxuICAgICAgXCJkZWZhdWx0XCI6IGZhbHNlLFxuICAgICAgXCJkb2NcIjogXCJJZiB0cnVlLCB0aGUgc3ltYm9scyB3aWxsIG5vdCBjcm9zcyB0aWxlIGVkZ2VzIHRvIGF2b2lkIG11dHVhbCBjb2xsaXNpb25zLiBSZWNvbW1lbmRlZCBpbiBsYXllcnMgdGhhdCBkb24ndCBoYXZlIGVub3VnaCBwYWRkaW5nIGluIHRoZSB2ZWN0b3IgdGlsZSB0byBwcmV2ZW50IGNvbGxpc2lvbnMsIG9yIGlmIGl0IGlzIGEgcG9pbnQgc3ltYm9sIGxheWVyIHBsYWNlZCBhZnRlciBhIGxpbmUgc3ltYm9sIGxheWVyLlwiXG4gICAgfSxcbiAgICBcImljb24tYWxsb3ctb3ZlcmxhcFwiOiB7XG4gICAgICBcInR5cGVcIjogXCJib29sZWFuXCIsXG4gICAgICBcImZ1bmN0aW9uXCI6IFwicGllY2V3aXNlLWNvbnN0YW50XCIsXG4gICAgICBcImRlZmF1bHRcIjogZmFsc2UsXG4gICAgICBcImRvY1wiOiBcIklmIHRydWUsIHRoZSBpY29uIHdpbGwgYmUgdmlzaWJsZSBldmVuIGlmIGl0IGNvbGxpZGVzIHdpdGggb3RoZXIgcHJldmlvdXNseSBkcmF3biBzeW1ib2xzLlwiLFxuICAgICAgXCJyZXF1aXJlc1wiOiBbXG4gICAgICAgIFwiaWNvbi1pbWFnZVwiXG4gICAgICBdXG4gICAgfSxcbiAgICBcImljb24taWdub3JlLXBsYWNlbWVudFwiOiB7XG4gICAgICBcInR5cGVcIjogXCJib29sZWFuXCIsXG4gICAgICBcImZ1bmN0aW9uXCI6IFwicGllY2V3aXNlLWNvbnN0YW50XCIsXG4gICAgICBcImRlZmF1bHRcIjogZmFsc2UsXG4gICAgICBcImRvY1wiOiBcIklmIHRydWUsIG90aGVyIHN5bWJvbHMgY2FuIGJlIHZpc2libGUgZXZlbiBpZiB0aGV5IGNvbGxpZGUgd2l0aCB0aGUgaWNvbi5cIixcbiAgICAgIFwicmVxdWlyZXNcIjogW1xuICAgICAgICBcImljb24taW1hZ2VcIlxuICAgICAgXVxuICAgIH0sXG4gICAgXCJpY29uLW9wdGlvbmFsXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcImJvb2xlYW5cIixcbiAgICAgIFwiZnVuY3Rpb25cIjogXCJwaWVjZXdpc2UtY29uc3RhbnRcIixcbiAgICAgIFwiZGVmYXVsdFwiOiBmYWxzZSxcbiAgICAgIFwiZG9jXCI6IFwiSWYgdHJ1ZSwgdGV4dCB3aWxsIGRpc3BsYXkgd2l0aG91dCB0aGVpciBjb3JyZXNwb25kaW5nIGljb25zIHdoZW4gdGhlIGljb24gY29sbGlkZXMgd2l0aCBvdGhlciBzeW1ib2xzIGFuZCB0aGUgdGV4dCBkb2VzIG5vdC5cIixcbiAgICAgIFwicmVxdWlyZXNcIjogW1xuICAgICAgICBcImljb24taW1hZ2VcIixcbiAgICAgICAgXCJ0ZXh0LWZpZWxkXCJcbiAgICAgIF1cbiAgICB9LFxuICAgIFwiaWNvbi1yb3RhdGlvbi1hbGlnbm1lbnRcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwiZW51bVwiLFxuICAgICAgXCJmdW5jdGlvblwiOiBcInBpZWNld2lzZS1jb25zdGFudFwiLFxuICAgICAgXCJ2YWx1ZXNcIjogW1xuICAgICAgICBcIm1hcFwiLFxuICAgICAgICBcInZpZXdwb3J0XCJcbiAgICAgIF0sXG4gICAgICBcImRlZmF1bHRcIjogXCJ2aWV3cG9ydFwiLFxuICAgICAgXCJkb2NcIjogXCJPcmllbnRhdGlvbiBvZiBpY29uIHdoZW4gbWFwIGlzIHJvdGF0ZWQuXCIsXG4gICAgICBcInJlcXVpcmVzXCI6IFtcbiAgICAgICAgXCJpY29uLWltYWdlXCJcbiAgICAgIF1cbiAgICB9LFxuICAgIFwiaWNvbi1zaXplXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgXCJkZWZhdWx0XCI6IDEsXG4gICAgICBcIm1pbmltdW1cIjogMCxcbiAgICAgIFwiZnVuY3Rpb25cIjogXCJpbnRlcnBvbGF0ZWRcIixcbiAgICAgIFwiZG9jXCI6IFwiU2NhbGUgZmFjdG9yIGZvciBpY29uLiAxIGlzIG9yaWdpbmFsIHNpemUsIDMgdHJpcGxlcyB0aGUgc2l6ZS5cIixcbiAgICAgIFwicmVxdWlyZXNcIjogW1xuICAgICAgICBcImljb24taW1hZ2VcIlxuICAgICAgXVxuICAgIH0sXG4gICAgXCJpY29uLWltYWdlXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgXCJmdW5jdGlvblwiOiBcInBpZWNld2lzZS1jb25zdGFudFwiLFxuICAgICAgXCJkb2NcIjogXCJBIHN0cmluZyB3aXRoIHt0b2tlbnN9IHJlcGxhY2VkLCByZWZlcmVuY2luZyB0aGUgZGF0YSBwcm9wZXJ0eSB0byBwdWxsIGZyb20uXCIsXG4gICAgICBcInRva2Vuc1wiOiB0cnVlXG4gICAgfSxcbiAgICBcImljb24tcm90YXRlXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgXCJkZWZhdWx0XCI6IDAsXG4gICAgICBcInBlcmlvZFwiOiAzNjAsXG4gICAgICBcImZ1bmN0aW9uXCI6IFwiaW50ZXJwb2xhdGVkXCIsXG4gICAgICBcInVuaXRzXCI6IFwiZGVncmVlc1wiLFxuICAgICAgXCJkb2NcIjogXCJSb3RhdGVzIHRoZSBpY29uIGNsb2Nrd2lzZS5cIixcbiAgICAgIFwicmVxdWlyZXNcIjogW1xuICAgICAgICBcImljb24taW1hZ2VcIlxuICAgICAgXVxuICAgIH0sXG4gICAgXCJpY29uLXBhZGRpbmdcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgICBcImRlZmF1bHRcIjogMixcbiAgICAgIFwibWluaW11bVwiOiAwLFxuICAgICAgXCJmdW5jdGlvblwiOiBcImludGVycG9sYXRlZFwiLFxuICAgICAgXCJ1bml0c1wiOiBcInBpeGVsc1wiLFxuICAgICAgXCJkb2NcIjogXCJTaXplIG9mIHRoZSBhZGRpdGlvbmFsIGFyZWEgYXJvdW5kIHRoZSBpY29uIGJvdW5kaW5nIGJveCB1c2VkIGZvciBkZXRlY3Rpbmcgc3ltYm9sIGNvbGxpc2lvbnMuXCIsXG4gICAgICBcInJlcXVpcmVzXCI6IFtcbiAgICAgICAgXCJpY29uLWltYWdlXCJcbiAgICAgIF1cbiAgICB9LFxuICAgIFwiaWNvbi1rZWVwLXVwcmlnaHRcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwiYm9vbGVhblwiLFxuICAgICAgXCJmdW5jdGlvblwiOiBcInBpZWNld2lzZS1jb25zdGFudFwiLFxuICAgICAgXCJkZWZhdWx0XCI6IGZhbHNlLFxuICAgICAgXCJkb2NcIjogXCJJZiB0cnVlLCB0aGUgaWNvbiBtYXkgYmUgZmxpcHBlZCB0byBwcmV2ZW50IGl0IGZyb20gYmVpbmcgcmVuZGVyZWQgdXBzaWRlLWRvd24uXCIsXG4gICAgICBcInJlcXVpcmVzXCI6IFtcbiAgICAgICAgXCJpY29uLWltYWdlXCIsXG4gICAgICAgIHtcbiAgICAgICAgICBcImljb24tcm90YXRpb24tYWxpZ25tZW50XCI6IFwibWFwXCJcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIFwic3ltYm9sLXBsYWNlbWVudFwiOiBcImxpbmVcIlxuICAgICAgICB9XG4gICAgICBdXG4gICAgfSxcbiAgICBcImljb24tb2Zmc2V0XCI6IHtcbiAgICAgIFwidHlwZVwiOiBcImFycmF5XCIsXG4gICAgICBcInZhbHVlXCI6IFwibnVtYmVyXCIsXG4gICAgICBcImxlbmd0aFwiOiAyLFxuICAgICAgXCJkZWZhdWx0XCI6IFtcbiAgICAgICAgMCxcbiAgICAgICAgMFxuICAgICAgXSxcbiAgICAgIFwiZnVuY3Rpb25cIjogXCJpbnRlcnBvbGF0ZWRcIixcbiAgICAgIFwiZG9jXCI6IFwiT2Zmc2V0IGRpc3RhbmNlIG9mIGljb24gZnJvbSBpdHMgYW5jaG9yLiBQb3NpdGl2ZSB2YWx1ZXMgaW5kaWNhdGUgcmlnaHQgYW5kIGRvd24sIHdoaWxlIG5lZ2F0aXZlIHZhbHVlcyBpbmRpY2F0ZSBsZWZ0IGFuZCB1cC5cIixcbiAgICAgIFwicmVxdWlyZXNcIjogW1xuICAgICAgICBcImljb24taW1hZ2VcIlxuICAgICAgXVxuICAgIH0sXG4gICAgXCJ0ZXh0LXJvdGF0aW9uLWFsaWdubWVudFwiOiB7XG4gICAgICBcInR5cGVcIjogXCJlbnVtXCIsXG4gICAgICBcImZ1bmN0aW9uXCI6IFwicGllY2V3aXNlLWNvbnN0YW50XCIsXG4gICAgICBcInZhbHVlc1wiOiBbXG4gICAgICAgIFwibWFwXCIsXG4gICAgICAgIFwidmlld3BvcnRcIlxuICAgICAgXSxcbiAgICAgIFwiZGVmYXVsdFwiOiBcInZpZXdwb3J0XCIsXG4gICAgICBcImRvY1wiOiBcIk9yaWVudGF0aW9uIG9mIHRleHQgd2hlbiBtYXAgaXMgcm90YXRlZC5cIixcbiAgICAgIFwicmVxdWlyZXNcIjogW1xuICAgICAgICBcInRleHQtZmllbGRcIlxuICAgICAgXVxuICAgIH0sXG4gICAgXCJ0ZXh0LWZpZWxkXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgXCJmdW5jdGlvblwiOiBcInBpZWNld2lzZS1jb25zdGFudFwiLFxuICAgICAgXCJkZWZhdWx0XCI6IFwiXCIsXG4gICAgICBcInRva2Vuc1wiOiB0cnVlLFxuICAgICAgXCJkb2NcIjogXCJWYWx1ZSB0byB1c2UgZm9yIGEgdGV4dCBsYWJlbC4gRmVhdHVyZSBwcm9wZXJ0aWVzIGFyZSBzcGVjaWZpZWQgdXNpbmcgdG9rZW5zIGxpa2Uge2ZpZWxkX25hbWV9LlwiXG4gICAgfSxcbiAgICBcInRleHQtZm9udFwiOiB7XG4gICAgICBcInR5cGVcIjogXCJhcnJheVwiLFxuICAgICAgXCJ2YWx1ZVwiOiBcInN0cmluZ1wiLFxuICAgICAgXCJmdW5jdGlvblwiOiBcInBpZWNld2lzZS1jb25zdGFudFwiLFxuICAgICAgXCJkZWZhdWx0XCI6IFtcIk9wZW4gU2FucyBSZWd1bGFyXCIsIFwiQXJpYWwgVW5pY29kZSBNUyBSZWd1bGFyXCJdLFxuICAgICAgXCJkb2NcIjogXCJGb250IHN0YWNrIHRvIHVzZSBmb3IgZGlzcGxheWluZyB0ZXh0LlwiLFxuICAgICAgXCJyZXF1aXJlc1wiOiBbXG4gICAgICAgIFwidGV4dC1maWVsZFwiXG4gICAgICBdXG4gICAgfSxcbiAgICBcInRleHQtc2l6ZVwiOiB7XG4gICAgICBcInR5cGVcIjogXCJudW1iZXJcIixcbiAgICAgIFwiZGVmYXVsdFwiOiAxNixcbiAgICAgIFwibWluaW11bVwiOiAwLFxuICAgICAgXCJ1bml0c1wiOiBcInBpeGVsc1wiLFxuICAgICAgXCJmdW5jdGlvblwiOiBcImludGVycG9sYXRlZFwiLFxuICAgICAgXCJkb2NcIjogXCJGb250IHNpemUuXCIsXG4gICAgICBcInJlcXVpcmVzXCI6IFtcbiAgICAgICAgXCJ0ZXh0LWZpZWxkXCJcbiAgICAgIF1cbiAgICB9LFxuICAgIFwidGV4dC1tYXgtd2lkdGhcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgICBcImRlZmF1bHRcIjogMTAsXG4gICAgICBcIm1pbmltdW1cIjogMCxcbiAgICAgIFwidW5pdHNcIjogXCJlbVwiLFxuICAgICAgXCJmdW5jdGlvblwiOiBcImludGVycG9sYXRlZFwiLFxuICAgICAgXCJkb2NcIjogXCJUaGUgbWF4aW11bSBsaW5lIHdpZHRoIGZvciB0ZXh0IHdyYXBwaW5nLlwiLFxuICAgICAgXCJyZXF1aXJlc1wiOiBbXG4gICAgICAgIFwidGV4dC1maWVsZFwiXG4gICAgICBdXG4gICAgfSxcbiAgICBcInRleHQtbGluZS1oZWlnaHRcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgICBcImRlZmF1bHRcIjogMS4yLFxuICAgICAgXCJ1bml0c1wiOiBcImVtXCIsXG4gICAgICBcImZ1bmN0aW9uXCI6IFwiaW50ZXJwb2xhdGVkXCIsXG4gICAgICBcImRvY1wiOiBcIlRleHQgbGVhZGluZyB2YWx1ZSBmb3IgbXVsdGktbGluZSB0ZXh0LlwiLFxuICAgICAgXCJyZXF1aXJlc1wiOiBbXG4gICAgICAgIFwidGV4dC1maWVsZFwiXG4gICAgICBdXG4gICAgfSxcbiAgICBcInRleHQtbGV0dGVyLXNwYWNpbmdcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgICBcImRlZmF1bHRcIjogMCxcbiAgICAgIFwidW5pdHNcIjogXCJlbVwiLFxuICAgICAgXCJmdW5jdGlvblwiOiBcImludGVycG9sYXRlZFwiLFxuICAgICAgXCJkb2NcIjogXCJUZXh0IHRyYWNraW5nIGFtb3VudC5cIixcbiAgICAgIFwicmVxdWlyZXNcIjogW1xuICAgICAgICBcInRleHQtZmllbGRcIlxuICAgICAgXVxuICAgIH0sXG4gICAgXCJ0ZXh0LWp1c3RpZnlcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwiZW51bVwiLFxuICAgICAgXCJmdW5jdGlvblwiOiBcInBpZWNld2lzZS1jb25zdGFudFwiLFxuICAgICAgXCJ2YWx1ZXNcIjogW1xuICAgICAgICBcImxlZnRcIixcbiAgICAgICAgXCJjZW50ZXJcIixcbiAgICAgICAgXCJyaWdodFwiXG4gICAgICBdLFxuICAgICAgXCJkZWZhdWx0XCI6IFwiY2VudGVyXCIsXG4gICAgICBcImRvY1wiOiBcIlRleHQganVzdGlmaWNhdGlvbiBvcHRpb25zLlwiLFxuICAgICAgXCJyZXF1aXJlc1wiOiBbXG4gICAgICAgIFwidGV4dC1maWVsZFwiXG4gICAgICBdXG4gICAgfSxcbiAgICBcInRleHQtYW5jaG9yXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcImVudW1cIixcbiAgICAgIFwiZnVuY3Rpb25cIjogXCJwaWVjZXdpc2UtY29uc3RhbnRcIixcbiAgICAgIFwidmFsdWVzXCI6IFtcbiAgICAgICAgXCJjZW50ZXJcIixcbiAgICAgICAgXCJsZWZ0XCIsXG4gICAgICAgIFwicmlnaHRcIixcbiAgICAgICAgXCJ0b3BcIixcbiAgICAgICAgXCJib3R0b21cIixcbiAgICAgICAgXCJ0b3AtbGVmdFwiLFxuICAgICAgICBcInRvcC1yaWdodFwiLFxuICAgICAgICBcImJvdHRvbS1sZWZ0XCIsXG4gICAgICAgIFwiYm90dG9tLXJpZ2h0XCJcbiAgICAgIF0sXG4gICAgICBcImRlZmF1bHRcIjogXCJjZW50ZXJcIixcbiAgICAgIFwiZG9jXCI6IFwiUGFydCBvZiB0aGUgdGV4dCBwbGFjZWQgY2xvc2VzdCB0byB0aGUgYW5jaG9yLlwiLFxuICAgICAgXCJyZXF1aXJlc1wiOiBbXG4gICAgICAgIFwidGV4dC1maWVsZFwiXG4gICAgICBdXG4gICAgfSxcbiAgICBcInRleHQtbWF4LWFuZ2xlXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgXCJkZWZhdWx0XCI6IDQ1LFxuICAgICAgXCJ1bml0c1wiOiBcImRlZ3JlZXNcIixcbiAgICAgIFwiZnVuY3Rpb25cIjogXCJpbnRlcnBvbGF0ZWRcIixcbiAgICAgIFwiZG9jXCI6IFwiTWF4aW11bSBhbmdsZSBjaGFuZ2UgYmV0d2VlbiBhZGphY2VudCBjaGFyYWN0ZXJzLlwiLFxuICAgICAgXCJyZXF1aXJlc1wiOiBbXG4gICAgICAgIFwidGV4dC1maWVsZFwiLFxuICAgICAgICB7XG4gICAgICAgICAgXCJzeW1ib2wtcGxhY2VtZW50XCI6IFwibGluZVwiXG4gICAgICAgIH1cbiAgICAgIF1cbiAgICB9LFxuICAgIFwidGV4dC1yb3RhdGVcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgICBcImRlZmF1bHRcIjogMCxcbiAgICAgIFwicGVyaW9kXCI6IDM2MCxcbiAgICAgIFwidW5pdHNcIjogXCJkZWdyZWVzXCIsXG4gICAgICBcImZ1bmN0aW9uXCI6IFwiaW50ZXJwb2xhdGVkXCIsXG4gICAgICBcImRvY1wiOiBcIlJvdGF0ZXMgdGhlIHRleHQgY2xvY2t3aXNlLlwiLFxuICAgICAgXCJyZXF1aXJlc1wiOiBbXG4gICAgICAgIFwidGV4dC1maWVsZFwiXG4gICAgICBdXG4gICAgfSxcbiAgICBcInRleHQtcGFkZGluZ1wiOiB7XG4gICAgICBcInR5cGVcIjogXCJudW1iZXJcIixcbiAgICAgIFwiZGVmYXVsdFwiOiAyLFxuICAgICAgXCJtaW5pbXVtXCI6IDAsXG4gICAgICBcInVuaXRzXCI6IFwicGl4ZWxzXCIsXG4gICAgICBcImZ1bmN0aW9uXCI6IFwiaW50ZXJwb2xhdGVkXCIsXG4gICAgICBcImRvY1wiOiBcIlNpemUgb2YgdGhlIGFkZGl0aW9uYWwgYXJlYSBhcm91bmQgdGhlIHRleHQgYm91bmRpbmcgYm94IHVzZWQgZm9yIGRldGVjdGluZyBzeW1ib2wgY29sbGlzaW9ucy5cIixcbiAgICAgIFwicmVxdWlyZXNcIjogW1xuICAgICAgICBcInRleHQtZmllbGRcIlxuICAgICAgXVxuICAgIH0sXG4gICAgXCJ0ZXh0LWtlZXAtdXByaWdodFwiOiB7XG4gICAgICBcInR5cGVcIjogXCJib29sZWFuXCIsXG4gICAgICBcImZ1bmN0aW9uXCI6IFwicGllY2V3aXNlLWNvbnN0YW50XCIsXG4gICAgICBcImRlZmF1bHRcIjogdHJ1ZSxcbiAgICAgIFwiZG9jXCI6IFwiSWYgdHJ1ZSwgdGhlIHRleHQgbWF5IGJlIGZsaXBwZWQgdmVydGljYWxseSB0byBwcmV2ZW50IGl0IGZyb20gYmVpbmcgcmVuZGVyZWQgdXBzaWRlLWRvd24uXCIsXG4gICAgICBcInJlcXVpcmVzXCI6IFtcbiAgICAgICAgXCJ0ZXh0LWZpZWxkXCIsXG4gICAgICAgIHtcbiAgICAgICAgICBcInRleHQtcm90YXRpb24tYWxpZ25tZW50XCI6IFwibWFwXCJcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIFwic3ltYm9sLXBsYWNlbWVudFwiOiBcImxpbmVcIlxuICAgICAgICB9XG4gICAgICBdXG4gICAgfSxcbiAgICBcInRleHQtdHJhbnNmb3JtXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcImVudW1cIixcbiAgICAgIFwiZnVuY3Rpb25cIjogXCJwaWVjZXdpc2UtY29uc3RhbnRcIixcbiAgICAgIFwidmFsdWVzXCI6IFtcbiAgICAgICAgXCJub25lXCIsXG4gICAgICAgIFwidXBwZXJjYXNlXCIsXG4gICAgICAgIFwibG93ZXJjYXNlXCJcbiAgICAgIF0sXG4gICAgICBcImRlZmF1bHRcIjogXCJub25lXCIsXG4gICAgICBcImRvY1wiOiBcIlNwZWNpZmllcyBob3cgdG8gY2FwaXRhbGl6ZSB0ZXh0LCBzaW1pbGFyIHRvIHRoZSBDU1MgYHRleHQtdHJhbnNmb3JtYCBwcm9wZXJ0eS5cIixcbiAgICAgIFwicmVxdWlyZXNcIjogW1xuICAgICAgICBcInRleHQtZmllbGRcIlxuICAgICAgXVxuICAgIH0sXG4gICAgXCJ0ZXh0LW9mZnNldFwiOiB7XG4gICAgICBcInR5cGVcIjogXCJhcnJheVwiLFxuICAgICAgXCJkb2NcIjogXCJPZmZzZXQgZGlzdGFuY2Ugb2YgdGV4dCBmcm9tIGl0cyBhbmNob3IuIFBvc2l0aXZlIHZhbHVlcyBpbmRpY2F0ZSByaWdodCBhbmQgZG93biwgd2hpbGUgbmVnYXRpdmUgdmFsdWVzIGluZGljYXRlIGxlZnQgYW5kIHVwLlwiLFxuICAgICAgXCJ2YWx1ZVwiOiBcIm51bWJlclwiLFxuICAgICAgXCJ1bml0c1wiOiBcImVtc1wiLFxuICAgICAgXCJmdW5jdGlvblwiOiBcImludGVycG9sYXRlZFwiLFxuICAgICAgXCJsZW5ndGhcIjogMixcbiAgICAgIFwiZGVmYXVsdFwiOiBbXG4gICAgICAgIDAsXG4gICAgICAgIDBcbiAgICAgIF0sXG4gICAgICBcInJlcXVpcmVzXCI6IFtcbiAgICAgICAgXCJ0ZXh0LWZpZWxkXCJcbiAgICAgIF1cbiAgICB9LFxuICAgIFwidGV4dC1hbGxvdy1vdmVybGFwXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcImJvb2xlYW5cIixcbiAgICAgIFwiZnVuY3Rpb25cIjogXCJwaWVjZXdpc2UtY29uc3RhbnRcIixcbiAgICAgIFwiZGVmYXVsdFwiOiBmYWxzZSxcbiAgICAgIFwiZG9jXCI6IFwiSWYgdHJ1ZSwgdGhlIHRleHQgd2lsbCBiZSB2aXNpYmxlIGV2ZW4gaWYgaXQgY29sbGlkZXMgd2l0aCBvdGhlciBwcmV2aW91c2x5IGRyYXduIHN5bWJvbHMuXCIsXG4gICAgICBcInJlcXVpcmVzXCI6IFtcbiAgICAgICAgXCJ0ZXh0LWZpZWxkXCJcbiAgICAgIF1cbiAgICB9LFxuICAgIFwidGV4dC1pZ25vcmUtcGxhY2VtZW50XCI6IHtcbiAgICAgIFwidHlwZVwiOiBcImJvb2xlYW5cIixcbiAgICAgIFwiZnVuY3Rpb25cIjogXCJwaWVjZXdpc2UtY29uc3RhbnRcIixcbiAgICAgIFwiZGVmYXVsdFwiOiBmYWxzZSxcbiAgICAgIFwiZG9jXCI6IFwiSWYgdHJ1ZSwgb3RoZXIgc3ltYm9scyBjYW4gYmUgdmlzaWJsZSBldmVuIGlmIHRoZXkgY29sbGlkZSB3aXRoIHRoZSB0ZXh0LlwiLFxuICAgICAgXCJyZXF1aXJlc1wiOiBbXG4gICAgICAgIFwidGV4dC1maWVsZFwiXG4gICAgICBdXG4gICAgfSxcbiAgICBcInRleHQtb3B0aW9uYWxcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwiYm9vbGVhblwiLFxuICAgICAgXCJmdW5jdGlvblwiOiBcInBpZWNld2lzZS1jb25zdGFudFwiLFxuICAgICAgXCJkZWZhdWx0XCI6IGZhbHNlLFxuICAgICAgXCJkb2NcIjogXCJJZiB0cnVlLCBpY29ucyB3aWxsIGRpc3BsYXkgd2l0aG91dCB0aGVpciBjb3JyZXNwb25kaW5nIHRleHQgd2hlbiB0aGUgdGV4dCBjb2xsaWRlcyB3aXRoIG90aGVyIHN5bWJvbHMgYW5kIHRoZSBpY29uIGRvZXMgbm90LlwiLFxuICAgICAgXCJyZXF1aXJlc1wiOiBbXG4gICAgICAgIFwidGV4dC1maWVsZFwiLFxuICAgICAgICBcImljb24taW1hZ2VcIlxuICAgICAgXVxuICAgIH0sXG4gICAgXCJ2aXNpYmlsaXR5XCI6IHtcbiAgICAgIFwidHlwZVwiOiBcImVudW1cIixcbiAgICAgIFwiZnVuY3Rpb25cIjogXCJwaWVjZXdpc2UtY29uc3RhbnRcIixcbiAgICAgIFwidmFsdWVzXCI6IFtcbiAgICAgICAgXCJ2aXNpYmxlXCIsXG4gICAgICAgIFwibm9uZVwiXG4gICAgICBdLFxuICAgICAgXCJkZWZhdWx0XCI6IFwidmlzaWJsZVwiLFxuICAgICAgXCJkb2NcIjogXCJUaGUgZGlzcGxheSBvZiB0aGlzIGxheWVyLiBgbm9uZWAgaGlkZXMgdGhpcyBsYXllci5cIlxuICAgIH1cbiAgfSxcbiAgXCJsYXlvdXRfcmFzdGVyXCI6IHtcbiAgICBcInZpc2liaWxpdHlcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwiZW51bVwiLFxuICAgICAgXCJmdW5jdGlvblwiOiBcInBpZWNld2lzZS1jb25zdGFudFwiLFxuICAgICAgXCJ2YWx1ZXNcIjogW1xuICAgICAgICBcInZpc2libGVcIixcbiAgICAgICAgXCJub25lXCJcbiAgICAgIF0sXG4gICAgICBcImRlZmF1bHRcIjogXCJ2aXNpYmxlXCIsXG4gICAgICBcImRvY1wiOiBcIlRoZSBkaXNwbGF5IG9mIHRoaXMgbGF5ZXIuIGBub25lYCBoaWRlcyB0aGlzIGxheWVyLlwiXG4gICAgfVxuICB9LFxuICBcImZpbHRlclwiOiB7XG4gICAgXCJ0eXBlXCI6IFwiYXJyYXlcIixcbiAgICBcInZhbHVlXCI6IFwiKlwiLFxuICAgIFwiZG9jXCI6IFwiQSBmaWx0ZXIgc2VsZWN0cyBzcGVjaWZpYyBmZWF0dXJlcyBmcm9tIGEgbGF5ZXIuXCJcbiAgfSxcbiAgXCJmaWx0ZXJfb3BlcmF0b3JcIjoge1xuICAgIFwidHlwZVwiOiBcImVudW1cIixcbiAgICBcInZhbHVlc1wiOiBbXG4gICAgICBcIj09XCIsXG4gICAgICBcIiE9XCIsXG4gICAgICBcIj5cIixcbiAgICAgIFwiPj1cIixcbiAgICAgIFwiPFwiLFxuICAgICAgXCI8PVwiLFxuICAgICAgXCJpblwiLFxuICAgICAgXCIhaW5cIixcbiAgICAgIFwiYWxsXCIsXG4gICAgICBcImFueVwiLFxuICAgICAgXCJub25lXCJcbiAgICBdLFxuICAgIFwiZG9jXCI6IFwiVGhlIGZpbHRlciBvcGVyYXRvci5cIlxuICB9LFxuICBcImdlb21ldHJ5X3R5cGVcIjoge1xuICAgIFwidHlwZVwiOiBcImVudW1cIixcbiAgICBcInZhbHVlc1wiOiBbXG4gICAgICBcIlBvaW50XCIsXG4gICAgICBcIkxpbmVTdHJpbmdcIixcbiAgICAgIFwiUG9seWdvblwiXG4gICAgXSxcbiAgICBcImRvY1wiOiBcIlRoZSBnZW9tZXRyeSB0eXBlIGZvciB0aGUgZmlsdGVyIHRvIHNlbGVjdC5cIlxuICB9LFxuICBcImNvbG9yX29wZXJhdGlvblwiOiB7XG4gICAgXCJ0eXBlXCI6IFwiZW51bVwiLFxuICAgIFwidmFsdWVzXCI6IFtcbiAgICAgIFwibGlnaHRlblwiLFxuICAgICAgXCJzYXR1cmF0ZVwiLFxuICAgICAgXCJzcGluXCIsXG4gICAgICBcImZhZGVcIixcbiAgICAgIFwibWl4XCJcbiAgICBdLFxuICAgIFwiZG9jXCI6IFwiQSBjb2xvciBvcGVyYXRpb24gdG8gYXBwbHkuXCJcbiAgfSxcbiAgXCJmdW5jdGlvblwiOiB7XG4gICAgXCJzdG9wc1wiOiB7XG4gICAgICBcInR5cGVcIjogXCJhcnJheVwiLFxuICAgICAgXCJyZXF1aXJlZFwiOiB0cnVlLFxuICAgICAgXCJkb2NcIjogXCJBbiBhcnJheSBvZiBzdG9wcy5cIixcbiAgICAgIFwidmFsdWVcIjogXCJmdW5jdGlvbl9zdG9wXCJcbiAgICB9LFxuICAgIFwiYmFzZVwiOiB7XG4gICAgICBcInR5cGVcIjogXCJudW1iZXJcIixcbiAgICAgIFwiZGVmYXVsdFwiOiAxLFxuICAgICAgXCJtaW5pbXVtXCI6IDAsXG4gICAgICBcImRvY1wiOiBcIlRoZSBleHBvbmVudGlhbCBiYXNlIG9mIHRoZSBpbnRlcnBvbGF0aW9uIGN1cnZlLiBJdCBjb250cm9scyB0aGUgcmF0ZSBhdCB3aGljaCB0aGUgcmVzdWx0IGluY3JlYXNlcy4gSGlnaGVyIHZhbHVlcyBtYWtlIHRoZSByZXN1bHQgaW5jcmVhc2UgbW9yZSB0b3dhcmRzIHRoZSBoaWdoIGVuZCBvZiB0aGUgcmFuZ2UuIFdpdGggYDFgIHRoZSBzdG9wcyBhcmUgaW50ZXJwb2xhdGVkIGxpbmVhcmx5LlwiXG4gICAgfVxuICB9LFxuICBcImZ1bmN0aW9uX3N0b3BcIjoge1xuICAgIFwidHlwZVwiOiBcImFycmF5XCIsXG4gICAgXCJtaW5pbXVtXCI6IDAsXG4gICAgXCJtYXhpbXVtXCI6IDIyLFxuICAgIFwidmFsdWVcIjogW1xuICAgICAgXCJudW1iZXJcIixcbiAgICAgIFwiY29sb3JcIlxuICAgIF0sXG4gICAgXCJsZW5ndGhcIjogMixcbiAgICBcImRvY1wiOiBcIlpvb20gbGV2ZWwgYW5kIHZhbHVlIHBhaXIuXCJcbiAgfSxcbiAgXCJwYWludFwiOiBbXG4gICAgXCJwYWludF9maWxsXCIsXG4gICAgXCJwYWludF9saW5lXCIsXG4gICAgXCJwYWludF9jaXJjbGVcIixcbiAgICBcInBhaW50X3N5bWJvbFwiLFxuICAgIFwicGFpbnRfcmFzdGVyXCIsXG4gICAgXCJwYWludF9iYWNrZ3JvdW5kXCJcbiAgXSxcbiAgXCJwYWludF9maWxsXCI6IHtcbiAgICBcImZpbGwtYW50aWFsaWFzXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcImJvb2xlYW5cIixcbiAgICAgIFwiZnVuY3Rpb25cIjogXCJwaWVjZXdpc2UtY29uc3RhbnRcIixcbiAgICAgIFwiZGVmYXVsdFwiOiB0cnVlLFxuICAgICAgXCJkb2NcIjogXCJXaGV0aGVyIG9yIG5vdCB0aGUgZmlsbCBzaG91bGQgYmUgYW50aWFsaWFzZWQuXCJcbiAgICB9LFxuICAgIFwiZmlsbC1vcGFjaXR5XCI6IHtcbiAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgXCJmdW5jdGlvblwiOiBcImludGVycG9sYXRlZFwiLFxuICAgICAgXCJkZWZhdWx0XCI6IDEsXG4gICAgICBcIm1pbmltdW1cIjogMCxcbiAgICAgIFwibWF4aW11bVwiOiAxLFxuICAgICAgXCJkb2NcIjogXCJUaGUgb3BhY2l0eSBnaXZlbiB0byB0aGUgZmlsbCBjb2xvci5cIixcbiAgICAgIFwidHJhbnNpdGlvblwiOiB0cnVlXG4gICAgfSxcbiAgICBcImZpbGwtY29sb3JcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwiY29sb3JcIixcbiAgICAgIFwiZGVmYXVsdFwiOiBcIiMwMDAwMDBcIixcbiAgICAgIFwiZG9jXCI6IFwiVGhlIGNvbG9yIG9mIHRoZSBmaWxsLlwiLFxuICAgICAgXCJmdW5jdGlvblwiOiBcImludGVycG9sYXRlZFwiLFxuICAgICAgXCJ0cmFuc2l0aW9uXCI6IHRydWUsXG4gICAgICBcInJlcXVpcmVzXCI6IFtcbiAgICAgICAge1xuICAgICAgICAgIFwiIVwiOiBcImZpbGwtcGF0dGVyblwiXG4gICAgICAgIH1cbiAgICAgIF1cbiAgICB9LFxuICAgIFwiZmlsbC1vdXRsaW5lLWNvbG9yXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcImNvbG9yXCIsXG4gICAgICBcImRvY1wiOiBcIlRoZSBvdXRsaW5lIGNvbG9yIG9mIHRoZSBmaWxsLiBNYXRjaGVzIHRoZSB2YWx1ZSBvZiBgZmlsbC1jb2xvcmAgaWYgdW5zcGVjaWZpZWQuXCIsXG4gICAgICBcImZ1bmN0aW9uXCI6IFwiaW50ZXJwb2xhdGVkXCIsXG4gICAgICBcInRyYW5zaXRpb25cIjogdHJ1ZSxcbiAgICAgIFwicmVxdWlyZXNcIjogW1xuICAgICAgICB7XG4gICAgICAgICAgXCIhXCI6IFwiZmlsbC1wYXR0ZXJuXCJcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIFwiZmlsbC1hbnRpYWxpYXNcIjogdHJ1ZVxuICAgICAgICB9XG4gICAgICBdXG4gICAgfSxcbiAgICBcImZpbGwtdHJhbnNsYXRlXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcImFycmF5XCIsXG4gICAgICBcInZhbHVlXCI6IFwibnVtYmVyXCIsXG4gICAgICBcImxlbmd0aFwiOiAyLFxuICAgICAgXCJkZWZhdWx0XCI6IFtcbiAgICAgICAgMCxcbiAgICAgICAgMFxuICAgICAgXSxcbiAgICAgIFwiZnVuY3Rpb25cIjogXCJpbnRlcnBvbGF0ZWRcIixcbiAgICAgIFwidHJhbnNpdGlvblwiOiB0cnVlLFxuICAgICAgXCJ1bml0c1wiOiBcInBpeGVsc1wiLFxuICAgICAgXCJkb2NcIjogXCJUaGUgZ2VvbWV0cnkncyBvZmZzZXQuIFZhbHVlcyBhcmUgW3gsIHldIHdoZXJlIG5lZ2F0aXZlcyBpbmRpY2F0ZSBsZWZ0IGFuZCB1cCwgcmVzcGVjdGl2ZWx5LlwiXG4gICAgfSxcbiAgICBcImZpbGwtdHJhbnNsYXRlLWFuY2hvclwiOiB7XG4gICAgICBcInR5cGVcIjogXCJlbnVtXCIsXG4gICAgICBcImZ1bmN0aW9uXCI6IFwicGllY2V3aXNlLWNvbnN0YW50XCIsXG4gICAgICBcInZhbHVlc1wiOiBbXG4gICAgICAgIFwibWFwXCIsXG4gICAgICAgIFwidmlld3BvcnRcIlxuICAgICAgXSxcbiAgICAgIFwiZG9jXCI6IFwiQ29udHJvbCB3aGV0aGVyIHRoZSB0cmFuc2xhdGlvbiBpcyByZWxhdGl2ZSB0byB0aGUgbWFwIChub3J0aCkgb3Igdmlld3BvcnQgKHNjcmVlbilcIixcbiAgICAgIFwiZGVmYXVsdFwiOiBcIm1hcFwiLFxuICAgICAgXCJyZXF1aXJlc1wiOiBbXG4gICAgICAgIFwiZmlsbC10cmFuc2xhdGVcIlxuICAgICAgXVxuICAgIH0sXG4gICAgXCJmaWxsLXBhdHRlcm5cIjoge1xuICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICBcImZ1bmN0aW9uXCI6IFwicGllY2V3aXNlLWNvbnN0YW50XCIsXG4gICAgICBcInRyYW5zaXRpb25cIjogdHJ1ZSxcbiAgICAgIFwiZG9jXCI6IFwiTmFtZSBvZiBpbWFnZSBpbiBzcHJpdGUgdG8gdXNlIGZvciBkcmF3aW5nIGltYWdlIGZpbGxzLiBGb3Igc2VhbWxlc3MgcGF0dGVybnMsIGltYWdlIHdpZHRoIGFuZCBoZWlnaHQgbXVzdCBiZSBhIGZhY3RvciBvZiB0d28gKDIsIDQsIDgsIC4uLiwgNTEyKS5cIlxuICAgIH1cbiAgfSxcbiAgXCJwYWludF9saW5lXCI6IHtcbiAgICBcImxpbmUtb3BhY2l0eVwiOiB7XG4gICAgICBcInR5cGVcIjogXCJudW1iZXJcIixcbiAgICAgIFwiZG9jXCI6IFwiVGhlIG9wYWNpdHkgYXQgd2hpY2ggdGhlIGxpbmUgd2lsbCBiZSBkcmF3bi5cIixcbiAgICAgIFwiZnVuY3Rpb25cIjogXCJpbnRlcnBvbGF0ZWRcIixcbiAgICAgIFwiZGVmYXVsdFwiOiAxLFxuICAgICAgXCJtaW5pbXVtXCI6IDAsXG4gICAgICBcIm1heGltdW1cIjogMSxcbiAgICAgIFwidHJhbnNpdGlvblwiOiB0cnVlXG4gICAgfSxcbiAgICBcImxpbmUtY29sb3JcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwiY29sb3JcIixcbiAgICAgIFwiZG9jXCI6IFwiVGhlIGNvbG9yIHdpdGggd2hpY2ggdGhlIGxpbmUgd2lsbCBiZSBkcmF3bi5cIixcbiAgICAgIFwiZGVmYXVsdFwiOiBcIiMwMDAwMDBcIixcbiAgICAgIFwiZnVuY3Rpb25cIjogXCJpbnRlcnBvbGF0ZWRcIixcbiAgICAgIFwidHJhbnNpdGlvblwiOiB0cnVlLFxuICAgICAgXCJyZXF1aXJlc1wiOiBbXG4gICAgICAgIHtcbiAgICAgICAgICBcIiFcIjogXCJsaW5lLXBhdHRlcm5cIlxuICAgICAgICB9XG4gICAgICBdXG4gICAgfSxcbiAgICBcImxpbmUtdHJhbnNsYXRlXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcImFycmF5XCIsXG4gICAgICBcInZhbHVlXCI6IFwibnVtYmVyXCIsXG4gICAgICBcImxlbmd0aFwiOiAyLFxuICAgICAgXCJkZWZhdWx0XCI6IFtcbiAgICAgICAgMCxcbiAgICAgICAgMFxuICAgICAgXSxcbiAgICAgIFwiZnVuY3Rpb25cIjogXCJpbnRlcnBvbGF0ZWRcIixcbiAgICAgIFwidHJhbnNpdGlvblwiOiB0cnVlLFxuICAgICAgXCJ1bml0c1wiOiBcInBpeGVsc1wiLFxuICAgICAgXCJkb2NcIjogXCJUaGUgZ2VvbWV0cnkncyBvZmZzZXQuIFZhbHVlcyBhcmUgW3gsIHldIHdoZXJlIG5lZ2F0aXZlcyBpbmRpY2F0ZSBsZWZ0IGFuZCB1cCwgcmVzcGVjdGl2ZWx5LlwiXG4gICAgfSxcbiAgICBcImxpbmUtdHJhbnNsYXRlLWFuY2hvclwiOiB7XG4gICAgICBcInR5cGVcIjogXCJlbnVtXCIsXG4gICAgICBcImZ1bmN0aW9uXCI6IFwicGllY2V3aXNlLWNvbnN0YW50XCIsXG4gICAgICBcInZhbHVlc1wiOiBbXG4gICAgICAgIFwibWFwXCIsXG4gICAgICAgIFwidmlld3BvcnRcIlxuICAgICAgXSxcbiAgICAgIFwiZG9jXCI6IFwiQ29udHJvbCB3aGV0aGVyIHRoZSB0cmFuc2xhdGlvbiBpcyByZWxhdGl2ZSB0byB0aGUgbWFwIChub3J0aCkgb3Igdmlld3BvcnQgKHNjcmVlbilcIixcbiAgICAgIFwiZGVmYXVsdFwiOiBcIm1hcFwiLFxuICAgICAgXCJyZXF1aXJlc1wiOiBbXG4gICAgICAgIFwibGluZS10cmFuc2xhdGVcIlxuICAgICAgXVxuICAgIH0sXG4gICAgXCJsaW5lLXdpZHRoXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgXCJkZWZhdWx0XCI6IDEsXG4gICAgICBcIm1pbmltdW1cIjogMCxcbiAgICAgIFwiZnVuY3Rpb25cIjogXCJpbnRlcnBvbGF0ZWRcIixcbiAgICAgIFwidHJhbnNpdGlvblwiOiB0cnVlLFxuICAgICAgXCJ1bml0c1wiOiBcInBpeGVsc1wiLFxuICAgICAgXCJkb2NcIjogXCJTdHJva2UgdGhpY2tuZXNzLlwiXG4gICAgfSxcbiAgICBcImxpbmUtZ2FwLXdpZHRoXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgXCJkZWZhdWx0XCI6IDAsXG4gICAgICBcIm1pbmltdW1cIjogMCxcbiAgICAgIFwiZG9jXCI6IFwiRHJhd3MgYSBsaW5lIGNhc2luZyBvdXRzaWRlIG9mIGEgbGluZSdzIGFjdHVhbCBwYXRoLiBWYWx1ZSBpbmRpY2F0ZXMgdGhlIHdpZHRoIG9mIHRoZSBpbm5lciBnYXAuXCIsXG4gICAgICBcImZ1bmN0aW9uXCI6IFwiaW50ZXJwb2xhdGVkXCIsXG4gICAgICBcInRyYW5zaXRpb25cIjogdHJ1ZSxcbiAgICAgIFwidW5pdHNcIjogXCJwaXhlbHNcIlxuICAgIH0sXG4gICAgXCJsaW5lLW9mZnNldFwiOiB7XG4gICAgICBcInR5cGVcIjogXCJudW1iZXJcIixcbiAgICAgIFwiZGVmYXVsdFwiOiAwLFxuICAgICAgXCJkb2NcIjogXCJUaGUgbGluZSdzIG9mZnNldCBwZXJwZW5kaWN1bGFyIHRvIGl0cyBkaXJlY3Rpb24uIFZhbHVlcyBtYXkgYmUgcG9zaXRpdmUgb3IgbmVnYXRpdmUsIHdoZXJlIHBvc2l0aXZlIGluZGljYXRlcyBcXFwicmlnaHR3YXJkc1xcXCIgKGlmIHlvdSB3ZXJlIG1vdmluZyBpbiB0aGUgZGlyZWN0aW9uIG9mIHRoZSBsaW5lKSBhbmQgbmVnYXRpdmUgaW5kaWNhdGVzIFxcXCJsZWZ0d2FyZHMuXFxcIlwiLFxuICAgICAgXCJmdW5jdGlvblwiOiBcImludGVycG9sYXRlZFwiLFxuICAgICAgXCJ0cmFuc2l0aW9uXCI6IHRydWUsXG4gICAgICBcInVuaXRzXCI6IFwicGl4ZWxzXCJcbiAgICB9LFxuICAgIFwibGluZS1ibHVyXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgXCJkZWZhdWx0XCI6IDAsXG4gICAgICBcIm1pbmltdW1cIjogMCxcbiAgICAgIFwiZnVuY3Rpb25cIjogXCJpbnRlcnBvbGF0ZWRcIixcbiAgICAgIFwidHJhbnNpdGlvblwiOiB0cnVlLFxuICAgICAgXCJ1bml0c1wiOiBcInBpeGVsc1wiLFxuICAgICAgXCJkb2NcIjogXCJCbHVyIGFwcGxpZWQgdG8gdGhlIGxpbmUsIGluIHBpeGVscy5cIlxuICAgIH0sXG4gICAgXCJsaW5lLWRhc2hhcnJheVwiOiB7XG4gICAgICBcInR5cGVcIjogXCJhcnJheVwiLFxuICAgICAgXCJ2YWx1ZVwiOiBcIm51bWJlclwiLFxuICAgICAgXCJmdW5jdGlvblwiOiBcInBpZWNld2lzZS1jb25zdGFudFwiLFxuICAgICAgXCJkb2NcIjogXCJTcGVjaWZpZXMgdGhlIGxlbmd0aHMgb2YgdGhlIGFsdGVybmF0aW5nIGRhc2hlcyBhbmQgZ2FwcyB0aGF0IGZvcm0gdGhlIGRhc2ggcGF0dGVybi4gVGhlIGxlbmd0aHMgYXJlIGxhdGVyIHNjYWxlZCBieSB0aGUgbGluZSB3aWR0aC4gVG8gY29udmVydCBhIGRhc2ggbGVuZ3RoIHRvIHBpeGVscywgbXVsdGlwbHkgdGhlIGxlbmd0aCBieSB0aGUgY3VycmVudCBsaW5lIHdpZHRoLlwiLFxuICAgICAgXCJtaW5pbXVtXCI6IDAsXG4gICAgICBcInRyYW5zaXRpb25cIjogdHJ1ZSxcbiAgICAgIFwidW5pdHNcIjogXCJsaW5lIHdpZHRoc1wiLFxuICAgICAgXCJyZXF1aXJlc1wiOiBbXG4gICAgICAgIHtcbiAgICAgICAgICBcIiFcIjogXCJsaW5lLXBhdHRlcm5cIlxuICAgICAgICB9XG4gICAgICBdXG4gICAgfSxcbiAgICBcImxpbmUtcGF0dGVyblwiOiB7XG4gICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgIFwiZnVuY3Rpb25cIjogXCJwaWVjZXdpc2UtY29uc3RhbnRcIixcbiAgICAgIFwidHJhbnNpdGlvblwiOiB0cnVlLFxuICAgICAgXCJkb2NcIjogXCJOYW1lIG9mIGltYWdlIGluIHNwcml0ZSB0byB1c2UgZm9yIGRyYXdpbmcgaW1hZ2UgbGluZXMuIEZvciBzZWFtbGVzcyBwYXR0ZXJucywgaW1hZ2Ugd2lkdGggbXVzdCBiZSBhIGZhY3RvciBvZiB0d28gKDIsIDQsIDgsIC4uLiwgNTEyKS5cIlxuICAgIH1cbiAgfSxcbiAgXCJwYWludF9jaXJjbGVcIjoge1xuICAgIFwiY2lyY2xlLXJhZGl1c1wiOiB7XG4gICAgICBcInR5cGVcIjogXCJudW1iZXJcIixcbiAgICAgIFwiZGVmYXVsdFwiOiA1LFxuICAgICAgXCJtaW5pbXVtXCI6IDAsXG4gICAgICBcImZ1bmN0aW9uXCI6IFwiaW50ZXJwb2xhdGVkXCIsXG4gICAgICBcInRyYW5zaXRpb25cIjogdHJ1ZSxcbiAgICAgIFwidW5pdHNcIjogXCJwaXhlbHNcIixcbiAgICAgIFwiZG9jXCI6IFwiQ2lyY2xlIHJhZGl1cy5cIlxuICAgIH0sXG4gICAgXCJjaXJjbGUtY29sb3JcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwiY29sb3JcIixcbiAgICAgIFwiZGVmYXVsdFwiOiBcIiMwMDAwMDBcIixcbiAgICAgIFwiZG9jXCI6IFwiVGhlIGNvbG9yIG9mIHRoZSBjaXJjbGUuXCIsXG4gICAgICBcImZ1bmN0aW9uXCI6IFwiaW50ZXJwb2xhdGVkXCIsXG4gICAgICBcInRyYW5zaXRpb25cIjogdHJ1ZVxuICAgIH0sXG4gICAgXCJjaXJjbGUtYmx1clwiOiB7XG4gICAgICBcInR5cGVcIjogXCJudW1iZXJcIixcbiAgICAgIFwiZGVmYXVsdFwiOiAwLFxuICAgICAgXCJkb2NcIjogXCJBbW91bnQgdG8gYmx1ciB0aGUgY2lyY2xlLiAxIGJsdXJzIHRoZSBjaXJjbGUgc3VjaCB0aGF0IG9ubHkgdGhlIGNlbnRlcnBvaW50IGlzIGZ1bGwgb3BhY2l0eS5cIixcbiAgICAgIFwiZnVuY3Rpb25cIjogXCJpbnRlcnBvbGF0ZWRcIixcbiAgICAgIFwidHJhbnNpdGlvblwiOiB0cnVlXG4gICAgfSxcbiAgICBcImNpcmNsZS1vcGFjaXR5XCI6IHtcbiAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgXCJkb2NcIjogXCJUaGUgb3BhY2l0eSBhdCB3aGljaCB0aGUgY2lyY2xlIHdpbGwgYmUgZHJhd24uXCIsXG4gICAgICBcImRlZmF1bHRcIjogMSxcbiAgICAgIFwibWluaW11bVwiOiAwLFxuICAgICAgXCJtYXhpbXVtXCI6IDEsXG4gICAgICBcImZ1bmN0aW9uXCI6IFwiaW50ZXJwb2xhdGVkXCIsXG4gICAgICBcInRyYW5zaXRpb25cIjogdHJ1ZVxuICAgIH0sXG4gICAgXCJjaXJjbGUtdHJhbnNsYXRlXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcImFycmF5XCIsXG4gICAgICBcInZhbHVlXCI6IFwibnVtYmVyXCIsXG4gICAgICBcImxlbmd0aFwiOiAyLFxuICAgICAgXCJkZWZhdWx0XCI6IFswLCAwXSxcbiAgICAgIFwiZnVuY3Rpb25cIjogXCJpbnRlcnBvbGF0ZWRcIixcbiAgICAgIFwidHJhbnNpdGlvblwiOiB0cnVlLFxuICAgICAgXCJ1bml0c1wiOiBcInBpeGVsc1wiLFxuICAgICAgXCJkb2NcIjogXCJUaGUgZ2VvbWV0cnkncyBvZmZzZXQuIFZhbHVlcyBhcmUgW3gsIHldIHdoZXJlIG5lZ2F0aXZlcyBpbmRpY2F0ZSBsZWZ0IGFuZCB1cCwgcmVzcGVjdGl2ZWx5LlwiXG4gICAgfSxcbiAgICBcImNpcmNsZS10cmFuc2xhdGUtYW5jaG9yXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcImVudW1cIixcbiAgICAgIFwiZnVuY3Rpb25cIjogXCJwaWVjZXdpc2UtY29uc3RhbnRcIixcbiAgICAgIFwidmFsdWVzXCI6IFtcbiAgICAgICAgXCJtYXBcIixcbiAgICAgICAgXCJ2aWV3cG9ydFwiXG4gICAgICBdLFxuICAgICAgXCJkb2NcIjogXCJDb250cm9sIHdoZXRoZXIgdGhlIHRyYW5zbGF0aW9uIGlzIHJlbGF0aXZlIHRvIHRoZSBtYXAgKG5vcnRoKSBvciB2aWV3cG9ydCAoc2NyZWVuKVwiLFxuICAgICAgXCJkZWZhdWx0XCI6IFwibWFwXCIsXG4gICAgICBcInJlcXVpcmVzXCI6IFtcbiAgICAgICAgXCJjaXJjbGUtdHJhbnNsYXRlXCJcbiAgICAgIF1cbiAgICB9XG4gIH0sXG4gIFwicGFpbnRfc3ltYm9sXCI6IHtcbiAgICBcImljb24tb3BhY2l0eVwiOiB7XG4gICAgICBcImRvY1wiOiBcIlRoZSBvcGFjaXR5IGF0IHdoaWNoIHRoZSBpY29uIHdpbGwgYmUgZHJhd24uXCIsXG4gICAgICBcInR5cGVcIjogXCJudW1iZXJcIixcbiAgICAgIFwiZGVmYXVsdFwiOiAxLFxuICAgICAgXCJtaW5pbXVtXCI6IDAsXG4gICAgICBcIm1heGltdW1cIjogMSxcbiAgICAgIFwiZnVuY3Rpb25cIjogXCJpbnRlcnBvbGF0ZWRcIixcbiAgICAgIFwidHJhbnNpdGlvblwiOiB0cnVlLFxuICAgICAgXCJyZXF1aXJlc1wiOiBbXG4gICAgICAgIFwiaWNvbi1pbWFnZVwiXG4gICAgICBdXG4gICAgfSxcbiAgICBcImljb24tY29sb3JcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwiY29sb3JcIixcbiAgICAgIFwiZGVmYXVsdFwiOiBcIiMwMDAwMDBcIixcbiAgICAgIFwiZnVuY3Rpb25cIjogXCJpbnRlcnBvbGF0ZWRcIixcbiAgICAgIFwidHJhbnNpdGlvblwiOiB0cnVlLFxuICAgICAgXCJkb2NcIjogXCJUaGUgY29sb3Igb2YgdGhlIGljb24uIFRoaXMgY2FuIG9ubHkgYmUgdXNlZCB3aXRoIHNkZiBpY29ucy5cIixcbiAgICAgIFwicmVxdWlyZXNcIjogW1xuICAgICAgICBcImljb24taW1hZ2VcIlxuICAgICAgXVxuICAgIH0sXG4gICAgXCJpY29uLWhhbG8tY29sb3JcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwiY29sb3JcIixcbiAgICAgIFwiZGVmYXVsdFwiOiBcInJnYmEoMCwgMCwgMCwgMClcIixcbiAgICAgIFwiZnVuY3Rpb25cIjogXCJpbnRlcnBvbGF0ZWRcIixcbiAgICAgIFwidHJhbnNpdGlvblwiOiB0cnVlLFxuICAgICAgXCJkb2NcIjogXCJUaGUgY29sb3Igb2YgdGhlIGljb24ncyBoYWxvLiBJY29uIGhhbG9zIGNhbiBvbmx5IGJlIHVzZWQgd2l0aCBzZGYgaWNvbnMuXCIsXG4gICAgICBcInJlcXVpcmVzXCI6IFtcbiAgICAgICAgXCJpY29uLWltYWdlXCJcbiAgICAgIF1cbiAgICB9LFxuICAgIFwiaWNvbi1oYWxvLXdpZHRoXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgXCJkZWZhdWx0XCI6IDAsXG4gICAgICBcIm1pbmltdW1cIjogMCxcbiAgICAgIFwiZnVuY3Rpb25cIjogXCJpbnRlcnBvbGF0ZWRcIixcbiAgICAgIFwidHJhbnNpdGlvblwiOiB0cnVlLFxuICAgICAgXCJ1bml0c1wiOiBcInBpeGVsc1wiLFxuICAgICAgXCJkb2NcIjogXCJEaXN0YW5jZSBvZiBoYWxvIHRvIHRoZSBpY29uIG91dGxpbmUuXCIsXG4gICAgICBcInJlcXVpcmVzXCI6IFtcbiAgICAgICAgXCJpY29uLWltYWdlXCJcbiAgICAgIF1cbiAgICB9LFxuICAgIFwiaWNvbi1oYWxvLWJsdXJcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgICBcImRlZmF1bHRcIjogMCxcbiAgICAgIFwibWluaW11bVwiOiAwLFxuICAgICAgXCJmdW5jdGlvblwiOiBcImludGVycG9sYXRlZFwiLFxuICAgICAgXCJ0cmFuc2l0aW9uXCI6IHRydWUsXG4gICAgICBcInVuaXRzXCI6IFwicGl4ZWxzXCIsXG4gICAgICBcImRvY1wiOiBcIkZhZGUgb3V0IHRoZSBoYWxvIHRvd2FyZHMgdGhlIG91dHNpZGUuXCIsXG4gICAgICBcInJlcXVpcmVzXCI6IFtcbiAgICAgICAgXCJpY29uLWltYWdlXCJcbiAgICAgIF1cbiAgICB9LFxuICAgIFwiaWNvbi10cmFuc2xhdGVcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwiYXJyYXlcIixcbiAgICAgIFwidmFsdWVcIjogXCJudW1iZXJcIixcbiAgICAgIFwibGVuZ3RoXCI6IDIsXG4gICAgICBcImRlZmF1bHRcIjogW1xuICAgICAgICAwLFxuICAgICAgICAwXG4gICAgICBdLFxuICAgICAgXCJmdW5jdGlvblwiOiBcImludGVycG9sYXRlZFwiLFxuICAgICAgXCJ0cmFuc2l0aW9uXCI6IHRydWUsXG4gICAgICBcInVuaXRzXCI6IFwicGl4ZWxzXCIsXG4gICAgICBcImRvY1wiOiBcIkRpc3RhbmNlIHRoYXQgdGhlIGljb24ncyBhbmNob3IgaXMgbW92ZWQgZnJvbSBpdHMgb3JpZ2luYWwgcGxhY2VtZW50LiBQb3NpdGl2ZSB2YWx1ZXMgaW5kaWNhdGUgcmlnaHQgYW5kIGRvd24sIHdoaWxlIG5lZ2F0aXZlIHZhbHVlcyBpbmRpY2F0ZSBsZWZ0IGFuZCB1cC5cIixcbiAgICAgIFwicmVxdWlyZXNcIjogW1xuICAgICAgICBcImljb24taW1hZ2VcIlxuICAgICAgXVxuICAgIH0sXG4gICAgXCJpY29uLXRyYW5zbGF0ZS1hbmNob3JcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwiZW51bVwiLFxuICAgICAgXCJmdW5jdGlvblwiOiBcInBpZWNld2lzZS1jb25zdGFudFwiLFxuICAgICAgXCJ2YWx1ZXNcIjogW1xuICAgICAgICBcIm1hcFwiLFxuICAgICAgICBcInZpZXdwb3J0XCJcbiAgICAgIF0sXG4gICAgICBcImRvY1wiOiBcIkNvbnRyb2wgd2hldGhlciB0aGUgdHJhbnNsYXRpb24gaXMgcmVsYXRpdmUgdG8gdGhlIG1hcCAobm9ydGgpIG9yIHZpZXdwb3J0IChzY3JlZW4pLlwiLFxuICAgICAgXCJkZWZhdWx0XCI6IFwibWFwXCIsXG4gICAgICBcInJlcXVpcmVzXCI6IFtcbiAgICAgICAgXCJpY29uLWltYWdlXCIsXG4gICAgICAgIFwiaWNvbi10cmFuc2xhdGVcIlxuICAgICAgXVxuICAgIH0sXG4gICAgXCJ0ZXh0LW9wYWNpdHlcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgICBcImRvY1wiOiBcIlRoZSBvcGFjaXR5IGF0IHdoaWNoIHRoZSB0ZXh0IHdpbGwgYmUgZHJhd24uXCIsXG4gICAgICBcImRlZmF1bHRcIjogMSxcbiAgICAgIFwibWluaW11bVwiOiAwLFxuICAgICAgXCJtYXhpbXVtXCI6IDEsXG4gICAgICBcImZ1bmN0aW9uXCI6IFwiaW50ZXJwb2xhdGVkXCIsXG4gICAgICBcInRyYW5zaXRpb25cIjogdHJ1ZSxcbiAgICAgIFwicmVxdWlyZXNcIjogW1xuICAgICAgICBcInRleHQtZmllbGRcIlxuICAgICAgXVxuICAgIH0sXG4gICAgXCJ0ZXh0LWNvbG9yXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcImNvbG9yXCIsXG4gICAgICBcImRvY1wiOiBcIlRoZSBjb2xvciB3aXRoIHdoaWNoIHRoZSB0ZXh0IHdpbGwgYmUgZHJhd24uXCIsXG4gICAgICBcImRlZmF1bHRcIjogXCIjMDAwMDAwXCIsXG4gICAgICBcImZ1bmN0aW9uXCI6IFwiaW50ZXJwb2xhdGVkXCIsXG4gICAgICBcInRyYW5zaXRpb25cIjogdHJ1ZSxcbiAgICAgIFwicmVxdWlyZXNcIjogW1xuICAgICAgICBcInRleHQtZmllbGRcIlxuICAgICAgXVxuICAgIH0sXG4gICAgXCJ0ZXh0LWhhbG8tY29sb3JcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwiY29sb3JcIixcbiAgICAgIFwiZGVmYXVsdFwiOiBcInJnYmEoMCwgMCwgMCwgMClcIixcbiAgICAgIFwiZnVuY3Rpb25cIjogXCJpbnRlcnBvbGF0ZWRcIixcbiAgICAgIFwidHJhbnNpdGlvblwiOiB0cnVlLFxuICAgICAgXCJkb2NcIjogXCJUaGUgY29sb3Igb2YgdGhlIHRleHQncyBoYWxvLCB3aGljaCBoZWxwcyBpdCBzdGFuZCBvdXQgZnJvbSBiYWNrZ3JvdW5kcy5cIixcbiAgICAgIFwicmVxdWlyZXNcIjogW1xuICAgICAgICBcInRleHQtZmllbGRcIlxuICAgICAgXVxuICAgIH0sXG4gICAgXCJ0ZXh0LWhhbG8td2lkdGhcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgICBcImRlZmF1bHRcIjogMCxcbiAgICAgIFwibWluaW11bVwiOiAwLFxuICAgICAgXCJmdW5jdGlvblwiOiBcImludGVycG9sYXRlZFwiLFxuICAgICAgXCJ0cmFuc2l0aW9uXCI6IHRydWUsXG4gICAgICBcInVuaXRzXCI6IFwicGl4ZWxzXCIsXG4gICAgICBcImRvY1wiOiBcIkRpc3RhbmNlIG9mIGhhbG8gdG8gdGhlIGZvbnQgb3V0bGluZS4gTWF4IHRleHQgaGFsbyB3aWR0aCBpcyAxLzQgb2YgdGhlIGZvbnQtc2l6ZS5cIixcbiAgICAgIFwicmVxdWlyZXNcIjogW1xuICAgICAgICBcInRleHQtZmllbGRcIlxuICAgICAgXVxuICAgIH0sXG4gICAgXCJ0ZXh0LWhhbG8tYmx1clwiOiB7XG4gICAgICBcInR5cGVcIjogXCJudW1iZXJcIixcbiAgICAgIFwiZGVmYXVsdFwiOiAwLFxuICAgICAgXCJtaW5pbXVtXCI6IDAsXG4gICAgICBcImZ1bmN0aW9uXCI6IFwiaW50ZXJwb2xhdGVkXCIsXG4gICAgICBcInRyYW5zaXRpb25cIjogdHJ1ZSxcbiAgICAgIFwidW5pdHNcIjogXCJwaXhlbHNcIixcbiAgICAgIFwiZG9jXCI6IFwiVGhlIGhhbG8ncyBmYWRlb3V0IGRpc3RhbmNlIHRvd2FyZHMgdGhlIG91dHNpZGUuXCIsXG4gICAgICBcInJlcXVpcmVzXCI6IFtcbiAgICAgICAgXCJ0ZXh0LWZpZWxkXCJcbiAgICAgIF1cbiAgICB9LFxuICAgIFwidGV4dC10cmFuc2xhdGVcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwiYXJyYXlcIixcbiAgICAgIFwidmFsdWVcIjogXCJudW1iZXJcIixcbiAgICAgIFwibGVuZ3RoXCI6IDIsXG4gICAgICBcImRlZmF1bHRcIjogW1xuICAgICAgICAwLFxuICAgICAgICAwXG4gICAgICBdLFxuICAgICAgXCJmdW5jdGlvblwiOiBcImludGVycG9sYXRlZFwiLFxuICAgICAgXCJ0cmFuc2l0aW9uXCI6IHRydWUsXG4gICAgICBcInVuaXRzXCI6IFwicGl4ZWxzXCIsXG4gICAgICBcImRvY1wiOiBcIkRpc3RhbmNlIHRoYXQgdGhlIHRleHQncyBhbmNob3IgaXMgbW92ZWQgZnJvbSBpdHMgb3JpZ2luYWwgcGxhY2VtZW50LiBQb3NpdGl2ZSB2YWx1ZXMgaW5kaWNhdGUgcmlnaHQgYW5kIGRvd24sIHdoaWxlIG5lZ2F0aXZlIHZhbHVlcyBpbmRpY2F0ZSBsZWZ0IGFuZCB1cC5cIixcbiAgICAgIFwicmVxdWlyZXNcIjogW1xuICAgICAgICBcInRleHQtZmllbGRcIlxuICAgICAgXVxuICAgIH0sXG4gICAgXCJ0ZXh0LXRyYW5zbGF0ZS1hbmNob3JcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwiZW51bVwiLFxuICAgICAgXCJmdW5jdGlvblwiOiBcInBpZWNld2lzZS1jb25zdGFudFwiLFxuICAgICAgXCJ2YWx1ZXNcIjogW1xuICAgICAgICBcIm1hcFwiLFxuICAgICAgICBcInZpZXdwb3J0XCJcbiAgICAgIF0sXG4gICAgICBcImRvY1wiOiBcIkNvbnRyb2wgd2hldGhlciB0aGUgdHJhbnNsYXRpb24gaXMgcmVsYXRpdmUgdG8gdGhlIG1hcCAobm9ydGgpIG9yIHZpZXdwb3J0IChzY3JlZW4pLlwiLFxuICAgICAgXCJkZWZhdWx0XCI6IFwibWFwXCIsXG4gICAgICBcInJlcXVpcmVzXCI6IFtcbiAgICAgICAgXCJ0ZXh0LWZpZWxkXCIsXG4gICAgICAgIFwidGV4dC10cmFuc2xhdGVcIlxuICAgICAgXVxuICAgIH1cbiAgfSxcbiAgXCJwYWludF9yYXN0ZXJcIjoge1xuICAgIFwicmFzdGVyLW9wYWNpdHlcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgICBcImRvY1wiOiBcIlRoZSBvcGFjaXR5IGF0IHdoaWNoIHRoZSBpbWFnZSB3aWxsIGJlIGRyYXduLlwiLFxuICAgICAgXCJkZWZhdWx0XCI6IDEsXG4gICAgICBcIm1pbmltdW1cIjogMCxcbiAgICAgIFwibWF4aW11bVwiOiAxLFxuICAgICAgXCJmdW5jdGlvblwiOiBcImludGVycG9sYXRlZFwiLFxuICAgICAgXCJ0cmFuc2l0aW9uXCI6IHRydWVcbiAgICB9LFxuICAgIFwicmFzdGVyLWh1ZS1yb3RhdGVcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgICBcImRlZmF1bHRcIjogMCxcbiAgICAgIFwicGVyaW9kXCI6IDM2MCxcbiAgICAgIFwiZnVuY3Rpb25cIjogXCJpbnRlcnBvbGF0ZWRcIixcbiAgICAgIFwidHJhbnNpdGlvblwiOiB0cnVlLFxuICAgICAgXCJ1bml0c1wiOiBcImRlZ3JlZXNcIixcbiAgICAgIFwiZG9jXCI6IFwiUm90YXRlcyBodWVzIGFyb3VuZCB0aGUgY29sb3Igd2hlZWwuXCJcbiAgICB9LFxuICAgIFwicmFzdGVyLWJyaWdodG5lc3MtbWluXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgXCJmdW5jdGlvblwiOiBcImludGVycG9sYXRlZFwiLFxuICAgICAgXCJkb2NcIjogXCJJbmNyZWFzZSBvciByZWR1Y2UgdGhlIGJyaWdodG5lc3Mgb2YgdGhlIGltYWdlLiBUaGUgdmFsdWUgaXMgdGhlIG1pbmltdW0gYnJpZ2h0bmVzcy5cIixcbiAgICAgIFwiZGVmYXVsdFwiOiAwLFxuICAgICAgXCJtaW5pbXVtXCI6IDAsXG4gICAgICBcIm1heGltdW1cIjogMSxcbiAgICAgIFwidHJhbnNpdGlvblwiOiB0cnVlXG4gICAgfSxcbiAgICBcInJhc3Rlci1icmlnaHRuZXNzLW1heFwiOiB7XG4gICAgICBcInR5cGVcIjogXCJudW1iZXJcIixcbiAgICAgIFwiZnVuY3Rpb25cIjogXCJpbnRlcnBvbGF0ZWRcIixcbiAgICAgIFwiZG9jXCI6IFwiSW5jcmVhc2Ugb3IgcmVkdWNlIHRoZSBicmlnaHRuZXNzIG9mIHRoZSBpbWFnZS4gVGhlIHZhbHVlIGlzIHRoZSBtYXhpbXVtIGJyaWdodG5lc3MuXCIsXG4gICAgICBcImRlZmF1bHRcIjogMSxcbiAgICAgIFwibWluaW11bVwiOiAwLFxuICAgICAgXCJtYXhpbXVtXCI6IDEsXG4gICAgICBcInRyYW5zaXRpb25cIjogdHJ1ZVxuICAgIH0sXG4gICAgXCJyYXN0ZXItc2F0dXJhdGlvblwiOiB7XG4gICAgICBcInR5cGVcIjogXCJudW1iZXJcIixcbiAgICAgIFwiZG9jXCI6IFwiSW5jcmVhc2Ugb3IgcmVkdWNlIHRoZSBzYXR1cmF0aW9uIG9mIHRoZSBpbWFnZS5cIixcbiAgICAgIFwiZGVmYXVsdFwiOiAwLFxuICAgICAgXCJtaW5pbXVtXCI6IC0xLFxuICAgICAgXCJtYXhpbXVtXCI6IDEsXG4gICAgICBcImZ1bmN0aW9uXCI6IFwiaW50ZXJwb2xhdGVkXCIsXG4gICAgICBcInRyYW5zaXRpb25cIjogdHJ1ZVxuICAgIH0sXG4gICAgXCJyYXN0ZXItY29udHJhc3RcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgICBcImRvY1wiOiBcIkluY3JlYXNlIG9yIHJlZHVjZSB0aGUgY29udHJhc3Qgb2YgdGhlIGltYWdlLlwiLFxuICAgICAgXCJkZWZhdWx0XCI6IDAsXG4gICAgICBcIm1pbmltdW1cIjogLTEsXG4gICAgICBcIm1heGltdW1cIjogMSxcbiAgICAgIFwiZnVuY3Rpb25cIjogXCJpbnRlcnBvbGF0ZWRcIixcbiAgICAgIFwidHJhbnNpdGlvblwiOiB0cnVlXG4gICAgfSxcbiAgICBcInJhc3Rlci1mYWRlLWR1cmF0aW9uXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgXCJkZWZhdWx0XCI6IDMwMCxcbiAgICAgIFwibWluaW11bVwiOiAwLFxuICAgICAgXCJmdW5jdGlvblwiOiBcImludGVycG9sYXRlZFwiLFxuICAgICAgXCJ0cmFuc2l0aW9uXCI6IHRydWUsXG4gICAgICBcInVuaXRzXCI6IFwibWlsbGlzZWNvbmRzXCIsXG4gICAgICBcImRvY1wiOiBcIkZhZGUgZHVyYXRpb24gd2hlbiBhIG5ldyB0aWxlIGlzIGFkZGVkLlwiXG4gICAgfVxuICB9LFxuICBcInBhaW50X2JhY2tncm91bmRcIjoge1xuICAgIFwiYmFja2dyb3VuZC1jb2xvclwiOiB7XG4gICAgICBcInR5cGVcIjogXCJjb2xvclwiLFxuICAgICAgXCJkZWZhdWx0XCI6IFwiIzAwMDAwMFwiLFxuICAgICAgXCJkb2NcIjogXCJUaGUgY29sb3Igd2l0aCB3aGljaCB0aGUgYmFja2dyb3VuZCB3aWxsIGJlIGRyYXduLlwiLFxuICAgICAgXCJmdW5jdGlvblwiOiBcImludGVycG9sYXRlZFwiLFxuICAgICAgXCJ0cmFuc2l0aW9uXCI6IHRydWUsXG4gICAgICBcInJlcXVpcmVzXCI6IFtcbiAgICAgICAge1xuICAgICAgICAgIFwiIVwiOiBcImJhY2tncm91bmQtcGF0dGVyblwiXG4gICAgICAgIH1cbiAgICAgIF1cbiAgICB9LFxuICAgIFwiYmFja2dyb3VuZC1wYXR0ZXJuXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgXCJmdW5jdGlvblwiOiBcInBpZWNld2lzZS1jb25zdGFudFwiLFxuICAgICAgXCJ0cmFuc2l0aW9uXCI6IHRydWUsXG4gICAgICBcImRvY1wiOiBcIk5hbWUgb2YgaW1hZ2UgaW4gc3ByaXRlIHRvIHVzZSBmb3IgZHJhd2luZyBhbiBpbWFnZSBiYWNrZ3JvdW5kLiBGb3Igc2VhbWxlc3MgcGF0dGVybnMsIGltYWdlIHdpZHRoIGFuZCBoZWlnaHQgbXVzdCBiZSBhIGZhY3RvciBvZiB0d28gKDIsIDQsIDgsIC4uLiwgNTEyKS5cIlxuICAgIH0sXG4gICAgXCJiYWNrZ3JvdW5kLW9wYWNpdHlcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgICBcImRlZmF1bHRcIjogMSxcbiAgICAgIFwibWluaW11bVwiOiAwLFxuICAgICAgXCJtYXhpbXVtXCI6IDEsXG4gICAgICBcImRvY1wiOiBcIlRoZSBvcGFjaXR5IGF0IHdoaWNoIHRoZSBiYWNrZ3JvdW5kIHdpbGwgYmUgZHJhd24uXCIsXG4gICAgICBcImZ1bmN0aW9uXCI6IFwiaW50ZXJwb2xhdGVkXCIsXG4gICAgICBcInRyYW5zaXRpb25cIjogdHJ1ZVxuICAgIH1cbiAgfSxcbiAgXCJ0cmFuc2l0aW9uXCI6IHtcbiAgICBcImR1cmF0aW9uXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgXCJkZWZhdWx0XCI6IDMwMCxcbiAgICAgIFwibWluaW11bVwiOiAwLFxuICAgICAgXCJ1bml0c1wiOiBcIm1pbGxpc2Vjb25kc1wiLFxuICAgICAgXCJkb2NcIjogXCJUaW1lIGFsbG90dGVkIGZvciB0cmFuc2l0aW9ucyB0byBjb21wbGV0ZS5cIlxuICAgIH0sXG4gICAgXCJkZWxheVwiOiB7XG4gICAgICBcInR5cGVcIjogXCJudW1iZXJcIixcbiAgICAgIFwiZGVmYXVsdFwiOiAwLFxuICAgICAgXCJtaW5pbXVtXCI6IDAsXG4gICAgICBcInVuaXRzXCI6IFwibWlsbGlzZWNvbmRzXCIsXG4gICAgICBcImRvY1wiOiBcIkxlbmd0aCBvZiB0aW1lIGJlZm9yZSBhIHRyYW5zaXRpb24gYmVnaW5zLlwiXG4gICAgfVxuICB9XG59XG4iLCJtb2R1bGUuZXhwb3J0cz17XCIkdmVyc2lvblwiOjgsXCIkcm9vdFwiOntcInZlcnNpb25cIjp7XCJyZXF1aXJlZFwiOnRydWUsXCJ0eXBlXCI6XCJlbnVtXCIsXCJ2YWx1ZXNcIjpbOF19LFwibmFtZVwiOntcInR5cGVcIjpcInN0cmluZ1wifSxcIm1ldGFkYXRhXCI6e1widHlwZVwiOlwiKlwifSxcImNlbnRlclwiOntcInR5cGVcIjpcImFycmF5XCIsXCJ2YWx1ZVwiOlwibnVtYmVyXCJ9LFwiem9vbVwiOntcInR5cGVcIjpcIm51bWJlclwifSxcImJlYXJpbmdcIjp7XCJ0eXBlXCI6XCJudW1iZXJcIixcImRlZmF1bHRcIjowLFwicGVyaW9kXCI6MzYwLFwidW5pdHNcIjpcImRlZ3JlZXNcIn0sXCJwaXRjaFwiOntcInR5cGVcIjpcIm51bWJlclwiLFwiZGVmYXVsdFwiOjAsXCJ1bml0c1wiOlwiZGVncmVlc1wifSxcInNvdXJjZXNcIjp7XCJyZXF1aXJlZFwiOnRydWUsXCJ0eXBlXCI6XCJzb3VyY2VzXCJ9LFwic3ByaXRlXCI6e1widHlwZVwiOlwic3RyaW5nXCJ9LFwiZ2x5cGhzXCI6e1widHlwZVwiOlwic3RyaW5nXCJ9LFwidHJhbnNpdGlvblwiOntcInR5cGVcIjpcInRyYW5zaXRpb25cIn0sXCJsYXllcnNcIjp7XCJyZXF1aXJlZFwiOnRydWUsXCJ0eXBlXCI6XCJhcnJheVwiLFwidmFsdWVcIjpcImxheWVyXCJ9fSxcInNvdXJjZXNcIjp7XCIqXCI6e1widHlwZVwiOlwic291cmNlXCJ9fSxcInNvdXJjZVwiOltcInNvdXJjZV90aWxlXCIsXCJzb3VyY2VfZ2VvanNvblwiLFwic291cmNlX3ZpZGVvXCIsXCJzb3VyY2VfaW1hZ2VcIl0sXCJzb3VyY2VfdGlsZVwiOntcInR5cGVcIjp7XCJyZXF1aXJlZFwiOnRydWUsXCJ0eXBlXCI6XCJlbnVtXCIsXCJ2YWx1ZXNcIjpbXCJ2ZWN0b3JcIixcInJhc3RlclwiXX0sXCJ1cmxcIjp7XCJ0eXBlXCI6XCJzdHJpbmdcIn0sXCJ0aWxlc1wiOntcInR5cGVcIjpcImFycmF5XCIsXCJ2YWx1ZVwiOlwic3RyaW5nXCJ9LFwibWluem9vbVwiOntcInR5cGVcIjpcIm51bWJlclwiLFwiZGVmYXVsdFwiOjB9LFwibWF4em9vbVwiOntcInR5cGVcIjpcIm51bWJlclwiLFwiZGVmYXVsdFwiOjIyfSxcInRpbGVTaXplXCI6e1widHlwZVwiOlwibnVtYmVyXCIsXCJkZWZhdWx0XCI6NTEyLFwidW5pdHNcIjpcInBpeGVsc1wifSxcIipcIjp7XCJ0eXBlXCI6XCIqXCJ9fSxcInNvdXJjZV9nZW9qc29uXCI6e1widHlwZVwiOntcInJlcXVpcmVkXCI6dHJ1ZSxcInR5cGVcIjpcImVudW1cIixcInZhbHVlc1wiOltcImdlb2pzb25cIl19LFwiZGF0YVwiOntcInR5cGVcIjpcIipcIn0sXCJtYXh6b29tXCI6e1widHlwZVwiOlwibnVtYmVyXCIsXCJkZWZhdWx0XCI6MTR9LFwiYnVmZmVyXCI6e1widHlwZVwiOlwibnVtYmVyXCIsXCJkZWZhdWx0XCI6NjR9LFwidG9sZXJhbmNlXCI6e1widHlwZVwiOlwibnVtYmVyXCIsXCJkZWZhdWx0XCI6M30sXCJjbHVzdGVyXCI6e1widHlwZVwiOlwiYm9vbGVhblwiLFwiZGVmYXVsdFwiOmZhbHNlfSxcImNsdXN0ZXJSYWRpdXNcIjp7XCJ0eXBlXCI6XCJudW1iZXJcIixcImRlZmF1bHRcIjo0MDB9LFwiY2x1c3Rlck1heFpvb21cIjp7XCJ0eXBlXCI6XCJudW1iZXJcIn19LFwic291cmNlX3ZpZGVvXCI6e1widHlwZVwiOntcInJlcXVpcmVkXCI6dHJ1ZSxcInR5cGVcIjpcImVudW1cIixcInZhbHVlc1wiOltcInZpZGVvXCJdfSxcInVybHNcIjp7XCJyZXF1aXJlZFwiOnRydWUsXCJ0eXBlXCI6XCJhcnJheVwiLFwidmFsdWVcIjpcInN0cmluZ1wifSxcImNvb3JkaW5hdGVzXCI6e1wicmVxdWlyZWRcIjp0cnVlLFwidHlwZVwiOlwiYXJyYXlcIixcImxlbmd0aFwiOjQsXCJ2YWx1ZVwiOntcInR5cGVcIjpcImFycmF5XCIsXCJsZW5ndGhcIjoyLFwidmFsdWVcIjpcIm51bWJlclwifX19LFwic291cmNlX2ltYWdlXCI6e1widHlwZVwiOntcInJlcXVpcmVkXCI6dHJ1ZSxcInR5cGVcIjpcImVudW1cIixcInZhbHVlc1wiOltcImltYWdlXCJdfSxcInVybFwiOntcInJlcXVpcmVkXCI6dHJ1ZSxcInR5cGVcIjpcInN0cmluZ1wifSxcImNvb3JkaW5hdGVzXCI6e1wicmVxdWlyZWRcIjp0cnVlLFwidHlwZVwiOlwiYXJyYXlcIixcImxlbmd0aFwiOjQsXCJ2YWx1ZVwiOntcInR5cGVcIjpcImFycmF5XCIsXCJsZW5ndGhcIjoyLFwidmFsdWVcIjpcIm51bWJlclwifX19LFwibGF5ZXJcIjp7XCJpZFwiOntcInR5cGVcIjpcInN0cmluZ1wiLFwicmVxdWlyZWRcIjp0cnVlfSxcInR5cGVcIjp7XCJ0eXBlXCI6XCJlbnVtXCIsXCJ2YWx1ZXNcIjpbXCJmaWxsXCIsXCJsaW5lXCIsXCJzeW1ib2xcIixcImNpcmNsZVwiLFwicmFzdGVyXCIsXCJiYWNrZ3JvdW5kXCJdfSxcIm1ldGFkYXRhXCI6e1widHlwZVwiOlwiKlwifSxcInJlZlwiOntcInR5cGVcIjpcInN0cmluZ1wifSxcInNvdXJjZVwiOntcInR5cGVcIjpcInN0cmluZ1wifSxcInNvdXJjZS1sYXllclwiOntcInR5cGVcIjpcInN0cmluZ1wifSxcIm1pbnpvb21cIjp7XCJ0eXBlXCI6XCJudW1iZXJcIixcIm1pbmltdW1cIjowLFwibWF4aW11bVwiOjIyfSxcIm1heHpvb21cIjp7XCJ0eXBlXCI6XCJudW1iZXJcIixcIm1pbmltdW1cIjowLFwibWF4aW11bVwiOjIyfSxcImludGVyYWN0aXZlXCI6e1widHlwZVwiOlwiYm9vbGVhblwiLFwiZGVmYXVsdFwiOmZhbHNlfSxcImZpbHRlclwiOntcInR5cGVcIjpcImZpbHRlclwifSxcImxheW91dFwiOntcInR5cGVcIjpcImxheW91dFwifSxcInBhaW50XCI6e1widHlwZVwiOlwicGFpbnRcIn0sXCJwYWludC4qXCI6e1widHlwZVwiOlwicGFpbnRcIn19LFwibGF5b3V0XCI6W1wibGF5b3V0X2ZpbGxcIixcImxheW91dF9saW5lXCIsXCJsYXlvdXRfY2lyY2xlXCIsXCJsYXlvdXRfc3ltYm9sXCIsXCJsYXlvdXRfcmFzdGVyXCIsXCJsYXlvdXRfYmFja2dyb3VuZFwiXSxcImxheW91dF9iYWNrZ3JvdW5kXCI6e1widmlzaWJpbGl0eVwiOntcInR5cGVcIjpcImVudW1cIixcImZ1bmN0aW9uXCI6XCJwaWVjZXdpc2UtY29uc3RhbnRcIixcInZhbHVlc1wiOltcInZpc2libGVcIixcIm5vbmVcIl0sXCJkZWZhdWx0XCI6XCJ2aXNpYmxlXCJ9fSxcImxheW91dF9maWxsXCI6e1widmlzaWJpbGl0eVwiOntcInR5cGVcIjpcImVudW1cIixcImZ1bmN0aW9uXCI6XCJwaWVjZXdpc2UtY29uc3RhbnRcIixcInZhbHVlc1wiOltcInZpc2libGVcIixcIm5vbmVcIl0sXCJkZWZhdWx0XCI6XCJ2aXNpYmxlXCJ9fSxcImxheW91dF9jaXJjbGVcIjp7XCJ2aXNpYmlsaXR5XCI6e1widHlwZVwiOlwiZW51bVwiLFwiZnVuY3Rpb25cIjpcInBpZWNld2lzZS1jb25zdGFudFwiLFwidmFsdWVzXCI6W1widmlzaWJsZVwiLFwibm9uZVwiXSxcImRlZmF1bHRcIjpcInZpc2libGVcIn19LFwibGF5b3V0X2xpbmVcIjp7XCJsaW5lLWNhcFwiOntcInR5cGVcIjpcImVudW1cIixcImZ1bmN0aW9uXCI6XCJwaWVjZXdpc2UtY29uc3RhbnRcIixcInZhbHVlc1wiOltcImJ1dHRcIixcInJvdW5kXCIsXCJzcXVhcmVcIl0sXCJkZWZhdWx0XCI6XCJidXR0XCJ9LFwibGluZS1qb2luXCI6e1widHlwZVwiOlwiZW51bVwiLFwiZnVuY3Rpb25cIjpcInBpZWNld2lzZS1jb25zdGFudFwiLFwidmFsdWVzXCI6W1wiYmV2ZWxcIixcInJvdW5kXCIsXCJtaXRlclwiXSxcImRlZmF1bHRcIjpcIm1pdGVyXCJ9LFwibGluZS1taXRlci1saW1pdFwiOntcInR5cGVcIjpcIm51bWJlclwiLFwiZGVmYXVsdFwiOjIsXCJmdW5jdGlvblwiOlwiaW50ZXJwb2xhdGVkXCIsXCJyZXF1aXJlc1wiOlt7XCJsaW5lLWpvaW5cIjpcIm1pdGVyXCJ9XX0sXCJsaW5lLXJvdW5kLWxpbWl0XCI6e1widHlwZVwiOlwibnVtYmVyXCIsXCJkZWZhdWx0XCI6MS4wNSxcImZ1bmN0aW9uXCI6XCJpbnRlcnBvbGF0ZWRcIixcInJlcXVpcmVzXCI6W3tcImxpbmUtam9pblwiOlwicm91bmRcIn1dfSxcInZpc2liaWxpdHlcIjp7XCJ0eXBlXCI6XCJlbnVtXCIsXCJmdW5jdGlvblwiOlwicGllY2V3aXNlLWNvbnN0YW50XCIsXCJ2YWx1ZXNcIjpbXCJ2aXNpYmxlXCIsXCJub25lXCJdLFwiZGVmYXVsdFwiOlwidmlzaWJsZVwifX0sXCJsYXlvdXRfc3ltYm9sXCI6e1wic3ltYm9sLXBsYWNlbWVudFwiOntcInR5cGVcIjpcImVudW1cIixcImZ1bmN0aW9uXCI6XCJwaWVjZXdpc2UtY29uc3RhbnRcIixcInZhbHVlc1wiOltcInBvaW50XCIsXCJsaW5lXCJdLFwiZGVmYXVsdFwiOlwicG9pbnRcIn0sXCJzeW1ib2wtc3BhY2luZ1wiOntcInR5cGVcIjpcIm51bWJlclwiLFwiZGVmYXVsdFwiOjI1MCxcIm1pbmltdW1cIjoxLFwiZnVuY3Rpb25cIjpcImludGVycG9sYXRlZFwiLFwidW5pdHNcIjpcInBpeGVsc1wiLFwicmVxdWlyZXNcIjpbe1wic3ltYm9sLXBsYWNlbWVudFwiOlwibGluZVwifV19LFwic3ltYm9sLWF2b2lkLWVkZ2VzXCI6e1widHlwZVwiOlwiYm9vbGVhblwiLFwiZnVuY3Rpb25cIjpcInBpZWNld2lzZS1jb25zdGFudFwiLFwiZGVmYXVsdFwiOmZhbHNlfSxcImljb24tYWxsb3ctb3ZlcmxhcFwiOntcInR5cGVcIjpcImJvb2xlYW5cIixcImZ1bmN0aW9uXCI6XCJwaWVjZXdpc2UtY29uc3RhbnRcIixcImRlZmF1bHRcIjpmYWxzZSxcInJlcXVpcmVzXCI6W1wiaWNvbi1pbWFnZVwiXX0sXCJpY29uLWlnbm9yZS1wbGFjZW1lbnRcIjp7XCJ0eXBlXCI6XCJib29sZWFuXCIsXCJmdW5jdGlvblwiOlwicGllY2V3aXNlLWNvbnN0YW50XCIsXCJkZWZhdWx0XCI6ZmFsc2UsXCJyZXF1aXJlc1wiOltcImljb24taW1hZ2VcIl19LFwiaWNvbi1vcHRpb25hbFwiOntcInR5cGVcIjpcImJvb2xlYW5cIixcImZ1bmN0aW9uXCI6XCJwaWVjZXdpc2UtY29uc3RhbnRcIixcImRlZmF1bHRcIjpmYWxzZSxcInJlcXVpcmVzXCI6W1wiaWNvbi1pbWFnZVwiLFwidGV4dC1maWVsZFwiXX0sXCJpY29uLXJvdGF0aW9uLWFsaWdubWVudFwiOntcInR5cGVcIjpcImVudW1cIixcImZ1bmN0aW9uXCI6XCJwaWVjZXdpc2UtY29uc3RhbnRcIixcInZhbHVlc1wiOltcIm1hcFwiLFwidmlld3BvcnRcIl0sXCJkZWZhdWx0XCI6XCJ2aWV3cG9ydFwiLFwicmVxdWlyZXNcIjpbXCJpY29uLWltYWdlXCJdfSxcImljb24tc2l6ZVwiOntcInR5cGVcIjpcIm51bWJlclwiLFwiZGVmYXVsdFwiOjEsXCJtaW5pbXVtXCI6MCxcImZ1bmN0aW9uXCI6XCJpbnRlcnBvbGF0ZWRcIixcInJlcXVpcmVzXCI6W1wiaWNvbi1pbWFnZVwiXX0sXCJpY29uLWltYWdlXCI6e1widHlwZVwiOlwic3RyaW5nXCIsXCJmdW5jdGlvblwiOlwicGllY2V3aXNlLWNvbnN0YW50XCIsXCJ0b2tlbnNcIjp0cnVlfSxcImljb24tcm90YXRlXCI6e1widHlwZVwiOlwibnVtYmVyXCIsXCJkZWZhdWx0XCI6MCxcInBlcmlvZFwiOjM2MCxcImZ1bmN0aW9uXCI6XCJpbnRlcnBvbGF0ZWRcIixcInVuaXRzXCI6XCJkZWdyZWVzXCIsXCJyZXF1aXJlc1wiOltcImljb24taW1hZ2VcIl19LFwiaWNvbi1wYWRkaW5nXCI6e1widHlwZVwiOlwibnVtYmVyXCIsXCJkZWZhdWx0XCI6MixcIm1pbmltdW1cIjowLFwiZnVuY3Rpb25cIjpcImludGVycG9sYXRlZFwiLFwidW5pdHNcIjpcInBpeGVsc1wiLFwicmVxdWlyZXNcIjpbXCJpY29uLWltYWdlXCJdfSxcImljb24ta2VlcC11cHJpZ2h0XCI6e1widHlwZVwiOlwiYm9vbGVhblwiLFwiZnVuY3Rpb25cIjpcInBpZWNld2lzZS1jb25zdGFudFwiLFwiZGVmYXVsdFwiOmZhbHNlLFwicmVxdWlyZXNcIjpbXCJpY29uLWltYWdlXCIse1wiaWNvbi1yb3RhdGlvbi1hbGlnbm1lbnRcIjpcIm1hcFwifSx7XCJzeW1ib2wtcGxhY2VtZW50XCI6XCJsaW5lXCJ9XX0sXCJpY29uLW9mZnNldFwiOntcInR5cGVcIjpcImFycmF5XCIsXCJ2YWx1ZVwiOlwibnVtYmVyXCIsXCJsZW5ndGhcIjoyLFwiZGVmYXVsdFwiOlswLDBdLFwiZnVuY3Rpb25cIjpcImludGVycG9sYXRlZFwiLFwicmVxdWlyZXNcIjpbXCJpY29uLWltYWdlXCJdfSxcInRleHQtcm90YXRpb24tYWxpZ25tZW50XCI6e1widHlwZVwiOlwiZW51bVwiLFwiZnVuY3Rpb25cIjpcInBpZWNld2lzZS1jb25zdGFudFwiLFwidmFsdWVzXCI6W1wibWFwXCIsXCJ2aWV3cG9ydFwiXSxcImRlZmF1bHRcIjpcInZpZXdwb3J0XCIsXCJyZXF1aXJlc1wiOltcInRleHQtZmllbGRcIl19LFwidGV4dC1maWVsZFwiOntcInR5cGVcIjpcInN0cmluZ1wiLFwiZnVuY3Rpb25cIjpcInBpZWNld2lzZS1jb25zdGFudFwiLFwiZGVmYXVsdFwiOlwiXCIsXCJ0b2tlbnNcIjp0cnVlfSxcInRleHQtZm9udFwiOntcInR5cGVcIjpcImFycmF5XCIsXCJ2YWx1ZVwiOlwic3RyaW5nXCIsXCJmdW5jdGlvblwiOlwicGllY2V3aXNlLWNvbnN0YW50XCIsXCJkZWZhdWx0XCI6W1wiT3BlbiBTYW5zIFJlZ3VsYXJcIixcIkFyaWFsIFVuaWNvZGUgTVMgUmVndWxhclwiXSxcInJlcXVpcmVzXCI6W1widGV4dC1maWVsZFwiXX0sXCJ0ZXh0LXNpemVcIjp7XCJ0eXBlXCI6XCJudW1iZXJcIixcImRlZmF1bHRcIjoxNixcIm1pbmltdW1cIjowLFwidW5pdHNcIjpcInBpeGVsc1wiLFwiZnVuY3Rpb25cIjpcImludGVycG9sYXRlZFwiLFwicmVxdWlyZXNcIjpbXCJ0ZXh0LWZpZWxkXCJdfSxcInRleHQtbWF4LXdpZHRoXCI6e1widHlwZVwiOlwibnVtYmVyXCIsXCJkZWZhdWx0XCI6MTAsXCJtaW5pbXVtXCI6MCxcInVuaXRzXCI6XCJlbVwiLFwiZnVuY3Rpb25cIjpcImludGVycG9sYXRlZFwiLFwicmVxdWlyZXNcIjpbXCJ0ZXh0LWZpZWxkXCJdfSxcInRleHQtbGluZS1oZWlnaHRcIjp7XCJ0eXBlXCI6XCJudW1iZXJcIixcImRlZmF1bHRcIjoxLjIsXCJ1bml0c1wiOlwiZW1cIixcImZ1bmN0aW9uXCI6XCJpbnRlcnBvbGF0ZWRcIixcInJlcXVpcmVzXCI6W1widGV4dC1maWVsZFwiXX0sXCJ0ZXh0LWxldHRlci1zcGFjaW5nXCI6e1widHlwZVwiOlwibnVtYmVyXCIsXCJkZWZhdWx0XCI6MCxcInVuaXRzXCI6XCJlbVwiLFwiZnVuY3Rpb25cIjpcImludGVycG9sYXRlZFwiLFwicmVxdWlyZXNcIjpbXCJ0ZXh0LWZpZWxkXCJdfSxcInRleHQtanVzdGlmeVwiOntcInR5cGVcIjpcImVudW1cIixcImZ1bmN0aW9uXCI6XCJwaWVjZXdpc2UtY29uc3RhbnRcIixcInZhbHVlc1wiOltcImxlZnRcIixcImNlbnRlclwiLFwicmlnaHRcIl0sXCJkZWZhdWx0XCI6XCJjZW50ZXJcIixcInJlcXVpcmVzXCI6W1widGV4dC1maWVsZFwiXX0sXCJ0ZXh0LWFuY2hvclwiOntcInR5cGVcIjpcImVudW1cIixcImZ1bmN0aW9uXCI6XCJwaWVjZXdpc2UtY29uc3RhbnRcIixcInZhbHVlc1wiOltcImNlbnRlclwiLFwibGVmdFwiLFwicmlnaHRcIixcInRvcFwiLFwiYm90dG9tXCIsXCJ0b3AtbGVmdFwiLFwidG9wLXJpZ2h0XCIsXCJib3R0b20tbGVmdFwiLFwiYm90dG9tLXJpZ2h0XCJdLFwiZGVmYXVsdFwiOlwiY2VudGVyXCIsXCJyZXF1aXJlc1wiOltcInRleHQtZmllbGRcIl19LFwidGV4dC1tYXgtYW5nbGVcIjp7XCJ0eXBlXCI6XCJudW1iZXJcIixcImRlZmF1bHRcIjo0NSxcInVuaXRzXCI6XCJkZWdyZWVzXCIsXCJmdW5jdGlvblwiOlwiaW50ZXJwb2xhdGVkXCIsXCJyZXF1aXJlc1wiOltcInRleHQtZmllbGRcIix7XCJzeW1ib2wtcGxhY2VtZW50XCI6XCJsaW5lXCJ9XX0sXCJ0ZXh0LXJvdGF0ZVwiOntcInR5cGVcIjpcIm51bWJlclwiLFwiZGVmYXVsdFwiOjAsXCJwZXJpb2RcIjozNjAsXCJ1bml0c1wiOlwiZGVncmVlc1wiLFwiZnVuY3Rpb25cIjpcImludGVycG9sYXRlZFwiLFwicmVxdWlyZXNcIjpbXCJ0ZXh0LWZpZWxkXCJdfSxcInRleHQtcGFkZGluZ1wiOntcInR5cGVcIjpcIm51bWJlclwiLFwiZGVmYXVsdFwiOjIsXCJtaW5pbXVtXCI6MCxcInVuaXRzXCI6XCJwaXhlbHNcIixcImZ1bmN0aW9uXCI6XCJpbnRlcnBvbGF0ZWRcIixcInJlcXVpcmVzXCI6W1widGV4dC1maWVsZFwiXX0sXCJ0ZXh0LWtlZXAtdXByaWdodFwiOntcInR5cGVcIjpcImJvb2xlYW5cIixcImZ1bmN0aW9uXCI6XCJwaWVjZXdpc2UtY29uc3RhbnRcIixcImRlZmF1bHRcIjp0cnVlLFwicmVxdWlyZXNcIjpbXCJ0ZXh0LWZpZWxkXCIse1widGV4dC1yb3RhdGlvbi1hbGlnbm1lbnRcIjpcIm1hcFwifSx7XCJzeW1ib2wtcGxhY2VtZW50XCI6XCJsaW5lXCJ9XX0sXCJ0ZXh0LXRyYW5zZm9ybVwiOntcInR5cGVcIjpcImVudW1cIixcImZ1bmN0aW9uXCI6XCJwaWVjZXdpc2UtY29uc3RhbnRcIixcInZhbHVlc1wiOltcIm5vbmVcIixcInVwcGVyY2FzZVwiLFwibG93ZXJjYXNlXCJdLFwiZGVmYXVsdFwiOlwibm9uZVwiLFwicmVxdWlyZXNcIjpbXCJ0ZXh0LWZpZWxkXCJdfSxcInRleHQtb2Zmc2V0XCI6e1widHlwZVwiOlwiYXJyYXlcIixcInZhbHVlXCI6XCJudW1iZXJcIixcInVuaXRzXCI6XCJlbXNcIixcImZ1bmN0aW9uXCI6XCJpbnRlcnBvbGF0ZWRcIixcImxlbmd0aFwiOjIsXCJkZWZhdWx0XCI6WzAsMF0sXCJyZXF1aXJlc1wiOltcInRleHQtZmllbGRcIl19LFwidGV4dC1hbGxvdy1vdmVybGFwXCI6e1widHlwZVwiOlwiYm9vbGVhblwiLFwiZnVuY3Rpb25cIjpcInBpZWNld2lzZS1jb25zdGFudFwiLFwiZGVmYXVsdFwiOmZhbHNlLFwicmVxdWlyZXNcIjpbXCJ0ZXh0LWZpZWxkXCJdfSxcInRleHQtaWdub3JlLXBsYWNlbWVudFwiOntcInR5cGVcIjpcImJvb2xlYW5cIixcImZ1bmN0aW9uXCI6XCJwaWVjZXdpc2UtY29uc3RhbnRcIixcImRlZmF1bHRcIjpmYWxzZSxcInJlcXVpcmVzXCI6W1widGV4dC1maWVsZFwiXX0sXCJ0ZXh0LW9wdGlvbmFsXCI6e1widHlwZVwiOlwiYm9vbGVhblwiLFwiZnVuY3Rpb25cIjpcInBpZWNld2lzZS1jb25zdGFudFwiLFwiZGVmYXVsdFwiOmZhbHNlLFwicmVxdWlyZXNcIjpbXCJ0ZXh0LWZpZWxkXCIsXCJpY29uLWltYWdlXCJdfSxcInZpc2liaWxpdHlcIjp7XCJ0eXBlXCI6XCJlbnVtXCIsXCJmdW5jdGlvblwiOlwicGllY2V3aXNlLWNvbnN0YW50XCIsXCJ2YWx1ZXNcIjpbXCJ2aXNpYmxlXCIsXCJub25lXCJdLFwiZGVmYXVsdFwiOlwidmlzaWJsZVwifX0sXCJsYXlvdXRfcmFzdGVyXCI6e1widmlzaWJpbGl0eVwiOntcInR5cGVcIjpcImVudW1cIixcImZ1bmN0aW9uXCI6XCJwaWVjZXdpc2UtY29uc3RhbnRcIixcInZhbHVlc1wiOltcInZpc2libGVcIixcIm5vbmVcIl0sXCJkZWZhdWx0XCI6XCJ2aXNpYmxlXCJ9fSxcImZpbHRlclwiOntcInR5cGVcIjpcImFycmF5XCIsXCJ2YWx1ZVwiOlwiKlwifSxcImZpbHRlcl9vcGVyYXRvclwiOntcInR5cGVcIjpcImVudW1cIixcInZhbHVlc1wiOltcIj09XCIsXCIhPVwiLFwiPlwiLFwiPj1cIixcIjxcIixcIjw9XCIsXCJpblwiLFwiIWluXCIsXCJhbGxcIixcImFueVwiLFwibm9uZVwiXX0sXCJnZW9tZXRyeV90eXBlXCI6e1widHlwZVwiOlwiZW51bVwiLFwidmFsdWVzXCI6W1wiUG9pbnRcIixcIkxpbmVTdHJpbmdcIixcIlBvbHlnb25cIl19LFwiY29sb3Jfb3BlcmF0aW9uXCI6e1widHlwZVwiOlwiZW51bVwiLFwidmFsdWVzXCI6W1wibGlnaHRlblwiLFwic2F0dXJhdGVcIixcInNwaW5cIixcImZhZGVcIixcIm1peFwiXX0sXCJmdW5jdGlvblwiOntcInN0b3BzXCI6e1widHlwZVwiOlwiYXJyYXlcIixcInJlcXVpcmVkXCI6dHJ1ZSxcInZhbHVlXCI6XCJmdW5jdGlvbl9zdG9wXCJ9LFwiYmFzZVwiOntcInR5cGVcIjpcIm51bWJlclwiLFwiZGVmYXVsdFwiOjEsXCJtaW5pbXVtXCI6MH19LFwiZnVuY3Rpb25fc3RvcFwiOntcInR5cGVcIjpcImFycmF5XCIsXCJtaW5pbXVtXCI6MCxcIm1heGltdW1cIjoyMixcInZhbHVlXCI6W1wibnVtYmVyXCIsXCJjb2xvclwiXSxcImxlbmd0aFwiOjJ9LFwicGFpbnRcIjpbXCJwYWludF9maWxsXCIsXCJwYWludF9saW5lXCIsXCJwYWludF9jaXJjbGVcIixcInBhaW50X3N5bWJvbFwiLFwicGFpbnRfcmFzdGVyXCIsXCJwYWludF9iYWNrZ3JvdW5kXCJdLFwicGFpbnRfZmlsbFwiOntcImZpbGwtYW50aWFsaWFzXCI6e1widHlwZVwiOlwiYm9vbGVhblwiLFwiZnVuY3Rpb25cIjpcInBpZWNld2lzZS1jb25zdGFudFwiLFwiZGVmYXVsdFwiOnRydWV9LFwiZmlsbC1vcGFjaXR5XCI6e1widHlwZVwiOlwibnVtYmVyXCIsXCJmdW5jdGlvblwiOlwiaW50ZXJwb2xhdGVkXCIsXCJkZWZhdWx0XCI6MSxcIm1pbmltdW1cIjowLFwibWF4aW11bVwiOjEsXCJ0cmFuc2l0aW9uXCI6dHJ1ZX0sXCJmaWxsLWNvbG9yXCI6e1widHlwZVwiOlwiY29sb3JcIixcImRlZmF1bHRcIjpcIiMwMDAwMDBcIixcImZ1bmN0aW9uXCI6XCJpbnRlcnBvbGF0ZWRcIixcInRyYW5zaXRpb25cIjp0cnVlLFwicmVxdWlyZXNcIjpbe1wiIVwiOlwiZmlsbC1wYXR0ZXJuXCJ9XX0sXCJmaWxsLW91dGxpbmUtY29sb3JcIjp7XCJ0eXBlXCI6XCJjb2xvclwiLFwiZnVuY3Rpb25cIjpcImludGVycG9sYXRlZFwiLFwidHJhbnNpdGlvblwiOnRydWUsXCJyZXF1aXJlc1wiOlt7XCIhXCI6XCJmaWxsLXBhdHRlcm5cIn0se1wiZmlsbC1hbnRpYWxpYXNcIjp0cnVlfV19LFwiZmlsbC10cmFuc2xhdGVcIjp7XCJ0eXBlXCI6XCJhcnJheVwiLFwidmFsdWVcIjpcIm51bWJlclwiLFwibGVuZ3RoXCI6MixcImRlZmF1bHRcIjpbMCwwXSxcImZ1bmN0aW9uXCI6XCJpbnRlcnBvbGF0ZWRcIixcInRyYW5zaXRpb25cIjp0cnVlLFwidW5pdHNcIjpcInBpeGVsc1wifSxcImZpbGwtdHJhbnNsYXRlLWFuY2hvclwiOntcInR5cGVcIjpcImVudW1cIixcImZ1bmN0aW9uXCI6XCJwaWVjZXdpc2UtY29uc3RhbnRcIixcInZhbHVlc1wiOltcIm1hcFwiLFwidmlld3BvcnRcIl0sXCJkZWZhdWx0XCI6XCJtYXBcIixcInJlcXVpcmVzXCI6W1wiZmlsbC10cmFuc2xhdGVcIl19LFwiZmlsbC1wYXR0ZXJuXCI6e1widHlwZVwiOlwic3RyaW5nXCIsXCJmdW5jdGlvblwiOlwicGllY2V3aXNlLWNvbnN0YW50XCIsXCJ0cmFuc2l0aW9uXCI6dHJ1ZX19LFwicGFpbnRfbGluZVwiOntcImxpbmUtb3BhY2l0eVwiOntcInR5cGVcIjpcIm51bWJlclwiLFwiZnVuY3Rpb25cIjpcImludGVycG9sYXRlZFwiLFwiZGVmYXVsdFwiOjEsXCJtaW5pbXVtXCI6MCxcIm1heGltdW1cIjoxLFwidHJhbnNpdGlvblwiOnRydWV9LFwibGluZS1jb2xvclwiOntcInR5cGVcIjpcImNvbG9yXCIsXCJkZWZhdWx0XCI6XCIjMDAwMDAwXCIsXCJmdW5jdGlvblwiOlwiaW50ZXJwb2xhdGVkXCIsXCJ0cmFuc2l0aW9uXCI6dHJ1ZSxcInJlcXVpcmVzXCI6W3tcIiFcIjpcImxpbmUtcGF0dGVyblwifV19LFwibGluZS10cmFuc2xhdGVcIjp7XCJ0eXBlXCI6XCJhcnJheVwiLFwidmFsdWVcIjpcIm51bWJlclwiLFwibGVuZ3RoXCI6MixcImRlZmF1bHRcIjpbMCwwXSxcImZ1bmN0aW9uXCI6XCJpbnRlcnBvbGF0ZWRcIixcInRyYW5zaXRpb25cIjp0cnVlLFwidW5pdHNcIjpcInBpeGVsc1wifSxcImxpbmUtdHJhbnNsYXRlLWFuY2hvclwiOntcInR5cGVcIjpcImVudW1cIixcImZ1bmN0aW9uXCI6XCJwaWVjZXdpc2UtY29uc3RhbnRcIixcInZhbHVlc1wiOltcIm1hcFwiLFwidmlld3BvcnRcIl0sXCJkZWZhdWx0XCI6XCJtYXBcIixcInJlcXVpcmVzXCI6W1wibGluZS10cmFuc2xhdGVcIl19LFwibGluZS13aWR0aFwiOntcInR5cGVcIjpcIm51bWJlclwiLFwiZGVmYXVsdFwiOjEsXCJtaW5pbXVtXCI6MCxcImZ1bmN0aW9uXCI6XCJpbnRlcnBvbGF0ZWRcIixcInRyYW5zaXRpb25cIjp0cnVlLFwidW5pdHNcIjpcInBpeGVsc1wifSxcImxpbmUtZ2FwLXdpZHRoXCI6e1widHlwZVwiOlwibnVtYmVyXCIsXCJkZWZhdWx0XCI6MCxcIm1pbmltdW1cIjowLFwiZnVuY3Rpb25cIjpcImludGVycG9sYXRlZFwiLFwidHJhbnNpdGlvblwiOnRydWUsXCJ1bml0c1wiOlwicGl4ZWxzXCJ9LFwibGluZS1vZmZzZXRcIjp7XCJ0eXBlXCI6XCJudW1iZXJcIixcImRlZmF1bHRcIjowLFwiZnVuY3Rpb25cIjpcImludGVycG9sYXRlZFwiLFwidHJhbnNpdGlvblwiOnRydWUsXCJ1bml0c1wiOlwicGl4ZWxzXCJ9LFwibGluZS1ibHVyXCI6e1widHlwZVwiOlwibnVtYmVyXCIsXCJkZWZhdWx0XCI6MCxcIm1pbmltdW1cIjowLFwiZnVuY3Rpb25cIjpcImludGVycG9sYXRlZFwiLFwidHJhbnNpdGlvblwiOnRydWUsXCJ1bml0c1wiOlwicGl4ZWxzXCJ9LFwibGluZS1kYXNoYXJyYXlcIjp7XCJ0eXBlXCI6XCJhcnJheVwiLFwidmFsdWVcIjpcIm51bWJlclwiLFwiZnVuY3Rpb25cIjpcInBpZWNld2lzZS1jb25zdGFudFwiLFwibWluaW11bVwiOjAsXCJ0cmFuc2l0aW9uXCI6dHJ1ZSxcInVuaXRzXCI6XCJsaW5lIHdpZHRoc1wiLFwicmVxdWlyZXNcIjpbe1wiIVwiOlwibGluZS1wYXR0ZXJuXCJ9XX0sXCJsaW5lLXBhdHRlcm5cIjp7XCJ0eXBlXCI6XCJzdHJpbmdcIixcImZ1bmN0aW9uXCI6XCJwaWVjZXdpc2UtY29uc3RhbnRcIixcInRyYW5zaXRpb25cIjp0cnVlfX0sXCJwYWludF9jaXJjbGVcIjp7XCJjaXJjbGUtcmFkaXVzXCI6e1widHlwZVwiOlwibnVtYmVyXCIsXCJkZWZhdWx0XCI6NSxcIm1pbmltdW1cIjowLFwiZnVuY3Rpb25cIjpcImludGVycG9sYXRlZFwiLFwidHJhbnNpdGlvblwiOnRydWUsXCJ1bml0c1wiOlwicGl4ZWxzXCJ9LFwiY2lyY2xlLWNvbG9yXCI6e1widHlwZVwiOlwiY29sb3JcIixcImRlZmF1bHRcIjpcIiMwMDAwMDBcIixcImZ1bmN0aW9uXCI6XCJpbnRlcnBvbGF0ZWRcIixcInRyYW5zaXRpb25cIjp0cnVlfSxcImNpcmNsZS1ibHVyXCI6e1widHlwZVwiOlwibnVtYmVyXCIsXCJkZWZhdWx0XCI6MCxcImZ1bmN0aW9uXCI6XCJpbnRlcnBvbGF0ZWRcIixcInRyYW5zaXRpb25cIjp0cnVlfSxcImNpcmNsZS1vcGFjaXR5XCI6e1widHlwZVwiOlwibnVtYmVyXCIsXCJkZWZhdWx0XCI6MSxcIm1pbmltdW1cIjowLFwibWF4aW11bVwiOjEsXCJmdW5jdGlvblwiOlwiaW50ZXJwb2xhdGVkXCIsXCJ0cmFuc2l0aW9uXCI6dHJ1ZX0sXCJjaXJjbGUtdHJhbnNsYXRlXCI6e1widHlwZVwiOlwiYXJyYXlcIixcInZhbHVlXCI6XCJudW1iZXJcIixcImxlbmd0aFwiOjIsXCJkZWZhdWx0XCI6WzAsMF0sXCJmdW5jdGlvblwiOlwiaW50ZXJwb2xhdGVkXCIsXCJ0cmFuc2l0aW9uXCI6dHJ1ZSxcInVuaXRzXCI6XCJwaXhlbHNcIn0sXCJjaXJjbGUtdHJhbnNsYXRlLWFuY2hvclwiOntcInR5cGVcIjpcImVudW1cIixcImZ1bmN0aW9uXCI6XCJwaWVjZXdpc2UtY29uc3RhbnRcIixcInZhbHVlc1wiOltcIm1hcFwiLFwidmlld3BvcnRcIl0sXCJkZWZhdWx0XCI6XCJtYXBcIixcInJlcXVpcmVzXCI6W1wiY2lyY2xlLXRyYW5zbGF0ZVwiXX19LFwicGFpbnRfc3ltYm9sXCI6e1wiaWNvbi1vcGFjaXR5XCI6e1widHlwZVwiOlwibnVtYmVyXCIsXCJkZWZhdWx0XCI6MSxcIm1pbmltdW1cIjowLFwibWF4aW11bVwiOjEsXCJmdW5jdGlvblwiOlwiaW50ZXJwb2xhdGVkXCIsXCJ0cmFuc2l0aW9uXCI6dHJ1ZSxcInJlcXVpcmVzXCI6W1wiaWNvbi1pbWFnZVwiXX0sXCJpY29uLWNvbG9yXCI6e1widHlwZVwiOlwiY29sb3JcIixcImRlZmF1bHRcIjpcIiMwMDAwMDBcIixcImZ1bmN0aW9uXCI6XCJpbnRlcnBvbGF0ZWRcIixcInRyYW5zaXRpb25cIjp0cnVlLFwicmVxdWlyZXNcIjpbXCJpY29uLWltYWdlXCJdfSxcImljb24taGFsby1jb2xvclwiOntcInR5cGVcIjpcImNvbG9yXCIsXCJkZWZhdWx0XCI6XCJyZ2JhKDAsIDAsIDAsIDApXCIsXCJmdW5jdGlvblwiOlwiaW50ZXJwb2xhdGVkXCIsXCJ0cmFuc2l0aW9uXCI6dHJ1ZSxcInJlcXVpcmVzXCI6W1wiaWNvbi1pbWFnZVwiXX0sXCJpY29uLWhhbG8td2lkdGhcIjp7XCJ0eXBlXCI6XCJudW1iZXJcIixcImRlZmF1bHRcIjowLFwibWluaW11bVwiOjAsXCJmdW5jdGlvblwiOlwiaW50ZXJwb2xhdGVkXCIsXCJ0cmFuc2l0aW9uXCI6dHJ1ZSxcInVuaXRzXCI6XCJwaXhlbHNcIixcInJlcXVpcmVzXCI6W1wiaWNvbi1pbWFnZVwiXX0sXCJpY29uLWhhbG8tYmx1clwiOntcInR5cGVcIjpcIm51bWJlclwiLFwiZGVmYXVsdFwiOjAsXCJtaW5pbXVtXCI6MCxcImZ1bmN0aW9uXCI6XCJpbnRlcnBvbGF0ZWRcIixcInRyYW5zaXRpb25cIjp0cnVlLFwidW5pdHNcIjpcInBpeGVsc1wiLFwicmVxdWlyZXNcIjpbXCJpY29uLWltYWdlXCJdfSxcImljb24tdHJhbnNsYXRlXCI6e1widHlwZVwiOlwiYXJyYXlcIixcInZhbHVlXCI6XCJudW1iZXJcIixcImxlbmd0aFwiOjIsXCJkZWZhdWx0XCI6WzAsMF0sXCJmdW5jdGlvblwiOlwiaW50ZXJwb2xhdGVkXCIsXCJ0cmFuc2l0aW9uXCI6dHJ1ZSxcInVuaXRzXCI6XCJwaXhlbHNcIixcInJlcXVpcmVzXCI6W1wiaWNvbi1pbWFnZVwiXX0sXCJpY29uLXRyYW5zbGF0ZS1hbmNob3JcIjp7XCJ0eXBlXCI6XCJlbnVtXCIsXCJmdW5jdGlvblwiOlwicGllY2V3aXNlLWNvbnN0YW50XCIsXCJ2YWx1ZXNcIjpbXCJtYXBcIixcInZpZXdwb3J0XCJdLFwiZGVmYXVsdFwiOlwibWFwXCIsXCJyZXF1aXJlc1wiOltcImljb24taW1hZ2VcIixcImljb24tdHJhbnNsYXRlXCJdfSxcInRleHQtb3BhY2l0eVwiOntcInR5cGVcIjpcIm51bWJlclwiLFwiZGVmYXVsdFwiOjEsXCJtaW5pbXVtXCI6MCxcIm1heGltdW1cIjoxLFwiZnVuY3Rpb25cIjpcImludGVycG9sYXRlZFwiLFwidHJhbnNpdGlvblwiOnRydWUsXCJyZXF1aXJlc1wiOltcInRleHQtZmllbGRcIl19LFwidGV4dC1jb2xvclwiOntcInR5cGVcIjpcImNvbG9yXCIsXCJkZWZhdWx0XCI6XCIjMDAwMDAwXCIsXCJmdW5jdGlvblwiOlwiaW50ZXJwb2xhdGVkXCIsXCJ0cmFuc2l0aW9uXCI6dHJ1ZSxcInJlcXVpcmVzXCI6W1widGV4dC1maWVsZFwiXX0sXCJ0ZXh0LWhhbG8tY29sb3JcIjp7XCJ0eXBlXCI6XCJjb2xvclwiLFwiZGVmYXVsdFwiOlwicmdiYSgwLCAwLCAwLCAwKVwiLFwiZnVuY3Rpb25cIjpcImludGVycG9sYXRlZFwiLFwidHJhbnNpdGlvblwiOnRydWUsXCJyZXF1aXJlc1wiOltcInRleHQtZmllbGRcIl19LFwidGV4dC1oYWxvLXdpZHRoXCI6e1widHlwZVwiOlwibnVtYmVyXCIsXCJkZWZhdWx0XCI6MCxcIm1pbmltdW1cIjowLFwiZnVuY3Rpb25cIjpcImludGVycG9sYXRlZFwiLFwidHJhbnNpdGlvblwiOnRydWUsXCJ1bml0c1wiOlwicGl4ZWxzXCIsXCJyZXF1aXJlc1wiOltcInRleHQtZmllbGRcIl19LFwidGV4dC1oYWxvLWJsdXJcIjp7XCJ0eXBlXCI6XCJudW1iZXJcIixcImRlZmF1bHRcIjowLFwibWluaW11bVwiOjAsXCJmdW5jdGlvblwiOlwiaW50ZXJwb2xhdGVkXCIsXCJ0cmFuc2l0aW9uXCI6dHJ1ZSxcInVuaXRzXCI6XCJwaXhlbHNcIixcInJlcXVpcmVzXCI6W1widGV4dC1maWVsZFwiXX0sXCJ0ZXh0LXRyYW5zbGF0ZVwiOntcInR5cGVcIjpcImFycmF5XCIsXCJ2YWx1ZVwiOlwibnVtYmVyXCIsXCJsZW5ndGhcIjoyLFwiZGVmYXVsdFwiOlswLDBdLFwiZnVuY3Rpb25cIjpcImludGVycG9sYXRlZFwiLFwidHJhbnNpdGlvblwiOnRydWUsXCJ1bml0c1wiOlwicGl4ZWxzXCIsXCJyZXF1aXJlc1wiOltcInRleHQtZmllbGRcIl19LFwidGV4dC10cmFuc2xhdGUtYW5jaG9yXCI6e1widHlwZVwiOlwiZW51bVwiLFwiZnVuY3Rpb25cIjpcInBpZWNld2lzZS1jb25zdGFudFwiLFwidmFsdWVzXCI6W1wibWFwXCIsXCJ2aWV3cG9ydFwiXSxcImRlZmF1bHRcIjpcIm1hcFwiLFwicmVxdWlyZXNcIjpbXCJ0ZXh0LWZpZWxkXCIsXCJ0ZXh0LXRyYW5zbGF0ZVwiXX19LFwicGFpbnRfcmFzdGVyXCI6e1wicmFzdGVyLW9wYWNpdHlcIjp7XCJ0eXBlXCI6XCJudW1iZXJcIixcImRlZmF1bHRcIjoxLFwibWluaW11bVwiOjAsXCJtYXhpbXVtXCI6MSxcImZ1bmN0aW9uXCI6XCJpbnRlcnBvbGF0ZWRcIixcInRyYW5zaXRpb25cIjp0cnVlfSxcInJhc3Rlci1odWUtcm90YXRlXCI6e1widHlwZVwiOlwibnVtYmVyXCIsXCJkZWZhdWx0XCI6MCxcInBlcmlvZFwiOjM2MCxcImZ1bmN0aW9uXCI6XCJpbnRlcnBvbGF0ZWRcIixcInRyYW5zaXRpb25cIjp0cnVlLFwidW5pdHNcIjpcImRlZ3JlZXNcIn0sXCJyYXN0ZXItYnJpZ2h0bmVzcy1taW5cIjp7XCJ0eXBlXCI6XCJudW1iZXJcIixcImZ1bmN0aW9uXCI6XCJpbnRlcnBvbGF0ZWRcIixcImRlZmF1bHRcIjowLFwibWluaW11bVwiOjAsXCJtYXhpbXVtXCI6MSxcInRyYW5zaXRpb25cIjp0cnVlfSxcInJhc3Rlci1icmlnaHRuZXNzLW1heFwiOntcInR5cGVcIjpcIm51bWJlclwiLFwiZnVuY3Rpb25cIjpcImludGVycG9sYXRlZFwiLFwiZGVmYXVsdFwiOjEsXCJtaW5pbXVtXCI6MCxcIm1heGltdW1cIjoxLFwidHJhbnNpdGlvblwiOnRydWV9LFwicmFzdGVyLXNhdHVyYXRpb25cIjp7XCJ0eXBlXCI6XCJudW1iZXJcIixcImRlZmF1bHRcIjowLFwibWluaW11bVwiOi0xLFwibWF4aW11bVwiOjEsXCJmdW5jdGlvblwiOlwiaW50ZXJwb2xhdGVkXCIsXCJ0cmFuc2l0aW9uXCI6dHJ1ZX0sXCJyYXN0ZXItY29udHJhc3RcIjp7XCJ0eXBlXCI6XCJudW1iZXJcIixcImRlZmF1bHRcIjowLFwibWluaW11bVwiOi0xLFwibWF4aW11bVwiOjEsXCJmdW5jdGlvblwiOlwiaW50ZXJwb2xhdGVkXCIsXCJ0cmFuc2l0aW9uXCI6dHJ1ZX0sXCJyYXN0ZXItZmFkZS1kdXJhdGlvblwiOntcInR5cGVcIjpcIm51bWJlclwiLFwiZGVmYXVsdFwiOjMwMCxcIm1pbmltdW1cIjowLFwiZnVuY3Rpb25cIjpcImludGVycG9sYXRlZFwiLFwidHJhbnNpdGlvblwiOnRydWUsXCJ1bml0c1wiOlwibWlsbGlzZWNvbmRzXCJ9fSxcInBhaW50X2JhY2tncm91bmRcIjp7XCJiYWNrZ3JvdW5kLWNvbG9yXCI6e1widHlwZVwiOlwiY29sb3JcIixcImRlZmF1bHRcIjpcIiMwMDAwMDBcIixcImZ1bmN0aW9uXCI6XCJpbnRlcnBvbGF0ZWRcIixcInRyYW5zaXRpb25cIjp0cnVlLFwicmVxdWlyZXNcIjpbe1wiIVwiOlwiYmFja2dyb3VuZC1wYXR0ZXJuXCJ9XX0sXCJiYWNrZ3JvdW5kLXBhdHRlcm5cIjp7XCJ0eXBlXCI6XCJzdHJpbmdcIixcImZ1bmN0aW9uXCI6XCJwaWVjZXdpc2UtY29uc3RhbnRcIixcInRyYW5zaXRpb25cIjp0cnVlfSxcImJhY2tncm91bmQtb3BhY2l0eVwiOntcInR5cGVcIjpcIm51bWJlclwiLFwiZGVmYXVsdFwiOjEsXCJtaW5pbXVtXCI6MCxcIm1heGltdW1cIjoxLFwiZnVuY3Rpb25cIjpcImludGVycG9sYXRlZFwiLFwidHJhbnNpdGlvblwiOnRydWV9fSxcInRyYW5zaXRpb25cIjp7XCJkdXJhdGlvblwiOntcInR5cGVcIjpcIm51bWJlclwiLFwiZGVmYXVsdFwiOjMwMCxcIm1pbmltdW1cIjowLFwidW5pdHNcIjpcIm1pbGxpc2Vjb25kc1wifSxcImRlbGF5XCI6e1widHlwZVwiOlwibnVtYmVyXCIsXCJkZWZhdWx0XCI6MCxcIm1pbmltdW1cIjowLFwidW5pdHNcIjpcIm1pbGxpc2Vjb25kc1wifX19IiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyBsaWdodHdlaWdodCBCdWZmZXIgc2hpbSBmb3IgcGJmIGJyb3dzZXIgYnVpbGRcbi8vIGJhc2VkIG9uIGNvZGUgZnJvbSBnaXRodWIuY29tL2Zlcm9zcy9idWZmZXIgKE1JVC1saWNlbnNlZClcblxubW9kdWxlLmV4cG9ydHMgPSBCdWZmZXI7XG5cbnZhciBpZWVlNzU0ID0gcmVxdWlyZSgnaWVlZTc1NCcpO1xuXG52YXIgQnVmZmVyTWV0aG9kcztcblxuZnVuY3Rpb24gQnVmZmVyKGxlbmd0aCkge1xuICAgIHZhciBhcnI7XG4gICAgaWYgKGxlbmd0aCAmJiBsZW5ndGgubGVuZ3RoKSB7XG4gICAgICAgIGFyciA9IGxlbmd0aDtcbiAgICAgICAgbGVuZ3RoID0gYXJyLmxlbmd0aDtcbiAgICB9XG4gICAgdmFyIGJ1ZiA9IG5ldyBVaW50OEFycmF5KGxlbmd0aCB8fCAwKTtcbiAgICBpZiAoYXJyKSBidWYuc2V0KGFycik7XG5cbiAgICBidWYucmVhZFVJbnQzMkxFID0gQnVmZmVyTWV0aG9kcy5yZWFkVUludDMyTEU7XG4gICAgYnVmLndyaXRlVUludDMyTEUgPSBCdWZmZXJNZXRob2RzLndyaXRlVUludDMyTEU7XG4gICAgYnVmLnJlYWRJbnQzMkxFID0gQnVmZmVyTWV0aG9kcy5yZWFkSW50MzJMRTtcbiAgICBidWYud3JpdGVJbnQzMkxFID0gQnVmZmVyTWV0aG9kcy53cml0ZUludDMyTEU7XG4gICAgYnVmLnJlYWRGbG9hdExFID0gQnVmZmVyTWV0aG9kcy5yZWFkRmxvYXRMRTtcbiAgICBidWYud3JpdGVGbG9hdExFID0gQnVmZmVyTWV0aG9kcy53cml0ZUZsb2F0TEU7XG4gICAgYnVmLnJlYWREb3VibGVMRSA9IEJ1ZmZlck1ldGhvZHMucmVhZERvdWJsZUxFO1xuICAgIGJ1Zi53cml0ZURvdWJsZUxFID0gQnVmZmVyTWV0aG9kcy53cml0ZURvdWJsZUxFO1xuICAgIGJ1Zi50b1N0cmluZyA9IEJ1ZmZlck1ldGhvZHMudG9TdHJpbmc7XG4gICAgYnVmLndyaXRlID0gQnVmZmVyTWV0aG9kcy53cml0ZTtcbiAgICBidWYuc2xpY2UgPSBCdWZmZXJNZXRob2RzLnNsaWNlO1xuICAgIGJ1Zi5jb3B5ID0gQnVmZmVyTWV0aG9kcy5jb3B5O1xuXG4gICAgYnVmLl9pc0J1ZmZlciA9IHRydWU7XG4gICAgcmV0dXJuIGJ1Zjtcbn1cblxudmFyIGxhc3RTdHIsIGxhc3RTdHJFbmNvZGVkO1xuXG5CdWZmZXJNZXRob2RzID0ge1xuICAgIHJlYWRVSW50MzJMRTogZnVuY3Rpb24ocG9zKSB7XG4gICAgICAgIHJldHVybiAoKHRoaXNbcG9zXSkgfFxuICAgICAgICAgICAgKHRoaXNbcG9zICsgMV0gPDwgOCkgfFxuICAgICAgICAgICAgKHRoaXNbcG9zICsgMl0gPDwgMTYpKSArXG4gICAgICAgICAgICAodGhpc1twb3MgKyAzXSAqIDB4MTAwMDAwMCk7XG4gICAgfSxcblxuICAgIHdyaXRlVUludDMyTEU6IGZ1bmN0aW9uKHZhbCwgcG9zKSB7XG4gICAgICAgIHRoaXNbcG9zXSA9IHZhbDtcbiAgICAgICAgdGhpc1twb3MgKyAxXSA9ICh2YWwgPj4+IDgpO1xuICAgICAgICB0aGlzW3BvcyArIDJdID0gKHZhbCA+Pj4gMTYpO1xuICAgICAgICB0aGlzW3BvcyArIDNdID0gKHZhbCA+Pj4gMjQpO1xuICAgIH0sXG5cbiAgICByZWFkSW50MzJMRTogZnVuY3Rpb24ocG9zKSB7XG4gICAgICAgIHJldHVybiAoKHRoaXNbcG9zXSkgfFxuICAgICAgICAgICAgKHRoaXNbcG9zICsgMV0gPDwgOCkgfFxuICAgICAgICAgICAgKHRoaXNbcG9zICsgMl0gPDwgMTYpKSArXG4gICAgICAgICAgICAodGhpc1twb3MgKyAzXSA8PCAyNCk7XG4gICAgfSxcblxuICAgIHJlYWRGbG9hdExFOiAgZnVuY3Rpb24ocG9zKSB7IHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgcG9zLCB0cnVlLCAyMywgNCk7IH0sXG4gICAgcmVhZERvdWJsZUxFOiBmdW5jdGlvbihwb3MpIHsgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBwb3MsIHRydWUsIDUyLCA4KTsgfSxcblxuICAgIHdyaXRlRmxvYXRMRTogIGZ1bmN0aW9uKHZhbCwgcG9zKSB7IHJldHVybiBpZWVlNzU0LndyaXRlKHRoaXMsIHZhbCwgcG9zLCB0cnVlLCAyMywgNCk7IH0sXG4gICAgd3JpdGVEb3VibGVMRTogZnVuY3Rpb24odmFsLCBwb3MpIHsgcmV0dXJuIGllZWU3NTQud3JpdGUodGhpcywgdmFsLCBwb3MsIHRydWUsIDUyLCA4KTsgfSxcblxuICAgIHRvU3RyaW5nOiBmdW5jdGlvbihlbmNvZGluZywgc3RhcnQsIGVuZCkge1xuICAgICAgICB2YXIgc3RyID0gJycsXG4gICAgICAgICAgICB0bXAgPSAnJztcblxuICAgICAgICBzdGFydCA9IHN0YXJ0IHx8IDA7XG4gICAgICAgIGVuZCA9IE1hdGgubWluKHRoaXMubGVuZ3RoLCBlbmQgfHwgdGhpcy5sZW5ndGgpO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgY2ggPSB0aGlzW2ldO1xuICAgICAgICAgICAgaWYgKGNoIDw9IDB4N0YpIHtcbiAgICAgICAgICAgICAgICBzdHIgKz0gZGVjb2RlVVJJQ29tcG9uZW50KHRtcCkgKyBTdHJpbmcuZnJvbUNoYXJDb2RlKGNoKTtcbiAgICAgICAgICAgICAgICB0bXAgPSAnJztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdG1wICs9ICclJyArIGNoLnRvU3RyaW5nKDE2KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHN0ciArPSBkZWNvZGVVUklDb21wb25lbnQodG1wKTtcblxuICAgICAgICByZXR1cm4gc3RyO1xuICAgIH0sXG5cbiAgICB3cml0ZTogZnVuY3Rpb24oc3RyLCBwb3MpIHtcbiAgICAgICAgdmFyIGJ5dGVzID0gc3RyID09PSBsYXN0U3RyID8gbGFzdFN0ckVuY29kZWQgOiBlbmNvZGVTdHJpbmcoc3RyKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdGhpc1twb3MgKyBpXSA9IGJ5dGVzW2ldO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIHNsaWNlOiBmdW5jdGlvbihzdGFydCwgZW5kKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN1YmFycmF5KHN0YXJ0LCBlbmQpO1xuICAgIH0sXG5cbiAgICBjb3B5OiBmdW5jdGlvbihidWYsIHBvcykge1xuICAgICAgICBwb3MgPSBwb3MgfHwgMDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBidWZbcG9zICsgaV0gPSB0aGlzW2ldO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuQnVmZmVyTWV0aG9kcy53cml0ZUludDMyTEUgPSBCdWZmZXJNZXRob2RzLndyaXRlVUludDMyTEU7XG5cbkJ1ZmZlci5ieXRlTGVuZ3RoID0gZnVuY3Rpb24oc3RyKSB7XG4gICAgbGFzdFN0ciA9IHN0cjtcbiAgICBsYXN0U3RyRW5jb2RlZCA9IGVuY29kZVN0cmluZyhzdHIpO1xuICAgIHJldHVybiBsYXN0U3RyRW5jb2RlZC5sZW5ndGg7XG59O1xuXG5CdWZmZXIuaXNCdWZmZXIgPSBmdW5jdGlvbihidWYpIHtcbiAgICByZXR1cm4gISEoYnVmICYmIGJ1Zi5faXNCdWZmZXIpO1xufTtcblxuZnVuY3Rpb24gZW5jb2RlU3RyaW5nKHN0cikge1xuICAgIHZhciBsZW5ndGggPSBzdHIubGVuZ3RoLFxuICAgICAgICBieXRlcyA9IFtdO1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIGMsIGxlYWQ7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBjID0gc3RyLmNoYXJDb2RlQXQoaSk7IC8vIGNvZGUgcG9pbnRcblxuICAgICAgICBpZiAoYyA+IDB4RDdGRiAmJiBjIDwgMHhFMDAwKSB7XG5cbiAgICAgICAgICAgIGlmIChsZWFkKSB7XG4gICAgICAgICAgICAgICAgaWYgKGMgPCAweERDMDApIHtcbiAgICAgICAgICAgICAgICAgICAgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKTtcbiAgICAgICAgICAgICAgICAgICAgbGVhZCA9IGM7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYyA9IGxlYWQgLSAweEQ4MDAgPDwgMTAgfCBjIC0gMHhEQzAwIHwgMHgxMDAwMDtcbiAgICAgICAgICAgICAgICAgICAgbGVhZCA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChjID4gMHhEQkZGIHx8IChpICsgMSA9PT0gbGVuZ3RoKSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKTtcbiAgICAgICAgICAgICAgICBlbHNlIGxlYWQgPSBjO1xuXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfSBlbHNlIGlmIChsZWFkKSB7XG4gICAgICAgICAgICBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpO1xuICAgICAgICAgICAgbGVhZCA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYyA8IDB4ODApIGJ5dGVzLnB1c2goYyk7XG4gICAgICAgIGVsc2UgaWYgKGMgPCAweDgwMCkgYnl0ZXMucHVzaChjID4+IDB4NiB8IDB4QzAsIGMgJiAweDNGIHwgMHg4MCk7XG4gICAgICAgIGVsc2UgaWYgKGMgPCAweDEwMDAwKSBieXRlcy5wdXNoKGMgPj4gMHhDIHwgMHhFMCwgYyA+PiAweDYgJiAweDNGIHwgMHg4MCwgYyAmIDB4M0YgfCAweDgwKTtcbiAgICAgICAgZWxzZSBieXRlcy5wdXNoKGMgPj4gMHgxMiB8IDB4RjAsIGMgPj4gMHhDICYgMHgzRiB8IDB4ODAsIGMgPj4gMHg2ICYgMHgzRiB8IDB4ODAsIGMgJiAweDNGIHwgMHg4MCk7XG4gICAgfVxuICAgIHJldHVybiBieXRlcztcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBQYmY7XG5cbnZhciBCdWZmZXIgPSBnbG9iYWwuQnVmZmVyIHx8IHJlcXVpcmUoJy4vYnVmZmVyJyk7XG5cbmZ1bmN0aW9uIFBiZihidWYpIHtcbiAgICB0aGlzLmJ1ZiA9ICFCdWZmZXIuaXNCdWZmZXIoYnVmKSA/IG5ldyBCdWZmZXIoYnVmIHx8IDApIDogYnVmO1xuICAgIHRoaXMucG9zID0gMDtcbiAgICB0aGlzLmxlbmd0aCA9IHRoaXMuYnVmLmxlbmd0aDtcbn1cblxuUGJmLlZhcmludCAgPSAwOyAvLyB2YXJpbnQ6IGludDMyLCBpbnQ2NCwgdWludDMyLCB1aW50NjQsIHNpbnQzMiwgc2ludDY0LCBib29sLCBlbnVtXG5QYmYuRml4ZWQ2NCA9IDE7IC8vIDY0LWJpdDogZG91YmxlLCBmaXhlZDY0LCBzZml4ZWQ2NFxuUGJmLkJ5dGVzICAgPSAyOyAvLyBsZW5ndGgtZGVsaW1pdGVkOiBzdHJpbmcsIGJ5dGVzLCBlbWJlZGRlZCBtZXNzYWdlcywgcGFja2VkIHJlcGVhdGVkIGZpZWxkc1xuUGJmLkZpeGVkMzIgPSA1OyAvLyAzMi1iaXQ6IGZsb2F0LCBmaXhlZDMyLCBzZml4ZWQzMlxuXG52YXIgU0hJRlRfTEVGVF8zMiA9ICgxIDw8IDE2KSAqICgxIDw8IDE2KSxcbiAgICBTSElGVF9SSUdIVF8zMiA9IDEgLyBTSElGVF9MRUZUXzMyLFxuICAgIFBPV18yXzYzID0gTWF0aC5wb3coMiwgNjMpO1xuXG5QYmYucHJvdG90eXBlID0ge1xuXG4gICAgZGVzdHJveTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuYnVmID0gbnVsbDtcbiAgICB9LFxuXG4gICAgLy8gPT09IFJFQURJTkcgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuICAgIHJlYWRGaWVsZHM6IGZ1bmN0aW9uKHJlYWRGaWVsZCwgcmVzdWx0LCBlbmQpIHtcbiAgICAgICAgZW5kID0gZW5kIHx8IHRoaXMubGVuZ3RoO1xuXG4gICAgICAgIHdoaWxlICh0aGlzLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgdmFyIHZhbCA9IHRoaXMucmVhZFZhcmludCgpLFxuICAgICAgICAgICAgICAgIHRhZyA9IHZhbCA+PiAzLFxuICAgICAgICAgICAgICAgIHN0YXJ0UG9zID0gdGhpcy5wb3M7XG5cbiAgICAgICAgICAgIHJlYWRGaWVsZCh0YWcsIHJlc3VsdCwgdGhpcyk7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLnBvcyA9PT0gc3RhcnRQb3MpIHRoaXMuc2tpcCh2YWwpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcblxuICAgIHJlYWRNZXNzYWdlOiBmdW5jdGlvbihyZWFkRmllbGQsIHJlc3VsdCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZWFkRmllbGRzKHJlYWRGaWVsZCwgcmVzdWx0LCB0aGlzLnJlYWRWYXJpbnQoKSArIHRoaXMucG9zKTtcbiAgICB9LFxuXG4gICAgcmVhZEZpeGVkMzI6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgdmFsID0gdGhpcy5idWYucmVhZFVJbnQzMkxFKHRoaXMucG9zKTtcbiAgICAgICAgdGhpcy5wb3MgKz0gNDtcbiAgICAgICAgcmV0dXJuIHZhbDtcbiAgICB9LFxuXG4gICAgcmVhZFNGaXhlZDMyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHZhbCA9IHRoaXMuYnVmLnJlYWRJbnQzMkxFKHRoaXMucG9zKTtcbiAgICAgICAgdGhpcy5wb3MgKz0gNDtcbiAgICAgICAgcmV0dXJuIHZhbDtcbiAgICB9LFxuXG4gICAgLy8gNjQtYml0IGludCBoYW5kbGluZyBpcyBiYXNlZCBvbiBnaXRodWIuY29tL2Rwdy9ub2RlLWJ1ZmZlci1tb3JlLWludHMgKE1JVC1saWNlbnNlZClcblxuICAgIHJlYWRGaXhlZDY0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHZhbCA9IHRoaXMuYnVmLnJlYWRVSW50MzJMRSh0aGlzLnBvcykgKyB0aGlzLmJ1Zi5yZWFkVUludDMyTEUodGhpcy5wb3MgKyA0KSAqIFNISUZUX0xFRlRfMzI7XG4gICAgICAgIHRoaXMucG9zICs9IDg7XG4gICAgICAgIHJldHVybiB2YWw7XG4gICAgfSxcblxuICAgIHJlYWRTRml4ZWQ2NDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciB2YWwgPSB0aGlzLmJ1Zi5yZWFkVUludDMyTEUodGhpcy5wb3MpICsgdGhpcy5idWYucmVhZEludDMyTEUodGhpcy5wb3MgKyA0KSAqIFNISUZUX0xFRlRfMzI7XG4gICAgICAgIHRoaXMucG9zICs9IDg7XG4gICAgICAgIHJldHVybiB2YWw7XG4gICAgfSxcblxuICAgIHJlYWRGbG9hdDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciB2YWwgPSB0aGlzLmJ1Zi5yZWFkRmxvYXRMRSh0aGlzLnBvcyk7XG4gICAgICAgIHRoaXMucG9zICs9IDQ7XG4gICAgICAgIHJldHVybiB2YWw7XG4gICAgfSxcblxuICAgIHJlYWREb3VibGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgdmFsID0gdGhpcy5idWYucmVhZERvdWJsZUxFKHRoaXMucG9zKTtcbiAgICAgICAgdGhpcy5wb3MgKz0gODtcbiAgICAgICAgcmV0dXJuIHZhbDtcbiAgICB9LFxuXG4gICAgcmVhZFZhcmludDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBidWYgPSB0aGlzLmJ1ZixcbiAgICAgICAgICAgIHZhbCwgYiwgYjAsIGIxLCBiMiwgYjM7XG5cbiAgICAgICAgYjAgPSBidWZbdGhpcy5wb3MrK107IGlmIChiMCA8IDB4ODApIHJldHVybiBiMDsgICAgICAgICAgICAgICAgIGIwID0gYjAgJiAweDdmO1xuICAgICAgICBiMSA9IGJ1Zlt0aGlzLnBvcysrXTsgaWYgKGIxIDwgMHg4MCkgcmV0dXJuIGIwIHwgYjEgPDwgNzsgICAgICAgYjEgPSAoYjEgJiAweDdmKSA8PCA3O1xuICAgICAgICBiMiA9IGJ1Zlt0aGlzLnBvcysrXTsgaWYgKGIyIDwgMHg4MCkgcmV0dXJuIGIwIHwgYjEgfCBiMiA8PCAxNDsgYjIgPSAoYjIgJiAweDdmKSA8PCAxNDtcbiAgICAgICAgYjMgPSBidWZbdGhpcy5wb3MrK107IGlmIChiMyA8IDB4ODApIHJldHVybiBiMCB8IGIxIHwgYjIgfCBiMyA8PCAyMTtcblxuICAgICAgICB2YWwgPSBiMCB8IGIxIHwgYjIgfCAoYjMgJiAweDdmKSA8PCAyMTtcblxuICAgICAgICBiID0gYnVmW3RoaXMucG9zKytdOyB2YWwgKz0gKGIgJiAweDdmKSAqIDB4MTAwMDAwMDA7ICAgICAgICAgaWYgKGIgPCAweDgwKSByZXR1cm4gdmFsO1xuICAgICAgICBiID0gYnVmW3RoaXMucG9zKytdOyB2YWwgKz0gKGIgJiAweDdmKSAqIDB4ODAwMDAwMDAwOyAgICAgICAgaWYgKGIgPCAweDgwKSByZXR1cm4gdmFsO1xuICAgICAgICBiID0gYnVmW3RoaXMucG9zKytdOyB2YWwgKz0gKGIgJiAweDdmKSAqIDB4NDAwMDAwMDAwMDA7ICAgICAgaWYgKGIgPCAweDgwKSByZXR1cm4gdmFsO1xuICAgICAgICBiID0gYnVmW3RoaXMucG9zKytdOyB2YWwgKz0gKGIgJiAweDdmKSAqIDB4MjAwMDAwMDAwMDAwMDsgICAgaWYgKGIgPCAweDgwKSByZXR1cm4gdmFsO1xuICAgICAgICBiID0gYnVmW3RoaXMucG9zKytdOyB2YWwgKz0gKGIgJiAweDdmKSAqIDB4MTAwMDAwMDAwMDAwMDAwOyAgaWYgKGIgPCAweDgwKSByZXR1cm4gdmFsO1xuICAgICAgICBiID0gYnVmW3RoaXMucG9zKytdOyB2YWwgKz0gKGIgJiAweDdmKSAqIDB4ODAwMDAwMDAwMDAwMDAwMDsgaWYgKGIgPCAweDgwKSByZXR1cm4gdmFsO1xuXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgdmFyaW50IG5vdCBtb3JlIHRoYW4gMTAgYnl0ZXMnKTtcbiAgICB9LFxuXG4gICAgcmVhZFZhcmludDY0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHN0YXJ0UG9zID0gdGhpcy5wb3MsXG4gICAgICAgICAgICB2YWwgPSB0aGlzLnJlYWRWYXJpbnQoKTtcblxuICAgICAgICBpZiAodmFsIDwgUE9XXzJfNjMpIHJldHVybiB2YWw7XG5cbiAgICAgICAgdmFyIHBvcyA9IHRoaXMucG9zIC0gMjtcbiAgICAgICAgd2hpbGUgKHRoaXMuYnVmW3Bvc10gPT09IDB4ZmYpIHBvcy0tO1xuICAgICAgICBpZiAocG9zIDwgc3RhcnRQb3MpIHBvcyA9IHN0YXJ0UG9zO1xuXG4gICAgICAgIHZhbCA9IDA7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcG9zIC0gc3RhcnRQb3MgKyAxOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBiID0gfnRoaXMuYnVmW3N0YXJ0UG9zICsgaV0gJiAweDdmO1xuICAgICAgICAgICAgdmFsICs9IGkgPCA0ID8gYiA8PCBpICogNyA6IGIgKiBNYXRoLnBvdygyLCBpICogNyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gLXZhbCAtIDE7XG4gICAgfSxcblxuICAgIHJlYWRTVmFyaW50OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIG51bSA9IHRoaXMucmVhZFZhcmludCgpO1xuICAgICAgICByZXR1cm4gbnVtICUgMiA9PT0gMSA/IChudW0gKyAxKSAvIC0yIDogbnVtIC8gMjsgLy8gemlnemFnIGVuY29kaW5nXG4gICAgfSxcblxuICAgIHJlYWRCb29sZWFuOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIEJvb2xlYW4odGhpcy5yZWFkVmFyaW50KCkpO1xuICAgIH0sXG5cbiAgICByZWFkU3RyaW5nOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGVuZCA9IHRoaXMucmVhZFZhcmludCgpICsgdGhpcy5wb3MsXG4gICAgICAgICAgICBzdHIgPSB0aGlzLmJ1Zi50b1N0cmluZygndXRmOCcsIHRoaXMucG9zLCBlbmQpO1xuICAgICAgICB0aGlzLnBvcyA9IGVuZDtcbiAgICAgICAgcmV0dXJuIHN0cjtcbiAgICB9LFxuXG4gICAgcmVhZEJ5dGVzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGVuZCA9IHRoaXMucmVhZFZhcmludCgpICsgdGhpcy5wb3MsXG4gICAgICAgICAgICBidWZmZXIgPSB0aGlzLmJ1Zi5zbGljZSh0aGlzLnBvcywgZW5kKTtcbiAgICAgICAgdGhpcy5wb3MgPSBlbmQ7XG4gICAgICAgIHJldHVybiBidWZmZXI7XG4gICAgfSxcblxuICAgIC8vIHZlcmJvc2UgZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnM7IGRvZXNuJ3QgYWZmZWN0IGd6aXBwZWQgc2l6ZVxuXG4gICAgcmVhZFBhY2tlZFZhcmludDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBlbmQgPSB0aGlzLnJlYWRWYXJpbnQoKSArIHRoaXMucG9zLCBhcnIgPSBbXTtcbiAgICAgICAgd2hpbGUgKHRoaXMucG9zIDwgZW5kKSBhcnIucHVzaCh0aGlzLnJlYWRWYXJpbnQoKSk7XG4gICAgICAgIHJldHVybiBhcnI7XG4gICAgfSxcbiAgICByZWFkUGFja2VkU1ZhcmludDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBlbmQgPSB0aGlzLnJlYWRWYXJpbnQoKSArIHRoaXMucG9zLCBhcnIgPSBbXTtcbiAgICAgICAgd2hpbGUgKHRoaXMucG9zIDwgZW5kKSBhcnIucHVzaCh0aGlzLnJlYWRTVmFyaW50KCkpO1xuICAgICAgICByZXR1cm4gYXJyO1xuICAgIH0sXG4gICAgcmVhZFBhY2tlZEJvb2xlYW46IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgZW5kID0gdGhpcy5yZWFkVmFyaW50KCkgKyB0aGlzLnBvcywgYXJyID0gW107XG4gICAgICAgIHdoaWxlICh0aGlzLnBvcyA8IGVuZCkgYXJyLnB1c2godGhpcy5yZWFkQm9vbGVhbigpKTtcbiAgICAgICAgcmV0dXJuIGFycjtcbiAgICB9LFxuICAgIHJlYWRQYWNrZWRGbG9hdDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBlbmQgPSB0aGlzLnJlYWRWYXJpbnQoKSArIHRoaXMucG9zLCBhcnIgPSBbXTtcbiAgICAgICAgd2hpbGUgKHRoaXMucG9zIDwgZW5kKSBhcnIucHVzaCh0aGlzLnJlYWRGbG9hdCgpKTtcbiAgICAgICAgcmV0dXJuIGFycjtcbiAgICB9LFxuICAgIHJlYWRQYWNrZWREb3VibGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgZW5kID0gdGhpcy5yZWFkVmFyaW50KCkgKyB0aGlzLnBvcywgYXJyID0gW107XG4gICAgICAgIHdoaWxlICh0aGlzLnBvcyA8IGVuZCkgYXJyLnB1c2godGhpcy5yZWFkRG91YmxlKCkpO1xuICAgICAgICByZXR1cm4gYXJyO1xuICAgIH0sXG4gICAgcmVhZFBhY2tlZEZpeGVkMzI6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgZW5kID0gdGhpcy5yZWFkVmFyaW50KCkgKyB0aGlzLnBvcywgYXJyID0gW107XG4gICAgICAgIHdoaWxlICh0aGlzLnBvcyA8IGVuZCkgYXJyLnB1c2godGhpcy5yZWFkRml4ZWQzMigpKTtcbiAgICAgICAgcmV0dXJuIGFycjtcbiAgICB9LFxuICAgIHJlYWRQYWNrZWRTRml4ZWQzMjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBlbmQgPSB0aGlzLnJlYWRWYXJpbnQoKSArIHRoaXMucG9zLCBhcnIgPSBbXTtcbiAgICAgICAgd2hpbGUgKHRoaXMucG9zIDwgZW5kKSBhcnIucHVzaCh0aGlzLnJlYWRTRml4ZWQzMigpKTtcbiAgICAgICAgcmV0dXJuIGFycjtcbiAgICB9LFxuICAgIHJlYWRQYWNrZWRGaXhlZDY0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGVuZCA9IHRoaXMucmVhZFZhcmludCgpICsgdGhpcy5wb3MsIGFyciA9IFtdO1xuICAgICAgICB3aGlsZSAodGhpcy5wb3MgPCBlbmQpIGFyci5wdXNoKHRoaXMucmVhZEZpeGVkNjQoKSk7XG4gICAgICAgIHJldHVybiBhcnI7XG4gICAgfSxcbiAgICByZWFkUGFja2VkU0ZpeGVkNjQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgZW5kID0gdGhpcy5yZWFkVmFyaW50KCkgKyB0aGlzLnBvcywgYXJyID0gW107XG4gICAgICAgIHdoaWxlICh0aGlzLnBvcyA8IGVuZCkgYXJyLnB1c2godGhpcy5yZWFkU0ZpeGVkNjQoKSk7XG4gICAgICAgIHJldHVybiBhcnI7XG4gICAgfSxcblxuICAgIHNraXA6IGZ1bmN0aW9uKHZhbCkge1xuICAgICAgICB2YXIgdHlwZSA9IHZhbCAmIDB4NztcbiAgICAgICAgaWYgKHR5cGUgPT09IFBiZi5WYXJpbnQpIHdoaWxlICh0aGlzLmJ1Zlt0aGlzLnBvcysrXSA+IDB4N2YpIHt9XG4gICAgICAgIGVsc2UgaWYgKHR5cGUgPT09IFBiZi5CeXRlcykgdGhpcy5wb3MgPSB0aGlzLnJlYWRWYXJpbnQoKSArIHRoaXMucG9zO1xuICAgICAgICBlbHNlIGlmICh0eXBlID09PSBQYmYuRml4ZWQzMikgdGhpcy5wb3MgKz0gNDtcbiAgICAgICAgZWxzZSBpZiAodHlwZSA9PT0gUGJmLkZpeGVkNjQpIHRoaXMucG9zICs9IDg7XG4gICAgICAgIGVsc2UgdGhyb3cgbmV3IEVycm9yKCdVbmltcGxlbWVudGVkIHR5cGU6ICcgKyB0eXBlKTtcbiAgICB9LFxuXG4gICAgLy8gPT09IFdSSVRJTkcgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuICAgIHdyaXRlVGFnOiBmdW5jdGlvbih0YWcsIHR5cGUpIHtcbiAgICAgICAgdGhpcy53cml0ZVZhcmludCgodGFnIDw8IDMpIHwgdHlwZSk7XG4gICAgfSxcblxuICAgIHJlYWxsb2M6IGZ1bmN0aW9uKG1pbikge1xuICAgICAgICB2YXIgbGVuZ3RoID0gdGhpcy5sZW5ndGggfHwgMTY7XG5cbiAgICAgICAgd2hpbGUgKGxlbmd0aCA8IHRoaXMucG9zICsgbWluKSBsZW5ndGggKj0gMjtcblxuICAgICAgICBpZiAobGVuZ3RoICE9PSB0aGlzLmxlbmd0aCkge1xuICAgICAgICAgICAgdmFyIGJ1ZiA9IG5ldyBCdWZmZXIobGVuZ3RoKTtcbiAgICAgICAgICAgIHRoaXMuYnVmLmNvcHkoYnVmKTtcbiAgICAgICAgICAgIHRoaXMuYnVmID0gYnVmO1xuICAgICAgICAgICAgdGhpcy5sZW5ndGggPSBsZW5ndGg7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgZmluaXNoOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5sZW5ndGggPSB0aGlzLnBvcztcbiAgICAgICAgdGhpcy5wb3MgPSAwO1xuICAgICAgICByZXR1cm4gdGhpcy5idWYuc2xpY2UoMCwgdGhpcy5sZW5ndGgpO1xuICAgIH0sXG5cbiAgICB3cml0ZUZpeGVkMzI6IGZ1bmN0aW9uKHZhbCkge1xuICAgICAgICB0aGlzLnJlYWxsb2MoNCk7XG4gICAgICAgIHRoaXMuYnVmLndyaXRlVUludDMyTEUodmFsLCB0aGlzLnBvcyk7XG4gICAgICAgIHRoaXMucG9zICs9IDQ7XG4gICAgfSxcblxuICAgIHdyaXRlU0ZpeGVkMzI6IGZ1bmN0aW9uKHZhbCkge1xuICAgICAgICB0aGlzLnJlYWxsb2MoNCk7XG4gICAgICAgIHRoaXMuYnVmLndyaXRlSW50MzJMRSh2YWwsIHRoaXMucG9zKTtcbiAgICAgICAgdGhpcy5wb3MgKz0gNDtcbiAgICB9LFxuXG4gICAgd3JpdGVGaXhlZDY0OiBmdW5jdGlvbih2YWwpIHtcbiAgICAgICAgdGhpcy5yZWFsbG9jKDgpO1xuICAgICAgICB0aGlzLmJ1Zi53cml0ZUludDMyTEUodmFsICYgLTEsIHRoaXMucG9zKTtcbiAgICAgICAgdGhpcy5idWYud3JpdGVVSW50MzJMRShNYXRoLmZsb29yKHZhbCAqIFNISUZUX1JJR0hUXzMyKSwgdGhpcy5wb3MgKyA0KTtcbiAgICAgICAgdGhpcy5wb3MgKz0gODtcbiAgICB9LFxuXG4gICAgd3JpdGVTRml4ZWQ2NDogZnVuY3Rpb24odmFsKSB7XG4gICAgICAgIHRoaXMucmVhbGxvYyg4KTtcbiAgICAgICAgdGhpcy5idWYud3JpdGVJbnQzMkxFKHZhbCAmIC0xLCB0aGlzLnBvcyk7XG4gICAgICAgIHRoaXMuYnVmLndyaXRlSW50MzJMRShNYXRoLmZsb29yKHZhbCAqIFNISUZUX1JJR0hUXzMyKSwgdGhpcy5wb3MgKyA0KTtcbiAgICAgICAgdGhpcy5wb3MgKz0gODtcbiAgICB9LFxuXG4gICAgd3JpdGVWYXJpbnQ6IGZ1bmN0aW9uKHZhbCkge1xuICAgICAgICB2YWwgPSArdmFsO1xuXG4gICAgICAgIGlmICh2YWwgPD0gMHg3Zikge1xuICAgICAgICAgICAgdGhpcy5yZWFsbG9jKDEpO1xuICAgICAgICAgICAgdGhpcy5idWZbdGhpcy5wb3MrK10gPSB2YWw7XG5cbiAgICAgICAgfSBlbHNlIGlmICh2YWwgPD0gMHgzZmZmKSB7XG4gICAgICAgICAgICB0aGlzLnJlYWxsb2MoMik7XG4gICAgICAgICAgICB0aGlzLmJ1Zlt0aGlzLnBvcysrXSA9ICgodmFsID4+PiAwKSAmIDB4N2YpIHwgMHg4MDtcbiAgICAgICAgICAgIHRoaXMuYnVmW3RoaXMucG9zKytdID0gKCh2YWwgPj4+IDcpICYgMHg3Zik7XG5cbiAgICAgICAgfSBlbHNlIGlmICh2YWwgPD0gMHgxZmZmZmYpIHtcbiAgICAgICAgICAgIHRoaXMucmVhbGxvYygzKTtcbiAgICAgICAgICAgIHRoaXMuYnVmW3RoaXMucG9zKytdID0gKCh2YWwgPj4+IDApICYgMHg3ZikgfCAweDgwO1xuICAgICAgICAgICAgdGhpcy5idWZbdGhpcy5wb3MrK10gPSAoKHZhbCA+Pj4gNykgJiAweDdmKSB8IDB4ODA7XG4gICAgICAgICAgICB0aGlzLmJ1Zlt0aGlzLnBvcysrXSA9ICgodmFsID4+PiAxNCkgJiAweDdmKTtcblxuICAgICAgICB9IGVsc2UgaWYgKHZhbCA8PSAweGZmZmZmZmYpIHtcbiAgICAgICAgICAgIHRoaXMucmVhbGxvYyg0KTtcbiAgICAgICAgICAgIHRoaXMuYnVmW3RoaXMucG9zKytdID0gKCh2YWwgPj4+IDApICYgMHg3ZikgfCAweDgwO1xuICAgICAgICAgICAgdGhpcy5idWZbdGhpcy5wb3MrK10gPSAoKHZhbCA+Pj4gNykgJiAweDdmKSB8IDB4ODA7XG4gICAgICAgICAgICB0aGlzLmJ1Zlt0aGlzLnBvcysrXSA9ICgodmFsID4+PiAxNCkgJiAweDdmKSB8IDB4ODA7XG4gICAgICAgICAgICB0aGlzLmJ1Zlt0aGlzLnBvcysrXSA9ICgodmFsID4+PiAyMSkgJiAweDdmKTtcblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIHBvcyA9IHRoaXMucG9zO1xuICAgICAgICAgICAgd2hpbGUgKHZhbCA+PSAweDgwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZWFsbG9jKDEpO1xuICAgICAgICAgICAgICAgIHRoaXMuYnVmW3RoaXMucG9zKytdID0gKHZhbCAmIDB4ZmYpIHwgMHg4MDtcbiAgICAgICAgICAgICAgICB2YWwgLz0gMHg4MDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMucmVhbGxvYygxKTtcbiAgICAgICAgICAgIHRoaXMuYnVmW3RoaXMucG9zKytdID0gdmFsIHwgMDtcbiAgICAgICAgICAgIGlmICh0aGlzLnBvcyAtIHBvcyA+IDEwKSB0aHJvdyBuZXcgRXJyb3IoJ0dpdmVuIHZhcmludCBkb2VzblxcJ3QgZml0IGludG8gMTAgYnl0ZXMnKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICB3cml0ZVNWYXJpbnQ6IGZ1bmN0aW9uKHZhbCkge1xuICAgICAgICB0aGlzLndyaXRlVmFyaW50KHZhbCA8IDAgPyAtdmFsICogMiAtIDEgOiB2YWwgKiAyKTtcbiAgICB9LFxuXG4gICAgd3JpdGVCb29sZWFuOiBmdW5jdGlvbih2YWwpIHtcbiAgICAgICAgdGhpcy53cml0ZVZhcmludChCb29sZWFuKHZhbCkpO1xuICAgIH0sXG5cbiAgICB3cml0ZVN0cmluZzogZnVuY3Rpb24oc3RyKSB7XG4gICAgICAgIHN0ciA9IFN0cmluZyhzdHIpO1xuICAgICAgICB2YXIgYnl0ZXMgPSBCdWZmZXIuYnl0ZUxlbmd0aChzdHIpO1xuICAgICAgICB0aGlzLndyaXRlVmFyaW50KGJ5dGVzKTtcbiAgICAgICAgdGhpcy5yZWFsbG9jKGJ5dGVzKTtcbiAgICAgICAgdGhpcy5idWYud3JpdGUoc3RyLCB0aGlzLnBvcyk7XG4gICAgICAgIHRoaXMucG9zICs9IGJ5dGVzO1xuICAgIH0sXG5cbiAgICB3cml0ZUZsb2F0OiBmdW5jdGlvbih2YWwpIHtcbiAgICAgICAgdGhpcy5yZWFsbG9jKDQpO1xuICAgICAgICB0aGlzLmJ1Zi53cml0ZUZsb2F0TEUodmFsLCB0aGlzLnBvcyk7XG4gICAgICAgIHRoaXMucG9zICs9IDQ7XG4gICAgfSxcblxuICAgIHdyaXRlRG91YmxlOiBmdW5jdGlvbih2YWwpIHtcbiAgICAgICAgdGhpcy5yZWFsbG9jKDgpO1xuICAgICAgICB0aGlzLmJ1Zi53cml0ZURvdWJsZUxFKHZhbCwgdGhpcy5wb3MpO1xuICAgICAgICB0aGlzLnBvcyArPSA4O1xuICAgIH0sXG5cbiAgICB3cml0ZUJ5dGVzOiBmdW5jdGlvbihidWZmZXIpIHtcbiAgICAgICAgdmFyIGxlbiA9IGJ1ZmZlci5sZW5ndGg7XG4gICAgICAgIHRoaXMud3JpdGVWYXJpbnQobGVuKTtcbiAgICAgICAgdGhpcy5yZWFsbG9jKGxlbik7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHRoaXMuYnVmW3RoaXMucG9zKytdID0gYnVmZmVyW2ldO1xuICAgIH0sXG5cbiAgICB3cml0ZVJhd01lc3NhZ2U6IGZ1bmN0aW9uKGZuLCBvYmopIHtcbiAgICAgICAgdGhpcy5wb3MrKzsgLy8gcmVzZXJ2ZSAxIGJ5dGUgZm9yIHNob3J0IG1lc3NhZ2UgbGVuZ3RoXG5cbiAgICAgICAgLy8gd3JpdGUgdGhlIG1lc3NhZ2UgZGlyZWN0bHkgdG8gdGhlIGJ1ZmZlciBhbmQgc2VlIGhvdyBtdWNoIHdhcyB3cml0dGVuXG4gICAgICAgIHZhciBzdGFydFBvcyA9IHRoaXMucG9zO1xuICAgICAgICBmbihvYmosIHRoaXMpO1xuICAgICAgICB2YXIgbGVuID0gdGhpcy5wb3MgLSBzdGFydFBvcztcblxuICAgICAgICB2YXIgdmFyaW50TGVuID1cbiAgICAgICAgICAgIGxlbiA8PSAweDdmID8gMSA6XG4gICAgICAgICAgICBsZW4gPD0gMHgzZmZmID8gMiA6XG4gICAgICAgICAgICBsZW4gPD0gMHgxZmZmZmYgPyAzIDpcbiAgICAgICAgICAgIGxlbiA8PSAweGZmZmZmZmYgPyA0IDogTWF0aC5jZWlsKE1hdGgubG9nKGxlbikgLyAoTWF0aC5MTjIgKiA3KSk7XG5cbiAgICAgICAgLy8gaWYgMSBieXRlIGlzbid0IGVub3VnaCBmb3IgZW5jb2RpbmcgbWVzc2FnZSBsZW5ndGgsIHNoaWZ0IHRoZSBkYXRhIHRvIHRoZSByaWdodFxuICAgICAgICBpZiAodmFyaW50TGVuID4gMSkge1xuICAgICAgICAgICAgdGhpcy5yZWFsbG9jKHZhcmludExlbiAtIDEpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IHRoaXMucG9zIC0gMTsgaSA+PSBzdGFydFBvczsgaS0tKSB0aGlzLmJ1ZltpICsgdmFyaW50TGVuIC0gMV0gPSB0aGlzLmJ1ZltpXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGZpbmFsbHksIHdyaXRlIHRoZSBtZXNzYWdlIGxlbmd0aCBpbiB0aGUgcmVzZXJ2ZWQgcGxhY2UgYW5kIHJlc3RvcmUgdGhlIHBvc2l0aW9uXG4gICAgICAgIHRoaXMucG9zID0gc3RhcnRQb3MgLSAxO1xuICAgICAgICB0aGlzLndyaXRlVmFyaW50KGxlbik7XG4gICAgICAgIHRoaXMucG9zICs9IGxlbjtcbiAgICB9LFxuXG4gICAgd3JpdGVNZXNzYWdlOiBmdW5jdGlvbih0YWcsIGZuLCBvYmopIHtcbiAgICAgICAgdGhpcy53cml0ZVRhZyh0YWcsIFBiZi5CeXRlcyk7XG4gICAgICAgIHRoaXMud3JpdGVSYXdNZXNzYWdlKGZuLCBvYmopO1xuICAgIH0sXG5cbiAgICB3cml0ZVBhY2tlZFZhcmludDogICBmdW5jdGlvbih0YWcsIGFycikgeyB0aGlzLndyaXRlTWVzc2FnZSh0YWcsIHdyaXRlUGFja2VkVmFyaW50LCBhcnIpOyAgIH0sXG4gICAgd3JpdGVQYWNrZWRTVmFyaW50OiAgZnVuY3Rpb24odGFnLCBhcnIpIHsgdGhpcy53cml0ZU1lc3NhZ2UodGFnLCB3cml0ZVBhY2tlZFNWYXJpbnQsIGFycik7ICB9LFxuICAgIHdyaXRlUGFja2VkQm9vbGVhbjogIGZ1bmN0aW9uKHRhZywgYXJyKSB7IHRoaXMud3JpdGVNZXNzYWdlKHRhZywgd3JpdGVQYWNrZWRCb29sZWFuLCBhcnIpOyAgfSxcbiAgICB3cml0ZVBhY2tlZEZsb2F0OiAgICBmdW5jdGlvbih0YWcsIGFycikgeyB0aGlzLndyaXRlTWVzc2FnZSh0YWcsIHdyaXRlUGFja2VkRmxvYXQsIGFycik7ICAgIH0sXG4gICAgd3JpdGVQYWNrZWREb3VibGU6ICAgZnVuY3Rpb24odGFnLCBhcnIpIHsgdGhpcy53cml0ZU1lc3NhZ2UodGFnLCB3cml0ZVBhY2tlZERvdWJsZSwgYXJyKTsgICB9LFxuICAgIHdyaXRlUGFja2VkRml4ZWQzMjogIGZ1bmN0aW9uKHRhZywgYXJyKSB7IHRoaXMud3JpdGVNZXNzYWdlKHRhZywgd3JpdGVQYWNrZWRGaXhlZDMyLCBhcnIpOyAgfSxcbiAgICB3cml0ZVBhY2tlZFNGaXhlZDMyOiBmdW5jdGlvbih0YWcsIGFycikgeyB0aGlzLndyaXRlTWVzc2FnZSh0YWcsIHdyaXRlUGFja2VkU0ZpeGVkMzIsIGFycik7IH0sXG4gICAgd3JpdGVQYWNrZWRGaXhlZDY0OiAgZnVuY3Rpb24odGFnLCBhcnIpIHsgdGhpcy53cml0ZU1lc3NhZ2UodGFnLCB3cml0ZVBhY2tlZEZpeGVkNjQsIGFycik7ICB9LFxuICAgIHdyaXRlUGFja2VkU0ZpeGVkNjQ6IGZ1bmN0aW9uKHRhZywgYXJyKSB7IHRoaXMud3JpdGVNZXNzYWdlKHRhZywgd3JpdGVQYWNrZWRTRml4ZWQ2NCwgYXJyKTsgfSxcblxuICAgIHdyaXRlQnl0ZXNGaWVsZDogZnVuY3Rpb24odGFnLCBidWZmZXIpIHtcbiAgICAgICAgdGhpcy53cml0ZVRhZyh0YWcsIFBiZi5CeXRlcyk7XG4gICAgICAgIHRoaXMud3JpdGVCeXRlcyhidWZmZXIpO1xuICAgIH0sXG4gICAgd3JpdGVGaXhlZDMyRmllbGQ6IGZ1bmN0aW9uKHRhZywgdmFsKSB7XG4gICAgICAgIHRoaXMud3JpdGVUYWcodGFnLCBQYmYuRml4ZWQzMik7XG4gICAgICAgIHRoaXMud3JpdGVGaXhlZDMyKHZhbCk7XG4gICAgfSxcbiAgICB3cml0ZVNGaXhlZDMyRmllbGQ6IGZ1bmN0aW9uKHRhZywgdmFsKSB7XG4gICAgICAgIHRoaXMud3JpdGVUYWcodGFnLCBQYmYuRml4ZWQzMik7XG4gICAgICAgIHRoaXMud3JpdGVTRml4ZWQzMih2YWwpO1xuICAgIH0sXG4gICAgd3JpdGVGaXhlZDY0RmllbGQ6IGZ1bmN0aW9uKHRhZywgdmFsKSB7XG4gICAgICAgIHRoaXMud3JpdGVUYWcodGFnLCBQYmYuRml4ZWQ2NCk7XG4gICAgICAgIHRoaXMud3JpdGVGaXhlZDY0KHZhbCk7XG4gICAgfSxcbiAgICB3cml0ZVNGaXhlZDY0RmllbGQ6IGZ1bmN0aW9uKHRhZywgdmFsKSB7XG4gICAgICAgIHRoaXMud3JpdGVUYWcodGFnLCBQYmYuRml4ZWQ2NCk7XG4gICAgICAgIHRoaXMud3JpdGVTRml4ZWQ2NCh2YWwpO1xuICAgIH0sXG4gICAgd3JpdGVWYXJpbnRGaWVsZDogZnVuY3Rpb24odGFnLCB2YWwpIHtcbiAgICAgICAgdGhpcy53cml0ZVRhZyh0YWcsIFBiZi5WYXJpbnQpO1xuICAgICAgICB0aGlzLndyaXRlVmFyaW50KHZhbCk7XG4gICAgfSxcbiAgICB3cml0ZVNWYXJpbnRGaWVsZDogZnVuY3Rpb24odGFnLCB2YWwpIHtcbiAgICAgICAgdGhpcy53cml0ZVRhZyh0YWcsIFBiZi5WYXJpbnQpO1xuICAgICAgICB0aGlzLndyaXRlU1ZhcmludCh2YWwpO1xuICAgIH0sXG4gICAgd3JpdGVTdHJpbmdGaWVsZDogZnVuY3Rpb24odGFnLCBzdHIpIHtcbiAgICAgICAgdGhpcy53cml0ZVRhZyh0YWcsIFBiZi5CeXRlcyk7XG4gICAgICAgIHRoaXMud3JpdGVTdHJpbmcoc3RyKTtcbiAgICB9LFxuICAgIHdyaXRlRmxvYXRGaWVsZDogZnVuY3Rpb24odGFnLCB2YWwpIHtcbiAgICAgICAgdGhpcy53cml0ZVRhZyh0YWcsIFBiZi5GaXhlZDMyKTtcbiAgICAgICAgdGhpcy53cml0ZUZsb2F0KHZhbCk7XG4gICAgfSxcbiAgICB3cml0ZURvdWJsZUZpZWxkOiBmdW5jdGlvbih0YWcsIHZhbCkge1xuICAgICAgICB0aGlzLndyaXRlVGFnKHRhZywgUGJmLkZpeGVkNjQpO1xuICAgICAgICB0aGlzLndyaXRlRG91YmxlKHZhbCk7XG4gICAgfSxcbiAgICB3cml0ZUJvb2xlYW5GaWVsZDogZnVuY3Rpb24odGFnLCB2YWwpIHtcbiAgICAgICAgdGhpcy53cml0ZVZhcmludEZpZWxkKHRhZywgQm9vbGVhbih2YWwpKTtcbiAgICB9XG59O1xuXG5mdW5jdGlvbiB3cml0ZVBhY2tlZFZhcmludChhcnIsIHBiZikgICB7IGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSBwYmYud3JpdGVWYXJpbnQoYXJyW2ldKTsgICB9XG5mdW5jdGlvbiB3cml0ZVBhY2tlZFNWYXJpbnQoYXJyLCBwYmYpICB7IGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSBwYmYud3JpdGVTVmFyaW50KGFycltpXSk7ICB9XG5mdW5jdGlvbiB3cml0ZVBhY2tlZEZsb2F0KGFyciwgcGJmKSAgICB7IGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSBwYmYud3JpdGVGbG9hdChhcnJbaV0pOyAgICB9XG5mdW5jdGlvbiB3cml0ZVBhY2tlZERvdWJsZShhcnIsIHBiZikgICB7IGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSBwYmYud3JpdGVEb3VibGUoYXJyW2ldKTsgICB9XG5mdW5jdGlvbiB3cml0ZVBhY2tlZEJvb2xlYW4oYXJyLCBwYmYpICB7IGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSBwYmYud3JpdGVCb29sZWFuKGFycltpXSk7ICB9XG5mdW5jdGlvbiB3cml0ZVBhY2tlZEZpeGVkMzIoYXJyLCBwYmYpICB7IGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSBwYmYud3JpdGVGaXhlZDMyKGFycltpXSk7ICB9XG5mdW5jdGlvbiB3cml0ZVBhY2tlZFNGaXhlZDMyKGFyciwgcGJmKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSBwYmYud3JpdGVTRml4ZWQzMihhcnJbaV0pOyB9XG5mdW5jdGlvbiB3cml0ZVBhY2tlZEZpeGVkNjQoYXJyLCBwYmYpICB7IGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSBwYmYud3JpdGVGaXhlZDY0KGFycltpXSk7ICB9XG5mdW5jdGlvbiB3cml0ZVBhY2tlZFNGaXhlZDY0KGFyciwgcGJmKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSBwYmYud3JpdGVTRml4ZWQ2NChhcnJbaV0pOyB9XG4iLCJleHBvcnRzLnJlYWQgPSBmdW5jdGlvbiAoYnVmZmVyLCBvZmZzZXQsIGlzTEUsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgZSwgbVxuICB2YXIgZUxlbiA9IG5CeXRlcyAqIDggLSBtTGVuIC0gMVxuICB2YXIgZU1heCA9ICgxIDw8IGVMZW4pIC0gMVxuICB2YXIgZUJpYXMgPSBlTWF4ID4+IDFcbiAgdmFyIG5CaXRzID0gLTdcbiAgdmFyIGkgPSBpc0xFID8gKG5CeXRlcyAtIDEpIDogMFxuICB2YXIgZCA9IGlzTEUgPyAtMSA6IDFcbiAgdmFyIHMgPSBidWZmZXJbb2Zmc2V0ICsgaV1cblxuICBpICs9IGRcblxuICBlID0gcyAmICgoMSA8PCAoLW5CaXRzKSkgLSAxKVxuICBzID4+PSAoLW5CaXRzKVxuICBuQml0cyArPSBlTGVuXG4gIGZvciAoOyBuQml0cyA+IDA7IGUgPSBlICogMjU2ICsgYnVmZmVyW29mZnNldCArIGldLCBpICs9IGQsIG5CaXRzIC09IDgpIHt9XG5cbiAgbSA9IGUgJiAoKDEgPDwgKC1uQml0cykpIC0gMSlcbiAgZSA+Pj0gKC1uQml0cylcbiAgbkJpdHMgKz0gbUxlblxuICBmb3IgKDsgbkJpdHMgPiAwOyBtID0gbSAqIDI1NiArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KSB7fVxuXG4gIGlmIChlID09PSAwKSB7XG4gICAgZSA9IDEgLSBlQmlhc1xuICB9IGVsc2UgaWYgKGUgPT09IGVNYXgpIHtcbiAgICByZXR1cm4gbSA/IE5hTiA6ICgocyA/IC0xIDogMSkgKiBJbmZpbml0eSlcbiAgfSBlbHNlIHtcbiAgICBtID0gbSArIE1hdGgucG93KDIsIG1MZW4pXG4gICAgZSA9IGUgLSBlQmlhc1xuICB9XG4gIHJldHVybiAocyA/IC0xIDogMSkgKiBtICogTWF0aC5wb3coMiwgZSAtIG1MZW4pXG59XG5cbmV4cG9ydHMud3JpdGUgPSBmdW5jdGlvbiAoYnVmZmVyLCB2YWx1ZSwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHtcbiAgdmFyIGUsIG0sIGNcbiAgdmFyIGVMZW4gPSBuQnl0ZXMgKiA4IC0gbUxlbiAtIDFcbiAgdmFyIGVNYXggPSAoMSA8PCBlTGVuKSAtIDFcbiAgdmFyIGVCaWFzID0gZU1heCA+PiAxXG4gIHZhciBydCA9IChtTGVuID09PSAyMyA/IE1hdGgucG93KDIsIC0yNCkgLSBNYXRoLnBvdygyLCAtNzcpIDogMClcbiAgdmFyIGkgPSBpc0xFID8gMCA6IChuQnl0ZXMgLSAxKVxuICB2YXIgZCA9IGlzTEUgPyAxIDogLTFcbiAgdmFyIHMgPSB2YWx1ZSA8IDAgfHwgKHZhbHVlID09PSAwICYmIDEgLyB2YWx1ZSA8IDApID8gMSA6IDBcblxuICB2YWx1ZSA9IE1hdGguYWJzKHZhbHVlKVxuXG4gIGlmIChpc05hTih2YWx1ZSkgfHwgdmFsdWUgPT09IEluZmluaXR5KSB7XG4gICAgbSA9IGlzTmFOKHZhbHVlKSA/IDEgOiAwXG4gICAgZSA9IGVNYXhcbiAgfSBlbHNlIHtcbiAgICBlID0gTWF0aC5mbG9vcihNYXRoLmxvZyh2YWx1ZSkgLyBNYXRoLkxOMilcbiAgICBpZiAodmFsdWUgKiAoYyA9IE1hdGgucG93KDIsIC1lKSkgPCAxKSB7XG4gICAgICBlLS1cbiAgICAgIGMgKj0gMlxuICAgIH1cbiAgICBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIHZhbHVlICs9IHJ0IC8gY1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZSArPSBydCAqIE1hdGgucG93KDIsIDEgLSBlQmlhcylcbiAgICB9XG4gICAgaWYgKHZhbHVlICogYyA+PSAyKSB7XG4gICAgICBlKytcbiAgICAgIGMgLz0gMlxuICAgIH1cblxuICAgIGlmIChlICsgZUJpYXMgPj0gZU1heCkge1xuICAgICAgbSA9IDBcbiAgICAgIGUgPSBlTWF4XG4gICAgfSBlbHNlIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgbSA9ICh2YWx1ZSAqIGMgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pXG4gICAgICBlID0gZSArIGVCaWFzXG4gICAgfSBlbHNlIHtcbiAgICAgIG0gPSB2YWx1ZSAqIE1hdGgucG93KDIsIGVCaWFzIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKVxuICAgICAgZSA9IDBcbiAgICB9XG4gIH1cblxuICBmb3IgKDsgbUxlbiA+PSA4OyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBtICYgMHhmZiwgaSArPSBkLCBtIC89IDI1NiwgbUxlbiAtPSA4KSB7fVxuXG4gIGUgPSAoZSA8PCBtTGVuKSB8IG1cbiAgZUxlbiArPSBtTGVuXG4gIGZvciAoOyBlTGVuID4gMDsgYnVmZmVyW29mZnNldCArIGldID0gZSAmIDB4ZmYsIGkgKz0gZCwgZSAvPSAyNTYsIGVMZW4gLT0gOCkge31cblxuICBidWZmZXJbb2Zmc2V0ICsgaSAtIGRdIHw9IHMgKiAxMjhcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBQb2ludDtcblxuZnVuY3Rpb24gUG9pbnQoeCwgeSkge1xuICAgIHRoaXMueCA9IHg7XG4gICAgdGhpcy55ID0geTtcbn1cblxuUG9pbnQucHJvdG90eXBlID0ge1xuICAgIGNsb25lOiBmdW5jdGlvbigpIHsgcmV0dXJuIG5ldyBQb2ludCh0aGlzLngsIHRoaXMueSk7IH0sXG5cbiAgICBhZGQ6ICAgICBmdW5jdGlvbihwKSB7IHJldHVybiB0aGlzLmNsb25lKCkuX2FkZChwKTsgICAgIH0sXG4gICAgc3ViOiAgICAgZnVuY3Rpb24ocCkgeyByZXR1cm4gdGhpcy5jbG9uZSgpLl9zdWIocCk7ICAgICB9LFxuICAgIG11bHQ6ICAgIGZ1bmN0aW9uKGspIHsgcmV0dXJuIHRoaXMuY2xvbmUoKS5fbXVsdChrKTsgICAgfSxcbiAgICBkaXY6ICAgICBmdW5jdGlvbihrKSB7IHJldHVybiB0aGlzLmNsb25lKCkuX2RpdihrKTsgICAgIH0sXG4gICAgcm90YXRlOiAgZnVuY3Rpb24oYSkgeyByZXR1cm4gdGhpcy5jbG9uZSgpLl9yb3RhdGUoYSk7ICB9LFxuICAgIG1hdE11bHQ6IGZ1bmN0aW9uKG0pIHsgcmV0dXJuIHRoaXMuY2xvbmUoKS5fbWF0TXVsdChtKTsgfSxcbiAgICB1bml0OiAgICBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMuY2xvbmUoKS5fdW5pdCgpOyB9LFxuICAgIHBlcnA6ICAgIGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5jbG9uZSgpLl9wZXJwKCk7IH0sXG4gICAgcm91bmQ6ICAgZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLmNsb25lKCkuX3JvdW5kKCk7IH0sXG5cbiAgICBtYWc6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gTWF0aC5zcXJ0KHRoaXMueCAqIHRoaXMueCArIHRoaXMueSAqIHRoaXMueSk7XG4gICAgfSxcblxuICAgIGVxdWFsczogZnVuY3Rpb24ocCkge1xuICAgICAgICByZXR1cm4gdGhpcy54ID09PSBwLnggJiZcbiAgICAgICAgICAgICAgIHRoaXMueSA9PT0gcC55O1xuICAgIH0sXG5cbiAgICBkaXN0OiBmdW5jdGlvbihwKSB7XG4gICAgICAgIHJldHVybiBNYXRoLnNxcnQodGhpcy5kaXN0U3FyKHApKTtcbiAgICB9LFxuXG4gICAgZGlzdFNxcjogZnVuY3Rpb24ocCkge1xuICAgICAgICB2YXIgZHggPSBwLnggLSB0aGlzLngsXG4gICAgICAgICAgICBkeSA9IHAueSAtIHRoaXMueTtcbiAgICAgICAgcmV0dXJuIGR4ICogZHggKyBkeSAqIGR5O1xuICAgIH0sXG5cbiAgICBhbmdsZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBNYXRoLmF0YW4yKHRoaXMueSwgdGhpcy54KTtcbiAgICB9LFxuXG4gICAgYW5nbGVUbzogZnVuY3Rpb24oYikge1xuICAgICAgICByZXR1cm4gTWF0aC5hdGFuMih0aGlzLnkgLSBiLnksIHRoaXMueCAtIGIueCk7XG4gICAgfSxcblxuICAgIGFuZ2xlV2l0aDogZnVuY3Rpb24oYikge1xuICAgICAgICByZXR1cm4gdGhpcy5hbmdsZVdpdGhTZXAoYi54LCBiLnkpO1xuICAgIH0sXG5cbiAgICAvLyBGaW5kIHRoZSBhbmdsZSBvZiB0aGUgdHdvIHZlY3RvcnMsIHNvbHZpbmcgdGhlIGZvcm11bGEgZm9yIHRoZSBjcm9zcyBwcm9kdWN0IGEgeCBiID0gfGF8fGJ8c2luKM64KSBmb3IgzrguXG4gICAgYW5nbGVXaXRoU2VwOiBmdW5jdGlvbih4LCB5KSB7XG4gICAgICAgIHJldHVybiBNYXRoLmF0YW4yKFxuICAgICAgICAgICAgdGhpcy54ICogeSAtIHRoaXMueSAqIHgsXG4gICAgICAgICAgICB0aGlzLnggKiB4ICsgdGhpcy55ICogeSk7XG4gICAgfSxcblxuICAgIF9tYXRNdWx0OiBmdW5jdGlvbihtKSB7XG4gICAgICAgIHZhciB4ID0gbVswXSAqIHRoaXMueCArIG1bMV0gKiB0aGlzLnksXG4gICAgICAgICAgICB5ID0gbVsyXSAqIHRoaXMueCArIG1bM10gKiB0aGlzLnk7XG4gICAgICAgIHRoaXMueCA9IHg7XG4gICAgICAgIHRoaXMueSA9IHk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBfYWRkOiBmdW5jdGlvbihwKSB7XG4gICAgICAgIHRoaXMueCArPSBwLng7XG4gICAgICAgIHRoaXMueSArPSBwLnk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBfc3ViOiBmdW5jdGlvbihwKSB7XG4gICAgICAgIHRoaXMueCAtPSBwLng7XG4gICAgICAgIHRoaXMueSAtPSBwLnk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBfbXVsdDogZnVuY3Rpb24oaykge1xuICAgICAgICB0aGlzLnggKj0gaztcbiAgICAgICAgdGhpcy55ICo9IGs7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBfZGl2OiBmdW5jdGlvbihrKSB7XG4gICAgICAgIHRoaXMueCAvPSBrO1xuICAgICAgICB0aGlzLnkgLz0gaztcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIF91bml0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5fZGl2KHRoaXMubWFnKCkpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgX3BlcnA6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgeSA9IHRoaXMueTtcbiAgICAgICAgdGhpcy55ID0gdGhpcy54O1xuICAgICAgICB0aGlzLnggPSAteTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIF9yb3RhdGU6IGZ1bmN0aW9uKGFuZ2xlKSB7XG4gICAgICAgIHZhciBjb3MgPSBNYXRoLmNvcyhhbmdsZSksXG4gICAgICAgICAgICBzaW4gPSBNYXRoLnNpbihhbmdsZSksXG4gICAgICAgICAgICB4ID0gY29zICogdGhpcy54IC0gc2luICogdGhpcy55LFxuICAgICAgICAgICAgeSA9IHNpbiAqIHRoaXMueCArIGNvcyAqIHRoaXMueTtcbiAgICAgICAgdGhpcy54ID0geDtcbiAgICAgICAgdGhpcy55ID0geTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIF9yb3VuZDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMueCA9IE1hdGgucm91bmQodGhpcy54KTtcbiAgICAgICAgdGhpcy55ID0gTWF0aC5yb3VuZCh0aGlzLnkpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG59O1xuXG4vLyBjb25zdHJ1Y3RzIFBvaW50IGZyb20gYW4gYXJyYXkgaWYgbmVjZXNzYXJ5XG5Qb2ludC5jb252ZXJ0ID0gZnVuY3Rpb24gKGEpIHtcbiAgICBpZiAoYSBpbnN0YW5jZW9mIFBvaW50KSB7XG4gICAgICAgIHJldHVybiBhO1xuICAgIH1cbiAgICBpZiAoQXJyYXkuaXNBcnJheShhKSkge1xuICAgICAgICByZXR1cm4gbmV3IFBvaW50KGFbMF0sIGFbMV0pO1xuICAgIH1cbiAgICByZXR1cm4gYTtcbn07XG4iLCIvKlxuIChjKSAyMDE1LCBWbGFkaW1pciBBZ2Fmb25raW5cbiBSQnVzaCwgYSBKYXZhU2NyaXB0IGxpYnJhcnkgZm9yIGhpZ2gtcGVyZm9ybWFuY2UgMkQgc3BhdGlhbCBpbmRleGluZyBvZiBwb2ludHMgYW5kIHJlY3RhbmdsZXMuXG4gaHR0cHM6Ly9naXRodWIuY29tL21vdXJuZXIvcmJ1c2hcbiovXG5cbihmdW5jdGlvbiAoKSB7XG4ndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIHJidXNoKG1heEVudHJpZXMsIGZvcm1hdCkge1xuXG4gICAgLy8ganNoaW50IG5ld2NhcDogZmFsc2UsIHZhbGlkdGhpczogdHJ1ZVxuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiByYnVzaCkpIHJldHVybiBuZXcgcmJ1c2gobWF4RW50cmllcywgZm9ybWF0KTtcblxuICAgIC8vIG1heCBlbnRyaWVzIGluIGEgbm9kZSBpcyA5IGJ5IGRlZmF1bHQ7IG1pbiBub2RlIGZpbGwgaXMgNDAlIGZvciBiZXN0IHBlcmZvcm1hbmNlXG4gICAgdGhpcy5fbWF4RW50cmllcyA9IE1hdGgubWF4KDQsIG1heEVudHJpZXMgfHwgOSk7XG4gICAgdGhpcy5fbWluRW50cmllcyA9IE1hdGgubWF4KDIsIE1hdGguY2VpbCh0aGlzLl9tYXhFbnRyaWVzICogMC40KSk7XG5cbiAgICBpZiAoZm9ybWF0KSB7XG4gICAgICAgIHRoaXMuX2luaXRGb3JtYXQoZm9ybWF0KTtcbiAgICB9XG5cbiAgICB0aGlzLmNsZWFyKCk7XG59XG5cbnJidXNoLnByb3RvdHlwZSA9IHtcblxuICAgIGFsbDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWxsKHRoaXMuZGF0YSwgW10pO1xuICAgIH0sXG5cbiAgICBzZWFyY2g6IGZ1bmN0aW9uIChiYm94KSB7XG5cbiAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmRhdGEsXG4gICAgICAgICAgICByZXN1bHQgPSBbXSxcbiAgICAgICAgICAgIHRvQkJveCA9IHRoaXMudG9CQm94O1xuXG4gICAgICAgIGlmICghaW50ZXJzZWN0cyhiYm94LCBub2RlLmJib3gpKSByZXR1cm4gcmVzdWx0O1xuXG4gICAgICAgIHZhciBub2Rlc1RvU2VhcmNoID0gW10sXG4gICAgICAgICAgICBpLCBsZW4sIGNoaWxkLCBjaGlsZEJCb3g7XG5cbiAgICAgICAgd2hpbGUgKG5vZGUpIHtcbiAgICAgICAgICAgIGZvciAoaSA9IDAsIGxlbiA9IG5vZGUuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblxuICAgICAgICAgICAgICAgIGNoaWxkID0gbm9kZS5jaGlsZHJlbltpXTtcbiAgICAgICAgICAgICAgICBjaGlsZEJCb3ggPSBub2RlLmxlYWYgPyB0b0JCb3goY2hpbGQpIDogY2hpbGQuYmJveDtcblxuICAgICAgICAgICAgICAgIGlmIChpbnRlcnNlY3RzKGJib3gsIGNoaWxkQkJveCkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUubGVhZikgcmVzdWx0LnB1c2goY2hpbGQpO1xuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChjb250YWlucyhiYm94LCBjaGlsZEJCb3gpKSB0aGlzLl9hbGwoY2hpbGQsIHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgIGVsc2Ugbm9kZXNUb1NlYXJjaC5wdXNoKGNoaWxkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBub2RlID0gbm9kZXNUb1NlYXJjaC5wb3AoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcblxuICAgIGNvbGxpZGVzOiBmdW5jdGlvbiAoYmJveCkge1xuXG4gICAgICAgIHZhciBub2RlID0gdGhpcy5kYXRhLFxuICAgICAgICAgICAgdG9CQm94ID0gdGhpcy50b0JCb3g7XG5cbiAgICAgICAgaWYgKCFpbnRlcnNlY3RzKGJib3gsIG5vZGUuYmJveCkpIHJldHVybiBmYWxzZTtcblxuICAgICAgICB2YXIgbm9kZXNUb1NlYXJjaCA9IFtdLFxuICAgICAgICAgICAgaSwgbGVuLCBjaGlsZCwgY2hpbGRCQm94O1xuXG4gICAgICAgIHdoaWxlIChub2RlKSB7XG4gICAgICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSBub2RlLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cbiAgICAgICAgICAgICAgICBjaGlsZCA9IG5vZGUuY2hpbGRyZW5baV07XG4gICAgICAgICAgICAgICAgY2hpbGRCQm94ID0gbm9kZS5sZWFmID8gdG9CQm94KGNoaWxkKSA6IGNoaWxkLmJib3g7XG5cbiAgICAgICAgICAgICAgICBpZiAoaW50ZXJzZWN0cyhiYm94LCBjaGlsZEJCb3gpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChub2RlLmxlYWYgfHwgY29udGFpbnMoYmJveCwgY2hpbGRCQm94KSkgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgIG5vZGVzVG9TZWFyY2gucHVzaChjaGlsZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbm9kZSA9IG5vZGVzVG9TZWFyY2gucG9wKCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcblxuICAgIGxvYWQ6IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIGlmICghKGRhdGEgJiYgZGF0YS5sZW5ndGgpKSByZXR1cm4gdGhpcztcblxuICAgICAgICBpZiAoZGF0YS5sZW5ndGggPCB0aGlzLl9taW5FbnRyaWVzKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gZGF0YS5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIHRoaXMuaW5zZXJ0KGRhdGFbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICAvLyByZWN1cnNpdmVseSBidWlsZCB0aGUgdHJlZSB3aXRoIHRoZSBnaXZlbiBkYXRhIGZyb20gc3RyYXRjaCB1c2luZyBPTVQgYWxnb3JpdGhtXG4gICAgICAgIHZhciBub2RlID0gdGhpcy5fYnVpbGQoZGF0YS5zbGljZSgpLCAwLCBkYXRhLmxlbmd0aCAtIDEsIDApO1xuXG4gICAgICAgIGlmICghdGhpcy5kYXRhLmNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgICAgICAgLy8gc2F2ZSBhcyBpcyBpZiB0cmVlIGlzIGVtcHR5XG4gICAgICAgICAgICB0aGlzLmRhdGEgPSBub2RlO1xuXG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5kYXRhLmhlaWdodCA9PT0gbm9kZS5oZWlnaHQpIHtcbiAgICAgICAgICAgIC8vIHNwbGl0IHJvb3QgaWYgdHJlZXMgaGF2ZSB0aGUgc2FtZSBoZWlnaHRcbiAgICAgICAgICAgIHRoaXMuX3NwbGl0Um9vdCh0aGlzLmRhdGEsIG5vZGUpO1xuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAodGhpcy5kYXRhLmhlaWdodCA8IG5vZGUuaGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgLy8gc3dhcCB0cmVlcyBpZiBpbnNlcnRlZCBvbmUgaXMgYmlnZ2VyXG4gICAgICAgICAgICAgICAgdmFyIHRtcE5vZGUgPSB0aGlzLmRhdGE7XG4gICAgICAgICAgICAgICAgdGhpcy5kYXRhID0gbm9kZTtcbiAgICAgICAgICAgICAgICBub2RlID0gdG1wTm9kZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gaW5zZXJ0IHRoZSBzbWFsbCB0cmVlIGludG8gdGhlIGxhcmdlIHRyZWUgYXQgYXBwcm9wcmlhdGUgbGV2ZWxcbiAgICAgICAgICAgIHRoaXMuX2luc2VydChub2RlLCB0aGlzLmRhdGEuaGVpZ2h0IC0gbm9kZS5oZWlnaHQgLSAxLCB0cnVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBpbnNlcnQ6IGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgIGlmIChpdGVtKSB0aGlzLl9pbnNlcnQoaXRlbSwgdGhpcy5kYXRhLmhlaWdodCAtIDEpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgY2xlYXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5kYXRhID0ge1xuICAgICAgICAgICAgY2hpbGRyZW46IFtdLFxuICAgICAgICAgICAgaGVpZ2h0OiAxLFxuICAgICAgICAgICAgYmJveDogZW1wdHkoKSxcbiAgICAgICAgICAgIGxlYWY6IHRydWVcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIHJlbW92ZTogZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgaWYgKCFpdGVtKSByZXR1cm4gdGhpcztcblxuICAgICAgICB2YXIgbm9kZSA9IHRoaXMuZGF0YSxcbiAgICAgICAgICAgIGJib3ggPSB0aGlzLnRvQkJveChpdGVtKSxcbiAgICAgICAgICAgIHBhdGggPSBbXSxcbiAgICAgICAgICAgIGluZGV4ZXMgPSBbXSxcbiAgICAgICAgICAgIGksIHBhcmVudCwgaW5kZXgsIGdvaW5nVXA7XG5cbiAgICAgICAgLy8gZGVwdGgtZmlyc3QgaXRlcmF0aXZlIHRyZWUgdHJhdmVyc2FsXG4gICAgICAgIHdoaWxlIChub2RlIHx8IHBhdGgubGVuZ3RoKSB7XG5cbiAgICAgICAgICAgIGlmICghbm9kZSkgeyAvLyBnbyB1cFxuICAgICAgICAgICAgICAgIG5vZGUgPSBwYXRoLnBvcCgpO1xuICAgICAgICAgICAgICAgIHBhcmVudCA9IHBhdGhbcGF0aC5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgICAgICBpID0gaW5kZXhlcy5wb3AoKTtcbiAgICAgICAgICAgICAgICBnb2luZ1VwID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG5vZGUubGVhZikgeyAvLyBjaGVjayBjdXJyZW50IG5vZGVcbiAgICAgICAgICAgICAgICBpbmRleCA9IG5vZGUuY2hpbGRyZW4uaW5kZXhPZihpdGVtKTtcblxuICAgICAgICAgICAgICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaXRlbSBmb3VuZCwgcmVtb3ZlIHRoZSBpdGVtIGFuZCBjb25kZW5zZSB0cmVlIHVwd2FyZHNcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5jaGlsZHJlbi5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgICAgICAgICBwYXRoLnB1c2gobm9kZSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2NvbmRlbnNlKHBhdGgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghZ29pbmdVcCAmJiAhbm9kZS5sZWFmICYmIGNvbnRhaW5zKG5vZGUuYmJveCwgYmJveCkpIHsgLy8gZ28gZG93blxuICAgICAgICAgICAgICAgIHBhdGgucHVzaChub2RlKTtcbiAgICAgICAgICAgICAgICBpbmRleGVzLnB1c2goaSk7XG4gICAgICAgICAgICAgICAgaSA9IDA7XG4gICAgICAgICAgICAgICAgcGFyZW50ID0gbm9kZTtcbiAgICAgICAgICAgICAgICBub2RlID0gbm9kZS5jaGlsZHJlblswXTtcblxuICAgICAgICAgICAgfSBlbHNlIGlmIChwYXJlbnQpIHsgLy8gZ28gcmlnaHRcbiAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgICAgbm9kZSA9IHBhcmVudC5jaGlsZHJlbltpXTtcbiAgICAgICAgICAgICAgICBnb2luZ1VwID0gZmFsc2U7XG5cbiAgICAgICAgICAgIH0gZWxzZSBub2RlID0gbnVsbDsgLy8gbm90aGluZyBmb3VuZFxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIHRvQkJveDogZnVuY3Rpb24gKGl0ZW0pIHsgcmV0dXJuIGl0ZW07IH0sXG5cbiAgICBjb21wYXJlTWluWDogZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIGFbMF0gLSBiWzBdOyB9LFxuICAgIGNvbXBhcmVNaW5ZOiBmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gYVsxXSAtIGJbMV07IH0sXG5cbiAgICB0b0pTT046IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuZGF0YTsgfSxcblxuICAgIGZyb21KU09OOiBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgX2FsbDogZnVuY3Rpb24gKG5vZGUsIHJlc3VsdCkge1xuICAgICAgICB2YXIgbm9kZXNUb1NlYXJjaCA9IFtdO1xuICAgICAgICB3aGlsZSAobm9kZSkge1xuICAgICAgICAgICAgaWYgKG5vZGUubGVhZikgcmVzdWx0LnB1c2guYXBwbHkocmVzdWx0LCBub2RlLmNoaWxkcmVuKTtcbiAgICAgICAgICAgIGVsc2Ugbm9kZXNUb1NlYXJjaC5wdXNoLmFwcGx5KG5vZGVzVG9TZWFyY2gsIG5vZGUuY2hpbGRyZW4pO1xuXG4gICAgICAgICAgICBub2RlID0gbm9kZXNUb1NlYXJjaC5wb3AoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG5cbiAgICBfYnVpbGQ6IGZ1bmN0aW9uIChpdGVtcywgbGVmdCwgcmlnaHQsIGhlaWdodCkge1xuXG4gICAgICAgIHZhciBOID0gcmlnaHQgLSBsZWZ0ICsgMSxcbiAgICAgICAgICAgIE0gPSB0aGlzLl9tYXhFbnRyaWVzLFxuICAgICAgICAgICAgbm9kZTtcblxuICAgICAgICBpZiAoTiA8PSBNKSB7XG4gICAgICAgICAgICAvLyByZWFjaGVkIGxlYWYgbGV2ZWw7IHJldHVybiBsZWFmXG4gICAgICAgICAgICBub2RlID0ge1xuICAgICAgICAgICAgICAgIGNoaWxkcmVuOiBpdGVtcy5zbGljZShsZWZ0LCByaWdodCArIDEpLFxuICAgICAgICAgICAgICAgIGhlaWdodDogMSxcbiAgICAgICAgICAgICAgICBiYm94OiBudWxsLFxuICAgICAgICAgICAgICAgIGxlYWY6IHRydWVcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjYWxjQkJveChub2RlLCB0aGlzLnRvQkJveCk7XG4gICAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghaGVpZ2h0KSB7XG4gICAgICAgICAgICAvLyB0YXJnZXQgaGVpZ2h0IG9mIHRoZSBidWxrLWxvYWRlZCB0cmVlXG4gICAgICAgICAgICBoZWlnaHQgPSBNYXRoLmNlaWwoTWF0aC5sb2coTikgLyBNYXRoLmxvZyhNKSk7XG5cbiAgICAgICAgICAgIC8vIHRhcmdldCBudW1iZXIgb2Ygcm9vdCBlbnRyaWVzIHRvIG1heGltaXplIHN0b3JhZ2UgdXRpbGl6YXRpb25cbiAgICAgICAgICAgIE0gPSBNYXRoLmNlaWwoTiAvIE1hdGgucG93KE0sIGhlaWdodCAtIDEpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIG5vZGUgPSB7XG4gICAgICAgICAgICBjaGlsZHJlbjogW10sXG4gICAgICAgICAgICBoZWlnaHQ6IGhlaWdodCxcbiAgICAgICAgICAgIGJib3g6IG51bGwsXG4gICAgICAgICAgICBsZWFmOiBmYWxzZVxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIHNwbGl0IHRoZSBpdGVtcyBpbnRvIE0gbW9zdGx5IHNxdWFyZSB0aWxlc1xuXG4gICAgICAgIHZhciBOMiA9IE1hdGguY2VpbChOIC8gTSksXG4gICAgICAgICAgICBOMSA9IE4yICogTWF0aC5jZWlsKE1hdGguc3FydChNKSksXG4gICAgICAgICAgICBpLCBqLCByaWdodDIsIHJpZ2h0MztcblxuICAgICAgICBtdWx0aVNlbGVjdChpdGVtcywgbGVmdCwgcmlnaHQsIE4xLCB0aGlzLmNvbXBhcmVNaW5YKTtcblxuICAgICAgICBmb3IgKGkgPSBsZWZ0OyBpIDw9IHJpZ2h0OyBpICs9IE4xKSB7XG5cbiAgICAgICAgICAgIHJpZ2h0MiA9IE1hdGgubWluKGkgKyBOMSAtIDEsIHJpZ2h0KTtcblxuICAgICAgICAgICAgbXVsdGlTZWxlY3QoaXRlbXMsIGksIHJpZ2h0MiwgTjIsIHRoaXMuY29tcGFyZU1pblkpO1xuXG4gICAgICAgICAgICBmb3IgKGogPSBpOyBqIDw9IHJpZ2h0MjsgaiArPSBOMikge1xuXG4gICAgICAgICAgICAgICAgcmlnaHQzID0gTWF0aC5taW4oaiArIE4yIC0gMSwgcmlnaHQyKTtcblxuICAgICAgICAgICAgICAgIC8vIHBhY2sgZWFjaCBlbnRyeSByZWN1cnNpdmVseVxuICAgICAgICAgICAgICAgIG5vZGUuY2hpbGRyZW4ucHVzaCh0aGlzLl9idWlsZChpdGVtcywgaiwgcmlnaHQzLCBoZWlnaHQgLSAxKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjYWxjQkJveChub2RlLCB0aGlzLnRvQkJveCk7XG5cbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfSxcblxuICAgIF9jaG9vc2VTdWJ0cmVlOiBmdW5jdGlvbiAoYmJveCwgbm9kZSwgbGV2ZWwsIHBhdGgpIHtcblxuICAgICAgICB2YXIgaSwgbGVuLCBjaGlsZCwgdGFyZ2V0Tm9kZSwgYXJlYSwgZW5sYXJnZW1lbnQsIG1pbkFyZWEsIG1pbkVubGFyZ2VtZW50O1xuXG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICBwYXRoLnB1c2gobm9kZSk7XG5cbiAgICAgICAgICAgIGlmIChub2RlLmxlYWYgfHwgcGF0aC5sZW5ndGggLSAxID09PSBsZXZlbCkgYnJlYWs7XG5cbiAgICAgICAgICAgIG1pbkFyZWEgPSBtaW5FbmxhcmdlbWVudCA9IEluZmluaXR5O1xuXG4gICAgICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSBub2RlLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY2hpbGQgPSBub2RlLmNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgICAgIGFyZWEgPSBiYm94QXJlYShjaGlsZC5iYm94KTtcbiAgICAgICAgICAgICAgICBlbmxhcmdlbWVudCA9IGVubGFyZ2VkQXJlYShiYm94LCBjaGlsZC5iYm94KSAtIGFyZWE7XG5cbiAgICAgICAgICAgICAgICAvLyBjaG9vc2UgZW50cnkgd2l0aCB0aGUgbGVhc3QgYXJlYSBlbmxhcmdlbWVudFxuICAgICAgICAgICAgICAgIGlmIChlbmxhcmdlbWVudCA8IG1pbkVubGFyZ2VtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIG1pbkVubGFyZ2VtZW50ID0gZW5sYXJnZW1lbnQ7XG4gICAgICAgICAgICAgICAgICAgIG1pbkFyZWEgPSBhcmVhIDwgbWluQXJlYSA/IGFyZWEgOiBtaW5BcmVhO1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXROb2RlID0gY2hpbGQ7XG5cbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGVubGFyZ2VtZW50ID09PSBtaW5FbmxhcmdlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBvdGhlcndpc2UgY2hvb3NlIG9uZSB3aXRoIHRoZSBzbWFsbGVzdCBhcmVhXG4gICAgICAgICAgICAgICAgICAgIGlmIChhcmVhIDwgbWluQXJlYSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWluQXJlYSA9IGFyZWE7XG4gICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXROb2RlID0gY2hpbGQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG5vZGUgPSB0YXJnZXROb2RlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfSxcblxuICAgIF9pbnNlcnQ6IGZ1bmN0aW9uIChpdGVtLCBsZXZlbCwgaXNOb2RlKSB7XG5cbiAgICAgICAgdmFyIHRvQkJveCA9IHRoaXMudG9CQm94LFxuICAgICAgICAgICAgYmJveCA9IGlzTm9kZSA/IGl0ZW0uYmJveCA6IHRvQkJveChpdGVtKSxcbiAgICAgICAgICAgIGluc2VydFBhdGggPSBbXTtcblxuICAgICAgICAvLyBmaW5kIHRoZSBiZXN0IG5vZGUgZm9yIGFjY29tbW9kYXRpbmcgdGhlIGl0ZW0sIHNhdmluZyBhbGwgbm9kZXMgYWxvbmcgdGhlIHBhdGggdG9vXG4gICAgICAgIHZhciBub2RlID0gdGhpcy5fY2hvb3NlU3VidHJlZShiYm94LCB0aGlzLmRhdGEsIGxldmVsLCBpbnNlcnRQYXRoKTtcblxuICAgICAgICAvLyBwdXQgdGhlIGl0ZW0gaW50byB0aGUgbm9kZVxuICAgICAgICBub2RlLmNoaWxkcmVuLnB1c2goaXRlbSk7XG4gICAgICAgIGV4dGVuZChub2RlLmJib3gsIGJib3gpO1xuXG4gICAgICAgIC8vIHNwbGl0IG9uIG5vZGUgb3ZlcmZsb3c7IHByb3BhZ2F0ZSB1cHdhcmRzIGlmIG5lY2Vzc2FyeVxuICAgICAgICB3aGlsZSAobGV2ZWwgPj0gMCkge1xuICAgICAgICAgICAgaWYgKGluc2VydFBhdGhbbGV2ZWxdLmNoaWxkcmVuLmxlbmd0aCA+IHRoaXMuX21heEVudHJpZXMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zcGxpdChpbnNlcnRQYXRoLCBsZXZlbCk7XG4gICAgICAgICAgICAgICAgbGV2ZWwtLTtcbiAgICAgICAgICAgIH0gZWxzZSBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGFkanVzdCBiYm94ZXMgYWxvbmcgdGhlIGluc2VydGlvbiBwYXRoXG4gICAgICAgIHRoaXMuX2FkanVzdFBhcmVudEJCb3hlcyhiYm94LCBpbnNlcnRQYXRoLCBsZXZlbCk7XG4gICAgfSxcblxuICAgIC8vIHNwbGl0IG92ZXJmbG93ZWQgbm9kZSBpbnRvIHR3b1xuICAgIF9zcGxpdDogZnVuY3Rpb24gKGluc2VydFBhdGgsIGxldmVsKSB7XG5cbiAgICAgICAgdmFyIG5vZGUgPSBpbnNlcnRQYXRoW2xldmVsXSxcbiAgICAgICAgICAgIE0gPSBub2RlLmNoaWxkcmVuLmxlbmd0aCxcbiAgICAgICAgICAgIG0gPSB0aGlzLl9taW5FbnRyaWVzO1xuXG4gICAgICAgIHRoaXMuX2Nob29zZVNwbGl0QXhpcyhub2RlLCBtLCBNKTtcblxuICAgICAgICB2YXIgc3BsaXRJbmRleCA9IHRoaXMuX2Nob29zZVNwbGl0SW5kZXgobm9kZSwgbSwgTSk7XG5cbiAgICAgICAgdmFyIG5ld05vZGUgPSB7XG4gICAgICAgICAgICBjaGlsZHJlbjogbm9kZS5jaGlsZHJlbi5zcGxpY2Uoc3BsaXRJbmRleCwgbm9kZS5jaGlsZHJlbi5sZW5ndGggLSBzcGxpdEluZGV4KSxcbiAgICAgICAgICAgIGhlaWdodDogbm9kZS5oZWlnaHQsXG4gICAgICAgICAgICBiYm94OiBudWxsLFxuICAgICAgICAgICAgbGVhZjogZmFsc2VcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAobm9kZS5sZWFmKSBuZXdOb2RlLmxlYWYgPSB0cnVlO1xuXG4gICAgICAgIGNhbGNCQm94KG5vZGUsIHRoaXMudG9CQm94KTtcbiAgICAgICAgY2FsY0JCb3gobmV3Tm9kZSwgdGhpcy50b0JCb3gpO1xuXG4gICAgICAgIGlmIChsZXZlbCkgaW5zZXJ0UGF0aFtsZXZlbCAtIDFdLmNoaWxkcmVuLnB1c2gobmV3Tm9kZSk7XG4gICAgICAgIGVsc2UgdGhpcy5fc3BsaXRSb290KG5vZGUsIG5ld05vZGUpO1xuICAgIH0sXG5cbiAgICBfc3BsaXRSb290OiBmdW5jdGlvbiAobm9kZSwgbmV3Tm9kZSkge1xuICAgICAgICAvLyBzcGxpdCByb290IG5vZGVcbiAgICAgICAgdGhpcy5kYXRhID0ge1xuICAgICAgICAgICAgY2hpbGRyZW46IFtub2RlLCBuZXdOb2RlXSxcbiAgICAgICAgICAgIGhlaWdodDogbm9kZS5oZWlnaHQgKyAxLFxuICAgICAgICAgICAgYmJveDogbnVsbCxcbiAgICAgICAgICAgIGxlYWY6IGZhbHNlXG4gICAgICAgIH07XG4gICAgICAgIGNhbGNCQm94KHRoaXMuZGF0YSwgdGhpcy50b0JCb3gpO1xuICAgIH0sXG5cbiAgICBfY2hvb3NlU3BsaXRJbmRleDogZnVuY3Rpb24gKG5vZGUsIG0sIE0pIHtcblxuICAgICAgICB2YXIgaSwgYmJveDEsIGJib3gyLCBvdmVybGFwLCBhcmVhLCBtaW5PdmVybGFwLCBtaW5BcmVhLCBpbmRleDtcblxuICAgICAgICBtaW5PdmVybGFwID0gbWluQXJlYSA9IEluZmluaXR5O1xuXG4gICAgICAgIGZvciAoaSA9IG07IGkgPD0gTSAtIG07IGkrKykge1xuICAgICAgICAgICAgYmJveDEgPSBkaXN0QkJveChub2RlLCAwLCBpLCB0aGlzLnRvQkJveCk7XG4gICAgICAgICAgICBiYm94MiA9IGRpc3RCQm94KG5vZGUsIGksIE0sIHRoaXMudG9CQm94KTtcblxuICAgICAgICAgICAgb3ZlcmxhcCA9IGludGVyc2VjdGlvbkFyZWEoYmJveDEsIGJib3gyKTtcbiAgICAgICAgICAgIGFyZWEgPSBiYm94QXJlYShiYm94MSkgKyBiYm94QXJlYShiYm94Mik7XG5cbiAgICAgICAgICAgIC8vIGNob29zZSBkaXN0cmlidXRpb24gd2l0aCBtaW5pbXVtIG92ZXJsYXBcbiAgICAgICAgICAgIGlmIChvdmVybGFwIDwgbWluT3ZlcmxhcCkge1xuICAgICAgICAgICAgICAgIG1pbk92ZXJsYXAgPSBvdmVybGFwO1xuICAgICAgICAgICAgICAgIGluZGV4ID0gaTtcblxuICAgICAgICAgICAgICAgIG1pbkFyZWEgPSBhcmVhIDwgbWluQXJlYSA/IGFyZWEgOiBtaW5BcmVhO1xuXG4gICAgICAgICAgICB9IGVsc2UgaWYgKG92ZXJsYXAgPT09IG1pbk92ZXJsYXApIHtcbiAgICAgICAgICAgICAgICAvLyBvdGhlcndpc2UgY2hvb3NlIGRpc3RyaWJ1dGlvbiB3aXRoIG1pbmltdW0gYXJlYVxuICAgICAgICAgICAgICAgIGlmIChhcmVhIDwgbWluQXJlYSkge1xuICAgICAgICAgICAgICAgICAgICBtaW5BcmVhID0gYXJlYTtcbiAgICAgICAgICAgICAgICAgICAgaW5kZXggPSBpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBpbmRleDtcbiAgICB9LFxuXG4gICAgLy8gc29ydHMgbm9kZSBjaGlsZHJlbiBieSB0aGUgYmVzdCBheGlzIGZvciBzcGxpdFxuICAgIF9jaG9vc2VTcGxpdEF4aXM6IGZ1bmN0aW9uIChub2RlLCBtLCBNKSB7XG5cbiAgICAgICAgdmFyIGNvbXBhcmVNaW5YID0gbm9kZS5sZWFmID8gdGhpcy5jb21wYXJlTWluWCA6IGNvbXBhcmVOb2RlTWluWCxcbiAgICAgICAgICAgIGNvbXBhcmVNaW5ZID0gbm9kZS5sZWFmID8gdGhpcy5jb21wYXJlTWluWSA6IGNvbXBhcmVOb2RlTWluWSxcbiAgICAgICAgICAgIHhNYXJnaW4gPSB0aGlzLl9hbGxEaXN0TWFyZ2luKG5vZGUsIG0sIE0sIGNvbXBhcmVNaW5YKSxcbiAgICAgICAgICAgIHlNYXJnaW4gPSB0aGlzLl9hbGxEaXN0TWFyZ2luKG5vZGUsIG0sIE0sIGNvbXBhcmVNaW5ZKTtcblxuICAgICAgICAvLyBpZiB0b3RhbCBkaXN0cmlidXRpb25zIG1hcmdpbiB2YWx1ZSBpcyBtaW5pbWFsIGZvciB4LCBzb3J0IGJ5IG1pblgsXG4gICAgICAgIC8vIG90aGVyd2lzZSBpdCdzIGFscmVhZHkgc29ydGVkIGJ5IG1pbllcbiAgICAgICAgaWYgKHhNYXJnaW4gPCB5TWFyZ2luKSBub2RlLmNoaWxkcmVuLnNvcnQoY29tcGFyZU1pblgpO1xuICAgIH0sXG5cbiAgICAvLyB0b3RhbCBtYXJnaW4gb2YgYWxsIHBvc3NpYmxlIHNwbGl0IGRpc3RyaWJ1dGlvbnMgd2hlcmUgZWFjaCBub2RlIGlzIGF0IGxlYXN0IG0gZnVsbFxuICAgIF9hbGxEaXN0TWFyZ2luOiBmdW5jdGlvbiAobm9kZSwgbSwgTSwgY29tcGFyZSkge1xuXG4gICAgICAgIG5vZGUuY2hpbGRyZW4uc29ydChjb21wYXJlKTtcblxuICAgICAgICB2YXIgdG9CQm94ID0gdGhpcy50b0JCb3gsXG4gICAgICAgICAgICBsZWZ0QkJveCA9IGRpc3RCQm94KG5vZGUsIDAsIG0sIHRvQkJveCksXG4gICAgICAgICAgICByaWdodEJCb3ggPSBkaXN0QkJveChub2RlLCBNIC0gbSwgTSwgdG9CQm94KSxcbiAgICAgICAgICAgIG1hcmdpbiA9IGJib3hNYXJnaW4obGVmdEJCb3gpICsgYmJveE1hcmdpbihyaWdodEJCb3gpLFxuICAgICAgICAgICAgaSwgY2hpbGQ7XG5cbiAgICAgICAgZm9yIChpID0gbTsgaSA8IE0gLSBtOyBpKyspIHtcbiAgICAgICAgICAgIGNoaWxkID0gbm9kZS5jaGlsZHJlbltpXTtcbiAgICAgICAgICAgIGV4dGVuZChsZWZ0QkJveCwgbm9kZS5sZWFmID8gdG9CQm94KGNoaWxkKSA6IGNoaWxkLmJib3gpO1xuICAgICAgICAgICAgbWFyZ2luICs9IGJib3hNYXJnaW4obGVmdEJCb3gpO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChpID0gTSAtIG0gLSAxOyBpID49IG07IGktLSkge1xuICAgICAgICAgICAgY2hpbGQgPSBub2RlLmNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgZXh0ZW5kKHJpZ2h0QkJveCwgbm9kZS5sZWFmID8gdG9CQm94KGNoaWxkKSA6IGNoaWxkLmJib3gpO1xuICAgICAgICAgICAgbWFyZ2luICs9IGJib3hNYXJnaW4ocmlnaHRCQm94KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBtYXJnaW47XG4gICAgfSxcblxuICAgIF9hZGp1c3RQYXJlbnRCQm94ZXM6IGZ1bmN0aW9uIChiYm94LCBwYXRoLCBsZXZlbCkge1xuICAgICAgICAvLyBhZGp1c3QgYmJveGVzIGFsb25nIHRoZSBnaXZlbiB0cmVlIHBhdGhcbiAgICAgICAgZm9yICh2YXIgaSA9IGxldmVsOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgZXh0ZW5kKHBhdGhbaV0uYmJveCwgYmJveCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgX2NvbmRlbnNlOiBmdW5jdGlvbiAocGF0aCkge1xuICAgICAgICAvLyBnbyB0aHJvdWdoIHRoZSBwYXRoLCByZW1vdmluZyBlbXB0eSBub2RlcyBhbmQgdXBkYXRpbmcgYmJveGVzXG4gICAgICAgIGZvciAodmFyIGkgPSBwYXRoLmxlbmd0aCAtIDEsIHNpYmxpbmdzOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgaWYgKHBhdGhbaV0uY2hpbGRyZW4ubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgaWYgKGkgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHNpYmxpbmdzID0gcGF0aFtpIC0gMV0uY2hpbGRyZW47XG4gICAgICAgICAgICAgICAgICAgIHNpYmxpbmdzLnNwbGljZShzaWJsaW5ncy5pbmRleE9mKHBhdGhbaV0pLCAxKTtcblxuICAgICAgICAgICAgICAgIH0gZWxzZSB0aGlzLmNsZWFyKCk7XG5cbiAgICAgICAgICAgIH0gZWxzZSBjYWxjQkJveChwYXRoW2ldLCB0aGlzLnRvQkJveCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgX2luaXRGb3JtYXQ6IGZ1bmN0aW9uIChmb3JtYXQpIHtcbiAgICAgICAgLy8gZGF0YSBmb3JtYXQgKG1pblgsIG1pblksIG1heFgsIG1heFkgYWNjZXNzb3JzKVxuXG4gICAgICAgIC8vIHVzZXMgZXZhbC10eXBlIGZ1bmN0aW9uIGNvbXBpbGF0aW9uIGluc3RlYWQgb2YganVzdCBhY2NlcHRpbmcgYSB0b0JCb3ggZnVuY3Rpb25cbiAgICAgICAgLy8gYmVjYXVzZSB0aGUgYWxnb3JpdGhtcyBhcmUgdmVyeSBzZW5zaXRpdmUgdG8gc29ydGluZyBmdW5jdGlvbnMgcGVyZm9ybWFuY2UsXG4gICAgICAgIC8vIHNvIHRoZXkgc2hvdWxkIGJlIGRlYWQgc2ltcGxlIGFuZCB3aXRob3V0IGlubmVyIGNhbGxzXG5cbiAgICAgICAgLy8ganNoaW50IGV2aWw6IHRydWVcblxuICAgICAgICB2YXIgY29tcGFyZUFyciA9IFsncmV0dXJuIGEnLCAnIC0gYicsICc7J107XG5cbiAgICAgICAgdGhpcy5jb21wYXJlTWluWCA9IG5ldyBGdW5jdGlvbignYScsICdiJywgY29tcGFyZUFyci5qb2luKGZvcm1hdFswXSkpO1xuICAgICAgICB0aGlzLmNvbXBhcmVNaW5ZID0gbmV3IEZ1bmN0aW9uKCdhJywgJ2InLCBjb21wYXJlQXJyLmpvaW4oZm9ybWF0WzFdKSk7XG5cbiAgICAgICAgdGhpcy50b0JCb3ggPSBuZXcgRnVuY3Rpb24oJ2EnLCAncmV0dXJuIFthJyArIGZvcm1hdC5qb2luKCcsIGEnKSArICddOycpO1xuICAgIH1cbn07XG5cblxuLy8gY2FsY3VsYXRlIG5vZGUncyBiYm94IGZyb20gYmJveGVzIG9mIGl0cyBjaGlsZHJlblxuZnVuY3Rpb24gY2FsY0JCb3gobm9kZSwgdG9CQm94KSB7XG4gICAgbm9kZS5iYm94ID0gZGlzdEJCb3gobm9kZSwgMCwgbm9kZS5jaGlsZHJlbi5sZW5ndGgsIHRvQkJveCk7XG59XG5cbi8vIG1pbiBib3VuZGluZyByZWN0YW5nbGUgb2Ygbm9kZSBjaGlsZHJlbiBmcm9tIGsgdG8gcC0xXG5mdW5jdGlvbiBkaXN0QkJveChub2RlLCBrLCBwLCB0b0JCb3gpIHtcbiAgICB2YXIgYmJveCA9IGVtcHR5KCk7XG5cbiAgICBmb3IgKHZhciBpID0gaywgY2hpbGQ7IGkgPCBwOyBpKyspIHtcbiAgICAgICAgY2hpbGQgPSBub2RlLmNoaWxkcmVuW2ldO1xuICAgICAgICBleHRlbmQoYmJveCwgbm9kZS5sZWFmID8gdG9CQm94KGNoaWxkKSA6IGNoaWxkLmJib3gpO1xuICAgIH1cblxuICAgIHJldHVybiBiYm94O1xufVxuXG5mdW5jdGlvbiBlbXB0eSgpIHsgcmV0dXJuIFtJbmZpbml0eSwgSW5maW5pdHksIC1JbmZpbml0eSwgLUluZmluaXR5XTsgfVxuXG5mdW5jdGlvbiBleHRlbmQoYSwgYikge1xuICAgIGFbMF0gPSBNYXRoLm1pbihhWzBdLCBiWzBdKTtcbiAgICBhWzFdID0gTWF0aC5taW4oYVsxXSwgYlsxXSk7XG4gICAgYVsyXSA9IE1hdGgubWF4KGFbMl0sIGJbMl0pO1xuICAgIGFbM10gPSBNYXRoLm1heChhWzNdLCBiWzNdKTtcbiAgICByZXR1cm4gYTtcbn1cblxuZnVuY3Rpb24gY29tcGFyZU5vZGVNaW5YKGEsIGIpIHsgcmV0dXJuIGEuYmJveFswXSAtIGIuYmJveFswXTsgfVxuZnVuY3Rpb24gY29tcGFyZU5vZGVNaW5ZKGEsIGIpIHsgcmV0dXJuIGEuYmJveFsxXSAtIGIuYmJveFsxXTsgfVxuXG5mdW5jdGlvbiBiYm94QXJlYShhKSAgIHsgcmV0dXJuIChhWzJdIC0gYVswXSkgKiAoYVszXSAtIGFbMV0pOyB9XG5mdW5jdGlvbiBiYm94TWFyZ2luKGEpIHsgcmV0dXJuIChhWzJdIC0gYVswXSkgKyAoYVszXSAtIGFbMV0pOyB9XG5cbmZ1bmN0aW9uIGVubGFyZ2VkQXJlYShhLCBiKSB7XG4gICAgcmV0dXJuIChNYXRoLm1heChiWzJdLCBhWzJdKSAtIE1hdGgubWluKGJbMF0sIGFbMF0pKSAqXG4gICAgICAgICAgIChNYXRoLm1heChiWzNdLCBhWzNdKSAtIE1hdGgubWluKGJbMV0sIGFbMV0pKTtcbn1cblxuZnVuY3Rpb24gaW50ZXJzZWN0aW9uQXJlYShhLCBiKSB7XG4gICAgdmFyIG1pblggPSBNYXRoLm1heChhWzBdLCBiWzBdKSxcbiAgICAgICAgbWluWSA9IE1hdGgubWF4KGFbMV0sIGJbMV0pLFxuICAgICAgICBtYXhYID0gTWF0aC5taW4oYVsyXSwgYlsyXSksXG4gICAgICAgIG1heFkgPSBNYXRoLm1pbihhWzNdLCBiWzNdKTtcblxuICAgIHJldHVybiBNYXRoLm1heCgwLCBtYXhYIC0gbWluWCkgKlxuICAgICAgICAgICBNYXRoLm1heCgwLCBtYXhZIC0gbWluWSk7XG59XG5cbmZ1bmN0aW9uIGNvbnRhaW5zKGEsIGIpIHtcbiAgICByZXR1cm4gYVswXSA8PSBiWzBdICYmXG4gICAgICAgICAgIGFbMV0gPD0gYlsxXSAmJlxuICAgICAgICAgICBiWzJdIDw9IGFbMl0gJiZcbiAgICAgICAgICAgYlszXSA8PSBhWzNdO1xufVxuXG5mdW5jdGlvbiBpbnRlcnNlY3RzKGEsIGIpIHtcbiAgICByZXR1cm4gYlswXSA8PSBhWzJdICYmXG4gICAgICAgICAgIGJbMV0gPD0gYVszXSAmJlxuICAgICAgICAgICBiWzJdID49IGFbMF0gJiZcbiAgICAgICAgICAgYlszXSA+PSBhWzFdO1xufVxuXG4vLyBzb3J0IGFuIGFycmF5IHNvIHRoYXQgaXRlbXMgY29tZSBpbiBncm91cHMgb2YgbiB1bnNvcnRlZCBpdGVtcywgd2l0aCBncm91cHMgc29ydGVkIGJldHdlZW4gZWFjaCBvdGhlcjtcbi8vIGNvbWJpbmVzIHNlbGVjdGlvbiBhbGdvcml0aG0gd2l0aCBiaW5hcnkgZGl2aWRlICYgY29ucXVlciBhcHByb2FjaFxuXG5mdW5jdGlvbiBtdWx0aVNlbGVjdChhcnIsIGxlZnQsIHJpZ2h0LCBuLCBjb21wYXJlKSB7XG4gICAgdmFyIHN0YWNrID0gW2xlZnQsIHJpZ2h0XSxcbiAgICAgICAgbWlkO1xuXG4gICAgd2hpbGUgKHN0YWNrLmxlbmd0aCkge1xuICAgICAgICByaWdodCA9IHN0YWNrLnBvcCgpO1xuICAgICAgICBsZWZ0ID0gc3RhY2sucG9wKCk7XG5cbiAgICAgICAgaWYgKHJpZ2h0IC0gbGVmdCA8PSBuKSBjb250aW51ZTtcblxuICAgICAgICBtaWQgPSBsZWZ0ICsgTWF0aC5jZWlsKChyaWdodCAtIGxlZnQpIC8gbiAvIDIpICogbjtcbiAgICAgICAgc2VsZWN0KGFyciwgbGVmdCwgcmlnaHQsIG1pZCwgY29tcGFyZSk7XG5cbiAgICAgICAgc3RhY2sucHVzaChsZWZ0LCBtaWQsIG1pZCwgcmlnaHQpO1xuICAgIH1cbn1cblxuLy8gRmxveWQtUml2ZXN0IHNlbGVjdGlvbiBhbGdvcml0aG06XG4vLyBzb3J0IGFuIGFycmF5IGJldHdlZW4gbGVmdCBhbmQgcmlnaHQgKGluY2x1c2l2ZSkgc28gdGhhdCB0aGUgc21hbGxlc3QgayBlbGVtZW50cyBjb21lIGZpcnN0ICh1bm9yZGVyZWQpXG5mdW5jdGlvbiBzZWxlY3QoYXJyLCBsZWZ0LCByaWdodCwgaywgY29tcGFyZSkge1xuICAgIHZhciBuLCBpLCB6LCBzLCBzZCwgbmV3TGVmdCwgbmV3UmlnaHQsIHQsIGo7XG5cbiAgICB3aGlsZSAocmlnaHQgPiBsZWZ0KSB7XG4gICAgICAgIGlmIChyaWdodCAtIGxlZnQgPiA2MDApIHtcbiAgICAgICAgICAgIG4gPSByaWdodCAtIGxlZnQgKyAxO1xuICAgICAgICAgICAgaSA9IGsgLSBsZWZ0ICsgMTtcbiAgICAgICAgICAgIHogPSBNYXRoLmxvZyhuKTtcbiAgICAgICAgICAgIHMgPSAwLjUgKiBNYXRoLmV4cCgyICogeiAvIDMpO1xuICAgICAgICAgICAgc2QgPSAwLjUgKiBNYXRoLnNxcnQoeiAqIHMgKiAobiAtIHMpIC8gbikgKiAoaSAtIG4gLyAyIDwgMCA/IC0xIDogMSk7XG4gICAgICAgICAgICBuZXdMZWZ0ID0gTWF0aC5tYXgobGVmdCwgTWF0aC5mbG9vcihrIC0gaSAqIHMgLyBuICsgc2QpKTtcbiAgICAgICAgICAgIG5ld1JpZ2h0ID0gTWF0aC5taW4ocmlnaHQsIE1hdGguZmxvb3IoayArIChuIC0gaSkgKiBzIC8gbiArIHNkKSk7XG4gICAgICAgICAgICBzZWxlY3QoYXJyLCBuZXdMZWZ0LCBuZXdSaWdodCwgaywgY29tcGFyZSk7XG4gICAgICAgIH1cblxuICAgICAgICB0ID0gYXJyW2tdO1xuICAgICAgICBpID0gbGVmdDtcbiAgICAgICAgaiA9IHJpZ2h0O1xuXG4gICAgICAgIHN3YXAoYXJyLCBsZWZ0LCBrKTtcbiAgICAgICAgaWYgKGNvbXBhcmUoYXJyW3JpZ2h0XSwgdCkgPiAwKSBzd2FwKGFyciwgbGVmdCwgcmlnaHQpO1xuXG4gICAgICAgIHdoaWxlIChpIDwgaikge1xuICAgICAgICAgICAgc3dhcChhcnIsIGksIGopO1xuICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgai0tO1xuICAgICAgICAgICAgd2hpbGUgKGNvbXBhcmUoYXJyW2ldLCB0KSA8IDApIGkrKztcbiAgICAgICAgICAgIHdoaWxlIChjb21wYXJlKGFycltqXSwgdCkgPiAwKSBqLS07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY29tcGFyZShhcnJbbGVmdF0sIHQpID09PSAwKSBzd2FwKGFyciwgbGVmdCwgaik7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaisrO1xuICAgICAgICAgICAgc3dhcChhcnIsIGosIHJpZ2h0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChqIDw9IGspIGxlZnQgPSBqICsgMTtcbiAgICAgICAgaWYgKGsgPD0gaikgcmlnaHQgPSBqIC0gMTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHN3YXAoYXJyLCBpLCBqKSB7XG4gICAgdmFyIHRtcCA9IGFycltpXTtcbiAgICBhcnJbaV0gPSBhcnJbal07XG4gICAgYXJyW2pdID0gdG1wO1xufVxuXG5cbi8vIGV4cG9ydCBhcyBBTUQvQ29tbW9uSlMgbW9kdWxlIG9yIGdsb2JhbCB2YXJpYWJsZVxuaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkgZGVmaW5lKCdyYnVzaCcsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJidXNoOyB9KTtcbmVsc2UgaWYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnKSBtb2R1bGUuZXhwb3J0cyA9IHJidXNoO1xuZWxzZSBpZiAodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnKSBzZWxmLnJidXNoID0gcmJ1c2g7XG5lbHNlIHdpbmRvdy5yYnVzaCA9IHJidXNoO1xuXG59KSgpO1xuIiwiLy8gQ29weXJpZ2h0IDIwMTQgU2ltb24gTHlkZWxsXHJcbi8vIFgxMSAo4oCcTUlU4oCdKSBMaWNlbnNlZC4gKFNlZSBMSUNFTlNFLilcclxuXHJcbnZvaWQgKGZ1bmN0aW9uKHJvb3QsIGZhY3RvcnkpIHtcclxuICBpZiAodHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIHtcclxuICAgIGRlZmluZShmYWN0b3J5KVxyXG4gIH0gZWxzZSBpZiAodHlwZW9mIGV4cG9ydHMgPT09IFwib2JqZWN0XCIpIHtcclxuICAgIG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpXHJcbiAgfSBlbHNlIHtcclxuICAgIHJvb3QucmVzb2x2ZVVybCA9IGZhY3RvcnkoKVxyXG4gIH1cclxufSh0aGlzLCBmdW5jdGlvbigpIHtcclxuXHJcbiAgZnVuY3Rpb24gcmVzb2x2ZVVybCgvKiAuLi51cmxzICovKSB7XHJcbiAgICB2YXIgbnVtVXJscyA9IGFyZ3VtZW50cy5sZW5ndGhcclxuXHJcbiAgICBpZiAobnVtVXJscyA9PT0gMCkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJyZXNvbHZlVXJsIHJlcXVpcmVzIGF0IGxlYXN0IG9uZSBhcmd1bWVudDsgZ290IG5vbmUuXCIpXHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGJhc2UgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYmFzZVwiKVxyXG4gICAgYmFzZS5ocmVmID0gYXJndW1lbnRzWzBdXHJcblxyXG4gICAgaWYgKG51bVVybHMgPT09IDEpIHtcclxuICAgICAgcmV0dXJuIGJhc2UuaHJlZlxyXG4gICAgfVxyXG5cclxuICAgIHZhciBoZWFkID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJoZWFkXCIpWzBdXHJcbiAgICBoZWFkLmluc2VydEJlZm9yZShiYXNlLCBoZWFkLmZpcnN0Q2hpbGQpXHJcblxyXG4gICAgdmFyIGEgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYVwiKVxyXG4gICAgdmFyIHJlc29sdmVkXHJcblxyXG4gICAgZm9yICh2YXIgaW5kZXggPSAxOyBpbmRleCA8IG51bVVybHM7IGluZGV4KyspIHtcclxuICAgICAgYS5ocmVmID0gYXJndW1lbnRzW2luZGV4XVxyXG4gICAgICByZXNvbHZlZCA9IGEuaHJlZlxyXG4gICAgICBiYXNlLmhyZWYgPSByZXNvbHZlZFxyXG4gICAgfVxyXG5cclxuICAgIGhlYWQucmVtb3ZlQ2hpbGQoYmFzZSlcclxuXHJcbiAgICByZXR1cm4gcmVzb2x2ZWRcclxuICB9XHJcblxyXG4gIHJldHVybiByZXNvbHZlVXJsXHJcblxyXG59KSk7XHJcbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBTaGVsZlBhY2s7XG5cbi8qKlxuICogVXNlcyB0aGUgU2hlbGYgQmVzdCBIZWlnaHQgRml0IGFsZ29yaXRobSBmcm9tXG4gKiBodHRwOi8vY2xiLmRlbW9uLmZpL2ZpbGVzL1JlY3RhbmdsZUJpblBhY2sucGRmXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBTaGVsZlBhY2sod2lkdGgsIGhlaWdodCkge1xuICAgIHRoaXMud2lkdGggPSB3aWR0aDtcbiAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcbiAgICB0aGlzLnNoZWx2ZXMgPSBbXTtcbiAgICB0aGlzLnN0YXRzID0ge307XG4gICAgdGhpcy5jb3VudCA9IGZ1bmN0aW9uKGgpIHtcbiAgICAgICAgdGhpcy5zdGF0c1toXSA9ICh0aGlzLnN0YXRzW2hdIHwgMCkgKyAxO1xuICAgIH07XG59XG5cblNoZWxmUGFjay5wcm90b3R5cGUuYWxsb2NhdGUgPSBmdW5jdGlvbihyZXFXaWR0aCwgcmVxSGVpZ2h0KSB7XG4gICAgdmFyIHkgPSAwLFxuICAgICAgICBiZXN0ID0geyBzaGVsZjogLTEsIHdhc3RlOiBJbmZpbml0eSB9LFxuICAgICAgICBzaGVsZiwgd2FzdGU7XG5cbiAgICAvLyBmaW5kIHNoZWxmXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnNoZWx2ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgc2hlbGYgPSB0aGlzLnNoZWx2ZXNbaV07XG4gICAgICAgIHkgKz0gc2hlbGYuaGVpZ2h0O1xuXG4gICAgICAgIC8vIGV4YWN0bHkgdGhlIHJpZ2h0IGhlaWdodCB3aXRoIHdpZHRoIHRvIHNwYXJlLCBwYWNrIGl0Li5cbiAgICAgICAgaWYgKHJlcUhlaWdodCA9PT0gc2hlbGYuaGVpZ2h0ICYmIHJlcVdpZHRoIDw9IHNoZWxmLmZyZWUpIHtcbiAgICAgICAgICAgIHRoaXMuY291bnQocmVxSGVpZ2h0KTtcbiAgICAgICAgICAgIHJldHVybiBzaGVsZi5hbGxvYyhyZXFXaWR0aCwgcmVxSGVpZ2h0KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBub3QgZW5vdWdoIGhlaWdodCBvciB3aWR0aCwgc2tpcCBpdC4uXG4gICAgICAgIGlmIChyZXFIZWlnaHQgPiBzaGVsZi5oZWlnaHQgfHwgcmVxV2lkdGggPiBzaGVsZi5mcmVlKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBtYXliZSBlbm91Z2ggaGVpZ2h0IG9yIHdpZHRoLCBtaW5pbWl6ZSB3YXN0ZS4uXG4gICAgICAgIGlmIChyZXFIZWlnaHQgPCBzaGVsZi5oZWlnaHQgJiYgcmVxV2lkdGggPD0gc2hlbGYuZnJlZSkge1xuICAgICAgICAgICAgd2FzdGUgPSBzaGVsZi5oZWlnaHQgLSByZXFIZWlnaHQ7XG4gICAgICAgICAgICBpZiAod2FzdGUgPCBiZXN0Lndhc3RlKSB7XG4gICAgICAgICAgICAgICAgYmVzdC53YXN0ZSA9IHdhc3RlO1xuICAgICAgICAgICAgICAgIGJlc3Quc2hlbGYgPSBpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGJlc3Quc2hlbGYgIT09IC0xKSB7XG4gICAgICAgIHNoZWxmID0gdGhpcy5zaGVsdmVzW2Jlc3Quc2hlbGZdO1xuICAgICAgICB0aGlzLmNvdW50KHJlcUhlaWdodCk7XG4gICAgICAgIHJldHVybiBzaGVsZi5hbGxvYyhyZXFXaWR0aCwgcmVxSGVpZ2h0KTtcbiAgICB9XG5cbiAgICAvLyBhZGQgc2hlbGZcbiAgICBpZiAocmVxSGVpZ2h0IDw9ICh0aGlzLmhlaWdodCAtIHkpICYmIHJlcVdpZHRoIDw9IHRoaXMud2lkdGgpIHtcbiAgICAgICAgc2hlbGYgPSBuZXcgU2hlbGYoeSwgdGhpcy53aWR0aCwgcmVxSGVpZ2h0KTtcbiAgICAgICAgdGhpcy5zaGVsdmVzLnB1c2goc2hlbGYpO1xuICAgICAgICB0aGlzLmNvdW50KHJlcUhlaWdodCk7XG4gICAgICAgIHJldHVybiBzaGVsZi5hbGxvYyhyZXFXaWR0aCwgcmVxSGVpZ2h0KTtcbiAgICB9XG5cbiAgICAvLyBubyBtb3JlIHNwYWNlXG4gICAgcmV0dXJuIHt4OiAtMSwgeTogLTF9O1xufTtcblxuXG5TaGVsZlBhY2sucHJvdG90eXBlLnJlc2l6ZSA9IGZ1bmN0aW9uKHJlcVdpZHRoLCByZXFIZWlnaHQpIHtcbiAgICBpZiAocmVxV2lkdGggPCB0aGlzLndpZHRoIHx8IHJlcUhlaWdodCA8IHRoaXMuaGVpZ2h0KSB7IHJldHVybiBmYWxzZTsgfVxuICAgIHRoaXMuaGVpZ2h0ID0gcmVxSGVpZ2h0O1xuICAgIHRoaXMud2lkdGggPSByZXFXaWR0aDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuc2hlbHZlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzLnNoZWx2ZXNbaV0ucmVzaXplKHJlcVdpZHRoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59O1xuXG5cbmZ1bmN0aW9uIFNoZWxmKHksIHdpZHRoLCBoZWlnaHQpIHtcbiAgICB0aGlzLnkgPSB5O1xuICAgIHRoaXMueCA9IDA7XG4gICAgdGhpcy53aWR0aCA9IHRoaXMuZnJlZSA9IHdpZHRoO1xuICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xufVxuXG5TaGVsZi5wcm90b3R5cGUgPSB7XG4gICAgYWxsb2M6IGZ1bmN0aW9uKHJlcVdpZHRoLCByZXFIZWlnaHQpIHtcbiAgICAgICAgaWYgKHJlcVdpZHRoID4gdGhpcy5mcmVlIHx8IHJlcUhlaWdodCA+IHRoaXMuaGVpZ2h0KSB7XG4gICAgICAgICAgICByZXR1cm4ge3g6IC0xLCB5OiAtMX07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHggPSB0aGlzLng7XG4gICAgICAgIHRoaXMueCArPSByZXFXaWR0aDtcbiAgICAgICAgdGhpcy5mcmVlIC09IHJlcVdpZHRoO1xuICAgICAgICByZXR1cm4ge3g6IHgsIHk6IHRoaXMueSwgdzogcmVxV2lkdGgsIGg6IHJlcUhlaWdodH07XG4gICAgfSxcblxuICAgIHJlc2l6ZTogZnVuY3Rpb24ocmVxV2lkdGgpIHtcbiAgICAgICAgaWYgKHJlcVdpZHRoIDwgdGhpcy53aWR0aCkgeyByZXR1cm4gZmFsc2U7IH1cbiAgICAgICAgdGhpcy5mcmVlICs9IChyZXFXaWR0aCAtIHRoaXMud2lkdGgpO1xuICAgICAgICB0aGlzLndpZHRoID0gcmVxV2lkdGg7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbn07XG5cbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHJidXNoID0gcmVxdWlyZSgncmJ1c2gnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBzdXBlcmNsdXN0ZXI7XG5cbmZ1bmN0aW9uIHN1cGVyY2x1c3RlcihvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBTdXBlckNsdXN0ZXIob3B0aW9ucyk7XG59XG5cbmZ1bmN0aW9uIFN1cGVyQ2x1c3RlcihvcHRpb25zKSB7XG4gICAgdGhpcy5vcHRpb25zID0gZXh0ZW5kKE9iamVjdC5jcmVhdGUodGhpcy5vcHRpb25zKSwgb3B0aW9ucyk7XG4gICAgdGhpcy5faW5pdFRyZWVzKCk7XG59XG5cblN1cGVyQ2x1c3Rlci5wcm90b3R5cGUgPSB7XG4gICAgb3B0aW9uczoge1xuICAgICAgICBtaW5ab29tOiAwLCAgIC8vIG1pbiB6b29tIHRvIGdlbmVyYXRlIGNsdXN0ZXJzIG9uXG4gICAgICAgIG1heFpvb206IDE2LCAgLy8gbWF4IHpvb20gbGV2ZWwgdG8gY2x1c3RlciB0aGUgcG9pbnRzIG9uXG4gICAgICAgIHJhZGl1czogNDAsICAgLy8gY2x1c3RlciByYWRpdXMgaW4gcGl4ZWxzXG4gICAgICAgIGV4dGVudDogNTEyLCAgLy8gdGlsZSBleHRlbnQgKHJhZGl1cyBpcyBjYWxjdWxhdGVkIHJlbGF0aXZlIHRvIGl0KVxuICAgICAgICBub2RlU2l6ZTogMTYsIC8vIHNpemUgb2YgdGhlIFItdHJlZSBsZWFmIG5vZGUsIGFmZmVjdHMgcGVyZm9ybWFuY2VcbiAgICAgICAgbG9nOiBmYWxzZSAgICAvLyB3aGV0aGVyIHRvIGxvZyB0aW1pbmcgaW5mb1xuICAgIH0sXG5cbiAgICBsb2FkOiBmdW5jdGlvbiAocG9pbnRzKSB7XG4gICAgICAgIHZhciBsb2cgPSB0aGlzLm9wdGlvbnMubG9nO1xuXG4gICAgICAgIGlmIChsb2cpIGNvbnNvbGUudGltZSgndG90YWwgdGltZScpO1xuXG4gICAgICAgIHZhciB0aW1lcklkID0gJ3ByZXBhcmUgJyArIHBvaW50cy5sZW5ndGggKyAnIHBvaW50cyc7XG4gICAgICAgIGlmIChsb2cpIGNvbnNvbGUudGltZSh0aW1lcklkKTtcblxuICAgICAgICAvLyBnZW5lcmF0ZSBhIGNsdXN0ZXIgb2JqZWN0IGZvciBlYWNoIHBvaW50XG4gICAgICAgIHZhciBjbHVzdGVycyA9IHBvaW50cy5tYXAoY3JlYXRlUG9pbnRDbHVzdGVyKTtcbiAgICAgICAgaWYgKGxvZykgY29uc29sZS50aW1lRW5kKHRpbWVySWQpO1xuXG4gICAgICAgIC8vIGNsdXN0ZXIgcG9pbnRzIG9uIG1heCB6b29tLCB0aGVuIGNsdXN0ZXIgdGhlIHJlc3VsdHMgb24gcHJldmlvdXMgem9vbSwgZXRjLjtcbiAgICAgICAgLy8gcmVzdWx0cyBpbiBhIGNsdXN0ZXIgaGllcmFyY2h5IGFjcm9zcyB6b29tIGxldmVsc1xuICAgICAgICBmb3IgKHZhciB6ID0gdGhpcy5vcHRpb25zLm1heFpvb207IHogPj0gdGhpcy5vcHRpb25zLm1pblpvb207IHotLSkge1xuICAgICAgICAgICAgdmFyIG5vdyA9ICtEYXRlLm5vdygpO1xuXG4gICAgICAgICAgICB0aGlzLnRyZWVzW3ogKyAxXS5sb2FkKGNsdXN0ZXJzKTsgLy8gaW5kZXggaW5wdXQgcG9pbnRzIGludG8gYW4gUi10cmVlXG4gICAgICAgICAgICBjbHVzdGVycyA9IHRoaXMuX2NsdXN0ZXIoY2x1c3RlcnMsIHopOyAvLyBjcmVhdGUgYSBuZXcgc2V0IG9mIGNsdXN0ZXJzIGZvciB0aGUgem9vbVxuXG4gICAgICAgICAgICBpZiAobG9nKSBjb25zb2xlLmxvZygneiVkOiAlZCBjbHVzdGVycyBpbiAlZG1zJywgeiwgY2x1c3RlcnMubGVuZ3RoLCArRGF0ZS5ub3coKSAtIG5vdyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50cmVlc1t0aGlzLm9wdGlvbnMubWluWm9vbV0ubG9hZChjbHVzdGVycyk7IC8vIGluZGV4IHRvcC1sZXZlbCBjbHVzdGVyc1xuXG4gICAgICAgIGlmIChsb2cpIGNvbnNvbGUudGltZUVuZCgndG90YWwgdGltZScpO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBnZXRDbHVzdGVyczogZnVuY3Rpb24gKGJib3gsIHpvb20pIHtcbiAgICAgICAgdmFyIHByb2pCQm94ID0gW2xuZ1goYmJveFswXSksIGxhdFkoYmJveFszXSksIGxuZ1goYmJveFsyXSksIGxhdFkoYmJveFsxXSldO1xuICAgICAgICB2YXIgeiA9IE1hdGgubWF4KHRoaXMub3B0aW9ucy5taW5ab29tLCBNYXRoLm1pbih6b29tLCB0aGlzLm9wdGlvbnMubWF4Wm9vbSArIDEpKTtcbiAgICAgICAgdmFyIGNsdXN0ZXJzID0gdGhpcy50cmVlc1t6XS5zZWFyY2gocHJvakJCb3gpO1xuICAgICAgICByZXR1cm4gY2x1c3RlcnMubWFwKGdldENsdXN0ZXJKU09OKTtcbiAgICB9LFxuXG4gICAgZ2V0VGlsZTogZnVuY3Rpb24gKHosIHgsIHkpIHtcbiAgICAgICAgdmFyIHoyID0gTWF0aC5wb3coMiwgeik7XG4gICAgICAgIHZhciBleHRlbnQgPSB0aGlzLm9wdGlvbnMuZXh0ZW50O1xuICAgICAgICB2YXIgcCA9IHRoaXMub3B0aW9ucy5yYWRpdXMgLyBleHRlbnQ7XG4gICAgICAgIHZhciBjbHVzdGVycyA9IHRoaXMudHJlZXNbel0uc2VhcmNoKFtcbiAgICAgICAgICAgICh4IC0gcCkgLyB6MixcbiAgICAgICAgICAgICh5IC0gcCkgLyB6MixcbiAgICAgICAgICAgICh4ICsgMSArIHApIC8gejIsXG4gICAgICAgICAgICAoeSArIDEgKyBwKSAvIHoyXG4gICAgICAgIF0pO1xuICAgICAgICBpZiAoIWNsdXN0ZXJzLmxlbmd0aCkgcmV0dXJuIG51bGw7XG4gICAgICAgIHZhciB0aWxlID0ge1xuICAgICAgICAgICAgZmVhdHVyZXM6IFtdXG4gICAgICAgIH07XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2x1c3RlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBjID0gY2x1c3RlcnNbaV07XG4gICAgICAgICAgICB2YXIgZmVhdHVyZSA9IHtcbiAgICAgICAgICAgICAgICB0eXBlOiAxLFxuICAgICAgICAgICAgICAgIGdlb21ldHJ5OiBbW1xuICAgICAgICAgICAgICAgICAgICBNYXRoLnJvdW5kKGV4dGVudCAqIChjLnd4ICogejIgLSB4KSksXG4gICAgICAgICAgICAgICAgICAgIE1hdGgucm91bmQoZXh0ZW50ICogKGMud3kgKiB6MiAtIHkpKVxuICAgICAgICAgICAgICAgIF1dLFxuICAgICAgICAgICAgICAgIHRhZ3M6IGMucG9pbnQgPyBjLnBvaW50LnByb3BlcnRpZXMgOiBnZXRDbHVzdGVyUHJvcGVydGllcyhjKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRpbGUuZmVhdHVyZXMucHVzaChmZWF0dXJlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGlsZTtcbiAgICB9LFxuXG4gICAgX2luaXRUcmVlczogZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnRyZWVzID0gW107XG4gICAgICAgIC8vIG1ha2UgYW4gUi1UcmVlIGluZGV4IGZvciBlYWNoIHpvb20gbGV2ZWxcbiAgICAgICAgZm9yICh2YXIgeiA9IDA7IHogPD0gdGhpcy5vcHRpb25zLm1heFpvb20gKyAxOyB6KyspIHtcbiAgICAgICAgICAgIHRoaXMudHJlZXNbel0gPSByYnVzaCh0aGlzLm9wdGlvbnMubm9kZVNpemUpO1xuICAgICAgICAgICAgdGhpcy50cmVlc1t6XS50b0JCb3ggPSB0b0JCb3g7XG4gICAgICAgICAgICB0aGlzLnRyZWVzW3pdLmNvbXBhcmVNaW5YID0gY29tcGFyZU1pblg7XG4gICAgICAgICAgICB0aGlzLnRyZWVzW3pdLmNvbXBhcmVNaW5ZID0gY29tcGFyZU1pblk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgX2NsdXN0ZXI6IGZ1bmN0aW9uIChwb2ludHMsIHpvb20pIHtcbiAgICAgICAgdmFyIGNsdXN0ZXJzID0gW107XG4gICAgICAgIHZhciByID0gdGhpcy5vcHRpb25zLnJhZGl1cyAvICh0aGlzLm9wdGlvbnMuZXh0ZW50ICogTWF0aC5wb3coMiwgem9vbSkpO1xuICAgICAgICB2YXIgYmJveCA9IFswLCAwLCAwLCAwXTtcblxuICAgICAgICAvLyBsb29wIHRocm91Z2ggZWFjaCBwb2ludFxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBvaW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIHAgPSBwb2ludHNbaV07XG4gICAgICAgICAgICAvLyBpZiB3ZSd2ZSBhbHJlYWR5IHZpc2l0ZWQgdGhlIHBvaW50IGF0IHRoaXMgem9vbSBsZXZlbCwgc2tpcCBpdFxuICAgICAgICAgICAgaWYgKHAuem9vbSA8PSB6b29tKSBjb250aW51ZTtcbiAgICAgICAgICAgIHAuem9vbSA9IHpvb207XG5cbiAgICAgICAgICAgIC8vIGZpbmQgYWxsIG5lYXJieSBwb2ludHMgd2l0aCBhIGJib3ggc2VhcmNoXG4gICAgICAgICAgICBiYm94WzBdID0gcC53eCAtIHI7XG4gICAgICAgICAgICBiYm94WzFdID0gcC53eSAtIHI7XG4gICAgICAgICAgICBiYm94WzJdID0gcC53eCArIHI7XG4gICAgICAgICAgICBiYm94WzNdID0gcC53eSArIHI7XG4gICAgICAgICAgICB2YXIgYmJveE5laWdoYm9ycyA9IHRoaXMudHJlZXNbem9vbSArIDFdLnNlYXJjaChiYm94KTtcblxuICAgICAgICAgICAgdmFyIGZvdW5kTmVpZ2hib3JzID0gZmFsc2U7XG4gICAgICAgICAgICB2YXIgbnVtUG9pbnRzID0gcC5udW1Qb2ludHM7XG4gICAgICAgICAgICB2YXIgd3ggPSBwLnd4ICogbnVtUG9pbnRzO1xuICAgICAgICAgICAgdmFyIHd5ID0gcC53eSAqIG51bVBvaW50cztcblxuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBiYm94TmVpZ2hib3JzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGIgPSBiYm94TmVpZ2hib3JzW2pdO1xuICAgICAgICAgICAgICAgIC8vIGZpbHRlciBvdXQgbmVpZ2hib3JzIHRoYXQgYXJlIHRvbyBmYXIgb3IgYWxyZWFkeSBwcm9jZXNzZWRcbiAgICAgICAgICAgICAgICBpZiAoem9vbSA8IGIuem9vbSAmJiBkaXN0U3EocCwgYikgPD0gciAqIHIpIHtcbiAgICAgICAgICAgICAgICAgICAgZm91bmROZWlnaGJvcnMgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBiLnpvb20gPSB6b29tOyAvLyBzYXZlIHRoZSB6b29tIChzbyBpdCBkb2Vzbid0IGdldCBwcm9jZXNzZWQgdHdpY2UpXG4gICAgICAgICAgICAgICAgICAgIHd4ICs9IGIud3ggKiBiLm51bVBvaW50czsgLy8gYWNjdW11bGF0ZSBjb29yZGluYXRlcyBmb3IgY2FsY3VsYXRpbmcgd2VpZ2h0ZWQgY2VudGVyXG4gICAgICAgICAgICAgICAgICAgIHd5ICs9IGIud3kgKiBiLm51bVBvaW50cztcbiAgICAgICAgICAgICAgICAgICAgbnVtUG9pbnRzICs9IGIubnVtUG9pbnRzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCFmb3VuZE5laWdoYm9ycykge1xuICAgICAgICAgICAgICAgIGNsdXN0ZXJzLnB1c2gocCk7IC8vIG5vIG5laWdoYm9ycywgYWRkIGEgc2luZ2xlIHBvaW50IGFzIGNsdXN0ZXJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gZm9ybSBhIGNsdXN0ZXIgd2l0aCBuZWlnaGJvcnNcbiAgICAgICAgICAgIHZhciBjbHVzdGVyID0gY3JlYXRlQ2x1c3RlcihwLngsIHAueSk7XG4gICAgICAgICAgICBjbHVzdGVyLm51bVBvaW50cyA9IG51bVBvaW50cztcblxuICAgICAgICAgICAgLy8gc2F2ZSB3ZWlnaHRlZCBjbHVzdGVyIGNlbnRlciBmb3IgZGlzcGxheVxuICAgICAgICAgICAgY2x1c3Rlci53eCA9IHd4IC8gbnVtUG9pbnRzO1xuICAgICAgICAgICAgY2x1c3Rlci53eSA9IHd5IC8gbnVtUG9pbnRzO1xuXG4gICAgICAgICAgICBjbHVzdGVycy5wdXNoKGNsdXN0ZXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNsdXN0ZXJzO1xuICAgIH1cbn07XG5cbmZ1bmN0aW9uIHRvQkJveChwKSB7XG4gICAgcmV0dXJuIFtwLngsIHAueSwgcC54LCBwLnldO1xufVxuZnVuY3Rpb24gY29tcGFyZU1pblgoYSwgYikge1xuICAgIHJldHVybiBhLnggLSBiLng7XG59XG5mdW5jdGlvbiBjb21wYXJlTWluWShhLCBiKSB7XG4gICAgcmV0dXJuIGEueSAtIGIueTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlQ2x1c3Rlcih4LCB5KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgeDogeCwgLy8gY2x1c3RlciBjZW50ZXJcbiAgICAgICAgeTogeSxcbiAgICAgICAgd3g6IHgsIC8vIHdlaWdodGVkIGNsdXN0ZXIgY2VudGVyXG4gICAgICAgIHd5OiB5LFxuICAgICAgICB6b29tOiBJbmZpbml0eSwgLy8gdGhlIGxhc3Qgem9vbSB0aGUgY2x1c3RlciB3YXMgcHJvY2Vzc2VkIGF0XG4gICAgICAgIHBvaW50OiBudWxsLFxuICAgICAgICBudW1Qb2ludHM6IDFcbiAgICB9O1xufVxuXG5mdW5jdGlvbiBjcmVhdGVQb2ludENsdXN0ZXIocCkge1xuICAgIHZhciBjb29yZHMgPSBwLmdlb21ldHJ5LmNvb3JkaW5hdGVzO1xuICAgIHZhciBjbHVzdGVyID0gY3JlYXRlQ2x1c3RlcihsbmdYKGNvb3Jkc1swXSksIGxhdFkoY29vcmRzWzFdKSk7XG4gICAgY2x1c3Rlci5wb2ludCA9IHA7XG4gICAgcmV0dXJuIGNsdXN0ZXI7XG59XG5cbmZ1bmN0aW9uIGdldENsdXN0ZXJKU09OKGNsdXN0ZXIpIHtcbiAgICByZXR1cm4gY2x1c3Rlci5wb2ludCA/IGNsdXN0ZXIucG9pbnQgOiB7XG4gICAgICAgIHR5cGU6ICdGZWF0dXJlJyxcbiAgICAgICAgcHJvcGVydGllczogZ2V0Q2x1c3RlclByb3BlcnRpZXMoY2x1c3RlciksXG4gICAgICAgIGdlb21ldHJ5OiB7XG4gICAgICAgICAgICB0eXBlOiAnUG9pbnQnLFxuICAgICAgICAgICAgY29vcmRpbmF0ZXM6IFt4TG5nKGNsdXN0ZXIud3gpLCB5TGF0KGNsdXN0ZXIud3kpXVxuICAgICAgICB9XG4gICAgfTtcbn1cblxuZnVuY3Rpb24gZ2V0Q2x1c3RlclByb3BlcnRpZXMoY2x1c3Rlcikge1xuICAgIHZhciBjb3VudCA9IGNsdXN0ZXIubnVtUG9pbnRzO1xuICAgIHZhciBhYmJyZXYgPSBjb3VudCA+PSAxMDAwMCA/IE1hdGgucm91bmQoY291bnQgLyAxMDAwKSArICdrJyA6XG4gICAgICAgICAgICAgICAgIGNvdW50ID49IDEwMDAgPyAoTWF0aC5yb3VuZChjb3VudCAvIDEwMCkgLyAxMCkgKyAnaycgOiBjb3VudDtcbiAgICByZXR1cm4ge1xuICAgICAgICBjbHVzdGVyOiB0cnVlLFxuICAgICAgICBwb2ludF9jb3VudDogY291bnQsXG4gICAgICAgIHBvaW50X2NvdW50X2FiYnJldmlhdGVkOiBhYmJyZXZcbiAgICB9O1xufVxuXG4vLyBsb25naXR1ZGUvbGF0aXR1ZGUgdG8gc3BoZXJpY2FsIG1lcmNhdG9yIGluIFswLi4xXSByYW5nZVxuZnVuY3Rpb24gbG5nWChsbmcpIHtcbiAgICByZXR1cm4gbG5nIC8gMzYwICsgMC41O1xufVxuZnVuY3Rpb24gbGF0WShsYXQpIHtcbiAgICB2YXIgc2luID0gTWF0aC5zaW4obGF0ICogTWF0aC5QSSAvIDE4MCksXG4gICAgICAgIHkgPSAoMC41IC0gMC4yNSAqIE1hdGgubG9nKCgxICsgc2luKSAvICgxIC0gc2luKSkgLyBNYXRoLlBJKTtcbiAgICByZXR1cm4geSA8IDAgPyAwIDpcbiAgICAgICAgICAgeSA+IDEgPyAxIDogeTtcbn1cblxuLy8gc3BoZXJpY2FsIG1lcmNhdG9yIHRvIGxvbmdpdHVkZS9sYXRpdHVkZVxuZnVuY3Rpb24geExuZyh4KSB7XG4gICAgcmV0dXJuICh4IC0gMC41KSAqIDM2MDtcbn1cbmZ1bmN0aW9uIHlMYXQoeSkge1xuICAgIHZhciB5MiA9ICgxODAgLSB5ICogMzYwKSAqIE1hdGguUEkgLyAxODA7XG4gICAgcmV0dXJuIDM2MCAqIE1hdGguYXRhbihNYXRoLmV4cCh5MikpIC8gTWF0aC5QSSAtIDkwO1xufVxuXG4vLyBzcXVhcmVkIGRpc3RhbmNlIGJldHdlZW4gdHdvIHBvaW50c1xuZnVuY3Rpb24gZGlzdFNxKGEsIGIpIHtcbiAgICB2YXIgZHggPSBhLnd4IC0gYi53eDtcbiAgICB2YXIgZHkgPSBhLnd5IC0gYi53eTtcbiAgICByZXR1cm4gZHggKiBkeCArIGR5ICogZHk7XG59XG5cbmZ1bmN0aW9uIGV4dGVuZChkZXN0LCBzcmMpIHtcbiAgICBmb3IgKHZhciBpZCBpbiBzcmMpIGRlc3RbaWRdID0gc3JjW2lkXTtcbiAgICByZXR1cm4gZGVzdDtcbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKEMpIDIwMDggQXBwbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dFxuICogbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zXG4gKiBhcmUgbWV0OlxuICogMS4gUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHRcbiAqICAgIG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cbiAqIDIuIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmUgY29weXJpZ2h0XG4gKiAgICBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIgaW4gdGhlXG4gKiAgICBkb2N1bWVudGF0aW9uIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxuICpcbiAqIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgQVBQTEUgSU5DLiBgYEFTIElTJycgQU5EIEFOWVxuICogRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBUSEVcbiAqIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUlxuICogUFVSUE9TRSBBUkUgRElTQ0xBSU1FRC4gIElOIE5PIEVWRU5UIFNIQUxMIEFQUExFIElOQy4gT1JcbiAqIENPTlRSSUJVVE9SUyBCRSBMSUFCTEUgRk9SIEFOWSBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLCBTUEVDSUFMLFxuICogRVhFTVBMQVJZLCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLFxuICogUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUzsgTE9TUyBPRiBVU0UsIERBVEEsIE9SXG4gKiBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORCBPTiBBTlkgVEhFT1JZXG4gKiBPRiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlRcbiAqIChJTkNMVURJTkcgTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRVxuICogT0YgVEhJUyBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cbiAqXG4gKiBQb3J0ZWQgZnJvbSBXZWJraXRcbiAqIGh0dHA6Ly9zdm4ud2Via2l0Lm9yZy9yZXBvc2l0b3J5L3dlYmtpdC90cnVuay9Tb3VyY2UvV2ViQ29yZS9wbGF0Zm9ybS9ncmFwaGljcy9Vbml0QmV6aWVyLmhcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IFVuaXRCZXppZXI7XG5cbmZ1bmN0aW9uIFVuaXRCZXppZXIocDF4LCBwMXksIHAyeCwgcDJ5KSB7XG4gICAgLy8gQ2FsY3VsYXRlIHRoZSBwb2x5bm9taWFsIGNvZWZmaWNpZW50cywgaW1wbGljaXQgZmlyc3QgYW5kIGxhc3QgY29udHJvbCBwb2ludHMgYXJlICgwLDApIGFuZCAoMSwxKS5cbiAgICB0aGlzLmN4ID0gMy4wICogcDF4O1xuICAgIHRoaXMuYnggPSAzLjAgKiAocDJ4IC0gcDF4KSAtIHRoaXMuY3g7XG4gICAgdGhpcy5heCA9IDEuMCAtIHRoaXMuY3ggLSB0aGlzLmJ4O1xuXG4gICAgdGhpcy5jeSA9IDMuMCAqIHAxeTtcbiAgICB0aGlzLmJ5ID0gMy4wICogKHAyeSAtIHAxeSkgLSB0aGlzLmN5O1xuICAgIHRoaXMuYXkgPSAxLjAgLSB0aGlzLmN5IC0gdGhpcy5ieTtcblxuICAgIHRoaXMucDF4ID0gcDF4O1xuICAgIHRoaXMucDF5ID0gcDJ5O1xuICAgIHRoaXMucDJ4ID0gcDJ4O1xuICAgIHRoaXMucDJ5ID0gcDJ5O1xufVxuXG5Vbml0QmV6aWVyLnByb3RvdHlwZS5zYW1wbGVDdXJ2ZVggPSBmdW5jdGlvbih0KSB7XG4gICAgLy8gYGF4IHReMyArIGJ4IHReMiArIGN4IHQnIGV4cGFuZGVkIHVzaW5nIEhvcm5lcidzIHJ1bGUuXG4gICAgcmV0dXJuICgodGhpcy5heCAqIHQgKyB0aGlzLmJ4KSAqIHQgKyB0aGlzLmN4KSAqIHQ7XG59O1xuXG5Vbml0QmV6aWVyLnByb3RvdHlwZS5zYW1wbGVDdXJ2ZVkgPSBmdW5jdGlvbih0KSB7XG4gICAgcmV0dXJuICgodGhpcy5heSAqIHQgKyB0aGlzLmJ5KSAqIHQgKyB0aGlzLmN5KSAqIHQ7XG59O1xuXG5Vbml0QmV6aWVyLnByb3RvdHlwZS5zYW1wbGVDdXJ2ZURlcml2YXRpdmVYID0gZnVuY3Rpb24odCkge1xuICAgIHJldHVybiAoMy4wICogdGhpcy5heCAqIHQgKyAyLjAgKiB0aGlzLmJ4KSAqIHQgKyB0aGlzLmN4O1xufTtcblxuVW5pdEJlemllci5wcm90b3R5cGUuc29sdmVDdXJ2ZVggPSBmdW5jdGlvbih4LCBlcHNpbG9uKSB7XG4gICAgaWYgKHR5cGVvZiBlcHNpbG9uID09PSAndW5kZWZpbmVkJykgZXBzaWxvbiA9IDFlLTY7XG5cbiAgICB2YXIgdDAsIHQxLCB0MiwgeDIsIGk7XG5cbiAgICAvLyBGaXJzdCB0cnkgYSBmZXcgaXRlcmF0aW9ucyBvZiBOZXd0b24ncyBtZXRob2QgLS0gbm9ybWFsbHkgdmVyeSBmYXN0LlxuICAgIGZvciAodDIgPSB4LCBpID0gMDsgaSA8IDg7IGkrKykge1xuXG4gICAgICAgIHgyID0gdGhpcy5zYW1wbGVDdXJ2ZVgodDIpIC0geDtcbiAgICAgICAgaWYgKE1hdGguYWJzKHgyKSA8IGVwc2lsb24pIHJldHVybiB0MjtcblxuICAgICAgICB2YXIgZDIgPSB0aGlzLnNhbXBsZUN1cnZlRGVyaXZhdGl2ZVgodDIpO1xuICAgICAgICBpZiAoTWF0aC5hYnMoZDIpIDwgMWUtNikgYnJlYWs7XG5cbiAgICAgICAgdDIgPSB0MiAtIHgyIC8gZDI7XG4gICAgfVxuXG4gICAgLy8gRmFsbCBiYWNrIHRvIHRoZSBiaXNlY3Rpb24gbWV0aG9kIGZvciByZWxpYWJpbGl0eS5cbiAgICB0MCA9IDAuMDtcbiAgICB0MSA9IDEuMDtcbiAgICB0MiA9IHg7XG5cbiAgICBpZiAodDIgPCB0MCkgcmV0dXJuIHQwO1xuICAgIGlmICh0MiA+IHQxKSByZXR1cm4gdDE7XG5cbiAgICB3aGlsZSAodDAgPCB0MSkge1xuXG4gICAgICAgIHgyID0gdGhpcy5zYW1wbGVDdXJ2ZVgodDIpO1xuICAgICAgICBpZiAoTWF0aC5hYnMoeDIgLSB4KSA8IGVwc2lsb24pIHJldHVybiB0MjtcblxuICAgICAgICBpZiAoeCA+IHgyKSB7XG4gICAgICAgICAgICB0MCA9IHQyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdDEgPSB0MjtcbiAgICAgICAgfVxuXG4gICAgICAgIHQyID0gKHQxIC0gdDApICogMC41ICsgdDA7XG4gICAgfVxuXG4gICAgLy8gRmFpbHVyZS5cbiAgICByZXR1cm4gdDI7XG59O1xuXG5Vbml0QmV6aWVyLnByb3RvdHlwZS5zb2x2ZSA9IGZ1bmN0aW9uKHgsIGVwc2lsb24pIHtcbiAgICByZXR1cm4gdGhpcy5zYW1wbGVDdXJ2ZVkodGhpcy5zb2x2ZUN1cnZlWCh4LCBlcHNpbG9uKSk7XG59O1xuIiwibW9kdWxlLmV4cG9ydHMuVmVjdG9yVGlsZSA9IHJlcXVpcmUoJy4vbGliL3ZlY3RvcnRpbGUuanMnKTtcbm1vZHVsZS5leHBvcnRzLlZlY3RvclRpbGVGZWF0dXJlID0gcmVxdWlyZSgnLi9saWIvdmVjdG9ydGlsZWZlYXR1cmUuanMnKTtcbm1vZHVsZS5leHBvcnRzLlZlY3RvclRpbGVMYXllciA9IHJlcXVpcmUoJy4vbGliL3ZlY3RvcnRpbGVsYXllci5qcycpO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgVmVjdG9yVGlsZUxheWVyID0gcmVxdWlyZSgnLi92ZWN0b3J0aWxlbGF5ZXInKTtcblxubW9kdWxlLmV4cG9ydHMgPSBWZWN0b3JUaWxlO1xuXG5mdW5jdGlvbiBWZWN0b3JUaWxlKHBiZiwgZW5kKSB7XG4gICAgdGhpcy5sYXllcnMgPSBwYmYucmVhZEZpZWxkcyhyZWFkVGlsZSwge30sIGVuZCk7XG59XG5cbmZ1bmN0aW9uIHJlYWRUaWxlKHRhZywgbGF5ZXJzLCBwYmYpIHtcbiAgICBpZiAodGFnID09PSAzKSB7XG4gICAgICAgIHZhciBsYXllciA9IG5ldyBWZWN0b3JUaWxlTGF5ZXIocGJmLCBwYmYucmVhZFZhcmludCgpICsgcGJmLnBvcyk7XG4gICAgICAgIGlmIChsYXllci5sZW5ndGgpIGxheWVyc1tsYXllci5uYW1lXSA9IGxheWVyO1xuICAgIH1cbn1cblxuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgUG9pbnQgPSByZXF1aXJlKCdwb2ludC1nZW9tZXRyeScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFZlY3RvclRpbGVGZWF0dXJlO1xuXG5mdW5jdGlvbiBWZWN0b3JUaWxlRmVhdHVyZShwYmYsIGVuZCwgZXh0ZW50LCBrZXlzLCB2YWx1ZXMpIHtcbiAgICAvLyBQdWJsaWNcbiAgICB0aGlzLnByb3BlcnRpZXMgPSB7fTtcbiAgICB0aGlzLmV4dGVudCA9IGV4dGVudDtcbiAgICB0aGlzLnR5cGUgPSAwO1xuXG4gICAgLy8gUHJpdmF0ZVxuICAgIHRoaXMuX3BiZiA9IHBiZjtcbiAgICB0aGlzLl9nZW9tZXRyeSA9IC0xO1xuICAgIHRoaXMuX2tleXMgPSBrZXlzO1xuICAgIHRoaXMuX3ZhbHVlcyA9IHZhbHVlcztcblxuICAgIHBiZi5yZWFkRmllbGRzKHJlYWRGZWF0dXJlLCB0aGlzLCBlbmQpO1xufVxuXG5mdW5jdGlvbiByZWFkRmVhdHVyZSh0YWcsIGZlYXR1cmUsIHBiZikge1xuICAgIGlmICh0YWcgPT0gMSkgZmVhdHVyZS5faWQgPSBwYmYucmVhZFZhcmludCgpO1xuICAgIGVsc2UgaWYgKHRhZyA9PSAyKSByZWFkVGFnKHBiZiwgZmVhdHVyZSk7XG4gICAgZWxzZSBpZiAodGFnID09IDMpIGZlYXR1cmUudHlwZSA9IHBiZi5yZWFkVmFyaW50KCk7XG4gICAgZWxzZSBpZiAodGFnID09IDQpIGZlYXR1cmUuX2dlb21ldHJ5ID0gcGJmLnBvcztcbn1cblxuZnVuY3Rpb24gcmVhZFRhZyhwYmYsIGZlYXR1cmUpIHtcbiAgICB2YXIgZW5kID0gcGJmLnJlYWRWYXJpbnQoKSArIHBiZi5wb3M7XG5cbiAgICB3aGlsZSAocGJmLnBvcyA8IGVuZCkge1xuICAgICAgICB2YXIga2V5ID0gZmVhdHVyZS5fa2V5c1twYmYucmVhZFZhcmludCgpXSxcbiAgICAgICAgICAgIHZhbHVlID0gZmVhdHVyZS5fdmFsdWVzW3BiZi5yZWFkVmFyaW50KCldO1xuICAgICAgICBmZWF0dXJlLnByb3BlcnRpZXNba2V5XSA9IHZhbHVlO1xuICAgIH1cbn1cblxuVmVjdG9yVGlsZUZlYXR1cmUudHlwZXMgPSBbJ1Vua25vd24nLCAnUG9pbnQnLCAnTGluZVN0cmluZycsICdQb2x5Z29uJ107XG5cblZlY3RvclRpbGVGZWF0dXJlLnByb3RvdHlwZS5sb2FkR2VvbWV0cnkgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgcGJmID0gdGhpcy5fcGJmO1xuICAgIHBiZi5wb3MgPSB0aGlzLl9nZW9tZXRyeTtcblxuICAgIHZhciBlbmQgPSBwYmYucmVhZFZhcmludCgpICsgcGJmLnBvcyxcbiAgICAgICAgY21kID0gMSxcbiAgICAgICAgbGVuZ3RoID0gMCxcbiAgICAgICAgeCA9IDAsXG4gICAgICAgIHkgPSAwLFxuICAgICAgICBsaW5lcyA9IFtdLFxuICAgICAgICBsaW5lO1xuXG4gICAgd2hpbGUgKHBiZi5wb3MgPCBlbmQpIHtcbiAgICAgICAgaWYgKCFsZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciBjbWRMZW4gPSBwYmYucmVhZFZhcmludCgpO1xuICAgICAgICAgICAgY21kID0gY21kTGVuICYgMHg3O1xuICAgICAgICAgICAgbGVuZ3RoID0gY21kTGVuID4+IDM7XG4gICAgICAgIH1cblxuICAgICAgICBsZW5ndGgtLTtcblxuICAgICAgICBpZiAoY21kID09PSAxIHx8IGNtZCA9PT0gMikge1xuICAgICAgICAgICAgeCArPSBwYmYucmVhZFNWYXJpbnQoKTtcbiAgICAgICAgICAgIHkgKz0gcGJmLnJlYWRTVmFyaW50KCk7XG5cbiAgICAgICAgICAgIGlmIChjbWQgPT09IDEpIHsgLy8gbW92ZVRvXG4gICAgICAgICAgICAgICAgaWYgKGxpbmUpIGxpbmVzLnB1c2gobGluZSk7XG4gICAgICAgICAgICAgICAgbGluZSA9IFtdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsaW5lLnB1c2gobmV3IFBvaW50KHgsIHkpKTtcblxuICAgICAgICB9IGVsc2UgaWYgKGNtZCA9PT0gNykge1xuXG4gICAgICAgICAgICAvLyBXb3JrYXJvdW5kIGZvciBodHRwczovL2dpdGh1Yi5jb20vbWFwYm94L21hcG5pay12ZWN0b3ItdGlsZS9pc3N1ZXMvOTBcbiAgICAgICAgICAgIGlmIChsaW5lKSB7XG4gICAgICAgICAgICAgICAgbGluZS5wdXNoKGxpbmVbMF0uY2xvbmUoKSk7IC8vIGNsb3NlUG9seWdvblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Vua25vd24gY29tbWFuZCAnICsgY21kKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmIChsaW5lKSBsaW5lcy5wdXNoKGxpbmUpO1xuXG4gICAgcmV0dXJuIGxpbmVzO1xufTtcblxuVmVjdG9yVGlsZUZlYXR1cmUucHJvdG90eXBlLmJib3ggPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgcGJmID0gdGhpcy5fcGJmO1xuICAgIHBiZi5wb3MgPSB0aGlzLl9nZW9tZXRyeTtcblxuICAgIHZhciBlbmQgPSBwYmYucmVhZFZhcmludCgpICsgcGJmLnBvcyxcbiAgICAgICAgY21kID0gMSxcbiAgICAgICAgbGVuZ3RoID0gMCxcbiAgICAgICAgeCA9IDAsXG4gICAgICAgIHkgPSAwLFxuICAgICAgICB4MSA9IEluZmluaXR5LFxuICAgICAgICB4MiA9IC1JbmZpbml0eSxcbiAgICAgICAgeTEgPSBJbmZpbml0eSxcbiAgICAgICAgeTIgPSAtSW5maW5pdHk7XG5cbiAgICB3aGlsZSAocGJmLnBvcyA8IGVuZCkge1xuICAgICAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgICAgICAgdmFyIGNtZExlbiA9IHBiZi5yZWFkVmFyaW50KCk7XG4gICAgICAgICAgICBjbWQgPSBjbWRMZW4gJiAweDc7XG4gICAgICAgICAgICBsZW5ndGggPSBjbWRMZW4gPj4gMztcbiAgICAgICAgfVxuXG4gICAgICAgIGxlbmd0aC0tO1xuXG4gICAgICAgIGlmIChjbWQgPT09IDEgfHwgY21kID09PSAyKSB7XG4gICAgICAgICAgICB4ICs9IHBiZi5yZWFkU1ZhcmludCgpO1xuICAgICAgICAgICAgeSArPSBwYmYucmVhZFNWYXJpbnQoKTtcbiAgICAgICAgICAgIGlmICh4IDwgeDEpIHgxID0geDtcbiAgICAgICAgICAgIGlmICh4ID4geDIpIHgyID0geDtcbiAgICAgICAgICAgIGlmICh5IDwgeTEpIHkxID0geTtcbiAgICAgICAgICAgIGlmICh5ID4geTIpIHkyID0geTtcblxuICAgICAgICB9IGVsc2UgaWYgKGNtZCAhPT0gNykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bmtub3duIGNvbW1hbmQgJyArIGNtZCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gW3gxLCB5MSwgeDIsIHkyXTtcbn07XG5cblZlY3RvclRpbGVGZWF0dXJlLnByb3RvdHlwZS50b0dlb0pTT04gPSBmdW5jdGlvbih4LCB5LCB6KSB7XG4gICAgdmFyIHNpemUgPSB0aGlzLmV4dGVudCAqIE1hdGgucG93KDIsIHopLFxuICAgICAgICB4MCA9IHRoaXMuZXh0ZW50ICogeCxcbiAgICAgICAgeTAgPSB0aGlzLmV4dGVudCAqIHksXG4gICAgICAgIGNvb3JkcyA9IHRoaXMubG9hZEdlb21ldHJ5KCksXG4gICAgICAgIHR5cGUgPSBWZWN0b3JUaWxlRmVhdHVyZS50eXBlc1t0aGlzLnR5cGVdO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb29yZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGxpbmUgPSBjb29yZHNbaV07XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbGluZS5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgdmFyIHAgPSBsaW5lW2pdLCB5MiA9IDE4MCAtIChwLnkgKyB5MCkgKiAzNjAgLyBzaXplO1xuICAgICAgICAgICAgbGluZVtqXSA9IFtcbiAgICAgICAgICAgICAgICAocC54ICsgeDApICogMzYwIC8gc2l6ZSAtIDE4MCxcbiAgICAgICAgICAgICAgICAzNjAgLyBNYXRoLlBJICogTWF0aC5hdGFuKE1hdGguZXhwKHkyICogTWF0aC5QSSAvIDE4MCkpIC0gOTBcbiAgICAgICAgICAgIF07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodHlwZSA9PT0gJ1BvaW50JyAmJiBjb29yZHMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIGNvb3JkcyA9IGNvb3Jkc1swXVswXTtcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdQb2ludCcpIHtcbiAgICAgICAgY29vcmRzID0gY29vcmRzWzBdO1xuICAgICAgICB0eXBlID0gJ011bHRpUG9pbnQnO1xuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ0xpbmVTdHJpbmcnICYmIGNvb3Jkcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgY29vcmRzID0gY29vcmRzWzBdO1xuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ0xpbmVTdHJpbmcnKSB7XG4gICAgICAgIHR5cGUgPSAnTXVsdGlMaW5lU3RyaW5nJztcbiAgICB9XG5cbiAgICB2YXIgcmVzdWx0ID0ge1xuICAgICAgICB0eXBlOiBcIkZlYXR1cmVcIixcbiAgICAgICAgZ2VvbWV0cnk6IHtcbiAgICAgICAgICAgIHR5cGU6IHR5cGUsXG4gICAgICAgICAgICBjb29yZGluYXRlczogY29vcmRzXG4gICAgICAgIH0sXG4gICAgICAgIHByb3BlcnRpZXM6IHRoaXMucHJvcGVydGllc1xuICAgIH07XG5cbiAgICBpZiAoJ19pZCcgaW4gdGhpcykge1xuICAgICAgICByZXN1bHQuaWQgPSB0aGlzLl9pZDtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIFZlY3RvclRpbGVGZWF0dXJlID0gcmVxdWlyZSgnLi92ZWN0b3J0aWxlZmVhdHVyZS5qcycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFZlY3RvclRpbGVMYXllcjtcblxuZnVuY3Rpb24gVmVjdG9yVGlsZUxheWVyKHBiZiwgZW5kKSB7XG4gICAgLy8gUHVibGljXG4gICAgdGhpcy52ZXJzaW9uID0gMTtcbiAgICB0aGlzLm5hbWUgPSBudWxsO1xuICAgIHRoaXMuZXh0ZW50ID0gNDA5NjtcbiAgICB0aGlzLmxlbmd0aCA9IDA7XG5cbiAgICAvLyBQcml2YXRlXG4gICAgdGhpcy5fcGJmID0gcGJmO1xuICAgIHRoaXMuX2tleXMgPSBbXTtcbiAgICB0aGlzLl92YWx1ZXMgPSBbXTtcbiAgICB0aGlzLl9mZWF0dXJlcyA9IFtdO1xuXG4gICAgcGJmLnJlYWRGaWVsZHMocmVhZExheWVyLCB0aGlzLCBlbmQpO1xuXG4gICAgdGhpcy5sZW5ndGggPSB0aGlzLl9mZWF0dXJlcy5sZW5ndGg7XG59XG5cbmZ1bmN0aW9uIHJlYWRMYXllcih0YWcsIGxheWVyLCBwYmYpIHtcbiAgICBpZiAodGFnID09PSAxNSkgbGF5ZXIudmVyc2lvbiA9IHBiZi5yZWFkVmFyaW50KCk7XG4gICAgZWxzZSBpZiAodGFnID09PSAxKSBsYXllci5uYW1lID0gcGJmLnJlYWRTdHJpbmcoKTtcbiAgICBlbHNlIGlmICh0YWcgPT09IDUpIGxheWVyLmV4dGVudCA9IHBiZi5yZWFkVmFyaW50KCk7XG4gICAgZWxzZSBpZiAodGFnID09PSAyKSBsYXllci5fZmVhdHVyZXMucHVzaChwYmYucG9zKTtcbiAgICBlbHNlIGlmICh0YWcgPT09IDMpIGxheWVyLl9rZXlzLnB1c2gocGJmLnJlYWRTdHJpbmcoKSk7XG4gICAgZWxzZSBpZiAodGFnID09PSA0KSBsYXllci5fdmFsdWVzLnB1c2gocmVhZFZhbHVlTWVzc2FnZShwYmYpKTtcbn1cblxuZnVuY3Rpb24gcmVhZFZhbHVlTWVzc2FnZShwYmYpIHtcbiAgICB2YXIgdmFsdWUgPSBudWxsLFxuICAgICAgICBlbmQgPSBwYmYucmVhZFZhcmludCgpICsgcGJmLnBvcztcblxuICAgIHdoaWxlIChwYmYucG9zIDwgZW5kKSB7XG4gICAgICAgIHZhciB0YWcgPSBwYmYucmVhZFZhcmludCgpID4+IDM7XG5cbiAgICAgICAgdmFsdWUgPSB0YWcgPT09IDEgPyBwYmYucmVhZFN0cmluZygpIDpcbiAgICAgICAgICAgIHRhZyA9PT0gMiA/IHBiZi5yZWFkRmxvYXQoKSA6XG4gICAgICAgICAgICB0YWcgPT09IDMgPyBwYmYucmVhZERvdWJsZSgpIDpcbiAgICAgICAgICAgIHRhZyA9PT0gNCA/IHBiZi5yZWFkVmFyaW50NjQoKSA6XG4gICAgICAgICAgICB0YWcgPT09IDUgPyBwYmYucmVhZFZhcmludCgpIDpcbiAgICAgICAgICAgIHRhZyA9PT0gNiA/IHBiZi5yZWFkU1ZhcmludCgpIDpcbiAgICAgICAgICAgIHRhZyA9PT0gNyA/IHBiZi5yZWFkQm9vbGVhbigpIDogbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gdmFsdWU7XG59XG5cbi8vIHJldHVybiBmZWF0dXJlIGBpYCBmcm9tIHRoaXMgbGF5ZXIgYXMgYSBgVmVjdG9yVGlsZUZlYXR1cmVgXG5WZWN0b3JUaWxlTGF5ZXIucHJvdG90eXBlLmZlYXR1cmUgPSBmdW5jdGlvbihpKSB7XG4gICAgaWYgKGkgPCAwIHx8IGkgPj0gdGhpcy5fZmVhdHVyZXMubGVuZ3RoKSB0aHJvdyBuZXcgRXJyb3IoJ2ZlYXR1cmUgaW5kZXggb3V0IG9mIGJvdW5kcycpO1xuXG4gICAgdGhpcy5fcGJmLnBvcyA9IHRoaXMuX2ZlYXR1cmVzW2ldO1xuXG4gICAgdmFyIGVuZCA9IHRoaXMuX3BiZi5yZWFkVmFyaW50KCkgKyB0aGlzLl9wYmYucG9zO1xuICAgIHJldHVybiBuZXcgVmVjdG9yVGlsZUZlYXR1cmUodGhpcy5fcGJmLCBlbmQsIHRoaXMuZXh0ZW50LCB0aGlzLl9rZXlzLCB0aGlzLl92YWx1ZXMpO1xufTtcbiIsInZhciBQYmYgPSByZXF1aXJlKCdwYmYnKVxudmFyIHZ0cGIgPSByZXF1aXJlKCcuL3ZlY3Rvci10aWxlLXBiJylcbnZhciBHZW9KU09OV3JhcHBlciA9IHJlcXVpcmUoJy4vbGliL2dlb2pzb25fd3JhcHBlcicpXG5cbm1vZHVsZS5leHBvcnRzID0gZnJvbVZlY3RvclRpbGVKc1xubW9kdWxlLmV4cG9ydHMuZnJvbVZlY3RvclRpbGVKcyA9IGZyb21WZWN0b3JUaWxlSnNcbm1vZHVsZS5leHBvcnRzLmZyb21HZW9qc29uVnQgPSBmcm9tR2VvanNvblZ0XG5tb2R1bGUuZXhwb3J0cy5HZW9KU09OV3JhcHBlciA9IEdlb0pTT05XcmFwcGVyXG5cbi8qKlxuICogU2VyaWFsaXplIGEgdmVjdG9yLXRpbGUtanMtY3JlYXRlZCB0aWxlIHRvIHBiZlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB0aWxlXG4gKiBAcmV0dXJuIHtCdWZmZXJ9IHVuY29tcHJlc3NlZCwgcGJmLXNlcmlhbGl6ZWQgdGlsZSBkYXRhXG4gKi9cbmZ1bmN0aW9uIGZyb21WZWN0b3JUaWxlSnMgKHRpbGUpIHtcbiAgdmFyIGxheWVycyA9IFtdXG4gIGZvciAodmFyIGwgaW4gdGlsZS5sYXllcnMpIHtcbiAgICBsYXllcnMucHVzaChwcmVwYXJlTGF5ZXIodGlsZS5sYXllcnNbbF0pKVxuICB9XG5cbiAgdmFyIG91dCA9IG5ldyBQYmYoKVxuICB2dHBiLnRpbGUud3JpdGUoeyBsYXllcnM6IGxheWVycyB9LCBvdXQpXG4gIHJldHVybiBvdXQuZmluaXNoKClcbn1cblxuLyoqXG4gKiBTZXJpYWxpemVkIGEgZ2VvanNvbi12dC1jcmVhdGVkIHRpbGUgdG8gcGJmLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBsYXllcnMgLSBBbiBvYmplY3QgbWFwcGluZyBsYXllciBuYW1lcyB0byBnZW9qc29uLXZ0LWNyZWF0ZWQgdmVjdG9yIHRpbGUgb2JqZWN0c1xuICogQHJldHVybiB7QnVmZmVyfSB1bmNvbXByZXNzZWQsIHBiZi1zZXJpYWxpemVkIHRpbGUgZGF0YVxuICovXG5mdW5jdGlvbiBmcm9tR2VvanNvblZ0IChsYXllcnMpIHtcbiAgdmFyIGwgPSB7fVxuICBmb3IgKHZhciBrIGluIGxheWVycykge1xuICAgIGxba10gPSBuZXcgR2VvSlNPTldyYXBwZXIobGF5ZXJzW2tdLmZlYXR1cmVzKVxuICAgIGxba10ubmFtZSA9IGtcbiAgfVxuICByZXR1cm4gZnJvbVZlY3RvclRpbGVKcyh7bGF5ZXJzOiBsfSlcbn1cblxuLyoqXG4gKiBQcmVwYXJlIHRoZSBnaXZlbiBsYXllciB0byBiZSBzZXJpYWxpemVkIGJ5IHRoZSBhdXRvLWdlbmVyYXRlZCBwYmZcbiAqIHNlcmlhbGl6ZXIgYnkgZW5jb2RpbmcgdGhlIGZlYXR1cmUgZ2VvbWV0cnkgYW5kIHByb3BlcnRpZXMuXG4gKi9cbmZ1bmN0aW9uIHByZXBhcmVMYXllciAobGF5ZXIpIHtcbiAgdmFyIHByZXBhcmVkTGF5ZXIgPSB7XG4gICAgbmFtZTogbGF5ZXIubmFtZSB8fCAnJyxcbiAgICB2ZXJzaW9uOiBsYXllci52ZXJzaW9uIHx8IDEsXG4gICAgZXh0ZW50OiBsYXllci5leHRlbnQgfHwgNDA5NixcbiAgICBrZXlzOiBbXSxcbiAgICB2YWx1ZXM6IFtdLFxuICAgIGZlYXR1cmVzOiBbXVxuICB9XG5cbiAgdmFyIGtleWNhY2hlID0ge31cbiAgdmFyIHZhbHVlY2FjaGUgPSB7fVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGF5ZXIubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZmVhdHVyZSA9IGxheWVyLmZlYXR1cmUoaSlcbiAgICBmZWF0dXJlLmdlb21ldHJ5ID0gZW5jb2RlR2VvbWV0cnkoZmVhdHVyZS5sb2FkR2VvbWV0cnkoKSlcblxuICAgIHZhciB0YWdzID0gW11cbiAgICBmb3IgKHZhciBrZXkgaW4gZmVhdHVyZS5wcm9wZXJ0aWVzKSB7XG4gICAgICB2YXIga2V5SW5kZXggPSBrZXljYWNoZVtrZXldXG4gICAgICBpZiAodHlwZW9mIGtleUluZGV4ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICBwcmVwYXJlZExheWVyLmtleXMucHVzaChrZXkpXG4gICAgICAgIGtleUluZGV4ID0gcHJlcGFyZWRMYXllci5rZXlzLmxlbmd0aCAtIDFcbiAgICAgICAga2V5Y2FjaGVba2V5XSA9IGtleUluZGV4XG4gICAgICB9XG4gICAgICB2YXIgdmFsdWUgPSB3cmFwVmFsdWUoZmVhdHVyZS5wcm9wZXJ0aWVzW2tleV0pXG4gICAgICB2YXIgdmFsdWVJbmRleCA9IHZhbHVlY2FjaGVbdmFsdWUua2V5XVxuICAgICAgaWYgKHR5cGVvZiB2YWx1ZUluZGV4ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICBwcmVwYXJlZExheWVyLnZhbHVlcy5wdXNoKHZhbHVlKVxuICAgICAgICB2YWx1ZUluZGV4ID0gcHJlcGFyZWRMYXllci52YWx1ZXMubGVuZ3RoIC0gMVxuICAgICAgICB2YWx1ZWNhY2hlW3ZhbHVlLmtleV0gPSB2YWx1ZUluZGV4XG4gICAgICB9XG4gICAgICB0YWdzLnB1c2goa2V5SW5kZXgpXG4gICAgICB0YWdzLnB1c2godmFsdWVJbmRleClcbiAgICB9XG5cbiAgICBmZWF0dXJlLnRhZ3MgPSB0YWdzXG4gICAgcHJlcGFyZWRMYXllci5mZWF0dXJlcy5wdXNoKGZlYXR1cmUpXG4gIH1cblxuICByZXR1cm4gcHJlcGFyZWRMYXllclxufVxuXG5mdW5jdGlvbiBjb21tYW5kIChjbWQsIGxlbmd0aCkge1xuICByZXR1cm4gKGxlbmd0aCA8PCAzKSArIChjbWQgJiAweDcpXG59XG5cbmZ1bmN0aW9uIHppZ3phZyAobnVtKSB7XG4gIHJldHVybiAobnVtIDw8IDEpIF4gKG51bSA+PiAzMSlcbn1cblxuLyoqXG4gKiBFbmNvZGUgYSBwb2x5Z29uJ3MgZ2VvbWV0cnkgaW50byBhbiBhcnJheSByZWFkeSB0byBiZSBzZXJpYWxpemVkXG4gKiB0byBtYXBib3ggdmVjdG9yIHRpbGUgc3BlY2lmaWVkIGdlb21ldHJ5IGRhdGEuXG4gKlxuICogQHBhcmFtIHtBcnJheX0gUmluZ3MsIGVhY2ggYmVpbmcgYW4gYXJyYXkgb2YgW3gsIHldIHRpbGUtc3BhY2UgY29vcmRpbmF0ZXNcbiAqIEByZXR1cm4ge0FycmF5fSBlbmNvZGVkIGdlb21ldHJ5XG4gKi9cbmZ1bmN0aW9uIGVuY29kZUdlb21ldHJ5IChnZW9tZXRyeSkge1xuICB2YXIgZW5jb2RlZCA9IFtdXG4gIHZhciB4ID0gMFxuICB2YXIgeSA9IDBcbiAgdmFyIHJpbmdzID0gZ2VvbWV0cnkubGVuZ3RoXG4gIGZvciAodmFyIHIgPSAwOyByIDwgcmluZ3M7IHIrKykge1xuICAgIHZhciByaW5nID0gZ2VvbWV0cnlbcl1cbiAgICBlbmNvZGVkLnB1c2goY29tbWFuZCgxLCAxKSkgLy8gbW92ZXRvXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCByaW5nLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoaSA9PT0gMSkge1xuICAgICAgICBlbmNvZGVkLnB1c2goY29tbWFuZCgyLCByaW5nLmxlbmd0aCAtIDEpKSAvLyBsaW5ldG9cbiAgICAgIH1cbiAgICAgIHZhciBkeCA9IHJpbmdbaV0ueCAtIHhcbiAgICAgIHZhciBkeSA9IHJpbmdbaV0ueSAtIHlcbiAgICAgIGVuY29kZWQucHVzaCh6aWd6YWcoZHgpLCB6aWd6YWcoZHkpKVxuICAgICAgeCArPSBkeFxuICAgICAgeSArPSBkeVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBlbmNvZGVkXG59XG5cbi8qKlxuICogV3JhcCBhIHByb3BlcnR5IHZhbHVlIGFjY29yZGluZyB0byBpdHMgdHlwZS4gVGhlIHJldHVybmVkIG9iamVjdFxuICogaXMgb2YgdGhlIGZvcm0geyB4eHh4X3ZhbHVlOiBwcmltaXRpdmVWYWx1ZSB9LCB3aGljaCBpcyB3aGF0IHRoZSBnZW5lcmF0ZWRcbiAqIHByb3RvYnVmIHNlcmlhbGl6ZXIgZXhwZWN0cy5cbiAqL1xuZnVuY3Rpb24gd3JhcFZhbHVlICh2YWx1ZSkge1xuICB2YXIgcmVzdWx0XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlXG4gIGlmICh0eXBlID09PSAnc3RyaW5nJykge1xuICAgIHJlc3VsdCA9IHsgc3RyaW5nX3ZhbHVlOiB2YWx1ZSB9XG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgcmVzdWx0ID0geyBib29sX3ZhbHVlOiB2YWx1ZSB9XG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gJ251bWJlcicpIHtcbiAgICBpZiAodmFsdWUgIT09ICh2YWx1ZSB8IDApKSB7XG4gICAgICByZXN1bHQgPSB7IGZsb2F0X3ZhbHVlOiB2YWx1ZSB9XG4gICAgfSBlbHNlIGlmICh2YWx1ZSA8IDApIHtcbiAgICAgIHJlc3VsdCA9IHsgc2ludF92YWx1ZTogdmFsdWUgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQgPSB7IHVpbnRfdmFsdWU6IHZhbHVlIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcmVzdWx0ID0geyBzdHJpbmdfdmFsdWU6ICcnICsgdmFsdWUgfVxuICB9XG5cbiAgcmVzdWx0LmtleSA9IHR5cGUgKyAnOicgKyB2YWx1ZVxuICByZXR1cm4gcmVzdWx0XG59XG4iLCIndXNlIHN0cmljdCdcblxudmFyIFBvaW50ID0gcmVxdWlyZSgncG9pbnQtZ2VvbWV0cnknKVxudmFyIFZlY3RvclRpbGVGZWF0dXJlID0gcmVxdWlyZSgndmVjdG9yLXRpbGUnKS5WZWN0b3JUaWxlRmVhdHVyZVxuXG5tb2R1bGUuZXhwb3J0cyA9IEdlb0pTT05XcmFwcGVyXG5cbi8vIGNvbmZvcm0gdG8gdmVjdG9ydGlsZSBhcGlcbmZ1bmN0aW9uIEdlb0pTT05XcmFwcGVyIChmZWF0dXJlcykge1xuICB0aGlzLmZlYXR1cmVzID0gZmVhdHVyZXNcbiAgdGhpcy5sZW5ndGggPSBmZWF0dXJlcy5sZW5ndGhcbn1cblxuR2VvSlNPTldyYXBwZXIucHJvdG90eXBlLmZlYXR1cmUgPSBmdW5jdGlvbiAoaSkge1xuICByZXR1cm4gbmV3IEZlYXR1cmVXcmFwcGVyKHRoaXMuZmVhdHVyZXNbaV0pXG59XG5cbmZ1bmN0aW9uIEZlYXR1cmVXcmFwcGVyIChmZWF0dXJlKSB7XG4gIHRoaXMudHlwZSA9IGZlYXR1cmUudHlwZVxuICB0aGlzLnJhd0dlb21ldHJ5ID0gZmVhdHVyZS50eXBlID09PSAxID8gW2ZlYXR1cmUuZ2VvbWV0cnldIDogZmVhdHVyZS5nZW9tZXRyeVxuICB0aGlzLnByb3BlcnRpZXMgPSBmZWF0dXJlLnRhZ3NcbiAgdGhpcy5leHRlbnQgPSA0MDk2XG59XG5cbkZlYXR1cmVXcmFwcGVyLnByb3RvdHlwZS5sb2FkR2VvbWV0cnkgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciByaW5ncyA9IHRoaXMucmF3R2VvbWV0cnlcbiAgdGhpcy5nZW9tZXRyeSA9IFtdXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCByaW5ncy5sZW5ndGg7IGkrKykge1xuICAgIHZhciByaW5nID0gcmluZ3NbaV1cbiAgICB2YXIgbmV3UmluZyA9IFtdXG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCByaW5nLmxlbmd0aDsgaisrKSB7XG4gICAgICBuZXdSaW5nLnB1c2gobmV3IFBvaW50KHJpbmdbal1bMF0sIHJpbmdbal1bMV0pKVxuICAgIH1cbiAgICB0aGlzLmdlb21ldHJ5LnB1c2gobmV3UmluZylcbiAgfVxuICByZXR1cm4gdGhpcy5nZW9tZXRyeVxufVxuXG5GZWF0dXJlV3JhcHBlci5wcm90b3R5cGUuYmJveCA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKCF0aGlzLmdlb21ldHJ5KSB0aGlzLmxvYWRHZW9tZXRyeSgpXG5cbiAgdmFyIHJpbmdzID0gdGhpcy5nZW9tZXRyeVxuICB2YXIgeDEgPSBJbmZpbml0eVxuICB2YXIgeDIgPSAtSW5maW5pdHlcbiAgdmFyIHkxID0gSW5maW5pdHlcbiAgdmFyIHkyID0gLUluZmluaXR5XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCByaW5ncy5sZW5ndGg7IGkrKykge1xuICAgIHZhciByaW5nID0gcmluZ3NbaV1cblxuICAgIGZvciAodmFyIGogPSAwOyBqIDwgcmluZy5sZW5ndGg7IGorKykge1xuICAgICAgdmFyIGNvb3JkID0gcmluZ1tqXVxuXG4gICAgICB4MSA9IE1hdGgubWluKHgxLCBjb29yZC54KVxuICAgICAgeDIgPSBNYXRoLm1heCh4MiwgY29vcmQueClcbiAgICAgIHkxID0gTWF0aC5taW4oeTEsIGNvb3JkLnkpXG4gICAgICB5MiA9IE1hdGgubWF4KHkyLCBjb29yZC55KVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBbeDEsIHkxLCB4MiwgeTJdXG59XG5cbkZlYXR1cmVXcmFwcGVyLnByb3RvdHlwZS50b0dlb0pTT04gPSBWZWN0b3JUaWxlRmVhdHVyZS5wcm90b3R5cGUudG9HZW9KU09OXG4iLCIndXNlIHN0cmljdCc7XG5cbi8vIHRpbGUgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG52YXIgdGlsZSA9IGV4cG9ydHMudGlsZSA9IHtyZWFkOiByZWFkVGlsZSwgd3JpdGU6IHdyaXRlVGlsZX07XG5cbnRpbGUuR2VvbVR5cGUgPSB7XG4gICAgXCJVbmtub3duXCI6IDAsXG4gICAgXCJQb2ludFwiOiAxLFxuICAgIFwiTGluZVN0cmluZ1wiOiAyLFxuICAgIFwiUG9seWdvblwiOiAzXG59O1xuXG5mdW5jdGlvbiByZWFkVGlsZShwYmYsIGVuZCkge1xuICAgIHJldHVybiBwYmYucmVhZEZpZWxkcyhyZWFkVGlsZUZpZWxkLCB7XCJsYXllcnNcIjogW119LCBlbmQpO1xufVxuXG5mdW5jdGlvbiByZWFkVGlsZUZpZWxkKHRhZywgdGlsZSwgcGJmKSB7XG4gICAgaWYgKHRhZyA9PT0gMykgdGlsZS5sYXllcnMucHVzaChyZWFkTGF5ZXIocGJmLCBwYmYucmVhZFZhcmludCgpICsgcGJmLnBvcykpO1xufVxuXG5mdW5jdGlvbiB3cml0ZVRpbGUodGlsZSwgcGJmKSB7XG4gICAgdmFyIGk7XG4gICAgaWYgKHRpbGUubGF5ZXJzICE9PSB1bmRlZmluZWQpIGZvciAoaSA9IDA7IGkgPCB0aWxlLmxheWVycy5sZW5ndGg7IGkrKykgcGJmLndyaXRlTWVzc2FnZSgzLCB3cml0ZUxheWVyLCB0aWxlLmxheWVyc1tpXSk7XG59XG5cbi8vIHZhbHVlID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxudGlsZS52YWx1ZSA9IHtyZWFkOiByZWFkVmFsdWUsIHdyaXRlOiB3cml0ZVZhbHVlfTtcblxuZnVuY3Rpb24gcmVhZFZhbHVlKHBiZiwgZW5kKSB7XG4gICAgcmV0dXJuIHBiZi5yZWFkRmllbGRzKHJlYWRWYWx1ZUZpZWxkLCB7fSwgZW5kKTtcbn1cblxuZnVuY3Rpb24gcmVhZFZhbHVlRmllbGQodGFnLCB2YWx1ZSwgcGJmKSB7XG4gICAgaWYgKHRhZyA9PT0gMSkgdmFsdWUuc3RyaW5nX3ZhbHVlID0gcGJmLnJlYWRTdHJpbmcoKTtcbiAgICBlbHNlIGlmICh0YWcgPT09IDIpIHZhbHVlLmZsb2F0X3ZhbHVlID0gcGJmLnJlYWRGbG9hdCgpO1xuICAgIGVsc2UgaWYgKHRhZyA9PT0gMykgdmFsdWUuZG91YmxlX3ZhbHVlID0gcGJmLnJlYWREb3VibGUoKTtcbiAgICBlbHNlIGlmICh0YWcgPT09IDQpIHZhbHVlLmludF92YWx1ZSA9IHBiZi5yZWFkVmFyaW50KCk7XG4gICAgZWxzZSBpZiAodGFnID09PSA1KSB2YWx1ZS51aW50X3ZhbHVlID0gcGJmLnJlYWRWYXJpbnQoKTtcbiAgICBlbHNlIGlmICh0YWcgPT09IDYpIHZhbHVlLnNpbnRfdmFsdWUgPSBwYmYucmVhZFNWYXJpbnQoKTtcbiAgICBlbHNlIGlmICh0YWcgPT09IDcpIHZhbHVlLmJvb2xfdmFsdWUgPSBwYmYucmVhZEJvb2xlYW4oKTtcbn1cblxuZnVuY3Rpb24gd3JpdGVWYWx1ZSh2YWx1ZSwgcGJmKSB7XG4gICAgaWYgKHZhbHVlLnN0cmluZ192YWx1ZSAhPT0gdW5kZWZpbmVkKSBwYmYud3JpdGVTdHJpbmdGaWVsZCgxLCB2YWx1ZS5zdHJpbmdfdmFsdWUpO1xuICAgIGlmICh2YWx1ZS5mbG9hdF92YWx1ZSAhPT0gdW5kZWZpbmVkKSBwYmYud3JpdGVGbG9hdEZpZWxkKDIsIHZhbHVlLmZsb2F0X3ZhbHVlKTtcbiAgICBpZiAodmFsdWUuZG91YmxlX3ZhbHVlICE9PSB1bmRlZmluZWQpIHBiZi53cml0ZURvdWJsZUZpZWxkKDMsIHZhbHVlLmRvdWJsZV92YWx1ZSk7XG4gICAgaWYgKHZhbHVlLmludF92YWx1ZSAhPT0gdW5kZWZpbmVkKSBwYmYud3JpdGVWYXJpbnRGaWVsZCg0LCB2YWx1ZS5pbnRfdmFsdWUpO1xuICAgIGlmICh2YWx1ZS51aW50X3ZhbHVlICE9PSB1bmRlZmluZWQpIHBiZi53cml0ZVZhcmludEZpZWxkKDUsIHZhbHVlLnVpbnRfdmFsdWUpO1xuICAgIGlmICh2YWx1ZS5zaW50X3ZhbHVlICE9PSB1bmRlZmluZWQpIHBiZi53cml0ZVNWYXJpbnRGaWVsZCg2LCB2YWx1ZS5zaW50X3ZhbHVlKTtcbiAgICBpZiAodmFsdWUuYm9vbF92YWx1ZSAhPT0gdW5kZWZpbmVkKSBwYmYud3JpdGVCb29sZWFuRmllbGQoNywgdmFsdWUuYm9vbF92YWx1ZSk7XG59XG5cbi8vIGZlYXR1cmUgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG50aWxlLmZlYXR1cmUgPSB7cmVhZDogcmVhZEZlYXR1cmUsIHdyaXRlOiB3cml0ZUZlYXR1cmV9O1xuXG5mdW5jdGlvbiByZWFkRmVhdHVyZShwYmYsIGVuZCkge1xuICAgIHZhciBmZWF0dXJlID0gcGJmLnJlYWRGaWVsZHMocmVhZEZlYXR1cmVGaWVsZCwge30sIGVuZCk7XG4gICAgaWYgKGZlYXR1cmUudHlwZSA9PT0gdW5kZWZpbmVkKSBmZWF0dXJlLnR5cGUgPSBcIlVua25vd25cIjtcbiAgICByZXR1cm4gZmVhdHVyZTtcbn1cblxuZnVuY3Rpb24gcmVhZEZlYXR1cmVGaWVsZCh0YWcsIGZlYXR1cmUsIHBiZikge1xuICAgIGlmICh0YWcgPT09IDEpIGZlYXR1cmUuaWQgPSBwYmYucmVhZFZhcmludCgpO1xuICAgIGVsc2UgaWYgKHRhZyA9PT0gMikgZmVhdHVyZS50YWdzID0gcGJmLnJlYWRQYWNrZWRWYXJpbnQoKTtcbiAgICBlbHNlIGlmICh0YWcgPT09IDMpIGZlYXR1cmUudHlwZSA9IHBiZi5yZWFkVmFyaW50KCk7XG4gICAgZWxzZSBpZiAodGFnID09PSA0KSBmZWF0dXJlLmdlb21ldHJ5ID0gcGJmLnJlYWRQYWNrZWRWYXJpbnQoKTtcbn1cblxuZnVuY3Rpb24gd3JpdGVGZWF0dXJlKGZlYXR1cmUsIHBiZikge1xuICAgIGlmIChmZWF0dXJlLmlkICE9PSB1bmRlZmluZWQpIHBiZi53cml0ZVZhcmludEZpZWxkKDEsIGZlYXR1cmUuaWQpO1xuICAgIGlmIChmZWF0dXJlLnRhZ3MgIT09IHVuZGVmaW5lZCkgcGJmLndyaXRlUGFja2VkVmFyaW50KDIsIGZlYXR1cmUudGFncyk7XG4gICAgaWYgKGZlYXR1cmUudHlwZSAhPT0gdW5kZWZpbmVkKSBwYmYud3JpdGVWYXJpbnRGaWVsZCgzLCBmZWF0dXJlLnR5cGUpO1xuICAgIGlmIChmZWF0dXJlLmdlb21ldHJ5ICE9PSB1bmRlZmluZWQpIHBiZi53cml0ZVBhY2tlZFZhcmludCg0LCBmZWF0dXJlLmdlb21ldHJ5KTtcbn1cblxuLy8gbGF5ZXIgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG50aWxlLmxheWVyID0ge3JlYWQ6IHJlYWRMYXllciwgd3JpdGU6IHdyaXRlTGF5ZXJ9O1xuXG5mdW5jdGlvbiByZWFkTGF5ZXIocGJmLCBlbmQpIHtcbiAgICByZXR1cm4gcGJmLnJlYWRGaWVsZHMocmVhZExheWVyRmllbGQsIHtcImZlYXR1cmVzXCI6IFtdLCBcImtleXNcIjogW10sIFwidmFsdWVzXCI6IFtdfSwgZW5kKTtcbn1cblxuZnVuY3Rpb24gcmVhZExheWVyRmllbGQodGFnLCBsYXllciwgcGJmKSB7XG4gICAgaWYgKHRhZyA9PT0gMTUpIGxheWVyLnZlcnNpb24gPSBwYmYucmVhZFZhcmludCgpO1xuICAgIGVsc2UgaWYgKHRhZyA9PT0gMSkgbGF5ZXIubmFtZSA9IHBiZi5yZWFkU3RyaW5nKCk7XG4gICAgZWxzZSBpZiAodGFnID09PSAyKSBsYXllci5mZWF0dXJlcy5wdXNoKHJlYWRGZWF0dXJlKHBiZiwgcGJmLnJlYWRWYXJpbnQoKSArIHBiZi5wb3MpKTtcbiAgICBlbHNlIGlmICh0YWcgPT09IDMpIGxheWVyLmtleXMucHVzaChwYmYucmVhZFN0cmluZygpKTtcbiAgICBlbHNlIGlmICh0YWcgPT09IDQpIGxheWVyLnZhbHVlcy5wdXNoKHJlYWRWYWx1ZShwYmYsIHBiZi5yZWFkVmFyaW50KCkgKyBwYmYucG9zKSk7XG4gICAgZWxzZSBpZiAodGFnID09PSA1KSBsYXllci5leHRlbnQgPSBwYmYucmVhZFZhcmludCgpO1xufVxuXG5mdW5jdGlvbiB3cml0ZUxheWVyKGxheWVyLCBwYmYpIHtcbiAgICBpZiAobGF5ZXIudmVyc2lvbiAhPT0gdW5kZWZpbmVkKSBwYmYud3JpdGVWYXJpbnRGaWVsZCgxNSwgbGF5ZXIudmVyc2lvbik7XG4gICAgaWYgKGxheWVyLm5hbWUgIT09IHVuZGVmaW5lZCkgcGJmLndyaXRlU3RyaW5nRmllbGQoMSwgbGF5ZXIubmFtZSk7XG4gICAgdmFyIGk7XG4gICAgaWYgKGxheWVyLmZlYXR1cmVzICE9PSB1bmRlZmluZWQpIGZvciAoaSA9IDA7IGkgPCBsYXllci5mZWF0dXJlcy5sZW5ndGg7IGkrKykgcGJmLndyaXRlTWVzc2FnZSgyLCB3cml0ZUZlYXR1cmUsIGxheWVyLmZlYXR1cmVzW2ldKTtcbiAgICBpZiAobGF5ZXIua2V5cyAhPT0gdW5kZWZpbmVkKSBmb3IgKGkgPSAwOyBpIDwgbGF5ZXIua2V5cy5sZW5ndGg7IGkrKykgcGJmLndyaXRlU3RyaW5nRmllbGQoMywgbGF5ZXIua2V5c1tpXSk7XG4gICAgaWYgKGxheWVyLnZhbHVlcyAhPT0gdW5kZWZpbmVkKSBmb3IgKGkgPSAwOyBpIDwgbGF5ZXIudmFsdWVzLmxlbmd0aDsgaSsrKSBwYmYud3JpdGVNZXNzYWdlKDQsIHdyaXRlVmFsdWUsIGxheWVyLnZhbHVlc1tpXSk7XG4gICAgaWYgKGxheWVyLmV4dGVudCAhPT0gdW5kZWZpbmVkKSBwYmYud3JpdGVWYXJpbnRGaWVsZCg1LCBsYXllci5leHRlbnQpO1xufVxuIiwidmFyIGJ1bmRsZUZuID0gYXJndW1lbnRzWzNdO1xudmFyIHNvdXJjZXMgPSBhcmd1bWVudHNbNF07XG52YXIgY2FjaGUgPSBhcmd1bWVudHNbNV07XG5cbnZhciBzdHJpbmdpZnkgPSBKU09OLnN0cmluZ2lmeTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZm4pIHtcbiAgICB2YXIga2V5cyA9IFtdO1xuICAgIHZhciB3a2V5O1xuICAgIHZhciBjYWNoZUtleXMgPSBPYmplY3Qua2V5cyhjYWNoZSk7XG5cbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IGNhY2hlS2V5cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgdmFyIGtleSA9IGNhY2hlS2V5c1tpXTtcbiAgICAgICAgdmFyIGV4cCA9IGNhY2hlW2tleV0uZXhwb3J0cztcbiAgICAgICAgLy8gVXNpbmcgYmFiZWwgYXMgYSB0cmFuc3BpbGVyIHRvIHVzZSBlc21vZHVsZSwgdGhlIGV4cG9ydCB3aWxsIGFsd2F5c1xuICAgICAgICAvLyBiZSBhbiBvYmplY3Qgd2l0aCB0aGUgZGVmYXVsdCBleHBvcnQgYXMgYSBwcm9wZXJ0eSBvZiBpdC4gVG8gZW5zdXJlXG4gICAgICAgIC8vIHRoZSBleGlzdGluZyBhcGkgYW5kIGJhYmVsIGVzbW9kdWxlIGV4cG9ydHMgYXJlIGJvdGggc3VwcG9ydGVkIHdlXG4gICAgICAgIC8vIGNoZWNrIGZvciBib3RoXG4gICAgICAgIGlmIChleHAgPT09IGZuIHx8IGV4cC5kZWZhdWx0ID09PSBmbikge1xuICAgICAgICAgICAgd2tleSA9IGtleTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCF3a2V5KSB7XG4gICAgICAgIHdrZXkgPSBNYXRoLmZsb29yKE1hdGgucG93KDE2LCA4KSAqIE1hdGgucmFuZG9tKCkpLnRvU3RyaW5nKDE2KTtcbiAgICAgICAgdmFyIHdjYWNoZSA9IHt9O1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGNhY2hlS2V5cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBrZXkgPSBjYWNoZUtleXNbaV07XG4gICAgICAgICAgICB3Y2FjaGVba2V5XSA9IGtleTtcbiAgICAgICAgfVxuICAgICAgICBzb3VyY2VzW3drZXldID0gW1xuICAgICAgICAgICAgRnVuY3Rpb24oWydyZXF1aXJlJywnbW9kdWxlJywnZXhwb3J0cyddLCAnKCcgKyBmbiArICcpKHNlbGYpJyksXG4gICAgICAgICAgICB3Y2FjaGVcbiAgICAgICAgXTtcbiAgICB9XG4gICAgdmFyIHNrZXkgPSBNYXRoLmZsb29yKE1hdGgucG93KDE2LCA4KSAqIE1hdGgucmFuZG9tKCkpLnRvU3RyaW5nKDE2KTtcblxuICAgIHZhciBzY2FjaGUgPSB7fTsgc2NhY2hlW3drZXldID0gd2tleTtcbiAgICBzb3VyY2VzW3NrZXldID0gW1xuICAgICAgICBGdW5jdGlvbihbJ3JlcXVpcmUnXSwgKFxuICAgICAgICAgICAgLy8gdHJ5IHRvIGNhbGwgZGVmYXVsdCBpZiBkZWZpbmVkIHRvIGFsc28gc3VwcG9ydCBiYWJlbCBlc21vZHVsZVxuICAgICAgICAgICAgLy8gZXhwb3J0c1xuICAgICAgICAgICAgJ3ZhciBmID0gcmVxdWlyZSgnICsgc3RyaW5naWZ5KHdrZXkpICsgJyk7JyArXG4gICAgICAgICAgICAnKGYuZGVmYXVsdCA/IGYuZGVmYXVsdCA6IGYpKHNlbGYpOydcbiAgICAgICAgKSksXG4gICAgICAgIHNjYWNoZVxuICAgIF07XG5cbiAgICB2YXIgc3JjID0gJygnICsgYnVuZGxlRm4gKyAnKSh7J1xuICAgICAgICArIE9iamVjdC5rZXlzKHNvdXJjZXMpLm1hcChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICByZXR1cm4gc3RyaW5naWZ5KGtleSkgKyAnOlsnXG4gICAgICAgICAgICAgICAgKyBzb3VyY2VzW2tleV1bMF1cbiAgICAgICAgICAgICAgICArICcsJyArIHN0cmluZ2lmeShzb3VyY2VzW2tleV1bMV0pICsgJ10nXG4gICAgICAgICAgICA7XG4gICAgICAgIH0pLmpvaW4oJywnKVxuICAgICAgICArICd9LHt9LFsnICsgc3RyaW5naWZ5KHNrZXkpICsgJ10pJ1xuICAgIDtcblxuICAgIHZhciBVUkwgPSB3aW5kb3cuVVJMIHx8IHdpbmRvdy53ZWJraXRVUkwgfHwgd2luZG93Lm1velVSTCB8fCB3aW5kb3cubXNVUkw7XG5cbiAgICByZXR1cm4gbmV3IFdvcmtlcihVUkwuY3JlYXRlT2JqZWN0VVJMKFxuICAgICAgICBuZXcgQmxvYihbc3JjXSwgeyB0eXBlOiAndGV4dC9qYXZhc2NyaXB0JyB9KVxuICAgICkpO1xufTtcbiJdfQ==
