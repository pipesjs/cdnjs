{"version":3,"sources":["../node_modules/browser-pack/_prelude.js","../lib/Autocomplete.js","../node_modules/dom-scroll-into-view/index.js","../node_modules/dom-scroll-into-view/lib/dom-scroll-into-view.js","../node_modules/dom-scroll-into-view/lib/util.js"],"names":["e","t","n","r","s","o","u","a","require","i","f","Error","code","l","exports","call","length","1","module","React","PropTypes","findDOMNode","scrollIntoView","_debugStates","IMPERATIVE_API","Autocomplete","props","_classCallCheck","this","_this","_possibleConstructorReturn","__proto__","Object","getPrototypeOf","state","isOpen","highlightedIndex","exposeAPI","bind","handleInputFocus","handleInputBlur","handleChange","handleKeyDown","handleKeyUp","handleInputClick","refs","_ignoreBlur","_performAutoCompleteOnUpdate","_performAutoCompleteOnKeyUp","nextProps","items","setState","setMenuPositions","prevProps","prevState","open","maybeAutoCompleteText","maybeScrollItemIntoView","onMenuVisibilityChange","input","focus","el","_this2","forEach","ev","itemNode","menuNode","menu","onlyScrollIfNeeded","event","keyDownHandlers","key","onChange","target","value","_this3","shouldItemRender","filter","item","sortItems","sort","b","autoHighlight","getFilteredItems","matchedItem","getItemValue","toLowerCase","indexOf","node","rect","getBoundingClientRect","computedStyle","global","window","getComputedStyle","marginBottom","parseInt","marginLeft","marginRight","menuTop","bottom","menuLeft","left","menuWidth","width","index","_this4","setIgnoreBlur","onSelect","ignore","_this5","map","element","renderItem","cursor","cloneElement","onMouseEnter","highlightItemFromMouse","onClick","selectItemFromMouse","ref","style","top","minWidth","renderMenu","onMouseLeave","onBlur","inputProps","onFocus","ownerDocument","activeElement","isInputFocused","internal","external","debug","push","id","createElement","_extends","wrapperStyle","wrapperProps","role","aria-autocomplete","aria-expanded","autoComplete","onKeyDown","composeEventHandlers","onKeyUp","JSON","stringify","slice","Component","propTypes","array","isRequired","any","func","menuStyle","object","bool","defaultProps","display","children","borderRadius","boxShadow","background","padding","fontSize","position","overflow","maxHeight","ArrowDown","preventDefault","itemsLength","ArrowUp","Enter","_this6","select","setSelectionRange","Escape","Tab","elem","container","config","nodeType","util","getWindow","allowHorizontalScroll","alignWithTop","alignWithLeft","undefined","containerOffset","ch","cw","containerScroll","diffTop","diffBottom","win","winScroll","ww","wh","isWin","isWindow","elemOffset","offset","eh","outerHeight","ew","outerWidth","height","scrollLeft","scrollTop","clientHeight","clientWidth","parseFloat","css","getClientPosition","box","x","y","doc","body","docElem","documentElement","clientLeft","clientTop","getScroll","w","ret","method","d","document","getScrollLeft","getScrollTop","getOffset","pos","defaultView","parentWindow","_getComputedStyle","name","val","getPropertyValue","_getComputedStyleIE","CURRENT_STYLE","_RE_NUM_NO_PX","test","RE_POS","LEFT","rsLeft","RUNTIME_STYLE","pixelLeft","PX","setOffset","current","old","each","arr","fn","isBorderBoxFn","getComputedStyleX","swap","options","callback","getPBMWidth","which","prop","j","cssProp","obj","getWH","extra","domUtils","viewportWidth","viewportHeight","docWidth","docHeight","borderBoxValue","offsetWidth","offsetHeight","isBorderBox","cssBoxValue","Number","BORDER_INDEX","CONTENT_INDEX","borderBoxValueOrIsBorderBox","PADDING_INDEX","BOX_MODELS","getWHIgnoreDisplay","args","arguments","apply","cssShow","mix","to","from","RE_NUM","source","RegExp","refWin","Math","max","documentElementProp","compatMode","visibility","first","charAt","toUpperCase","includeMargin","utils","clone","v","scrollTo","merge"],"mappings":"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","sourceRoot":"","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","const React = require('react')\nconst PropTypes = require('prop-types')\nconst { findDOMNode } = require('react-dom')\nconst scrollIntoView = require('dom-scroll-into-view')\n\nlet _debugStates = []\nconst IMPERATIVE_API = [\n  'blur',\n  'checkValidity',\n  'click',\n  'focus',\n  'select',\n  'setCustomValidity',\n  'setSelectionRange',\n  'setRangeText',\n]\n\nclass Autocomplete extends React.Component {\n\n  static propTypes = {\n    /**\n     * The items to display in the dropdown menu\n     */\n    items: PropTypes.array.isRequired,\n    /**\n     * The value to display in the input field\n     */\n    value: PropTypes.any,\n    /**\n     * Arguments: `event: Event, value: String`\n     *\n     * Invoked every time the user changes the input's value.\n     */\n    onChange: PropTypes.func,\n    /**\n     * Arguments: `value: String, item: Any`\n     *\n     * Invoked when the user selects an item from the dropdown menu.\n     */\n    onSelect: PropTypes.func,\n    /**\n     * Arguments: `item: Any, value: String`\n     *\n     * Invoked for each entry in `items` and its return value is used to\n     * determine whether or not it should be displayed in the dropdown menu.\n     * By default all items are always rendered.\n     */\n    shouldItemRender: PropTypes.func,\n    /**\n     * Arguments: `itemA: Any, itemB: Any, value: String`\n     *\n     * The function which is used to sort `items` before display.\n     */\n    sortItems: PropTypes.func,\n    /**\n     * Arguments: `item: Any`\n     *\n     * Used to read the display value from each entry in `items`.\n     */\n    getItemValue: PropTypes.func.isRequired,\n    /**\n     * Arguments: `item: Any, isHighlighted: Boolean, styles: Object`\n     *\n     * Invoked for each entry in `items` that also passes `shouldItemRender` to\n     * generate the render tree for each item in the dropdown menu. `styles` is\n     * an optional set of styles that can be applied to improve the look/feel\n     * of the items in the dropdown menu.\n     */\n    renderItem: PropTypes.func.isRequired,\n    /**\n     * Arguments: `items: Array<Any>, value: String, styles: Object`\n     *\n     * Invoked to generate the render tree for the dropdown menu. Ensure the\n     * returned tree includes `items` or else no items will be rendered.\n     * `styles` will contain { top, left, minWidth } which are the coordinates\n     * of the top-left corner and the width of the dropdown menu.\n     */\n    renderMenu: PropTypes.func,\n    /**\n     * Styles that are applied to the dropdown menu in the default `renderMenu`\n     * implementation. If you override `renderMenu` and you want to use\n     * `menuStyles` you must manually apply them (`this.props.menuStyles`).\n     */\n    menuStyle: PropTypes.object,\n    /**\n     * Props that are applied to the `<input />` element rendered by\n     * `Autocomplete`. Any properties supported by `HTMLInputElement` can be\n     * specified, apart from the following which are set by `Autocomplete`:\n     * value, autoComplete, role, aria-autocomplete\n     */\n    inputProps: PropTypes.object,\n    /**\n     * Props that are applied to the element which wraps the `<input />` and\n     * dropdown menu elements rendered by `Autocomplete`.\n     */\n    wrapperProps: PropTypes.object,\n    /**\n     * This is a shorthand for `wrapperProps={{ style: <your styles> }}`.\n     * Note that `wrapperStyle` is applied before `wrapperProps`, so the latter\n     * will win if it contains a `style` entry.\n     */\n    wrapperStyle: PropTypes.object,\n    /**\n     * Whether or not to automatically highlight the top match in the dropdown\n     * menu.\n     */\n    autoHighlight: PropTypes.bool,\n    /**\n     * Arguments: `isOpen: Boolean`\n     *\n     * Invoked every time the dropdown menu's visibility changes (i.e. every\n     * time it is displayed/hidden).\n     */\n    onMenuVisibilityChange: PropTypes.func,\n    /**\n     * Used to override the internal logic which displays/hides the dropdown\n     * menu. This is useful if you want to force a certain state based on your\n     * UX/business logic. Use it together with `onMenuVisibilityChange` for\n     * fine-grained control over the dropdown menu dynamics.\n     */\n    open: PropTypes.bool,\n    debug: PropTypes.bool,\n  }\n\n  static defaultProps = {\n    value: '',\n    wrapperProps: {},\n    wrapperStyle: {\n      display: 'inline-block'\n    },\n    inputProps: {},\n    onChange() {},\n    onSelect() {},\n    renderMenu(items, value, style) {\n      return <div style={{ ...style, ...this.menuStyle }} children={items}/>\n    },\n    menuStyle: {\n      borderRadius: '3px',\n      boxShadow: '0 2px 12px rgba(0, 0, 0, 0.1)',\n      background: 'rgba(255, 255, 255, 0.9)',\n      padding: '2px 0',\n      fontSize: '90%',\n      position: 'fixed',\n      overflow: 'auto',\n      maxHeight: '50%', // TODO: don't cheat, let it flow to the bottom\n    },\n    autoHighlight: true,\n    onMenuVisibilityChange() {},\n  }\n\n  constructor(props) {\n    super(props)\n    this.state = {\n      isOpen: false,\n      highlightedIndex: null,\n    }\n    this.exposeAPI = this.exposeAPI.bind(this)\n    this.handleInputFocus = this.handleInputFocus.bind(this)\n    this.handleInputBlur = this.handleInputBlur.bind(this)\n    this.handleChange = this.handleChange.bind(this)\n    this.handleKeyDown = this.handleKeyDown.bind(this)\n    this.handleKeyUp = this.handleKeyUp.bind(this)\n    this.handleInputClick = this.handleInputClick.bind(this)\n  }\n\n  componentWillMount() {\n    // this.refs is frozen, so we need to assign a new object to it\n    this.refs = {}\n    this._ignoreBlur = false\n    this._performAutoCompleteOnUpdate = false\n    this._performAutoCompleteOnKeyUp = false\n  }\n\n  componentWillReceiveProps(nextProps) {\n    this._performAutoCompleteOnUpdate = true\n    // If `items` has changed we want to reset `highlightedIndex`\n    // since it probably no longer refers to a relevant item\n    if (this.props.items !== nextProps.items ||\n      // The entries in `items` may have been changed even though the\n      // object reference remains the same, double check by seeing\n      // if `highlightedIndex` points to an existing item\n      this.state.highlightedIndex >= nextProps.items.length) {\n      this.setState({ highlightedIndex: null })\n    }\n  }\n\n  componentDidMount() {\n    if (this.isOpen()) {\n      this.setMenuPositions()\n    }\n  }\n\n  componentDidUpdate(prevProps, prevState) {\n    if ((this.state.isOpen && !prevState.isOpen) || ('open' in this.props && this.props.open && !prevProps.open))\n      this.setMenuPositions()\n\n    if (this.isOpen() && this._performAutoCompleteOnUpdate) {\n      this._performAutoCompleteOnUpdate = false\n      this.maybeAutoCompleteText()\n    }\n\n    this.maybeScrollItemIntoView()\n    if (prevState.isOpen !== this.state.isOpen) {\n      this.props.onMenuVisibilityChange(this.state.isOpen)\n    }\n    // Capture the input's focus as long as the ignoreBlur flag is set\n    if (this._ignoreBlur) {\n      this.refs.input.focus()\n    }\n  }\n\n  exposeAPI(el) {\n    this.refs.input = el\n    IMPERATIVE_API.forEach(ev => this[ev] = (el && el[ev] && el[ev].bind(el)))\n  }\n\n  maybeScrollItemIntoView() {\n    if (this.isOpen() && this.state.highlightedIndex !== null) {\n      const itemNode = this.refs[`item-${this.state.highlightedIndex}`]\n      const menuNode = this.refs.menu\n      if(itemNode) {\n        scrollIntoView(\n          findDOMNode(itemNode),\n          findDOMNode(menuNode),\n          { onlyScrollIfNeeded: true }\n        )\n      }\n    }\n  }\n\n  handleKeyDown(event) {\n    if (Autocomplete.keyDownHandlers[event.key])\n      Autocomplete.keyDownHandlers[event.key].call(this, event)\n    else if (!this.isOpen()) {\n      this.setState({\n        isOpen: true\n      })\n    }\n  }\n\n  handleChange(event) {\n    this._performAutoCompleteOnKeyUp = true\n    this.setState({ highlightedIndex: null })\n    this.props.onChange(event, event.target.value)\n  }\n\n  handleKeyUp() {\n    if (this._performAutoCompleteOnKeyUp) {\n      this._performAutoCompleteOnKeyUp = false\n      this.maybeAutoCompleteText()\n    }\n  }\n\n  static keyDownHandlers = {\n    ArrowDown(event) {\n      event.preventDefault()\n      const itemsLength = this.getFilteredItems().length\n      if (!itemsLength) return\n      const { highlightedIndex } = this.state\n      const index = (\n        highlightedIndex === null ||\n        highlightedIndex === itemsLength - 1\n      ) ?  0 : highlightedIndex + 1\n      this._performAutoCompleteOnKeyUp = true\n      this.setState({\n        highlightedIndex: index,\n        isOpen: true,\n      })\n    },\n\n    ArrowUp(event) {\n      event.preventDefault()\n      const itemsLength = this.getFilteredItems().length\n      if (!itemsLength) return\n      const { highlightedIndex } = this.state\n      const index = (\n        highlightedIndex === 0 ||\n        highlightedIndex === null\n      ) ? itemsLength - 1 : highlightedIndex - 1\n      this._performAutoCompleteOnKeyUp = true\n      this.setState({\n        highlightedIndex: index,\n        isOpen: true,\n      })\n    },\n\n    Enter(event) {\n      if (!this.isOpen()) {\n        // menu is closed so there is no selection to accept -> do nothing\n        return\n      }\n      else if (this.state.highlightedIndex == null) {\n        // input has focus but no menu item is selected + enter is hit -> close the menu, highlight whatever's in input\n        this.setState({\n          isOpen: false\n        }, () => {\n          this.refs.input.select()\n        })\n      }\n      else {\n        // text entered + menu item has been highlighted + enter is hit -> update value to that of selected menu item, close the menu\n        event.preventDefault()\n        const item = this.getFilteredItems()[this.state.highlightedIndex]\n        const value = this.props.getItemValue(item)\n        this.setState({\n          isOpen: false,\n          highlightedIndex: null\n        }, () => {\n          //this.refs.input.focus() // TODO: file issue\n          this.refs.input.setSelectionRange(\n            value.length,\n            value.length\n          )\n          this.props.onSelect(value, item)\n        })\n      }\n    },\n\n    Escape() {\n      // In case the user is currently hovering over the menu\n      this.setIgnoreBlur(false)\n      this.setState({\n        highlightedIndex: null,\n        isOpen: false\n      })\n    },\n\n    Tab() {\n      // In case the user is currently hovering over the menu\n      this.setIgnoreBlur(false)\n    },\n  }\n\n  getFilteredItems() {\n    let items = this.props.items\n\n    if (this.props.shouldItemRender) {\n      items = items.filter((item) => (\n        this.props.shouldItemRender(item, this.props.value)\n      ))\n    }\n\n    if (this.props.sortItems) {\n      items.sort((a, b) => (\n        this.props.sortItems(a, b, this.props.value)\n      ))\n    }\n\n    return items\n  }\n\n  maybeAutoCompleteText() {\n    if (!this.props.autoHighlight || this.props.value === '')\n      return\n    const { highlightedIndex } = this.state\n    const items = this.getFilteredItems()\n    if (items.length === 0)\n      return\n    const matchedItem = highlightedIndex !== null ?\n      items[highlightedIndex] : items[0]\n    const itemValue = this.props.getItemValue(matchedItem)\n    const itemValueDoesMatch = (itemValue.toLowerCase().indexOf(\n      this.props.value.toLowerCase()\n    ) === 0)\n    if (itemValueDoesMatch && highlightedIndex === null)\n      this.setState({ highlightedIndex: 0 })\n  }\n\n  setMenuPositions() {\n    const node = this.refs.input\n    const rect = node.getBoundingClientRect()\n    const computedStyle = global.window.getComputedStyle(node)\n    const marginBottom = parseInt(computedStyle.marginBottom, 10) || 0\n    const marginLeft = parseInt(computedStyle.marginLeft, 10) || 0\n    const marginRight = parseInt(computedStyle.marginRight, 10) || 0\n    this.setState({\n      menuTop: rect.bottom + marginBottom,\n      menuLeft: rect.left + marginLeft,\n      menuWidth: rect.width + marginLeft + marginRight\n    })\n  }\n\n  highlightItemFromMouse(index) {\n    this.setState({ highlightedIndex: index })\n  }\n\n  selectItemFromMouse(item) {\n    const value = this.props.getItemValue(item)\n    this.setState({\n      isOpen: false,\n      highlightedIndex: null\n    }, () => {\n      // Clear the ignoreBlur flag after the component has\n      // updated to release control over the input's focus\n      this.setIgnoreBlur(false)\n      this.props.onSelect(value, item)\n    })\n  }\n\n  setIgnoreBlur(ignore) {\n    this._ignoreBlur = ignore\n  }\n\n  renderMenu() {\n    const items = this.getFilteredItems().map((item, index) => {\n      const element = this.props.renderItem(\n        item,\n        this.state.highlightedIndex === index,\n        { cursor: 'default' }\n      )\n      return React.cloneElement(element, {\n        onMouseEnter: () => this.highlightItemFromMouse(index),\n        onClick: () => this.selectItemFromMouse(item),\n        ref: e => this.refs[`item-${index}`] = e,\n      })\n    })\n    const style = {\n      left: this.state.menuLeft,\n      top: this.state.menuTop,\n      minWidth: this.state.menuWidth,\n    }\n    const menu = this.props.renderMenu(items, this.props.value, style)\n    return React.cloneElement(menu, {\n      ref: e => this.refs.menu = e,\n      // Ignore blur to prevent menu from de-rendering before we can process click\n      onMouseEnter: () => this.setIgnoreBlur(true),\n      onMouseLeave: () => this.setIgnoreBlur(false),\n    })\n  }\n\n  handleInputBlur(event) {\n    if (this._ignoreBlur) {\n      return\n    }\n    this.setState({\n      isOpen: false,\n      highlightedIndex: null\n    })\n    const { onBlur } = this.props.inputProps\n    if (onBlur) {\n      onBlur(event)\n    }\n  }\n\n  handleInputFocus(event) {\n    if (this._ignoreBlur) {\n      return\n    }\n    this.setState({ isOpen: true })\n    const { onFocus } = this.props.inputProps\n    if (onFocus) {\n      onFocus(event)\n    }\n  }\n\n  isInputFocused() {\n    const el = this.refs.input\n    return el.ownerDocument && (el === el.ownerDocument.activeElement)\n  }\n\n  handleInputClick() {\n    // Input will not be focused if it's disabled\n    if (this.isInputFocused() && !this.isOpen())\n      this.setState({ isOpen: true })\n  }\n\n  composeEventHandlers(internal, external) {\n    return external\n      ? e => { internal(e); external(e) }\n      : internal\n  }\n\n  isOpen() {\n    return 'open' in this.props ? this.props.open : this.state.isOpen\n  }\n\n  render() {\n    if (this.props.debug) { // you don't like it, you love it\n      _debugStates.push({\n        id: _debugStates.length,\n        state: this.state\n      })\n    }\n\n    const { inputProps } = this.props\n    const open = this.isOpen()\n    return (\n      <div style={{ ...this.props.wrapperStyle }} {...this.props.wrapperProps}>\n        <input\n          {...inputProps}\n          role=\"combobox\"\n          aria-autocomplete=\"list\"\n          aria-expanded={open}\n          autoComplete=\"off\"\n          ref={this.exposeAPI}\n          onFocus={this.handleInputFocus}\n          onBlur={this.handleInputBlur}\n          onChange={this.handleChange}\n          onKeyDown={this.composeEventHandlers(this.handleKeyDown, inputProps.onKeyDown)}\n          onKeyUp={this.composeEventHandlers(this.handleKeyUp, inputProps.onKeyUp)}\n          onClick={this.composeEventHandlers(this.handleInputClick, inputProps.onClick)}\n          value={this.props.value}\n        />\n        {open && this.renderMenu()}\n        {this.props.debug && (\n          <pre style={{ marginLeft: 300 }}>\n            {JSON.stringify(_debugStates.slice(_debugStates.length - 5, _debugStates.length), null, 2)}\n          </pre>\n        )}\n      </div>\n    )\n  }\n}\n\nmodule.exports = Autocomplete\n\n","module.exports = require('./lib/dom-scroll-into-view');\n","var util = require('./util');\n\nfunction scrollIntoView(elem, container, config) {\n  config = config || {};\n  // document 归一化到 window\n  if (container.nodeType === 9) {\n    container = util.getWindow(container);\n  }\n\n  var allowHorizontalScroll = config.allowHorizontalScroll;\n  var onlyScrollIfNeeded = config.onlyScrollIfNeeded;\n  var alignWithTop = config.alignWithTop;\n  var alignWithLeft = config.alignWithLeft;\n\n  allowHorizontalScroll = allowHorizontalScroll === undefined ? true : allowHorizontalScroll;\n\n  var isWin = util.isWindow(container);\n  var elemOffset = util.offset(elem);\n  var eh = util.outerHeight(elem);\n  var ew = util.outerWidth(elem);\n  var containerOffset, ch, cw, containerScroll,\n    diffTop, diffBottom, win,\n    winScroll, ww, wh;\n\n  if (isWin) {\n    win = container;\n    wh = util.height(win);\n    ww = util.width(win);\n    winScroll = {\n      left: util.scrollLeft(win),\n      top: util.scrollTop(win)\n    };\n    // elem 相对 container 可视视窗的距离\n    diffTop = {\n      left: elemOffset.left - winScroll.left,\n      top: elemOffset.top - winScroll.top\n    };\n    diffBottom = {\n      left: elemOffset.left + ew - (winScroll.left + ww),\n      top: elemOffset.top + eh - (winScroll.top + wh)\n    };\n    containerScroll = winScroll;\n  } else {\n    containerOffset = util.offset(container);\n    ch = container.clientHeight;\n    cw = container.clientWidth;\n    containerScroll = {\n      left: container.scrollLeft,\n      top: container.scrollTop\n    };\n    // elem 相对 container 可视视窗的距离\n    // 注意边框, offset 是边框到根节点\n    diffTop = {\n      left: elemOffset.left - (containerOffset.left +\n      (parseFloat(util.css(container, 'borderLeftWidth')) || 0)),\n      top: elemOffset.top - (containerOffset.top +\n      (parseFloat(util.css(container, 'borderTopWidth')) || 0))\n    };\n    diffBottom = {\n      left: elemOffset.left + ew -\n      (containerOffset.left + cw +\n      (parseFloat(util.css(container, 'borderRightWidth')) || 0)),\n      top: elemOffset.top + eh -\n      (containerOffset.top + ch +\n      (parseFloat(util.css(container, 'borderBottomWidth')) || 0))\n    };\n  }\n\n  if (diffTop.top < 0 || diffBottom.top > 0) {\n    // 强制向上\n    if (alignWithTop === true) {\n      util.scrollTop(container, containerScroll.top + diffTop.top);\n    } else if (alignWithTop === false) {\n      util.scrollTop(container, containerScroll.top + diffBottom.top);\n    } else {\n      // 自动调整\n      if (diffTop.top < 0) {\n        util.scrollTop(container, containerScroll.top + diffTop.top);\n      } else {\n        util.scrollTop(container, containerScroll.top + diffBottom.top);\n      }\n    }\n  } else {\n    if (!onlyScrollIfNeeded) {\n      alignWithTop = alignWithTop === undefined ? true : !!alignWithTop;\n      if (alignWithTop) {\n        util.scrollTop(container, containerScroll.top + diffTop.top);\n      } else {\n        util.scrollTop(container, containerScroll.top + diffBottom.top);\n      }\n    }\n  }\n\n  if (allowHorizontalScroll) {\n    if (diffTop.left < 0 || diffBottom.left > 0) {\n      // 强制向上\n      if (alignWithLeft === true) {\n        util.scrollLeft(container, containerScroll.left + diffTop.left);\n      } else if (alignWithLeft === false) {\n        util.scrollLeft(container, containerScroll.left + diffBottom.left);\n      } else {\n        // 自动调整\n        if (diffTop.left < 0) {\n          util.scrollLeft(container, containerScroll.left + diffTop.left);\n        } else {\n          util.scrollLeft(container, containerScroll.left + diffBottom.left);\n        }\n      }\n    } else {\n      if (!onlyScrollIfNeeded) {\n        alignWithLeft = alignWithLeft === undefined ? true : !!alignWithLeft;\n        if (alignWithLeft) {\n          util.scrollLeft(container, containerScroll.left + diffTop.left);\n        } else {\n          util.scrollLeft(container, containerScroll.left + diffBottom.left);\n        }\n      }\n    }\n  }\n}\n\nmodule.exports = scrollIntoView;\n","var RE_NUM = /[\\-+]?(?:\\d*\\.|)\\d+(?:[eE][\\-+]?\\d+|)/.source;\n\nfunction getClientPosition(elem) {\n  var box, x, y;\n  var doc = elem.ownerDocument;\n  var body = doc.body;\n  var docElem = doc && doc.documentElement;\n  // 根据 GBS 最新数据，A-Grade Browsers 都已支持 getBoundingClientRect 方法，不用再考虑传统的实现方式\n  box = elem.getBoundingClientRect();\n\n  // 注：jQuery 还考虑减去 docElem.clientLeft/clientTop\n  // 但测试发现，这样反而会导致当 html 和 body 有边距/边框样式时，获取的值不正确\n  // 此外，ie6 会忽略 html 的 margin 值，幸运地是没有谁会去设置 html 的 margin\n\n  x = box.left;\n  y = box.top;\n\n  // In IE, most of the time, 2 extra pixels are added to the top and left\n  // due to the implicit 2-pixel inset border.  In IE6/7 quirks mode and\n  // IE6 standards mode, this border can be overridden by setting the\n  // document element's border to zero -- thus, we cannot rely on the\n  // offset always being 2 pixels.\n\n  // In quirks mode, the offset can be determined by querying the body's\n  // clientLeft/clientTop, but in standards mode, it is found by querying\n  // the document element's clientLeft/clientTop.  Since we already called\n  // getClientBoundingRect we have already forced a reflow, so it is not\n  // too expensive just to query them all.\n\n  // ie 下应该减去窗口的边框吧，毕竟默认 absolute 都是相对窗口定位的\n  // 窗口边框标准是设 documentElement ,quirks 时设置 body\n  // 最好禁止在 body 和 html 上边框 ，但 ie < 9 html 默认有 2px ，减去\n  // 但是非 ie 不可能设置窗口边框，body html 也不是窗口 ,ie 可以通过 html,body 设置\n  // 标准 ie 下 docElem.clientTop 就是 border-top\n  // ie7 html 即窗口边框改变不了。永远为 2\n  // 但标准 firefox/chrome/ie9 下 docElem.clientTop 是窗口边框，即使设了 border-top 也为 0\n\n  x -= docElem.clientLeft || body.clientLeft || 0;\n  y -= docElem.clientTop || body.clientTop || 0;\n\n  return {left: x, top: y};\n}\n\nfunction getScroll(w, top) {\n  var ret = w['page' + (top ? 'Y' : 'X') + 'Offset'];\n  var method = 'scroll' + (top ? 'Top' : 'Left');\n  if (typeof ret !== 'number') {\n    var d = w.document;\n    //ie6,7,8 standard mode\n    ret = d.documentElement[method];\n    if (typeof ret !== 'number') {\n      //quirks mode\n      ret = d.body[method];\n    }\n  }\n  return ret;\n}\n\nfunction getScrollLeft(w) {\n  return getScroll(w);\n}\n\nfunction getScrollTop(w) {\n  return getScroll(w, true);\n}\n\nfunction getOffset(el) {\n  var pos = getClientPosition(el);\n  var doc = el.ownerDocument;\n  var w = doc.defaultView || doc.parentWindow;\n  pos.left += getScrollLeft(w);\n  pos.top += getScrollTop(w);\n  return pos;\n}\nfunction _getComputedStyle(elem, name, computedStyle) {\n  var val = '';\n  var d = elem.ownerDocument;\n\n  // https://github.com/kissyteam/kissy/issues/61\n  if ((computedStyle = (computedStyle || d.defaultView.getComputedStyle(elem, null)))) {\n    val = computedStyle.getPropertyValue(name) || computedStyle[name];\n  }\n\n  return val;\n}\n\nvar _RE_NUM_NO_PX = new RegExp('^(' + RE_NUM + ')(?!px)[a-z%]+$', 'i');\nvar RE_POS = /^(top|right|bottom|left)$/,\n  CURRENT_STYLE = 'currentStyle',\n  RUNTIME_STYLE = 'runtimeStyle',\n  LEFT = 'left',\n  PX = 'px';\n\nfunction _getComputedStyleIE(elem, name) {\n  // currentStyle maybe null\n  // http://msdn.microsoft.com/en-us/library/ms535231.aspx\n  var ret = elem[CURRENT_STYLE] && elem[CURRENT_STYLE][name];\n\n  // 当 width/height 设置为百分比时，通过 pixelLeft 方式转换的 width/height 值\n  // 一开始就处理了! CUSTOM_STYLE.height,CUSTOM_STYLE.width ,cssHook 解决@2011-08-19\n  // 在 ie 下不对，需要直接用 offset 方式\n  // borderWidth 等值也有问题，但考虑到 borderWidth 设为百分比的概率很小，这里就不考虑了\n\n  // From the awesome hack by Dean Edwards\n  // http://erik.eae.net/archives/2007/07/27/18.54.15/#comment-102291\n  // If we're not dealing with a regular pixel number\n  // but a number that has a weird ending, we need to convert it to pixels\n  // exclude left right for relativity\n  if (_RE_NUM_NO_PX.test(ret) && !RE_POS.test(name)) {\n    // Remember the original values\n    var style = elem.style,\n      left = style[LEFT],\n      rsLeft = elem[RUNTIME_STYLE][LEFT];\n\n    // prevent flashing of content\n    elem[RUNTIME_STYLE][LEFT] = elem[CURRENT_STYLE][LEFT];\n\n    // Put in the new values to get a computed value out\n    style[LEFT] = name === 'fontSize' ? '1em' : (ret || 0);\n    ret = style.pixelLeft + PX;\n\n    // Revert the changed values\n    style[LEFT] = left;\n\n    elem[RUNTIME_STYLE][LEFT] = rsLeft;\n  }\n  return ret === '' ? 'auto' : ret;\n}\n\nvar getComputedStyleX;\nif (typeof window !== 'undefined') {\n  getComputedStyleX = window.getComputedStyle ? _getComputedStyle : _getComputedStyleIE;\n}\n\n// 设置 elem 相对 elem.ownerDocument 的坐标\nfunction setOffset(elem, offset) {\n  // set position first, in-case top/left are set even on static elem\n  if (css(elem, 'position') === 'static') {\n    elem.style.position = 'relative';\n  }\n\n  var old = getOffset(elem),\n    ret = {},\n    current, key;\n\n  for (key in offset) {\n    current = parseFloat(css(elem, key)) || 0;\n    ret[key] = current + offset[key] - old[key];\n  }\n  css(elem, ret);\n}\n\nfunction each(arr, fn) {\n  for (var i = 0; i < arr.length; i++) {\n    fn(arr[i]);\n  }\n}\n\nfunction isBorderBoxFn(elem) {\n  return getComputedStyleX(elem, 'boxSizing') === 'border-box';\n}\n\nvar BOX_MODELS = ['margin', 'border', 'padding'],\n  CONTENT_INDEX = -1,\n  PADDING_INDEX = 2,\n  BORDER_INDEX = 1,\n  MARGIN_INDEX = 0;\n\nfunction swap(elem, options, callback) {\n  var old = {},\n    style = elem.style,\n    name;\n\n  // Remember the old values, and insert the new ones\n  for (name in options) {\n    old[name] = style[name];\n    style[name] = options[name];\n  }\n\n  callback.call(elem);\n\n  // Revert the old values\n  for (name in options) {\n    style[name] = old[name];\n  }\n}\n\nfunction getPBMWidth(elem, props, which) {\n  var value = 0, prop, j, i;\n  for (j = 0; j < props.length; j++) {\n    prop = props[j];\n    if (prop) {\n      for (i = 0; i < which.length; i++) {\n        var cssProp;\n        if (prop === 'border') {\n          cssProp = prop + which[i] + 'Width';\n        } else {\n          cssProp = prop + which[i];\n        }\n        value += parseFloat(getComputedStyleX(elem, cssProp)) || 0;\n      }\n    }\n  }\n  return value;\n}\n\n/**\n * A crude way of determining if an object is a window\n * @member util\n */\nfunction isWindow(obj) {\n  // must use == for ie8\n  /*jshint eqeqeq:false*/\n  return obj != null && obj == obj.window;\n}\n\nvar domUtils = {};\n\neach(['Width', 'Height'], function (name) {\n  domUtils['doc' + name] = function (refWin) {\n    var d = refWin.document;\n    return Math.max(\n      //firefox chrome documentElement.scrollHeight< body.scrollHeight\n      //ie standard mode : documentElement.scrollHeight> body.scrollHeight\n      d.documentElement['scroll' + name],\n      //quirks : documentElement.scrollHeight 最大等于可视窗口多一点？\n      d.body['scroll' + name],\n      domUtils['viewport' + name](d));\n  };\n\n  domUtils['viewport' + name] = function (win) {\n    // pc browser includes scrollbar in window.innerWidth\n    var prop = 'client' + name,\n      doc = win.document,\n      body = doc.body,\n      documentElement = doc.documentElement,\n      documentElementProp = documentElement[prop];\n    // 标准模式取 documentElement\n    // backcompat 取 body\n    return doc.compatMode === 'CSS1Compat' && documentElementProp ||\n      body && body[prop] || documentElementProp;\n  };\n});\n\n/*\n 得到元素的大小信息\n @param elem\n @param name\n @param {String} [extra]  'padding' : (css width) + padding\n 'border' : (css width) + padding + border\n 'margin' : (css width) + padding + border + margin\n */\nfunction getWH(elem, name, extra) {\n  if (isWindow(elem)) {\n    return name === 'width' ? domUtils.viewportWidth(elem) : domUtils.viewportHeight(elem);\n  } else if (elem.nodeType === 9) {\n    return name === 'width' ? domUtils.docWidth(elem) : domUtils.docHeight(elem);\n  }\n  var which = name === 'width' ? ['Left', 'Right'] : ['Top', 'Bottom'],\n    borderBoxValue = name === 'width' ? elem.offsetWidth : elem.offsetHeight;\n  var computedStyle = getComputedStyleX(elem);\n  var isBorderBox = isBorderBoxFn(elem, computedStyle);\n  var cssBoxValue = 0;\n  if (borderBoxValue == null || borderBoxValue <= 0) {\n    borderBoxValue = undefined;\n    // Fall back to computed then un computed css if necessary\n    cssBoxValue = getComputedStyleX(elem, name);\n    if (cssBoxValue == null || (Number(cssBoxValue)) < 0) {\n      cssBoxValue = elem.style[name] || 0;\n    }\n    // Normalize '', auto, and prepare for extra\n    cssBoxValue = parseFloat(cssBoxValue) || 0;\n  }\n  if (extra === undefined) {\n    extra = isBorderBox ? BORDER_INDEX : CONTENT_INDEX;\n  }\n  var borderBoxValueOrIsBorderBox = borderBoxValue !== undefined || isBorderBox;\n  var val = borderBoxValue || cssBoxValue;\n  if (extra === CONTENT_INDEX) {\n    if (borderBoxValueOrIsBorderBox) {\n      return val - getPBMWidth(elem, ['border', 'padding'],\n          which, computedStyle);\n    } else {\n      return cssBoxValue;\n    }\n  } else if (borderBoxValueOrIsBorderBox) {\n    return val + (extra === BORDER_INDEX ? 0 :\n        (extra === PADDING_INDEX ?\n          -getPBMWidth(elem, ['border'], which, computedStyle) :\n          getPBMWidth(elem, ['margin'], which, computedStyle)));\n  } else {\n    return cssBoxValue + getPBMWidth(elem, BOX_MODELS.slice(extra),\n        which, computedStyle);\n  }\n}\n\nvar cssShow = {position: 'absolute', visibility: 'hidden', display: 'block'};\n\n// fix #119 : https://github.com/kissyteam/kissy/issues/119\nfunction getWHIgnoreDisplay(elem) {\n  var val, args = arguments;\n  // in case elem is window\n  // elem.offsetWidth === undefined\n  if (elem.offsetWidth !== 0) {\n    val = getWH.apply(undefined, args);\n  } else {\n    swap(elem, cssShow, function () {\n      val = getWH.apply(undefined, args);\n    });\n  }\n  return val;\n}\n\neach(['width', 'height'], function (name) {\n  var first = name.charAt(0).toUpperCase() + name.slice(1);\n  domUtils['outer' + first] = function (el, includeMargin) {\n    return el && getWHIgnoreDisplay(el, name, includeMargin ? MARGIN_INDEX : BORDER_INDEX);\n  };\n  var which = name === 'width' ? ['Left', 'Right'] : ['Top', 'Bottom'];\n\n  domUtils[name] = function (elem, val) {\n    if (val !== undefined) {\n      if (elem) {\n        var computedStyle = getComputedStyleX(elem);\n        var isBorderBox = isBorderBoxFn(elem);\n        if (isBorderBox) {\n          val += getPBMWidth(elem, ['padding', 'border'], which, computedStyle);\n        }\n        return css(elem, name, val);\n      }\n      return;\n    }\n    return elem && getWHIgnoreDisplay(elem, name, CONTENT_INDEX);\n  };\n});\n\nfunction css(el, name, value) {\n  if (typeof name === 'object') {\n    for (var i in name) {\n      css(el, i, name[i]);\n    }\n    return;\n  }\n  if (typeof value !== 'undefined') {\n    if (typeof value === 'number') {\n      value = value + 'px';\n    }\n    el.style[name] = value;\n  } else {\n    return getComputedStyleX(el, name);\n  }\n}\n\nfunction mix(to, from) {\n  for (var i in from) {\n    to[i] = from[i];\n  }\n  return to;\n}\n\nvar utils = module.exports = {\n  getWindow: function (node) {\n    var doc = node.ownerDocument || node;\n    return doc.defaultView || doc.parentWindow;\n  },\n  offset: function (el, value) {\n    if (typeof value !== 'undefined') {\n      setOffset(el, value);\n    } else {\n      return getOffset(el);\n    }\n  },\n  isWindow: isWindow,\n  each: each,\n  css: css,\n  clone: function (obj) {\n    var ret = {};\n    for (var i in obj) {\n      ret[i] = obj[i];\n    }\n    var overflow = obj.overflow;\n    if (overflow) {\n      for (i in obj) {\n        ret.overflow[i] = obj.overflow[i];\n      }\n    }\n    return ret;\n  },\n  mix: mix,\n  scrollLeft: function (w, v) {\n    if (isWindow(w)) {\n      if (v === undefined) {\n        return getScrollLeft(w);\n      } else {\n        window.scrollTo(v, getScrollTop(w));\n      }\n    } else {\n      if (v === undefined) {\n        return w.scrollLeft;\n      } else {\n        w.scrollLeft = v;\n      }\n    }\n  },\n  scrollTop: function (w, v) {\n    if (isWindow(w)) {\n      if (v === undefined) {\n        return getScrollTop(w);\n      } else {\n        window.scrollTo(getScrollLeft(w), v);\n      }\n    } else {\n      if (v === undefined) {\n        return w.scrollTop;\n      } else {\n        w.scrollTop = v;\n      }\n    }\n  },\n  merge: function () {\n    var ret = {};\n    for (var i = 0; i < arguments.length; i++) {\n      utils.mix(ret, arguments[i]);\n    }\n    return ret;\n  },\n  viewportWidth: 0,\n  viewportHeight: 0\n};\n\nmix(utils, domUtils);\n"]}