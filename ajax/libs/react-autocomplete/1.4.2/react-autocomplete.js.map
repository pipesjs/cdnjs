{
  "version": 3,
  "sources": [
    "../node_modules/browser-pack/_prelude.js",
    "../lib/Autocomplete.js",
    "../node_modules/dom-scroll-into-view/index.js",
    "../node_modules/dom-scroll-into-view/lib/dom-scroll-into-view.js",
    "../node_modules/dom-scroll-into-view/lib/util.js"
  ],
  "names": [],
  "mappings": "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TjB;AAUE,mBAAW,KAAK,oBAAL,CAA0B,KAAK,aAA/B,EAA8C,WAAW,SAAzD,CAVb;AAWE,iBAAS,KAAK,oBAAL,CAA0B,KAAK,WAA/B,EAA4C,WAAW,OAAvD,CAXX;AAYE,iBAAS,KAAK,oBAAL,CAA0B,KAAK,gBAA/B,EAAiD,WAAW,OAA5D,CAZX;AAaE,eAAO,KAAK,KAAL,CAAW;AAbpB,SADF;AAgBG,cAAQ,KAAK,UAAL,EAhBX;AAiBG,WAAK,KAAL,CAAW,KAAX,IACC;AAAA;AAAA,UAAK,OAAO,EAAC,YAAY,GAAb,EAAZ;AACG,aAAK,SAAL,CAAe,aAAa,KAAb,CAAmB,aAAa,MAAb,GAAsB,CAAzC,EAA4C,aAAa,MAAzD,CAAf,EAAiF,IAAjF,EAAuF,CAAvF;AADH;AAlBJ,KADF;AAyBD;AAtckC,CAAlB,CAAnB;;AAycA,OAAO,OAAP,GAAiB,YAAjB;;;;;AChdA;AACA;;ACDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1HA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA",
  "sourcesContent": [
    "(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})",
    "const React = require('react')\nconst { PropTypes } = React\nconst { findDOMNode } = require('react-dom')\nconst scrollIntoView = require('dom-scroll-into-view')\n\nlet _debugStates = []\n\nlet Autocomplete = React.createClass({\n\n  propTypes: {\n    /**\n     * The items to display in the dropdown menu\n     */\n    items: PropTypes.array.isRequired,\n    /**\n     * The value to display in the input field\n     */\n    value: PropTypes.any,\n    /**\n     * Arguments: `event: Event, value: String`\n     *\n     * Invoked every time the user changes the input's value.\n     */\n    onChange: PropTypes.func,\n    /**\n     * Arguments: `value: String, item: Any`\n     *\n     * Invoked when the user selects an item from the dropdown menu.\n     */\n    onSelect: PropTypes.func,\n    /**\n     * Arguments: `item: Any, value: String`\n     *\n     * Invoked for each entry in `items` and its return value is used to\n     * determine whether or not it should be displayed in the dropdown menu.\n     * By default all items are always rendered.\n     */\n    shouldItemRender: PropTypes.func,\n    /**\n     * Arguments: `itemA: Any, itemB: Any, value: String`\n     *\n     * The function which is used to sort `items` before display.\n     */\n    sortItems: PropTypes.func,\n    /**\n     * Arguments: `item: Any`\n     *\n     * Used to read the display value from each entry in `items`.\n     */\n    getItemValue: PropTypes.func.isRequired,\n    /**\n     * Arguments: `item: Any, isHighlighted: Boolean, styles: Object`\n     *\n     * Invoked for each entry in `items` that also passes `shouldItemRender` to\n     * generate the render tree for each item in the dropdown menu. `styles` is\n     * an optional set of styles that can be applied to improve the look/feel\n     * of the items in the dropdown menu.\n     */\n    renderItem: PropTypes.func.isRequired,\n    /**\n     * Arguments: `items: Array<Any>, value: String, styles: Object`\n     *\n     * Invoked to generate the render tree for the dropdown menu. Ensure the\n     * returned tree includes `items` or else no items will be rendered.\n     * `styles` will contain { top, left, minWidth } which are the coordinates\n     * of the top-left corner and the width of the dropdown menu.\n     */\n    renderMenu: PropTypes.func,\n    /**\n     * Styles that are applied to the dropdown menu in the default `renderMenu`\n     * implementation. If you override `renderMenu` and you want to use\n     * `menuStyles` you must manually apply them (`this.props.menuStyles`).\n     */\n    menuStyle: PropTypes.object,\n    /**\n     * Props that are applied to the `<input />` element rendered by\n     * `Autocomplete`. Any properties supported by `HTMLInputElement` can be\n     * specified, apart from the following which are set by `Autocomplete`:\n     * value, autoComplete, role, aria-autocomplete\n     */\n    inputProps: PropTypes.object,\n    /**\n     * Props that are applied to the element which wraps the `<input />` and\n     * dropdown menu elements rendered by `Autocomplete`.\n     */\n    wrapperProps: PropTypes.object,\n    /**\n     * This is a shorthand for `wrapperProps={{ style: <your styles> }}`.\n     * Note that `wrapperStyle` is applied before `wrapperProps`, so the latter\n     * will win if it contains a `style` entry.\n     */\n    wrapperStyle: PropTypes.object,\n    /**\n     * Whether or not to automatically highlight the top match in the dropdown\n     * menu.\n     */\n    autoHighlight: PropTypes.bool,\n    /**\n     * Arguments: `isOpen: Boolean`\n     *\n     * Invoked every time the dropdown menu's visibility changes (i.e. every\n     * time it is displayed/hidden).\n     */\n    onMenuVisibilityChange: PropTypes.func,\n    /**\n     * Used to override the internal logic which displays/hides the dropdown\n     * menu. This is useful if you want to force a certain state based on your\n     * UX/business logic. Use it together with `onMenuVisibilityChange` for\n     * fine-grained control over the dropdown menu dynamics.\n     */\n    open: PropTypes.bool,\n    debug: PropTypes.bool,\n  },\n\n  getDefaultProps () {\n    return {\n      value: '',\n      wrapperProps: {},\n      wrapperStyle: {\n        display: 'inline-block'\n      },\n      inputProps: {},\n      onChange () {},\n      onSelect () {},\n      renderMenu (items, value, style) {\n        return <div style={{...style, ...this.menuStyle}} children={items}/>\n      },\n      menuStyle: {\n        borderRadius: '3px',\n        boxShadow: '0 2px 12px rgba(0, 0, 0, 0.1)',\n        background: 'rgba(255, 255, 255, 0.9)',\n        padding: '2px 0',\n        fontSize: '90%',\n        position: 'fixed',\n        overflow: 'auto',\n        maxHeight: '50%', // TODO: don't cheat, let it flow to the bottom\n      },\n      autoHighlight: true,\n      onMenuVisibilityChange () {},\n    }\n  },\n\n  getInitialState () {\n    return {\n      isOpen: false,\n      highlightedIndex: null,\n    }\n  },\n\n  componentWillMount () {\n    this._ignoreBlur = false\n    this._performAutoCompleteOnUpdate = false\n    this._performAutoCompleteOnKeyUp = false\n  },\n\n  componentWillReceiveProps (nextProps) {\n    this._performAutoCompleteOnUpdate = true\n    // If `items` has changed we want to reset `highlightedIndex`\n    // since it probably no longer refers to a relevant item\n    if (this.props.items !== nextProps.items ||\n      // The entries in `items` may have been changed even though the\n      // object reference remains the same, double check by seeing\n      // if `highlightedIndex` points to an existing item\n      this.state.highlightedIndex >= nextProps.items.length) {\n      this.setState({ highlightedIndex: null })\n    }\n  },\n\n  componentDidUpdate (prevProps, prevState) {\n    if (this.state.isOpen === true && prevState.isOpen === false)\n      this.setMenuPositions()\n\n    if (this.state.isOpen && this._performAutoCompleteOnUpdate) {\n      this._performAutoCompleteOnUpdate = false\n      this.maybeAutoCompleteText()\n    }\n\n    this.maybeScrollItemIntoView()\n    if (prevState.isOpen !== this.state.isOpen) {\n      this.props.onMenuVisibilityChange(this.state.isOpen)\n    }\n  },\n\n  maybeScrollItemIntoView () {\n    if (this.state.isOpen === true && this.state.highlightedIndex !== null) {\n      var itemNode = this.refs[`item-${this.state.highlightedIndex}`]\n      var menuNode = this.refs.menu\n      if(itemNode) {\n        scrollIntoView(\n          findDOMNode(itemNode),\n          findDOMNode(menuNode),\n          { onlyScrollIfNeeded: true }\n        )\n      }\n    }\n  },\n\n  handleKeyDown (event) {\n    if (this.keyDownHandlers[event.key])\n      this.keyDownHandlers[event.key].call(this, event)\n    else {\n      this.setState({\n        highlightedIndex: null,\n        isOpen: true\n      })\n    }\n  },\n\n  handleChange (event) {\n    this._performAutoCompleteOnKeyUp = true\n    this.props.onChange(event, event.target.value)\n  },\n\n  handleKeyUp () {\n    if (this._performAutoCompleteOnKeyUp) {\n      this._performAutoCompleteOnKeyUp = false\n      this.maybeAutoCompleteText()\n    }\n  },\n\n  keyDownHandlers: {\n    ArrowDown (event) {\n      event.preventDefault()\n      const itemsLength = this.getFilteredItems().length\n      if (!itemsLength) return\n      var { highlightedIndex } = this.state\n      var index = (\n        highlightedIndex === null ||\n        highlightedIndex === itemsLength - 1\n      ) ?  0 : highlightedIndex + 1\n      this._performAutoCompleteOnKeyUp = true\n      this.setState({\n        highlightedIndex: index,\n        isOpen: true,\n      })\n    },\n\n    ArrowUp (event) {\n      event.preventDefault()\n      const itemsLength = this.getFilteredItems().length\n      if (!itemsLength) return\n      var { highlightedIndex } = this.state\n      var index = (\n        highlightedIndex === 0 ||\n        highlightedIndex === null\n      ) ? itemsLength - 1 : highlightedIndex - 1\n      this._performAutoCompleteOnKeyUp = true\n      this.setState({\n        highlightedIndex: index,\n        isOpen: true,\n      })\n    },\n\n    Enter (event) {\n      if (this.state.isOpen === false) {\n        // menu is closed so there is no selection to accept -> do nothing\n        return\n      }\n      else if (this.state.highlightedIndex == null) {\n        // input has focus but no menu item is selected + enter is hit -> close the menu, highlight whatever's in input\n        this.setState({\n          isOpen: false\n        }, () => {\n          this.refs.input.select()\n        })\n      }\n      else {\n        // text entered + menu item has been highlighted + enter is hit -> update value to that of selected menu item, close the menu\n        event.preventDefault()\n        var item = this.getFilteredItems()[this.state.highlightedIndex]\n        var value = this.props.getItemValue(item)\n        this.setState({\n          isOpen: false,\n          highlightedIndex: null\n        }, () => {\n          //this.refs.input.focus() // TODO: file issue\n          this.refs.input.setSelectionRange(\n            value.length,\n            value.length\n          )\n          this.props.onSelect(value, item)\n        })\n      }\n    },\n\n    Escape (event) {\n      this.setState({\n        highlightedIndex: null,\n        isOpen: false\n      })\n    }\n  },\n\n  getFilteredItems () {\n    let items = this.props.items\n\n    if (this.props.shouldItemRender) {\n      items = items.filter((item) => (\n        this.props.shouldItemRender(item, this.props.value)\n      ))\n    }\n\n    if (this.props.sortItems) {\n      items.sort((a, b) => (\n        this.props.sortItems(a, b, this.props.value)\n      ))\n    }\n\n    return items\n  },\n\n  maybeAutoCompleteText () {\n    if (!this.props.autoHighlight || this.props.value === '')\n      return\n    var { highlightedIndex } = this.state\n    var items = this.getFilteredItems()\n    if (items.length === 0)\n      return\n    var matchedItem = highlightedIndex !== null ?\n      items[highlightedIndex] : items[0]\n    var itemValue = this.props.getItemValue(matchedItem)\n    var itemValueDoesMatch = (itemValue.toLowerCase().indexOf(\n      this.props.value.toLowerCase()\n    ) === 0)\n    if (itemValueDoesMatch && highlightedIndex === null)\n      this.setState({ highlightedIndex: 0 })\n  },\n\n  setMenuPositions () {\n    var node = this.refs.input\n    var rect = node.getBoundingClientRect()\n    var computedStyle = global.window.getComputedStyle(node)\n    var marginBottom = parseInt(computedStyle.marginBottom, 10) || 0;\n    var marginLeft = parseInt(computedStyle.marginLeft, 10) || 0;\n    var marginRight = parseInt(computedStyle.marginRight, 10) || 0;\n    this.setState({\n      menuTop: rect.bottom + marginBottom,\n      menuLeft: rect.left + marginLeft,\n      menuWidth: rect.width + marginLeft + marginRight\n    })\n  },\n\n  highlightItemFromMouse (index) {\n    this.setState({ highlightedIndex: index })\n  },\n\n  selectItemFromMouse (item) {\n    var value = this.props.getItemValue(item);\n    this.setState({\n      isOpen: false,\n      highlightedIndex: null\n    }, () => {\n      this.props.onSelect(value, item)\n      this.refs.input.focus()\n    })\n  },\n\n  setIgnoreBlur (ignore) {\n    this._ignoreBlur = ignore\n  },\n\n  renderMenu () {\n    var items = this.getFilteredItems().map((item, index) => {\n      var element = this.props.renderItem(\n        item,\n        this.state.highlightedIndex === index,\n        {cursor: 'default'}\n      )\n      return React.cloneElement(element, {\n        onMouseDown: () => this.setIgnoreBlur(true), // Ignore blur to prevent menu from de-rendering before we can process click\n        onMouseEnter: () => this.highlightItemFromMouse(index),\n        onClick: () => this.selectItemFromMouse(item),\n        ref: `item-${index}`,\n      })\n    })\n    var style = {\n      left: this.state.menuLeft,\n      top: this.state.menuTop,\n      minWidth: this.state.menuWidth,\n    }\n    var menu = this.props.renderMenu(items, this.props.value, style)\n    return React.cloneElement(menu, { ref: 'menu' })\n  },\n\n  handleInputBlur () {\n    if (this._ignoreBlur)\n      return\n    this.setState({\n      isOpen: false,\n      highlightedIndex: null\n    })\n  },\n\n  handleInputFocus () {\n    if (this._ignoreBlur) {\n      this.setIgnoreBlur(false)\n      return\n    }\n    // We don't want `selectItemFromMouse` to trigger when\n    // the user clicks into the input to focus it, so set this\n    // flag to cancel out the logic in `handleInputClick`.\n    // The event order is:  MouseDown -> Focus -> MouseUp -> Click\n    this._ignoreClick = true\n    this.setState({ isOpen: true })\n  },\n\n  isInputFocused () {\n    var el = this.refs.input\n    return el.ownerDocument && (el === el.ownerDocument.activeElement)\n  },\n\n  handleInputClick () {\n    // Input will not be focused if it's disabled\n    if (this.isInputFocused() && this.state.isOpen === false)\n      this.setState({ isOpen: true })\n    else if (this.state.highlightedIndex !== null && !this._ignoreClick)\n      this.selectItemFromMouse(this.getFilteredItems()[this.state.highlightedIndex])\n    this._ignoreClick = false\n  },\n\n  composeEventHandlers (internal, external) {\n    return external\n      ? e => { internal(e); external(e); }\n      : internal\n  },\n\n  render () {\n    if (this.props.debug) { // you don't like it, you love it\n      _debugStates.push({\n        id: _debugStates.length,\n        state: this.state\n      })\n    }\n\n    const { inputProps } = this.props\n    const open = ('open' in this.props ? this.props.open : this.state.isOpen)\n    return (\n      <div style={{...this.props.wrapperStyle}} {...this.props.wrapperProps}>\n        <input\n          {...inputProps}\n          role=\"combobox\"\n          aria-autocomplete=\"list\"\n          aria-expanded={open}\n          autoComplete=\"off\"\n          ref=\"input\"\n          onFocus={this.composeEventHandlers(this.handleInputFocus, inputProps.onFocus)}\n          onBlur={this.composeEventHandlers(this.handleInputBlur, inputProps.onBlur)}\n          onChange={this.handleChange}\n          onKeyDown={this.composeEventHandlers(this.handleKeyDown, inputProps.onKeyDown)}\n          onKeyUp={this.composeEventHandlers(this.handleKeyUp, inputProps.onKeyUp)}\n          onClick={this.composeEventHandlers(this.handleInputClick, inputProps.onClick)}\n          value={this.props.value}\n        />\n        {open && this.renderMenu()}\n        {this.props.debug && (\n          <pre style={{marginLeft: 300}}>\n            {JSON.stringify(_debugStates.slice(_debugStates.length - 5, _debugStates.length), null, 2)}\n          </pre>\n        )}\n      </div>\n    )\n  }\n})\n\nmodule.exports = Autocomplete\n\n",
    "module.exports = require('./lib/dom-scroll-into-view');\n",
    "var util = require('./util');\n\nfunction scrollIntoView(elem, container, config) {\n  config = config || {};\n  // document 归一化到 window\n  if (container.nodeType === 9) {\n    container = util.getWindow(container);\n  }\n\n  var allowHorizontalScroll = config.allowHorizontalScroll;\n  var onlyScrollIfNeeded = config.onlyScrollIfNeeded;\n  var alignWithTop = config.alignWithTop;\n  var alignWithLeft = config.alignWithLeft;\n\n  allowHorizontalScroll = allowHorizontalScroll === undefined ? true : allowHorizontalScroll;\n\n  var isWin = util.isWindow(container);\n  var elemOffset = util.offset(elem);\n  var eh = util.outerHeight(elem);\n  var ew = util.outerWidth(elem);\n  var containerOffset, ch, cw, containerScroll,\n    diffTop, diffBottom, win,\n    winScroll, ww, wh;\n\n  if (isWin) {\n    win = container;\n    wh = util.height(win);\n    ww = util.width(win);\n    winScroll = {\n      left: util.scrollLeft(win),\n      top: util.scrollTop(win)\n    };\n    // elem 相对 container 可视视窗的距离\n    diffTop = {\n      left: elemOffset.left - winScroll.left,\n      top: elemOffset.top - winScroll.top\n    };\n    diffBottom = {\n      left: elemOffset.left + ew - (winScroll.left + ww),\n      top: elemOffset.top + eh - (winScroll.top + wh)\n    };\n    containerScroll = winScroll;\n  } else {\n    containerOffset = util.offset(container);\n    ch = container.clientHeight;\n    cw = container.clientWidth;\n    containerScroll = {\n      left: container.scrollLeft,\n      top: container.scrollTop\n    };\n    // elem 相对 container 可视视窗的距离\n    // 注意边框, offset 是边框到根节点\n    diffTop = {\n      left: elemOffset.left - (containerOffset.left +\n      (parseFloat(util.css(container, 'borderLeftWidth')) || 0)),\n      top: elemOffset.top - (containerOffset.top +\n      (parseFloat(util.css(container, 'borderTopWidth')) || 0))\n    };\n    diffBottom = {\n      left: elemOffset.left + ew -\n      (containerOffset.left + cw +\n      (parseFloat(util.css(container, 'borderRightWidth')) || 0)),\n      top: elemOffset.top + eh -\n      (containerOffset.top + ch +\n      (parseFloat(util.css(container, 'borderBottomWidth')) || 0))\n    };\n  }\n\n  if (diffTop.top < 0 || diffBottom.top > 0) {\n    // 强制向上\n    if (alignWithTop === true) {\n      util.scrollTop(container, containerScroll.top + diffTop.top);\n    } else if (alignWithTop === false) {\n      util.scrollTop(container, containerScroll.top + diffBottom.top);\n    } else {\n      // 自动调整\n      if (diffTop.top < 0) {\n        util.scrollTop(container, containerScroll.top + diffTop.top);\n      } else {\n        util.scrollTop(container, containerScroll.top + diffBottom.top);\n      }\n    }\n  } else {\n    if (!onlyScrollIfNeeded) {\n      alignWithTop = alignWithTop === undefined ? true : !!alignWithTop;\n      if (alignWithTop) {\n        util.scrollTop(container, containerScroll.top + diffTop.top);\n      } else {\n        util.scrollTop(container, containerScroll.top + diffBottom.top);\n      }\n    }\n  }\n\n  if (allowHorizontalScroll) {\n    if (diffTop.left < 0 || diffBottom.left > 0) {\n      // 强制向上\n      if (alignWithLeft === true) {\n        util.scrollLeft(container, containerScroll.left + diffTop.left);\n      } else if (alignWithLeft === false) {\n        util.scrollLeft(container, containerScroll.left + diffBottom.left);\n      } else {\n        // 自动调整\n        if (diffTop.left < 0) {\n          util.scrollLeft(container, containerScroll.left + diffTop.left);\n        } else {\n          util.scrollLeft(container, containerScroll.left + diffBottom.left);\n        }\n      }\n    } else {\n      if (!onlyScrollIfNeeded) {\n        alignWithLeft = alignWithLeft === undefined ? true : !!alignWithLeft;\n        if (alignWithLeft) {\n          util.scrollLeft(container, containerScroll.left + diffTop.left);\n        } else {\n          util.scrollLeft(container, containerScroll.left + diffBottom.left);\n        }\n      }\n    }\n  }\n}\n\nmodule.exports = scrollIntoView;\n",
    "var RE_NUM = /[\\-+]?(?:\\d*\\.|)\\d+(?:[eE][\\-+]?\\d+|)/.source;\n\nfunction getClientPosition(elem) {\n  var box, x, y;\n  var doc = elem.ownerDocument;\n  var body = doc.body;\n  var docElem = doc && doc.documentElement;\n  // 根据 GBS 最新数据，A-Grade Browsers 都已支持 getBoundingClientRect 方法，不用再考虑传统的实现方式\n  box = elem.getBoundingClientRect();\n\n  // 注：jQuery 还考虑减去 docElem.clientLeft/clientTop\n  // 但测试发现，这样反而会导致当 html 和 body 有边距/边框样式时，获取的值不正确\n  // 此外，ie6 会忽略 html 的 margin 值，幸运地是没有谁会去设置 html 的 margin\n\n  x = box.left;\n  y = box.top;\n\n  // In IE, most of the time, 2 extra pixels are added to the top and left\n  // due to the implicit 2-pixel inset border.  In IE6/7 quirks mode and\n  // IE6 standards mode, this border can be overridden by setting the\n  // document element's border to zero -- thus, we cannot rely on the\n  // offset always being 2 pixels.\n\n  // In quirks mode, the offset can be determined by querying the body's\n  // clientLeft/clientTop, but in standards mode, it is found by querying\n  // the document element's clientLeft/clientTop.  Since we already called\n  // getClientBoundingRect we have already forced a reflow, so it is not\n  // too expensive just to query them all.\n\n  // ie 下应该减去窗口的边框吧，毕竟默认 absolute 都是相对窗口定位的\n  // 窗口边框标准是设 documentElement ,quirks 时设置 body\n  // 最好禁止在 body 和 html 上边框 ，但 ie < 9 html 默认有 2px ，减去\n  // 但是非 ie 不可能设置窗口边框，body html 也不是窗口 ,ie 可以通过 html,body 设置\n  // 标准 ie 下 docElem.clientTop 就是 border-top\n  // ie7 html 即窗口边框改变不了。永远为 2\n  // 但标准 firefox/chrome/ie9 下 docElem.clientTop 是窗口边框，即使设了 border-top 也为 0\n\n  x -= docElem.clientLeft || body.clientLeft || 0;\n  y -= docElem.clientTop || body.clientTop || 0;\n\n  return {left: x, top: y};\n}\n\nfunction getScroll(w, top) {\n  var ret = w['page' + (top ? 'Y' : 'X') + 'Offset'];\n  var method = 'scroll' + (top ? 'Top' : 'Left');\n  if (typeof ret !== 'number') {\n    var d = w.document;\n    //ie6,7,8 standard mode\n    ret = d.documentElement[method];\n    if (typeof ret !== 'number') {\n      //quirks mode\n      ret = d.body[method];\n    }\n  }\n  return ret;\n}\n\nfunction getScrollLeft(w) {\n  return getScroll(w);\n}\n\nfunction getScrollTop(w) {\n  return getScroll(w, true);\n}\n\nfunction getOffset(el) {\n  var pos = getClientPosition(el);\n  var doc = el.ownerDocument;\n  var w = doc.defaultView || doc.parentWindow;\n  pos.left += getScrollLeft(w);\n  pos.top += getScrollTop(w);\n  return pos;\n}\nfunction _getComputedStyle(elem, name, computedStyle) {\n  var val = '';\n  var d = elem.ownerDocument;\n\n  // https://github.com/kissyteam/kissy/issues/61\n  if ((computedStyle = (computedStyle || d.defaultView.getComputedStyle(elem, null)))) {\n    val = computedStyle.getPropertyValue(name) || computedStyle[name];\n  }\n\n  return val;\n}\n\nvar _RE_NUM_NO_PX = new RegExp('^(' + RE_NUM + ')(?!px)[a-z%]+$', 'i');\nvar RE_POS = /^(top|right|bottom|left)$/,\n  CURRENT_STYLE = 'currentStyle',\n  RUNTIME_STYLE = 'runtimeStyle',\n  LEFT = 'left',\n  PX = 'px';\n\nfunction _getComputedStyleIE(elem, name) {\n  // currentStyle maybe null\n  // http://msdn.microsoft.com/en-us/library/ms535231.aspx\n  var ret = elem[CURRENT_STYLE] && elem[CURRENT_STYLE][name];\n\n  // 当 width/height 设置为百分比时，通过 pixelLeft 方式转换的 width/height 值\n  // 一开始就处理了! CUSTOM_STYLE.height,CUSTOM_STYLE.width ,cssHook 解决@2011-08-19\n  // 在 ie 下不对，需要直接用 offset 方式\n  // borderWidth 等值也有问题，但考虑到 borderWidth 设为百分比的概率很小，这里就不考虑了\n\n  // From the awesome hack by Dean Edwards\n  // http://erik.eae.net/archives/2007/07/27/18.54.15/#comment-102291\n  // If we're not dealing with a regular pixel number\n  // but a number that has a weird ending, we need to convert it to pixels\n  // exclude left right for relativity\n  if (_RE_NUM_NO_PX.test(ret) && !RE_POS.test(name)) {\n    // Remember the original values\n    var style = elem.style,\n      left = style[LEFT],\n      rsLeft = elem[RUNTIME_STYLE][LEFT];\n\n    // prevent flashing of content\n    elem[RUNTIME_STYLE][LEFT] = elem[CURRENT_STYLE][LEFT];\n\n    // Put in the new values to get a computed value out\n    style[LEFT] = name === 'fontSize' ? '1em' : (ret || 0);\n    ret = style.pixelLeft + PX;\n\n    // Revert the changed values\n    style[LEFT] = left;\n\n    elem[RUNTIME_STYLE][LEFT] = rsLeft;\n  }\n  return ret === '' ? 'auto' : ret;\n}\n\nvar getComputedStyleX;\nif (typeof window !== 'undefined') {\n  getComputedStyleX = window.getComputedStyle ? _getComputedStyle : _getComputedStyleIE;\n}\n\n// 设置 elem 相对 elem.ownerDocument 的坐标\nfunction setOffset(elem, offset) {\n  // set position first, in-case top/left are set even on static elem\n  if (css(elem, 'position') === 'static') {\n    elem.style.position = 'relative';\n  }\n\n  var old = getOffset(elem),\n    ret = {},\n    current, key;\n\n  for (key in offset) {\n    current = parseFloat(css(elem, key)) || 0;\n    ret[key] = current + offset[key] - old[key];\n  }\n  css(elem, ret);\n}\n\nfunction each(arr, fn) {\n  for (var i = 0; i < arr.length; i++) {\n    fn(arr[i]);\n  }\n}\n\nfunction isBorderBoxFn(elem) {\n  return getComputedStyleX(elem, 'boxSizing') === 'border-box';\n}\n\nvar BOX_MODELS = ['margin', 'border', 'padding'],\n  CONTENT_INDEX = -1,\n  PADDING_INDEX = 2,\n  BORDER_INDEX = 1,\n  MARGIN_INDEX = 0;\n\nfunction swap(elem, options, callback) {\n  var old = {},\n    style = elem.style,\n    name;\n\n  // Remember the old values, and insert the new ones\n  for (name in options) {\n    old[name] = style[name];\n    style[name] = options[name];\n  }\n\n  callback.call(elem);\n\n  // Revert the old values\n  for (name in options) {\n    style[name] = old[name];\n  }\n}\n\nfunction getPBMWidth(elem, props, which) {\n  var value = 0, prop, j, i;\n  for (j = 0; j < props.length; j++) {\n    prop = props[j];\n    if (prop) {\n      for (i = 0; i < which.length; i++) {\n        var cssProp;\n        if (prop === 'border') {\n          cssProp = prop + which[i] + 'Width';\n        } else {\n          cssProp = prop + which[i];\n        }\n        value += parseFloat(getComputedStyleX(elem, cssProp)) || 0;\n      }\n    }\n  }\n  return value;\n}\n\n/**\n * A crude way of determining if an object is a window\n * @member util\n */\nfunction isWindow(obj) {\n  // must use == for ie8\n  /*jshint eqeqeq:false*/\n  return obj != null && obj == obj.window;\n}\n\nvar domUtils = {};\n\neach(['Width', 'Height'], function (name) {\n  domUtils['doc' + name] = function (refWin) {\n    var d = refWin.document;\n    return Math.max(\n      //firefox chrome documentElement.scrollHeight< body.scrollHeight\n      //ie standard mode : documentElement.scrollHeight> body.scrollHeight\n      d.documentElement['scroll' + name],\n      //quirks : documentElement.scrollHeight 最大等于可视窗口多一点？\n      d.body['scroll' + name],\n      domUtils['viewport' + name](d));\n  };\n\n  domUtils['viewport' + name] = function (win) {\n    // pc browser includes scrollbar in window.innerWidth\n    var prop = 'client' + name,\n      doc = win.document,\n      body = doc.body,\n      documentElement = doc.documentElement,\n      documentElementProp = documentElement[prop];\n    // 标准模式取 documentElement\n    // backcompat 取 body\n    return doc.compatMode === 'CSS1Compat' && documentElementProp ||\n      body && body[prop] || documentElementProp;\n  };\n});\n\n/*\n 得到元素的大小信息\n @param elem\n @param name\n @param {String} [extra]  'padding' : (css width) + padding\n 'border' : (css width) + padding + border\n 'margin' : (css width) + padding + border + margin\n */\nfunction getWH(elem, name, extra) {\n  if (isWindow(elem)) {\n    return name === 'width' ? domUtils.viewportWidth(elem) : domUtils.viewportHeight(elem);\n  } else if (elem.nodeType === 9) {\n    return name === 'width' ? domUtils.docWidth(elem) : domUtils.docHeight(elem);\n  }\n  var which = name === 'width' ? ['Left', 'Right'] : ['Top', 'Bottom'],\n    borderBoxValue = name === 'width' ? elem.offsetWidth : elem.offsetHeight;\n  var computedStyle = getComputedStyleX(elem);\n  var isBorderBox = isBorderBoxFn(elem, computedStyle);\n  var cssBoxValue = 0;\n  if (borderBoxValue == null || borderBoxValue <= 0) {\n    borderBoxValue = undefined;\n    // Fall back to computed then un computed css if necessary\n    cssBoxValue = getComputedStyleX(elem, name);\n    if (cssBoxValue == null || (Number(cssBoxValue)) < 0) {\n      cssBoxValue = elem.style[name] || 0;\n    }\n    // Normalize '', auto, and prepare for extra\n    cssBoxValue = parseFloat(cssBoxValue) || 0;\n  }\n  if (extra === undefined) {\n    extra = isBorderBox ? BORDER_INDEX : CONTENT_INDEX;\n  }\n  var borderBoxValueOrIsBorderBox = borderBoxValue !== undefined || isBorderBox;\n  var val = borderBoxValue || cssBoxValue;\n  if (extra === CONTENT_INDEX) {\n    if (borderBoxValueOrIsBorderBox) {\n      return val - getPBMWidth(elem, ['border', 'padding'],\n          which, computedStyle);\n    } else {\n      return cssBoxValue;\n    }\n  } else if (borderBoxValueOrIsBorderBox) {\n    return val + (extra === BORDER_INDEX ? 0 :\n        (extra === PADDING_INDEX ?\n          -getPBMWidth(elem, ['border'], which, computedStyle) :\n          getPBMWidth(elem, ['margin'], which, computedStyle)));\n  } else {\n    return cssBoxValue + getPBMWidth(elem, BOX_MODELS.slice(extra),\n        which, computedStyle);\n  }\n}\n\nvar cssShow = {position: 'absolute', visibility: 'hidden', display: 'block'};\n\n// fix #119 : https://github.com/kissyteam/kissy/issues/119\nfunction getWHIgnoreDisplay(elem) {\n  var val, args = arguments;\n  // in case elem is window\n  // elem.offsetWidth === undefined\n  if (elem.offsetWidth !== 0) {\n    val = getWH.apply(undefined, args);\n  } else {\n    swap(elem, cssShow, function () {\n      val = getWH.apply(undefined, args);\n    });\n  }\n  return val;\n}\n\neach(['width', 'height'], function (name) {\n  var first = name.charAt(0).toUpperCase() + name.slice(1);\n  domUtils['outer' + first] = function (el, includeMargin) {\n    return el && getWHIgnoreDisplay(el, name, includeMargin ? MARGIN_INDEX : BORDER_INDEX);\n  };\n  var which = name === 'width' ? ['Left', 'Right'] : ['Top', 'Bottom'];\n\n  domUtils[name] = function (elem, val) {\n    if (val !== undefined) {\n      if (elem) {\n        var computedStyle = getComputedStyleX(elem);\n        var isBorderBox = isBorderBoxFn(elem);\n        if (isBorderBox) {\n          val += getPBMWidth(elem, ['padding', 'border'], which, computedStyle);\n        }\n        return css(elem, name, val);\n      }\n      return;\n    }\n    return elem && getWHIgnoreDisplay(elem, name, CONTENT_INDEX);\n  };\n});\n\nfunction css(el, name, value) {\n  if (typeof name === 'object') {\n    for (var i in name) {\n      css(el, i, name[i]);\n    }\n    return;\n  }\n  if (typeof value !== 'undefined') {\n    if (typeof value === 'number') {\n      value = value + 'px';\n    }\n    el.style[name] = value;\n  } else {\n    return getComputedStyleX(el, name);\n  }\n}\n\nfunction mix(to, from) {\n  for (var i in from) {\n    to[i] = from[i];\n  }\n  return to;\n}\n\nvar utils = module.exports = {\n  getWindow: function (node) {\n    var doc = node.ownerDocument || node;\n    return doc.defaultView || doc.parentWindow;\n  },\n  offset: function (el, value) {\n    if (typeof value !== 'undefined') {\n      setOffset(el, value);\n    } else {\n      return getOffset(el);\n    }\n  },\n  isWindow: isWindow,\n  each: each,\n  css: css,\n  clone: function (obj) {\n    var ret = {};\n    for (var i in obj) {\n      ret[i] = obj[i];\n    }\n    var overflow = obj.overflow;\n    if (overflow) {\n      for (i in obj) {\n        ret.overflow[i] = obj.overflow[i];\n      }\n    }\n    return ret;\n  },\n  mix: mix,\n  scrollLeft: function (w, v) {\n    if (isWindow(w)) {\n      if (v === undefined) {\n        return getScrollLeft(w);\n      } else {\n        window.scrollTo(v, getScrollTop(w));\n      }\n    } else {\n      if (v === undefined) {\n        return w.scrollLeft;\n      } else {\n        w.scrollLeft = v;\n      }\n    }\n  },\n  scrollTop: function (w, v) {\n    if (isWindow(w)) {\n      if (v === undefined) {\n        return getScrollTop(w);\n      } else {\n        window.scrollTo(getScrollLeft(w), v);\n      }\n    } else {\n      if (v === undefined) {\n        return w.scrollTop;\n      } else {\n        w.scrollTop = v;\n      }\n    }\n  },\n  merge: function () {\n    var ret = {};\n    for (var i = 0; i < arguments.length; i++) {\n      utils.mix(ret, arguments[i]);\n    }\n    return ret;\n  },\n  viewportWidth: 0,\n  viewportHeight: 0\n};\n\nmix(utils, domUtils);\n"
  ],
  "sourceRoot": ""
}