(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory(require("jquery"));
	else if(typeof define === 'function' && define.amd)
		define(["jquery"], factory);
	else if(typeof exports === 'object')
		exports["autonumeric"] = factory(require("jquery"));
	else
		root["autonumeric"] = factory(root["jQuery"]);
})(this, function(__WEBPACK_EXTERNAL_MODULE_1__) {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*** IMPORTS FROM imports-loader ***/\nvar jQuery = __webpack_require__(1);\nvar $ = __webpack_require__(1);\n(function() {\n\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n *               autoNumeric.js\n *\n * @version      2.0.9\n * @date         2017-02-28 UTC 14:00\n *\n * @author       Bob Knothe\n * @contributors Alexandre Bonneau, Sokolov Yura and other Github users,\n *               cf. AUTHORS.md.\n * @copyright    2009 Robert J. Knothe http://www.decorplanit.com/plugin/\n * @since        2009-08-09\n *\n * @summary      autoNumeric is a library that provides live as-you-type\n *               formatting for international numbers and currencies.\n *\n *               Note : Some functions are borrowed from big.js\n * @link         https://github.com/MikeMcl/big.js/\n *\n * Please report any bugs to https://github.com/BobKnothe/autoNumeric\n *\n * @license      Released under the MIT License\n * @link         http://www.opensource.org/licenses/mit-license.php\n *\n * Permission is hereby granted, free of charge, to any person\n * obtaining a copy of this software and associated documentation\n * files (the \"Software\"), to deal in the Software without\n * restriction, including without limitation the rights to use,\n * copy, modify, merge, publish, distribute, sub license, and/or sell\n * copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following\n * conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n * OTHER DEALINGS IN THE SOFTWARE.\n */\n\n/* global module, require, define */\n\n// Functions names for ES6 exports\nvar autoFormat = void 0;\nvar autoUnFormat = void 0;\nvar getDefaultConfig = void 0;\nvar getLanguages = void 0;\nvar validate = void 0;\nvar areSettingsValid = void 0;\n\n// AutoNumeric default settings\n/**\n * List of allowed tag on which autoNumeric can be used.\n */\nvar allowedTagList = ['b', 'caption', 'cite', 'code', 'const', 'dd', 'del', 'div', 'dfn', 'dt', 'em', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'ins', 'kdb', 'label', 'li', 'option', 'output', 'p', 'q', 's', 'sample', 'span', 'strong', 'td', 'th', 'u'];\n\n/**\n * Defaults options are public - these can be overridden by the following method:\n * - HTML5 data attributes (ie. `<input type=\"text\" data-currency-symbol=\" €\">`)\n * - Options passed by the 'init' or 'update' methods (ie. `aNInput.autoNumeric('update', { currencySymbol: ' €' });`)\n * - Use jQuery's `$.extend` method for global changes - also a great way to pass ASP.NET current culture settings\n */\nvar defaultSettings = {\n    /* Allowed thousand grouping separator characters :\n     * ','      // Comma\n     * '.'      // Dot\n     * ' '      // Normal space\n     * '\\u2009' // Thin-space\n     * '\\u202f' // Narrow no-break space\n     * '\\u00a0' // No-break space\n     * ''       // No separator\n     * \"'\"      // Apostrophe\n     * '٬'      // Arabic thousands separator\n     * '˙'      // Dot above\n     * Deprecated older option name : aSep\n     */\n    digitGroupSeparator: ',',\n\n    /* Remove the thousand separator on focus, currency symbol and suffix on focus\n     * example if the input value \"$ 1,999.88 suffix\"\n     * on \"focusin\" it becomes \"1999.88\" and back to \"$ 1,999.88 suffix\" on focus out.\n     * Deprecated older option name : nSep\n     */\n    noSeparatorOnFocus: false,\n\n    /* Digital grouping for the thousand separator used in Format\n     * digitalGroupSpacing: \"2\", results in 99,99,99,999 India's lakhs\n     * digitalGroupSpacing: \"2s\", results in 99,999,99,99,999 India's lakhs scaled\n     * digitalGroupSpacing: \"3\", results in 999,999,999 default\n     * digitalGroupSpacing: \"4\", results in 9999,9999,9999 used in some Asian countries\n     * Deprecated older option name : dGroup\n     */\n    digitalGroupSpacing: '3',\n\n    /* Allowed decimal separator characters :\n     * ',' : Comma\n     * '.' : Dot\n     * '·' : Middle-dot\n     * '٫' : Arabic decimal separator\n     * '⎖' : Decimal separator key symbol\n     * Deprecated older option name : aDec\n     */\n    decimalCharacter: '.',\n\n    /* Allow to declare an alternative decimal separator which is automatically replaced by `decimalCharacter` when typed.\n     * This is used by countries that use a comma \",\" as the decimal character and have keyboards\\numeric pads that have\n     * a period 'full stop' as the decimal characters (France or Spain for instance).\n     * Deprecated older option name : altDec\n     */\n    decimalCharacterAlternative: null,\n\n    /* currencySymbol = allowed currency symbol\n     * Must be in quotes currencySymbol: \"$\"\n     * space to the right of the currency symbol currencySymbol: '$ '\n     * space to the left of the currency symbol currencySymbol: ' $'\n     * Deprecated older option name : aSign\n     */\n    currencySymbol: '',\n\n    /* currencySymbolPlacement = placement of currency sign as a p=prefix or s=suffix\n     * for prefix currencySymbolPlacement: \"p\" (default)\n     * for suffix currencySymbolPlacement: \"s\"\n     * Deprecated older option name : pSign\n     */\n    //TODO Rename the options to more explicit names ('p' => 'prefix', etc.)\n    currencySymbolPlacement: 'p',\n\n    /* Placement of negative/positive sign relative to the currencySymbol option l=left, r=right, p=prefix & s=suffix\n     * -1,234.56  => default no options required\n     * -$1,234.56 => {currencySymbol: \"$\"} or {currencySymbol: \"$\", negativePositiveSignPlacement: \"l\"}\n     * $-1,234.56 => {currencySymbol: \"$\", negativePositiveSignPlacement: \"r\"} // Default if negativePositiveSignPlacement is 'null' and currencySymbol is not empty\n     * -1,234.56$ => {currencySymbol: \"$\", currencySymbolPlacement: \"s\", negativePositiveSignPlacement: \"p\"} // Default if negativePositiveSignPlacement is 'null' and currencySymbol is not empty\n     * 1,234.56-  => {negativePositiveSignPlacement: \"s\"}\n     * $1,234.56- => {currencySymbol: \"$\", negativePositiveSignPlacement: \"s\"}\n     * 1,234.56-$ => {currencySymbol: \"$\", currencySymbolPlacement: \"s\"}\n     * 1,234.56$- => {currencySymbol: \"$\", currencySymbolPlacement: \"s\", negativePositiveSignPlacement: \"r\"}\n     * Deprecated older option name : pNeg\n     */\n    //TODO Rename the options to more explicit names ('p' => 'prefix', etc.)\n    negativePositiveSignPlacement: null,\n\n    /* Allow the positive sign symbol `+` to be displayed for positive numbers.\n     * By default, this positive sign is not shown.\n     * The sign placement is controlled by the 'negativePositiveSignPlacement' option, mimicking the negative sign placement rules.\n     */\n    showPositiveSign: false,\n\n    /* Additional suffix\n     * Must be in quotes suffixText: 'gross', a space is allowed suffixText: ' dollars'\n     * Numeric characters and negative sign not allowed'\n     * Deprecated older option name : aSuffix\n     */\n    suffixText: '',\n\n    /* Override min max limits\n     * overrideMinMaxLimits: \"ceiling\" adheres to maximumValue and ignores minimumValue settings\n     * overrideMinMaxLimits: \"floor\" adheres to minimumValue and ignores maximumValue settings\n     * overrideMinMaxLimits: \"ignore\" ignores both minimumValue & maximumValue\n     * Deprecated older option name : oLimits\n     */\n    overrideMinMaxLimits: null,\n\n    /* Maximum possible value\n     * value must be enclosed in quotes and use the period for the decimal point\n     * value must be larger than minimumValue\n     * Deprecated older option name : vMax\n     */\n    maximumValue: '9999999999999.99', // 9.999.999.999.999,99 ~= 10000 billions\n\n    /* Minimum possible value\n     * value must be enclosed in quotes and use the period for the decimal point\n     * value must be smaller than maximumValue\n     * Deprecated older option name : vMin\n     */\n    minimumValue: '-9999999999999.99', // -9.999.999.999.999,99 ~= 10000 billions\n\n    /* Maximum number of decimal places = used to override decimal places set by the minimumValue & maximumValue values\n     * Deprecated older option name : mDec\n     */\n    decimalPlacesOverride: null,\n\n    /* Expanded decimal places visible when input has focus - example:\n     * {decimalPlacesShownOnFocus: \"5\"} and the default 2 decimal places with focus \"1,000.12345\" without focus \"1,000.12\" the results depends on the rounding method used\n     * the \"get\" method returns the extended decimal places\n     * Deprecated older option name : eDec\n     */\n    decimalPlacesShownOnFocus: null,\n\n    /* The next three options (scaleDivisor, scaleDecimalPlaces & scaleSymbol) handle scaling of the input when the input does not have focus\n     * Please note that the non-scaled value is held in data and it is advised that you use the \"saveValueToSessionStorage\" option to ensure retaining the value\n     * [\"divisor\", \"decimal places\", \"symbol\"]\n     * Example: with the following options set {scaleDivisor: '1000', scaleDecimalPlaces: '1', scaleSymbol: ' K'}\n     * Example: focusin value \"1,111.11\" focusout value \"1.1 K\"\n     */\n\n    /* The `scaleDivisor` decides the on focus value and places the result in the input on focusout\n     * Example {scaleDivisor: '1000'} or <input data-scale-divisor=\"1000\">\n     * The divisor value - does not need to be whole number but please understand that Javascript has limited accuracy in math\n     * The \"get\" method returns the full value, including the 'hidden' decimals.\n     */\n    scaleDivisor: null,\n\n    /*\n     * The `scaleDecimalPlaces` option is the number of decimal place when not in focus - for this to work, `scaledDivisor` must not be `null`.\n     * This is optional ; if omitted the decimal places will be the same when the input has the focus.\n     * Deprecated older option name : scaleDecimal\n     */\n    scaleDecimalPlaces: null,\n\n    /*\n     * The `scaleSymbol` option is a symbol placed as a suffix when not in focus.\n     * This is optional too.\n     */\n    scaleSymbol: null,\n\n    /* Set to true to allow the decimalPlacesShownOnFocus value to be saved with sessionStorage\n     * if ie 6 or 7 the value will be saved as a session cookie\n     * Deprecated older option name : aStor\n     */\n    saveValueToSessionStorage: false,\n\n    /*\n     * Manage how autoNumeric react when the user tries to paste an invalid number.\n     * - 'error'    : (This is the default behavior) The input value is not changed and an error is output in the console.\n     * - 'ignore'   : idem than 'error', but fail silently without outputting any error/warning in the console.\n     * - 'clamp'    : if the pasted value is either too small or too big regarding the minimumValue and maximumValue range, then the result is clamped to those limits.\n     * - 'truncate' : autoNumeric will insert as many pasted numbers it can at the initial caret/selection, until everything is pasted, or the range limit is hit.\n     *                The non-pasted numbers are dropped and therefore not used at all.\n     * - 'replace'  : autoNumeric will first insert as many pasted numbers it can at the initial caret/selection, then if the range limit is hit, it will try\n     *                to replace one by one the remaining initial numbers (on the right side of the caret) with the rest of the pasted numbers.\n     *\n     * Note 1 : A paste content starting with a negative sign '-' will be accepted anywhere in the input, and will set the resulting value as a negative number\n     * Note 2 : A paste content starting with a number will be accepted, even if the rest is gibberish (ie. '123foobar456').\n     *          Only the first number will be used (here '123').\n     * Note 3 : The paste event works with the `decimalPlacesShownOnFocus` option too.\n     */\n    //TODO Shouldn't we use `truncate` as the default value?\n    onInvalidPaste: 'error',\n\n    /* method used for rounding\n     * roundingMethod: \"S\", Round-Half-Up Symmetric (default)\n     * roundingMethod: \"A\", Round-Half-Up Asymmetric\n     * roundingMethod: \"s\", Round-Half-Down Symmetric (lower case s)\n     * roundingMethod: \"a\", Round-Half-Down Asymmetric (lower case a)\n     * roundingMethod: \"B\", Round-Half-Even \"Bankers Rounding\"\n     * roundingMethod: \"U\", Round Up \"Round-Away-From-Zero\"\n     * roundingMethod: \"D\", Round Down \"Round-Toward-Zero\" - same as truncate\n     * roundingMethod: \"C\", Round to Ceiling \"Toward Positive Infinity\"\n     * roundingMethod: \"F\", Round to Floor \"Toward Negative Infinity\"\n     * roundingMethod: \"N05\" Rounds to the nearest .05 => same as \"CHF\" used in 1.9X and still valid\n     * roundingMethod: \"U05\" Rounds up to next .05\n     * roundingMethod: \"D05\" Rounds down to next .05\n     * Deprecated older option name : mRound\n     */\n    //TODO Rename the options to more explicit names ('S' => 'RoundHalfUpSymmetric', etc.)\n    //TODO Add an `an.roundingMethod` object that enum those options clearly\n    roundingMethod: 'S',\n\n    /* Allow padding the decimal places with zeros\n     * allowDecimalPadding: true - always Pad decimals with zeros\n     * allowDecimalPadding: false - does not pad with zeros.\n     * Note: setting allowDecimalPadding to 'false' will override the 'decimalPlacesOverride' setting.\n     *\n     * thanks to Jonas Johansson for the suggestion\n     * Deprecated older option name : aPad\n     */\n    allowDecimalPadding: true,\n\n    /* Adds brackets on negative values (ie. transforms '-$ 999.99' to '(999.99)')\n     * Those brackets are visible only when the field does NOT have the focus.\n     * The left and right symbols should be enclosed in quotes and separated by a comma\n     * This option can be of the following values :\n     * null, // This is the default value, which deactivate this feature\n     * '(,)',\n     * '[,]',\n     * '<,>' or\n     * '{,}'\n     * Deprecated older option name : nBracket\n     */\n    //TODO Rename the options to more explicit names ('(,)' => 'parentheses', etc.)\n    negativeBracketsTypeOnBlur: null,\n\n    /* Displayed on empty string \"\"\n     * emptyInputBehavior: \"focus\" - (default) currency sign displayed and the input receives focus\n     * emptyInputBehavior: \"press\" - currency sign displays on any key being pressed\n     * emptyInputBehavior: \"always\" - always displays the currency sign only\n     * emptyInputBehavior: \"zero\" - if the input has no value on focus out displays a zero \"rounded\" with or without a currency sign\n     * Deprecated older option name : wEmpty\n     */\n    emptyInputBehavior: 'focus',\n\n    /* Controls leading zero behavior\n     * leadingZero: \"allow\", - allows leading zeros to be entered. Zeros will be truncated when entering additional digits. On focusout zeros will be deleted.\n     * leadingZero: \"deny\", - allows only one leading zero on values less than one\n     * leadingZero: \"keep\", - allows leading zeros to be entered. on focusout zeros will be retained.\n     * Deprecated older option name : lZero\n     */\n    leadingZero: 'deny',\n\n    /* Determine if the default value will be formatted on initialization.\n     * true = automatically formats the default value on initialization\n     * false = will not format the default value on initialization\n     * Deprecated older option name : aForm\n     */\n    formatOnPageLoad: true,\n\n    /* Determine if the select all keyboard command will select the complete input text, or only the input numeric value\n     * Note : If the currency symbol is between the numeric value and the negative sign, only the numeric value will selected\n     * Deprecated older option name : sNumber\n     */\n    selectNumberOnly: false,\n\n    /* Helper option for ASP.NET postback\n     * should be the value of the unformatted default value\n     * examples:\n     * no default value=\"\" {defaultValueOverride: \"\"}\n     * value=1234.56 {defaultValueOverride: '1234.56'}\n     * Deprecated older option name : anDefault\n     */\n    defaultValueOverride: null,\n\n    /* Removes formatting on submit event\n     * this output format: positive nnnn.nn, negative -nnnn.nn\n     * review the 'unSet' method for other formats\n     * Deprecated older option name : unSetOnSubmit\n     */\n    unformatOnSubmit: false,\n\n    /* Allows the output to be in the locale format via the \"get\", \"getString\" & \"getArray\" methods\n     * null or 'string' => 'nnnn.nn' or '-nnnn.nn' as text type. This is the default behavior.\n     * 'number'         => nnnn.nn or -nnnn.nn as a Number (Warning: this works only for integers inferior to Number.MAX_SAFE_INTEGER)\n     * ',' or '-,'      => 'nnnn,nn' or '-nnnn,nn'\n     * '.-'             => 'nnnn.nn' or 'nnnn.nn-'\n     * ',-'             => 'nnnn,nn' or 'nnnn,nn-'\n     * Deprecated older option name : outputType\n     */\n    outputFormat: null,\n\n    /* Defines if warnings should be shown\n     * Error handling function\n     * true => all warning are shown\n     * false => no warnings are shown, only the thrown errors\n     * Deprecated older option name : debug\n     */\n    showWarnings: true,\n\n    /*\n     * This option is the 'strict mode' (aka 'debug' mode), which allows autoNumeric to strictly analyse the options passed, and fails if an unknown options is used in the settings object.\n     * You should set that to 'TRUE' if you want to make sure you are only using 'pure' autoNumeric settings objects in your code.\n     * If you see uncaught errors in the console and your code starts to fail, this means somehow those options gets corrupted by another program.\n     */\n    failOnUnknownOption: false\n};\n\n/**\n * Wrapper variable that hold named keyboard keys with their respective keyCode as seen in DOM events.\n * //TODO Replace every call to this object with a call to `keyName`\n * @deprecated\n */\nvar keyCode = {\n    Backspace: 8,\n    Tab: 9,\n    Enter: 13,\n    Shift: 16,\n    Ctrl: 17,\n    Alt: 18,\n    PauseBreak: 19,\n    CapsLock: 20,\n    Esc: 27,\n    Space: 32,\n    PageUp: 33,\n    PageDown: 34,\n    End: 35,\n    Home: 36,\n    LeftArrow: 37,\n    UpArrow: 38,\n    RightArrow: 39,\n    DownArrow: 40,\n    Insert: 45,\n    Delete: 46,\n    num0: 48,\n    num1: 49,\n    num2: 50,\n    num3: 51,\n    num4: 52,\n    num5: 53,\n    num6: 54,\n    num7: 55,\n    num8: 56,\n    num9: 57,\n    a: 65,\n    b: 66,\n    c: 67,\n    d: 68,\n    e: 69,\n    f: 70,\n    g: 71,\n    h: 72,\n    i: 73,\n    j: 74,\n    k: 75,\n    l: 76,\n    m: 77,\n    n: 78,\n    o: 79,\n    p: 80,\n    q: 81,\n    r: 82,\n    s: 83,\n    t: 84,\n    u: 85,\n    v: 86,\n    w: 87,\n    x: 88,\n    y: 89,\n    z: 90,\n    Windows: 91,\n    RightClick: 93,\n    numpad0: 96,\n    numpad1: 97,\n    numpad2: 98,\n    numpad3: 99,\n    numpad4: 100,\n    numpad5: 101,\n    numpad6: 102,\n    numpad7: 103,\n    numpad8: 104,\n    numpad9: 105,\n    MultiplyNumpad: 106,\n    PlusNumpad: 107,\n    MinusNumpad: 109,\n    DotNumpad: 110,\n    SlashNumpad: 111,\n    F1: 112,\n    F2: 113,\n    F3: 114,\n    F4: 115,\n    F5: 116,\n    F6: 117,\n    F7: 118,\n    F8: 119,\n    F9: 120,\n    F10: 121,\n    F11: 122,\n    F12: 123,\n    NumLock: 144,\n    ScrollLock: 145,\n    MyComputer: 182,\n    MyCalculator: 183,\n    Semicolon: 186,\n    Equal: 187,\n    Comma: 188,\n    Hyphen: 189,\n    Dot: 190,\n    Slash: 191,\n    Backquote: 192,\n    LeftBracket: 219,\n    Backslash: 220,\n    RightBracket: 221,\n    Quote: 222,\n    Command: 224\n};\n\n/**\n * Wrapper variable that hold named keyboard keys with their respective key name (as set in KeyboardEvent.key).\n * Those names are listed here :\n * @link https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key/Key_Values\n */\nvar keyName = {\n    // Special values\n    Unidentified: 'Unidentified',\n\n    // Modifier keys\n    Alt: 'Alt',\n    AltGr: 'AltGraph',\n    CapsLock: 'CapsLock', // Under Chrome, e.key is empty for CapsLock\n    Ctrl: 'Control',\n    Fn: 'Fn',\n    FnLock: 'FnLock',\n    Hyper: 'Hyper', // 'OS' under Firefox\n    Meta: 'Meta', // The Windows, Command or ⌘ key // 'OS' under Firefox and IE9\n    Windows: 'Meta', // This is a non-official key name\n    Command: 'Meta', // This is a non-official key name\n    NumLock: 'NumLock',\n    ScrollLock: 'ScrollLock',\n    Shift: 'Shift',\n    Super: 'Super', // 'OS' under Firefox\n    Symbol: 'Symbol',\n    SymbolLock: 'SymbolLock',\n\n    // Whitespace keys\n    Enter: 'Enter',\n    Tab: 'Tab',\n    Space: ' ', // 'Spacebar' for Firefox <37, and IE9\n\n    // Navigation keys\n    DownArrow: 'ArrowDown', // 'Down' for Firefox <=36, and IE9\n    LeftArrow: 'ArrowLeft', // 'Left' for Firefox <=36, and IE9\n    RightArrow: 'ArrowRight', // 'Right' for Firefox <=36, and IE9\n    UpArrow: 'ArrowUp', // 'Up' for Firefox <=36, and IE9\n    End: 'End',\n    Home: 'Home',\n    PageDown: 'PageDown',\n    PageUp: 'PageUp',\n\n    // Editing keys\n    Backspace: 'Backspace',\n    Clear: 'Clear',\n    Copy: 'Copy',\n    CrSel: 'CrSel', // 'Crsel' for Firefox <=36, and IE9\n    Cut: 'Cut',\n    Delete: 'Delete', // 'Del' for Firefox <=36, and IE9\n    EraseEof: 'EraseEof',\n    ExSel: 'ExSel', // 'Exsel' for Firefox <=36, and IE9\n    Insert: 'Insert',\n    Paste: 'Paste',\n    Redo: 'Redo',\n    Undo: 'Undo',\n\n    // UI keys\n    Accept: 'Accept',\n    Again: 'Again',\n    Attn: 'Attn', // 'Unidentified' for Firefox, Chrome, and IE9 ('KanaMode' when using the Japanese keyboard layout)\n    Cancel: 'Cancel',\n    ContextMenu: 'ContextMenu', // 'Apps' for Firefox <=36, and IE9\n    Esc: 'Escape', // 'Esc' for Firefox <=36, and IE9\n    Execute: 'Execute',\n    Find: 'Find',\n    Finish: 'Finish', // 'Unidentified' for Firefox, Chrome, and IE9 ('Katakana' when using the Japanese keyboard layout)\n    Help: 'Help',\n    Pause: 'Pause',\n    Play: 'Play',\n    Props: 'Props',\n    Select: 'Select',\n    ZoomIn: 'ZoomIn',\n    ZoomOut: 'ZoomOut',\n\n    // Device keys\n    BrightnessDown: 'BrightnessDown',\n    BrightnessUp: 'BrightnessUp',\n    Eject: 'Eject',\n    LogOff: 'LogOff',\n    Power: 'Power',\n    PowerOff: 'PowerOff',\n    PrintScreen: 'PrintScreen',\n    Hibernate: 'Hibernate', // 'Unidentified' for Firefox <=37\n    Standby: 'Standby', // 'Unidentified' for Firefox <=36, and IE9\n    WakeUp: 'WakeUp',\n\n    // IME and composition keys\n    Compose: 'Compose',\n    Dead: 'Dead',\n\n    // Function keys\n    F1: 'F1',\n    F2: 'F2',\n    F3: 'F3',\n    F4: 'F4',\n    F5: 'F5',\n    F6: 'F6',\n    F7: 'F7',\n    F8: 'F8',\n    F9: 'F9',\n    F10: 'F10',\n    F11: 'F11',\n    F12: 'F12',\n\n    // Document keys\n    Print: 'Print',\n\n    // 'Normal' keys\n    num0: '0',\n    num1: '1',\n    num2: '2',\n    num3: '3',\n    num4: '4',\n    num5: '5',\n    num6: '6',\n    num7: '7',\n    num8: '8',\n    num9: '9',\n    numpad0: '0',\n    numpad1: '1',\n    numpad2: '2',\n    numpad3: '3',\n    numpad4: '4',\n    numpad5: '5',\n    numpad6: '6',\n    numpad7: '7',\n    numpad8: '8',\n    numpad9: '9',\n    a: 'a',\n    b: 'b',\n    c: 'c',\n    d: 'd',\n    e: 'e',\n    f: 'f',\n    g: 'g',\n    h: 'h',\n    i: 'i',\n    j: 'j',\n    k: 'k',\n    l: 'l',\n    m: 'm',\n    n: 'n',\n    o: 'o',\n    p: 'p',\n    q: 'q',\n    r: 'r',\n    s: 's',\n    t: 't',\n    u: 'u',\n    v: 'v',\n    w: 'w',\n    x: 'x',\n    y: 'y',\n    z: 'z',\n    MultiplyNumpad: '*',\n    PlusNumpad: '+',\n    MinusNumpad: '-',\n    DotNumpad: '.',\n    SlashNumpad: '/',\n    Semicolon: ';',\n    Equal: '=',\n    Comma: ',',\n    Hyphen: '-',\n    Minus: '-',\n    Plus: '+',\n    Dot: '.',\n    Slash: '/',\n    Backquote: '`',\n    LeftBracket: '[',\n    RightBracket: ']',\n    Backslash: '\\\\',\n    Quote: \"'\",\n    NumpadDot: '.',\n    NumpadDotAlt: ',', // Modern browsers automatically adapt the character sent by this key to the decimal character of the current language\n    NumpadMultiply: '*',\n    NumpadPlus: '+',\n    NumpadMinus: '-',\n    NumpadSlash: '/',\n    NumpadDotObsoleteBrowsers: 'Decimal',\n    NumpadMultiplyObsoleteBrowsers: 'Multiply',\n    NumpadPlusObsoleteBrowsers: 'Add',\n    NumpadMinusObsoleteBrowsers: 'Subtract',\n    NumpadSlashObsoleteBrowsers: 'Divide'\n};\n\nvar defaultMinimumValue = '-999999999999.99';\nvar defaultMaximumValue = '999999999999.99';\nvar defaultRoundingMethod = 'U';\nvar defaultLeadingZero = 'deny';\nvar defaultSelectNumberOnly = true;\n\n/**\n * Predefined options for the most common languages\n */\nvar languageOption = {\n    French: { // Français\n        digitGroupSeparator: '.', // or '\\u202f'\n        decimalCharacter: ',',\n        decimalCharacterAlternative: '.',\n        currencySymbol: '\\u202F\\u20AC',\n        currencySymbolPlacement: 's',\n        selectNumberOnly: defaultSelectNumberOnly,\n        roundingMethod: defaultRoundingMethod,\n        leadingZero: defaultLeadingZero,\n        minimumValue: defaultMinimumValue,\n        maximumValue: defaultMaximumValue\n    },\n    NorthAmerican: {\n        digitGroupSeparator: ',',\n        decimalCharacter: '.',\n        currencySymbol: '$',\n        currencySymbolPlacement: 'p',\n        selectNumberOnly: defaultSelectNumberOnly,\n        roundingMethod: defaultRoundingMethod,\n        leadingZero: defaultLeadingZero,\n        minimumValue: defaultMinimumValue,\n        maximumValue: defaultMaximumValue\n    },\n    British: {\n        digitGroupSeparator: ',',\n        decimalCharacter: '.',\n        currencySymbol: '£',\n        currencySymbolPlacement: 'p',\n        selectNumberOnly: defaultSelectNumberOnly,\n        roundingMethod: defaultRoundingMethod,\n        leadingZero: defaultLeadingZero,\n        minimumValue: defaultMinimumValue,\n        maximumValue: defaultMaximumValue\n    },\n    Swiss: { // Suisse\n        digitGroupSeparator: '\\'',\n        decimalCharacter: '.',\n        currencySymbol: '\\u202FCHF',\n        currencySymbolPlacement: 's',\n        selectNumberOnly: defaultSelectNumberOnly,\n        roundingMethod: defaultRoundingMethod,\n        leadingZero: defaultLeadingZero,\n        minimumValue: defaultMinimumValue,\n        maximumValue: defaultMaximumValue\n    },\n    Japanese: { // 日本語\n        digitGroupSeparator: ',',\n        decimalCharacter: '.',\n        currencySymbol: '¥',\n        currencySymbolPlacement: 'p',\n        selectNumberOnly: defaultSelectNumberOnly,\n        roundingMethod: defaultRoundingMethod,\n        leadingZero: defaultLeadingZero,\n        minimumValue: defaultMinimumValue,\n        maximumValue: defaultMaximumValue\n    }\n};\nlanguageOption.Spanish = languageOption.French; // Español (idem French)\nlanguageOption.Chinese = languageOption.Japanese; // 中国語 (Chinese)\n\n/**\n * UMD structure\n */\n(function (factory) {\n    //TODO This surely can be improved by letting webpack take care of generating this UMD part\n    if (true) {\n        // AMD. Register as an anonymous module.\n        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(1)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    } else if ((typeof module === 'undefined' ? 'undefined' : _typeof(module)) === 'object' && module.exports) {\n        // Node/CommonJS\n        module.exports = factory(require('jquery'));\n    } else {\n        // Browser globals\n        factory(window.jQuery);\n    }\n})(function ($) {\n    // Helper functions\n\n    /**\n     * Return TRUE if the `value` is null\n     *\n     * @static\n     * @param {*} value The value to test\n     * @returns {boolean} Return TRUE if the `value` is null, FALSE otherwise\n     */\n    function isNull(value) {\n        return value === null;\n    }\n\n    /**\n     * Return TRUE if the `value` is undefined\n     *\n     * @static\n     * @param {*} value The value to test\n     * @returns {boolean} Return TRUE if the `value` is undefined, FALSE otherwise\n     */\n    function isUndefined(value) {\n        return value === void 0;\n    }\n\n    /**\n     * Return TRUE if the `value` is undefined, null or empty\n     *\n     * @param {*} value\n     * @returns {boolean}\n     */\n    function isUndefinedOrNullOrEmpty(value) {\n        return value === null || value === void 0 || '' === value;\n    }\n\n    /**\n     * Return TRUE if the given parameter is a String\n     *\n     * @param {*} str\n     * @returns {boolean}\n     */\n    function isString(str) {\n        return typeof str === 'string' || str instanceof String;\n    }\n\n    /**\n     * Return TRUE if the parameter is a boolean\n     *\n     * @static\n     * @param {*} value\n     * @returns {boolean}\n     */\n    function isBoolean(value) {\n        return typeof value === 'boolean';\n    }\n\n    /**\n     * Return TRUE if the parameter is a string 'true' or 'false'\n     *\n     * This function accepts any cases for those strings.\n     * @param {string} value\n     * @returns {boolean}\n     */\n    function isTrueOrFalseString(value) {\n        var lowercaseValue = String(value).toLowerCase();\n        return lowercaseValue === 'true' || lowercaseValue === 'false';\n    }\n\n    /**\n     * Return TRUE if the parameter is an object\n     *\n     * @param {*} reference\n     * @returns {boolean}\n     */\n    function isObject(reference) {\n        return (typeof reference === 'undefined' ? 'undefined' : _typeof(reference)) === 'object' && reference !== null && !Array.isArray(reference);\n    }\n\n    /**\n     * Return TRUE if the given object is empty\n     * cf. http://stackoverflow.com/questions/679915/how-do-i-test-for-an-empty-javascript-object and http://jsperf.com/empty-object-test\n     *\n     * @param {object} obj\n     * @returns {boolean}\n     */\n    function isEmptyObj(obj) {\n        for (var prop in obj) {\n            if (obj.hasOwnProperty(prop)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Return TRUE if the parameter is a number (or a number written as a string).\n     *\n     * @param {*} n\n     * @returns {boolean}\n     */\n    function isNumber(n) {\n        return !isArray(n) && !isNaN(parseFloat(n)) && isFinite(n);\n    }\n\n    /**\n     * Return TRUE if the parameter is an integer (and not a float).\n     *\n     * @param {*} n\n     * @returns {boolean}\n     */\n    function isInt(n) {\n        return typeof n === 'number' && parseFloat(n) === parseInt(n, 10) && !isNaN(n);\n    }\n\n    /**\n     * Return the pasted text that will be used.\n     *\n     * @param {string} text\n     * @param {AutoNumericHolder} holder\n     * @returns {string|void|XML|*}\n     */\n    function preparePastedText(text, holder) {\n        return stripAllNonNumberCharacters(text, holder.settingsClone, true).replace(holder.settingsClone.decimalCharacter, '.');\n    }\n\n    /**\n     * Return TRUE is the string `str` contains the string `needle`\n     * Note: this function does not coerce the parameters types\n     *\n     * @param {string} str\n     * @param {string} needle\n     * @returns {boolean}\n     */\n    function contains(str, needle) {\n        if (!isString(str) || !isString(needle) || str === '' || needle === '') {\n            return false;\n        }\n\n        return str.indexOf(needle) !== -1;\n    }\n\n    /**\n     * Return TRUE if the `needle` is in the array\n     *\n     * @param {*} needle\n     * @param {Array} array\n     * @returns {boolean}\n     */\n    function isInArray(needle, array) {\n        if (!isArray(array) || array === [] || isUndefined(needle)) {\n            return false;\n        }\n\n        return array.indexOf(needle) !== -1;\n    }\n\n    /**\n     * Return TRUE if the parameter is an Array\n     *\n     * @param {*} arr\n     * @throws Error\n     * @returns {*|boolean}\n     */\n    function isArray(arr) {\n        if (Object.prototype.toString.call([]) === '[object Array]') {\n            // Make sure an array has a class attribute of [object Array]\n            // Test passed, now check if is an Array\n            return Array.isArray(arr) || (typeof arr === 'undefined' ? 'undefined' : _typeof(arr)) === 'object' && Object.prototype.toString.call(arr) === '[object Array]';\n        } else {\n            throw new Error('toString message changed for Object Array'); // Verify that the string returned by `toString` does not change in the future (cf. http://stackoverflow.com/a/8365215)\n        }\n    }\n\n    /**\n     * Return TRUE if the parameter is a string that represents a float number, and that number has a decimal part\n     *\n     * @param {string} str\n     * @returns {boolean}\n     */\n    // function hasDecimals(str) {\n    //     const [, decimalPart] = str.split('.');\n    //     return !isUndefined(decimalPart);\n    // }\n\n    /**\n     * Return the number of decimal places if the parameter is a string that represents a float number, and that number has a decimal part.\n     *\n     * @param {string} str\n     * @returns {int}\n     */\n    function decimalPlaces(str) {\n        var _str$split = str.split('.'),\n            _str$split2 = _slicedToArray(_str$split, 2),\n            decimalPart = _str$split2[1];\n\n        if (!isUndefined(decimalPart)) {\n            return decimalPart.length;\n        }\n\n        return 0;\n    }\n\n    /**\n     * Return the code for the key used to generate the given event.\n     *\n     * @param {Event} event\n     * @returns {string|Number}\n     */\n    function keyCodeNumber(event) {\n        // `event.keyCode` and `event.which` are deprecated, `KeyboardEvent.key` (https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key) must be used now\n        return typeof event.which === 'undefined' ? event.keyCode : event.which;\n    }\n\n    /**\n     * Return the character from the event key code.\n     * @example character(50) => '2'\n     *\n     * @param {Event} event\n     * @returns {string}\n     */\n    function character(event) {\n        if (typeof event.key === 'undefined' || event.key === 'Unidentified') {\n            return String.fromCharCode(this.keyCodeNumber(event));\n        } else {\n            // Special case for obsolete browsers like IE that return the old names\n            var result = void 0;\n            switch (event.key) {\n                case 'Decimal':\n                    result = keyName.NumpadDot;\n                    break;\n                case 'Multiply':\n                    result = keyName.NumpadMultiply;\n                    break;\n                case 'Add':\n                    result = keyName.NumpadPlus;\n                    break;\n                case 'Subtract':\n                    result = keyName.NumpadMinus;\n                    break;\n                case 'Divide':\n                    result = keyName.NumpadSlash;\n                    break;\n                case 'Del':\n                    // Special workaround for the obsolete browser IE11 which output a 'Delete' key when using the numpad 'dot' one! This fixes issue #401 //FIXME à terminer\n                    result = keyName.Dot; // as of version 2.0.8 the character() function is only called on keypress event. The 'Del' does not throw the keypress event.\n                    break;\n                default:\n                    result = event.key;\n            }\n\n            return result;\n        }\n    }\n\n    /**\n     * Return TRUE if the given value (a number as a string) is within the range set in the settings `minimumValue` and `maximumValue`, FALSE otherwise.\n     *\n     * @param {string} value\n     * @param {object} parsedMinValue Parsed via the `parseStr()` function\n     * @param {object} parsedMaxValue Parsed via the `parseStr()` function\n     * @returns {boolean}\n     */\n    function checkIfInRange(value, parsedMinValue, parsedMaxValue) {\n        var parsedValue = parseStr(value);\n        return testMinMax(parsedMinValue, parsedValue) > -1 && testMinMax(parsedMaxValue, parsedValue) < 1;\n    }\n\n    /**\n     * Return TRUE if the given string contains a negative sign :\n     * - everywhere in the string (by default), or\n     * - on the first character only if the `checkEverywhere` parameter is set to `false`.\n     *\n     * @param {string} numericString A number represented by a string\n     * @param {boolean} checkEverywhere If TRUE, then the negative sign is search everywhere in the numeric string (this is needed for instance if the string is '1234.56-')\n     * @returns {boolean}\n     */\n    function isNegative(numericString) {\n        var checkEverywhere = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n        //TODO Use the `negativeSignCharacter` from the settings here\n        if (checkEverywhere) {\n            return contains(numericString, '-');\n        }\n\n        return isNegativeStrict(numericString);\n    }\n\n    /**\n     * Return TRUE if the given string contains a negative sign on the first character (on the far left).\n     *\n     * @example isNegativeStrict('1234.56')     => false\n     * @example isNegativeStrict('1234.56-')    => false\n     * @example isNegativeStrict('-1234.56')    => true\n     * @example isNegativeStrict('-1,234.56 €') => true\n     *\n     * @param {string} numericString\n     * @returns {boolean}\n     */\n    function isNegativeStrict(numericString) {\n        //TODO Using the `negativeSignCharacter` from the settings here\n        return numericString.charAt(0) === '-';\n    }\n\n    /**\n     * Return TRUE if the formatted or unformatted numeric string represent the value 0 (ie. '0,00 €'), or is empty (' €').\n     * This works since we test if there are any numbers from 1 to 9 in the string. If there is none, then the number is zero (or the string is empty).\n     *\n     * @param {string} numericString\n     * @returns {boolean}\n     */\n    function isZeroOrHasNoValue(numericString) {\n        return !/[1-9]/g.test(numericString);\n    }\n\n    /**\n     * Return the negative version of the value (represented as a string) given as a parameter.\n     *\n     * @param {string} value\n     * @returns {*}\n     */\n    function setRawNegativeSign(value) {\n        if (!isNegativeStrict(value)) {\n            return '-' + value;\n        }\n\n        return value;\n    }\n\n    /**\n     * Replace the character at the position `index` in the string `string` by the character(s) `newCharacter`.\n     *\n     * @param {string} string\n     * @param {int} index\n     * @param {string} newCharacter\n     * @returns {string}\n     */\n    function replaceCharAt(string, index, newCharacter) {\n        return '' + string.substr(0, index) + newCharacter + string.substr(index + newCharacter.length);\n    }\n\n    /**\n     * Return the value clamped to the nearest minimum/maximum value, as defined in the settings.\n     *\n     * @param {string|number} value\n     * @param {object} settings\n     * @returns {number}\n     */\n    function clampToRangeLimits(value, settings) {\n        //XXX This function always assume `settings.minimumValue` is lower than `settings.maximumValue`\n        return Math.max(settings.minimumValue, Math.min(settings.maximumValue, value));\n    }\n\n    /**\n     * Return the number of number or dot characters on the left side of the caret, in a formatted number.\n     *\n     * @param {string} formattedNumberString\n     * @param {int} caretPosition This must be a positive integer\n     * @param {string} decimalCharacter\n     * @returns {number}\n     */\n    function countNumberCharactersOnTheCaretLeftSide(formattedNumberString, caretPosition, decimalCharacter) {\n        // Here we count the dot and report it as a number character too, since it will 'stay' in the Javascript number when unformatted\n        var numberDotOrNegativeSign = new RegExp('[0-9' + decimalCharacter + '-]'); // No need to escape the decimal character here, since it's in `[]`\n\n        var numberDotAndNegativeSignCount = 0;\n        for (var i = 0; i < caretPosition; i++) {\n            // Test if the character is a number, a dot or an hyphen. If it is, count it, otherwise ignore it\n            if (numberDotOrNegativeSign.test(formattedNumberString[i])) {\n                numberDotAndNegativeSignCount++;\n            }\n        }\n\n        return numberDotAndNegativeSignCount;\n    }\n\n    /**\n     * Walk the `formattedNumberString` from left to right, one char by one, counting the `formattedNumberStringIndex`.\n     * If the char is in the `rawNumberString` (starting at index 0), then `rawNumberStringIndex++`, and continue until\n     * there is no more characters in `rawNumberString`) or that `rawNumberStringIndex === caretPositionInRawValue`.\n     * When you stop, the `formattedNumberStringIndex` is the position where the caret should be set.\n     *\n     * @example\n     * 1234567|89.01   : position 7 (rawNumberString)\n     * 123.456.7|89,01 : position 9 (formattedNumberString)\n     *\n     * @param {string} rawNumberString\n     * @param {int} caretPositionInRawValue\n     * @param {string} formattedNumberString\n     * @param {string} decimalCharacter\n     * @returns {*}\n     */\n    function findCaretPositionInFormattedNumber(rawNumberString, caretPositionInRawValue, formattedNumberString, decimalCharacter) {\n        var formattedNumberStringSize = formattedNumberString.length;\n        var rawNumberStringSize = rawNumberString.length;\n\n        var formattedNumberStringIndex = void 0;\n        var rawNumberStringIndex = 0;\n        for (formattedNumberStringIndex = 0; formattedNumberStringIndex < formattedNumberStringSize && rawNumberStringIndex < rawNumberStringSize && rawNumberStringIndex < caretPositionInRawValue; formattedNumberStringIndex++) {\n            if (rawNumberString[rawNumberStringIndex] === formattedNumberString[formattedNumberStringIndex] || rawNumberString[rawNumberStringIndex] === '.' && formattedNumberString[formattedNumberStringIndex] === decimalCharacter) {\n                rawNumberStringIndex++;\n            }\n        }\n\n        return formattedNumberStringIndex;\n    }\n\n    /**\n     * Count the number of occurrence of the given character, in the given text.\n     *\n     * @param {string} character\n     * @param {string} text\n     * @returns {number}\n     */\n    function countCharInText(character, text) {\n        var charCounter = 0;\n        for (var i = 0; i < text.length; i++) {\n            if (text[i] === character) {\n                charCounter++;\n            }\n        }\n\n        return charCounter;\n    }\n\n    /**\n     * Return the index that can be used to set the caret position.\n     * This takes into account that the position is starting at '0', not 1.\n     *\n     * @param {int} characterCount\n     * @returns {number}\n     */\n    function convertCharacterCountToIndexPosition(characterCount) {\n        return Math.max(characterCount, characterCount - 1);\n    }\n\n    /**\n     * Cross browser routine for getting selected range/cursor position\n     *\n     * @param {HTMLElement|EventTarget} that\n     * @returns {{}}\n     */\n    function getElementSelection(that) {\n        var position = {};\n        if (isUndefined(that.selectionStart)) {\n            that.focus();\n            var select = document.selection.createRange();\n            position.length = select.text.length;\n            select.moveStart('character', -that.value.length);\n            position.end = select.text.length;\n            position.start = position.end - position.length;\n        } else {\n            position.start = that.selectionStart;\n            position.end = that.selectionEnd;\n            position.length = position.end - position.start;\n        }\n\n        return position;\n    }\n\n    /**\n     * Cross browser routine for setting selected range/cursor position\n     *\n     * @param {HTMLElement|EventTarget} that\n     * @param {int} start\n     * @param {int|null} end\n     */\n    function setElementSelection(that, start) {\n        var end = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n\n        if (isUndefinedOrNullOrEmpty(end)) {\n            end = start;\n        }\n\n        if (isUndefined(that.selectionStart)) {\n            that.focus();\n            var range = that.createTextRange();\n            range.collapse(true);\n            range.moveEnd('character', end);\n            range.moveStart('character', start);\n            range.select();\n        } else {\n            that.selectionStart = start;\n            that.selectionEnd = end;\n        }\n    }\n\n    /**\n     * Function that throw error messages\n     *\n     * @param {string} message\n     */\n    function throwError(message) {\n        throw new Error(message);\n    }\n\n    /**\n     * Function that display a warning messages, according to the debug level.\n     *\n     * @param {string} message\n     * @param {boolean} showWarning If FALSE, then the warning message is not displayed\n     */\n    function warning(message) {\n        var showWarning = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n        if (showWarning) {\n            /* eslint no-console: 0 */\n            console.warn('Warning: ' + message);\n        }\n    }\n\n    // autoNumeric-specific functions\n\n    /**\n     * Run any callbacks found in the settings object.\n     * Any parameter could be a callback:\n     * - a function, which invoked with jQuery element, parameters and this parameter name and returns parameter value\n     * - a name of function, attached to $(selector).autoNumeric.functionName(){} - which was called previously\n     * @param {object} $this jQuery-selected DOM element\n     * @param {object} settings\n     */\n    function runCallbacksFoundInTheSettingsObject($this, settings) {\n        // Loops through the settings object (option array) to find the following\n        $.each(settings, function (k, val) {\n            if (typeof val === 'function') {\n                settings[k] = val($this, settings, k);\n            } else if (typeof $this.autoNumeric[val] === 'function') {\n                // Calls the attached function from the html5 data example: data-a-sign=\"functionName\"\n                settings[k] = $this.autoNumeric[val]($this, settings, k);\n            }\n        });\n    }\n\n    /**\n     * Determine the maximum decimal length from the minimumValue and maximumValue settings\n     *\n     * @param {string} minimumValue\n     * @param {string} maximumValue\n     * @returns {number}\n     */\n    function maximumVMinAndVMaxDecimalLength(minimumValue, maximumValue) {\n        return Math.max(decimalPlaces(minimumValue), decimalPlaces(maximumValue));\n    }\n\n    /**\n     * Strip all unwanted non-number characters.\n     * This keeps the numbers, the negative sign as well as the custom decimal character.\n     *\n     * @param {string} s\n     * @param {object} settings\n     * @param {boolean} leftOrAll\n     * @returns {string|*}\n     */\n    function stripAllNonNumberCharacters(s, settings, leftOrAll) {\n        //TODO This function is called 10 times (sic!) on each key input, couldn't we lower that number? cf. issue #325\n        //TODO Refactor this with `convertToNumericString()` if possible?\n        if (settings.currencySymbol !== '') {\n            // Remove currency sign\n            s = s.replace(settings.currencySymbol, '');\n        }\n        if (settings.suffixText) {\n            // Remove suffix\n            while (contains(s, settings.suffixText)) {\n                s = s.replace(settings.suffixText, '');\n            }\n        }\n\n        // First replace anything before digits\n        s = s.replace(settings.skipFirstAutoStrip, '$1$2');\n\n        if ((settings.negativePositiveSignPlacement === 's' || settings.currencySymbolPlacement === 's' && settings.negativePositiveSignPlacement !== 'p') && isNegative(s) && s !== '') {\n            settings.trailingNegative = true;\n        }\n\n        // Then replace anything after digits\n        s = s.replace(settings.skipLastAutoStrip, '$1');\n\n        // Then remove any uninteresting characters\n        s = s.replace(settings.allowedAutoStrip, '');\n        if (settings.decimalCharacterAlternative) {\n            s = s.replace(settings.decimalCharacterAlternative, settings.decimalCharacter);\n        }\n\n        // Get only number string\n        var m = s.match(settings.numRegAutoStrip);\n        s = m ? [m[1], m[2], m[3]].join('') : '';\n\n        if (settings.leadingZero === 'allow' || settings.leadingZero === 'keep') {\n            var nSign = '';\n\n            var _s$split = s.split(settings.decimalCharacter),\n                _s$split2 = _slicedToArray(_s$split, 2),\n                integerPart = _s$split2[0],\n                decimalPart = _s$split2[1];\n\n            var modifiedIntegerPart = integerPart;\n            if (contains(modifiedIntegerPart, settings.negativeSignCharacter)) {\n                nSign = settings.negativeSignCharacter;\n                modifiedIntegerPart = modifiedIntegerPart.replace(settings.negativeSignCharacter, '');\n            }\n\n            // Strip leading zero on positive value if need\n            if (nSign === '' && modifiedIntegerPart.length > settings.mIntPos && modifiedIntegerPart.charAt(0) === '0') {\n                modifiedIntegerPart = modifiedIntegerPart.slice(1);\n            }\n\n            // Strip leading zero on negative value if need\n            if (nSign !== '' && modifiedIntegerPart.length > settings.mIntNeg && modifiedIntegerPart.charAt(0) === '0') {\n                modifiedIntegerPart = modifiedIntegerPart.slice(1);\n            }\n\n            s = '' + nSign + modifiedIntegerPart + (isUndefined(decimalPart) ? '' : settings.decimalCharacter + decimalPart);\n        }\n\n        if (leftOrAll && settings.leadingZero === 'deny' || !settings.hasFocus && settings.leadingZero === 'allow') {\n            s = s.replace(settings.stripReg, '$1$2');\n        }\n\n        return s;\n    }\n\n    /**\n     * Sets or removes brackets on negative values, depending on the focus state.\n     * The focus state is 'stored' in the settings object under the `settings.hasFocus` attribute.\n     * //TODO Use another object to keep track of internal data that are not settings\n     *\n     * @param {string} s\n     * @param {object} settings\n     * @returns {*}\n     */\n    function toggleNegativeBracket(s, settings) {\n        if (settings.currencySymbolPlacement === 'p' && settings.negativePositiveSignPlacement === 'l' || settings.currencySymbolPlacement === 's' && settings.negativePositiveSignPlacement === 'p') {\n            //TODO Split the first and last bracket only once during the settings initialization\n            var _settings$negativeBra = settings.negativeBracketsTypeOnBlur.split(','),\n                _settings$negativeBra2 = _slicedToArray(_settings$negativeBra, 2),\n                firstBracket = _settings$negativeBra2[0],\n                lastBracket = _settings$negativeBra2[1];\n\n            if (!settings.hasFocus) {\n                // Add brackets\n                s = s.replace(settings.negativeSignCharacter, '');\n                s = firstBracket + s + lastBracket;\n            } else if (settings.hasFocus && s.charAt(0) === firstBracket) {\n                // Remove brackets\n                //TODO Quid if the negative sign is not on the left, shouldn't we replace the '-' sign at the right place?\n                s = s.replace(firstBracket, settings.negativeSignCharacter);\n                s = s.replace(lastBracket, '');\n            }\n        }\n\n        return s;\n    }\n\n    /**\n     * Return a number as a numeric string that can be typecast to a Number that Javascript will understand.\n     *\n     * This function return the given string by stripping the currency sign (currencySymbol), the grouping separators (digitalGroupSpacing) and by replacing the decimal character (decimalCharacter) by a dot.\n     * Lastly, it also put the negative sign back to its normal position if needed.\n     *\n     * @param {string} s\n     * @param {object} settings\n     * @returns {string|void|XML|*}\n     */\n    function convertToNumericString(s, settings) {\n        // Remove the currency symbol\n        s = s.replace(settings.currencySymbol, '');\n\n        // Remove the grouping separators (thousands separators usually)\n        s = s.replace(settings.digitGroupSeparator, '');\n\n        // Replace the decimal character by a dot\n        if (settings.decimalCharacter !== '.') {\n            s = s.replace(settings.decimalCharacter, '.');\n        }\n\n        // Move the trailing negative sign to the right position, if any\n        if (isNegative(s) && s.lastIndexOf('-') === s.length - 1) {\n            s = s.replace('-', '');\n            s = '-' + s;\n        }\n\n        // Convert any arabic numbers to latin ones\n        var temp = arabicToLatinNumbers(s, true, false, false);\n        if (!isNaN(temp)) {\n            s = temp.toString();\n        }\n\n        return s;\n    }\n\n    /**\n     * Converts the ISO numeric string to the locale decimal and minus sign placement.\n     * See the \"outputFormat\" option definition for more details.\n     *\n     * @param {string|null} value\n     * @param {string} locale\n     * @returns {*}\n     */\n    function toLocale(value, locale) {\n        if (isNull(locale) || locale === 'string') {\n            return value;\n        }\n\n        var result = void 0;\n        switch (locale) {\n            case 'number':\n                result = Number(value);\n                break;\n            case '.-':\n                result = isNegative(value) ? value.replace('-', '') + '-' : value;\n                break;\n            case ',':\n            case '-,':\n                result = value.replace('.', ',');\n                break;\n            case ',-':\n                result = value.replace('.', ',');\n                result = isNegative(result) ? result.replace('-', '') + '-' : result;\n                break;\n            // The default case\n            case '.':\n            case '-.':\n                result = value;\n                break;\n            default:\n                throwError('The given outputFormat [' + locale + '] option is not recognized.');\n        }\n\n        return result;\n    }\n\n    /**\n     * Modify the negative sign and the decimal character of the given string value to an hyphen (-) and a dot (.) in order to make that value 'typecastable' to a real number.\n     *\n     * @param {string} s\n     * @param {object} settings\n     * @returns {string}\n     */\n    function modifyNegativeSignAndDecimalCharacterForRawValue(s, settings) {\n        if (settings.decimalCharacter !== '.') {\n            s = s.replace(settings.decimalCharacter, '.');\n        }\n        if (settings.negativeSignCharacter !== '-' && settings.negativeSignCharacter !== '') {\n            s = s.replace(settings.negativeSignCharacter, '-');\n        }\n        if (!s.match(/\\d/)) {\n            // The default value returned by `get` is not formatted with decimals\n            s += '0';\n        }\n\n        return s;\n    }\n\n    /**\n     * Modify the negative sign and the decimal character to use those defined in the settings.\n     *\n     * @param {string} s\n     * @param {object} settings\n     * @returns {string}\n     */\n    function modifyNegativeSignAndDecimalCharacterForFormattedValue(s, settings) {\n        if (settings.negativeSignCharacter !== '-' && settings.negativeSignCharacter !== '') {\n            s = s.replace('-', settings.negativeSignCharacter);\n        }\n        if (settings.decimalCharacter !== '.') {\n            s = s.replace('.', settings.decimalCharacter);\n        }\n\n        return s;\n    }\n\n    /**\n     * Private function to check for empty value\n     * //TODO Modify this function so that it return either TRUE or FALSE if the value is empty. Then create another function to return the input value if it's not empty.\n     *\n     * @param {string} inputValue\n     * @param {object} settings\n     * @param {boolean} signOnEmpty\n     * @returns {*}\n     */\n    function checkEmpty(inputValue, settings, signOnEmpty) {\n        if (inputValue === '' || inputValue === settings.negativeSignCharacter) {\n            if (settings.emptyInputBehavior === 'always' || signOnEmpty) {\n                return settings.negativePositiveSignPlacement === 'l' ? inputValue + settings.currencySymbol + settings.suffixText : settings.currencySymbol + inputValue + settings.suffixText;\n            }\n\n            return inputValue;\n        }\n\n        return null;\n    }\n\n    /**\n     * Modify the input value by adding the group separators, as defined in the settings.\n     *\n     * @param {string} inputValue\n     * @param {object} settings\n     * @returns {*}\n     */\n    function addGroupSeparators(inputValue, settings) {\n        if (settings.strip) {\n            inputValue = stripAllNonNumberCharacters(inputValue, settings, false);\n        }\n\n        //TODO This function `addGroupSeparators()` add group separators. Adding the negative sign as well is out of its scope. Move that to another function.\n        if (settings.trailingNegative && !isNegative(inputValue)) {\n            inputValue = '-' + inputValue;\n        }\n\n        var empty = checkEmpty(inputValue, settings, true);\n        var isValueNegative = isNegative(inputValue);\n        var isZero = isZeroOrHasNoValue(inputValue);\n        if (isValueNegative) {\n            inputValue = inputValue.replace('-', '');\n        }\n\n        if (!isNull(empty)) {\n            return empty;\n        }\n\n        settings.digitalGroupSpacing = settings.digitalGroupSpacing.toString();\n        var digitalGroup = void 0;\n        switch (settings.digitalGroupSpacing) {\n            case '2':\n                digitalGroup = /(\\d)((\\d)(\\d{2}?)+)$/;\n                break;\n            case '2s':\n                digitalGroup = /(\\d)((?:\\d{2}){0,2}\\d{3}(?:(?:\\d{2}){2}\\d{3})*?)$/;\n                break;\n            case '4':\n                digitalGroup = /(\\d)((\\d{4}?)+)$/;\n                break;\n            default:\n                digitalGroup = /(\\d)((\\d{3}?)+)$/;\n        }\n\n        // Splits the string at the decimal string\n\n        var _inputValue$split = inputValue.split(settings.decimalCharacter),\n            _inputValue$split2 = _slicedToArray(_inputValue$split, 2),\n            integerPart = _inputValue$split2[0],\n            decimalPart = _inputValue$split2[1];\n\n        if (settings.decimalCharacterAlternative && isUndefined(decimalPart)) {\n            var _inputValue$split3 = inputValue.split(settings.decimalCharacterAlternative);\n\n            var _inputValue$split4 = _slicedToArray(_inputValue$split3, 2);\n\n            integerPart = _inputValue$split4[0];\n            decimalPart = _inputValue$split4[1];\n        }\n\n        if (settings.digitGroupSeparator !== '') {\n            // Re-inserts the thousand separator via a regular expression\n            while (digitalGroup.test(integerPart)) {\n                integerPart = integerPart.replace(digitalGroup, '$1' + settings.digitGroupSeparator + '$2');\n            }\n        }\n\n        if (settings.decimalPlacesOverride !== 0 && !isUndefined(decimalPart)) {\n            if (decimalPart.length > settings.decimalPlacesOverride) {\n                decimalPart = decimalPart.substring(0, settings.decimalPlacesOverride);\n            }\n\n            // Joins the whole number with the decimal value\n            inputValue = integerPart + settings.decimalCharacter + decimalPart;\n        } else {\n            // Otherwise if it's an integer\n            inputValue = integerPart;\n        }\n\n        settings.trailingNegative = false;\n\n        if (settings.currencySymbolPlacement === 'p') {\n            if (isValueNegative) {\n                switch (settings.negativePositiveSignPlacement) {\n                    case 'l':\n                        inputValue = '' + settings.negativeSignCharacter + settings.currencySymbol + inputValue;\n                        break;\n                    case 'r':\n                        inputValue = '' + settings.currencySymbol + settings.negativeSignCharacter + inputValue;\n                        break;\n                    case 's':\n                        inputValue = '' + settings.currencySymbol + inputValue + settings.negativeSignCharacter;\n                        settings.trailingNegative = true;\n                        break;\n                    default:\n                    //\n                }\n            } else if (settings.showPositiveSign && !isZero) {\n                switch (settings.negativePositiveSignPlacement) {\n                    case 'l':\n                        inputValue = '' + settings.positiveSignCharacter + settings.currencySymbol + inputValue;\n                        break;\n                    case 'r':\n                        inputValue = '' + settings.currencySymbol + settings.positiveSignCharacter + inputValue;\n                        break;\n                    case 's':\n                        inputValue = '' + settings.currencySymbol + inputValue + settings.positiveSignCharacter;\n                        break;\n                    default:\n                    //\n                }\n            } else {\n                inputValue = settings.currencySymbol + inputValue;\n            }\n        }\n\n        if (settings.currencySymbolPlacement === 's') {\n            if (isValueNegative) {\n                switch (settings.negativePositiveSignPlacement) {\n                    case 'r':\n                        inputValue = '' + inputValue + settings.currencySymbol + settings.negativeSignCharacter;\n                        settings.trailingNegative = true;\n                        break;\n                    case 'l':\n                        inputValue = '' + inputValue + settings.negativeSignCharacter + settings.currencySymbol;\n                        settings.trailingNegative = true;\n                        break;\n                    case 'p':\n                        inputValue = '' + settings.negativeSignCharacter + inputValue + settings.currencySymbol;\n                        break;\n                    default:\n                    //\n                }\n            } else if (settings.showPositiveSign && !isZero) {\n                switch (settings.negativePositiveSignPlacement) {\n                    case 'r':\n                        inputValue = '' + inputValue + settings.currencySymbol + settings.positiveSignCharacter;\n                        break;\n                    case 'l':\n                        inputValue = '' + inputValue + settings.positiveSignCharacter + settings.currencySymbol;\n                        break;\n                    case 'p':\n                        inputValue = '' + settings.positiveSignCharacter + inputValue + settings.currencySymbol;\n                        break;\n                    default:\n                    //\n                }\n            } else {\n                inputValue = inputValue + settings.currencySymbol;\n            }\n        }\n\n        // Removes the negative sign and places brackets\n        if (settings.negativeBracketsTypeOnBlur !== null && (settings.rawValue < 0 || isNegativeStrict(inputValue))) {\n            inputValue = toggleNegativeBracket(inputValue, settings);\n        }\n\n        return inputValue + settings.suffixText;\n    }\n\n    /**\n     * Truncate not needed zeros\n     *\n     * @param {string} roundedInputValue\n     * @param {int} temporaryDecimalPlacesOverride\n     * @returns {void|XML|string|*}\n     */\n    function truncateZeros(roundedInputValue, temporaryDecimalPlacesOverride) {\n        var regex = void 0;\n        switch (temporaryDecimalPlacesOverride) {\n            case 0:\n                // Prevents padding - removes trailing zeros until the first significant digit is encountered\n                regex = /(\\.(?:\\d*[1-9])?)0*$/;\n                break;\n            case 1:\n                // Allows padding when decimalPlacesOverride equals one - leaves one zero trailing the decimal character\n                regex = /(\\.\\d(?:\\d*[1-9])?)0*$/;\n                break;\n            default:\n                // Removes access zeros to the decimalPlacesOverride length when allowDecimalPadding is set to true\n                regex = new RegExp('(\\\\.\\\\d{' + temporaryDecimalPlacesOverride + '}(?:\\\\d*[1-9])?)0*');\n        }\n\n        // If there are no decimal places, we don't need a decimal point at the end\n        roundedInputValue = roundedInputValue.replace(regex, '$1');\n        if (temporaryDecimalPlacesOverride === 0) {\n            roundedInputValue = roundedInputValue.replace(/\\.$/, '');\n        }\n\n        return roundedInputValue;\n    }\n\n    /**\n     * Round the input value using the rounding method defined in the settings.\n     * This function accepts multiple rounding methods. See the documentation for more details about those.\n     *\n     * Note : This is handled as text since JavaScript math function can return inaccurate values.\n     *\n     * @param {string} inputValue\n     * @param {object} settings\n     * @returns {*}\n     */\n    function roundValue(inputValue, settings) {\n        inputValue = inputValue === '' ? '0' : inputValue.toString();\n        if (settings.roundingMethod === 'N05' || settings.roundingMethod === 'CHF' || settings.roundingMethod === 'U05' || settings.roundingMethod === 'D05') {\n            switch (settings.roundingMethod) {\n                case 'N05':\n                    inputValue = (Math.round(inputValue * 20) / 20).toString();\n                    break;\n                case 'U05':\n                    inputValue = (Math.ceil(inputValue * 20) / 20).toString();\n                    break;\n                default:\n                    inputValue = (Math.floor(inputValue * 20) / 20).toString();\n            }\n\n            var result = void 0;\n            if (!contains(inputValue, '.')) {\n                result = inputValue + '.00';\n            } else if (inputValue.length - inputValue.indexOf('.') < 3) {\n                result = inputValue + '0';\n            } else {\n                result = inputValue;\n            }\n            return result;\n        }\n\n        var ivRounded = '';\n        var i = 0;\n        var nSign = '';\n        var temporaryDecimalPlacesOverride = void 0;\n\n        // sets the truncate zero method\n        if (settings.allowDecimalPadding) {\n            temporaryDecimalPlacesOverride = settings.decimalPlacesOverride;\n        } else {\n            temporaryDecimalPlacesOverride = 0;\n        }\n\n        // Checks if the inputValue (input Value) is a negative value\n        if (isNegativeStrict(inputValue)) {\n            nSign = '-';\n\n            // Removes the negative sign that will be added back later if required\n            inputValue = inputValue.replace('-', '');\n        }\n\n        // Append a zero if the first character is not a digit (then it is likely to be a dot)\n        if (!inputValue.match(/^\\d/)) {\n            inputValue = '0' + inputValue;\n        }\n\n        // Determines if the value is equal to zero. If it is, remove the negative sign\n        if (Number(inputValue) === 0) {\n            nSign = '';\n        }\n\n        // Trims leading zero's as needed\n        if (Number(inputValue) > 0 && settings.leadingZero !== 'keep' || inputValue.length > 0 && settings.leadingZero === 'allow') {\n            inputValue = inputValue.replace(/^0*(\\d)/, '$1');\n        }\n\n        var dPos = inputValue.lastIndexOf('.');\n        var inputValueHasADot = dPos === -1;\n\n        // Virtual decimal position\n        var vdPos = inputValueHasADot ? inputValue.length - 1 : dPos;\n\n        // Checks decimal places to determine if rounding is required :\n        // Check if no rounding is required\n        var cDec = inputValue.length - 1 - vdPos;\n\n        if (cDec <= settings.decimalPlacesOverride) {\n            // Check if we need to pad with zeros\n            ivRounded = inputValue;\n            if (cDec < temporaryDecimalPlacesOverride) {\n                if (inputValueHasADot) {\n                    ivRounded += settings.decimalCharacter;\n                }\n\n                var zeros = '000000';\n                while (cDec < temporaryDecimalPlacesOverride) {\n                    zeros = zeros.substring(0, temporaryDecimalPlacesOverride - cDec);\n                    ivRounded += zeros;\n                    cDec += zeros.length;\n                }\n            } else if (cDec > temporaryDecimalPlacesOverride) {\n                ivRounded = truncateZeros(ivRounded, temporaryDecimalPlacesOverride);\n            } else if (cDec === 0 && temporaryDecimalPlacesOverride === 0) {\n                ivRounded = ivRounded.replace(/\\.$/, '');\n            }\n\n            return Number(ivRounded) === 0 ? ivRounded : nSign + ivRounded;\n        }\n\n        // Rounded length of the string after rounding\n        var rLength = void 0;\n        if (inputValueHasADot) {\n            rLength = settings.decimalPlacesOverride - 1;\n        } else {\n            rLength = settings.decimalPlacesOverride + dPos;\n        }\n\n        var tRound = Number(inputValue.charAt(rLength + 1));\n        var odd = inputValue.charAt(rLength) === '.' ? inputValue.charAt(rLength - 1) % 2 : inputValue.charAt(rLength) % 2;\n        var ivArray = inputValue.substring(0, rLength + 1).split('');\n\n        if (tRound > 4 && settings.roundingMethod === 'S' || // Round half up symmetric\n        tRound > 4 && settings.roundingMethod === 'A' && nSign === '' || // Round half up asymmetric positive values\n        tRound > 5 && settings.roundingMethod === 'A' && nSign === '-' || // Round half up asymmetric negative values\n        tRound > 5 && settings.roundingMethod === 's' || // Round half down symmetric\n        tRound > 5 && settings.roundingMethod === 'a' && nSign === '' || // Round half down asymmetric positive values\n        tRound > 4 && settings.roundingMethod === 'a' && nSign === '-' || // Round half down asymmetric negative values\n        tRound > 5 && settings.roundingMethod === 'B' || // Round half even \"Banker's Rounding\"\n        tRound === 5 && settings.roundingMethod === 'B' && odd === 1 || // Round half even \"Banker's Rounding\"\n        tRound > 0 && settings.roundingMethod === 'C' && nSign === '' || // Round to ceiling toward positive infinite\n        tRound > 0 && settings.roundingMethod === 'F' && nSign === '-' || // Round to floor toward negative infinite\n        tRound > 0 && settings.roundingMethod === 'U') {\n            // Round up away from zero\n            // Round up the last digit if required, and continue until no more 9's are found\n            for (i = ivArray.length - 1; i >= 0; i -= 1) {\n                if (ivArray[i] !== '.') {\n                    ivArray[i] = +ivArray[i] + 1;\n                    if (ivArray[i] < 10) {\n                        break;\n                    }\n\n                    if (i > 0) {\n                        ivArray[i] = '0';\n                    }\n                }\n            }\n        }\n\n        // Reconstruct the string, converting any 10's to 0's\n        ivArray = ivArray.slice(0, rLength + 1);\n\n        // Return the rounded value\n        ivRounded = truncateZeros(ivArray.join(''), temporaryDecimalPlacesOverride);\n\n        return Number(ivRounded) === 0 ? ivRounded : nSign + ivRounded;\n    }\n\n    /**\n     * Truncates the decimal part of a number.\n     *\n     * @param {string} s\n     * @param {object} settings\n     * @param {boolean} isPaste\n     * @returns {*}\n     */\n    function truncateDecimal(s, settings, isPaste) {\n        s = isPaste ? roundValue(s, settings) : s;\n\n        if (settings.decimalCharacter && settings.decimalPlacesOverride) {\n            var _s$split3 = s.split(settings.decimalCharacter),\n                _s$split4 = _slicedToArray(_s$split3, 2),\n                integerPart = _s$split4[0],\n                decimalPart = _s$split4[1];\n\n            // truncate decimal part to satisfying length since we would round it anyway\n\n\n            if (decimalPart && decimalPart.length > settings.decimalPlacesOverride) {\n                if (settings.decimalPlacesOverride > 0) {\n                    var modifiedDecimalPart = decimalPart.substring(0, settings.decimalPlacesOverride);\n                    s = '' + integerPart + settings.decimalCharacter + modifiedDecimalPart;\n                } else {\n                    s = integerPart;\n                }\n            }\n        }\n\n        return s;\n    }\n\n    /**\n     * Function to parse minimumValue, maximumValue & the input value to prepare for testing to determine if the value falls within the min / max range.\n     * Return an object example: minimumValue: \"999999999999999.99\" returns the following \"{s: -1, e: 12, c: Array[15]}\".\n     *\n     * This function is adapted from Big.js https://github.com/MikeMcl/big.js/. Many thanks to Mike.\n     *\n     * @param {number|string} n A numeric value.\n     * @returns {{}}\n     */\n    function parseStr(n) {\n        var x = {}; // A Big number instance.\n        var e = void 0;\n        var i = void 0;\n        var nL = void 0;\n        var j = void 0;\n\n        // Minus zero?\n        if (n === 0 && 1 / n < 0) {\n            n = '-0';\n        }\n\n        // Determine sign. 1 positive, -1 negative\n        n = n.toString();\n        if (isNegativeStrict(n)) {\n            n = n.slice(1);\n            x.s = -1;\n        } else {\n            x.s = 1;\n        }\n\n        // Decimal point?\n        e = n.indexOf('.');\n        if (e > -1) {\n            n = n.replace('.', '');\n        }\n\n        // length of string if no decimal character\n        if (e < 0) {\n            // Integer\n            e = n.length;\n        }\n\n        // Determine leading zeros\n        i = n.search(/[1-9]/i) === -1 ? n.length : n.search(/[1-9]/i);\n        nL = n.length;\n        if (i === nL) {\n            // Zero\n            x.e = 0;\n            x.c = [0];\n        } else {\n            // Determine trailing zeros\n            for (j = nL - 1; n.charAt(j) === '0'; j -= 1) {\n                nL -= 1;\n            }\n            nL -= 1;\n\n            // Decimal location\n            x.e = e - i - 1;\n            x.c = [];\n\n            // Convert string to array of digits without leading/trailing zeros\n            for (e = 0; i <= nL; i += 1) {\n                x.c[e] = +n.charAt(i);\n                e += 1;\n            }\n        }\n\n        return x;\n    }\n\n    /**\n     * Function to test if the input value falls with the Min / Max settings.\n     * This uses the parsed strings for the above parseStr function.\n     *\n     * This function is adapted from Big.js https://github.com/MikeMcl/big.js/. Many thanks to Mike.\n     *\n     * @param {object} y Big number instance\n     * @param {object} x Big number instance\n     * @returns {*}\n     */\n    function testMinMax(y, x) {\n        var xc = x.c;\n        var yc = y.c;\n        var i = x.s;\n        var j = y.s;\n        var k = x.e;\n        var l = y.e;\n\n        // Either zero?\n        if (!xc[0] || !yc[0]) {\n            var _result = void 0;\n            if (!xc[0]) {\n                _result = !yc[0] ? 0 : -j;\n            } else {\n                _result = i;\n            }\n            return _result;\n        }\n\n        // Signs differ?\n        if (i !== j) {\n            return i;\n        }\n        var xNeg = i < 0;\n\n        // Compare exponents\n        if (k !== l) {\n            return k > l ^ xNeg ? 1 : -1;\n        }\n        i = -1;\n        k = xc.length;\n        l = yc.length;\n        j = k < l ? k : l;\n\n        // Compare digit by digit\n        for (i += 1; i < j; i += 1) {\n            if (xc[i] !== yc[i]) {\n                return xc[i] > yc[i] ^ xNeg ? 1 : -1;\n            }\n        }\n\n        // Compare lengths\n        var result = void 0;\n        if (k === l) {\n            result = 0;\n        } else {\n            result = k > l ^ xNeg ? 1 : -1;\n        }\n\n        return result;\n    }\n\n    /**\n     * Check that the number satisfy the format conditions\n     * and lays between settings.minimumValue and settings.maximumValue\n     * and the string length does not exceed the digits in settings.minimumValue and settings.maximumValue\n     *\n     * @param {string} s\n     * @param {object} settings\n     * @returns {*}\n     */\n    function checkIfInRangeWithOverrideOption(s, settings) {\n        s = s.toString();\n        s = s.replace(',', '.');\n        var minParse = parseStr(settings.minimumValue);\n        var maxParse = parseStr(settings.maximumValue);\n        var valParse = parseStr(s);\n\n        var result = void 0;\n        switch (settings.overrideMinMaxLimits) {\n            case 'floor':\n                result = [testMinMax(minParse, valParse) > -1, true];\n                break;\n            case 'ceiling':\n                result = [true, testMinMax(maxParse, valParse) < 1];\n                break;\n            case 'ignore':\n                result = [true, true];\n                break;\n            default:\n                result = [testMinMax(minParse, valParse) > -1, testMinMax(maxParse, valParse) < 1];\n        }\n\n        return result;\n    }\n\n    /**\n     * Thanks to Anthony & Evan C\n     *\n     * @param {Element|string} element\n     * @returns {*|jQuery|HTMLElement}\n     */\n    function getCurrentElement(element) {\n        /*\n         * If the parameter is a string (and therefore is a CSS selector), then we need to modify this string in order\n         * for jQuery to be able to parse the selector correctly.\n         * cf. http://learn.jquery.com/using-jquery-core/faq/how-do-i-select-an-element-by-an-id-that-has-characters-used-in-css-notation/\n         */\n        if (isString(element)) {\n            //TODO This block is apparently never entered. We should remove it after making sure that's 100% the case\n            element = '#' + element.replace(/(:|\\.|\\[|]|,|=)/g, '\\\\$1');\n        }\n\n        return $(element);\n    }\n\n    /**\n     * Function that attach the autoNumeric field properties to the DOM element via an AutoNumericHolder object.\n     *\n     * @param {object} $this jQuery-selected DOM element\n     * @param {object} settings\n     * @param {boolean} update\n     * @returns {*}\n     */\n    function getAutoNumericHolder($this, settings) {\n        var update = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n        var data = $this.data('autoNumeric');\n        if (!data) {\n            data = {};\n            $this.data('autoNumeric', data);\n        }\n\n        var holder = data.holder;\n        if (update || isUndefined(holder) && settings) {\n            holder = new AutoNumericHolder($this.get(0), settings);\n            data.holder = holder;\n        }\n\n        return holder;\n    }\n\n    /**\n     * Original settings saved for use when decimalPlacesShownOnFocus & noSeparatorOnFocus options are being used.\n     * Those original settings are used exclusively in the `focusin` and `focusout` event handlers.\n     *\n     * @param {object} settings\n     */\n    function keepAnOriginalSettingsCopy(settings) {\n        //TODO Rename the old option names to the new ones\n        settings.oDec = settings.decimalPlacesOverride;\n        settings.oPad = settings.allowDecimalPadding;\n        settings.oBracket = settings.negativeBracketsTypeOnBlur;\n        settings.oSep = settings.digitGroupSeparator;\n        settings.oSign = settings.currencySymbol;\n        settings.oSuffix = settings.suffixText;\n    }\n\n    /**\n     * Original settings saved for use when `decimalPlacesShownOnFocus` & `noSeparatorOnFocus` options are being used.\n     * This is taken from Quirksmode.\n     *\n     * @param {string} name\n     * @returns {*}\n     */\n    function readCookie(name) {\n        var nameEQ = name + '=';\n        var ca = document.cookie.split(';');\n        var c = '';\n        for (var i = 0; i < ca.length; i += 1) {\n            c = ca[i];\n            while (c.charAt(0) === ' ') {\n                c = c.substring(1, c.length);\n            }\n            if (c.indexOf(nameEQ) === 0) {\n                return c.substring(nameEQ.length, c.length);\n            }\n        }\n\n        return null;\n    }\n\n    /**\n     * Test if sessionStorage is supported.\n     * This is taken from Modernizr.\n     *\n     * @returns {boolean}\n     */\n    function storageTest() {\n        var mod = 'modernizr';\n        try {\n            sessionStorage.setItem(mod, mod);\n            sessionStorage.removeItem(mod);\n            return true;\n        } catch (e) {\n            return false;\n        }\n    }\n\n    /**\n     * properly formats the string to a numeric when leadingZero does not 'keep'.\n     *\n     * @param {string} value\n     * @param {object} settings\n     * @returns {string}\n     */\n    function cleanLeadingTrailingZeros(value, settings) {\n        // Return the empty string is the value is already empty. This prevent converting that value to '0'.\n        if (value === '') {\n            return '';\n        }\n\n        // Return '0' if the value is zero\n        if (Number(value) === 0 && settings.leadingZero !== 'keep') {\n            return '0';\n        }\n\n        if (settings.leadingZero !== 'keep') {\n            // Trim leading zero's - leaves one zero to the left of the decimal point\n            value = value.replace(/^(-)?0+(?=\\d)/g, '$1');\n\n            //TODO remove this from that function and use `trimPaddedZerosFromDecimalPlaces()` instead. Also create a new `trailingZero` option.\n            if (contains(value, '.')) {\n                // Trims trailing zeros after the decimal point\n                value = value.replace(/(\\.[0-9]*?)0+$/, '$1');\n            }\n        }\n        // Strips trailing decimal point\n        value = value.replace(/\\.$/, '');\n\n        return value;\n    }\n\n    /**\n     * Remove the trailing zeros in the decimal part of a number.\n     *\n     * @param {string} numericString\n     * @returns {*}\n     */\n    function trimPaddedZerosFromDecimalPlaces(numericString) {\n        var _numericString$split = numericString.split('.'),\n            _numericString$split2 = _slicedToArray(_numericString$split, 2),\n            integerPart = _numericString$split2[0],\n            decimalPart = _numericString$split2[1];\n\n        if (isUndefinedOrNullOrEmpty(decimalPart)) {\n            return integerPart;\n        }\n\n        var trimmedDecimalPart = decimalPart.replace(/0+$/g, '');\n\n        var result = void 0;\n        if (trimmedDecimalPart === '') {\n            result = integerPart;\n        } else {\n            result = integerPart + '.' + trimmedDecimalPart;\n        }\n\n        return result;\n    }\n\n    /**\n     * Creates or removes sessionStorage or cookie depending on what the browser is supporting.\n     *\n     * @param {Element|EventTarget} element\n     * @param {object} settings\n     * @param {string} action\n     * @returns {*}\n     */\n    function saveValueToPersistentStorage(element, settings, action) {\n        if (settings.saveValueToSessionStorage) {\n            var storedName = element.name !== '' && !isUndefined(element.name) ? 'AUTO_' + decodeURIComponent(element.name) : 'AUTO_' + element.id;\n            var date = void 0;\n            var expires = void 0;\n\n            // Sets cookie for browser that do not support sessionStorage IE 6 & IE 7\n            if (storageTest() === false) {\n                switch (action) {\n                    case 'set':\n                        document.cookie = storedName + '=' + settings.rawValue + '; expires= ; path=/';\n                        break;\n                    case 'wipe':\n                        date = new Date();\n                        date.setTime(date.getTime() + -1 * 24 * 60 * 60 * 1000);\n                        expires = '; expires=' + date.toUTCString(); // Note : `toGMTString()` has been deprecated (cf. https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/toGMTString)\n                        document.cookie = storedName + '=\\'\\' ;' + expires + '; path=/';\n                        break;\n                    case 'get':\n                        return readCookie(storedName);\n                }\n            } else {\n                switch (action) {\n                    case 'set':\n                        sessionStorage.setItem(storedName, settings.rawValue);\n                        break;\n                    case 'wipe':\n                        sessionStorage.removeItem(storedName);\n                        break;\n                    case 'get':\n                        return sessionStorage.getItem(storedName);\n                }\n            }\n        }\n    }\n\n    /**\n     * Holder object for field properties\n     */\n\n    var AutoNumericHolder = function () {\n        /**\n         * Class constructor\n         *\n         * @param {HTMLElement} that - A reference to the current DOM element\n         * @param {object} settings\n         */\n        function AutoNumericHolder(that, settings) {\n            _classCallCheck(this, AutoNumericHolder);\n\n            this.settings = settings;\n            this.that = that;\n            this.$that = $(that);\n            this.formatted = false;\n            this.settingsClone = settings;\n            this.value = that.value;\n        }\n\n        /**\n         * Update the value and the selection values inside the AutoNumericHolder object.\n         * This keeps tracks of the input value, as well as the current selection.\n         * This also resets the 'processed' and 'formatted' state.\n         *\n         * Note : Those two can change between the keydown, keypress and keyup events, that's why\n         *        this function is called on each event handler.\n         *\n         * @private\n         */\n\n\n        _createClass(AutoNumericHolder, [{\n            key: '_updateAutoNumericHolderProperties',\n            value: function _updateAutoNumericHolderProperties() {\n                this.value = this.that.value;\n                this.selection = getElementSelection(this.that);\n                this.processed = false;\n                this.formatted = false;\n            }\n\n            /**\n             * Update the keycode of the key that triggered the given event.\n             * Note : e.which is sometimes different than e.keyCode during the keypress event, when entering a printable character key (ie. 't'). `e.which` equals 0 for non-printable characters.\n             *\n             * //TODO Switch to the non-deprecated e.key attribute, instead of inconsistant e.which and e.keyCode.\n             * e.key describe the key name used to trigger the event.\n             * e.keyCode being deprecated : https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/keyCode\n             * How e.key works : https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key\n             * The key list is described here\n             * @link https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key/Key_Values\n             *\n             * @param {Event} e\n             * @private\n             */\n\n        }, {\n            key: '_updateAutoNumericHolderEventKeycode',\n            value: function _updateAutoNumericHolderEventKeycode(e) {\n                // Note: the keypress event overwrites meaningful value of e.keyCode, hence we do not update that value on 'keypress'\n                this.eventKeyCode = keyCodeNumber(e);\n            }\n\n            /**\n             * Set the text selection inside the input with the given start and end position.\n             *\n             * @param {int} start\n             * @param {int} end\n             * @param {undefined|boolean} setReal\n             * @private\n             */\n\n        }, {\n            key: '_setSelection',\n            value: function _setSelection(start, end, setReal) {\n                //TODO Modify setReal to be more explicit (and a boolean)\n                start = Math.max(start, 0);\n                end = Math.min(end, this.that.value.length); //TODO Replace `this.that.value.length` with `this.value.length`\n                this.selection = {\n                    start: start,\n                    end: end,\n                    length: end - start\n                };\n\n                if (isUndefined(setReal) || setReal) {\n                    setElementSelection(this.that, start, end);\n                }\n            }\n\n            /**\n             * Set the caret position inside the input at the given position.\n             *\n             * @param {int} pos\n             * @param {undefined|boolean} setReal\n             * @private\n             */\n\n        }, {\n            key: '_setCaretPosition',\n            value: function _setCaretPosition(pos, setReal) {\n                //TODO Modify setReal to be more explicit (and a boolean)\n                this._setSelection(pos, pos, setReal);\n            }\n\n            /**\n             * Return an array containing the string parts located on the left and right side of the caret or selection.\n             * Those parts are left 'untouched', ie. formatted by autoNumeric.\n             *\n             * @returns {[string, string]} The parts on the left and right of the caret or selection\n             * @private\n             */\n\n        }, {\n            key: '_getLeftAndRightPartAroundTheSelection',\n            value: function _getLeftAndRightPartAroundTheSelection() {\n                var value = this.value;\n                var left = value.substring(0, this.selection.start);\n                var right = value.substring(this.selection.end, value.length);\n\n                return [left, right];\n            }\n\n            /**\n             * Return an array containing the string parts located on the left and right side of the caret or selection.\n             * Those parts are unformatted (stripped) of any non-numbers characters.\n             *\n             * @returns {[string, string]} The parts on the left and right of the caret or selection, unformatted.\n             * @private\n             */\n\n        }, {\n            key: '_getUnformattedLeftAndRightPartAroundTheSelection',\n            value: function _getUnformattedLeftAndRightPartAroundTheSelection() {\n                var settingsClone = this.settingsClone;\n\n                var _getLeftAndRightPartA = this._getLeftAndRightPartAroundTheSelection(),\n                    _getLeftAndRightPartA2 = _slicedToArray(_getLeftAndRightPartA, 2),\n                    left = _getLeftAndRightPartA2[0],\n                    right = _getLeftAndRightPartA2[1];\n\n                if (left === '' && right === '') {\n                    settingsClone.trailingNegative = false;\n                }\n                // if changing the sign and left is equal to the number zero - prevents stripping the leading zeros\n                var stripZeros = true;\n                if (this.eventKeyCode === keyCode.Hyphen && Number(left) === 0) {\n                    stripZeros = false;\n                }\n                left = stripAllNonNumberCharacters(left, this.settingsClone, stripZeros);\n                right = stripAllNonNumberCharacters(right, this.settingsClone, false);\n\n                if (settingsClone.trailingNegative && !isNegative(left)) {\n                    left = '-' + left;\n                    right = right === '-' ? '' : right;\n                    settingsClone.trailingNegative = false;\n                }\n\n                return [left, right];\n            }\n\n            /**\n             * Strip parts from excess characters and leading zeros.\n             *\n             * @param {string} left\n             * @param {string} right\n             * @returns {[*,*]}\n             * @private\n             */\n\n        }, {\n            key: '_normalizeParts',\n            value: function _normalizeParts(left, right) {\n                var settingsClone = this.settingsClone;\n\n                // if changing the sign and left is equal to the number zero - prevents stripping the leading zeros\n                var stripZeros = true;\n                if (this.eventKeyCode === keyCode.Hyphen && Number(left) === 0) {\n                    stripZeros = false;\n                }\n                left = stripAllNonNumberCharacters(left, settingsClone, stripZeros);\n\n                // If right is not empty and first character is not decimalCharacter\n                right = stripAllNonNumberCharacters(right, settingsClone, false);\n\n                // Prevents multiple leading zeros from being entered\n                if (settingsClone.leadingZero === 'deny' && (this.eventKeyCode === keyCode.num0 || this.eventKeyCode === keyCode.numpad0) && Number(left) === 0 && !contains(left, settingsClone.decimalCharacter) && right !== '') {\n                    left = left.substring(0, left.length - 1);\n                }\n\n                if (settingsClone.trailingNegative && !isNegative(left)) {\n                    left = '-' + left;\n                    settingsClone.trailingNegative = false;\n                }\n\n                // Insert zero if has leading dot\n                this.newValue = left + right;\n                if (settingsClone.decimalCharacter) {\n                    var m = this.newValue.match(new RegExp('^' + settingsClone.aNegRegAutoStrip + '\\\\' + settingsClone.decimalCharacter));\n                    if (m) {\n                        left = left.replace(m[1], m[1] + '0');\n                        this.newValue = left + right;\n                    }\n                }\n\n                return [left, right];\n            }\n\n            /**\n             * Set part of number to value while keeping the cursor position. //TODO What about the cursor selection?\n             *\n             * @param {string} left\n             * @param {string} right\n             * @param {boolean} isPaste\n             * @returns {boolean}\n             * @private\n             */\n\n        }, {\n            key: '_setValueParts',\n            value: function _setValueParts(left, right) {\n                var isPaste = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n                var settingsClone = this.settingsClone;\n                var parts = this._normalizeParts(left, right);\n\n                var _checkIfInRangeWithOv = checkIfInRangeWithOverrideOption(this.newValue, settingsClone),\n                    _checkIfInRangeWithOv2 = _slicedToArray(_checkIfInRangeWithOv, 2),\n                    minTest = _checkIfInRangeWithOv2[0],\n                    maxTest = _checkIfInRangeWithOv2[1];\n\n                var position = parts[0].length;\n                this.newValue = parts.join('');\n\n                if (minTest && maxTest) {\n                    this.newValue = truncateDecimal(this.newValue, settingsClone, isPaste);\n                    //TODO Check if we need to replace the hard-coded ',' with settings.decimalCharacter\n                    var testValue = contains(this.newValue, ',') ? this.newValue.replace(',', '.') : this.newValue;\n                    if (testValue === '' || testValue === settingsClone.negativeSignCharacter) {\n                        settingsClone.rawValue = settingsClone.emptyInputBehavior === 'zero' ? '0' : '';\n                    } else {\n                        settingsClone.rawValue = cleanLeadingTrailingZeros(testValue, settingsClone);\n                    }\n\n                    if (position > this.newValue.length) {\n                        position = this.newValue.length;\n                    }\n\n                    // Make sure when the user enter a '0' on the far left with a leading zero option set to 'deny', that the caret does not moves since the input is dropped (fix issue #283)\n                    if (position === 1 && parts[0] === '0' && settingsClone.leadingZero === 'deny') {\n                        // If the user enter `0`, then the caret is put on the right side of it (Fix issue #299)\n                        if (parts[1] === '' || parts[0] === '0' && parts[1] !== '') {\n                            position = 1;\n                        } else {\n                            position = 0;\n                        }\n                    }\n\n                    this.value = this.newValue;\n                    this._setCaretPosition(position, false);\n\n                    return true;\n                }\n\n                if (!minTest) {\n                    this.$that.trigger('autoNumeric:minExceeded');\n                } else if (!maxTest) {\n                    this.$that.trigger('autoNumeric:maxExceeded');\n                }\n\n                return false;\n            }\n\n            /**\n             * Helper function for `_expandSelectionOnSign()`.\n             *\n             * @returns {*} Sign position of a formatted value\n             * @private\n             */\n\n        }, {\n            key: '_getSignPosition',\n            value: function _getSignPosition() {\n                var settingsClone = this.settingsClone;\n                var currencySymbol = settingsClone.currencySymbol;\n                var that = this.that;\n\n                if (currencySymbol) {\n                    var currencySymbolLen = currencySymbol.length;\n                    if (settingsClone.currencySymbolPlacement === 'p') {\n                        var hasNeg = settingsClone.negativeSignCharacter && that.value && that.value.charAt(0) === settingsClone.negativeSignCharacter;\n                        return hasNeg ? [1, currencySymbolLen + 1] : [0, currencySymbolLen];\n                    }\n                    var valueLen = that.value.length;\n                    return [valueLen - currencySymbolLen, valueLen];\n                }\n\n                return [1000, -1];\n            }\n\n            /**\n             * Expands selection to cover whole sign\n             * Prevents partial deletion/copying/overwriting of a sign\n             *\n             * @param {undefined|boolean} setReal\n             * @private\n             */\n\n        }, {\n            key: '_expandSelectionOnSign',\n            value: function _expandSelectionOnSign(setReal) {\n                //TODO Modify setReal to be more explicit (and a boolean only)\n                //TODO Use array destructuring here to set signPosition to more explicit variables\n                var signPosition = this._getSignPosition();\n                var selection = this.selection;\n\n                // If selection catches something except sign and catches only space from sign\n                if (selection.start < signPosition[1] && selection.end > signPosition[0]) {\n                    // Then select without empty space\n                    if ((selection.start < signPosition[0] || selection.end > signPosition[1]) && this.value.substring(Math.max(selection.start, signPosition[0]), Math.min(selection.end, signPosition[1])).match(/^\\s*$/)) {\n                        if (selection.start < signPosition[0]) {\n                            this._setSelection(selection.start, signPosition[0], setReal);\n                        } else {\n                            this._setSelection(signPosition[1], selection.end, setReal);\n                        }\n                    } else {\n                        // Else select with whole sign\n                        this._setSelection(Math.min(selection.start, signPosition[0]), Math.max(selection.end, signPosition[1]), setReal);\n                    }\n                }\n            }\n\n            /**\n             * Try to strip pasted value to digits\n             */\n\n        }, {\n            key: '_checkPaste',\n            value: function _checkPaste() {\n                if (!isUndefined(this.valuePartsBeforePaste)) {\n                    var oldParts = this.valuePartsBeforePaste;\n\n                    var _getLeftAndRightPartA3 = this._getLeftAndRightPartAroundTheSelection(),\n                        _getLeftAndRightPartA4 = _slicedToArray(_getLeftAndRightPartA3, 2),\n                        left = _getLeftAndRightPartA4[0],\n                        right = _getLeftAndRightPartA4[1];\n\n                    // Try to strip the pasted value first\n\n\n                    delete this.valuePartsBeforePaste;\n\n                    var modifiedLeftPart = left.substr(0, oldParts[0].length) + stripAllNonNumberCharacters(left.substr(oldParts[0].length), this.settingsClone, true);\n                    if (!this._setValueParts(modifiedLeftPart, right, true)) {\n                        this.value = oldParts.join('');\n                        this._setCaretPosition(oldParts[0].length, false);\n                    }\n                }\n            }\n\n            /**\n             * Process pasting, cursor moving and skipping of not interesting keys.\n             * If this function returns TRUE, then further processing is not performed.\n             *\n             * @param {Event} e\n             * @returns {boolean}\n             * @private\n             */\n\n        }, {\n            key: '_skipAlways',\n            value: function _skipAlways(e) {\n                // Catch the ctrl up on ctrl-v\n                if ((e.ctrlKey || e.metaKey) && e.type === 'keyup' && !isUndefined(this.valuePartsBeforePaste) || e.shiftKey && this.eventKeyCode === keyCode.Insert) {\n                    //TODO Move this test inside the `onKeyup` handler\n                    this._checkPaste();\n                    return false;\n                }\n\n                // Skip all function keys (F1-F12), Windows keys, tab and other special keys\n                if (this.eventKeyCode >= keyCode.F1 && this.eventKeyCode <= keyCode.F12 || this.eventKeyCode >= keyCode.Windows && this.eventKeyCode <= keyCode.RightClick || this.eventKeyCode >= keyCode.Tab && this.eventKeyCode < keyCode.Space ||\n                // `e.which` is sometimes different than `this.eventKeyCode` during the keypress event when entering a printable character key (ie. 't'). Also, `e.which` equals 0 for non-printable characters.\n                this.eventKeyCode < keyCode.Backspace && (e.which === 0 || e.which === this.eventKeyCode) || this.eventKeyCode === keyCode.NumLock || this.eventKeyCode === keyCode.ScrollLock || this.eventKeyCode === keyCode.Insert || this.eventKeyCode === keyCode.Command) {\n                    return true;\n                }\n\n                // If a \"Select all\" keyboard shortcut is detected (ctrl + a)\n                if ((e.ctrlKey || e.metaKey) && this.eventKeyCode === keyCode.a) {\n                    if (this.settings.selectNumberOnly) {\n                        // `preventDefault()` is used here to prevent the browser to first select all the input text (including the currency sign), otherwise we would see that whole selection first in a flash, then the selection with only the number part without the currency sign.\n                        e.preventDefault();\n                        var valueLen = this.that.value.length;\n                        var currencySymbolLen = this.settings.currencySymbol.length;\n                        var negLen = !isNegative(this.that.value) ? 0 : 1;\n                        var suffixTextLen = this.settings.suffixText.length;\n                        var currencySymbolPlacement = this.settings.currencySymbolPlacement;\n                        var negativePositiveSignPlacement = this.settings.negativePositiveSignPlacement;\n\n                        var start = void 0;\n                        if (currencySymbolPlacement === 's') {\n                            start = 0;\n                        } else {\n                            start = negativePositiveSignPlacement === 'l' && negLen === 1 && currencySymbolLen > 0 ? currencySymbolLen + 1 : currencySymbolLen;\n                        }\n\n                        var end = void 0;\n                        if (currencySymbolPlacement === 'p') {\n                            end = valueLen - suffixTextLen;\n                        } else {\n                            switch (negativePositiveSignPlacement) {\n                                case 'l':\n                                    end = valueLen - (suffixTextLen + currencySymbolLen);\n                                    break;\n                                case 'r':\n                                    end = currencySymbolLen > 0 ? valueLen - (currencySymbolLen + negLen + suffixTextLen) : valueLen - (currencySymbolLen + suffixTextLen);\n                                    break;\n                                default:\n                                    end = valueLen - (currencySymbolLen + suffixTextLen);\n                            }\n                        }\n\n                        setElementSelection(this.that, start, end);\n                    }\n\n                    return true;\n                }\n\n                // If a \"Copy\", \"Paste\" or \"Cut\" keyboard shortcut is detected (respectively 'ctrl + c', 'ctrl + v' or 'ctrl + x')\n                if ((e.ctrlKey || e.metaKey) && (this.eventKeyCode === keyCode.c || this.eventKeyCode === keyCode.v || this.eventKeyCode === keyCode.x)) {\n                    if (e.type === 'keydown') {\n                        this._expandSelectionOnSign();\n                    }\n\n                    // Try to prevent wrong paste\n                    if (this.eventKeyCode === keyCode.v || this.eventKeyCode === keyCode.Insert) {\n                        if (e.type === 'keydown' || e.type === 'keypress') {\n                            if (isUndefined(this.valuePartsBeforePaste)) {\n                                this.valuePartsBeforePaste = this._getLeftAndRightPartAroundTheSelection();\n                            }\n                        } else {\n                            this._checkPaste();\n                        }\n                    }\n\n                    return e.type === 'keydown' || e.type === 'keypress' || this.eventKeyCode === keyCode.c;\n                }\n\n                if (e.ctrlKey || e.metaKey) {\n                    return true;\n                }\n\n                // Jump over thousand separator\n                //TODO Move this test inside the `onKeydown` handler\n                if (this.eventKeyCode === keyCode.LeftArrow || this.eventKeyCode === keyCode.RightArrow) {\n                    if (e.type === 'keydown' && !e.shiftKey) {\n                        if (this.eventKeyCode === keyCode.LeftArrow && (this.that.value.charAt(this.selection.start - 2) === this.settingsClone.digitGroupSeparator || this.that.value.charAt(this.selection.start - 2) === this.settingsClone.decimalCharacter)) {\n                            this._setCaretPosition(this.selection.start - 1);\n                        } else if (this.eventKeyCode === keyCode.RightArrow && (this.that.value.charAt(this.selection.start + 1) === this.settingsClone.digitGroupSeparator || this.that.value.charAt(this.selection.start + 1) === this.settingsClone.decimalCharacter)) {\n                            this._setCaretPosition(this.selection.start + 1);\n                        }\n                    }\n                    return true;\n                }\n\n                return this.eventKeyCode >= keyCode.PageDown && this.eventKeyCode <= keyCode.DownArrow;\n            }\n\n            /**\n             * Process deletion of characters when the minus sign is to the right of the numeric characters.\n             *\n             * @param {string} left The part on the left of the caret or selection\n             * @param {string} right The part on the right of the caret or selection\n             * @returns {[string, string]}\n             * @private\n             */\n\n        }, {\n            key: '_processCharacterDeletionIfTrailingNegativeSign',\n            value: function _processCharacterDeletionIfTrailingNegativeSign(_ref) {\n                var _ref2 = _slicedToArray(_ref, 2),\n                    left = _ref2[0],\n                    right = _ref2[1];\n\n                var settingsClone = this.settingsClone;\n                if (settingsClone.currencySymbolPlacement === 'p' && settingsClone.negativePositiveSignPlacement === 's') {\n                    if (this.eventKeyCode === keyCode.Backspace) {\n                        settingsClone.caretFix = this.selection.start >= this.value.indexOf(settingsClone.suffixText) && settingsClone.suffixText !== '';\n                        if (this.value.charAt(this.selection.start - 1) === '-') {\n                            left = left.substring(1);\n                        } else if (this.selection.start <= this.value.length - settingsClone.suffixText.length) {\n                            left = left.substring(0, left.length - 1);\n                        }\n                    } else {\n                        settingsClone.caretFix = this.selection.start >= this.value.indexOf(settingsClone.suffixText) && settingsClone.suffixText !== '';\n                        if (this.selection.start >= this.value.indexOf(settingsClone.currencySymbol) + settingsClone.currencySymbol.length) {\n                            right = right.substring(1, right.length);\n                        }\n                        if (isNegative(left) && this.value.charAt(this.selection.start) === '-') {\n                            left = left.substring(1);\n                        }\n                    }\n                }\n\n                //TODO Merge the two following 'if' blocks into one `if (settingsClone.currencySymbolPlacement === 's') {` and a switch on settingsClone.negativePositiveSignPlacement\n                if (settingsClone.currencySymbolPlacement === 's' && settingsClone.negativePositiveSignPlacement === 'l') {\n                    settingsClone.caretFix = this.selection.start >= this.value.indexOf(settingsClone.negativeSignCharacter) + settingsClone.negativeSignCharacter.length;\n                    if (this.eventKeyCode === keyCode.Backspace) {\n                        if (this.selection.start === this.value.indexOf(settingsClone.negativeSignCharacter) + settingsClone.negativeSignCharacter.length && contains(this.value, settingsClone.negativeSignCharacter)) {\n                            left = left.substring(1);\n                        } else if (left !== '-' && (this.selection.start <= this.value.indexOf(settingsClone.negativeSignCharacter) || !contains(this.value, settingsClone.negativeSignCharacter))) {\n                            left = left.substring(0, left.length - 1);\n                        }\n                    } else {\n                        if (left[0] === '-') {\n                            right = right.substring(1);\n                        }\n                        if (this.selection.start === this.value.indexOf(settingsClone.negativeSignCharacter) && contains(this.value, settingsClone.negativeSignCharacter)) {\n                            left = left.substring(1);\n                        }\n                    }\n                }\n\n                if (settingsClone.currencySymbolPlacement === 's' && settingsClone.negativePositiveSignPlacement === 'r') {\n                    settingsClone.caretFix = this.selection.start >= this.value.indexOf(settingsClone.negativeSignCharacter) + settingsClone.negativeSignCharacter.length;\n                    if (this.eventKeyCode === keyCode.Backspace) {\n                        if (this.selection.start === this.value.indexOf(settingsClone.negativeSignCharacter) + settingsClone.negativeSignCharacter.length) {\n                            left = left.substring(1);\n                        } else if (left !== '-' && this.selection.start <= this.value.indexOf(settingsClone.negativeSignCharacter) - settingsClone.currencySymbol.length) {\n                            left = left.substring(0, left.length - 1);\n                        } else if (left !== '' && !contains(this.value, settingsClone.negativeSignCharacter)) {\n                            left = left.substring(0, left.length - 1);\n                        }\n                    } else {\n                        settingsClone.caretFix = this.selection.start >= this.value.indexOf(settingsClone.currencySymbol) && settingsClone.currencySymbol !== '';\n                        if (this.selection.start === this.value.indexOf(settingsClone.negativeSignCharacter)) {\n                            left = left.substring(1);\n                        }\n                        right = right.substring(1);\n                    }\n                }\n\n                return [left, right];\n            }\n\n            /**\n             * Process the deletion of characters.\n             */\n\n        }, {\n            key: '_processCharacterDeletion',\n            value: function _processCharacterDeletion() {\n                var settingsClone = this.settingsClone;\n\n                var left = void 0;\n                var right = void 0;\n\n                if (!this.selection.length) {\n                    var _getUnformattedLeftAn = this._getUnformattedLeftAndRightPartAroundTheSelection();\n\n                    var _getUnformattedLeftAn2 = _slicedToArray(_getUnformattedLeftAn, 2);\n\n                    left = _getUnformattedLeftAn2[0];\n                    right = _getUnformattedLeftAn2[1];\n\n                    if (left === '' && right === '') {\n                        settingsClone.throwInput = false;\n                    }\n\n                    if ((settingsClone.currencySymbolPlacement === 'p' && settingsClone.negativePositiveSignPlacement === 's' || settingsClone.currencySymbolPlacement === 's' && (settingsClone.negativePositiveSignPlacement === 'l' || settingsClone.negativePositiveSignPlacement === 'r')) && isNegative(this.value)) {\n                        var _processCharacterDele = this._processCharacterDeletionIfTrailingNegativeSign([left, right]); //TODO Change `this.value` to `this.that.value`?\n\n\n                        var _processCharacterDele2 = _slicedToArray(_processCharacterDele, 2);\n\n                        left = _processCharacterDele2[0];\n                        right = _processCharacterDele2[1];\n                    } else {\n                        if (this.eventKeyCode === keyCode.Backspace) {\n                            left = left.substring(0, left.length - 1);\n                        } else {\n                            right = right.substring(1, right.length);\n                        }\n                    }\n                } else {\n                    this._expandSelectionOnSign(false);\n\n                    var _getUnformattedLeftAn3 = this._getUnformattedLeftAndRightPartAroundTheSelection();\n\n                    var _getUnformattedLeftAn4 = _slicedToArray(_getUnformattedLeftAn3, 2);\n\n                    left = _getUnformattedLeftAn4[0];\n                    right = _getUnformattedLeftAn4[1];\n                }\n\n                this._setValueParts(left, right);\n            }\n\n            /**\n             * This function decides if the key pressed should be dropped or accepted, and modify the value 'on-the-fly' accordingly.\n             * Returns TRUE if the keycode is allowed.\n             * This functions also modify the value on-the-fly. //FIXME This should use another function in order to separate the test and the modification\n             *\n             * @param {Event} e\n             * @returns {boolean}\n             */\n\n        }, {\n            key: '_processCharacterInsertion',\n            value: function _processCharacterInsertion(e) {\n                var settingsClone = this.settingsClone;\n\n                var _getUnformattedLeftAn5 = this._getUnformattedLeftAndRightPartAroundTheSelection(),\n                    _getUnformattedLeftAn6 = _slicedToArray(_getUnformattedLeftAn5, 2),\n                    left = _getUnformattedLeftAn6[0],\n                    right = _getUnformattedLeftAn6[1];\n\n                settingsClone.throwInput = true;\n\n                // Retrieve the real character that has been entered (ie. 'a' instead of the key code)\n                var eventCharacter = character(e);\n\n                // Start rules when the decimal character key is pressed always use numeric pad dot to insert decimal separator\n                // Do not allow decimal character if no decimal part allowed\n                if (eventCharacter === settingsClone.decimalCharacter || settingsClone.decimalCharacterAlternative && eventCharacter === settingsClone.decimalCharacterAlternative || (eventCharacter === '.' || eventCharacter === ',') && this.eventKeyCode === keyCode.DotNumpad) {\n                    if (!settingsClone.decimalPlacesOverride || !settingsClone.decimalCharacter) {\n                        return true;\n                    }\n\n                    // Do not allow decimal character before negativeSignCharacter character\n                    if (settingsClone.negativeSignCharacter && contains(right, settingsClone.negativeSignCharacter)) {\n                        return true;\n                    }\n\n                    // Do not allow decimal character if other decimal character present\n                    if (contains(left, settingsClone.decimalCharacter)) {\n                        return true;\n                    }\n\n                    if (right.indexOf(settingsClone.decimalCharacter) > 0) {\n                        return true;\n                    }\n\n                    if (right.indexOf(settingsClone.decimalCharacter) === 0) {\n                        right = right.substr(1);\n                    }\n\n                    this._setValueParts(left + settingsClone.decimalCharacter, right);\n\n                    return true;\n                }\n\n                // Prevent minus if not allowed\n                if ((eventCharacter === '-' || eventCharacter === '+') && settingsClone.negativeSignCharacter === '-') {\n                    if (!settingsClone) {\n                        return true;\n                    }\n\n                    // Caret is always after minus\n                    if (settingsClone.currencySymbolPlacement === 'p' && settingsClone.negativePositiveSignPlacement === 's' || settingsClone.currencySymbolPlacement === 's' && settingsClone.negativePositiveSignPlacement !== 'p') {\n                        if (left === '' && contains(right, settingsClone.negativeSignCharacter)) {\n                            left = settingsClone.negativeSignCharacter;\n                            right = right.substring(1, right.length);\n                        }\n\n                        // Change number sign, remove part if should\n                        if (isNegativeStrict(left) || contains(left, settingsClone.negativeSignCharacter)) {\n                            left = left.substring(1, left.length);\n                        } else {\n                            left = eventCharacter === '-' ? settingsClone.negativeSignCharacter + left : left;\n                        }\n                    } else {\n                        if (left === '' && contains(right, settingsClone.negativeSignCharacter)) {\n                            left = settingsClone.negativeSignCharacter;\n                            right = right.substring(1, right.length);\n                        }\n\n                        // Change number sign, remove part if should\n                        if (left.charAt(0) === settingsClone.negativeSignCharacter) {\n                            left = left.substring(1, left.length);\n                        } else {\n                            left = eventCharacter === '-' ? settingsClone.negativeSignCharacter + left : left;\n                        }\n                    }\n\n                    this._setValueParts(left, right);\n\n                    return true;\n                }\n\n                // If the user tries to insert digit before minus sign\n                var eventNumber = Number(eventCharacter);\n                if (eventNumber >= 0 && eventNumber <= 9) {\n                    if (settingsClone.negativeSignCharacter && left === '' && contains(right, settingsClone.negativeSignCharacter)) {\n                        left = settingsClone.negativeSignCharacter;\n                        right = right.substring(1, right.length);\n                    }\n\n                    if (settingsClone.maximumValue <= 0 && settingsClone.minimumValue < settingsClone.maximumValue && !contains(this.value, settingsClone.negativeSignCharacter) && eventCharacter !== '0') {\n                        left = settingsClone.negativeSignCharacter + left;\n                    }\n\n                    this._setValueParts(left + eventCharacter, right);\n\n                    return true;\n                }\n\n                // Prevent any other character\n                settingsClone.throwInput = false;\n\n                return false;\n            }\n\n            /**\n             * Formatting of just processed value while keeping the cursor position\n             *\n             * @param {Event} e\n             * @private\n             */\n\n        }, {\n            key: '_formatValue',\n            value: function _formatValue(e) {\n                var _this = this;\n\n                var settingsClone = this.settingsClone;\n                var leftLength = this.value;\n\n                var _getUnformattedLeftAn7 = this._getUnformattedLeftAndRightPartAroundTheSelection(),\n                    _getUnformattedLeftAn8 = _slicedToArray(_getUnformattedLeftAn7, 1),\n                    left = _getUnformattedLeftAn8[0];\n\n                // No grouping separator and no currency sign\n\n\n                if ((settingsClone.digitGroupSeparator === '' || settingsClone.digitGroupSeparator !== '' && !contains(leftLength, settingsClone.digitGroupSeparator)) && (settingsClone.currencySymbol === '' || settingsClone.currencySymbol !== '' && !contains(leftLength, settingsClone.currencySymbol))) {\n                    var _leftLength$split = leftLength.split(settingsClone.decimalCharacter),\n                        _leftLength$split2 = _slicedToArray(_leftLength$split, 1),\n                        subParts = _leftLength$split2[0];\n\n                    var nSign = '';\n                    if (isNegative(subParts)) {\n                        nSign = '-';\n                        subParts = subParts.replace('-', '');\n                        left = left.replace('-', '');\n                    }\n\n                    // Strip leading zero on positive value if needed\n                    if (nSign === '' && subParts.length > settingsClone.mIntPos && left.charAt(0) === '0') {\n                        left = left.slice(1);\n                    }\n\n                    // Strip leading zero on negative value if needed\n                    if (nSign === '-' && subParts.length > settingsClone.mIntNeg && left.charAt(0) === '0') {\n                        left = left.slice(1);\n                    }\n\n                    left = nSign + left;\n                }\n\n                var value = addGroupSeparators(this.value, this.settingsClone);\n                var position = value.length;\n                if (value) {\n                    // Prepare regexp which searches for cursor position from unformatted left part\n                    var leftAr = left.split('');\n\n                    // Fixes caret position with trailing minus sign\n                    if ((settingsClone.negativePositiveSignPlacement === 's' || settingsClone.currencySymbolPlacement === 's' && settingsClone.negativePositiveSignPlacement !== 'p') && leftAr[0] === '-' && settingsClone.negativeSignCharacter !== '') {\n                        leftAr.shift();\n\n                        if ((this.eventKeyCode === keyCode.Backspace || this.eventKeyCode === keyCode.Delete) && settingsClone.caretFix) {\n                            if (settingsClone.currencySymbolPlacement === 's' && settingsClone.negativePositiveSignPlacement === 'l') {\n                                leftAr.push('-');\n                                settingsClone.caretFix = e.type === 'keydown';\n                            }\n\n                            if (settingsClone.currencySymbolPlacement === 'p' && settingsClone.negativePositiveSignPlacement === 's') {\n                                leftAr.push('-');\n                                settingsClone.caretFix = e.type === 'keydown';\n                            }\n\n                            if (settingsClone.currencySymbolPlacement === 's' && settingsClone.negativePositiveSignPlacement === 'r') {\n                                (function () {\n                                    var signParts = settingsClone.currencySymbol.split('');\n                                    var escapeChr = ['\\\\', '^', '$', '.', '|', '?', '*', '+', '(', ')', '['];\n                                    var escapedParts = [];\n                                    $.each(signParts, function (i, miniParts) {\n                                        miniParts = signParts[i];\n                                        if (isInArray(miniParts, escapeChr)) {\n                                            escapedParts.push('\\\\' + miniParts);\n                                        } else {\n                                            escapedParts.push(miniParts);\n                                        }\n                                    });\n\n                                    if (_this.eventKeyCode === keyCode.Backspace) {\n                                        escapedParts.push('-');\n                                    }\n\n                                    // Pushing the escaped sign\n                                    leftAr.push(escapedParts.join(''));\n                                    settingsClone.caretFix = e.type === 'keydown';\n                                })();\n                            }\n                        }\n                    }\n\n                    for (var i = 0; i < leftAr.length; i++) {\n                        if (!leftAr[i].match('\\\\d')) {\n                            leftAr[i] = '\\\\' + leftAr[i];\n                        }\n                    }\n\n                    var leftReg = new RegExp('^.*?' + leftAr.join('.*?'));\n\n                    // Search cursor position in formatted value\n                    var newLeft = value.match(leftReg);\n                    if (newLeft) {\n                        position = newLeft[0].length;\n\n                        // If the positive sign is shown, calculate the caret position accordingly\n                        if (settingsClone.showPositiveSign) {\n                            if (position === 0 && newLeft.input.charAt(0) === settingsClone.positiveSignCharacter) {\n                                position = newLeft.input.indexOf(settingsClone.currencySymbol) === 1 ? settingsClone.currencySymbol.length + 1 : 1;\n                            }\n\n                            if (position === 0 && newLeft.input.charAt(settingsClone.currencySymbol.length) === settingsClone.positiveSignCharacter) {\n                                position = settingsClone.currencySymbol.length + 1;\n                            }\n                        }\n\n                        // If we are just before the sign which is in prefix position\n                        if ((position === 0 && value.charAt(0) !== settingsClone.negativeSignCharacter || position === 1 && value.charAt(0) === settingsClone.negativeSignCharacter) && settingsClone.currencySymbol && settingsClone.currencySymbolPlacement === 'p') {\n                            // Place caret after prefix sign\n                            //TODO Should the test be 'isNegative' instead of 'isNegativeStrict' in order to search for '-' everywhere in the string?\n                            position = this.settingsClone.currencySymbol.length + (isNegativeStrict(value) ? 1 : 0);\n                        }\n                    } else {\n                        if (settingsClone.currencySymbol && settingsClone.currencySymbolPlacement === 's') {\n                            // If we could not find a place for cursor and have a sign as a suffix\n                            // Place caret before suffix currency sign\n                            position -= settingsClone.currencySymbol.length;\n                        }\n\n                        if (settingsClone.suffixText) {\n                            // If we could not find a place for cursor and have a suffix\n                            // Place caret before suffix\n                            position -= settingsClone.suffixText.length;\n                        }\n                    }\n                }\n\n                // Only update the value if it has changed. This prevents modifying the selection, if any.\n                if (value !== this.that.value || value === this.that.value && (this.eventKeyCode === keyCode.num0 || this.eventKeyCode === keyCode.numpad0)) {\n                    this.that.value = value;\n                    this._setCaretPosition(position);\n                }\n\n                this.formatted = true; //TODO Rename `this.formatted` to `this._formatExecuted`, since it's possible this function does not need to format anything (in the case where the keycode is dropped for instance)\n            }\n        }]);\n\n        return AutoNumericHolder;\n    }();\n\n    /**\n     * This function factorise the `getString()` and `getArray()` functions since they share quite a lot of code.\n     *\n     * The \"getString\" method uses jQuery's .serialize() method that creates a text string in standard URL-encoded notation.\n     * The \"getArray\" method on the other hand uses jQuery's .serializeArray() method that creates array or objects that can be encoded as a JSON string.\n     *\n     * It then loops through the string and un-formats the inputs with autoNumeric.\n     * By defaults values returned as ISO numeric string \"1234.56\" or \"-1234.56\" where the decimal character is a period\n     * Locale formats are supported \"1234.56-\" or \"1234,56\" or \"-1234,56 or \"1234,56-\", or even plain numbers => please see option \"outputFormat\" for more details\n     *\n     * @param {boolean} getArrayBehavior - If set to TRUE, then this function behave like `getArray()`, otherwise if set to FALSE, it behave like `getString()`\n     * @param {HTMLElement} that - A reference to the current DOM element\n     * @returns {*}\n     * @private\n     */\n\n\n    function _getStringOrArray() {\n        var getArrayBehavior = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n        var that = arguments[1];\n\n        var $this = getCurrentElement(that);\n        var formIndex = $('form').index($this);\n        var allFormElements = $('form:eq(' + formIndex + ')')[0];\n        var aiIndex = [];\n\n        // all input index\n        var scIndex = [];\n\n        // successful control index\n        var rSubmitterTypes = /^(?:submit|button|image|reset|file)$/i;\n\n        // from jQuery serialize method\n        var rSubmittable = /^(?:input|select|textarea|keygen)/i;\n\n        // from jQuery serialize method\n        var rCheckableType = /^(?:checkbox|radio)$/i;\n        var rNonAutoNumericTypes = /^(?:button|checkbox|color|date|datetime|datetime-local|email|file|image|month|number|password|radio|range|reset|search|submit|time|url|week)/i;\n\n        var count = 0;\n\n        // index of successful elements\n        $.each(allFormElements, function (i, field) {\n            if (field.name !== '' && rSubmittable.test(field.localName) && !rSubmitterTypes.test(field.type) && !field.disabled && (field.checked || !rCheckableType.test(field.type))) {\n                scIndex.push(count);\n                count++;\n            } else {\n                scIndex.push(-1);\n            }\n        });\n\n        // index of all inputs tags except checkbox\n        count = 0;\n        $.each(allFormElements, function (i, field) {\n            if (field.localName === 'input' && (field.type === '' || field.type === 'text' || field.type === 'hidden' || field.type === 'tel')) {\n                aiIndex.push(count);\n                count++;\n            } else {\n                aiIndex.push(-1);\n                if (field.localName === 'input' && rNonAutoNumericTypes.test(field.type)) {\n                    count++;\n                }\n            }\n        });\n\n        if (getArrayBehavior) {\n            var formFields = $this.serializeArray();\n\n            $.each(formFields, function (i, field) {\n                var scElement = scIndex.indexOf(i);\n\n                if (scElement > -1 && aiIndex[scElement] > -1) {\n                    var testInput = $('form:eq(' + formIndex + ') input:eq(' + aiIndex[scElement] + ')');\n                    var settings = testInput.data('autoNumeric');\n\n                    if ((typeof settings === 'undefined' ? 'undefined' : _typeof(settings)) === 'object') {\n                        field.value = testInput.autoNumeric('getLocalized').toString();\n                    }\n                }\n            });\n\n            return formFields;\n        } else {\n            var _ret2 = function () {\n                // getString() behavior\n                var formFields = $this.serialize();\n                var formParts = formFields.split('&');\n\n                $.each(formParts, function (i) {\n                    var _formParts$i$split = formParts[i].split('='),\n                        _formParts$i$split2 = _slicedToArray(_formParts$i$split, 2),\n                        inputName = _formParts$i$split2[0],\n                        inputValue = _formParts$i$split2[1];\n\n                    var scElement = scIndex.indexOf(i);\n\n                    // If the current element is a valid element\n                    if (scElement > -1 && aiIndex[scElement] > -1) {\n                        var testInput = $('form:eq(' + formIndex + ') input:eq(' + aiIndex[scElement] + ')');\n                        var settings = testInput.data('autoNumeric');\n\n                        if ((typeof settings === 'undefined' ? 'undefined' : _typeof(settings)) === 'object') {\n                            if (inputValue !== null) {\n                                var modifiedInputValue = testInput.autoNumeric('getLocalized').toString();\n                                formParts[i] = inputName + '=' + modifiedInputValue;\n                            }\n                        }\n                    }\n                });\n\n                return {\n                    v: formParts.join('&')\n                };\n            }();\n\n            if ((typeof _ret2 === 'undefined' ? 'undefined' : _typeof(_ret2)) === \"object\") return _ret2.v;\n        }\n    }\n\n    /**\n     * Handler for 'focusin' events\n     *\n     * @param {object} $this jQuery-selected DOM element\n     * @param {AutoNumericHolder} holder\n     * @param {Event} e\n     */\n    function onFocusInAndMouseEnter($this, holder, e) {\n        var settings = holder.settingsClone;\n\n        if (e.type === 'focusin' || e.type === 'mouseenter' && !$this.is(':focus') && settings.emptyInputBehavior === 'focus') {\n            settings.hasFocus = true;\n\n            if (settings.negativeBracketsTypeOnBlur !== null && settings.negativeSignCharacter !== '') {\n                $this.val(toggleNegativeBracket(e.target.value, settings));\n            }\n\n            // clean the value to compare to rawValue\n            var result = stripAllNonNumberCharacters(e.target.value, settings, true);\n            result = convertToNumericString(result, settings);\n            result = cleanLeadingTrailingZeros(result, settings);\n            if (settings.trailingNegative) {\n                result = '-' + result;\n            }\n\n            var roundedValue = void 0;\n            if (settings.decimalPlacesShownOnFocus) {\n                settings.decimalPlacesOverride = settings.decimalPlacesShownOnFocus;\n                roundedValue = roundValue(settings.rawValue, settings);\n                $this.val(addGroupSeparators(roundedValue, settings));\n            } else if (settings.scaleDivisor) {\n                settings.decimalPlacesOverride = Number(settings.oDec);\n                roundedValue = roundValue(settings.rawValue, settings);\n                $this.val(addGroupSeparators(roundedValue, settings));\n            } else if (settings.noSeparatorOnFocus) {\n                settings.digitGroupSeparator = '';\n                settings.currencySymbol = '';\n                settings.suffixText = '';\n                roundedValue = roundValue(settings.rawValue, settings);\n                $this.val(addGroupSeparators(roundedValue, settings));\n            } else if (result !== settings.rawValue) {\n                // updates the rawValue\n                $this.autoNumeric('set', result);\n            }\n\n            // In order to send a 'native' change event when blurring the input, we need to first store the initial input value on focus.\n            holder.valueOnFocus = e.target.value;\n            holder.lastVal = holder.valueOnFocus;\n            var onEmpty = checkEmpty(holder.valueOnFocus, settings, true);\n            if (onEmpty !== null && onEmpty !== '' && settings.emptyInputBehavior === 'focus') {\n                $this.val(onEmpty);\n                if (onEmpty === settings.currencySymbol && settings.currencySymbolPlacement === 's') {\n                    setElementSelection(e.target, 0, 0);\n                }\n            }\n        }\n    }\n\n    /**\n     * Handler for 'keydown' events.\n     * The user just started pushing any key, hence one event is sent.\n     *\n     * Note :\n     * By default a 'normal' input output those events in the right order when inputting a character key (ie. 'a') :\n     * - keydown\n     * - keypress\n     * - input\n     * - keyup\n     *\n     * ...when inputting a modifier key (ie. 'ctrl') :\n     * - keydown\n     * - keyup\n     *\n     * If 'delete' or 'backspace' is entered, the following events are sent :\n     * - keydown\n     * - input\n     * - keyup\n     *\n     * If 'enter' is entered and the value has not changed, the following events are sent :\n     * - keydown\n     * - keypress\n     * - keyup\n     *\n     * If 'enter' is entered and the value has been changed, the following events are sent :\n     * - keydown\n     * - keypress\n     * - change\n     * - keyup\n     *\n     * When a paste is done, the following events are sent :\n     * - input (if paste is done with the mouse)\n     *\n     * - keydown (if paste is done with ctrl+v)\n     * - keydown\n     * - input\n     * - keyup\n     * - keyup\n     *\n     * @param {AutoNumericHolder} holder\n     * @param {Event} e\n     */\n    function onKeydown(holder, e) {\n        //TODO Create a function that retrieve the element value (either by using `e.target.value` when the element is an <input>, or by using `element.textContent` when the element as its `contenteditable` set to true)\n        holder._updateAutoNumericHolderEventKeycode(e);\n        holder.initialValueOnKeydown = e.target.value; // This is needed in `onKeyup()` to check if the value as changed during the key press\n\n        if (holder.that.readOnly) {\n            holder.processed = true;\n\n            return;\n        }\n\n        // The \"enter\" key throws a `change` event if the value has changed since the `focus` event\n        if (holder.eventKeyCode === keyCode.Enter && holder.valueOnFocus !== e.target.value) {\n            triggerEvent('change', e.target);\n            holder.valueOnFocus = e.target.value;\n        }\n\n        holder._updateAutoNumericHolderProperties(e);\n\n        if (holder._skipAlways(e)) {\n            holder.processed = true;\n\n            return;\n        }\n\n        // Check if the key is a delete/backspace key\n        if (holder.eventKeyCode === keyCode.Backspace || holder.eventKeyCode === keyCode.Delete) {\n            holder._processCharacterDeletion(); // Because backspace and delete only triggers keydown and keyup events, not keypress\n            holder.processed = true;\n            holder._formatValue(e);\n\n            // If and only if the resulting value has changed after that backspace/delete, then we have to send an 'input' event like browsers normally do.\n            if (e.target.value !== holder.lastVal && holder.settingsClone.throwInput) {\n                // Throw an input event when a character deletion is detected\n                triggerEvent('input', e.target);\n                e.preventDefault(); // ...and immediately prevent the browser to delete a second character\n            }\n\n            holder.lastVal = e.target.value;\n            holder.settingsClone.throwInput = true;\n\n            return;\n        }\n\n        holder.formatted = false; //TODO Is this line needed?\n    }\n\n    /**\n     * Handler for 'keypress' events.\n     * The user is still pressing the key, which will output a character (ie. '2') continuously until it releases the key.\n     * Note: 'keypress' events are not sent for delete keys like Backspace/Delete.\n     *\n     * @param {AutoNumericHolder} holder\n     * @param {Event} e\n     */\n    function onKeypress(holder, e) {\n        // Retrieve the real character that has been entered (ie. 'a' instead of the key code)\n        var eventCharacter = character(e);\n\n        // Firefox generate a 'keypress' event (e.keyCode === 0) for the keys that do not print a character (ie. 'Insert', 'Delete', 'Fn' keys, 'PageUp', 'PageDown' etc.). 'Shift' on the other hand does not generate a keypress event.\n        if (eventCharacter === keyName.Insert) {\n            return;\n        }\n\n        var processed = holder.processed;\n        holder._updateAutoNumericHolderProperties(e);\n\n        if (holder._skipAlways(e)) {\n            return;\n        }\n\n        if (processed) {\n            e.preventDefault();\n\n            return;\n        }\n\n        var isCharacterInsertionAllowed = holder._processCharacterInsertion(e);\n        if (isCharacterInsertionAllowed) {\n            holder._formatValue(e);\n            if (e.target.value !== holder.lastVal && holder.settingsClone.throwInput) {\n                // Throws input event on adding a character\n                triggerEvent('input', e.target);\n                e.preventDefault(); // ...and immediately prevent the browser to add a second character\n            } else {\n                if ((eventCharacter === holder.settings.decimalCharacter || eventCharacter === holder.settings.decimalCharacterAlternative) && getElementSelection(e.target).start === getElementSelection(e.target).end && getElementSelection(e.target).start === e.target.value.indexOf(holder.settings.decimalCharacter)) {\n                    var position = getElementSelection(e.target).start + 1;\n                    setElementSelection(e.target, position, position);\n                }\n                e.preventDefault();\n            }\n\n            holder.lastVal = e.target.value;\n            holder.settingsClone.throwInput = true;\n\n            return;\n        }\n\n        e.preventDefault();\n\n        holder.formatted = false;\n    }\n\n    /**\n     * Handler for 'keyup' events.\n     * The user just released any key, hence one event is sent.\n     *\n     * @param {AutoNumericHolder} holder\n     * @param {object} settings\n     * @param {Event} e\n     */\n    function onKeyup(holder, settings, e) {\n        holder._updateAutoNumericHolderProperties(e);\n\n        var skip = holder._skipAlways(e);\n        delete holder.valuePartsBeforePaste;\n        if (skip || e.target.value === '') {\n            return;\n        }\n\n        // Added to properly place the caret when only the currency sign is present\n        if (e.target.value === holder.settingsClone.currencySymbol) {\n            if (holder.settingsClone.currencySymbolPlacement === 's') {\n                setElementSelection(e.target, 0, 0);\n            } else {\n                setElementSelection(e.target, holder.settingsClone.currencySymbol.length, holder.settingsClone.currencySymbol.length);\n            }\n        } else if (holder.eventKeyCode === keyCode.Tab) {\n            setElementSelection(e.target, 0, e.target.value.length);\n        }\n\n        if (e.target.value === holder.settingsClone.suffixText || holder.settingsClone.rawValue === '' && holder.settingsClone.currencySymbol !== '' && holder.settingsClone.suffixText !== '') {\n            setElementSelection(e.target, 0, 0);\n        }\n\n        // Saves the extended decimal to preserve the data when navigating away from the page\n        if (holder.settingsClone.decimalPlacesShownOnFocus !== null && holder.settingsClone.saveValueToSessionStorage) {\n            saveValueToPersistentStorage(e.target, settings, 'set');\n        }\n\n        if (!holder.formatted) {\n            holder._formatValue(e);\n        }\n\n        // If the input value has changed during the key press event chain, an event is sent to alert that a formatting has been done (cf. Issue #187)\n        if (e.target.value !== holder.initialValueOnKeydown) {\n            triggerEvent('autoNumeric:formatted', e.target);\n        }\n    }\n\n    /**\n     * Handler for 'focusout' events\n     *\n     * @param {object} $this jQuery-selected DOM element\n     * @param {AutoNumericHolder} holder\n     * @param {Event} e\n     */\n    function onFocusOutAndMouseLeave($this, holder, e) {\n        if (!$this.is(':focus')) {\n            var value = e.target.value;\n            var origValue = value;\n            var settings = holder.settingsClone;\n            settings.hasFocus = false;\n\n            if (settings.saveValueToSessionStorage) {\n                saveValueToPersistentStorage(e.target, settings, 'set');\n            }\n\n            if (settings.noSeparatorOnFocus === true) {\n                settings.digitGroupSeparator = settings.oSep;\n                settings.currencySymbol = settings.oSign;\n                settings.suffixText = settings.oSuffix;\n            }\n\n            if (settings.decimalPlacesShownOnFocus !== null) {\n                settings.decimalPlacesOverride = settings.oDec;\n                settings.allowDecimalPadding = settings.oPad;\n                settings.negativeBracketsTypeOnBlur = settings.oBracket;\n            }\n\n            value = stripAllNonNumberCharacters(value, settings, true);\n\n            if (value !== '') {\n                if (settings.trailingNegative && !isNegative(value)) {\n                    value = '-' + value;\n                    settings.trailingNegative = false;\n                }\n\n                var _checkIfInRangeWithOv3 = checkIfInRangeWithOverrideOption(value, settings),\n                    _checkIfInRangeWithOv4 = _slicedToArray(_checkIfInRangeWithOv3, 2),\n                    minTest = _checkIfInRangeWithOv4[0],\n                    maxTest = _checkIfInRangeWithOv4[1];\n\n                if (checkEmpty(value, settings, false) === null && minTest && maxTest) {\n                    value = modifyNegativeSignAndDecimalCharacterForRawValue(value, settings);\n                    settings.rawValue = cleanLeadingTrailingZeros(value, settings);\n\n                    if (settings.scaleDivisor) {\n                        value = value / settings.scaleDivisor;\n                        value = value.toString();\n                    }\n\n                    settings.decimalPlacesOverride = settings.scaleDivisor && settings.scaleDecimalPlaces ? Number(settings.scaleDecimalPlaces) : settings.decimalPlacesOverride;\n                    value = roundValue(value, settings);\n                    value = modifyNegativeSignAndDecimalCharacterForFormattedValue(value, settings);\n                } else {\n                    if (!minTest) {\n                        $this.trigger('autoNumeric:minExceeded');\n                    }\n                    if (!maxTest) {\n                        $this.trigger('autoNumeric:maxExceeded');\n                    }\n\n                    value = settings.rawValue;\n                }\n            } else {\n                if (settings.emptyInputBehavior === 'zero') {\n                    settings.rawValue = '0';\n                    value = roundValue('0', settings);\n                } else {\n                    settings.rawValue = '';\n                }\n            }\n\n            var groupedValue = checkEmpty(value, settings, false);\n            if (groupedValue === null) {\n                groupedValue = addGroupSeparators(value, settings);\n            }\n\n            if (groupedValue !== origValue) {\n                groupedValue = settings.scaleSymbol ? groupedValue + settings.scaleSymbol : groupedValue;\n                $this.val(groupedValue);\n            }\n\n            if (groupedValue !== holder.valueOnFocus) {\n                $this.change();\n                delete holder.valueOnFocus;\n            }\n        }\n    }\n\n    /**\n     * Handler for 'paste' events\n     *\n     * @param {object} $this jQuery-selected DOM element\n     * @param {AutoNumericHolder} holder\n     * @param {Event} e\n     */\n    function onPaste($this, holder, e) {\n        //TODO Using ctrl+z after a paste should cancel it -> How would that affect other frameworks/component built with that feature in mind though?\n        //FIXME When pasting '000' on a thousand group selection, the whole selection gets deleted, and only one '0' is pasted (cf. issue #302)\n        // The event is prevented by default, since otherwise the user would be able to paste invalid characters into the input\n        e.preventDefault();\n\n        var rawPastedText = e.clipboardData.getData('text/plain');\n\n        // 0. Special case if the user has selected all the input text before pasting\n        var initialFormattedValue = e.target.value;\n        var selectionStart = e.target.selectionStart || 0;\n        var selectionEnd = e.target.selectionEnd || 0;\n        var selectionSize = selectionEnd - selectionStart;\n        var isAllInputTextSelected = false;\n\n        if (selectionSize === initialFormattedValue.length) {\n            isAllInputTextSelected = true;\n        }\n\n        // 1. Check if the paste has a negative sign (only if it's the first character), and store that information for later use\n        var isPasteNegative = isNegativeStrict(rawPastedText);\n        if (isPasteNegative) {\n            // 1a. Remove the negative sign from the pasted text\n            rawPastedText = rawPastedText.slice(1, rawPastedText.length);\n        }\n\n        // 2. Strip all thousand separators, brackets and currency sign, and convert the decimal character to a dot\n        var untranslatedPastedText = preparePastedText(rawPastedText, holder);\n\n        var pastedText = void 0;\n        if (untranslatedPastedText === '.') {\n            // Special case : If the user tries to paste a single decimal character (that has been translated to '.' already)\n            pastedText = '.';\n        } else {\n            // Normal case\n            // Allow pasting arabic numbers\n            pastedText = arabicToLatinNumbers(untranslatedPastedText, false, false, false);\n        }\n\n        // 3. Test if the paste is valid (only has numbers and eventually a decimal character). If it's not valid, stop here.\n        if (pastedText !== '.' && (!isNumber(pastedText) || pastedText === '')) {\n            if (holder.settings.onInvalidPaste === 'error') {\n                //TODO Should we send a warning instead of throwing an error?\n                throwError('The pasted value \\'' + rawPastedText + '\\' is not a valid paste content.');\n            }\n\n            return;\n        }\n\n        // 4. Calculate the paste result\n        var caretPositionOnInitialTextAfterPasting = void 0;\n        var initialUnformattedNumber = void 0;\n        if (e.target.value === '') {\n            // autoNumeric 'get' returns '0.00' if the input is empty, hence we need to store the 'real' empty initial value when needed\n            //FIXME This has been fixed in a previous commit, get should return '' on an empty input. Remove this unneeded 'if'\n            initialUnformattedNumber = '';\n        } else {\n            initialUnformattedNumber = $this.autoNumeric('get');\n        }\n        var isInitialValueNegative = isNegativeStrict(initialUnformattedNumber);\n        var isPasteNegativeAndInitialValueIsPositive = void 0;\n        var result = void 0;\n\n        // If the pasted content is negative, then the result will be negative too\n        if (isPasteNegative && !isInitialValueNegative) {\n            initialUnformattedNumber = '-' + initialUnformattedNumber;\n            isInitialValueNegative = true;\n            isPasteNegativeAndInitialValueIsPositive = true;\n        } else {\n            isPasteNegativeAndInitialValueIsPositive = false;\n        }\n\n        var leftPartContainedADot = false;\n        switch (holder.settings.onInvalidPaste) {\n            /* 4a. Truncate paste behavior:\n             * Insert as many numbers as possible on the right hand side of the caret from the pasted text content, until the input reach its range limit.\n             * If there is more characters in the clipboard once a limit is reached, drop the extraneous characters.\n             * Otherwise paste all the numbers in the clipboard.\n             * While doing so, we check if the result is within the minimum and maximum values allowed, and stop as soon as we encounter one of those.\n             *\n             * 4b. Replace paste behavior:\n             * Idem than the 'truncate' paste behavior, except that when a range limit is hit, we try to replace the subsequent initial numbers with the pasted ones, until we hit the range limit a second (and last) time, or we run out of numbers to paste\n             */\n            /* eslint no-case-declarations: 0 */\n            case 'truncate':\n            case 'replace':\n                var leftFormattedPart = initialFormattedValue.slice(0, selectionStart);\n                var rightFormattedPart = initialFormattedValue.slice(selectionEnd, initialFormattedValue.length);\n\n                if (selectionStart !== selectionEnd) {\n                    // a. If there is a selection, remove the selected part, and return the left and right part\n                    result = preparePastedText(leftFormattedPart + rightFormattedPart, holder);\n                } else {\n                    // b. Else if this is only one caret (and therefore no selection), then return the left and right part\n                    result = preparePastedText(initialFormattedValue, holder);\n                }\n\n                // Add back the negative sign if needed\n                if (isInitialValueNegative) {\n                    result = setRawNegativeSign(result);\n                }\n\n                // Build the unformatted result string\n                caretPositionOnInitialTextAfterPasting = convertCharacterCountToIndexPosition(countNumberCharactersOnTheCaretLeftSide(initialFormattedValue, selectionStart, holder.settings.decimalCharacter));\n                if (isPasteNegativeAndInitialValueIsPositive) {\n                    // If the initial paste is negative and the initial value is not, then I must offset the caret position by one place to the right to take the additional hyphen into account\n                    caretPositionOnInitialTextAfterPasting++;\n                    //TODO Quid if the negative sign is not on the left (negativePositiveSignPlacement and currencySymbolPlacement)?\n                }\n\n                var leftPart = result.slice(0, caretPositionOnInitialTextAfterPasting);\n                var rightPart = result.slice(caretPositionOnInitialTextAfterPasting, result.length);\n                if (pastedText === '.') {\n                    if (contains(leftPart, '.')) {\n                        // If I remove a dot here, then I need to update the caret position (decrement it by 1) when positioning it\n                        // To do so, we keep that info in order to modify the caret position later\n                        leftPartContainedADot = true;\n                        leftPart = leftPart.replace('.', '');\n                    }\n                    rightPart = rightPart.replace('.', '');\n                }\n                // -- Here, we are good to go to continue on the same basis\n\n                // c. Add numbers one by one at the caret position, while testing if the result is valid and within the range of the minimum and maximum value\n                //    Continue until you either run out of numbers to paste, or that you get out of the range limits\n                var minParse = parseStr(holder.settings.minimumValue);\n                var maxParse = parseStr(holder.settings.maximumValue);\n                var lastGoodKnownResult = result; // This is set as the default, in case we do not add even one number\n                var pastedTextIndex = 0;\n                var modifiedLeftPart = leftPart;\n\n                while (pastedTextIndex < pastedText.length) {\n                    // Modify the result with another pasted character\n                    modifiedLeftPart += pastedText[pastedTextIndex];\n                    result = modifiedLeftPart + rightPart;\n\n                    // Check the range limits\n                    if (!checkIfInRange(result, minParse, maxParse)) {\n                        // The result is out of the range limits, stop the loop here\n                        break;\n                    }\n\n                    // Save the last good known result\n                    lastGoodKnownResult = result;\n\n                    // Update the local variables for the next loop\n                    pastedTextIndex++;\n                }\n\n                // Update the last caret position where to insert a new number\n                caretPositionOnInitialTextAfterPasting += pastedTextIndex;\n\n                //XXX Here we have the result for the `truncate` option\n                if (holder.settings.onInvalidPaste === 'truncate') {\n                    //TODO If the user as defined a truncate callback and there are still some numbers (that will be dropped), then call this callback with the initial paste as well as the remaining numbers\n                    result = lastGoodKnownResult;\n\n                    if (leftPartContainedADot) {\n                        // If a dot has been removed for the part on the left of the caret, we decrement the caret index position\n                        caretPositionOnInitialTextAfterPasting--;\n                    }\n                    break;\n                }\n                //XXX ...else we need to continue modifying the result for the 'replace' option\n\n                // d. Until there are numbers to paste, replace the initial numbers one by one, and still do the range test.\n                //    Stop when you have no more numbers to paste, or if you are out of the range limits.\n                //    If you do get to the range limits, use the previous known good value within those limits.\n                //    Note: The numbers are replaced one by one, in the integer then decimal part, while ignoring the decimal character\n                //TODO What should happen if the user try to paste a decimal number? Should we override the current initial decimal character in favor of this new one? If we do, then we have to recalculate the vMin/vMax from the start in order to take into account this new decimal character position..\n                var lastGoodKnownResultIndex = caretPositionOnInitialTextAfterPasting;\n                var lastGoodKnownResultSize = lastGoodKnownResult.length;\n\n                while (pastedTextIndex < pastedText.length && lastGoodKnownResultIndex < lastGoodKnownResultSize) {\n                    if (lastGoodKnownResult[lastGoodKnownResultIndex] === '.') {\n                        // We skip the decimal character 'replacement'. That way, we do not change the decimal character position regarding the remaining numbers.\n                        lastGoodKnownResultIndex++;\n                        continue;\n                    }\n\n                    // This replace one character at a time\n                    result = replaceCharAt(lastGoodKnownResult, lastGoodKnownResultIndex, pastedText[pastedTextIndex]);\n\n                    // Check the range limits\n                    if (!checkIfInRange(result, minParse, maxParse)) {\n                        // The result is out of the range limits, stop the loop here\n                        break;\n                    }\n\n                    // Save the last good known result\n                    lastGoodKnownResult = result;\n\n                    // Update the local variables for the next loop\n                    pastedTextIndex++;\n                    lastGoodKnownResultIndex++;\n                }\n\n                // Update the last caret position where to insert a new number\n                caretPositionOnInitialTextAfterPasting = lastGoodKnownResultIndex;\n\n                if (leftPartContainedADot) {\n                    // If a dot has been removed for the part on the left of the caret, we decrement the caret index position\n                    caretPositionOnInitialTextAfterPasting--;\n                }\n\n                result = lastGoodKnownResult;\n\n                break;\n            /* 4c. Normal paste behavior:\n             * Insert the pasted number inside the current unformatted text, at the right caret position or selection\n             */\n            case 'error':\n            case 'ignore':\n            case 'clamp':\n            default:\n                // 1. Generate the unformatted result\n                var leftFormattedPart2 = initialFormattedValue.slice(0, selectionStart);\n                var rightFormattedPart2 = initialFormattedValue.slice(selectionEnd, initialFormattedValue.length);\n\n                if (selectionStart !== selectionEnd) {\n                    // a. If there is a selection, remove the selected part, and return the left and right part\n                    result = preparePastedText(leftFormattedPart2 + rightFormattedPart2, holder);\n                } else {\n                    // b. Else if this is only one caret (and therefore no selection), then return the left and right part\n                    result = preparePastedText(initialFormattedValue, holder);\n                }\n\n                // Add back the negative sign if needed\n                if (isInitialValueNegative) {\n                    result = setRawNegativeSign(result);\n                }\n\n                // Build the unformatted result string\n                caretPositionOnInitialTextAfterPasting = convertCharacterCountToIndexPosition(countNumberCharactersOnTheCaretLeftSide(initialFormattedValue, selectionStart, holder.settings.decimalCharacter));\n                if (isPasteNegativeAndInitialValueIsPositive) {\n                    // If the initial paste is negative and the initial value is not, then I must offset the caret position by one place to the right to take the additional hyphen into account\n                    caretPositionOnInitialTextAfterPasting++;\n                    //TODO Quid if the negative sign is not on the left (negativePositiveSignPlacement and currencySymbolPlacement)?\n                }\n\n                leftPart = result.slice(0, caretPositionOnInitialTextAfterPasting);\n                rightPart = result.slice(caretPositionOnInitialTextAfterPasting, result.length);\n                if (pastedText === '.') {\n                    // If the user only paste a single decimal character, then we remove the previously existing one (if any)\n                    if (contains(leftPart, '.')) {\n                        // If I remove a dot here, then I need to update the caret position (decrement it by 1) when positioning it\n                        // To do so, we keep that info in order to modify the caret position later\n                        leftPartContainedADot = true;\n                        leftPart = leftPart.replace('.', '');\n                    }\n                    rightPart = rightPart.replace('.', '');\n                }\n                // -- Here, we are good to go to continue on the same basis\n\n                // Generate the unformatted result\n                result = '' + leftPart + pastedText + rightPart;\n\n                // 2. Calculate the caret position in the unformatted value, for later use\n                if (selectionStart === selectionEnd) {\n                    // There is no selection, then the caret position is set after the pasted text\n                    var indexWherePastedTextHasBeenInserted = convertCharacterCountToIndexPosition(countNumberCharactersOnTheCaretLeftSide(initialFormattedValue, selectionStart, holder.settings.decimalCharacter));\n                    caretPositionOnInitialTextAfterPasting = indexWherePastedTextHasBeenInserted + pastedText.length; // I must not count the characters that have been removed from the pasted text (ie. '.')\n                } else {\n                    if (isAllInputTextSelected) {\n                        // Special case when all the input text is selected before pasting, which means we'll completely erase its content and paste only the clipboard content\n                        caretPositionOnInitialTextAfterPasting = result.length;\n                    } else if (rightPart === '') {\n                        // If the user selected from the caret position to the end of the input (on the far right)\n                        caretPositionOnInitialTextAfterPasting = convertCharacterCountToIndexPosition(countNumberCharactersOnTheCaretLeftSide(initialFormattedValue, selectionStart, holder.settings.decimalCharacter)) + pastedText.length;\n                    } else {\n                        // Normal case\n                        var indexSelectionEndInRawValue = convertCharacterCountToIndexPosition(countNumberCharactersOnTheCaretLeftSide(initialFormattedValue, selectionEnd, holder.settings.decimalCharacter));\n\n                        // Here I must not count the characters that have been removed from the pasted text (ie. '.'), or the thousand separators in the initial selected text\n                        var selectedText = e.target.value.slice(selectionStart, selectionEnd);\n                        caretPositionOnInitialTextAfterPasting = indexSelectionEndInRawValue - selectionSize + countCharInText(holder.settings.digitGroupSeparator, selectedText) + pastedText.length;\n                    }\n                }\n\n                // Modify the caret position for special cases, only if the whole input has not been selected\n                if (!isAllInputTextSelected) {\n                    if (isPasteNegativeAndInitialValueIsPositive) {\n                        // If the pasted value has a '-' sign, but the initial value does not, offset the index by one\n                        caretPositionOnInitialTextAfterPasting++;\n                    }\n\n                    if (leftPartContainedADot) {\n                        // If a dot has been removed for the part on the left of the caret, we decrement the caret index position\n                        caretPositionOnInitialTextAfterPasting--;\n                    }\n                }\n        }\n\n        // 5. Check if the result is a valid number, if not, drop the paste and do nothing.\n        if (!isNumber(result) || result === '') {\n            if (holder.settings.onInvalidPaste === 'error') {\n                throwError('The pasted value \\'' + rawPastedText + '\\' would result into an invalid content \\'' + result + '\\'.'); //TODO Should we send a warning instead of throwing an error?\n                //TODO This is not DRY ; refactor with above\n            }\n            return;\n        }\n\n        // 6. If it's a valid number, check if it falls inside the minimum and maximum value. If this fails, modify the value following this procedure :\n        /*\n         * If 'error' (this is the default) :\n         *      - Normal paste behavior.\n         *      - Try to set the new value, if it fails, then throw an error in the console.\n         *      - Do not change the input value, do not change the current selection.\n         * If 'ignore' :\n         *      - Normal paste behavior.\n         *      - Try to set the new value, if it fails, do nothing more.\n         *      - Do not change the input value, do not change the current selection.\n         * If 'clamp' :\n         *      - Normal paste behavior.\n         *      - Try to set the new value, if it fails, set the value to the minimum or maximum limit, whichever is closest to the\n         *        paste result.\n         *      - Change the caret position to be positioned on the left hand side of the decimal character.\n         * If 'truncate' :\n         *      - Truncate paste behavior.\n         *      - Try to set the new value, until it fails (if the result is out of the min and max value limits).\n         *      - Drop the remaining non-pasted numbers, and keep the last known non-failing result.\n         *      - Change the caret position to be positioned after the last pasted character.\n         * If 'replace' :\n         *      - Replace paste behavior.\n         *      - Try to set the new value, until it fails (if the result is out of the min and max value limits).\n         *     - Then try to replace as many numbers as possible with the pasted ones. Once it fails, keep the last known non-failing result.\n         *      - Change the caret position to be positioned after the last pasted character.\n         */\n        var valueHasBeenSet = false;\n        var valueHasBeenClamped = false;\n        try {\n            $this.autoNumeric('set', result);\n            valueHasBeenSet = true;\n        } catch (error) {\n            var clampedValue = void 0;\n            switch (holder.settings.onInvalidPaste) {\n                case 'clamp':\n                    clampedValue = clampToRangeLimits(result, holder.settings);\n                    try {\n                        $this.autoNumeric('set', clampedValue);\n                    } catch (error) {\n                        throwError('Fatal error: Unable to set the clamped value \\'' + clampedValue + '\\'.');\n                    }\n\n                    valueHasBeenClamped = true;\n                    valueHasBeenSet = true;\n                    result = clampedValue; // This is used only for setting the caret position later\n                    break;\n                case 'error':\n                case 'truncate':\n                case 'replace':\n                    // Throw an error message\n                    throwError('The pasted value \\'' + rawPastedText + '\\' results in a value \\'' + result + '\\' that is outside of the minimum [' + holder.settings.minimumValue + '] and maximum [' + holder.settings.maximumValue + '] value range.');\n                // falls through\n                case 'ignore':\n                // Do nothing\n                // falls through\n                default:\n                    return; // ...and nothing else should be changed\n            }\n        }\n\n        // 7. Then lastly, set the caret position at the right logical place\n        var caretPositionInFormattedNumber = void 0;\n        if (valueHasBeenSet) {\n            switch (holder.settings.onInvalidPaste) {\n                case 'clamp':\n                    if (valueHasBeenClamped) {\n                        if (holder.settings.currencySymbolPlacement === 's') {\n                            setElementSelection(e.target, e.target.value.length - holder.settings.currencySymbol.length); // This puts the caret on the right of the last decimal place\n                        } else {\n                            setElementSelection(e.target, e.target.value.length); // ..and this on the far right\n                        }\n\n                        break;\n                    } // else if the value has not been clamped, the default behavior is used...\n                // falls through\n                case 'error':\n                case 'ignore':\n                case 'truncate':\n                case 'replace':\n                default:\n                    // Whenever one or multiple characters are pasted, this means we have to manage the potential thousand separators that could be added by the formatting\n                    caretPositionInFormattedNumber = findCaretPositionInFormattedNumber(result, caretPositionOnInitialTextAfterPasting, e.target.value, holder.settings.decimalCharacter);\n                    setElementSelection(e.target, caretPositionInFormattedNumber);\n            }\n        }\n\n        // 8. We make sure we send an input event only if the result is different than the initial value before the paste\n        if (valueHasBeenSet && initialFormattedValue !== e.target.value) {\n            // On a 'normal' non-autoNumeric input, an `input` event is sent when a paste is done. We mimic that.\n            triggerEvent('input', e.target);\n        }\n    }\n\n    /**\n     * When focusing out of the input, we check if the value has changed, and if it has, then we send a `change` event (since the native one would have been prevented by `e.preventDefault()` called in the other event listeners).\n     *\n     * @param {AutoNumericHolder} holder\n     * @param {Event} e\n     */\n    function onBlur(holder, e) {\n        if (e.target.value !== holder.valueOnFocus) {\n            triggerEvent('change', e.target);\n            // e.preventDefault(); // ...and immediately prevent the browser to send a second change event (that somehow gets picked up by jQuery, but not by `addEventListener()` //FIXME KNOWN BUG : This does not prevent the second change event to be picked up by jQuery, which adds '.00' at the end of an integer\n        }\n    }\n\n    /**\n     * Handler for 'submit' events\n     *\n     * @param {object} $this jQuery-selected DOM element\n     * @param {AutoNumericHolder} holder\n     */\n    function onSubmit($this, holder) {\n        $this.closest('form').on('submit.autoNumeric', function () {\n            if (holder) {\n                var $settings = holder.settingsClone;\n\n                if ($settings.unformatOnSubmit) {\n                    $this.val($settings.rawValue);\n                }\n            }\n        });\n    }\n\n    /**\n     * Return the jQuery selected input if the tag and type are supported by autoNumeric.\n     *\n     * @param {object} $this jQuery-selected DOM element\n     * @returns {boolean|*}\n     */\n    function getInputIfSupportedTagAndType($this) {\n        // Supported input type\n        var $input = $this.is('input[type=text], input[type=hidden], input[type=tel], input:not([type])');\n\n        // Checks for non-supported input types\n        if (!$input && $this.prop('tagName').toLowerCase() === 'input') {\n            throwError('The input type \"' + $this.prop('type') + '\" is not supported by autoNumeric');\n        }\n\n        // Checks for non-supported tags\n        var currentElementTag = $this.prop('tagName').toLowerCase();\n        if (currentElementTag !== 'input' && !isInArray(currentElementTag, allowedTagList)) {\n            throwError('The <' + currentElementTag + '> tag is not supported by autoNumeric');\n        }\n\n        return $input;\n    }\n\n    /**\n     * Formats the default value on page load.\n     * This is called only if the `formatOnPageLoad` option is set to `true`.\n     *\n     * @param {object} settings\n     * @param {object} $input jQuery-selected <input> element\n     * @param {object} $this jQuery-selected DOM element\n     */\n    function formatDefaultValueOnPageLoad(settings, $input, $this) {\n        var setValue = true;\n\n        if ($input) {\n            var currentValue = $this.val();\n            /*\n             * If the input value has been set by the dev, but not directly as an attribute in the html, then it takes\n             * precedence and should get formatted on init (if this input value is a valid number and that the\n             * developer wants it formatted on init (cf. `settings.formatOnPageLoad`)).\n             * Note; this is true whatever the developer has set for `data-an-default` in the html (asp.net users).\n             *\n             * In other words : if `defaultValueOverride` is not null, it means the developer is trying to prevent postback problems.\n             * But if `input.value` is set to a number, and `$this.attr('value')` is not set, then it means the dev has\n             * changed the input value, and then it means we should not overwrite his own decision to do so.\n             * Hence, if `defaultValueOverride` is not null, but `input.value` is a number and `$this.attr('value')` is not set,\n             * we should ignore `defaultValueOverride` altogether.\n             */\n            var unLocalizedCurrentValue = toNumericValue(currentValue, settings); // This allows to use a localized value on startup oDec\n            if (settings.formatOnPageLoad && currentValue !== '' && isUndefinedOrNullOrEmpty($this.attr('value'))) {\n                // Check if the `value` is valid or not\n                if (!isNaN(unLocalizedCurrentValue) && Infinity !== unLocalizedCurrentValue) {\n                    $this.autoNumeric('set', unLocalizedCurrentValue);\n                    setValue = false;\n                } else {\n                    // If not, inform the developer that nothing usable has been provided\n                    throwError('The value [' + currentValue + '] used in the input is not a valid value autoNumeric can work with.');\n                }\n            } else {\n                /* Checks for :\n                 * - page reload from back button, and\n                 * - ASP.net form post back\n                 *      The following HTML data attribute is REQUIRED (data-an-default=\"same value as the value attribute\")\n                 *      example: <asp:TextBox runat=\"server\" id=\"someID\" text=\"1234.56\" data-an-default=\"1234.56\">\n                 */\n                if (settings.defaultValueOverride !== null && settings.defaultValueOverride.toString() !== currentValue || settings.defaultValueOverride === null && currentValue !== '' && currentValue !== $this.attr('value') || currentValue !== '' && $this.attr('type') === 'hidden' && !isNumber(unLocalizedCurrentValue)) {\n                    if (settings.decimalPlacesShownOnFocus !== null && settings.saveValueToSessionStorage || settings.scaleDivisor && settings.saveValueToSessionStorage) {\n                        settings.rawValue = saveValueToPersistentStorage($this[0], settings, 'get');\n                    }\n\n                    // If the decimalPlacesShownOnFocus value should NOT be saved in sessionStorage\n                    if (!settings.saveValueToSessionStorage) {\n                        var toStrip = void 0;\n\n                        if (settings.negativeBracketsTypeOnBlur !== null && settings.negativeSignCharacter !== '') {\n                            settings.hasFocus = true;\n                            toStrip = toggleNegativeBracket(currentValue, settings);\n                        } else {\n                            toStrip = currentValue;\n                        }\n\n                        if ((settings.negativePositiveSignPlacement === 's' || settings.negativePositiveSignPlacement !== 'p' && settings.currencySymbolPlacement === 's') && settings.negativeSignCharacter !== '' && isNegative(currentValue)) {\n                            settings.rawValue = settings.negativeSignCharacter + stripAllNonNumberCharacters(toStrip, settings, true);\n                        } else {\n                            settings.rawValue = stripAllNonNumberCharacters(toStrip, settings, true);\n                        }\n                    }\n\n                    setValue = false;\n                }\n            }\n\n            if (currentValue === '') {\n                switch (settings.emptyInputBehavior) {\n                    case 'focus':\n                        setValue = false;\n                        break;\n                    case 'always':\n                        $this.val(settings.currencySymbol);\n                        setValue = false;\n                        break;\n                    case 'zero':\n                        $this.autoNumeric('set', '0');\n                        setValue = false;\n                        break;\n                    default:\n                    //\n                }\n            } else if (setValue && currentValue === $this.attr('value')) {\n                $this.autoNumeric('set', currentValue);\n            }\n        }\n\n        if (isInArray($this.prop('tagName').toLowerCase(), settings.tagList) && $this.text() !== '') {\n            if (settings.defaultValueOverride !== null) {\n                if (settings.defaultValueOverride === $this.text()) {\n                    $this.autoNumeric('set', $this.text());\n                }\n            } else {\n                $this.autoNumeric('set', $this.text());\n            }\n        }\n    }\n\n    /**\n     * Enhance the user experience by modifying the default `negativePositiveSignPlacement` option depending on `currencySymbol` and `currencySymbolPlacement`.\n     *\n     * If the user has not set the placement of the negative sign (`negativePositiveSignPlacement`), but has set a currency symbol (`currencySymbol`),\n     * then we modify the default value of `negativePositiveSignPlacement` in order to keep the resulting output logical by default :\n     * - \"$-1,234.56\" instead of \"-$1,234.56\" ({currencySymbol: \"$\", negativePositiveSignPlacement: \"r\"})\n     * - \"-1,234.56$\" instead of \"1,234.56-$\" ({currencySymbol: \"$\", currencySymbolPlacement: \"s\", negativePositiveSignPlacement: \"p\"})\n     *\n     * @param {object} settings\n     */\n    function correctNegativePositiveSignPlacementOption(settings) {\n        // If negativePositiveSignPlacement is already set, we do not overwrite it\n        if (!isNull(settings.negativePositiveSignPlacement)) {\n            return;\n        }\n\n        if (!isUndefined(settings) && isUndefinedOrNullOrEmpty(settings.negativePositiveSignPlacement) && !isUndefinedOrNullOrEmpty(settings.currencySymbol)) {\n            switch (settings.currencySymbolPlacement) {\n                case 's':\n                    settings.negativePositiveSignPlacement = 'p'; // Default -1,234.56 €\n                    break;\n                case 'p':\n                    settings.negativePositiveSignPlacement = 'l'; // Default -$1,234.56\n                    break;\n                default:\n                //\n            }\n        } else {\n            // Sets the default value if `negativePositiveSignPlacement` is `null`\n            settings.negativePositiveSignPlacement = 'l';\n        }\n    }\n\n    /**\n     * Analyze and save the minimumValue and maximumValue integer size for later uses\n     *\n     * @param {object} settings\n     */\n    function calculateVMinAndVMaxIntegerSizes(settings) {\n        var _settings$maximumValu = settings.maximumValue.toString().split('.'),\n            _settings$maximumValu2 = _slicedToArray(_settings$maximumValu, 1),\n            maximumValueIntegerPart = _settings$maximumValu2[0];\n\n        var _ref3 = !settings.minimumValue && settings.minimumValue !== 0 ? [] : settings.minimumValue.toString().split('.'),\n            _ref4 = _slicedToArray(_ref3, 1),\n            minimumValueIntegerPart = _ref4[0];\n\n        maximumValueIntegerPart = maximumValueIntegerPart.replace('-', '');\n        minimumValueIntegerPart = minimumValueIntegerPart.replace('-', '');\n\n        settings.mIntPos = Math.max(maximumValueIntegerPart.length, 1);\n        settings.mIntNeg = Math.max(minimumValueIntegerPart.length, 1);\n    }\n\n    /**\n     * Modify `decimalPlacesOverride` as needed\n     *\n     * @param {object} settings\n     */\n    function correctDecimalPlacesOverrideOption(settings) {\n        if (isNull(settings.decimalPlacesOverride)) {\n            settings.decimalPlacesOverride = maximumVMinAndVMaxDecimalLength(settings.minimumValue, settings.maximumValue);\n        }\n        settings.oDec = String(settings.decimalPlacesOverride);\n\n        // Most calculus assume `decimalPlacesOverride` is an integer, the following statement makes it clear (otherwise having it as a string leads to problems in rounding for instance)\n        settings.decimalPlacesOverride = Number(settings.decimalPlacesOverride);\n    }\n\n    /**\n     * Sets the alternative decimal separator key.\n     *\n     * @param {object} settings\n     */\n    function setsAlternativeDecimalSeparatorCharacter(settings) {\n        if (isNull(settings.decimalCharacterAlternative) && Number(settings.decimalPlacesOverride) > 0) {\n            if (settings.decimalCharacter === '.' && settings.digitGroupSeparator !== ',') {\n                settings.decimalCharacterAlternative = ',';\n            } else if (settings.decimalCharacter === ',' && settings.digitGroupSeparator !== '.') {\n                settings.decimalCharacterAlternative = '.';\n            }\n        }\n    }\n\n    /**\n     * Caches regular expressions for stripAllNonNumberCharacters\n     *\n     * @param {object} settings\n     */\n    function cachesUsualRegularExpressions(settings) {\n        var allNumbersReg = '[0-9]';\n        var noAllNumbersReg = '[^0-9]';\n\n        // Test if there is a negative character in the string\n        var aNegReg = settings.negativeSignCharacter ? '([-\\\\' + settings.negativeSignCharacter + ']?)' : '(-?)';\n        settings.aNegRegAutoStrip = aNegReg;\n\n        var negativeSignRegPart = void 0;\n        if (settings.negativeSignCharacter) {\n            negativeSignRegPart = '\\\\' + settings.negativeSignCharacter;\n        } else {\n            negativeSignRegPart = '';\n        }\n        settings.skipFirstAutoStrip = new RegExp(aNegReg + '[^-' + negativeSignRegPart + '\\\\' + settings.decimalCharacter + allNumbersReg + '].*?(' + allNumbersReg + '|\\\\' + settings.decimalCharacter + allNumbersReg + ')');\n        settings.skipLastAutoStrip = new RegExp('(' + allNumbersReg + '\\\\' + settings.decimalCharacter + '?)[^\\\\' + settings.decimalCharacter + allNumbersReg + ']' + noAllNumbersReg + '*$');\n\n        var allowed = '-0123456789\\\\' + settings.decimalCharacter;\n        settings.allowedAutoStrip = new RegExp('[^' + allowed + ']', 'g');\n        settings.numRegAutoStrip = new RegExp(aNegReg + '(?:\\\\' + settings.decimalCharacter + '?(' + allNumbersReg + '+\\\\' + settings.decimalCharacter + allNumbersReg + '+)|(' + allNumbersReg + '*(?:\\\\' + settings.decimalCharacter + allNumbersReg + '*)?))');\n\n        // Using this regex version `^${settings.aNegRegAutoStrip}0*(\\\\d|$)` entirely clear the input on blur\n        settings.stripReg = new RegExp('^' + settings.aNegRegAutoStrip + '0*(' + allNumbersReg + ')');\n    }\n\n    /**\n     * Modify the user settings to make them 'exploitable' later.\n     *\n     * @param {object} settings\n     */\n    function transformOptionsValuesToDefaultTypes(settings) {\n        $.each(settings, function (key, value) {\n            // Convert the string 'true' and 'false' to real Boolean\n            if (value === 'true' || value === 'false') {\n                settings[key] = value === 'true';\n            }\n\n            // Convert numbers in options to strings\n            //TODO if a value is already of type 'Number', shouldn't we keep it as a number for further manipulation, instead of using a string?\n            if (typeof value === 'number' && key !== 'aScale') {\n                settings[key] = value.toString();\n            }\n        });\n    }\n\n    /**\n     * Convert the old settings options name to new ones.\n     *\n     * @param {object} options\n     */\n    function convertOldOptionsToNewOnes(options) {\n        //TODO Delete this function once the old options are not used anymore\n        var oldOptionsConverter = {\n            // Old option name, with their corresponding new option\n            aSep: 'digitGroupSeparator',\n            nSep: 'noSeparatorOnFocus',\n            dGroup: 'digitalGroupSpacing',\n            aDec: 'decimalCharacter',\n            altDec: 'decimalCharacterAlternative',\n            aSign: 'currencySymbol',\n            pSign: 'currencySymbolPlacement',\n            pNeg: 'negativePositiveSignPlacement',\n            aSuffix: 'suffixText',\n            oLimits: 'overrideMinMaxLimits',\n            vMax: 'maximumValue',\n            vMin: 'minimumValue',\n            mDec: 'decimalPlacesOverride',\n            eDec: 'decimalPlacesShownOnFocus',\n            scaleDecimal: 'scaleDecimalPlaces',\n            aStor: 'saveValueToSessionStorage',\n            mRound: 'roundingMethod',\n            aPad: 'allowDecimalPadding',\n            nBracket: 'negativeBracketsTypeOnBlur',\n            wEmpty: 'emptyInputBehavior',\n            lZero: 'leadingZero',\n            aForm: 'formatOnPageLoad',\n            sNumber: 'selectNumberOnly',\n            anDefault: 'defaultValueOverride',\n            unSetOnSubmit: 'unformatOnSubmit',\n            outputType: 'outputFormat',\n            debug: 'showWarnings',\n            // Current options :\n            digitGroupSeparator: true,\n            noSeparatorOnFocus: true,\n            digitalGroupSpacing: true,\n            decimalCharacter: true,\n            decimalCharacterAlternative: true,\n            currencySymbol: true,\n            currencySymbolPlacement: true,\n            negativePositiveSignPlacement: true,\n            showPositiveSign: true,\n            suffixText: true,\n            overrideMinMaxLimits: true,\n            maximumValue: true,\n            minimumValue: true,\n            decimalPlacesOverride: true,\n            decimalPlacesShownOnFocus: true,\n            scaleDivisor: true,\n            scaleDecimalPlaces: true,\n            scaleSymbol: true,\n            saveValueToSessionStorage: true,\n            onInvalidPaste: true,\n            roundingMethod: true,\n            allowDecimalPadding: true,\n            negativeBracketsTypeOnBlur: true,\n            emptyInputBehavior: true,\n            leadingZero: true,\n            formatOnPageLoad: true,\n            selectNumberOnly: true,\n            defaultValueOverride: true,\n            unformatOnSubmit: true,\n            outputFormat: true,\n            showWarnings: true,\n            failOnUnknownOption: true,\n            //FIXME Find a way to exclude those internal data from the settings object (ideally by using another object, or better yet, class attributes) -->\n            hasFocus: true,\n            runOnce: true,\n            rawValue: true,\n            trailingNegative: true,\n            caretFix: true,\n            throwInput: true,\n            strip: true,\n            tagList: true,\n            negativeSignCharacter: true,\n            positiveSignCharacter: true,\n            mIntPos: true,\n            mIntNeg: true,\n            oDec: true,\n            oPad: true,\n            oBracket: true,\n            oSep: true,\n            oSign: true,\n            oSuffix: true,\n            aNegRegAutoStrip: true,\n            skipFirstAutoStrip: true,\n            skipLastAutoStrip: true,\n            allowedAutoStrip: true,\n            numRegAutoStrip: true,\n            stripReg: true,\n            holder: true\n        };\n\n        for (var option in options) {\n            if (options.hasOwnProperty(option)) {\n                if (oldOptionsConverter[option] === true) {\n                    // If the option is a 'new' option, we continue looping\n                    continue;\n                }\n\n                if (oldOptionsConverter.hasOwnProperty(option)) {\n                    // Else we have an 'old' option name\n                    warning('You are using the deprecated option name \\'' + option + '\\'. Please use \\'' + oldOptionsConverter[option] + '\\' instead from now on. The old option name will be dropped soon.', true);\n\n                    // Then we modify the initial option object to use the new options instead of the old ones\n                    options[oldOptionsConverter[option]] = options[option];\n                    delete options[option];\n                } else if (options.failOnUnknownOption) {\n                    // ...or the option name is unknown. This means there is a problem with the options object, therefore we throw an error.\n                    throwError('Option name \\'' + option + '\\' is unknown. Please fix the options passed to autoNumeric');\n                }\n            }\n        }\n    }\n\n    /**\n     * Analyse the settings/options passed by the user, validate and clean them, then return them.\n     * Note: This returns `null` if somehow the settings returned by jQuery is not an object.\n     *\n     * @param {object} options\n     * @param {object} $this jQuery-selected DOM element\n     * @param {boolean} update - If TRUE, then the settings already exists and this function only updates them instead of recreating them from scratch\n     * @returns {object|null}\n     */\n    function getInitialSettings(options, $this) {\n        var update = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n        // Attempt to grab \"autoNumeric\" settings. If they do not exist, it returns \"undefined\".\n        var settings = $this.data('autoNumeric');\n\n        // If the user used old options, we convert them to new ones\n        if (update || !isNull(options)) {\n            convertOldOptionsToNewOnes(options);\n        }\n\n        if (update || isUndefined(settings)) {\n            if (update) {\n                // The settings are updated\n                settings = $.extend(settings, options);\n            } else {\n                // If we couldn't grab any settings, create them from the default ones and combine them with the options passed\n                // The settings are generated for the first time\n                // This also attempt to grab the HTML5 data. If it doesn't exist, we'll get \"undefined\"\n                var tagData = $this.data();\n                settings = $.extend({}, defaultSettings, tagData, options, {\n                    hasFocus: false,\n                    runOnce: false,\n                    rawValue: '',\n                    trailingNegative: false,\n                    caretFix: false,\n                    throwInput: true, // Throw input event\n                    strip: true,\n                    tagList: allowedTagList\n                });\n            }\n\n            // Modify the user settings to make them 'exploitable'\n            transformOptionsValuesToDefaultTypes(settings);\n\n            // Improve the `negativePositiveSignPlacement` option if needed\n            correctNegativePositiveSignPlacementOption(settings);\n\n            // Set the negative and positive signs, as needed\n            settings.negativeSignCharacter = settings.minimumValue < 0 ? '-' : '';\n            settings.positiveSignCharacter = settings.maximumValue >= 0 ? '+' : '';\n\n            // Additional changes to the settings object (from the original autoCode() function)\n            runCallbacksFoundInTheSettingsObject($this, settings);\n            calculateVMinAndVMaxIntegerSizes(settings);\n            correctDecimalPlacesOverrideOption(settings);\n            setsAlternativeDecimalSeparatorCharacter(settings);\n            cachesUsualRegularExpressions(settings);\n\n            // Validate the settings\n            validate(settings, false); // Throws if necessary\n\n            // Original settings saved for use when decimalPlacesShownOnFocus, scaleDivisor & noSeparatorOnFocus options are being used\n            keepAnOriginalSettingsCopy(settings);\n\n            // Save our new settings\n            $this.data('autoNumeric', settings);\n\n            return settings;\n        } else {\n            return null;\n        }\n    }\n\n    /**\n     * Convert the `value` parameter that can either be :\n     * - a real number,\n     * - a string representing a real number, or\n     * - a string representing a localized number (with specific group separators and decimal character),\n     * ...to a string representing a real 'javascript' number (ie. '1234' or '1234.567').\n     *\n     * This function returns `NaN` if such conversion fails.\n     *\n     * @param {int|float|string} value\n     * @param {object} settings\n     * @returns {string|NaN}\n     */\n    function toNumericValue(value, settings) {\n        var result = void 0;\n        if (isNumber(Number(value))) {\n            // The value has either already been stripped, or a 'real' javascript number is passed as a parameter\n            result = value;\n        } else {\n            // Else if it's a string that `Number()` cannot typecast, then we try to convert the localized numeric string to a numeric one\n            // Convert the value to a numeric string, stripping unnecessary characters in the process\n            result = convertToNumericString(value.toString(), settings);\n\n            // If the result is still not a numeric string, then we throw a warning\n            if (!isNumber(Number(result))) {\n                warning('The value \"' + value + '\" being \"set\" is not numeric and therefore cannot be used appropriately.', settings.showWarnings);\n                result = NaN;\n            }\n        }\n\n        return result;\n    }\n\n    /**\n     * Methods supported by autoNumeric\n     */\n    var methods = {\n        /**\n         * Method to initialize autoNumeric and attach the settings (options can be passed as a parameter)\n         * The options passed as a parameter is an object that contains the settings (ie. {digitGroupSeparator: \".\", decimalCharacter: \",\", currencySymbol: '€ '})\n         *\n         * @example\n         * $(someSelector).autoNumeric('init');            // Initiate autoNumeric with defaults\n         * $(someSelector).autoNumeric();                  // Initiate autoNumeric with defaults\n         * $(someSelector).autoNumeric('init', {options}); // Initiate autoNumeric with options\n         * $(someSelector).autoNumeric({options});         // Initiate autoNumeric with options\n         *\n         * @param {object} options\n         * @returns {*|{statements, branches, lines, functions, excludes, overrides}|{statements, branches, lines, functions, excludes}|{statements, lines, branches, functions, excludes}}\n         */\n        init: function init(options) {\n            return this.each(function () {\n                var $this = $(this);\n                var $input = getInputIfSupportedTagAndType($this);\n\n                var settings = getInitialSettings(options, $this, false);\n                if (isNull(settings)) {\n                    return this;\n                }\n\n                // Create the AutoNumericHolder object that store the field properties\n                var holder = getAutoNumericHolder($this, settings, false);\n\n                if (!settings.runOnce && settings.formatOnPageLoad) {\n                    formatDefaultValueOnPageLoad(settings, $input, $this);\n                }\n\n                settings.runOnce = true;\n\n                // Add the events listeners to supported input types (\"text\", \"hidden\", \"tel\" and no type)\n                if ($input) {\n                    this.addEventListener('focusin', function (e) {\n                        onFocusInAndMouseEnter($this, holder, e);\n                    }, false);\n                    this.addEventListener('mouseenter', function (e) {\n                        onFocusInAndMouseEnter($this, holder, e);\n                    }, false);\n                    this.addEventListener('blur', function (e) {\n                        onFocusOutAndMouseLeave($this, holder, e);\n                    }, false);\n                    this.addEventListener('mouseleave', function (e) {\n                        onFocusOutAndMouseLeave($this, holder, e);\n                    }, false);\n                    this.addEventListener('keydown', function (e) {\n                        onKeydown(holder, e);\n                    }, false);\n                    this.addEventListener('keypress', function (e) {\n                        onKeypress(holder, e);\n                    }, false);\n                    this.addEventListener('keyup', function (e) {\n                        onKeyup(holder, settings, e);\n                    }, false);\n                    this.addEventListener('blur', function (e) {\n                        onBlur(holder, e);\n                    }, false);\n                    this.addEventListener('paste', function (e) {\n                        onPaste($this, holder, e);\n                    }, false);\n                    onSubmit($this, holder); //TODO Switch to `addEventListener'\n                }\n            });\n        },\n\n\n        /**\n         * Method to stop and remove autoNumeric for the current element.\n         * Note: this does not remove the formatting.\n         *\n         * @example $(someSelector).autoNumeric(\"destroy\"); // Destroys autoNumeric on this selected element\n         *\n         * @returns {*|jQuery}\n         */\n        destroy: function destroy() {\n            return $(this).each(function () {\n                var $this = getCurrentElement(this);\n                var settings = $this.data('autoNumeric');\n                if ((typeof settings === 'undefined' ? 'undefined' : _typeof(settings)) === 'object') {\n                    $this.val('');\n                    saveValueToPersistentStorage($this[0], settings, 'wipe');\n                    $this.removeData('autoNumeric');\n                    $this.off('.autoNumeric');\n                }\n            });\n        },\n\n\n        /**\n         * Method to clear the value from sessionStorage (or cookie, depending on browser supports).\n         *\n         * @example $(someSelector).autoNumeric(\"wipe\"); // Removes session storage and cookies from memory\n         *\n         * @returns {*|jQuery}\n         */\n        wipe: function wipe() {\n            return $(this).each(function () {\n                var $this = getCurrentElement(this);\n                var settings = $this.data('autoNumeric');\n                if ((typeof settings === 'undefined' ? 'undefined' : _typeof(settings)) === 'object') {\n                    $this.val('');\n                    settings.rawValue = '';\n                    saveValueToPersistentStorage($this[0], settings, 'wipe');\n                }\n            });\n        },\n\n\n        /**\n         * Method that updates the autoNumeric settings.\n         * It can be called multiple times if needed.\n         * The options passed as a parameter is an object that contains the settings (ie. {digitGroupSeparator: \".\", decimalCharacter: \",\", currencySymbol: '€ '}).\n         *\n         * @example $(someSelector).autoNumeric(\"update\", {options}); // Updates the settings\n         *\n         * @param {object} options\n         * @returns {*|jQuery}\n         */\n        update: function update(options) {\n            return $(this).each(function () {\n                // Retrieve the current unformatted input value\n                var $this = getCurrentElement(this);\n                var strip = $this.autoNumeric('get');\n\n                // Update the settings\n                var settings = getInitialSettings(options, $this, true);\n\n                // Update the AutoNumericHolder object that store the field properties\n                getAutoNumericHolder($this, settings, true);\n\n                // Reformat the input value with the new settings\n                if ($this.val() !== '' || $this.text() !== '') {\n                    return $this.autoNumeric('set', strip);\n                }\n            });\n        },\n\n\n        /**\n         * Method to format the value passed as a parameter.\n         * If the value is passed as a string, it can be an integer '1234' or a double '1234.56789'\n         * and must contain only numbers and one decimal (period) character\n         *\n         * @example $(someSelector).autoNumeric('set', '12345.67'); // Formats the value being passed as the second parameter\n         *\n         * @param {*} newValue\n         * @returns {*|jQuery}\n         */\n        set: function set(newValue) {\n            return $(this).each(function () {\n                if (newValue === null || isUndefined(newValue)) {\n                    return;\n                }\n\n                //TODO This looks a lot like `getInputIfSupportedTagAndType()`. Is that necessary? Can the input element be changed since autoNumeric has been initialized?\n                var $this = getCurrentElement(this);\n                var settings = $this.data('autoNumeric');\n                if ((typeof settings === 'undefined' ? 'undefined' : _typeof(settings)) !== 'object') {\n                    throwError('Initializing autoNumeric is required prior to calling the \"set\" method.');\n                }\n                // Reset the trailing negative settings, since it's possible the previous value was negative, but not the newly set one\n                settings.trailingNegative = false;\n\n                var $input = $this.is('input[type=text], input[type=hidden], input[type=tel], input:not([type])');\n\n                var value = toNumericValue(newValue, settings);\n                if (isNaN(value)) {\n                    return $this.val('');\n                }\n\n                if (value !== '') {\n                    var _checkIfInRangeWithOv5 = checkIfInRangeWithOverrideOption(value, settings),\n                        _checkIfInRangeWithOv6 = _slicedToArray(_checkIfInRangeWithOv5, 2),\n                        minTest = _checkIfInRangeWithOv6[0],\n                        maxTest = _checkIfInRangeWithOv6[1];\n                    // This test is needed by the showPositiveSign option\n\n\n                    var isZero = isZeroOrHasNoValue(value);\n                    if (isZero) {\n                        value = '0';\n                    }\n\n                    if (minTest && maxTest) {\n                        if ($input || isInArray($this.prop('tagName').toLowerCase(), settings.tagList)) {\n                            // to ensure rounding does not happen twice\n                            var hasBeenRounded = false;\n\n                            // rounds the the extended decimal places\n                            var tempDecimal = void 0;\n                            if (settings.decimalPlacesShownOnFocus) {\n                                tempDecimal = settings.decimalPlacesOverride;\n                                settings.decimalPlacesOverride = Number(settings.decimalPlacesShownOnFocus);\n                                value = roundValue(value, settings);\n                                hasBeenRounded = true;\n                                settings.decimalPlacesOverride = tempDecimal;\n                            }\n\n                            if (settings.scaleDivisor && !settings.onOff) {\n                                value = roundValue(value, settings);\n                                settings.rawValue = cleanLeadingTrailingZeros(value.replace(settings.decimalCharacter, '.'), settings);\n                                value = toNumericValue(value, settings);\n                                value = value / settings.scaleDivisor;\n                                value = value.toString();\n                                if (settings.scaleDecimalPlaces) {\n                                    tempDecimal = settings.decimalPlacesOverride;\n                                    settings.decimalPlacesOverride = Number(settings.scaleDecimalPlaces);\n                                    value = roundValue(value, settings);\n                                    hasBeenRounded = true;\n                                }\n                            }\n\n                            // Rounds if this has not been done already\n                            if (!hasBeenRounded) {\n                                value = roundValue(value, settings);\n                            }\n\n                            // Stores rawValue including the decimalPlacesShownOnFocus\n                            if (!settings.scaleDivisor) {\n                                settings.rawValue = cleanLeadingTrailingZeros(value.replace(settings.decimalCharacter, '.'), settings);\n                            }\n\n                            value = modifyNegativeSignAndDecimalCharacterForFormattedValue(value, settings);\n                            value = addGroupSeparators(value, settings);\n\n                            if (settings.scaleDivisor && settings.scaleDecimalPlaces && !settings.onOff) {\n                                settings.decimalPlacesOverride = tempDecimal;\n                            }\n                        }\n\n                        if (settings.saveValueToSessionStorage && (settings.decimalPlacesShownOnFocus || settings.scaleDivisor)) {\n                            saveValueToPersistentStorage($this[0], settings, 'set');\n                        }\n                    } else {\n                        settings.rawValue = '';\n                        saveValueToPersistentStorage($this[0], settings, 'wipe');\n                        var attemptedValue = value;\n                        value = '';\n                        if (!minTest) {\n                            $this.trigger('autoNumeric:minExceeded');\n                        }\n\n                        if (!maxTest) {\n                            $this.trigger('autoNumeric:maxExceeded');\n                        }\n\n                        throwError('The value [' + attemptedValue + '] being set falls outside of the minimumValue [' + settings.minimumValue + '] and maximumValue [' + settings.maximumValue + '] range set for this element');\n\n                        return $this.val('');\n                    }\n                } else {\n                    return $this.val('');\n                }\n\n                if (!settings.hasFocus && settings.scaleSymbol) {\n                    value = value + settings.scaleSymbol;\n                }\n\n                if ($input) {\n                    return $this.val(value);\n                }\n\n                if (isInArray($this.prop('tagName').toLowerCase(), settings.tagList)) {\n                    return $this.text(value);\n                }\n\n                return false;\n            });\n        },\n\n\n        /**\n         * Method to un-format inputs.\n         * This is handy to use right before form submission.\n         *\n         * By default, values are returned as ISO numeric strings (ie. \"1234.56\" or \"-1234.56\"), where the decimal character is a period.\n         * Locale formats are supported \"1234.56-\" or \"1234,56\" or \"-1234,56 or \"1234,56-\", or even plain numbers.\n         * Please see option \"outputFormat\" for more details\n         *\n         * @example $(someSelector).autoNumeric('unSet');\n         *\n         * @returns {*|jQuery}\n         */\n        unSet: function unSet() {\n            return $(this).each(function () {\n                var $this = getCurrentElement(this);\n                var settings = $this.data('autoNumeric');\n                if ((typeof settings === 'undefined' ? 'undefined' : _typeof(settings)) === 'object') {\n                    settings.hasFocus = true;\n                    $this.val($this.autoNumeric('getLocalized'));\n                }\n            });\n        },\n\n\n        /**\n         * Method to re-format inputs.\n         * This is handy to use right after form submission.\n         *\n         * This is called after the 'unSet' method to reformat the input\n         *\n         * @example $(someSelector).autoNumeric('reSet');\n         *\n         * @returns {*|jQuery}\n         */\n        reSet: function reSet() {\n            return $(this).each(function () {\n                var $this = getCurrentElement(this);\n                var settings = $this.data('autoNumeric');\n                if ((typeof settings === 'undefined' ? 'undefined' : _typeof(settings)) === 'object') {\n                    $this.autoNumeric('set', $this.val());\n                }\n            });\n        },\n\n\n        /**\n         * Return the unformatted value as a string.\n         *\n         * @usage $(someSelector).autoNumeric('get');\n         *\n         * @returns {string}\n         */\n        get: function get() {\n            //TODO Why would we need to get a new reference to $this since it has been done in `init()`?\n            var $this = getCurrentElement(this);\n            //TODO This looks a lot like `getInputIfSupportedTagAndType()`. Is that necessary? Can the input element be changed since autoNumeric has been initialized?\n            var $input = $this.is('input[type=text], input[type=hidden], input[type=tel], input:not([type])');\n            var settings = $this.data('autoNumeric');\n            if ((typeof settings === 'undefined' ? 'undefined' : _typeof(settings)) !== 'object') {\n                throwError('Initializing autoNumeric is required prior to calling the \"get\" method.');\n            }\n\n            // determine the element type then use .eq(0) selector to grab the value of the first element in selector\n            var value = '';\n            if ($input) {\n                value = $this.eq(0).val();\n            } else if (isInArray($this.prop('tagName').toLowerCase(), settings.tagList)) {\n                value = $this.eq(0).text();\n            } else {\n                throwError('The \"<' + $this.prop('tagName').toLowerCase() + '>\" tag is not supported by autoNumeric');\n            }\n\n            if (settings.decimalPlacesShownOnFocus || settings.scaleDivisor) {\n                value = settings.rawValue;\n            } else {\n                // Test if the value is negative\n                var isValueNegative = isNegative(value);\n\n                if (!/\\d/.test(value) && settings.emptyInputBehavior === 'focus') {\n                    return '';\n                }\n\n                if (value !== '' && settings.negativeBracketsTypeOnBlur !== null) {\n                    settings.hasFocus = true;\n                    value = toggleNegativeBracket(value, settings);\n                }\n\n                if (settings.runOnce || settings.formatOnPageLoad === false) {\n                    // Strips trailing negative symbol\n                    value = stripAllNonNumberCharacters(value, settings, true);\n                    // Trims leading and trailing zeros when leadingZero does NOT equal \"keep\".\n                    value = cleanLeadingTrailingZeros(value.replace(settings.decimalCharacter, '.'), settings);\n\n                    // Places the negative symbol in front of the trailing negative\n                    if (settings.trailingNegative && isValueNegative && !isNegative(value) && Number(value) !== 0) {\n                        value = '-' + value;\n                    }\n                }\n\n                if (value !== '' || value === '' && settings.emptyInputBehavior === 'zero') {\n                    value = modifyNegativeSignAndDecimalCharacterForRawValue(value, settings);\n                }\n            }\n\n            // Always return a numeric string\n            // This gets rid of the trailing zeros in the decimal places since `get` does not pad decimals\n            return trimPaddedZerosFromDecimalPlaces(value);\n        },\n\n\n        /**\n         * Returns the unformatted value, but following the `outputFormat` setting, which means the output can either be :\n         * - a string (that could or could not represent a number (ie. \"12345,67-\")), or\n         * - a plain number (if the setting 'number' is used).\n         *\n         * By default the returned values are an ISO numeric string \"1234.56\" or \"-1234.56\" where the decimal character is a period.\n         * Check the \"outputFormat\" option definition for more details.\n         *\n         * @usage $(someSelector).autoNumeric('getLocalized');\n         *\n         * @returns {*}\n         */\n        getLocalized: function getLocalized() {\n            var $this = getCurrentElement(this);\n            var value = $this.autoNumeric('get');\n            var settings = $this.data('autoNumeric');\n\n            if (Number(value) === 0 && settings.leadingZero !== 'keep') {\n                value = '0';\n            }\n\n            return toLocale(value, settings.outputFormat);\n        },\n\n\n        /**\n         * Return the input unformatted value as a real Javascript number.\n         *\n         * @usage $(someSelector).autoNumeric('getNumber');\n         *\n         * @returns {number}\n         */\n        getNumber: function getNumber() {\n            var $this = getCurrentElement(this);\n            var value = $this.autoNumeric('get');\n\n            return toLocale(value, 'number');\n        },\n\n\n        /**\n         * Return the current formatted value of the autoNumeric element.\n         * @usage aNInput.autoNumeric('getFormatted'))\n         *\n         * @returns {string}\n         */\n        getFormatted: function getFormatted() {\n            // Make sure `this[0]` exists as well as `.value` before trying to access that property\n            if (!this.hasOwnProperty('0') || !('value' in this[0])) {\n                throwError('Unable to get the formatted string from the element.');\n            }\n\n            return this[0].value;\n        },\n\n\n        /**\n         * The \"getString\" method uses jQuery's .serialize() method that creates a text string in standard URL-encoded notation.\n         *\n         * It then loops through the string and un-formats the inputs with autoNumeric.\n         * By defaults values returned as ISO numeric string \"1234.56\" or \"-1234.56\" where the decimal character is a period\n         * Locale formats are supported \"1234.56-\" or \"1234,56\" or \"-1234,56 or \"1234,56-\" or plain numbers => please see option \"outputFormat\" for details\n         *\n         * @returns {string}\n         */\n        getString: function getString() {\n            return _getStringOrArray(false, this);\n        },\n\n\n        /**\n         * The \"getArray\" method on the other hand uses jQuery's .serializeArray() method that creates array or objects that can be encoded as a JSON string.\n         *\n         * It then loops through the string and un-formats the inputs with autoNumeric.\n         * By defaults values returned as ISO numeric string \"1234.56\" or \"-1234.56\" where the decimal character is a period\n         * Locale formats are supported \"1234.56-\" or \"1234,56\" or \"-1234,56 or \"1234,56-\" or plain numbers => please see option \"outputFormat\" for details\n         *\n         * @returns {{}|[]}\n         */\n        getArray: function getArray() {\n            return _getStringOrArray(true, this);\n        },\n\n\n        /**\n         * The 'getSettings' function returns an object containing all the current autoNumeric settings.\n         *\n         * @example\n         * $(someSelector).autoNumeric('getSettings');\n         * $(someSelector).autoNumeric('getSettings').decimalCharacter; // Return the decimalCharacter setting as a string - any valid option name can be used\n         *\n         * @returns {object}\n         */\n        getSettings: function getSettings() {\n            //TODO Add an option argument `optionName` to this function so that it return only the value of that option, not the entire settings object\n            return this.data('autoNumeric');\n        }\n    };\n\n    /**\n     * The autoNumeric function accepts methods names (in string format) and those method parameters if needed.\n     * It initialize autoNumeric on the given element.\n     *\n     * @param {string} method The method name (ie. 'set', 'get', etc.)\n     * @param {*} args\n     * @returns {*}\n     */\n    $.fn.autoNumeric = function (method) {\n        if (methods[method]) {\n            for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n                args[_key - 1] = arguments[_key];\n            }\n\n            return methods[method].apply(this, args);\n        }\n\n        if ((typeof method === 'undefined' ? 'undefined' : _typeof(method)) === 'object' || !method) {\n            // The options have been passed directly, without using a named method\n            return methods.init.apply(this, [method]);\n        }\n\n        throwError('Method \"' + method + '\" is not supported by autoNumeric');\n    };\n\n    /**\n     * Return the default autoNumeric settings.\n     *\n     * @returns {object}\n     */\n    getDefaultConfig = function getDefaultConfig() {\n        return defaultSettings;\n    };\n\n    $.fn.autoNumeric.defaults = defaultSettings; // Make those settings public via jQuery too.\n\n    /**\n     * Return all the predefined language options in one object.\n     * You can also access a specific language object directly by using `an.getLanguages().French` for instance.\n     *\n     * @returns {object}\n     */\n    getLanguages = function getLanguages() {\n        return languageOption;\n    };\n\n    $.fn.autoNumeric.lang = languageOption; // Make those predefined language options public via jQuery too.\n\n    /**\n     * Public function that allows formatting without an element trigger.\n     *\n     * @param {number|string} value A number, or a string that represent a javascript number\n     * @param {object|null} options\n     * @returns {*}\n     */\n    autoFormat = function autoFormat(value) {\n        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\n        if (isUndefined(value) || value === null) {\n            return null;\n        }\n\n        if (!isString(value) && !isNumber(value)) {\n            throwError('The value \"' + value + '\" being \"set\" is not numeric and therefore cannot be used appropriately.');\n        }\n\n        // Initiate a very basic settings object\n        var settings = $.extend({}, defaultSettings, { strip: false }, options);\n        if (value < 0) {\n            settings.negativeSignCharacter = '-';\n        }\n\n        if (isNull(settings.decimalPlacesOverride)) {\n            settings.decimalPlacesOverride = maximumVMinAndVMaxDecimalLength(settings.minimumValue, settings.maximumValue);\n        }\n\n        // Check the validity of the `value` parameter\n        // Convert the value to a numeric string, stripping unnecessary characters in the process\n        var valueString = toNumericValue(value, settings);\n        if (isNaN(valueString)) {\n            throwError('The value [' + valueString + '] that you are trying to format is not a recognized number.');\n        }\n\n        // Basic tests to check if the given valueString is valid\n\n        var _checkIfInRangeWithOv7 = checkIfInRangeWithOverrideOption(valueString, settings),\n            _checkIfInRangeWithOv8 = _slicedToArray(_checkIfInRangeWithOv7, 2),\n            minTest = _checkIfInRangeWithOv8[0],\n            maxTest = _checkIfInRangeWithOv8[1];\n\n        if (!minTest || !maxTest) {\n            // Throw a custom event\n            triggerEvent('autoFormat.autoNumeric', document, 'Range test failed');\n            throwError('The value [' + valueString + '] being set falls outside of the minimumValue [' + settings.minimumValue + '] and maximumValue [' + settings.maximumValue + '] range set for this element');\n        }\n\n        // Everything is ok, proceed to rounding, formatting and grouping\n        valueString = roundValue(valueString, settings);\n        valueString = modifyNegativeSignAndDecimalCharacterForFormattedValue(valueString, settings);\n        valueString = addGroupSeparators(valueString, settings);\n\n        return valueString;\n    };\n\n    $.fn.autoFormat = autoFormat; // The jQuery export\n\n    /**\n     * Public function that allows unformatting without an element.\n     *\n     * @param {string|number} value\n     * @param {object} options\n     * @returns {*}\n     */\n    autoUnFormat = function autoUnFormat(value, options) {\n        if (isUndefined(value) || value === null) {\n            return null;\n        }\n\n        // Giving an unformatted value should return the same unformatted value, whatever the options passed as a parameter\n        if (isNumber(value)) {\n            return Number(value);\n        }\n\n        if (isArray(value) || isObject(value)) {\n            //TODO Complete the test to throw when given a wrongly formatted number (ie. 'foobar')\n            // Check the validity of the `value` parameter\n            throwError('A number or a string representing a number is needed to be able to unformat it, [' + value + '] given.');\n        }\n\n        var settings = $.extend({}, defaultSettings, { strip: false }, options);\n        var allowed = '-0123456789\\\\' + settings.decimalCharacter;\n        var autoStrip = new RegExp('[^' + allowed + ']', 'gi');\n        value = value.toString();\n\n        // This checks is a negative sign is anywhere in the `value`, not just on the very first character (ie. '12345.67-')\n        if (isNegative(value)) {\n            settings.negativeSignCharacter = '-';\n        } else if (settings.negativeBracketsTypeOnBlur && settings.negativeBracketsTypeOnBlur.split(',')[0] === value.charAt(0)) {\n            settings.negativeSignCharacter = '-';\n            settings.hasFocus = true;\n            value = toggleNegativeBracket(value, settings);\n        }\n\n        value = value.replace(autoStrip, '');\n        value = value.replace(settings.decimalCharacter, '.');\n        value = toLocale(value, settings.outputFormat);\n\n        return value;\n    };\n\n    $.fn.autoUnformat = autoUnFormat; // The jQuery export\n\n    /**\n     * Validate the given option object.\n     * If the options are valid, this function returns nothing, otherwise if the options are invalid, this function throws an error.\n     *\n     * This tests if the options are not conflicting and are well formatted.\n     * This function is lenient since it only tests the settings properties ; it ignores any other properties the options object could have.\n     *\n     * @param {*} userOptions\n     * @param {Boolean} shouldExtendDefaultOptions If TRUE, then this function will extends the `userOptions` passed by the user, with the default options.\n     * @throws Error\n     */\n    validate = function validate(userOptions) {\n        var shouldExtendDefaultOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n        if (isUndefinedOrNullOrEmpty(userOptions) || !isObject(userOptions) || isEmptyObj(userOptions)) {\n            throwError('The userOptions are invalid ; it should be a valid object, [' + userOptions + '] given.');\n        }\n\n        // If the user used old options, we convert them to new ones\n        if (!isNull(userOptions)) {\n            convertOldOptionsToNewOnes(userOptions);\n        }\n\n        // The user can choose if the `userOptions` has already been extended with the default options, or not\n        var options = void 0;\n        if (shouldExtendDefaultOptions) {\n            options = $.extend({}, defaultSettings, userOptions);\n        } else {\n            options = userOptions;\n        }\n\n        // First things first, we test that the `showWarnings` option is valid\n        if (!isTrueOrFalseString(options.showWarnings) && !isBoolean(options.showWarnings)) {\n            throwError('The debug option \\'showWarnings\\' is invalid ; it should be either \\'false\\' or \\'true\\', [' + options.showWarnings + '] given.');\n        }\n\n        // Define the regular expressions needed for the following tests\n        var testPositiveInteger = /^[0-9]+$/;\n        var testNumericalCharacters = /[0-9]+/;\n        // const testFloatAndPossibleNegativeSign = /^-?[0-9]+(\\.?[0-9]+)$/;\n        var testFloatOrIntegerAndPossibleNegativeSign = /^-?[0-9]+(\\.?[0-9]+)?$/;\n        var testPositiveFloatOrInteger = /^[0-9]+(\\.?[0-9]+)?$/;\n\n        // Then tests the options individually\n        if (!isInArray(options.digitGroupSeparator, [',', // Comma\n        '.', // Dot\n        ' ', // Normal space\n        '\\u2009', // Thin-space\n        '\\u202F', // Narrow no-break space\n        '\\xA0', // No-break space\n        '', // No separator\n        \"'\", // Apostrophe\n        '٬', // Arabic thousands separator\n        '˙'])) {\n            throwError('The thousand separator character option \\'digitGroupSeparator\\' is invalid ; it should be \\',\\', \\'.\\', \\'\\u066C\\', \\'\\u02D9\\', \"\\'\", \\' \\', \\'\\u2009\\', \\'\\u202F\\', \\'\\xA0\\' or empty (\\'\\'), [' + options.digitGroupSeparator + '] given.');\n        }\n\n        if (!isTrueOrFalseString(options.noSeparatorOnFocus) && !isBoolean(options.noSeparatorOnFocus)) {\n            throwError('The \\'noSeparatorOnFocus\\' option is invalid ; it should be either \\'false\\' or \\'true\\', [' + options.noSeparatorOnFocus + '] given.');\n        }\n\n        if (!testPositiveInteger.test(options.digitalGroupSpacing)) {\n            throwError('The digital grouping for thousand separator option \\'digitalGroupSpacing\\' is invalid ; it should be a positive integer, [' + options.digitalGroupSpacing + '] given.');\n        }\n\n        if (!isInArray(options.decimalCharacter, [',', // Comma\n        '.', // Dot\n        '·', // Middle-dot\n        '٫', // Arabic decimal separator\n        '⎖'])) {\n            throwError('The decimal separator character option \\'decimalCharacter\\' is invalid ; it should be \\'.\\', \\',\\', \\'\\xB7\\', \\'\\u2396\\' or \\'\\u066B\\', [' + options.decimalCharacter + '] given.');\n        }\n\n        // Checks if the decimal and thousand characters are the same\n        if (options.decimalCharacter === options.digitGroupSeparator) {\n            throwError('autoNumeric will not function properly when the decimal character \\'decimalCharacter\\' [' + options.decimalCharacter + '] and the thousand separator \\'digitGroupSeparator\\' [' + options.digitGroupSeparator + '] are the same character.');\n        }\n\n        if (!isNull(options.decimalCharacterAlternative) && !isString(options.decimalCharacterAlternative)) {\n            throwError('The alternate decimal separator character option \\'decimalCharacterAlternative\\' is invalid ; it should be a string, [' + options.decimalCharacterAlternative + '] given.');\n        }\n\n        if (options.currencySymbol !== '' && !isString(options.currencySymbol)) {\n            throwError('The currency symbol option \\'currencySymbol\\' is invalid ; it should be a string, [' + options.currencySymbol + '] given.');\n        }\n\n        if (!isInArray(options.currencySymbolPlacement, ['p', 's'])) {\n            throwError('The placement of the currency sign option \\'currencySymbolPlacement\\' is invalid ; it should either be \\'p\\' (prefix) or \\'s\\' (suffix), [' + options.currencySymbolPlacement + '] given.');\n        }\n\n        if (!isInArray(options.negativePositiveSignPlacement, ['p', 's', 'l', 'r', null])) {\n            throwError('The placement of the negative sign option \\'negativePositiveSignPlacement\\' is invalid ; it should either be \\'p\\' (prefix), \\'s\\' (suffix), \\'l\\' (left), \\'r\\' (right) or \\'null\\', [' + options.negativePositiveSignPlacement + '] given.');\n        }\n\n        if (!isTrueOrFalseString(options.showPositiveSign) && !isBoolean(options.showPositiveSign)) {\n            throwError('The show positive sign option \\'showPositiveSign\\' is invalid ; it should be either \\'false\\' or \\'true\\', [' + options.showPositiveSign + '] given.');\n        }\n\n        if (!isString(options.suffixText) || options.suffixText !== '' && (isNegative(options.suffixText) || testNumericalCharacters.test(options.suffixText))) {\n            throwError('The additional suffix option \\'suffixText\\' is invalid ; it should not contains the negative sign \\'-\\' nor any numerical characters, [' + options.suffixText + '] given.');\n        }\n\n        if (!isNull(options.overrideMinMaxLimits) && !isInArray(options.overrideMinMaxLimits, ['ceiling', 'floor', 'ignore'])) {\n            throwError('The override min & max limits option \\'overrideMinMaxLimits\\' is invalid ; it should either be \\'ceiling\\', \\'floor\\' or \\'ignore\\', [' + options.overrideMinMaxLimits + '] given.');\n        }\n\n        if (!isString(options.maximumValue) || !testFloatOrIntegerAndPossibleNegativeSign.test(options.maximumValue)) {\n            throwError('The maximum possible value option \\'maximumValue\\' is invalid ; it should be a string that represents a positive or negative number, [' + options.maximumValue + '] given.');\n        }\n\n        if (!isString(options.minimumValue) || !testFloatOrIntegerAndPossibleNegativeSign.test(options.minimumValue)) {\n            throwError('The minimum possible value option \\'minimumValue\\' is invalid ; it should be a string that represents a positive or negative number, [' + options.minimumValue + '] given.');\n        }\n\n        if (parseFloat(options.minimumValue) > parseFloat(options.maximumValue)) {\n            throwError('The minimum possible value option is greater than the maximum possible value option ; \\'minimumValue\\' [' + options.minimumValue + '] should be smaller than \\'maximumValue\\' [' + options.maximumValue + '].');\n        }\n\n        if (!(isNull(options.decimalPlacesOverride) || isInt(options.decimalPlacesOverride) && options.decimalPlacesOverride >= 0 || // If integer option\n        isString(options.decimalPlacesOverride) && testPositiveInteger.test(options.decimalPlacesOverride)) // If string option\n        ) {\n                throwError('The maximum number of decimal places option \\'decimalPlacesOverride\\' is invalid ; it should be a positive integer, [' + options.decimalPlacesOverride + '] given.');\n            }\n\n        // Write a warning message in the console if the number of decimal in minimumValue/maximumValue is overridden by decimalPlacesOverride (and not if decimalPlacesOverride is equal to the number of decimal used in minimumValue/maximumValue)\n        var vMinAndVMaxMaximumDecimalPlaces = maximumVMinAndVMaxDecimalLength(options.minimumValue, options.maximumValue);\n        if (!isNull(options.decimalPlacesOverride) && vMinAndVMaxMaximumDecimalPlaces !== Number(options.decimalPlacesOverride)) {\n            warning('Setting \\'decimalPlacesOverride\\' to [' + options.decimalPlacesOverride + '] will override the decimals declared in \\'minimumValue\\' [' + options.minimumValue + '] and \\'maximumValue\\' [' + options.maximumValue + '].', options.showWarnings);\n        }\n\n        if (!options.allowDecimalPadding && !isNull(options.decimalPlacesOverride)) {\n            warning('Setting \\'allowDecimalPadding\\' to [false] will override the current \\'decimalPlacesOverride\\' setting [' + options.decimalPlacesOverride + '].', options.showWarnings);\n        }\n\n        if (!isNull(options.decimalPlacesShownOnFocus) && (!isString(options.decimalPlacesShownOnFocus) || !testPositiveInteger.test(options.decimalPlacesShownOnFocus))) {\n            throwError('The number of expanded decimal places option \\'decimalPlacesShownOnFocus\\' is invalid ; it should be a positive integer, [' + options.decimalPlacesShownOnFocus + '] given.');\n        }\n\n        // Checks if the extended decimal places \"decimalPlacesShownOnFocus\" is greater than the normal decimal places \"decimalPlacesOverride\"\n        if (!isNull(options.decimalPlacesShownOnFocus) && !isNull(options.decimalPlacesOverride) && Number(options.decimalPlacesOverride) > Number(options.decimalPlacesShownOnFocus)) {\n            warning('The extended decimal places \\'decimalPlacesShownOnFocus\\' [' + options.decimalPlacesShownOnFocus + '] should be greater than the \\'decimalPlacesOverride\\' [' + options.decimalPlacesOverride + '] value. Currently, this will limit the ability of your client to manually change some of the decimal places. Do you really want to do that?', options.showWarnings);\n        }\n\n        if (!isNull(options.scaleDivisor) && !testPositiveFloatOrInteger.test(options.scaleDivisor)) {\n            throwError('The scale divisor option \\'scaleDivisor\\' is invalid ; it should be a positive number, preferably an integer, [' + options.scaleDivisor + '] given.');\n        }\n\n        if (!isNull(options.scaleDecimalPlaces) && !testPositiveInteger.test(options.scaleDecimalPlaces)) {\n            throwError('The scale number of decimals option \\'scaleDecimalPlaces\\' is invalid ; it should be a positive integer, [' + options.scaleDecimalPlaces + '] given.');\n        }\n\n        if (!isNull(options.scaleSymbol) && !isString(options.scaleSymbol)) {\n            throwError('The scale symbol option \\'scaleSymbol\\' is invalid ; it should be a string, [' + options.scaleSymbol + '] given.');\n        }\n\n        if (!isTrueOrFalseString(options.saveValueToSessionStorage) && !isBoolean(options.saveValueToSessionStorage)) {\n            throwError('The save to session storage option \\'saveValueToSessionStorage\\' is invalid ; it should be either \\'false\\' or \\'true\\', [' + options.saveValueToSessionStorage + '] given.');\n        }\n\n        if (!isInArray(options.onInvalidPaste, ['error', 'ignore', 'clamp', 'truncate', 'replace'])) {\n            throwError('The paste behavior option \\'onInvalidPaste\\' is invalid ; it should either be \\'error\\', \\'ignore\\', \\'clamp\\', \\'truncate\\' or \\'replace\\' (cf. documentation), [' + options.onInvalidPaste + '] given.');\n        }\n\n        if (!isInArray(options.roundingMethod, ['S', 'A', 's', 'a', 'B', 'U', 'D', 'C', 'F', 'N05', 'CHF', 'U05', 'D05'])) {\n            throwError('The rounding method option \\'roundingMethod\\' is invalid ; it should either be \\'S\\', \\'A\\', \\'s\\', \\'a\\', \\'B\\', \\'U\\', \\'D\\', \\'C\\', \\'F\\', \\'N05\\', \\'CHF\\', \\'U05\\' or \\'D05\\' (cf. documentation), [' + options.roundingMethod + '] given.');\n        }\n\n        if (!isTrueOrFalseString(options.allowDecimalPadding) && !isBoolean(options.allowDecimalPadding)) {\n            throwError('The control decimal padding option \\'allowDecimalPadding\\' is invalid ; it should be either \\'false\\' or \\'true\\', [' + options.allowDecimalPadding + '] given.');\n        }\n\n        if (!isNull(options.negativeBracketsTypeOnBlur) && !isInArray(options.negativeBracketsTypeOnBlur, ['(,)', '[,]', '<,>', '{,}'])) {\n            throwError('The brackets for negative values option \\'negativeBracketsTypeOnBlur\\' is invalid ; it should either be \\'(,)\\', \\'[,]\\', \\'<,>\\' or \\'{,}\\', [' + options.negativeBracketsTypeOnBlur + '] given.');\n        }\n\n        if (!isInArray(options.emptyInputBehavior, ['focus', 'press', 'always', 'zero'])) {\n            throwError('The display on empty string option \\'emptyInputBehavior\\' is invalid ; it should either be \\'focus\\', \\'press\\', \\'always\\' or \\'zero\\', [' + options.emptyInputBehavior + '] given.');\n        }\n\n        if (!isInArray(options.leadingZero, ['allow', 'deny', 'keep'])) {\n            throwError('The leading zero behavior option \\'leadingZero\\' is invalid ; it should either be \\'allow\\', \\'deny\\' or \\'keep\\', [' + options.leadingZero + '] given.');\n        }\n\n        if (!isTrueOrFalseString(options.formatOnPageLoad) && !isBoolean(options.formatOnPageLoad)) {\n            throwError('The format on initialization option \\'formatOnPageLoad\\' is invalid ; it should be either \\'false\\' or \\'true\\', [' + options.formatOnPageLoad + '] given.');\n        }\n\n        if (!isTrueOrFalseString(options.selectNumberOnly) && !isBoolean(options.selectNumberOnly)) {\n            throwError('The select number only option \\'selectNumberOnly\\' is invalid ; it should be either \\'false\\' or \\'true\\', [' + options.selectNumberOnly + '] given.');\n        }\n\n        if (!isNull(options.defaultValueOverride) && options.defaultValueOverride !== '' && !testFloatOrIntegerAndPossibleNegativeSign.test(options.defaultValueOverride)) {\n            throwError('The unformatted default value option \\'defaultValueOverride\\' is invalid ; it should be a string that represents a positive or negative number, [' + options.defaultValueOverride + '] given.');\n        }\n\n        if (!isTrueOrFalseString(options.unformatOnSubmit) && !isBoolean(options.unformatOnSubmit)) {\n            throwError('The remove formatting on submit option \\'unformatOnSubmit\\' is invalid ; it should be either \\'false\\' or \\'true\\', [' + options.unformatOnSubmit + '] given.');\n        }\n\n        if (!isNull(options.outputFormat) && !isInArray(options.outputFormat, ['string', 'number', '.', '-.', ',', '-,', '.-', ',-'])) {\n            throwError('The custom locale format option \\'outputFormat\\' is invalid ; it should either be null, \\'string\\', \\'number\\', \\'.\\', \\'-.\\', \\',\\', \\'-,\\', \\'.-\\' or \\',-\\', [' + options.outputFormat + '] given.');\n        }\n\n        if (!isTrueOrFalseString(options.failOnUnknownOption) && !isBoolean(options.failOnUnknownOption)) {\n            throwError('The debug option \\'failOnUnknownOption\\' is invalid ; it should be either \\'false\\' or \\'true\\', [' + options.failOnUnknownOption + '] given.');\n        }\n    };\n\n    $.fn.autoValidate = validate;\n\n    /**\n     * Return TRUE is the settings/options are valid, FALSE otherwise.\n     *\n     * @param {object} options\n     * @returns {boolean}\n     */\n    areSettingsValid = function areSettingsValid(options) {\n        var isValid = true;\n        try {\n            validate(options);\n        } catch (error) {\n            isValid = false;\n        }\n\n        return isValid;\n    };\n\n    /**\n     * Take an arabic number as a string and return a javascript number.\n     * By default, this function does not try to convert the arabic decimal and thousand separator characters.\n     * This returns `NaN` is the conversion is not possible.\n     * Based on http://stackoverflow.com/a/17025392/2834898\n     *\n     * @param {string} arabicNumbers\n     * @param {boolean} returnANumber If `true`, return a Number, otherwise return a String\n     * @param {boolean} parseDecimalCharacter\n     * @param {boolean} parseThousandSeparator\n     * @returns {string|number|NaN}\n     */\n    function arabicToLatinNumbers(arabicNumbers) {\n        var returnANumber = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n        var parseDecimalCharacter = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n        var parseThousandSeparator = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n\n        var result = arabicNumbers.toString();\n        if (result === '') {\n            return arabicNumbers;\n        }\n\n        if (parseDecimalCharacter) {\n            result = result.replace(/٫/, '.'); // Decimal character\n        }\n\n        if (parseThousandSeparator) {\n            result = result.replace(/٬/g, ''); // Thousand separator\n        }\n\n        // Replace the numbers only\n        result = result.replace(/[٠١٢٣٤٥٦٧٨٩]/g, function (d) {\n            return d.charCodeAt(0) - 1632;\n        }) // Arabic numbers\n        .replace(/[۰۱۲۳۴۵۶۷۸۹]/g, function (d) {\n            return d.charCodeAt(0) - 1776;\n        }); // Persian numbers\n\n        // `NaN` has precedence over the string `'NaN'`\n        var resultAsNumber = Number(result);\n        if (isNaN(resultAsNumber)) {\n            return resultAsNumber;\n        }\n\n        if (returnANumber) {\n            result = resultAsNumber;\n        }\n\n        return result;\n    }\n\n    /**\n     * Create a custom event and immediately sent it from the given element.\n     * By default, if no element is given, the event is thrown from `document`.\n     *\n     * @param {string} eventName\n     * @param {Element} element\n     * @param {object} detail\n     */\n    function triggerEvent(eventName) {\n        var element = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : document;\n        var detail = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n\n        var event = void 0;\n        if (window.CustomEvent) {\n            event = new CustomEvent(eventName, { detail: detail, bubbles: false, cancelable: false }); // This is not supported by default by IE ; We use the polyfill for IE9 and later.\n        } else {\n            event = document.createEvent('CustomEvent');\n            event.initCustomEvent(eventName, true, true, { detail: detail });\n        }\n\n        element.dispatchEvent(event);\n    }\n\n    /**\n     * Polyfill from https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent/CustomEvent for obsolete browsers (IE)\n     */\n    (function () {\n        if (typeof window.CustomEvent === 'function') {\n            return false;\n        }\n\n        function CustomEvent(event, params) {\n            params = params || { bubbles: false, cancelable: false, detail: void 0 };\n            var evt = document.createEvent('CustomEvent');\n            evt.initCustomEvent(event, params.bubbles, params.cancelable, params.detail);\n            return evt;\n        }\n\n        CustomEvent.prototype = window.Event.prototype;\n        window.CustomEvent = CustomEvent;\n    })();\n});\n\n/**\n * This exports the interface for the autoNumeric object\n */\nexports.default = {\n    format: autoFormat,\n    unFormat: autoUnFormat,\n    getDefaultConfig: getDefaultConfig,\n    getLanguages: getLanguages,\n    validate: validate, // an.validate(options) : throws if necessary\n    areSettingsValid: areSettingsValid };\n}.call(window));//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvYXV0b051bWVyaWMuanM/YTRlZSJdLCJuYW1lcyI6WyJhdXRvRm9ybWF0IiwiYXV0b1VuRm9ybWF0IiwiZ2V0RGVmYXVsdENvbmZpZyIsImdldExhbmd1YWdlcyIsInZhbGlkYXRlIiwiYXJlU2V0dGluZ3NWYWxpZCIsImFsbG93ZWRUYWdMaXN0IiwiZGVmYXVsdFNldHRpbmdzIiwiZGlnaXRHcm91cFNlcGFyYXRvciIsIm5vU2VwYXJhdG9yT25Gb2N1cyIsImRpZ2l0YWxHcm91cFNwYWNpbmciLCJkZWNpbWFsQ2hhcmFjdGVyIiwiZGVjaW1hbENoYXJhY3RlckFsdGVybmF0aXZlIiwiY3VycmVuY3lTeW1ib2wiLCJjdXJyZW5jeVN5bWJvbFBsYWNlbWVudCIsIm5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50Iiwic2hvd1Bvc2l0aXZlU2lnbiIsInN1ZmZpeFRleHQiLCJvdmVycmlkZU1pbk1heExpbWl0cyIsIm1heGltdW1WYWx1ZSIsIm1pbmltdW1WYWx1ZSIsImRlY2ltYWxQbGFjZXNPdmVycmlkZSIsImRlY2ltYWxQbGFjZXNTaG93bk9uRm9jdXMiLCJzY2FsZURpdmlzb3IiLCJzY2FsZURlY2ltYWxQbGFjZXMiLCJzY2FsZVN5bWJvbCIsInNhdmVWYWx1ZVRvU2Vzc2lvblN0b3JhZ2UiLCJvbkludmFsaWRQYXN0ZSIsInJvdW5kaW5nTWV0aG9kIiwiYWxsb3dEZWNpbWFsUGFkZGluZyIsIm5lZ2F0aXZlQnJhY2tldHNUeXBlT25CbHVyIiwiZW1wdHlJbnB1dEJlaGF2aW9yIiwibGVhZGluZ1plcm8iLCJmb3JtYXRPblBhZ2VMb2FkIiwic2VsZWN0TnVtYmVyT25seSIsImRlZmF1bHRWYWx1ZU92ZXJyaWRlIiwidW5mb3JtYXRPblN1Ym1pdCIsIm91dHB1dEZvcm1hdCIsInNob3dXYXJuaW5ncyIsImZhaWxPblVua25vd25PcHRpb24iLCJrZXlDb2RlIiwiQmFja3NwYWNlIiwiVGFiIiwiRW50ZXIiLCJTaGlmdCIsIkN0cmwiLCJBbHQiLCJQYXVzZUJyZWFrIiwiQ2Fwc0xvY2siLCJFc2MiLCJTcGFjZSIsIlBhZ2VVcCIsIlBhZ2VEb3duIiwiRW5kIiwiSG9tZSIsIkxlZnRBcnJvdyIsIlVwQXJyb3ciLCJSaWdodEFycm93IiwiRG93bkFycm93IiwiSW5zZXJ0IiwiRGVsZXRlIiwibnVtMCIsIm51bTEiLCJudW0yIiwibnVtMyIsIm51bTQiLCJudW01IiwibnVtNiIsIm51bTciLCJudW04IiwibnVtOSIsImEiLCJiIiwiYyIsImQiLCJlIiwiZiIsImciLCJoIiwiaSIsImoiLCJrIiwibCIsIm0iLCJuIiwibyIsInAiLCJxIiwiciIsInMiLCJ0IiwidSIsInYiLCJ3IiwieCIsInkiLCJ6IiwiV2luZG93cyIsIlJpZ2h0Q2xpY2siLCJudW1wYWQwIiwibnVtcGFkMSIsIm51bXBhZDIiLCJudW1wYWQzIiwibnVtcGFkNCIsIm51bXBhZDUiLCJudW1wYWQ2IiwibnVtcGFkNyIsIm51bXBhZDgiLCJudW1wYWQ5IiwiTXVsdGlwbHlOdW1wYWQiLCJQbHVzTnVtcGFkIiwiTWludXNOdW1wYWQiLCJEb3ROdW1wYWQiLCJTbGFzaE51bXBhZCIsIkYxIiwiRjIiLCJGMyIsIkY0IiwiRjUiLCJGNiIsIkY3IiwiRjgiLCJGOSIsIkYxMCIsIkYxMSIsIkYxMiIsIk51bUxvY2siLCJTY3JvbGxMb2NrIiwiTXlDb21wdXRlciIsIk15Q2FsY3VsYXRvciIsIlNlbWljb2xvbiIsIkVxdWFsIiwiQ29tbWEiLCJIeXBoZW4iLCJEb3QiLCJTbGFzaCIsIkJhY2txdW90ZSIsIkxlZnRCcmFja2V0IiwiQmFja3NsYXNoIiwiUmlnaHRCcmFja2V0IiwiUXVvdGUiLCJDb21tYW5kIiwia2V5TmFtZSIsIlVuaWRlbnRpZmllZCIsIkFsdEdyIiwiRm4iLCJGbkxvY2siLCJIeXBlciIsIk1ldGEiLCJTdXBlciIsIlN5bWJvbCIsIlN5bWJvbExvY2siLCJDbGVhciIsIkNvcHkiLCJDclNlbCIsIkN1dCIsIkVyYXNlRW9mIiwiRXhTZWwiLCJQYXN0ZSIsIlJlZG8iLCJVbmRvIiwiQWNjZXB0IiwiQWdhaW4iLCJBdHRuIiwiQ2FuY2VsIiwiQ29udGV4dE1lbnUiLCJFeGVjdXRlIiwiRmluZCIsIkZpbmlzaCIsIkhlbHAiLCJQYXVzZSIsIlBsYXkiLCJQcm9wcyIsIlNlbGVjdCIsIlpvb21JbiIsIlpvb21PdXQiLCJCcmlnaHRuZXNzRG93biIsIkJyaWdodG5lc3NVcCIsIkVqZWN0IiwiTG9nT2ZmIiwiUG93ZXIiLCJQb3dlck9mZiIsIlByaW50U2NyZWVuIiwiSGliZXJuYXRlIiwiU3RhbmRieSIsIldha2VVcCIsIkNvbXBvc2UiLCJEZWFkIiwiUHJpbnQiLCJNaW51cyIsIlBsdXMiLCJOdW1wYWREb3QiLCJOdW1wYWREb3RBbHQiLCJOdW1wYWRNdWx0aXBseSIsIk51bXBhZFBsdXMiLCJOdW1wYWRNaW51cyIsIk51bXBhZFNsYXNoIiwiTnVtcGFkRG90T2Jzb2xldGVCcm93c2VycyIsIk51bXBhZE11bHRpcGx5T2Jzb2xldGVCcm93c2VycyIsIk51bXBhZFBsdXNPYnNvbGV0ZUJyb3dzZXJzIiwiTnVtcGFkTWludXNPYnNvbGV0ZUJyb3dzZXJzIiwiTnVtcGFkU2xhc2hPYnNvbGV0ZUJyb3dzZXJzIiwiZGVmYXVsdE1pbmltdW1WYWx1ZSIsImRlZmF1bHRNYXhpbXVtVmFsdWUiLCJkZWZhdWx0Um91bmRpbmdNZXRob2QiLCJkZWZhdWx0TGVhZGluZ1plcm8iLCJkZWZhdWx0U2VsZWN0TnVtYmVyT25seSIsImxhbmd1YWdlT3B0aW9uIiwiRnJlbmNoIiwiTm9ydGhBbWVyaWNhbiIsIkJyaXRpc2giLCJTd2lzcyIsIkphcGFuZXNlIiwiU3BhbmlzaCIsIkNoaW5lc2UiLCJmYWN0b3J5IiwiZGVmaW5lIiwibW9kdWxlIiwiZXhwb3J0cyIsInJlcXVpcmUiLCJ3aW5kb3ciLCJqUXVlcnkiLCJpc051bGwiLCJ2YWx1ZSIsImlzVW5kZWZpbmVkIiwiaXNVbmRlZmluZWRPck51bGxPckVtcHR5IiwiaXNTdHJpbmciLCJzdHIiLCJTdHJpbmciLCJpc0Jvb2xlYW4iLCJpc1RydWVPckZhbHNlU3RyaW5nIiwibG93ZXJjYXNlVmFsdWUiLCJ0b0xvd2VyQ2FzZSIsImlzT2JqZWN0IiwicmVmZXJlbmNlIiwiQXJyYXkiLCJpc0FycmF5IiwiaXNFbXB0eU9iaiIsIm9iaiIsInByb3AiLCJoYXNPd25Qcm9wZXJ0eSIsImlzTnVtYmVyIiwiaXNOYU4iLCJwYXJzZUZsb2F0IiwiaXNGaW5pdGUiLCJpc0ludCIsInBhcnNlSW50IiwicHJlcGFyZVBhc3RlZFRleHQiLCJ0ZXh0IiwiaG9sZGVyIiwic3RyaXBBbGxOb25OdW1iZXJDaGFyYWN0ZXJzIiwic2V0dGluZ3NDbG9uZSIsInJlcGxhY2UiLCJjb250YWlucyIsIm5lZWRsZSIsImluZGV4T2YiLCJpc0luQXJyYXkiLCJhcnJheSIsImFyciIsIk9iamVjdCIsInByb3RvdHlwZSIsInRvU3RyaW5nIiwiY2FsbCIsIkVycm9yIiwiZGVjaW1hbFBsYWNlcyIsInNwbGl0IiwiZGVjaW1hbFBhcnQiLCJsZW5ndGgiLCJrZXlDb2RlTnVtYmVyIiwiZXZlbnQiLCJ3aGljaCIsImNoYXJhY3RlciIsImtleSIsImZyb21DaGFyQ29kZSIsInJlc3VsdCIsImNoZWNrSWZJblJhbmdlIiwicGFyc2VkTWluVmFsdWUiLCJwYXJzZWRNYXhWYWx1ZSIsInBhcnNlZFZhbHVlIiwicGFyc2VTdHIiLCJ0ZXN0TWluTWF4IiwiaXNOZWdhdGl2ZSIsIm51bWVyaWNTdHJpbmciLCJjaGVja0V2ZXJ5d2hlcmUiLCJpc05lZ2F0aXZlU3RyaWN0IiwiY2hhckF0IiwiaXNaZXJvT3JIYXNOb1ZhbHVlIiwidGVzdCIsInNldFJhd05lZ2F0aXZlU2lnbiIsInJlcGxhY2VDaGFyQXQiLCJzdHJpbmciLCJpbmRleCIsIm5ld0NoYXJhY3RlciIsInN1YnN0ciIsImNsYW1wVG9SYW5nZUxpbWl0cyIsInNldHRpbmdzIiwiTWF0aCIsIm1heCIsIm1pbiIsImNvdW50TnVtYmVyQ2hhcmFjdGVyc09uVGhlQ2FyZXRMZWZ0U2lkZSIsImZvcm1hdHRlZE51bWJlclN0cmluZyIsImNhcmV0UG9zaXRpb24iLCJudW1iZXJEb3RPck5lZ2F0aXZlU2lnbiIsIlJlZ0V4cCIsIm51bWJlckRvdEFuZE5lZ2F0aXZlU2lnbkNvdW50IiwiZmluZENhcmV0UG9zaXRpb25JbkZvcm1hdHRlZE51bWJlciIsInJhd051bWJlclN0cmluZyIsImNhcmV0UG9zaXRpb25JblJhd1ZhbHVlIiwiZm9ybWF0dGVkTnVtYmVyU3RyaW5nU2l6ZSIsInJhd051bWJlclN0cmluZ1NpemUiLCJmb3JtYXR0ZWROdW1iZXJTdHJpbmdJbmRleCIsInJhd051bWJlclN0cmluZ0luZGV4IiwiY291bnRDaGFySW5UZXh0IiwiY2hhckNvdW50ZXIiLCJjb252ZXJ0Q2hhcmFjdGVyQ291bnRUb0luZGV4UG9zaXRpb24iLCJjaGFyYWN0ZXJDb3VudCIsImdldEVsZW1lbnRTZWxlY3Rpb24iLCJ0aGF0IiwicG9zaXRpb24iLCJzZWxlY3Rpb25TdGFydCIsImZvY3VzIiwic2VsZWN0IiwiZG9jdW1lbnQiLCJzZWxlY3Rpb24iLCJjcmVhdGVSYW5nZSIsIm1vdmVTdGFydCIsImVuZCIsInN0YXJ0Iiwic2VsZWN0aW9uRW5kIiwic2V0RWxlbWVudFNlbGVjdGlvbiIsInJhbmdlIiwiY3JlYXRlVGV4dFJhbmdlIiwiY29sbGFwc2UiLCJtb3ZlRW5kIiwidGhyb3dFcnJvciIsIm1lc3NhZ2UiLCJ3YXJuaW5nIiwic2hvd1dhcm5pbmciLCJjb25zb2xlIiwid2FybiIsInJ1bkNhbGxiYWNrc0ZvdW5kSW5UaGVTZXR0aW5nc09iamVjdCIsIiR0aGlzIiwiJCIsImVhY2giLCJ2YWwiLCJhdXRvTnVtZXJpYyIsIm1heGltdW1WTWluQW5kVk1heERlY2ltYWxMZW5ndGgiLCJsZWZ0T3JBbGwiLCJza2lwRmlyc3RBdXRvU3RyaXAiLCJ0cmFpbGluZ05lZ2F0aXZlIiwic2tpcExhc3RBdXRvU3RyaXAiLCJhbGxvd2VkQXV0b1N0cmlwIiwibWF0Y2giLCJudW1SZWdBdXRvU3RyaXAiLCJqb2luIiwiblNpZ24iLCJpbnRlZ2VyUGFydCIsIm1vZGlmaWVkSW50ZWdlclBhcnQiLCJuZWdhdGl2ZVNpZ25DaGFyYWN0ZXIiLCJtSW50UG9zIiwic2xpY2UiLCJtSW50TmVnIiwiaGFzRm9jdXMiLCJzdHJpcFJlZyIsInRvZ2dsZU5lZ2F0aXZlQnJhY2tldCIsImZpcnN0QnJhY2tldCIsImxhc3RCcmFja2V0IiwiY29udmVydFRvTnVtZXJpY1N0cmluZyIsImxhc3RJbmRleE9mIiwidGVtcCIsImFyYWJpY1RvTGF0aW5OdW1iZXJzIiwidG9Mb2NhbGUiLCJsb2NhbGUiLCJOdW1iZXIiLCJtb2RpZnlOZWdhdGl2ZVNpZ25BbmREZWNpbWFsQ2hhcmFjdGVyRm9yUmF3VmFsdWUiLCJtb2RpZnlOZWdhdGl2ZVNpZ25BbmREZWNpbWFsQ2hhcmFjdGVyRm9yRm9ybWF0dGVkVmFsdWUiLCJjaGVja0VtcHR5IiwiaW5wdXRWYWx1ZSIsInNpZ25PbkVtcHR5IiwiYWRkR3JvdXBTZXBhcmF0b3JzIiwic3RyaXAiLCJlbXB0eSIsImlzVmFsdWVOZWdhdGl2ZSIsImlzWmVybyIsImRpZ2l0YWxHcm91cCIsInN1YnN0cmluZyIsInBvc2l0aXZlU2lnbkNoYXJhY3RlciIsInJhd1ZhbHVlIiwidHJ1bmNhdGVaZXJvcyIsInJvdW5kZWRJbnB1dFZhbHVlIiwidGVtcG9yYXJ5RGVjaW1hbFBsYWNlc092ZXJyaWRlIiwicmVnZXgiLCJyb3VuZFZhbHVlIiwicm91bmQiLCJjZWlsIiwiZmxvb3IiLCJpdlJvdW5kZWQiLCJkUG9zIiwiaW5wdXRWYWx1ZUhhc0FEb3QiLCJ2ZFBvcyIsImNEZWMiLCJ6ZXJvcyIsInJMZW5ndGgiLCJ0Um91bmQiLCJvZGQiLCJpdkFycmF5IiwidHJ1bmNhdGVEZWNpbWFsIiwiaXNQYXN0ZSIsIm1vZGlmaWVkRGVjaW1hbFBhcnQiLCJuTCIsInNlYXJjaCIsInhjIiwieWMiLCJ4TmVnIiwiY2hlY2tJZkluUmFuZ2VXaXRoT3ZlcnJpZGVPcHRpb24iLCJtaW5QYXJzZSIsIm1heFBhcnNlIiwidmFsUGFyc2UiLCJnZXRDdXJyZW50RWxlbWVudCIsImVsZW1lbnQiLCJnZXRBdXRvTnVtZXJpY0hvbGRlciIsInVwZGF0ZSIsImRhdGEiLCJBdXRvTnVtZXJpY0hvbGRlciIsImdldCIsImtlZXBBbk9yaWdpbmFsU2V0dGluZ3NDb3B5Iiwib0RlYyIsIm9QYWQiLCJvQnJhY2tldCIsIm9TZXAiLCJvU2lnbiIsIm9TdWZmaXgiLCJyZWFkQ29va2llIiwibmFtZSIsIm5hbWVFUSIsImNhIiwiY29va2llIiwic3RvcmFnZVRlc3QiLCJtb2QiLCJzZXNzaW9uU3RvcmFnZSIsInNldEl0ZW0iLCJyZW1vdmVJdGVtIiwiY2xlYW5MZWFkaW5nVHJhaWxpbmdaZXJvcyIsInRyaW1QYWRkZWRaZXJvc0Zyb21EZWNpbWFsUGxhY2VzIiwidHJpbW1lZERlY2ltYWxQYXJ0Iiwic2F2ZVZhbHVlVG9QZXJzaXN0ZW50U3RvcmFnZSIsImFjdGlvbiIsInN0b3JlZE5hbWUiLCJkZWNvZGVVUklDb21wb25lbnQiLCJpZCIsImRhdGUiLCJleHBpcmVzIiwiRGF0ZSIsInNldFRpbWUiLCJnZXRUaW1lIiwidG9VVENTdHJpbmciLCJnZXRJdGVtIiwiJHRoYXQiLCJmb3JtYXR0ZWQiLCJwcm9jZXNzZWQiLCJldmVudEtleUNvZGUiLCJzZXRSZWFsIiwicG9zIiwiX3NldFNlbGVjdGlvbiIsImxlZnQiLCJyaWdodCIsIl9nZXRMZWZ0QW5kUmlnaHRQYXJ0QXJvdW5kVGhlU2VsZWN0aW9uIiwic3RyaXBaZXJvcyIsIm5ld1ZhbHVlIiwiYU5lZ1JlZ0F1dG9TdHJpcCIsInBhcnRzIiwiX25vcm1hbGl6ZVBhcnRzIiwibWluVGVzdCIsIm1heFRlc3QiLCJ0ZXN0VmFsdWUiLCJfc2V0Q2FyZXRQb3NpdGlvbiIsInRyaWdnZXIiLCJjdXJyZW5jeVN5bWJvbExlbiIsImhhc05lZyIsInZhbHVlTGVuIiwic2lnblBvc2l0aW9uIiwiX2dldFNpZ25Qb3NpdGlvbiIsInZhbHVlUGFydHNCZWZvcmVQYXN0ZSIsIm9sZFBhcnRzIiwibW9kaWZpZWRMZWZ0UGFydCIsIl9zZXRWYWx1ZVBhcnRzIiwiY3RybEtleSIsIm1ldGFLZXkiLCJ0eXBlIiwic2hpZnRLZXkiLCJfY2hlY2tQYXN0ZSIsInByZXZlbnREZWZhdWx0IiwibmVnTGVuIiwic3VmZml4VGV4dExlbiIsIl9leHBhbmRTZWxlY3Rpb25PblNpZ24iLCJjYXJldEZpeCIsIl9nZXRVbmZvcm1hdHRlZExlZnRBbmRSaWdodFBhcnRBcm91bmRUaGVTZWxlY3Rpb24iLCJ0aHJvd0lucHV0IiwiX3Byb2Nlc3NDaGFyYWN0ZXJEZWxldGlvbklmVHJhaWxpbmdOZWdhdGl2ZVNpZ24iLCJldmVudENoYXJhY3RlciIsImV2ZW50TnVtYmVyIiwibGVmdExlbmd0aCIsInN1YlBhcnRzIiwibGVmdEFyIiwic2hpZnQiLCJwdXNoIiwic2lnblBhcnRzIiwiZXNjYXBlQ2hyIiwiZXNjYXBlZFBhcnRzIiwibWluaVBhcnRzIiwibGVmdFJlZyIsIm5ld0xlZnQiLCJpbnB1dCIsIl9nZXRTdHJpbmdPckFycmF5IiwiZ2V0QXJyYXlCZWhhdmlvciIsImZvcm1JbmRleCIsImFsbEZvcm1FbGVtZW50cyIsImFpSW5kZXgiLCJzY0luZGV4IiwiclN1Ym1pdHRlclR5cGVzIiwiclN1Ym1pdHRhYmxlIiwickNoZWNrYWJsZVR5cGUiLCJyTm9uQXV0b051bWVyaWNUeXBlcyIsImNvdW50IiwiZmllbGQiLCJsb2NhbE5hbWUiLCJkaXNhYmxlZCIsImNoZWNrZWQiLCJmb3JtRmllbGRzIiwic2VyaWFsaXplQXJyYXkiLCJzY0VsZW1lbnQiLCJ0ZXN0SW5wdXQiLCJzZXJpYWxpemUiLCJmb3JtUGFydHMiLCJpbnB1dE5hbWUiLCJtb2RpZmllZElucHV0VmFsdWUiLCJvbkZvY3VzSW5BbmRNb3VzZUVudGVyIiwiaXMiLCJ0YXJnZXQiLCJyb3VuZGVkVmFsdWUiLCJ2YWx1ZU9uRm9jdXMiLCJsYXN0VmFsIiwib25FbXB0eSIsIm9uS2V5ZG93biIsIl91cGRhdGVBdXRvTnVtZXJpY0hvbGRlckV2ZW50S2V5Y29kZSIsImluaXRpYWxWYWx1ZU9uS2V5ZG93biIsInJlYWRPbmx5IiwidHJpZ2dlckV2ZW50IiwiX3VwZGF0ZUF1dG9OdW1lcmljSG9sZGVyUHJvcGVydGllcyIsIl9za2lwQWx3YXlzIiwiX3Byb2Nlc3NDaGFyYWN0ZXJEZWxldGlvbiIsIl9mb3JtYXRWYWx1ZSIsIm9uS2V5cHJlc3MiLCJpc0NoYXJhY3Rlckluc2VydGlvbkFsbG93ZWQiLCJfcHJvY2Vzc0NoYXJhY3Rlckluc2VydGlvbiIsIm9uS2V5dXAiLCJza2lwIiwib25Gb2N1c091dEFuZE1vdXNlTGVhdmUiLCJvcmlnVmFsdWUiLCJncm91cGVkVmFsdWUiLCJjaGFuZ2UiLCJvblBhc3RlIiwicmF3UGFzdGVkVGV4dCIsImNsaXBib2FyZERhdGEiLCJnZXREYXRhIiwiaW5pdGlhbEZvcm1hdHRlZFZhbHVlIiwic2VsZWN0aW9uU2l6ZSIsImlzQWxsSW5wdXRUZXh0U2VsZWN0ZWQiLCJpc1Bhc3RlTmVnYXRpdmUiLCJ1bnRyYW5zbGF0ZWRQYXN0ZWRUZXh0IiwicGFzdGVkVGV4dCIsImNhcmV0UG9zaXRpb25PbkluaXRpYWxUZXh0QWZ0ZXJQYXN0aW5nIiwiaW5pdGlhbFVuZm9ybWF0dGVkTnVtYmVyIiwiaXNJbml0aWFsVmFsdWVOZWdhdGl2ZSIsImlzUGFzdGVOZWdhdGl2ZUFuZEluaXRpYWxWYWx1ZUlzUG9zaXRpdmUiLCJsZWZ0UGFydENvbnRhaW5lZEFEb3QiLCJsZWZ0Rm9ybWF0dGVkUGFydCIsInJpZ2h0Rm9ybWF0dGVkUGFydCIsImxlZnRQYXJ0IiwicmlnaHRQYXJ0IiwibGFzdEdvb2RLbm93blJlc3VsdCIsInBhc3RlZFRleHRJbmRleCIsImxhc3RHb29kS25vd25SZXN1bHRJbmRleCIsImxhc3RHb29kS25vd25SZXN1bHRTaXplIiwibGVmdEZvcm1hdHRlZFBhcnQyIiwicmlnaHRGb3JtYXR0ZWRQYXJ0MiIsImluZGV4V2hlcmVQYXN0ZWRUZXh0SGFzQmVlbkluc2VydGVkIiwiaW5kZXhTZWxlY3Rpb25FbmRJblJhd1ZhbHVlIiwic2VsZWN0ZWRUZXh0IiwidmFsdWVIYXNCZWVuU2V0IiwidmFsdWVIYXNCZWVuQ2xhbXBlZCIsImVycm9yIiwiY2xhbXBlZFZhbHVlIiwiY2FyZXRQb3NpdGlvbkluRm9ybWF0dGVkTnVtYmVyIiwib25CbHVyIiwib25TdWJtaXQiLCJjbG9zZXN0Iiwib24iLCIkc2V0dGluZ3MiLCJnZXRJbnB1dElmU3VwcG9ydGVkVGFnQW5kVHlwZSIsIiRpbnB1dCIsImN1cnJlbnRFbGVtZW50VGFnIiwiZm9ybWF0RGVmYXVsdFZhbHVlT25QYWdlTG9hZCIsInNldFZhbHVlIiwiY3VycmVudFZhbHVlIiwidW5Mb2NhbGl6ZWRDdXJyZW50VmFsdWUiLCJ0b051bWVyaWNWYWx1ZSIsImF0dHIiLCJJbmZpbml0eSIsInRvU3RyaXAiLCJ0YWdMaXN0IiwiY29ycmVjdE5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50T3B0aW9uIiwiY2FsY3VsYXRlVk1pbkFuZFZNYXhJbnRlZ2VyU2l6ZXMiLCJtYXhpbXVtVmFsdWVJbnRlZ2VyUGFydCIsIm1pbmltdW1WYWx1ZUludGVnZXJQYXJ0IiwiY29ycmVjdERlY2ltYWxQbGFjZXNPdmVycmlkZU9wdGlvbiIsInNldHNBbHRlcm5hdGl2ZURlY2ltYWxTZXBhcmF0b3JDaGFyYWN0ZXIiLCJjYWNoZXNVc3VhbFJlZ3VsYXJFeHByZXNzaW9ucyIsImFsbE51bWJlcnNSZWciLCJub0FsbE51bWJlcnNSZWciLCJhTmVnUmVnIiwibmVnYXRpdmVTaWduUmVnUGFydCIsImFsbG93ZWQiLCJ0cmFuc2Zvcm1PcHRpb25zVmFsdWVzVG9EZWZhdWx0VHlwZXMiLCJjb252ZXJ0T2xkT3B0aW9uc1RvTmV3T25lcyIsIm9wdGlvbnMiLCJvbGRPcHRpb25zQ29udmVydGVyIiwiYVNlcCIsIm5TZXAiLCJkR3JvdXAiLCJhRGVjIiwiYWx0RGVjIiwiYVNpZ24iLCJwU2lnbiIsInBOZWciLCJhU3VmZml4Iiwib0xpbWl0cyIsInZNYXgiLCJ2TWluIiwibURlYyIsImVEZWMiLCJzY2FsZURlY2ltYWwiLCJhU3RvciIsIm1Sb3VuZCIsImFQYWQiLCJuQnJhY2tldCIsIndFbXB0eSIsImxaZXJvIiwiYUZvcm0iLCJzTnVtYmVyIiwiYW5EZWZhdWx0IiwidW5TZXRPblN1Ym1pdCIsIm91dHB1dFR5cGUiLCJkZWJ1ZyIsInJ1bk9uY2UiLCJvcHRpb24iLCJnZXRJbml0aWFsU2V0dGluZ3MiLCJleHRlbmQiLCJ0YWdEYXRhIiwiTmFOIiwibWV0aG9kcyIsImluaXQiLCJhZGRFdmVudExpc3RlbmVyIiwiZGVzdHJveSIsInJlbW92ZURhdGEiLCJvZmYiLCJ3aXBlIiwic2V0IiwiaGFzQmVlblJvdW5kZWQiLCJ0ZW1wRGVjaW1hbCIsIm9uT2ZmIiwiYXR0ZW1wdGVkVmFsdWUiLCJ1blNldCIsInJlU2V0IiwiZXEiLCJnZXRMb2NhbGl6ZWQiLCJnZXROdW1iZXIiLCJnZXRGb3JtYXR0ZWQiLCJnZXRTdHJpbmciLCJnZXRBcnJheSIsImdldFNldHRpbmdzIiwiZm4iLCJtZXRob2QiLCJhcmdzIiwiYXBwbHkiLCJkZWZhdWx0cyIsImxhbmciLCJ2YWx1ZVN0cmluZyIsImF1dG9TdHJpcCIsImF1dG9VbmZvcm1hdCIsInVzZXJPcHRpb25zIiwic2hvdWxkRXh0ZW5kRGVmYXVsdE9wdGlvbnMiLCJ0ZXN0UG9zaXRpdmVJbnRlZ2VyIiwidGVzdE51bWVyaWNhbENoYXJhY3RlcnMiLCJ0ZXN0RmxvYXRPckludGVnZXJBbmRQb3NzaWJsZU5lZ2F0aXZlU2lnbiIsInRlc3RQb3NpdGl2ZUZsb2F0T3JJbnRlZ2VyIiwidk1pbkFuZFZNYXhNYXhpbXVtRGVjaW1hbFBsYWNlcyIsImF1dG9WYWxpZGF0ZSIsImlzVmFsaWQiLCJhcmFiaWNOdW1iZXJzIiwicmV0dXJuQU51bWJlciIsInBhcnNlRGVjaW1hbENoYXJhY3RlciIsInBhcnNlVGhvdXNhbmRTZXBhcmF0b3IiLCJjaGFyQ29kZUF0IiwicmVzdWx0QXNOdW1iZXIiLCJldmVudE5hbWUiLCJkZXRhaWwiLCJDdXN0b21FdmVudCIsImJ1YmJsZXMiLCJjYW5jZWxhYmxlIiwiY3JlYXRlRXZlbnQiLCJpbml0Q3VzdG9tRXZlbnQiLCJkaXNwYXRj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O0FBQ0g7O0FBRUQvUixnQkFBUXFTLGFBQVIsQ0FBc0IzYixLQUF0QjtBQUNIOztBQUVEOzs7QUFHQSxLQUFDLFlBQVc7QUFDUixZQUFJLE9BQU9qRCxPQUFPdWUsV0FBZCxLQUE4QixVQUFsQyxFQUE4QztBQUMxQyxtQkFBTyxLQUFQO0FBQ0g7O0FBRUQsaUJBQVNBLFdBQVQsQ0FBcUJ0YixLQUFyQixFQUE0QjRiLE1BQTVCLEVBQW9DO0FBQ2hDQSxxQkFBU0EsVUFBVSxFQUFFTCxTQUFTLEtBQVgsRUFBa0JDLFlBQVksS0FBOUIsRUFBcUNILFFBQVEsS0FBSyxDQUFsRCxFQUFuQjtBQUNBLGdCQUFNUSxNQUFNeFksU0FBU29ZLFdBQVQsQ0FBcUIsYUFBckIsQ0FBWjtBQUNBSSxnQkFBSUgsZUFBSixDQUFvQjFiLEtBQXBCLEVBQTJCNGIsT0FBT0wsT0FBbEMsRUFBMkNLLE9BQU9KLFVBQWxELEVBQThESSxPQUFPUCxNQUFyRTtBQUNBLG1CQUFPUSxHQUFQO0FBQ0g7O0FBRURQLG9CQUFZL2IsU0FBWixHQUF3QnhDLE9BQU8rZSxLQUFQLENBQWF2YyxTQUFyQztBQUNBeEMsZUFBT3VlLFdBQVAsR0FBcUJBLFdBQXJCO0FBQ0gsS0FkRDtBQWVILENBaC9JQSxDQUFEOztBQWsvSUE7OztrQkFHZTtBQUNYUyxZQUFVNXNCLFVBREM7QUFFWDZzQixjQUFVNXNCLFlBRkM7QUFHWEMsc0NBSFc7QUFJWEMsOEJBSlc7QUFLWEMsc0JBTFcsRUFLRDtBQUNWQyxzQ0FOVyxFIiwiZmlsZSI6IjAuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqICAgICAgICAgICAgICAgYXV0b051bWVyaWMuanNcbiAqXG4gKiBAdmVyc2lvbiAgICAgIDIuMC45XG4gKiBAZGF0ZSAgICAgICAgIDIwMTctMDItMjggVVRDIDE0OjAwXG4gKlxuICogQGF1dGhvciAgICAgICBCb2IgS25vdGhlXG4gKiBAY29udHJpYnV0b3JzIEFsZXhhbmRyZSBCb25uZWF1LCBTb2tvbG92IFl1cmEgYW5kIG90aGVyIEdpdGh1YiB1c2VycyxcbiAqICAgICAgICAgICAgICAgY2YuIEFVVEhPUlMubWQuXG4gKiBAY29weXJpZ2h0ICAgIDIwMDkgUm9iZXJ0IEouIEtub3RoZSBodHRwOi8vd3d3LmRlY29ycGxhbml0LmNvbS9wbHVnaW4vXG4gKiBAc2luY2UgICAgICAgIDIwMDktMDgtMDlcbiAqXG4gKiBAc3VtbWFyeSAgICAgIGF1dG9OdW1lcmljIGlzIGEgbGlicmFyeSB0aGF0IHByb3ZpZGVzIGxpdmUgYXMteW91LXR5cGVcbiAqICAgICAgICAgICAgICAgZm9ybWF0dGluZyBmb3IgaW50ZXJuYXRpb25hbCBudW1iZXJzIGFuZCBjdXJyZW5jaWVzLlxuICpcbiAqICAgICAgICAgICAgICAgTm90ZSA6IFNvbWUgZnVuY3Rpb25zIGFyZSBib3Jyb3dlZCBmcm9tIGJpZy5qc1xuICogQGxpbmsgICAgICAgICBodHRwczovL2dpdGh1Yi5jb20vTWlrZU1jbC9iaWcuanMvXG4gKlxuICogUGxlYXNlIHJlcG9ydCBhbnkgYnVncyB0byBodHRwczovL2dpdGh1Yi5jb20vQm9iS25vdGhlL2F1dG9OdW1lcmljXG4gKlxuICogQGxpY2Vuc2UgICAgICBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2VcbiAqIEBsaW5rICAgICAgICAgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvblxuICogb2J0YWluaW5nIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb25cbiAqIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dFxuICogcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsXG4gKiBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWIgbGljZW5zZSwgYW5kL29yIHNlbGxcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZVxuICogU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmdcbiAqIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmVcbiAqIGluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsXG4gKiBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVNcbiAqIE9GIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EXG4gKiBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVFxuICogSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksXG4gKiBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkdcbiAqIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1JcbiAqIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cbiAqL1xuXG5cbi8qIGdsb2JhbCBtb2R1bGUsIHJlcXVpcmUsIGRlZmluZSAqL1xuXG4vLyBGdW5jdGlvbnMgbmFtZXMgZm9yIEVTNiBleHBvcnRzXG5sZXQgYXV0b0Zvcm1hdDtcbmxldCBhdXRvVW5Gb3JtYXQ7XG5sZXQgZ2V0RGVmYXVsdENvbmZpZztcbmxldCBnZXRMYW5ndWFnZXM7XG5sZXQgdmFsaWRhdGU7XG5sZXQgYXJlU2V0dGluZ3NWYWxpZDtcblxuLy8gQXV0b051bWVyaWMgZGVmYXVsdCBzZXR0aW5nc1xuLyoqXG4gKiBMaXN0IG9mIGFsbG93ZWQgdGFnIG9uIHdoaWNoIGF1dG9OdW1lcmljIGNhbiBiZSB1c2VkLlxuICovXG5jb25zdCBhbGxvd2VkVGFnTGlzdCA9IFtcbiAgICAnYicsXG4gICAgJ2NhcHRpb24nLFxuICAgICdjaXRlJyxcbiAgICAnY29kZScsXG4gICAgJ2NvbnN0JyxcbiAgICAnZGQnLFxuICAgICdkZWwnLFxuICAgICdkaXYnLFxuICAgICdkZm4nLFxuICAgICdkdCcsXG4gICAgJ2VtJyxcbiAgICAnaDEnLFxuICAgICdoMicsXG4gICAgJ2gzJyxcbiAgICAnaDQnLFxuICAgICdoNScsXG4gICAgJ2g2JyxcbiAgICAnaW5zJyxcbiAgICAna2RiJyxcbiAgICAnbGFiZWwnLFxuICAgICdsaScsXG4gICAgJ29wdGlvbicsXG4gICAgJ291dHB1dCcsXG4gICAgJ3AnLFxuICAgICdxJyxcbiAgICAncycsXG4gICAgJ3NhbXBsZScsXG4gICAgJ3NwYW4nLFxuICAgICdzdHJvbmcnLFxuICAgICd0ZCcsXG4gICAgJ3RoJyxcbiAgICAndScsXG5dO1xuXG4vKipcbiAqIERlZmF1bHRzIG9wdGlvbnMgYXJlIHB1YmxpYyAtIHRoZXNlIGNhbiBiZSBvdmVycmlkZGVuIGJ5IHRoZSBmb2xsb3dpbmcgbWV0aG9kOlxuICogLSBIVE1MNSBkYXRhIGF0dHJpYnV0ZXMgKGllLiBgPGlucHV0IHR5cGU9XCJ0ZXh0XCIgZGF0YS1jdXJyZW5jeS1zeW1ib2w9XCIg4oKsXCI+YClcbiAqIC0gT3B0aW9ucyBwYXNzZWQgYnkgdGhlICdpbml0JyBvciAndXBkYXRlJyBtZXRob2RzIChpZS4gYGFOSW5wdXQuYXV0b051bWVyaWMoJ3VwZGF0ZScsIHsgY3VycmVuY3lTeW1ib2w6ICcg4oKsJyB9KTtgKVxuICogLSBVc2UgalF1ZXJ5J3MgYCQuZXh0ZW5kYCBtZXRob2QgZm9yIGdsb2JhbCBjaGFuZ2VzIC0gYWxzbyBhIGdyZWF0IHdheSB0byBwYXNzIEFTUC5ORVQgY3VycmVudCBjdWx0dXJlIHNldHRpbmdzXG4gKi9cbmNvbnN0IGRlZmF1bHRTZXR0aW5ncyA9IHtcbiAgICAvKiBBbGxvd2VkIHRob3VzYW5kIGdyb3VwaW5nIHNlcGFyYXRvciBjaGFyYWN0ZXJzIDpcbiAgICAgKiAnLCcgICAgICAvLyBDb21tYVxuICAgICAqICcuJyAgICAgIC8vIERvdFxuICAgICAqICcgJyAgICAgIC8vIE5vcm1hbCBzcGFjZVxuICAgICAqICdcXHUyMDA5JyAvLyBUaGluLXNwYWNlXG4gICAgICogJ1xcdTIwMmYnIC8vIE5hcnJvdyBuby1icmVhayBzcGFjZVxuICAgICAqICdcXHUwMGEwJyAvLyBOby1icmVhayBzcGFjZVxuICAgICAqICcnICAgICAgIC8vIE5vIHNlcGFyYXRvclxuICAgICAqIFwiJ1wiICAgICAgLy8gQXBvc3Ryb3BoZVxuICAgICAqICfZrCcgICAgICAvLyBBcmFiaWMgdGhvdXNhbmRzIHNlcGFyYXRvclxuICAgICAqICfLmScgICAgICAvLyBEb3QgYWJvdmVcbiAgICAgKiBEZXByZWNhdGVkIG9sZGVyIG9wdGlvbiBuYW1lIDogYVNlcFxuICAgICAqL1xuICAgIGRpZ2l0R3JvdXBTZXBhcmF0b3I6ICcsJyxcblxuICAgIC8qIFJlbW92ZSB0aGUgdGhvdXNhbmQgc2VwYXJhdG9yIG9uIGZvY3VzLCBjdXJyZW5jeSBzeW1ib2wgYW5kIHN1ZmZpeCBvbiBmb2N1c1xuICAgICAqIGV4YW1wbGUgaWYgdGhlIGlucHV0IHZhbHVlIFwiJCAxLDk5OS44OCBzdWZmaXhcIlxuICAgICAqIG9uIFwiZm9jdXNpblwiIGl0IGJlY29tZXMgXCIxOTk5Ljg4XCIgYW5kIGJhY2sgdG8gXCIkIDEsOTk5Ljg4IHN1ZmZpeFwiIG9uIGZvY3VzIG91dC5cbiAgICAgKiBEZXByZWNhdGVkIG9sZGVyIG9wdGlvbiBuYW1lIDogblNlcFxuICAgICAqL1xuICAgIG5vU2VwYXJhdG9yT25Gb2N1czogZmFsc2UsXG5cbiAgICAvKiBEaWdpdGFsIGdyb3VwaW5nIGZvciB0aGUgdGhvdXNhbmQgc2VwYXJhdG9yIHVzZWQgaW4gRm9ybWF0XG4gICAgICogZGlnaXRhbEdyb3VwU3BhY2luZzogXCIyXCIsIHJlc3VsdHMgaW4gOTksOTksOTksOTk5IEluZGlhJ3MgbGFraHNcbiAgICAgKiBkaWdpdGFsR3JvdXBTcGFjaW5nOiBcIjJzXCIsIHJlc3VsdHMgaW4gOTksOTk5LDk5LDk5LDk5OSBJbmRpYSdzIGxha2hzIHNjYWxlZFxuICAgICAqIGRpZ2l0YWxHcm91cFNwYWNpbmc6IFwiM1wiLCByZXN1bHRzIGluIDk5OSw5OTksOTk5IGRlZmF1bHRcbiAgICAgKiBkaWdpdGFsR3JvdXBTcGFjaW5nOiBcIjRcIiwgcmVzdWx0cyBpbiA5OTk5LDk5OTksOTk5OSB1c2VkIGluIHNvbWUgQXNpYW4gY291bnRyaWVzXG4gICAgICogRGVwcmVjYXRlZCBvbGRlciBvcHRpb24gbmFtZSA6IGRHcm91cFxuICAgICAqL1xuICAgIGRpZ2l0YWxHcm91cFNwYWNpbmc6ICczJyxcblxuICAgIC8qIEFsbG93ZWQgZGVjaW1hbCBzZXBhcmF0b3IgY2hhcmFjdGVycyA6XG4gICAgICogJywnIDogQ29tbWFcbiAgICAgKiAnLicgOiBEb3RcbiAgICAgKiAnwrcnIDogTWlkZGxlLWRvdFxuICAgICAqICfZqycgOiBBcmFiaWMgZGVjaW1hbCBzZXBhcmF0b3JcbiAgICAgKiAn4o6WJyA6IERlY2ltYWwgc2VwYXJhdG9yIGtleSBzeW1ib2xcbiAgICAgKiBEZXByZWNhdGVkIG9sZGVyIG9wdGlvbiBuYW1lIDogYURlY1xuICAgICAqL1xuICAgIGRlY2ltYWxDaGFyYWN0ZXI6ICcuJyxcblxuICAgIC8qIEFsbG93IHRvIGRlY2xhcmUgYW4gYWx0ZXJuYXRpdmUgZGVjaW1hbCBzZXBhcmF0b3Igd2hpY2ggaXMgYXV0b21hdGljYWxseSByZXBsYWNlZCBieSBgZGVjaW1hbENoYXJhY3RlcmAgd2hlbiB0eXBlZC5cbiAgICAgKiBUaGlzIGlzIHVzZWQgYnkgY291bnRyaWVzIHRoYXQgdXNlIGEgY29tbWEgXCIsXCIgYXMgdGhlIGRlY2ltYWwgY2hhcmFjdGVyIGFuZCBoYXZlIGtleWJvYXJkc1xcbnVtZXJpYyBwYWRzIHRoYXQgaGF2ZVxuICAgICAqIGEgcGVyaW9kICdmdWxsIHN0b3AnIGFzIHRoZSBkZWNpbWFsIGNoYXJhY3RlcnMgKEZyYW5jZSBvciBTcGFpbiBmb3IgaW5zdGFuY2UpLlxuICAgICAqIERlcHJlY2F0ZWQgb2xkZXIgb3B0aW9uIG5hbWUgOiBhbHREZWNcbiAgICAgKi9cbiAgICBkZWNpbWFsQ2hhcmFjdGVyQWx0ZXJuYXRpdmU6IG51bGwsXG5cbiAgICAvKiBjdXJyZW5jeVN5bWJvbCA9IGFsbG93ZWQgY3VycmVuY3kgc3ltYm9sXG4gICAgICogTXVzdCBiZSBpbiBxdW90ZXMgY3VycmVuY3lTeW1ib2w6IFwiJFwiXG4gICAgICogc3BhY2UgdG8gdGhlIHJpZ2h0IG9mIHRoZSBjdXJyZW5jeSBzeW1ib2wgY3VycmVuY3lTeW1ib2w6ICckICdcbiAgICAgKiBzcGFjZSB0byB0aGUgbGVmdCBvZiB0aGUgY3VycmVuY3kgc3ltYm9sIGN1cnJlbmN5U3ltYm9sOiAnICQnXG4gICAgICogRGVwcmVjYXRlZCBvbGRlciBvcHRpb24gbmFtZSA6IGFTaWduXG4gICAgICovXG4gICAgY3VycmVuY3lTeW1ib2w6ICcnLFxuXG4gICAgLyogY3VycmVuY3lTeW1ib2xQbGFjZW1lbnQgPSBwbGFjZW1lbnQgb2YgY3VycmVuY3kgc2lnbiBhcyBhIHA9cHJlZml4IG9yIHM9c3VmZml4XG4gICAgICogZm9yIHByZWZpeCBjdXJyZW5jeVN5bWJvbFBsYWNlbWVudDogXCJwXCIgKGRlZmF1bHQpXG4gICAgICogZm9yIHN1ZmZpeCBjdXJyZW5jeVN5bWJvbFBsYWNlbWVudDogXCJzXCJcbiAgICAgKiBEZXByZWNhdGVkIG9sZGVyIG9wdGlvbiBuYW1lIDogcFNpZ25cbiAgICAgKi9cbiAgICAvL1RPRE8gUmVuYW1lIHRoZSBvcHRpb25zIHRvIG1vcmUgZXhwbGljaXQgbmFtZXMgKCdwJyA9PiAncHJlZml4JywgZXRjLilcbiAgICBjdXJyZW5jeVN5bWJvbFBsYWNlbWVudDogJ3AnLFxuXG4gICAgLyogUGxhY2VtZW50IG9mIG5lZ2F0aXZlL3Bvc2l0aXZlIHNpZ24gcmVsYXRpdmUgdG8gdGhlIGN1cnJlbmN5U3ltYm9sIG9wdGlvbiBsPWxlZnQsIHI9cmlnaHQsIHA9cHJlZml4ICYgcz1zdWZmaXhcbiAgICAgKiAtMSwyMzQuNTYgID0+IGRlZmF1bHQgbm8gb3B0aW9ucyByZXF1aXJlZFxuICAgICAqIC0kMSwyMzQuNTYgPT4ge2N1cnJlbmN5U3ltYm9sOiBcIiRcIn0gb3Ige2N1cnJlbmN5U3ltYm9sOiBcIiRcIiwgbmVnYXRpdmVQb3NpdGl2ZVNpZ25QbGFjZW1lbnQ6IFwibFwifVxuICAgICAqICQtMSwyMzQuNTYgPT4ge2N1cnJlbmN5U3ltYm9sOiBcIiRcIiwgbmVnYXRpdmVQb3NpdGl2ZVNpZ25QbGFjZW1lbnQ6IFwiclwifSAvLyBEZWZhdWx0IGlmIG5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50IGlzICdudWxsJyBhbmQgY3VycmVuY3lTeW1ib2wgaXMgbm90IGVtcHR5XG4gICAgICogLTEsMjM0LjU2JCA9PiB7Y3VycmVuY3lTeW1ib2w6IFwiJFwiLCBjdXJyZW5jeVN5bWJvbFBsYWNlbWVudDogXCJzXCIsIG5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50OiBcInBcIn0gLy8gRGVmYXVsdCBpZiBuZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudCBpcyAnbnVsbCcgYW5kIGN1cnJlbmN5U3ltYm9sIGlzIG5vdCBlbXB0eVxuICAgICAqIDEsMjM0LjU2LSAgPT4ge25lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50OiBcInNcIn1cbiAgICAgKiAkMSwyMzQuNTYtID0+IHtjdXJyZW5jeVN5bWJvbDogXCIkXCIsIG5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50OiBcInNcIn1cbiAgICAgKiAxLDIzNC41Ni0kID0+IHtjdXJyZW5jeVN5bWJvbDogXCIkXCIsIGN1cnJlbmN5U3ltYm9sUGxhY2VtZW50OiBcInNcIn1cbiAgICAgKiAxLDIzNC41NiQtID0+IHtjdXJyZW5jeVN5bWJvbDogXCIkXCIsIGN1cnJlbmN5U3ltYm9sUGxhY2VtZW50OiBcInNcIiwgbmVnYXRpdmVQb3NpdGl2ZVNpZ25QbGFjZW1lbnQ6IFwiclwifVxuICAgICAqIERlcHJlY2F0ZWQgb2xkZXIgb3B0aW9uIG5hbWUgOiBwTmVnXG4gICAgICovXG4gICAgLy9UT0RPIFJlbmFtZSB0aGUgb3B0aW9ucyB0byBtb3JlIGV4cGxpY2l0IG5hbWVzICgncCcgPT4gJ3ByZWZpeCcsIGV0Yy4pXG4gICAgbmVnYXRpdmVQb3NpdGl2ZVNpZ25QbGFjZW1lbnQ6IG51bGwsXG5cblxuICAgIC8qIEFsbG93IHRoZSBwb3NpdGl2ZSBzaWduIHN5bWJvbCBgK2AgdG8gYmUgZGlzcGxheWVkIGZvciBwb3NpdGl2ZSBudW1iZXJzLlxuICAgICAqIEJ5IGRlZmF1bHQsIHRoaXMgcG9zaXRpdmUgc2lnbiBpcyBub3Qgc2hvd24uXG4gICAgICogVGhlIHNpZ24gcGxhY2VtZW50IGlzIGNvbnRyb2xsZWQgYnkgdGhlICduZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudCcgb3B0aW9uLCBtaW1pY2tpbmcgdGhlIG5lZ2F0aXZlIHNpZ24gcGxhY2VtZW50IHJ1bGVzLlxuICAgICAqL1xuICAgIHNob3dQb3NpdGl2ZVNpZ246IGZhbHNlLFxuXG4gICAgLyogQWRkaXRpb25hbCBzdWZmaXhcbiAgICAgKiBNdXN0IGJlIGluIHF1b3RlcyBzdWZmaXhUZXh0OiAnZ3Jvc3MnLCBhIHNwYWNlIGlzIGFsbG93ZWQgc3VmZml4VGV4dDogJyBkb2xsYXJzJ1xuICAgICAqIE51bWVyaWMgY2hhcmFjdGVycyBhbmQgbmVnYXRpdmUgc2lnbiBub3QgYWxsb3dlZCdcbiAgICAgKiBEZXByZWNhdGVkIG9sZGVyIG9wdGlvbiBuYW1lIDogYVN1ZmZpeFxuICAgICAqL1xuICAgIHN1ZmZpeFRleHQ6ICcnLFxuXG4gICAgLyogT3ZlcnJpZGUgbWluIG1heCBsaW1pdHNcbiAgICAgKiBvdmVycmlkZU1pbk1heExpbWl0czogXCJjZWlsaW5nXCIgYWRoZXJlcyB0byBtYXhpbXVtVmFsdWUgYW5kIGlnbm9yZXMgbWluaW11bVZhbHVlIHNldHRpbmdzXG4gICAgICogb3ZlcnJpZGVNaW5NYXhMaW1pdHM6IFwiZmxvb3JcIiBhZGhlcmVzIHRvIG1pbmltdW1WYWx1ZSBhbmQgaWdub3JlcyBtYXhpbXVtVmFsdWUgc2V0dGluZ3NcbiAgICAgKiBvdmVycmlkZU1pbk1heExpbWl0czogXCJpZ25vcmVcIiBpZ25vcmVzIGJvdGggbWluaW11bVZhbHVlICYgbWF4aW11bVZhbHVlXG4gICAgICogRGVwcmVjYXRlZCBvbGRlciBvcHRpb24gbmFtZSA6IG9MaW1pdHNcbiAgICAgKi9cbiAgICBvdmVycmlkZU1pbk1heExpbWl0czogbnVsbCxcblxuICAgIC8qIE1heGltdW0gcG9zc2libGUgdmFsdWVcbiAgICAgKiB2YWx1ZSBtdXN0IGJlIGVuY2xvc2VkIGluIHF1b3RlcyBhbmQgdXNlIHRoZSBwZXJpb2QgZm9yIHRoZSBkZWNpbWFsIHBvaW50XG4gICAgICogdmFsdWUgbXVzdCBiZSBsYXJnZXIgdGhhbiBtaW5pbXVtVmFsdWVcbiAgICAgKiBEZXByZWNhdGVkIG9sZGVyIG9wdGlvbiBuYW1lIDogdk1heFxuICAgICAqL1xuICAgIG1heGltdW1WYWx1ZTogJzk5OTk5OTk5OTk5OTkuOTknLCAvLyA5Ljk5OS45OTkuOTk5Ljk5OSw5OSB+PSAxMDAwMCBiaWxsaW9uc1xuXG4gICAgLyogTWluaW11bSBwb3NzaWJsZSB2YWx1ZVxuICAgICAqIHZhbHVlIG11c3QgYmUgZW5jbG9zZWQgaW4gcXVvdGVzIGFuZCB1c2UgdGhlIHBlcmlvZCBmb3IgdGhlIGRlY2ltYWwgcG9pbnRcbiAgICAgKiB2YWx1ZSBtdXN0IGJlIHNtYWxsZXIgdGhhbiBtYXhpbXVtVmFsdWVcbiAgICAgKiBEZXByZWNhdGVkIG9sZGVyIG9wdGlvbiBuYW1lIDogdk1pblxuICAgICAqL1xuICAgIG1pbmltdW1WYWx1ZTogJy05OTk5OTk5OTk5OTk5Ljk5JywgLy8gLTkuOTk5Ljk5OS45OTkuOTk5LDk5IH49IDEwMDAwIGJpbGxpb25zXG5cbiAgICAvKiBNYXhpbXVtIG51bWJlciBvZiBkZWNpbWFsIHBsYWNlcyA9IHVzZWQgdG8gb3ZlcnJpZGUgZGVjaW1hbCBwbGFjZXMgc2V0IGJ5IHRoZSBtaW5pbXVtVmFsdWUgJiBtYXhpbXVtVmFsdWUgdmFsdWVzXG4gICAgICogRGVwcmVjYXRlZCBvbGRlciBvcHRpb24gbmFtZSA6IG1EZWNcbiAgICAgKi9cbiAgICBkZWNpbWFsUGxhY2VzT3ZlcnJpZGU6IG51bGwsXG5cbiAgICAvKiBFeHBhbmRlZCBkZWNpbWFsIHBsYWNlcyB2aXNpYmxlIHdoZW4gaW5wdXQgaGFzIGZvY3VzIC0gZXhhbXBsZTpcbiAgICAgKiB7ZGVjaW1hbFBsYWNlc1Nob3duT25Gb2N1czogXCI1XCJ9IGFuZCB0aGUgZGVmYXVsdCAyIGRlY2ltYWwgcGxhY2VzIHdpdGggZm9jdXMgXCIxLDAwMC4xMjM0NVwiIHdpdGhvdXQgZm9jdXMgXCIxLDAwMC4xMlwiIHRoZSByZXN1bHRzIGRlcGVuZHMgb24gdGhlIHJvdW5kaW5nIG1ldGhvZCB1c2VkXG4gICAgICogdGhlIFwiZ2V0XCIgbWV0aG9kIHJldHVybnMgdGhlIGV4dGVuZGVkIGRlY2ltYWwgcGxhY2VzXG4gICAgICogRGVwcmVjYXRlZCBvbGRlciBvcHRpb24gbmFtZSA6IGVEZWNcbiAgICAgKi9cbiAgICBkZWNpbWFsUGxhY2VzU2hvd25PbkZvY3VzOiBudWxsLFxuXG4gICAgLyogVGhlIG5leHQgdGhyZWUgb3B0aW9ucyAoc2NhbGVEaXZpc29yLCBzY2FsZURlY2ltYWxQbGFjZXMgJiBzY2FsZVN5bWJvbCkgaGFuZGxlIHNjYWxpbmcgb2YgdGhlIGlucHV0IHdoZW4gdGhlIGlucHV0IGRvZXMgbm90IGhhdmUgZm9jdXNcbiAgICAgKiBQbGVhc2Ugbm90ZSB0aGF0IHRoZSBub24tc2NhbGVkIHZhbHVlIGlzIGhlbGQgaW4gZGF0YSBhbmQgaXQgaXMgYWR2aXNlZCB0aGF0IHlvdSB1c2UgdGhlIFwic2F2ZVZhbHVlVG9TZXNzaW9uU3RvcmFnZVwiIG9wdGlvbiB0byBlbnN1cmUgcmV0YWluaW5nIHRoZSB2YWx1ZVxuICAgICAqIFtcImRpdmlzb3JcIiwgXCJkZWNpbWFsIHBsYWNlc1wiLCBcInN5bWJvbFwiXVxuICAgICAqIEV4YW1wbGU6IHdpdGggdGhlIGZvbGxvd2luZyBvcHRpb25zIHNldCB7c2NhbGVEaXZpc29yOiAnMTAwMCcsIHNjYWxlRGVjaW1hbFBsYWNlczogJzEnLCBzY2FsZVN5bWJvbDogJyBLJ31cbiAgICAgKiBFeGFtcGxlOiBmb2N1c2luIHZhbHVlIFwiMSwxMTEuMTFcIiBmb2N1c291dCB2YWx1ZSBcIjEuMSBLXCJcbiAgICAgKi9cblxuICAgIC8qIFRoZSBgc2NhbGVEaXZpc29yYCBkZWNpZGVzIHRoZSBvbiBmb2N1cyB2YWx1ZSBhbmQgcGxhY2VzIHRoZSByZXN1bHQgaW4gdGhlIGlucHV0IG9uIGZvY3Vzb3V0XG4gICAgICogRXhhbXBsZSB7c2NhbGVEaXZpc29yOiAnMTAwMCd9IG9yIDxpbnB1dCBkYXRhLXNjYWxlLWRpdmlzb3I9XCIxMDAwXCI+XG4gICAgICogVGhlIGRpdmlzb3IgdmFsdWUgLSBkb2VzIG5vdCBuZWVkIHRvIGJlIHdob2xlIG51bWJlciBidXQgcGxlYXNlIHVuZGVyc3RhbmQgdGhhdCBKYXZhc2NyaXB0IGhhcyBsaW1pdGVkIGFjY3VyYWN5IGluIG1hdGhcbiAgICAgKiBUaGUgXCJnZXRcIiBtZXRob2QgcmV0dXJucyB0aGUgZnVsbCB2YWx1ZSwgaW5jbHVkaW5nIHRoZSAnaGlkZGVuJyBkZWNpbWFscy5cbiAgICAgKi9cbiAgICBzY2FsZURpdmlzb3I6IG51bGwsXG5cbiAgICAvKlxuICAgICAqIFRoZSBgc2NhbGVEZWNpbWFsUGxhY2VzYCBvcHRpb24gaXMgdGhlIG51bWJlciBvZiBkZWNpbWFsIHBsYWNlIHdoZW4gbm90IGluIGZvY3VzIC0gZm9yIHRoaXMgdG8gd29yaywgYHNjYWxlZERpdmlzb3JgIG11c3Qgbm90IGJlIGBudWxsYC5cbiAgICAgKiBUaGlzIGlzIG9wdGlvbmFsIDsgaWYgb21pdHRlZCB0aGUgZGVjaW1hbCBwbGFjZXMgd2lsbCBiZSB0aGUgc2FtZSB3aGVuIHRoZSBpbnB1dCBoYXMgdGhlIGZvY3VzLlxuICAgICAqIERlcHJlY2F0ZWQgb2xkZXIgb3B0aW9uIG5hbWUgOiBzY2FsZURlY2ltYWxcbiAgICAgKi9cbiAgICBzY2FsZURlY2ltYWxQbGFjZXM6IG51bGwsXG5cbiAgICAvKlxuICAgICAqIFRoZSBgc2NhbGVTeW1ib2xgIG9wdGlvbiBpcyBhIHN5bWJvbCBwbGFjZWQgYXMgYSBzdWZmaXggd2hlbiBub3QgaW4gZm9jdXMuXG4gICAgICogVGhpcyBpcyBvcHRpb25hbCB0b28uXG4gICAgICovXG4gICAgc2NhbGVTeW1ib2w6IG51bGwsXG5cbiAgICAvKiBTZXQgdG8gdHJ1ZSB0byBhbGxvdyB0aGUgZGVjaW1hbFBsYWNlc1Nob3duT25Gb2N1cyB2YWx1ZSB0byBiZSBzYXZlZCB3aXRoIHNlc3Npb25TdG9yYWdlXG4gICAgICogaWYgaWUgNiBvciA3IHRoZSB2YWx1ZSB3aWxsIGJlIHNhdmVkIGFzIGEgc2Vzc2lvbiBjb29raWVcbiAgICAgKiBEZXByZWNhdGVkIG9sZGVyIG9wdGlvbiBuYW1lIDogYVN0b3JcbiAgICAgKi9cbiAgICBzYXZlVmFsdWVUb1Nlc3Npb25TdG9yYWdlOiBmYWxzZSxcblxuICAgIC8qXG4gICAgICogTWFuYWdlIGhvdyBhdXRvTnVtZXJpYyByZWFjdCB3aGVuIHRoZSB1c2VyIHRyaWVzIHRvIHBhc3RlIGFuIGludmFsaWQgbnVtYmVyLlxuICAgICAqIC0gJ2Vycm9yJyAgICA6IChUaGlzIGlzIHRoZSBkZWZhdWx0IGJlaGF2aW9yKSBUaGUgaW5wdXQgdmFsdWUgaXMgbm90IGNoYW5nZWQgYW5kIGFuIGVycm9yIGlzIG91dHB1dCBpbiB0aGUgY29uc29sZS5cbiAgICAgKiAtICdpZ25vcmUnICAgOiBpZGVtIHRoYW4gJ2Vycm9yJywgYnV0IGZhaWwgc2lsZW50bHkgd2l0aG91dCBvdXRwdXR0aW5nIGFueSBlcnJvci93YXJuaW5nIGluIHRoZSBjb25zb2xlLlxuICAgICAqIC0gJ2NsYW1wJyAgICA6IGlmIHRoZSBwYXN0ZWQgdmFsdWUgaXMgZWl0aGVyIHRvbyBzbWFsbCBvciB0b28gYmlnIHJlZ2FyZGluZyB0aGUgbWluaW11bVZhbHVlIGFuZCBtYXhpbXVtVmFsdWUgcmFuZ2UsIHRoZW4gdGhlIHJlc3VsdCBpcyBjbGFtcGVkIHRvIHRob3NlIGxpbWl0cy5cbiAgICAgKiAtICd0cnVuY2F0ZScgOiBhdXRvTnVtZXJpYyB3aWxsIGluc2VydCBhcyBtYW55IHBhc3RlZCBudW1iZXJzIGl0IGNhbiBhdCB0aGUgaW5pdGlhbCBjYXJldC9zZWxlY3Rpb24sIHVudGlsIGV2ZXJ5dGhpbmcgaXMgcGFzdGVkLCBvciB0aGUgcmFuZ2UgbGltaXQgaXMgaGl0LlxuICAgICAqICAgICAgICAgICAgICAgIFRoZSBub24tcGFzdGVkIG51bWJlcnMgYXJlIGRyb3BwZWQgYW5kIHRoZXJlZm9yZSBub3QgdXNlZCBhdCBhbGwuXG4gICAgICogLSAncmVwbGFjZScgIDogYXV0b051bWVyaWMgd2lsbCBmaXJzdCBpbnNlcnQgYXMgbWFueSBwYXN0ZWQgbnVtYmVycyBpdCBjYW4gYXQgdGhlIGluaXRpYWwgY2FyZXQvc2VsZWN0aW9uLCB0aGVuIGlmIHRoZSByYW5nZSBsaW1pdCBpcyBoaXQsIGl0IHdpbGwgdHJ5XG4gICAgICogICAgICAgICAgICAgICAgdG8gcmVwbGFjZSBvbmUgYnkgb25lIHRoZSByZW1haW5pbmcgaW5pdGlhbCBudW1iZXJzIChvbiB0aGUgcmlnaHQgc2lkZSBvZiB0aGUgY2FyZXQpIHdpdGggdGhlIHJlc3Qgb2YgdGhlIHBhc3RlZCBudW1iZXJzLlxuICAgICAqXG4gICAgICogTm90ZSAxIDogQSBwYXN0ZSBjb250ZW50IHN0YXJ0aW5nIHdpdGggYSBuZWdhdGl2ZSBzaWduICctJyB3aWxsIGJlIGFjY2VwdGVkIGFueXdoZXJlIGluIHRoZSBpbnB1dCwgYW5kIHdpbGwgc2V0IHRoZSByZXN1bHRpbmcgdmFsdWUgYXMgYSBuZWdhdGl2ZSBudW1iZXJcbiAgICAgKiBOb3RlIDIgOiBBIHBhc3RlIGNvbnRlbnQgc3RhcnRpbmcgd2l0aCBhIG51bWJlciB3aWxsIGJlIGFjY2VwdGVkLCBldmVuIGlmIHRoZSByZXN0IGlzIGdpYmJlcmlzaCAoaWUuICcxMjNmb29iYXI0NTYnKS5cbiAgICAgKiAgICAgICAgICBPbmx5IHRoZSBmaXJzdCBudW1iZXIgd2lsbCBiZSB1c2VkIChoZXJlICcxMjMnKS5cbiAgICAgKiBOb3RlIDMgOiBUaGUgcGFzdGUgZXZlbnQgd29ya3Mgd2l0aCB0aGUgYGRlY2ltYWxQbGFjZXNTaG93bk9uRm9jdXNgIG9wdGlvbiB0b28uXG4gICAgICovXG4gICAgLy9UT0RPIFNob3VsZG4ndCB3ZSB1c2UgYHRydW5jYXRlYCBhcyB0aGUgZGVmYXVsdCB2YWx1ZT9cbiAgICBvbkludmFsaWRQYXN0ZTogJ2Vycm9yJyxcblxuICAgIC8qIG1ldGhvZCB1c2VkIGZvciByb3VuZGluZ1xuICAgICAqIHJvdW5kaW5nTWV0aG9kOiBcIlNcIiwgUm91bmQtSGFsZi1VcCBTeW1tZXRyaWMgKGRlZmF1bHQpXG4gICAgICogcm91bmRpbmdNZXRob2Q6IFwiQVwiLCBSb3VuZC1IYWxmLVVwIEFzeW1tZXRyaWNcbiAgICAgKiByb3VuZGluZ01ldGhvZDogXCJzXCIsIFJvdW5kLUhhbGYtRG93biBTeW1tZXRyaWMgKGxvd2VyIGNhc2UgcylcbiAgICAgKiByb3VuZGluZ01ldGhvZDogXCJhXCIsIFJvdW5kLUhhbGYtRG93biBBc3ltbWV0cmljIChsb3dlciBjYXNlIGEpXG4gICAgICogcm91bmRpbmdNZXRob2Q6IFwiQlwiLCBSb3VuZC1IYWxmLUV2ZW4gXCJCYW5rZXJzIFJvdW5kaW5nXCJcbiAgICAgKiByb3VuZGluZ01ldGhvZDogXCJVXCIsIFJvdW5kIFVwIFwiUm91bmQtQXdheS1Gcm9tLVplcm9cIlxuICAgICAqIHJvdW5kaW5nTWV0aG9kOiBcIkRcIiwgUm91bmQgRG93biBcIlJvdW5kLVRvd2FyZC1aZXJvXCIgLSBzYW1lIGFzIHRydW5jYXRlXG4gICAgICogcm91bmRpbmdNZXRob2Q6IFwiQ1wiLCBSb3VuZCB0byBDZWlsaW5nIFwiVG93YXJkIFBvc2l0aXZlIEluZmluaXR5XCJcbiAgICAgKiByb3VuZGluZ01ldGhvZDogXCJGXCIsIFJvdW5kIHRvIEZsb29yIFwiVG93YXJkIE5lZ2F0aXZlIEluZmluaXR5XCJcbiAgICAgKiByb3VuZGluZ01ldGhvZDogXCJOMDVcIiBSb3VuZHMgdG8gdGhlIG5lYXJlc3QgLjA1ID0+IHNhbWUgYXMgXCJDSEZcIiB1c2VkIGluIDEuOVggYW5kIHN0aWxsIHZhbGlkXG4gICAgICogcm91bmRpbmdNZXRob2Q6IFwiVTA1XCIgUm91bmRzIHVwIHRvIG5leHQgLjA1XG4gICAgICogcm91bmRpbmdNZXRob2Q6IFwiRDA1XCIgUm91bmRzIGRvd24gdG8gbmV4dCAuMDVcbiAgICAgKiBEZXByZWNhdGVkIG9sZGVyIG9wdGlvbiBuYW1lIDogbVJvdW5kXG4gICAgICovXG4gICAgLy9UT0RPIFJlbmFtZSB0aGUgb3B0aW9ucyB0byBtb3JlIGV4cGxpY2l0IG5hbWVzICgnUycgPT4gJ1JvdW5kSGFsZlVwU3ltbWV0cmljJywgZXRjLilcbiAgICAvL1RPRE8gQWRkIGFuIGBhbi5yb3VuZGluZ01ldGhvZGAgb2JqZWN0IHRoYXQgZW51bSB0aG9zZSBvcHRpb25zIGNsZWFybHlcbiAgICByb3VuZGluZ01ldGhvZDogJ1MnLFxuXG4gICAgLyogQWxsb3cgcGFkZGluZyB0aGUgZGVjaW1hbCBwbGFjZXMgd2l0aCB6ZXJvc1xuICAgICAqIGFsbG93RGVjaW1hbFBhZGRpbmc6IHRydWUgLSBhbHdheXMgUGFkIGRlY2ltYWxzIHdpdGggemVyb3NcbiAgICAgKiBhbGxvd0RlY2ltYWxQYWRkaW5nOiBmYWxzZSAtIGRvZXMgbm90IHBhZCB3aXRoIHplcm9zLlxuICAgICAqIE5vdGU6IHNldHRpbmcgYWxsb3dEZWNpbWFsUGFkZGluZyB0byAnZmFsc2UnIHdpbGwgb3ZlcnJpZGUgdGhlICdkZWNpbWFsUGxhY2VzT3ZlcnJpZGUnIHNldHRpbmcuXG4gICAgICpcbiAgICAgKiB0aGFua3MgdG8gSm9uYXMgSm9oYW5zc29uIGZvciB0aGUgc3VnZ2VzdGlvblxuICAgICAqIERlcHJlY2F0ZWQgb2xkZXIgb3B0aW9uIG5hbWUgOiBhUGFkXG4gICAgICovXG4gICAgYWxsb3dEZWNpbWFsUGFkZGluZzogdHJ1ZSxcblxuICAgIC8qIEFkZHMgYnJhY2tldHMgb24gbmVnYXRpdmUgdmFsdWVzIChpZS4gdHJhbnNmb3JtcyAnLSQgOTk5Ljk5JyB0byAnKDk5OS45OSknKVxuICAgICAqIFRob3NlIGJyYWNrZXRzIGFyZSB2aXNpYmxlIG9ubHkgd2hlbiB0aGUgZmllbGQgZG9lcyBOT1QgaGF2ZSB0aGUgZm9jdXMuXG4gICAgICogVGhlIGxlZnQgYW5kIHJpZ2h0IHN5bWJvbHMgc2hvdWxkIGJlIGVuY2xvc2VkIGluIHF1b3RlcyBhbmQgc2VwYXJhdGVkIGJ5IGEgY29tbWFcbiAgICAgKiBUaGlzIG9wdGlvbiBjYW4gYmUgb2YgdGhlIGZvbGxvd2luZyB2YWx1ZXMgOlxuICAgICAqIG51bGwsIC8vIFRoaXMgaXMgdGhlIGRlZmF1bHQgdmFsdWUsIHdoaWNoIGRlYWN0aXZhdGUgdGhpcyBmZWF0dXJlXG4gICAgICogJygsKScsXG4gICAgICogJ1ssXScsXG4gICAgICogJzwsPicgb3JcbiAgICAgKiAneyx9J1xuICAgICAqIERlcHJlY2F0ZWQgb2xkZXIgb3B0aW9uIG5hbWUgOiBuQnJhY2tldFxuICAgICAqL1xuICAgIC8vVE9ETyBSZW5hbWUgdGhlIG9wdGlvbnMgdG8gbW9yZSBleHBsaWNpdCBuYW1lcyAoJygsKScgPT4gJ3BhcmVudGhlc2VzJywgZXRjLilcbiAgICBuZWdhdGl2ZUJyYWNrZXRzVHlwZU9uQmx1cjogbnVsbCxcblxuICAgIC8qIERpc3BsYXllZCBvbiBlbXB0eSBzdHJpbmcgXCJcIlxuICAgICAqIGVtcHR5SW5wdXRCZWhhdmlvcjogXCJmb2N1c1wiIC0gKGRlZmF1bHQpIGN1cnJlbmN5IHNpZ24gZGlzcGxheWVkIGFuZCB0aGUgaW5wdXQgcmVjZWl2ZXMgZm9jdXNcbiAgICAgKiBlbXB0eUlucHV0QmVoYXZpb3I6IFwicHJlc3NcIiAtIGN1cnJlbmN5IHNpZ24gZGlzcGxheXMgb24gYW55IGtleSBiZWluZyBwcmVzc2VkXG4gICAgICogZW1wdHlJbnB1dEJlaGF2aW9yOiBcImFsd2F5c1wiIC0gYWx3YXlzIGRpc3BsYXlzIHRoZSBjdXJyZW5jeSBzaWduIG9ubHlcbiAgICAgKiBlbXB0eUlucHV0QmVoYXZpb3I6IFwiemVyb1wiIC0gaWYgdGhlIGlucHV0IGhhcyBubyB2YWx1ZSBvbiBmb2N1cyBvdXQgZGlzcGxheXMgYSB6ZXJvIFwicm91bmRlZFwiIHdpdGggb3Igd2l0aG91dCBhIGN1cnJlbmN5IHNpZ25cbiAgICAgKiBEZXByZWNhdGVkIG9sZGVyIG9wdGlvbiBuYW1lIDogd0VtcHR5XG4gICAgICovXG4gICAgZW1wdHlJbnB1dEJlaGF2aW9yOiAnZm9jdXMnLFxuXG4gICAgLyogQ29udHJvbHMgbGVhZGluZyB6ZXJvIGJlaGF2aW9yXG4gICAgICogbGVhZGluZ1plcm86IFwiYWxsb3dcIiwgLSBhbGxvd3MgbGVhZGluZyB6ZXJvcyB0byBiZSBlbnRlcmVkLiBaZXJvcyB3aWxsIGJlIHRydW5jYXRlZCB3aGVuIGVudGVyaW5nIGFkZGl0aW9uYWwgZGlnaXRzLiBPbiBmb2N1c291dCB6ZXJvcyB3aWxsIGJlIGRlbGV0ZWQuXG4gICAgICogbGVhZGluZ1plcm86IFwiZGVueVwiLCAtIGFsbG93cyBvbmx5IG9uZSBsZWFkaW5nIHplcm8gb24gdmFsdWVzIGxlc3MgdGhhbiBvbmVcbiAgICAgKiBsZWFkaW5nWmVybzogXCJrZWVwXCIsIC0gYWxsb3dzIGxlYWRpbmcgemVyb3MgdG8gYmUgZW50ZXJlZC4gb24gZm9jdXNvdXQgemVyb3Mgd2lsbCBiZSByZXRhaW5lZC5cbiAgICAgKiBEZXByZWNhdGVkIG9sZGVyIG9wdGlvbiBuYW1lIDogbFplcm9cbiAgICAgKi9cbiAgICBsZWFkaW5nWmVybzogJ2RlbnknLFxuXG4gICAgLyogRGV0ZXJtaW5lIGlmIHRoZSBkZWZhdWx0IHZhbHVlIHdpbGwgYmUgZm9ybWF0dGVkIG9uIGluaXRpYWxpemF0aW9uLlxuICAgICAqIHRydWUgPSBhdXRvbWF0aWNhbGx5IGZvcm1hdHMgdGhlIGRlZmF1bHQgdmFsdWUgb24gaW5pdGlhbGl6YXRpb25cbiAgICAgKiBmYWxzZSA9IHdpbGwgbm90IGZvcm1hdCB0aGUgZGVmYXVsdCB2YWx1ZSBvbiBpbml0aWFsaXphdGlvblxuICAgICAqIERlcHJlY2F0ZWQgb2xkZXIgb3B0aW9uIG5hbWUgOiBhRm9ybVxuICAgICAqL1xuICAgIGZvcm1hdE9uUGFnZUxvYWQ6IHRydWUsXG5cbiAgICAvKiBEZXRlcm1pbmUgaWYgdGhlIHNlbGVjdCBhbGwga2V5Ym9hcmQgY29tbWFuZCB3aWxsIHNlbGVjdCB0aGUgY29tcGxldGUgaW5wdXQgdGV4dCwgb3Igb25seSB0aGUgaW5wdXQgbnVtZXJpYyB2YWx1ZVxuICAgICAqIE5vdGUgOiBJZiB0aGUgY3VycmVuY3kgc3ltYm9sIGlzIGJldHdlZW4gdGhlIG51bWVyaWMgdmFsdWUgYW5kIHRoZSBuZWdhdGl2ZSBzaWduLCBvbmx5IHRoZSBudW1lcmljIHZhbHVlIHdpbGwgc2VsZWN0ZWRcbiAgICAgKiBEZXByZWNhdGVkIG9sZGVyIG9wdGlvbiBuYW1lIDogc051bWJlclxuICAgICAqL1xuICAgIHNlbGVjdE51bWJlck9ubHk6IGZhbHNlLFxuXG4gICAgLyogSGVscGVyIG9wdGlvbiBmb3IgQVNQLk5FVCBwb3N0YmFja1xuICAgICAqIHNob3VsZCBiZSB0aGUgdmFsdWUgb2YgdGhlIHVuZm9ybWF0dGVkIGRlZmF1bHQgdmFsdWVcbiAgICAgKiBleGFtcGxlczpcbiAgICAgKiBubyBkZWZhdWx0IHZhbHVlPVwiXCIge2RlZmF1bHRWYWx1ZU92ZXJyaWRlOiBcIlwifVxuICAgICAqIHZhbHVlPTEyMzQuNTYge2RlZmF1bHRWYWx1ZU92ZXJyaWRlOiAnMTIzNC41Nid9XG4gICAgICogRGVwcmVjYXRlZCBvbGRlciBvcHRpb24gbmFtZSA6IGFuRGVmYXVsdFxuICAgICAqL1xuICAgIGRlZmF1bHRWYWx1ZU92ZXJyaWRlOiBudWxsLFxuXG4gICAgLyogUmVtb3ZlcyBmb3JtYXR0aW5nIG9uIHN1Ym1pdCBldmVudFxuICAgICAqIHRoaXMgb3V0cHV0IGZvcm1hdDogcG9zaXRpdmUgbm5ubi5ubiwgbmVnYXRpdmUgLW5ubm4ubm5cbiAgICAgKiByZXZpZXcgdGhlICd1blNldCcgbWV0aG9kIGZvciBvdGhlciBmb3JtYXRzXG4gICAgICogRGVwcmVjYXRlZCBvbGRlciBvcHRpb24gbmFtZSA6IHVuU2V0T25TdWJtaXRcbiAgICAgKi9cbiAgICB1bmZvcm1hdE9uU3VibWl0OiBmYWxzZSxcblxuICAgIC8qIEFsbG93cyB0aGUgb3V0cHV0IHRvIGJlIGluIHRoZSBsb2NhbGUgZm9ybWF0IHZpYSB0aGUgXCJnZXRcIiwgXCJnZXRTdHJpbmdcIiAmIFwiZ2V0QXJyYXlcIiBtZXRob2RzXG4gICAgICogbnVsbCBvciAnc3RyaW5nJyA9PiAnbm5ubi5ubicgb3IgJy1ubm5uLm5uJyBhcyB0ZXh0IHR5cGUuIFRoaXMgaXMgdGhlIGRlZmF1bHQgYmVoYXZpb3IuXG4gICAgICogJ251bWJlcicgICAgICAgICA9PiBubm5uLm5uIG9yIC1ubm5uLm5uIGFzIGEgTnVtYmVyIChXYXJuaW5nOiB0aGlzIHdvcmtzIG9ubHkgZm9yIGludGVnZXJzIGluZmVyaW9yIHRvIE51bWJlci5NQVhfU0FGRV9JTlRFR0VSKVxuICAgICAqICcsJyBvciAnLSwnICAgICAgPT4gJ25ubm4sbm4nIG9yICctbm5ubixubidcbiAgICAgKiAnLi0nICAgICAgICAgICAgID0+ICdubm5uLm5uJyBvciAnbm5ubi5ubi0nXG4gICAgICogJywtJyAgICAgICAgICAgICA9PiAnbm5ubixubicgb3IgJ25ubm4sbm4tJ1xuICAgICAqIERlcHJlY2F0ZWQgb2xkZXIgb3B0aW9uIG5hbWUgOiBvdXRwdXRUeXBlXG4gICAgICovXG4gICAgb3V0cHV0Rm9ybWF0OiBudWxsLFxuXG4gICAgLyogRGVmaW5lcyBpZiB3YXJuaW5ncyBzaG91bGQgYmUgc2hvd25cbiAgICAgKiBFcnJvciBoYW5kbGluZyBmdW5jdGlvblxuICAgICAqIHRydWUgPT4gYWxsIHdhcm5pbmcgYXJlIHNob3duXG4gICAgICogZmFsc2UgPT4gbm8gd2FybmluZ3MgYXJlIHNob3duLCBvbmx5IHRoZSB0aHJvd24gZXJyb3JzXG4gICAgICogRGVwcmVjYXRlZCBvbGRlciBvcHRpb24gbmFtZSA6IGRlYnVnXG4gICAgICovXG4gICAgc2hvd1dhcm5pbmdzOiB0cnVlLFxuXG4gICAgLypcbiAgICAgKiBUaGlzIG9wdGlvbiBpcyB0aGUgJ3N0cmljdCBtb2RlJyAoYWthICdkZWJ1ZycgbW9kZSksIHdoaWNoIGFsbG93cyBhdXRvTnVtZXJpYyB0byBzdHJpY3RseSBhbmFseXNlIHRoZSBvcHRpb25zIHBhc3NlZCwgYW5kIGZhaWxzIGlmIGFuIHVua25vd24gb3B0aW9ucyBpcyB1c2VkIGluIHRoZSBzZXR0aW5ncyBvYmplY3QuXG4gICAgICogWW91IHNob3VsZCBzZXQgdGhhdCB0byAnVFJVRScgaWYgeW91IHdhbnQgdG8gbWFrZSBzdXJlIHlvdSBhcmUgb25seSB1c2luZyAncHVyZScgYXV0b051bWVyaWMgc2V0dGluZ3Mgb2JqZWN0cyBpbiB5b3VyIGNvZGUuXG4gICAgICogSWYgeW91IHNlZSB1bmNhdWdodCBlcnJvcnMgaW4gdGhlIGNvbnNvbGUgYW5kIHlvdXIgY29kZSBzdGFydHMgdG8gZmFpbCwgdGhpcyBtZWFucyBzb21laG93IHRob3NlIG9wdGlvbnMgZ2V0cyBjb3JydXB0ZWQgYnkgYW5vdGhlciBwcm9ncmFtLlxuICAgICAqL1xuICAgIGZhaWxPblVua25vd25PcHRpb246IGZhbHNlLFxufTtcblxuLyoqXG4gKiBXcmFwcGVyIHZhcmlhYmxlIHRoYXQgaG9sZCBuYW1lZCBrZXlib2FyZCBrZXlzIHdpdGggdGhlaXIgcmVzcGVjdGl2ZSBrZXlDb2RlIGFzIHNlZW4gaW4gRE9NIGV2ZW50cy5cbiAqIC8vVE9ETyBSZXBsYWNlIGV2ZXJ5IGNhbGwgdG8gdGhpcyBvYmplY3Qgd2l0aCBhIGNhbGwgdG8gYGtleU5hbWVgXG4gKiBAZGVwcmVjYXRlZFxuICovXG5jb25zdCBrZXlDb2RlID0ge1xuICAgIEJhY2tzcGFjZTogICAgICA4LFxuICAgIFRhYjogICAgICAgICAgICA5LFxuICAgIEVudGVyOiAgICAgICAgICAxMyxcbiAgICBTaGlmdDogICAgICAgICAgMTYsXG4gICAgQ3RybDogICAgICAgICAgIDE3LFxuICAgIEFsdDogICAgICAgICAgICAxOCxcbiAgICBQYXVzZUJyZWFrOiAgICAgMTksXG4gICAgQ2Fwc0xvY2s6ICAgICAgIDIwLFxuICAgIEVzYzogICAgICAgICAgICAyNyxcbiAgICBTcGFjZTogICAgICAgICAgMzIsXG4gICAgUGFnZVVwOiAgICAgICAgIDMzLFxuICAgIFBhZ2VEb3duOiAgICAgICAzNCxcbiAgICBFbmQ6ICAgICAgICAgICAgMzUsXG4gICAgSG9tZTogICAgICAgICAgIDM2LFxuICAgIExlZnRBcnJvdzogICAgICAzNyxcbiAgICBVcEFycm93OiAgICAgICAgMzgsXG4gICAgUmlnaHRBcnJvdzogICAgIDM5LFxuICAgIERvd25BcnJvdzogICAgICA0MCxcbiAgICBJbnNlcnQ6ICAgICAgICAgNDUsXG4gICAgRGVsZXRlOiAgICAgICAgIDQ2LFxuICAgIG51bTA6ICAgICAgICAgICA0OCxcbiAgICBudW0xOiAgICAgICAgICAgNDksXG4gICAgbnVtMjogICAgICAgICAgIDUwLFxuICAgIG51bTM6ICAgICAgICAgICA1MSxcbiAgICBudW00OiAgICAgICAgICAgNTIsXG4gICAgbnVtNTogICAgICAgICAgIDUzLFxuICAgIG51bTY6ICAgICAgICAgICA1NCxcbiAgICBudW03OiAgICAgICAgICAgNTUsXG4gICAgbnVtODogICAgICAgICAgIDU2LFxuICAgIG51bTk6ICAgICAgICAgICA1NyxcbiAgICBhOiAgICAgICAgICAgICAgNjUsXG4gICAgYjogICAgICAgICAgICAgIDY2LFxuICAgIGM6ICAgICAgICAgICAgICA2NyxcbiAgICBkOiAgICAgICAgICAgICAgNjgsXG4gICAgZTogICAgICAgICAgICAgIDY5LFxuICAgIGY6ICAgICAgICAgICAgICA3MCxcbiAgICBnOiAgICAgICAgICAgICAgNzEsXG4gICAgaDogICAgICAgICAgICAgIDcyLFxuICAgIGk6ICAgICAgICAgICAgICA3MyxcbiAgICBqOiAgICAgICAgICAgICAgNzQsXG4gICAgazogICAgICAgICAgICAgIDc1LFxuICAgIGw6ICAgICAgICAgICAgICA3NixcbiAgICBtOiAgICAgICAgICAgICAgNzcsXG4gICAgbjogICAgICAgICAgICAgIDc4LFxuICAgIG86ICAgICAgICAgICAgICA3OSxcbiAgICBwOiAgICAgICAgICAgICAgODAsXG4gICAgcTogICAgICAgICAgICAgIDgxLFxuICAgIHI6ICAgICAgICAgICAgICA4MixcbiAgICBzOiAgICAgICAgICAgICAgODMsXG4gICAgdDogICAgICAgICAgICAgIDg0LFxuICAgIHU6ICAgICAgICAgICAgICA4NSxcbiAgICB2OiAgICAgICAgICAgICAgODYsXG4gICAgdzogICAgICAgICAgICAgIDg3LFxuICAgIHg6ICAgICAgICAgICAgICA4OCxcbiAgICB5OiAgICAgICAgICAgICAgODksXG4gICAgejogICAgICAgICAgICAgIDkwLFxuICAgIFdpbmRvd3M6ICAgICAgICA5MSxcbiAgICBSaWdodENsaWNrOiAgICAgOTMsXG4gICAgbnVtcGFkMDogICAgICAgIDk2LFxuICAgIG51bXBhZDE6ICAgICAgICA5NyxcbiAgICBudW1wYWQyOiAgICAgICAgOTgsXG4gICAgbnVtcGFkMzogICAgICAgIDk5LFxuICAgIG51bXBhZDQ6ICAgICAgICAxMDAsXG4gICAgbnVtcGFkNTogICAgICAgIDEwMSxcbiAgICBudW1wYWQ2OiAgICAgICAgMTAyLFxuICAgIG51bXBhZDc6ICAgICAgICAxMDMsXG4gICAgbnVtcGFkODogICAgICAgIDEwNCxcbiAgICBudW1wYWQ5OiAgICAgICAgMTA1LFxuICAgIE11bHRpcGx5TnVtcGFkOiAxMDYsXG4gICAgUGx1c051bXBhZDogICAgIDEwNyxcbiAgICBNaW51c051bXBhZDogICAgMTA5LFxuICAgIERvdE51bXBhZDogICAgICAxMTAsXG4gICAgU2xhc2hOdW1wYWQ6ICAgIDExMSxcbiAgICBGMTogICAgICAgICAgICAgMTEyLFxuICAgIEYyOiAgICAgICAgICAgICAxMTMsXG4gICAgRjM6ICAgICAgICAgICAgIDExNCxcbiAgICBGNDogICAgICAgICAgICAgMTE1LFxuICAgIEY1OiAgICAgICAgICAgICAxMTYsXG4gICAgRjY6ICAgICAgICAgICAgIDExNyxcbiAgICBGNzogICAgICAgICAgICAgMTE4LFxuICAgIEY4OiAgICAgICAgICAgICAxMTksXG4gICAgRjk6ICAgICAgICAgICAgIDEyMCxcbiAgICBGMTA6ICAgICAgICAgICAgMTIxLFxuICAgIEYxMTogICAgICAgICAgICAxMjIsXG4gICAgRjEyOiAgICAgICAgICAgIDEyMyxcbiAgICBOdW1Mb2NrOiAgICAgICAgMTQ0LFxuICAgIFNjcm9sbExvY2s6ICAgICAxNDUsXG4gICAgTXlDb21wdXRlcjogICAgIDE4MixcbiAgICBNeUNhbGN1bGF0b3I6ICAgMTgzLFxuICAgIFNlbWljb2xvbjogICAgICAxODYsXG4gICAgRXF1YWw6ICAgICAgICAgIDE4NyxcbiAgICBDb21tYTogICAgICAgICAgMTg4LFxuICAgIEh5cGhlbjogICAgICAgICAxODksXG4gICAgRG90OiAgICAgICAgICAgIDE5MCxcbiAgICBTbGFzaDogICAgICAgICAgMTkxLFxuICAgIEJhY2txdW90ZTogICAgICAxOTIsXG4gICAgTGVmdEJyYWNrZXQ6ICAgIDIxOSxcbiAgICBCYWNrc2xhc2g6ICAgICAgMjIwLFxuICAgIFJpZ2h0QnJhY2tldDogICAyMjEsXG4gICAgUXVvdGU6ICAgICAgICAgIDIyMixcbiAgICBDb21tYW5kOiAgICAgICAgMjI0LFxufTtcblxuLyoqXG4gKiBXcmFwcGVyIHZhcmlhYmxlIHRoYXQgaG9sZCBuYW1lZCBrZXlib2FyZCBrZXlzIHdpdGggdGhlaXIgcmVzcGVjdGl2ZSBrZXkgbmFtZSAoYXMgc2V0IGluIEtleWJvYXJkRXZlbnQua2V5KS5cbiAqIFRob3NlIG5hbWVzIGFyZSBsaXN0ZWQgaGVyZSA6XG4gKiBAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvS2V5Ym9hcmRFdmVudC9rZXkvS2V5X1ZhbHVlc1xuICovXG5jb25zdCBrZXlOYW1lID0ge1xuICAgIC8vIFNwZWNpYWwgdmFsdWVzXG4gICAgVW5pZGVudGlmaWVkOiAgICdVbmlkZW50aWZpZWQnLFxuXG4gICAgLy8gTW9kaWZpZXIga2V5c1xuICAgIEFsdDogICAgICAgICAgICAnQWx0JyxcbiAgICBBbHRHcjogICAgICAgICAgJ0FsdEdyYXBoJyxcbiAgICBDYXBzTG9jazogICAgICAgJ0NhcHNMb2NrJywgLy8gVW5kZXIgQ2hyb21lLCBlLmtleSBpcyBlbXB0eSBmb3IgQ2Fwc0xvY2tcbiAgICBDdHJsOiAgICAgICAgICAgJ0NvbnRyb2wnLFxuICAgIEZuOiAgICAgICAgICAgICAnRm4nLFxuICAgIEZuTG9jazogICAgICAgICAnRm5Mb2NrJyxcbiAgICBIeXBlcjogICAgICAgICAgJ0h5cGVyJywgLy8gJ09TJyB1bmRlciBGaXJlZm94XG4gICAgTWV0YTogICAgICAgICAgICdNZXRhJywgLy8gVGhlIFdpbmRvd3MsIENvbW1hbmQgb3Ig4oyYIGtleSAvLyAnT1MnIHVuZGVyIEZpcmVmb3ggYW5kIElFOVxuICAgIFdpbmRvd3M6ICAgICAgICAnTWV0YScsIC8vIFRoaXMgaXMgYSBub24tb2ZmaWNpYWwga2V5IG5hbWVcbiAgICBDb21tYW5kOiAgICAgICAgJ01ldGEnLCAvLyBUaGlzIGlzIGEgbm9uLW9mZmljaWFsIGtleSBuYW1lXG4gICAgTnVtTG9jazogICAgICAgICdOdW1Mb2NrJyxcbiAgICBTY3JvbGxMb2NrOiAgICAgJ1Njcm9sbExvY2snLFxuICAgIFNoaWZ0OiAgICAgICAgICAnU2hpZnQnLFxuICAgIFN1cGVyOiAgICAgICAgICAnU3VwZXInLCAvLyAnT1MnIHVuZGVyIEZpcmVmb3hcbiAgICBTeW1ib2w6ICAgICAgICAgJ1N5bWJvbCcsXG4gICAgU3ltYm9sTG9jazogICAgICdTeW1ib2xMb2NrJyxcblxuICAgIC8vIFdoaXRlc3BhY2Uga2V5c1xuICAgIEVudGVyOiAgICAgICAgICAnRW50ZXInLFxuICAgIFRhYjogICAgICAgICAgICAnVGFiJyxcbiAgICBTcGFjZTogICAgICAgICAgJyAnLCAvLyAnU3BhY2ViYXInIGZvciBGaXJlZm94IDwzNywgYW5kIElFOVxuXG4gICAgLy8gTmF2aWdhdGlvbiBrZXlzXG4gICAgRG93bkFycm93OiAgICAgICdBcnJvd0Rvd24nLCAvLyAnRG93bicgZm9yIEZpcmVmb3ggPD0zNiwgYW5kIElFOVxuICAgIExlZnRBcnJvdzogICAgICAnQXJyb3dMZWZ0JywgLy8gJ0xlZnQnIGZvciBGaXJlZm94IDw9MzYsIGFuZCBJRTlcbiAgICBSaWdodEFycm93OiAgICAgJ0Fycm93UmlnaHQnLCAvLyAnUmlnaHQnIGZvciBGaXJlZm94IDw9MzYsIGFuZCBJRTlcbiAgICBVcEFycm93OiAgICAgICAgJ0Fycm93VXAnLCAvLyAnVXAnIGZvciBGaXJlZm94IDw9MzYsIGFuZCBJRTlcbiAgICBFbmQ6ICAgICAgICAgICAgJ0VuZCcsXG4gICAgSG9tZTogICAgICAgICAgICdIb21lJyxcbiAgICBQYWdlRG93bjogICAgICAgJ1BhZ2VEb3duJyxcbiAgICBQYWdlVXA6ICAgICAgICAgJ1BhZ2VVcCcsXG5cbiAgICAvLyBFZGl0aW5nIGtleXNcbiAgICBCYWNrc3BhY2U6ICAgICAgJ0JhY2tzcGFjZScsXG4gICAgQ2xlYXI6ICAgICAgICAgICdDbGVhcicsXG4gICAgQ29weTogICAgICAgICAgICdDb3B5JyxcbiAgICBDclNlbDogICAgICAgICAgJ0NyU2VsJywgLy8gJ0Nyc2VsJyBmb3IgRmlyZWZveCA8PTM2LCBhbmQgSUU5XG4gICAgQ3V0OiAgICAgICAgICAgICdDdXQnLFxuICAgIERlbGV0ZTogICAgICAgICAnRGVsZXRlJywgLy8gJ0RlbCcgZm9yIEZpcmVmb3ggPD0zNiwgYW5kIElFOVxuICAgIEVyYXNlRW9mOiAgICAgICAnRXJhc2VFb2YnLFxuICAgIEV4U2VsOiAgICAgICAgICAnRXhTZWwnLCAvLyAnRXhzZWwnIGZvciBGaXJlZm94IDw9MzYsIGFuZCBJRTlcbiAgICBJbnNlcnQ6ICAgICAgICAgJ0luc2VydCcsXG4gICAgUGFzdGU6ICAgICAgICAgICdQYXN0ZScsXG4gICAgUmVkbzogICAgICAgICAgICdSZWRvJyxcbiAgICBVbmRvOiAgICAgICAgICAgJ1VuZG8nLFxuXG4gICAgLy8gVUkga2V5c1xuICAgIEFjY2VwdDogICAgICAgICAnQWNjZXB0JyxcbiAgICBBZ2FpbjogICAgICAgICAgJ0FnYWluJyxcbiAgICBBdHRuOiAgICAgICAgICAgJ0F0dG4nLCAvLyAnVW5pZGVudGlmaWVkJyBmb3IgRmlyZWZveCwgQ2hyb21lLCBhbmQgSUU5ICgnS2FuYU1vZGUnIHdoZW4gdXNpbmcgdGhlIEphcGFuZXNlIGtleWJvYXJkIGxheW91dClcbiAgICBDYW5jZWw6ICAgICAgICAgJ0NhbmNlbCcsXG4gICAgQ29udGV4dE1lbnU6ICAgICdDb250ZXh0TWVudScsIC8vICdBcHBzJyBmb3IgRmlyZWZveCA8PTM2LCBhbmQgSUU5XG4gICAgRXNjOiAgICAgICAgICAgICdFc2NhcGUnLCAvLyAnRXNjJyBmb3IgRmlyZWZveCA8PTM2LCBhbmQgSUU5XG4gICAgRXhlY3V0ZTogICAgICAgICdFeGVjdXRlJyxcbiAgICBGaW5kOiAgICAgICAgICAgJ0ZpbmQnLFxuICAgIEZpbmlzaDogICAgICAgICAnRmluaXNoJywgLy8gJ1VuaWRlbnRpZmllZCcgZm9yIEZpcmVmb3gsIENocm9tZSwgYW5kIElFOSAoJ0thdGFrYW5hJyB3aGVuIHVzaW5nIHRoZSBKYXBhbmVzZSBrZXlib2FyZCBsYXlvdXQpXG4gICAgSGVscDogICAgICAgICAgICdIZWxwJyxcbiAgICBQYXVzZTogICAgICAgICAgJ1BhdXNlJyxcbiAgICBQbGF5OiAgICAgICAgICAgJ1BsYXknLFxuICAgIFByb3BzOiAgICAgICAgICAnUHJvcHMnLFxuICAgIFNlbGVjdDogICAgICAgICAnU2VsZWN0JyxcbiAgICBab29tSW46ICAgICAgICAgJ1pvb21JbicsXG4gICAgWm9vbU91dDogICAgICAgICdab29tT3V0JyxcblxuICAgIC8vIERldmljZSBrZXlzXG4gICAgQnJpZ2h0bmVzc0Rvd246ICdCcmlnaHRuZXNzRG93bicsXG4gICAgQnJpZ2h0bmVzc1VwOiAgICdCcmlnaHRuZXNzVXAnLFxuICAgIEVqZWN0OiAgICAgICAgICAnRWplY3QnLFxuICAgIExvZ09mZjogICAgICAgICAnTG9nT2ZmJyxcbiAgICBQb3dlcjogICAgICAgICAgJ1Bvd2VyJyxcbiAgICBQb3dlck9mZjogICAgICAgJ1Bvd2VyT2ZmJyxcbiAgICBQcmludFNjcmVlbjogICAgJ1ByaW50U2NyZWVuJyxcbiAgICBIaWJlcm5hdGU6ICAgICAgJ0hpYmVybmF0ZScsIC8vICdVbmlkZW50aWZpZWQnIGZvciBGaXJlZm94IDw9MzdcbiAgICBTdGFuZGJ5OiAgICAgICAgJ1N0YW5kYnknLCAvLyAnVW5pZGVudGlmaWVkJyBmb3IgRmlyZWZveCA8PTM2LCBhbmQgSUU5XG4gICAgV2FrZVVwOiAgICAgICAgICdXYWtlVXAnLFxuXG4gICAgLy8gSU1FIGFuZCBjb21wb3NpdGlvbiBrZXlzXG4gICAgQ29tcG9zZTogICAgICAgICdDb21wb3NlJyxcbiAgICBEZWFkOiAgICAgICAgICAgJ0RlYWQnLFxuXG4gICAgLy8gRnVuY3Rpb24ga2V5c1xuICAgIEYxOiAgICAgICAgICAgICAnRjEnLFxuICAgIEYyOiAgICAgICAgICAgICAnRjInLFxuICAgIEYzOiAgICAgICAgICAgICAnRjMnLFxuICAgIEY0OiAgICAgICAgICAgICAnRjQnLFxuICAgIEY1OiAgICAgICAgICAgICAnRjUnLFxuICAgIEY2OiAgICAgICAgICAgICAnRjYnLFxuICAgIEY3OiAgICAgICAgICAgICAnRjcnLFxuICAgIEY4OiAgICAgICAgICAgICAnRjgnLFxuICAgIEY5OiAgICAgICAgICAgICAnRjknLFxuICAgIEYxMDogICAgICAgICAgICAnRjEwJyxcbiAgICBGMTE6ICAgICAgICAgICAgJ0YxMScsXG4gICAgRjEyOiAgICAgICAgICAgICdGMTInLFxuXG4gICAgLy8gRG9jdW1lbnQga2V5c1xuICAgIFByaW50OiAgICAgICAgICAnUHJpbnQnLFxuXG4gICAgLy8gJ05vcm1hbCcga2V5c1xuICAgIG51bTA6ICAgICAgICAgICAnMCcsXG4gICAgbnVtMTogICAgICAgICAgICcxJyxcbiAgICBudW0yOiAgICAgICAgICAgJzInLFxuICAgIG51bTM6ICAgICAgICAgICAnMycsXG4gICAgbnVtNDogICAgICAgICAgICc0JyxcbiAgICBudW01OiAgICAgICAgICAgJzUnLFxuICAgIG51bTY6ICAgICAgICAgICAnNicsXG4gICAgbnVtNzogICAgICAgICAgICc3JyxcbiAgICBudW04OiAgICAgICAgICAgJzgnLFxuICAgIG51bTk6ICAgICAgICAgICAnOScsXG4gICAgbnVtcGFkMDogICAgICAgICcwJyxcbiAgICBudW1wYWQxOiAgICAgICAgJzEnLFxuICAgIG51bXBhZDI6ICAgICAgICAnMicsXG4gICAgbnVtcGFkMzogICAgICAgICczJyxcbiAgICBudW1wYWQ0OiAgICAgICAgJzQnLFxuICAgIG51bXBhZDU6ICAgICAgICAnNScsXG4gICAgbnVtcGFkNjogICAgICAgICc2JyxcbiAgICBudW1wYWQ3OiAgICAgICAgJzcnLFxuICAgIG51bXBhZDg6ICAgICAgICAnOCcsXG4gICAgbnVtcGFkOTogICAgICAgICc5JyxcbiAgICBhOiAgICAgICAgICAgICAgJ2EnLFxuICAgIGI6ICAgICAgICAgICAgICAnYicsXG4gICAgYzogICAgICAgICAgICAgICdjJyxcbiAgICBkOiAgICAgICAgICAgICAgJ2QnLFxuICAgIGU6ICAgICAgICAgICAgICAnZScsXG4gICAgZjogICAgICAgICAgICAgICdmJyxcbiAgICBnOiAgICAgICAgICAgICAgJ2cnLFxuICAgIGg6ICAgICAgICAgICAgICAnaCcsXG4gICAgaTogICAgICAgICAgICAgICdpJyxcbiAgICBqOiAgICAgICAgICAgICAgJ2onLFxuICAgIGs6ICAgICAgICAgICAgICAnaycsXG4gICAgbDogICAgICAgICAgICAgICdsJyxcbiAgICBtOiAgICAgICAgICAgICAgJ20nLFxuICAgIG46ICAgICAgICAgICAgICAnbicsXG4gICAgbzogICAgICAgICAgICAgICdvJyxcbiAgICBwOiAgICAgICAgICAgICAgJ3AnLFxuICAgIHE6ICAgICAgICAgICAgICAncScsXG4gICAgcjogICAgICAgICAgICAgICdyJyxcbiAgICBzOiAgICAgICAgICAgICAgJ3MnLFxuICAgIHQ6ICAgICAgICAgICAgICAndCcsXG4gICAgdTogICAgICAgICAgICAgICd1JyxcbiAgICB2OiAgICAgICAgICAgICAgJ3YnLFxuICAgIHc6ICAgICAgICAgICAgICAndycsXG4gICAgeDogICAgICAgICAgICAgICd4JyxcbiAgICB5OiAgICAgICAgICAgICAgJ3knLFxuICAgIHo6ICAgICAgICAgICAgICAneicsXG4gICAgTXVsdGlwbHlOdW1wYWQ6ICcqJyxcbiAgICBQbHVzTnVtcGFkOiAgICAgJysnLFxuICAgIE1pbnVzTnVtcGFkOiAgICAnLScsXG4gICAgRG90TnVtcGFkOiAgICAgICcuJyxcbiAgICBTbGFzaE51bXBhZDogICAgJy8nLFxuICAgIFNlbWljb2xvbjogICAgICAnOycsXG4gICAgRXF1YWw6ICAgICAgICAgICc9JyxcbiAgICBDb21tYTogICAgICAgICAgJywnLFxuICAgIEh5cGhlbjogICAgICAgICAnLScsXG4gICAgTWludXM6ICAgICAgICAgICctJyxcbiAgICBQbHVzOiAgICAgICAgICAgJysnLFxuICAgIERvdDogICAgICAgICAgICAnLicsXG4gICAgU2xhc2g6ICAgICAgICAgICcvJyxcbiAgICBCYWNrcXVvdGU6ICAgICAgJ2AnLFxuICAgIExlZnRCcmFja2V0OiAgICAnWycsXG4gICAgUmlnaHRCcmFja2V0OiAgICddJyxcbiAgICBCYWNrc2xhc2g6ICAgICAgJ1xcXFwnLFxuICAgIFF1b3RlOiAgICAgICAgICBcIidcIixcbiAgICBOdW1wYWREb3Q6ICAgICAgJy4nLFxuICAgIE51bXBhZERvdEFsdDogICAnLCcsIC8vIE1vZGVybiBicm93c2VycyBhdXRvbWF0aWNhbGx5IGFkYXB0IHRoZSBjaGFyYWN0ZXIgc2VudCBieSB0aGlzIGtleSB0byB0aGUgZGVjaW1hbCBjaGFyYWN0ZXIgb2YgdGhlIGN1cnJlbnQgbGFuZ3VhZ2VcbiAgICBOdW1wYWRNdWx0aXBseTogJyonLFxuICAgIE51bXBhZFBsdXM6ICAgICAnKycsXG4gICAgTnVtcGFkTWludXM6ICAgICctJyxcbiAgICBOdW1wYWRTbGFzaDogICAgJy8nLFxuICAgIE51bXBhZERvdE9ic29sZXRlQnJvd3NlcnM6ICAgICAgJ0RlY2ltYWwnLFxuICAgIE51bXBhZE11bHRpcGx5T2Jzb2xldGVCcm93c2VyczogJ011bHRpcGx5JyxcbiAgICBOdW1wYWRQbHVzT2Jzb2xldGVCcm93c2VyczogICAgICdBZGQnLFxuICAgIE51bXBhZE1pbnVzT2Jzb2xldGVCcm93c2VyczogICAgJ1N1YnRyYWN0JyxcbiAgICBOdW1wYWRTbGFzaE9ic29sZXRlQnJvd3NlcnM6ICAgICdEaXZpZGUnLFxufTtcblxuY29uc3QgZGVmYXVsdE1pbmltdW1WYWx1ZSAgICAgPSAnLTk5OTk5OTk5OTk5OS45OSc7XG5jb25zdCBkZWZhdWx0TWF4aW11bVZhbHVlICAgICA9ICc5OTk5OTk5OTk5OTkuOTknO1xuY29uc3QgZGVmYXVsdFJvdW5kaW5nTWV0aG9kICAgPSAnVSc7XG5jb25zdCBkZWZhdWx0TGVhZGluZ1plcm8gICAgICA9ICdkZW55JztcbmNvbnN0IGRlZmF1bHRTZWxlY3ROdW1iZXJPbmx5ID0gdHJ1ZTtcblxuLyoqXG4gKiBQcmVkZWZpbmVkIG9wdGlvbnMgZm9yIHRoZSBtb3N0IGNvbW1vbiBsYW5ndWFnZXNcbiAqL1xuY29uc3QgbGFuZ3VhZ2VPcHRpb24gPSB7XG4gICAgRnJlbmNoOiB7IC8vIEZyYW7Dp2Fpc1xuICAgICAgICBkaWdpdEdyb3VwU2VwYXJhdG9yICAgICAgICA6ICcuJywgLy8gb3IgJ1xcdTIwMmYnXG4gICAgICAgIGRlY2ltYWxDaGFyYWN0ZXIgICAgICAgICAgIDogJywnLFxuICAgICAgICBkZWNpbWFsQ2hhcmFjdGVyQWx0ZXJuYXRpdmU6ICcuJyxcbiAgICAgICAgY3VycmVuY3lTeW1ib2wgICAgICAgICAgICAgOiAnXFx1MjAyZuKCrCcsXG4gICAgICAgIGN1cnJlbmN5U3ltYm9sUGxhY2VtZW50ICAgIDogJ3MnLFxuICAgICAgICBzZWxlY3ROdW1iZXJPbmx5ICAgICAgICAgICA6IGRlZmF1bHRTZWxlY3ROdW1iZXJPbmx5LFxuICAgICAgICByb3VuZGluZ01ldGhvZCAgICAgICAgICAgICA6IGRlZmF1bHRSb3VuZGluZ01ldGhvZCxcbiAgICAgICAgbGVhZGluZ1plcm8gICAgICAgICAgICAgICAgOiBkZWZhdWx0TGVhZGluZ1plcm8sXG4gICAgICAgIG1pbmltdW1WYWx1ZSAgICAgICAgICAgICAgIDogZGVmYXVsdE1pbmltdW1WYWx1ZSxcbiAgICAgICAgbWF4aW11bVZhbHVlICAgICAgICAgICAgICAgOiBkZWZhdWx0TWF4aW11bVZhbHVlLFxuICAgIH0sXG4gICAgTm9ydGhBbWVyaWNhbjoge1xuICAgICAgICBkaWdpdEdyb3VwU2VwYXJhdG9yICAgIDogJywnLFxuICAgICAgICBkZWNpbWFsQ2hhcmFjdGVyICAgICAgIDogJy4nLFxuICAgICAgICBjdXJyZW5jeVN5bWJvbCAgICAgICAgIDogJyQnLFxuICAgICAgICBjdXJyZW5jeVN5bWJvbFBsYWNlbWVudDogJ3AnLFxuICAgICAgICBzZWxlY3ROdW1iZXJPbmx5ICAgICAgIDogZGVmYXVsdFNlbGVjdE51bWJlck9ubHksXG4gICAgICAgIHJvdW5kaW5nTWV0aG9kICAgICAgICAgOiBkZWZhdWx0Um91bmRpbmdNZXRob2QsXG4gICAgICAgIGxlYWRpbmdaZXJvICAgICAgICAgICAgOiBkZWZhdWx0TGVhZGluZ1plcm8sXG4gICAgICAgIG1pbmltdW1WYWx1ZSAgICAgICAgICAgOiBkZWZhdWx0TWluaW11bVZhbHVlLFxuICAgICAgICBtYXhpbXVtVmFsdWUgICAgICAgICAgIDogZGVmYXVsdE1heGltdW1WYWx1ZSxcbiAgICB9LFxuICAgIEJyaXRpc2g6IHtcbiAgICAgICAgZGlnaXRHcm91cFNlcGFyYXRvciAgICA6ICcsJyxcbiAgICAgICAgZGVjaW1hbENoYXJhY3RlciAgICAgICA6ICcuJyxcbiAgICAgICAgY3VycmVuY3lTeW1ib2wgICAgICAgICA6ICfCoycsXG4gICAgICAgIGN1cnJlbmN5U3ltYm9sUGxhY2VtZW50OiAncCcsXG4gICAgICAgIHNlbGVjdE51bWJlck9ubHkgICAgICAgOiBkZWZhdWx0U2VsZWN0TnVtYmVyT25seSxcbiAgICAgICAgcm91bmRpbmdNZXRob2QgICAgICAgICA6IGRlZmF1bHRSb3VuZGluZ01ldGhvZCxcbiAgICAgICAgbGVhZGluZ1plcm8gICAgICAgICAgICA6IGRlZmF1bHRMZWFkaW5nWmVybyxcbiAgICAgICAgbWluaW11bVZhbHVlICAgICAgICAgICA6IGRlZmF1bHRNaW5pbXVtVmFsdWUsXG4gICAgICAgIG1heGltdW1WYWx1ZSAgICAgICAgICAgOiBkZWZhdWx0TWF4aW11bVZhbHVlLFxuICAgIH0sXG4gICAgU3dpc3M6IHsgLy8gU3Vpc3NlXG4gICAgICAgIGRpZ2l0R3JvdXBTZXBhcmF0b3IgICAgOiBgJ2AsXG4gICAgICAgIGRlY2ltYWxDaGFyYWN0ZXIgICAgICAgOiAnLicsXG4gICAgICAgIGN1cnJlbmN5U3ltYm9sICAgICAgICAgOiAnXFx1MjAyZkNIRicsXG4gICAgICAgIGN1cnJlbmN5U3ltYm9sUGxhY2VtZW50OiAncycsXG4gICAgICAgIHNlbGVjdE51bWJlck9ubHkgICAgICAgOiBkZWZhdWx0U2VsZWN0TnVtYmVyT25seSxcbiAgICAgICAgcm91bmRpbmdNZXRob2QgICAgICAgICA6IGRlZmF1bHRSb3VuZGluZ01ldGhvZCxcbiAgICAgICAgbGVhZGluZ1plcm8gICAgICAgICAgICA6IGRlZmF1bHRMZWFkaW5nWmVybyxcbiAgICAgICAgbWluaW11bVZhbHVlICAgICAgICAgICA6IGRlZmF1bHRNaW5pbXVtVmFsdWUsXG4gICAgICAgIG1heGltdW1WYWx1ZSAgICAgICAgICAgOiBkZWZhdWx0TWF4aW11bVZhbHVlLFxuICAgIH0sXG4gICAgSmFwYW5lc2U6IHsgLy8g5pel5pys6KqeXG4gICAgICAgIGRpZ2l0R3JvdXBTZXBhcmF0b3IgICAgOiAnLCcsXG4gICAgICAgIGRlY2ltYWxDaGFyYWN0ZXIgICAgICAgOiAnLicsXG4gICAgICAgIGN1cnJlbmN5U3ltYm9sICAgICAgICAgOiAnwqUnLFxuICAgICAgICBjdXJyZW5jeVN5bWJvbFBsYWNlbWVudDogJ3AnLFxuICAgICAgICBzZWxlY3ROdW1iZXJPbmx5ICAgICAgIDogZGVmYXVsdFNlbGVjdE51bWJlck9ubHksXG4gICAgICAgIHJvdW5kaW5nTWV0aG9kICAgICAgICAgOiBkZWZhdWx0Um91bmRpbmdNZXRob2QsXG4gICAgICAgIGxlYWRpbmdaZXJvICAgICAgICAgICAgOiBkZWZhdWx0TGVhZGluZ1plcm8sXG4gICAgICAgIG1pbmltdW1WYWx1ZSAgICAgICAgICAgOiBkZWZhdWx0TWluaW11bVZhbHVlLFxuICAgICAgICBtYXhpbXVtVmFsdWUgICAgICAgICAgIDogZGVmYXVsdE1heGltdW1WYWx1ZSxcbiAgICB9LFxufTtcbmxhbmd1YWdlT3B0aW9uLlNwYW5pc2ggPSBsYW5ndWFnZU9wdGlvbi5GcmVuY2g7IC8vIEVzcGHDsW9sIChpZGVtIEZyZW5jaClcbmxhbmd1YWdlT3B0aW9uLkNoaW5lc2UgPSBsYW5ndWFnZU9wdGlvbi5KYXBhbmVzZTsgLy8g5Lit5Zu96KqeIChDaGluZXNlKVxuXG4vKipcbiAqIFVNRCBzdHJ1Y3R1cmVcbiAqL1xuKGZ1bmN0aW9uKGZhY3RvcnkpIHtcbiAgICAvL1RPRE8gVGhpcyBzdXJlbHkgY2FuIGJlIGltcHJvdmVkIGJ5IGxldHRpbmcgd2VicGFjayB0YWtlIGNhcmUgb2YgZ2VuZXJhdGluZyB0aGlzIFVNRCBwYXJ0XG5pZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgICAgIC8vIEFNRC4gUmVnaXN0ZXIgYXMgYW4gYW5vbnltb3VzIG1vZHVsZS5cbiAgICBkZWZpbmUoWydqcXVlcnknXSwgZmFjdG9yeSk7XG59IGVsc2UgaWYgKHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gICAgICAgIC8vIE5vZGUvQ29tbW9uSlNcbiAgICBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkocmVxdWlyZSgnanF1ZXJ5JykpO1xufSBlbHNlIHtcbiAgICAgICAgLy8gQnJvd3NlciBnbG9iYWxzXG4gICAgZmFjdG9yeSh3aW5kb3cualF1ZXJ5KTtcbn1cbn0oJCA9PiB7XG4gICAgLy8gSGVscGVyIGZ1bmN0aW9uc1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIFRSVUUgaWYgdGhlIGB2YWx1ZWAgaXMgbnVsbFxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHRlc3RcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJuIFRSVUUgaWYgdGhlIGB2YWx1ZWAgaXMgbnVsbCwgRkFMU0Ugb3RoZXJ3aXNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNOdWxsKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSA9PT0gbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gVFJVRSBpZiB0aGUgYHZhbHVlYCBpcyB1bmRlZmluZWRcbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byB0ZXN0XG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybiBUUlVFIGlmIHRoZSBgdmFsdWVgIGlzIHVuZGVmaW5lZCwgRkFMU0Ugb3RoZXJ3aXNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNVbmRlZmluZWQodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlID09PSB2b2lkKDApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybiBUUlVFIGlmIHRoZSBgdmFsdWVgIGlzIHVuZGVmaW5lZCwgbnVsbCBvciBlbXB0eVxuICAgICAqXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzVW5kZWZpbmVkT3JOdWxsT3JFbXB0eSh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHZvaWQoMCkgfHwgJycgPT09IHZhbHVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybiBUUlVFIGlmIHRoZSBnaXZlbiBwYXJhbWV0ZXIgaXMgYSBTdHJpbmdcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Kn0gc3RyXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNTdHJpbmcoc3RyKSB7XG4gICAgICAgIHJldHVybiAodHlwZW9mIHN0ciA9PT0gJ3N0cmluZycgfHwgc3RyIGluc3RhbmNlb2YgU3RyaW5nKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gVFJVRSBpZiB0aGUgcGFyYW1ldGVyIGlzIGEgYm9vbGVhblxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0Jvb2xlYW4odmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZih2YWx1ZSkgPT09ICdib29sZWFuJztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gVFJVRSBpZiB0aGUgcGFyYW1ldGVyIGlzIGEgc3RyaW5nICd0cnVlJyBvciAnZmFsc2UnXG4gICAgICpcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIGFjY2VwdHMgYW55IGNhc2VzIGZvciB0aG9zZSBzdHJpbmdzLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzVHJ1ZU9yRmFsc2VTdHJpbmcodmFsdWUpIHtcbiAgICAgICAgY29uc3QgbG93ZXJjYXNlVmFsdWUgPSBTdHJpbmcodmFsdWUpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIHJldHVybiBsb3dlcmNhc2VWYWx1ZSA9PT0gJ3RydWUnIHx8IGxvd2VyY2FzZVZhbHVlID09PSAnZmFsc2UnO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybiBUUlVFIGlmIHRoZSBwYXJhbWV0ZXIgaXMgYW4gb2JqZWN0XG4gICAgICpcbiAgICAgKiBAcGFyYW0geyp9IHJlZmVyZW5jZVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzT2JqZWN0KHJlZmVyZW5jZSkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIHJlZmVyZW5jZSA9PT0gJ29iamVjdCcgJiYgcmVmZXJlbmNlICE9PSBudWxsICYmICFBcnJheS5pc0FycmF5KHJlZmVyZW5jZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIFRSVUUgaWYgdGhlIGdpdmVuIG9iamVjdCBpcyBlbXB0eVxuICAgICAqIGNmLiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzY3OTkxNS9ob3ctZG8taS10ZXN0LWZvci1hbi1lbXB0eS1qYXZhc2NyaXB0LW9iamVjdCBhbmQgaHR0cDovL2pzcGVyZi5jb20vZW1wdHktb2JqZWN0LXRlc3RcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvYmpcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0VtcHR5T2JqKG9iaikge1xuICAgICAgICBmb3IgKGNvbnN0IHByb3AgaW4gb2JqKSB7XG4gICAgICAgICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KHByb3ApKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybiBUUlVFIGlmIHRoZSBwYXJhbWV0ZXIgaXMgYSBudW1iZXIgKG9yIGEgbnVtYmVyIHdyaXR0ZW4gYXMgYSBzdHJpbmcpLlxuICAgICAqXG4gICAgICogQHBhcmFtIHsqfSBuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNOdW1iZXIobikge1xuICAgICAgICByZXR1cm4gIWlzQXJyYXkobikgJiYgIWlzTmFOKHBhcnNlRmxvYXQobikpICYmIGlzRmluaXRlKG4pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybiBUUlVFIGlmIHRoZSBwYXJhbWV0ZXIgaXMgYW4gaW50ZWdlciAoYW5kIG5vdCBhIGZsb2F0KS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Kn0gblxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzSW50KG4pIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBuID09PSAnbnVtYmVyJyAmJiBwYXJzZUZsb2F0KG4pID09PSBwYXJzZUludChuLCAxMCkgJiYgIWlzTmFOKG4pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybiB0aGUgcGFzdGVkIHRleHQgdGhhdCB3aWxsIGJlIHVzZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dFxuICAgICAqIEBwYXJhbSB7QXV0b051bWVyaWNIb2xkZXJ9IGhvbGRlclxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd8dm9pZHxYTUx8Kn1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwcmVwYXJlUGFzdGVkVGV4dCh0ZXh0LCBob2xkZXIpIHtcbiAgICAgICAgcmV0dXJuIHN0cmlwQWxsTm9uTnVtYmVyQ2hhcmFjdGVycyh0ZXh0LCBob2xkZXIuc2V0dGluZ3NDbG9uZSwgdHJ1ZSkucmVwbGFjZShob2xkZXIuc2V0dGluZ3NDbG9uZS5kZWNpbWFsQ2hhcmFjdGVyLCAnLicpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybiBUUlVFIGlzIHRoZSBzdHJpbmcgYHN0cmAgY29udGFpbnMgdGhlIHN0cmluZyBgbmVlZGxlYFxuICAgICAqIE5vdGU6IHRoaXMgZnVuY3Rpb24gZG9lcyBub3QgY29lcmNlIHRoZSBwYXJhbWV0ZXJzIHR5cGVzXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5lZWRsZVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNvbnRhaW5zKHN0ciwgbmVlZGxlKSB7XG4gICAgICAgIGlmICghaXNTdHJpbmcoc3RyKSB8fCAhaXNTdHJpbmcobmVlZGxlKSB8fCBzdHIgPT09ICcnIHx8IG5lZWRsZSA9PT0gJycpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzdHIuaW5kZXhPZihuZWVkbGUpICE9PSAtMTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gVFJVRSBpZiB0aGUgYG5lZWRsZWAgaXMgaW4gdGhlIGFycmF5XG4gICAgICpcbiAgICAgKiBAcGFyYW0geyp9IG5lZWRsZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5XG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNJbkFycmF5KG5lZWRsZSwgYXJyYXkpIHtcbiAgICAgICAgaWYgKCFpc0FycmF5KGFycmF5KSB8fCBhcnJheSA9PT0gW10gfHwgaXNVbmRlZmluZWQobmVlZGxlKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGFycmF5LmluZGV4T2YobmVlZGxlKSAhPT0gLTE7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIFRSVUUgaWYgdGhlIHBhcmFtZXRlciBpcyBhbiBBcnJheVxuICAgICAqXG4gICAgICogQHBhcmFtIHsqfSBhcnJcbiAgICAgKiBAdGhyb3dzIEVycm9yXG4gICAgICogQHJldHVybnMgeyp8Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0FycmF5KGFycikge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKFtdKSA9PT0gJ1tvYmplY3QgQXJyYXldJykgeyAvLyBNYWtlIHN1cmUgYW4gYXJyYXkgaGFzIGEgY2xhc3MgYXR0cmlidXRlIG9mIFtvYmplY3QgQXJyYXldXG4gICAgICAgICAgICAvLyBUZXN0IHBhc3NlZCwgbm93IGNoZWNrIGlmIGlzIGFuIEFycmF5XG4gICAgICAgICAgICByZXR1cm4gQXJyYXkuaXNBcnJheShhcnIpIHx8ICh0eXBlb2YgYXJyID09PSAnb2JqZWN0JyAmJiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYXJyKSA9PT0gJ1tvYmplY3QgQXJyYXldJyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3RvU3RyaW5nIG1lc3NhZ2UgY2hhbmdlZCBmb3IgT2JqZWN0IEFycmF5Jyk7IC8vIFZlcmlmeSB0aGF0IHRoZSBzdHJpbmcgcmV0dXJuZWQgYnkgYHRvU3RyaW5nYCBkb2VzIG5vdCBjaGFuZ2UgaW4gdGhlIGZ1dHVyZSAoY2YuIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzgzNjUyMTUpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gVFJVRSBpZiB0aGUgcGFyYW1ldGVyIGlzIGEgc3RyaW5nIHRoYXQgcmVwcmVzZW50cyBhIGZsb2F0IG51bWJlciwgYW5kIHRoYXQgbnVtYmVyIGhhcyBhIGRlY2ltYWwgcGFydFxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHN0clxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIC8vIGZ1bmN0aW9uIGhhc0RlY2ltYWxzKHN0cikge1xuICAgIC8vICAgICBjb25zdCBbLCBkZWNpbWFsUGFydF0gPSBzdHIuc3BsaXQoJy4nKTtcbiAgICAvLyAgICAgcmV0dXJuICFpc1VuZGVmaW5lZChkZWNpbWFsUGFydCk7XG4gICAgLy8gfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSBudW1iZXIgb2YgZGVjaW1hbCBwbGFjZXMgaWYgdGhlIHBhcmFtZXRlciBpcyBhIHN0cmluZyB0aGF0IHJlcHJlc2VudHMgYSBmbG9hdCBudW1iZXIsIGFuZCB0aGF0IG51bWJlciBoYXMgYSBkZWNpbWFsIHBhcnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyXG4gICAgICogQHJldHVybnMge2ludH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkZWNpbWFsUGxhY2VzKHN0cikge1xuICAgICAgICBjb25zdCBbLCBkZWNpbWFsUGFydF0gPSBzdHIuc3BsaXQoJy4nKTtcbiAgICAgICAgaWYgKCFpc1VuZGVmaW5lZChkZWNpbWFsUGFydCkpIHtcbiAgICAgICAgICAgIHJldHVybiBkZWNpbWFsUGFydC5sZW5ndGg7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdGhlIGNvZGUgZm9yIHRoZSBrZXkgdXNlZCB0byBnZW5lcmF0ZSB0aGUgZ2l2ZW4gZXZlbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudFxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd8TnVtYmVyfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGtleUNvZGVOdW1iZXIoZXZlbnQpIHtcbiAgICAgICAgLy8gYGV2ZW50LmtleUNvZGVgIGFuZCBgZXZlbnQud2hpY2hgIGFyZSBkZXByZWNhdGVkLCBgS2V5Ym9hcmRFdmVudC5rZXlgIChodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvS2V5Ym9hcmRFdmVudC9rZXkpIG11c3QgYmUgdXNlZCBub3dcbiAgICAgICAgcmV0dXJuICh0eXBlb2YgZXZlbnQud2hpY2ggPT09ICd1bmRlZmluZWQnKT9ldmVudC5rZXlDb2RlOmV2ZW50LndoaWNoO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybiB0aGUgY2hhcmFjdGVyIGZyb20gdGhlIGV2ZW50IGtleSBjb2RlLlxuICAgICAqIEBleGFtcGxlIGNoYXJhY3Rlcig1MCkgPT4gJzInXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudFxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICovXG4gICAgZnVuY3Rpb24gY2hhcmFjdGVyKGV2ZW50KSB7XG4gICAgICAgIGlmICh0eXBlb2YgZXZlbnQua2V5ID09PSAndW5kZWZpbmVkJyB8fCBldmVudC5rZXkgPT09ICdVbmlkZW50aWZpZWQnKSB7XG4gICAgICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZSh0aGlzLmtleUNvZGVOdW1iZXIoZXZlbnQpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIFNwZWNpYWwgY2FzZSBmb3Igb2Jzb2xldGUgYnJvd3NlcnMgbGlrZSBJRSB0aGF0IHJldHVybiB0aGUgb2xkIG5hbWVzXG4gICAgICAgICAgICBsZXQgcmVzdWx0O1xuICAgICAgICAgICAgc3dpdGNoIChldmVudC5rZXkpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdEZWNpbWFsJzpcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0ga2V5TmFtZS5OdW1wYWREb3Q7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ011bHRpcGx5JzpcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0ga2V5TmFtZS5OdW1wYWRNdWx0aXBseTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnQWRkJzpcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0ga2V5TmFtZS5OdW1wYWRQbHVzO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdTdWJ0cmFjdCc6XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IGtleU5hbWUuTnVtcGFkTWludXM7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ0RpdmlkZSc6XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IGtleU5hbWUuTnVtcGFkU2xhc2g7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ0RlbCc6XG4gICAgICAgICAgICAgICAgICAgIC8vIFNwZWNpYWwgd29ya2Fyb3VuZCBmb3IgdGhlIG9ic29sZXRlIGJyb3dzZXIgSUUxMSB3aGljaCBvdXRwdXQgYSAnRGVsZXRlJyBrZXkgd2hlbiB1c2luZyB0aGUgbnVtcGFkICdkb3QnIG9uZSEgVGhpcyBmaXhlcyBpc3N1ZSAjNDAxIC8vRklYTUUgw6AgdGVybWluZXJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0ga2V5TmFtZS5Eb3Q7IC8vIGFzIG9mIHZlcnNpb24gMi4wLjggdGhlIGNoYXJhY3RlcigpIGZ1bmN0aW9uIGlzIG9ubHkgY2FsbGVkIG9uIGtleXByZXNzIGV2ZW50LiBUaGUgJ0RlbCcgZG9lcyBub3QgdGhyb3cgdGhlIGtleXByZXNzIGV2ZW50LlxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBldmVudC5rZXk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gVFJVRSBpZiB0aGUgZ2l2ZW4gdmFsdWUgKGEgbnVtYmVyIGFzIGEgc3RyaW5nKSBpcyB3aXRoaW4gdGhlIHJhbmdlIHNldCBpbiB0aGUgc2V0dGluZ3MgYG1pbmltdW1WYWx1ZWAgYW5kIGBtYXhpbXVtVmFsdWVgLCBGQUxTRSBvdGhlcndpc2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcGFyc2VkTWluVmFsdWUgUGFyc2VkIHZpYSB0aGUgYHBhcnNlU3RyKClgIGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHBhcnNlZE1heFZhbHVlIFBhcnNlZCB2aWEgdGhlIGBwYXJzZVN0cigpYCBmdW5jdGlvblxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNoZWNrSWZJblJhbmdlKHZhbHVlLCBwYXJzZWRNaW5WYWx1ZSwgcGFyc2VkTWF4VmFsdWUpIHtcbiAgICAgICAgY29uc3QgcGFyc2VkVmFsdWUgPSBwYXJzZVN0cih2YWx1ZSk7XG4gICAgICAgIHJldHVybiB0ZXN0TWluTWF4KHBhcnNlZE1pblZhbHVlLCBwYXJzZWRWYWx1ZSkgPiAtMSAmJiB0ZXN0TWluTWF4KHBhcnNlZE1heFZhbHVlLCBwYXJzZWRWYWx1ZSkgPCAxO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybiBUUlVFIGlmIHRoZSBnaXZlbiBzdHJpbmcgY29udGFpbnMgYSBuZWdhdGl2ZSBzaWduIDpcbiAgICAgKiAtIGV2ZXJ5d2hlcmUgaW4gdGhlIHN0cmluZyAoYnkgZGVmYXVsdCksIG9yXG4gICAgICogLSBvbiB0aGUgZmlyc3QgY2hhcmFjdGVyIG9ubHkgaWYgdGhlIGBjaGVja0V2ZXJ5d2hlcmVgIHBhcmFtZXRlciBpcyBzZXQgdG8gYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBudW1lcmljU3RyaW5nIEEgbnVtYmVyIHJlcHJlc2VudGVkIGJ5IGEgc3RyaW5nXG4gICAgICogQHBhcmFtIHtib29sZWFufSBjaGVja0V2ZXJ5d2hlcmUgSWYgVFJVRSwgdGhlbiB0aGUgbmVnYXRpdmUgc2lnbiBpcyBzZWFyY2ggZXZlcnl3aGVyZSBpbiB0aGUgbnVtZXJpYyBzdHJpbmcgKHRoaXMgaXMgbmVlZGVkIGZvciBpbnN0YW5jZSBpZiB0aGUgc3RyaW5nIGlzICcxMjM0LjU2LScpXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNOZWdhdGl2ZShudW1lcmljU3RyaW5nLCBjaGVja0V2ZXJ5d2hlcmUgPSB0cnVlKSB7XG4gICAgICAgIC8vVE9ETyBVc2UgdGhlIGBuZWdhdGl2ZVNpZ25DaGFyYWN0ZXJgIGZyb20gdGhlIHNldHRpbmdzIGhlcmVcbiAgICAgICAgaWYgKGNoZWNrRXZlcnl3aGVyZSkge1xuICAgICAgICAgICAgcmV0dXJuIGNvbnRhaW5zKG51bWVyaWNTdHJpbmcsICctJyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gaXNOZWdhdGl2ZVN0cmljdChudW1lcmljU3RyaW5nKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gVFJVRSBpZiB0aGUgZ2l2ZW4gc3RyaW5nIGNvbnRhaW5zIGEgbmVnYXRpdmUgc2lnbiBvbiB0aGUgZmlyc3QgY2hhcmFjdGVyIChvbiB0aGUgZmFyIGxlZnQpLlxuICAgICAqXG4gICAgICogQGV4YW1wbGUgaXNOZWdhdGl2ZVN0cmljdCgnMTIzNC41NicpICAgICA9PiBmYWxzZVxuICAgICAqIEBleGFtcGxlIGlzTmVnYXRpdmVTdHJpY3QoJzEyMzQuNTYtJykgICAgPT4gZmFsc2VcbiAgICAgKiBAZXhhbXBsZSBpc05lZ2F0aXZlU3RyaWN0KCctMTIzNC41NicpICAgID0+IHRydWVcbiAgICAgKiBAZXhhbXBsZSBpc05lZ2F0aXZlU3RyaWN0KCctMSwyMzQuNTYg4oKsJykgPT4gdHJ1ZVxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG51bWVyaWNTdHJpbmdcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc05lZ2F0aXZlU3RyaWN0KG51bWVyaWNTdHJpbmcpIHtcbiAgICAgICAgLy9UT0RPIFVzaW5nIHRoZSBgbmVnYXRpdmVTaWduQ2hhcmFjdGVyYCBmcm9tIHRoZSBzZXR0aW5ncyBoZXJlXG4gICAgICAgIHJldHVybiBudW1lcmljU3RyaW5nLmNoYXJBdCgwKSA9PT0gJy0nO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybiBUUlVFIGlmIHRoZSBmb3JtYXR0ZWQgb3IgdW5mb3JtYXR0ZWQgbnVtZXJpYyBzdHJpbmcgcmVwcmVzZW50IHRoZSB2YWx1ZSAwIChpZS4gJzAsMDAg4oKsJyksIG9yIGlzIGVtcHR5ICgnIOKCrCcpLlxuICAgICAqIFRoaXMgd29ya3Mgc2luY2Ugd2UgdGVzdCBpZiB0aGVyZSBhcmUgYW55IG51bWJlcnMgZnJvbSAxIHRvIDkgaW4gdGhlIHN0cmluZy4gSWYgdGhlcmUgaXMgbm9uZSwgdGhlbiB0aGUgbnVtYmVyIGlzIHplcm8gKG9yIHRoZSBzdHJpbmcgaXMgZW1wdHkpLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG51bWVyaWNTdHJpbmdcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc1plcm9Pckhhc05vVmFsdWUobnVtZXJpY1N0cmluZykge1xuICAgICAgICByZXR1cm4gISgvWzEtOV0vZykudGVzdChudW1lcmljU3RyaW5nKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdGhlIG5lZ2F0aXZlIHZlcnNpb24gb2YgdGhlIHZhbHVlIChyZXByZXNlbnRlZCBhcyBhIHN0cmluZykgZ2l2ZW4gYXMgYSBwYXJhbWV0ZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcbiAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzZXRSYXdOZWdhdGl2ZVNpZ24odmFsdWUpIHtcbiAgICAgICAgaWYgKCFpc05lZ2F0aXZlU3RyaWN0KHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIGAtJHt2YWx1ZX1gO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlcGxhY2UgdGhlIGNoYXJhY3RlciBhdCB0aGUgcG9zaXRpb24gYGluZGV4YCBpbiB0aGUgc3RyaW5nIGBzdHJpbmdgIGJ5IHRoZSBjaGFyYWN0ZXIocykgYG5ld0NoYXJhY3RlcmAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nXG4gICAgICogQHBhcmFtIHtpbnR9IGluZGV4XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5ld0NoYXJhY3RlclxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICovXG4gICAgZnVuY3Rpb24gcmVwbGFjZUNoYXJBdChzdHJpbmcsIGluZGV4LCBuZXdDaGFyYWN0ZXIpIHtcbiAgICAgICAgcmV0dXJuIGAke3N0cmluZy5zdWJzdHIoMCwgaW5kZXgpfSR7bmV3Q2hhcmFjdGVyfSR7c3RyaW5nLnN1YnN0cihpbmRleCArIG5ld0NoYXJhY3Rlci5sZW5ndGgpfWA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSB2YWx1ZSBjbGFtcGVkIHRvIHRoZSBuZWFyZXN0IG1pbmltdW0vbWF4aW11bSB2YWx1ZSwgYXMgZGVmaW5lZCBpbiB0aGUgc2V0dGluZ3MuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ9IHZhbHVlXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHNldHRpbmdzXG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjbGFtcFRvUmFuZ2VMaW1pdHModmFsdWUsIHNldHRpbmdzKSB7XG4gICAgICAgIC8vWFhYIFRoaXMgZnVuY3Rpb24gYWx3YXlzIGFzc3VtZSBgc2V0dGluZ3MubWluaW11bVZhbHVlYCBpcyBsb3dlciB0aGFuIGBzZXR0aW5ncy5tYXhpbXVtVmFsdWVgXG4gICAgICAgIHJldHVybiBNYXRoLm1heChzZXR0aW5ncy5taW5pbXVtVmFsdWUsIE1hdGgubWluKHNldHRpbmdzLm1heGltdW1WYWx1ZSwgdmFsdWUpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdGhlIG51bWJlciBvZiBudW1iZXIgb3IgZG90IGNoYXJhY3RlcnMgb24gdGhlIGxlZnQgc2lkZSBvZiB0aGUgY2FyZXQsIGluIGEgZm9ybWF0dGVkIG51bWJlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBmb3JtYXR0ZWROdW1iZXJTdHJpbmdcbiAgICAgKiBAcGFyYW0ge2ludH0gY2FyZXRQb3NpdGlvbiBUaGlzIG11c3QgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGRlY2ltYWxDaGFyYWN0ZXJcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNvdW50TnVtYmVyQ2hhcmFjdGVyc09uVGhlQ2FyZXRMZWZ0U2lkZShmb3JtYXR0ZWROdW1iZXJTdHJpbmcsIGNhcmV0UG9zaXRpb24sIGRlY2ltYWxDaGFyYWN0ZXIpIHtcbiAgICAgICAgLy8gSGVyZSB3ZSBjb3VudCB0aGUgZG90IGFuZCByZXBvcnQgaXQgYXMgYSBudW1iZXIgY2hhcmFjdGVyIHRvbywgc2luY2UgaXQgd2lsbCAnc3RheScgaW4gdGhlIEphdmFzY3JpcHQgbnVtYmVyIHdoZW4gdW5mb3JtYXR0ZWRcbiAgICAgICAgY29uc3QgbnVtYmVyRG90T3JOZWdhdGl2ZVNpZ24gPSBuZXcgUmVnRXhwKGBbMC05JHtkZWNpbWFsQ2hhcmFjdGVyfS1dYCk7IC8vIE5vIG5lZWQgdG8gZXNjYXBlIHRoZSBkZWNpbWFsIGNoYXJhY3RlciBoZXJlLCBzaW5jZSBpdCdzIGluIGBbXWBcblxuICAgICAgICBsZXQgbnVtYmVyRG90QW5kTmVnYXRpdmVTaWduQ291bnQgPSAwO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNhcmV0UG9zaXRpb247IGkrKykge1xuICAgICAgICAgICAgLy8gVGVzdCBpZiB0aGUgY2hhcmFjdGVyIGlzIGEgbnVtYmVyLCBhIGRvdCBvciBhbiBoeXBoZW4uIElmIGl0IGlzLCBjb3VudCBpdCwgb3RoZXJ3aXNlIGlnbm9yZSBpdFxuICAgICAgICAgICAgaWYgKG51bWJlckRvdE9yTmVnYXRpdmVTaWduLnRlc3QoZm9ybWF0dGVkTnVtYmVyU3RyaW5nW2ldKSkge1xuICAgICAgICAgICAgICAgIG51bWJlckRvdEFuZE5lZ2F0aXZlU2lnbkNvdW50Kys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbnVtYmVyRG90QW5kTmVnYXRpdmVTaWduQ291bnQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogV2FsayB0aGUgYGZvcm1hdHRlZE51bWJlclN0cmluZ2AgZnJvbSBsZWZ0IHRvIHJpZ2h0LCBvbmUgY2hhciBieSBvbmUsIGNvdW50aW5nIHRoZSBgZm9ybWF0dGVkTnVtYmVyU3RyaW5nSW5kZXhgLlxuICAgICAqIElmIHRoZSBjaGFyIGlzIGluIHRoZSBgcmF3TnVtYmVyU3RyaW5nYCAoc3RhcnRpbmcgYXQgaW5kZXggMCksIHRoZW4gYHJhd051bWJlclN0cmluZ0luZGV4KytgLCBhbmQgY29udGludWUgdW50aWxcbiAgICAgKiB0aGVyZSBpcyBubyBtb3JlIGNoYXJhY3RlcnMgaW4gYHJhd051bWJlclN0cmluZ2ApIG9yIHRoYXQgYHJhd051bWJlclN0cmluZ0luZGV4ID09PSBjYXJldFBvc2l0aW9uSW5SYXdWYWx1ZWAuXG4gICAgICogV2hlbiB5b3Ugc3RvcCwgdGhlIGBmb3JtYXR0ZWROdW1iZXJTdHJpbmdJbmRleGAgaXMgdGhlIHBvc2l0aW9uIHdoZXJlIHRoZSBjYXJldCBzaG91bGQgYmUgc2V0LlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAxMjM0NTY3fDg5LjAxICAgOiBwb3NpdGlvbiA3IChyYXdOdW1iZXJTdHJpbmcpXG4gICAgICogMTIzLjQ1Ni43fDg5LDAxIDogcG9zaXRpb24gOSAoZm9ybWF0dGVkTnVtYmVyU3RyaW5nKVxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHJhd051bWJlclN0cmluZ1xuICAgICAqIEBwYXJhbSB7aW50fSBjYXJldFBvc2l0aW9uSW5SYXdWYWx1ZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBmb3JtYXR0ZWROdW1iZXJTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZGVjaW1hbENoYXJhY3RlclxuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZpbmRDYXJldFBvc2l0aW9uSW5Gb3JtYXR0ZWROdW1iZXIocmF3TnVtYmVyU3RyaW5nLCBjYXJldFBvc2l0aW9uSW5SYXdWYWx1ZSwgZm9ybWF0dGVkTnVtYmVyU3RyaW5nLCBkZWNpbWFsQ2hhcmFjdGVyKSB7XG4gICAgICAgIGNvbnN0IGZvcm1hdHRlZE51bWJlclN0cmluZ1NpemUgPSBmb3JtYXR0ZWROdW1iZXJTdHJpbmcubGVuZ3RoO1xuICAgICAgICBjb25zdCByYXdOdW1iZXJTdHJpbmdTaXplID0gcmF3TnVtYmVyU3RyaW5nLmxlbmd0aDtcblxuICAgICAgICBsZXQgZm9ybWF0dGVkTnVtYmVyU3RyaW5nSW5kZXg7XG4gICAgICAgIGxldCByYXdOdW1iZXJTdHJpbmdJbmRleCA9IDA7XG4gICAgICAgIGZvciAoZm9ybWF0dGVkTnVtYmVyU3RyaW5nSW5kZXggPSAwO1xuICAgICAgICAgICAgIGZvcm1hdHRlZE51bWJlclN0cmluZ0luZGV4IDwgZm9ybWF0dGVkTnVtYmVyU3RyaW5nU2l6ZSAmJlxuICAgICAgICAgICAgIHJhd051bWJlclN0cmluZ0luZGV4IDwgcmF3TnVtYmVyU3RyaW5nU2l6ZSAmJlxuICAgICAgICAgICAgIHJhd051bWJlclN0cmluZ0luZGV4IDwgY2FyZXRQb3NpdGlvbkluUmF3VmFsdWU7XG4gICAgICAgICAgICAgZm9ybWF0dGVkTnVtYmVyU3RyaW5nSW5kZXgrKykge1xuICAgICAgICAgICAgaWYgKHJhd051bWJlclN0cmluZ1tyYXdOdW1iZXJTdHJpbmdJbmRleF0gPT09IGZvcm1hdHRlZE51bWJlclN0cmluZ1tmb3JtYXR0ZWROdW1iZXJTdHJpbmdJbmRleF0gfHxcbiAgICAgICAgICAgICAgICAocmF3TnVtYmVyU3RyaW5nW3Jhd051bWJlclN0cmluZ0luZGV4XSA9PT0gJy4nICYmIGZvcm1hdHRlZE51bWJlclN0cmluZ1tmb3JtYXR0ZWROdW1iZXJTdHJpbmdJbmRleF0gPT09IGRlY2ltYWxDaGFyYWN0ZXIpKSB7XG4gICAgICAgICAgICAgICAgcmF3TnVtYmVyU3RyaW5nSW5kZXgrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmb3JtYXR0ZWROdW1iZXJTdHJpbmdJbmRleDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb3VudCB0aGUgbnVtYmVyIG9mIG9jY3VycmVuY2Ugb2YgdGhlIGdpdmVuIGNoYXJhY3RlciwgaW4gdGhlIGdpdmVuIHRleHQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY2hhcmFjdGVyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRleHRcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNvdW50Q2hhckluVGV4dChjaGFyYWN0ZXIsIHRleHQpIHtcbiAgICAgICAgbGV0IGNoYXJDb3VudGVyID0gMDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0ZXh0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAodGV4dFtpXSA9PT0gY2hhcmFjdGVyKSB7XG4gICAgICAgICAgICAgICAgY2hhckNvdW50ZXIrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjaGFyQ291bnRlcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdGhlIGluZGV4IHRoYXQgY2FuIGJlIHVzZWQgdG8gc2V0IHRoZSBjYXJldCBwb3NpdGlvbi5cbiAgICAgKiBUaGlzIHRha2VzIGludG8gYWNjb3VudCB0aGF0IHRoZSBwb3NpdGlvbiBpcyBzdGFydGluZyBhdCAnMCcsIG5vdCAxLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtpbnR9IGNoYXJhY3RlckNvdW50XG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjb252ZXJ0Q2hhcmFjdGVyQ291bnRUb0luZGV4UG9zaXRpb24oY2hhcmFjdGVyQ291bnQpIHtcbiAgICAgICAgcmV0dXJuIE1hdGgubWF4KGNoYXJhY3RlckNvdW50LCBjaGFyYWN0ZXJDb3VudCAtIDEpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyb3NzIGJyb3dzZXIgcm91dGluZSBmb3IgZ2V0dGluZyBzZWxlY3RlZCByYW5nZS9jdXJzb3IgcG9zaXRpb25cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR8RXZlbnRUYXJnZXR9IHRoYXRcbiAgICAgKiBAcmV0dXJucyB7e319XG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0RWxlbWVudFNlbGVjdGlvbih0aGF0KSB7XG4gICAgICAgIGNvbnN0IHBvc2l0aW9uID0ge307XG4gICAgICAgIGlmIChpc1VuZGVmaW5lZCh0aGF0LnNlbGVjdGlvblN0YXJ0KSkge1xuICAgICAgICAgICAgdGhhdC5mb2N1cygpO1xuICAgICAgICAgICAgY29uc3Qgc2VsZWN0ID0gZG9jdW1lbnQuc2VsZWN0aW9uLmNyZWF0ZVJhbmdlKCk7XG4gICAgICAgICAgICBwb3NpdGlvbi5sZW5ndGggPSBzZWxlY3QudGV4dC5sZW5ndGg7XG4gICAgICAgICAgICBzZWxlY3QubW92ZVN0YXJ0KCdjaGFyYWN0ZXInLCAtdGhhdC52YWx1ZS5sZW5ndGgpO1xuICAgICAgICAgICAgcG9zaXRpb24uZW5kID0gc2VsZWN0LnRleHQubGVuZ3RoO1xuICAgICAgICAgICAgcG9zaXRpb24uc3RhcnQgPSBwb3NpdGlvbi5lbmQgLSBwb3NpdGlvbi5sZW5ndGg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwb3NpdGlvbi5zdGFydCA9IHRoYXQuc2VsZWN0aW9uU3RhcnQ7XG4gICAgICAgICAgICBwb3NpdGlvbi5lbmQgPSB0aGF0LnNlbGVjdGlvbkVuZDtcbiAgICAgICAgICAgIHBvc2l0aW9uLmxlbmd0aCA9IHBvc2l0aW9uLmVuZCAtIHBvc2l0aW9uLnN0YXJ0O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHBvc2l0aW9uO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyb3NzIGJyb3dzZXIgcm91dGluZSBmb3Igc2V0dGluZyBzZWxlY3RlZCByYW5nZS9jdXJzb3IgcG9zaXRpb25cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR8RXZlbnRUYXJnZXR9IHRoYXRcbiAgICAgKiBAcGFyYW0ge2ludH0gc3RhcnRcbiAgICAgKiBAcGFyYW0ge2ludHxudWxsfSBlbmRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzZXRFbGVtZW50U2VsZWN0aW9uKHRoYXQsIHN0YXJ0LCBlbmQgPSBudWxsKSB7XG4gICAgICAgIGlmIChpc1VuZGVmaW5lZE9yTnVsbE9yRW1wdHkoZW5kKSkge1xuICAgICAgICAgICAgZW5kID0gc3RhcnQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNVbmRlZmluZWQodGhhdC5zZWxlY3Rpb25TdGFydCkpIHtcbiAgICAgICAgICAgIHRoYXQuZm9jdXMoKTtcbiAgICAgICAgICAgIGNvbnN0IHJhbmdlID0gdGhhdC5jcmVhdGVUZXh0UmFuZ2UoKTtcbiAgICAgICAgICAgIHJhbmdlLmNvbGxhcHNlKHRydWUpO1xuICAgICAgICAgICAgcmFuZ2UubW92ZUVuZCgnY2hhcmFjdGVyJywgZW5kKTtcbiAgICAgICAgICAgIHJhbmdlLm1vdmVTdGFydCgnY2hhcmFjdGVyJywgc3RhcnQpO1xuICAgICAgICAgICAgcmFuZ2Uuc2VsZWN0KCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGF0LnNlbGVjdGlvblN0YXJ0ID0gc3RhcnQ7XG4gICAgICAgICAgICB0aGF0LnNlbGVjdGlvbkVuZCA9IGVuZDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZ1bmN0aW9uIHRoYXQgdGhyb3cgZXJyb3IgbWVzc2FnZXNcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBtZXNzYWdlXG4gICAgICovXG4gICAgZnVuY3Rpb24gdGhyb3dFcnJvcihtZXNzYWdlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGdW5jdGlvbiB0aGF0IGRpc3BsYXkgYSB3YXJuaW5nIG1lc3NhZ2VzLCBhY2NvcmRpbmcgdG8gdGhlIGRlYnVnIGxldmVsLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG1lc3NhZ2VcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHNob3dXYXJuaW5nIElmIEZBTFNFLCB0aGVuIHRoZSB3YXJuaW5nIG1lc3NhZ2UgaXMgbm90IGRpc3BsYXllZFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHdhcm5pbmcobWVzc2FnZSwgc2hvd1dhcm5pbmcgPSB0cnVlKSB7XG4gICAgICAgIGlmIChzaG93V2FybmluZykge1xuICAgICAgICAgICAgLyogZXNsaW50IG5vLWNvbnNvbGU6IDAgKi9cbiAgICAgICAgICAgIGNvbnNvbGUud2FybihgV2FybmluZzogJHttZXNzYWdlfWApO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gYXV0b051bWVyaWMtc3BlY2lmaWMgZnVuY3Rpb25zXG5cbiAgICAvKipcbiAgICAgKiBSdW4gYW55IGNhbGxiYWNrcyBmb3VuZCBpbiB0aGUgc2V0dGluZ3Mgb2JqZWN0LlxuICAgICAqIEFueSBwYXJhbWV0ZXIgY291bGQgYmUgYSBjYWxsYmFjazpcbiAgICAgKiAtIGEgZnVuY3Rpb24sIHdoaWNoIGludm9rZWQgd2l0aCBqUXVlcnkgZWxlbWVudCwgcGFyYW1ldGVycyBhbmQgdGhpcyBwYXJhbWV0ZXIgbmFtZSBhbmQgcmV0dXJucyBwYXJhbWV0ZXIgdmFsdWVcbiAgICAgKiAtIGEgbmFtZSBvZiBmdW5jdGlvbiwgYXR0YWNoZWQgdG8gJChzZWxlY3RvcikuYXV0b051bWVyaWMuZnVuY3Rpb25OYW1lKCl7fSAtIHdoaWNoIHdhcyBjYWxsZWQgcHJldmlvdXNseVxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSAkdGhpcyBqUXVlcnktc2VsZWN0ZWQgRE9NIGVsZW1lbnRcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3NcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBydW5DYWxsYmFja3NGb3VuZEluVGhlU2V0dGluZ3NPYmplY3QoJHRoaXMsIHNldHRpbmdzKSB7XG4gICAgICAgIC8vIExvb3BzIHRocm91Z2ggdGhlIHNldHRpbmdzIG9iamVjdCAob3B0aW9uIGFycmF5KSB0byBmaW5kIHRoZSBmb2xsb3dpbmdcbiAgICAgICAgJC5lYWNoKHNldHRpbmdzLCAoaywgdmFsKSA9PiB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIHNldHRpbmdzW2tdID0gdmFsKCR0aGlzLCBzZXR0aW5ncywgayk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiAkdGhpcy5hdXRvTnVtZXJpY1t2YWxdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgLy8gQ2FsbHMgdGhlIGF0dGFjaGVkIGZ1bmN0aW9uIGZyb20gdGhlIGh0bWw1IGRhdGEgZXhhbXBsZTogZGF0YS1hLXNpZ249XCJmdW5jdGlvbk5hbWVcIlxuICAgICAgICAgICAgICAgIHNldHRpbmdzW2tdID0gJHRoaXMuYXV0b051bWVyaWNbdmFsXSgkdGhpcywgc2V0dGluZ3MsIGspO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmUgdGhlIG1heGltdW0gZGVjaW1hbCBsZW5ndGggZnJvbSB0aGUgbWluaW11bVZhbHVlIGFuZCBtYXhpbXVtVmFsdWUgc2V0dGluZ3NcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBtaW5pbXVtVmFsdWVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbWF4aW11bVZhbHVlXG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtYXhpbXVtVk1pbkFuZFZNYXhEZWNpbWFsTGVuZ3RoKG1pbmltdW1WYWx1ZSwgbWF4aW11bVZhbHVlKSB7XG4gICAgICAgIHJldHVybiBNYXRoLm1heChkZWNpbWFsUGxhY2VzKG1pbmltdW1WYWx1ZSksIGRlY2ltYWxQbGFjZXMobWF4aW11bVZhbHVlKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU3RyaXAgYWxsIHVud2FudGVkIG5vbi1udW1iZXIgY2hhcmFjdGVycy5cbiAgICAgKiBUaGlzIGtlZXBzIHRoZSBudW1iZXJzLCB0aGUgbmVnYXRpdmUgc2lnbiBhcyB3ZWxsIGFzIHRoZSBjdXN0b20gZGVjaW1hbCBjaGFyYWN0ZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc1xuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5nc1xuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gbGVmdE9yQWxsXG4gICAgICogQHJldHVybnMge3N0cmluZ3wqfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHN0cmlwQWxsTm9uTnVtYmVyQ2hhcmFjdGVycyhzLCBzZXR0aW5ncywgbGVmdE9yQWxsKSB7XG4gICAgICAgIC8vVE9ETyBUaGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCAxMCB0aW1lcyAoc2ljISkgb24gZWFjaCBrZXkgaW5wdXQsIGNvdWxkbid0IHdlIGxvd2VyIHRoYXQgbnVtYmVyPyBjZi4gaXNzdWUgIzMyNVxuICAgICAgICAvL1RPRE8gUmVmYWN0b3IgdGhpcyB3aXRoIGBjb252ZXJ0VG9OdW1lcmljU3RyaW5nKClgIGlmIHBvc3NpYmxlP1xuICAgICAgICBpZiAoc2V0dGluZ3MuY3VycmVuY3lTeW1ib2wgIT09ICcnKSB7XG4gICAgICAgICAgICAvLyBSZW1vdmUgY3VycmVuY3kgc2lnblxuICAgICAgICAgICAgcyA9IHMucmVwbGFjZShzZXR0aW5ncy5jdXJyZW5jeVN5bWJvbCwgJycpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzZXR0aW5ncy5zdWZmaXhUZXh0KSB7XG4gICAgICAgICAgICAvLyBSZW1vdmUgc3VmZml4XG4gICAgICAgICAgICB3aGlsZSAoY29udGFpbnMocywgc2V0dGluZ3Muc3VmZml4VGV4dCkpIHtcbiAgICAgICAgICAgICAgICBzID0gcy5yZXBsYWNlKHNldHRpbmdzLnN1ZmZpeFRleHQsICcnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEZpcnN0IHJlcGxhY2UgYW55dGhpbmcgYmVmb3JlIGRpZ2l0c1xuICAgICAgICBzID0gcy5yZXBsYWNlKHNldHRpbmdzLnNraXBGaXJzdEF1dG9TdHJpcCwgJyQxJDInKTtcblxuICAgICAgICBpZiAoKHNldHRpbmdzLm5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50ID09PSAncycgfHxcbiAgICAgICAgICAgIChzZXR0aW5ncy5jdXJyZW5jeVN5bWJvbFBsYWNlbWVudCA9PT0gJ3MnICYmIHNldHRpbmdzLm5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50ICE9PSAncCcpKSAmJlxuICAgICAgICAgICAgaXNOZWdhdGl2ZShzKSAmJlxuICAgICAgICAgICAgcyAhPT0gJycpIHtcbiAgICAgICAgICAgIHNldHRpbmdzLnRyYWlsaW5nTmVnYXRpdmUgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVGhlbiByZXBsYWNlIGFueXRoaW5nIGFmdGVyIGRpZ2l0c1xuICAgICAgICBzID0gcy5yZXBsYWNlKHNldHRpbmdzLnNraXBMYXN0QXV0b1N0cmlwLCAnJDEnKTtcblxuICAgICAgICAvLyBUaGVuIHJlbW92ZSBhbnkgdW5pbnRlcmVzdGluZyBjaGFyYWN0ZXJzXG4gICAgICAgIHMgPSBzLnJlcGxhY2Uoc2V0dGluZ3MuYWxsb3dlZEF1dG9TdHJpcCwgJycpO1xuICAgICAgICBpZiAoc2V0dGluZ3MuZGVjaW1hbENoYXJhY3RlckFsdGVybmF0aXZlKSB7XG4gICAgICAgICAgICBzID0gcy5yZXBsYWNlKHNldHRpbmdzLmRlY2ltYWxDaGFyYWN0ZXJBbHRlcm5hdGl2ZSwgc2V0dGluZ3MuZGVjaW1hbENoYXJhY3Rlcik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBHZXQgb25seSBudW1iZXIgc3RyaW5nXG4gICAgICAgIGNvbnN0IG0gPSBzLm1hdGNoKHNldHRpbmdzLm51bVJlZ0F1dG9TdHJpcCk7XG4gICAgICAgIHMgPSBtID8gW21bMV0sIG1bMl0sIG1bM11dLmpvaW4oJycpIDogJyc7XG5cbiAgICAgICAgaWYgKHNldHRpbmdzLmxlYWRpbmdaZXJvID09PSAnYWxsb3cnIHx8IHNldHRpbmdzLmxlYWRpbmdaZXJvID09PSAna2VlcCcpIHtcbiAgICAgICAgICAgIGxldCBuU2lnbiA9ICcnO1xuICAgICAgICAgICAgY29uc3QgW2ludGVnZXJQYXJ0LCBkZWNpbWFsUGFydF0gPSBzLnNwbGl0KHNldHRpbmdzLmRlY2ltYWxDaGFyYWN0ZXIpO1xuICAgICAgICAgICAgbGV0IG1vZGlmaWVkSW50ZWdlclBhcnQgPSBpbnRlZ2VyUGFydDtcbiAgICAgICAgICAgIGlmIChjb250YWlucyhtb2RpZmllZEludGVnZXJQYXJ0LCBzZXR0aW5ncy5uZWdhdGl2ZVNpZ25DaGFyYWN0ZXIpKSB7XG4gICAgICAgICAgICAgICAgblNpZ24gPSBzZXR0aW5ncy5uZWdhdGl2ZVNpZ25DaGFyYWN0ZXI7XG4gICAgICAgICAgICAgICAgbW9kaWZpZWRJbnRlZ2VyUGFydCA9IG1vZGlmaWVkSW50ZWdlclBhcnQucmVwbGFjZShzZXR0aW5ncy5uZWdhdGl2ZVNpZ25DaGFyYWN0ZXIsICcnKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gU3RyaXAgbGVhZGluZyB6ZXJvIG9uIHBvc2l0aXZlIHZhbHVlIGlmIG5lZWRcbiAgICAgICAgICAgIGlmIChuU2lnbiA9PT0gJycgJiYgbW9kaWZpZWRJbnRlZ2VyUGFydC5sZW5ndGggPiBzZXR0aW5ncy5tSW50UG9zICYmIG1vZGlmaWVkSW50ZWdlclBhcnQuY2hhckF0KDApID09PSAnMCcpIHtcbiAgICAgICAgICAgICAgICBtb2RpZmllZEludGVnZXJQYXJ0ID0gbW9kaWZpZWRJbnRlZ2VyUGFydC5zbGljZSgxKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gU3RyaXAgbGVhZGluZyB6ZXJvIG9uIG5lZ2F0aXZlIHZhbHVlIGlmIG5lZWRcbiAgICAgICAgICAgIGlmIChuU2lnbiAhPT0gJycgJiYgbW9kaWZpZWRJbnRlZ2VyUGFydC5sZW5ndGggPiBzZXR0aW5ncy5tSW50TmVnICYmIG1vZGlmaWVkSW50ZWdlclBhcnQuY2hhckF0KDApID09PSAnMCcpIHtcbiAgICAgICAgICAgICAgICBtb2RpZmllZEludGVnZXJQYXJ0ID0gbW9kaWZpZWRJbnRlZ2VyUGFydC5zbGljZSgxKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcyA9IGAke25TaWdufSR7bW9kaWZpZWRJbnRlZ2VyUGFydH0ke2lzVW5kZWZpbmVkKGRlY2ltYWxQYXJ0KT8nJzpzZXR0aW5ncy5kZWNpbWFsQ2hhcmFjdGVyICsgZGVjaW1hbFBhcnR9YDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICgobGVmdE9yQWxsICYmIHNldHRpbmdzLmxlYWRpbmdaZXJvID09PSAnZGVueScpIHx8XG4gICAgICAgICAgICAoIXNldHRpbmdzLmhhc0ZvY3VzICYmIHNldHRpbmdzLmxlYWRpbmdaZXJvID09PSAnYWxsb3cnKSkge1xuICAgICAgICAgICAgcyA9IHMucmVwbGFjZShzZXR0aW5ncy5zdHJpcFJlZywgJyQxJDInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgb3IgcmVtb3ZlcyBicmFja2V0cyBvbiBuZWdhdGl2ZSB2YWx1ZXMsIGRlcGVuZGluZyBvbiB0aGUgZm9jdXMgc3RhdGUuXG4gICAgICogVGhlIGZvY3VzIHN0YXRlIGlzICdzdG9yZWQnIGluIHRoZSBzZXR0aW5ncyBvYmplY3QgdW5kZXIgdGhlIGBzZXR0aW5ncy5oYXNGb2N1c2AgYXR0cmlidXRlLlxuICAgICAqIC8vVE9ETyBVc2UgYW5vdGhlciBvYmplY3QgdG8ga2VlcCB0cmFjayBvZiBpbnRlcm5hbCBkYXRhIHRoYXQgYXJlIG5vdCBzZXR0aW5nc1xuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHNcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3NcbiAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0b2dnbGVOZWdhdGl2ZUJyYWNrZXQocywgc2V0dGluZ3MpIHtcbiAgICAgICAgaWYgKChzZXR0aW5ncy5jdXJyZW5jeVN5bWJvbFBsYWNlbWVudCA9PT0gJ3AnICYmIHNldHRpbmdzLm5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50ID09PSAnbCcpIHx8XG4gICAgICAgICAgICAoc2V0dGluZ3MuY3VycmVuY3lTeW1ib2xQbGFjZW1lbnQgPT09ICdzJyAmJiBzZXR0aW5ncy5uZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudCA9PT0gJ3AnKSkge1xuICAgICAgICAgICAgLy9UT0RPIFNwbGl0IHRoZSBmaXJzdCBhbmQgbGFzdCBicmFja2V0IG9ubHkgb25jZSBkdXJpbmcgdGhlIHNldHRpbmdzIGluaXRpYWxpemF0aW9uXG4gICAgICAgICAgICBjb25zdCBbZmlyc3RCcmFja2V0LCBsYXN0QnJhY2tldF0gPSBzZXR0aW5ncy5uZWdhdGl2ZUJyYWNrZXRzVHlwZU9uQmx1ci5zcGxpdCgnLCcpO1xuICAgICAgICAgICAgaWYgKCFzZXR0aW5ncy5oYXNGb2N1cykge1xuICAgICAgICAgICAgICAgIC8vIEFkZCBicmFja2V0c1xuICAgICAgICAgICAgICAgIHMgPSBzLnJlcGxhY2Uoc2V0dGluZ3MubmVnYXRpdmVTaWduQ2hhcmFjdGVyLCAnJyk7XG4gICAgICAgICAgICAgICAgcyA9IGZpcnN0QnJhY2tldCArIHMgKyBsYXN0QnJhY2tldDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc2V0dGluZ3MuaGFzRm9jdXMgJiYgcy5jaGFyQXQoMCkgPT09IGZpcnN0QnJhY2tldCkge1xuICAgICAgICAgICAgICAgIC8vIFJlbW92ZSBicmFja2V0c1xuICAgICAgICAgICAgICAgIC8vVE9ETyBRdWlkIGlmIHRoZSBuZWdhdGl2ZSBzaWduIGlzIG5vdCBvbiB0aGUgbGVmdCwgc2hvdWxkbid0IHdlIHJlcGxhY2UgdGhlICctJyBzaWduIGF0IHRoZSByaWdodCBwbGFjZT9cbiAgICAgICAgICAgICAgICBzID0gcy5yZXBsYWNlKGZpcnN0QnJhY2tldCwgc2V0dGluZ3MubmVnYXRpdmVTaWduQ2hhcmFjdGVyKTtcbiAgICAgICAgICAgICAgICBzID0gcy5yZXBsYWNlKGxhc3RCcmFja2V0LCAnJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gYSBudW1iZXIgYXMgYSBudW1lcmljIHN0cmluZyB0aGF0IGNhbiBiZSB0eXBlY2FzdCB0byBhIE51bWJlciB0aGF0IEphdmFzY3JpcHQgd2lsbCB1bmRlcnN0YW5kLlxuICAgICAqXG4gICAgICogVGhpcyBmdW5jdGlvbiByZXR1cm4gdGhlIGdpdmVuIHN0cmluZyBieSBzdHJpcHBpbmcgdGhlIGN1cnJlbmN5IHNpZ24gKGN1cnJlbmN5U3ltYm9sKSwgdGhlIGdyb3VwaW5nIHNlcGFyYXRvcnMgKGRpZ2l0YWxHcm91cFNwYWNpbmcpIGFuZCBieSByZXBsYWNpbmcgdGhlIGRlY2ltYWwgY2hhcmFjdGVyIChkZWNpbWFsQ2hhcmFjdGVyKSBieSBhIGRvdC5cbiAgICAgKiBMYXN0bHksIGl0IGFsc28gcHV0IHRoZSBuZWdhdGl2ZSBzaWduIGJhY2sgdG8gaXRzIG5vcm1hbCBwb3NpdGlvbiBpZiBuZWVkZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc1xuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5nc1xuICAgICAqIEByZXR1cm5zIHtzdHJpbmd8dm9pZHxYTUx8Kn1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjb252ZXJ0VG9OdW1lcmljU3RyaW5nKHMsIHNldHRpbmdzKSB7XG4gICAgICAgIC8vIFJlbW92ZSB0aGUgY3VycmVuY3kgc3ltYm9sXG4gICAgICAgIHMgPSBzLnJlcGxhY2Uoc2V0dGluZ3MuY3VycmVuY3lTeW1ib2wsICcnKTtcblxuICAgICAgICAvLyBSZW1vdmUgdGhlIGdyb3VwaW5nIHNlcGFyYXRvcnMgKHRob3VzYW5kcyBzZXBhcmF0b3JzIHVzdWFsbHkpXG4gICAgICAgIHMgPSBzLnJlcGxhY2Uoc2V0dGluZ3MuZGlnaXRHcm91cFNlcGFyYXRvciwgJycpO1xuXG4gICAgICAgIC8vIFJlcGxhY2UgdGhlIGRlY2ltYWwgY2hhcmFjdGVyIGJ5IGEgZG90XG4gICAgICAgIGlmIChzZXR0aW5ncy5kZWNpbWFsQ2hhcmFjdGVyICE9PSAnLicpIHtcbiAgICAgICAgICAgIHMgPSBzLnJlcGxhY2Uoc2V0dGluZ3MuZGVjaW1hbENoYXJhY3RlciwgJy4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE1vdmUgdGhlIHRyYWlsaW5nIG5lZ2F0aXZlIHNpZ24gdG8gdGhlIHJpZ2h0IHBvc2l0aW9uLCBpZiBhbnlcbiAgICAgICAgaWYgKGlzTmVnYXRpdmUocykgJiYgcy5sYXN0SW5kZXhPZignLScpID09PSBzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgIHMgPSBzLnJlcGxhY2UoJy0nLCAnJyk7XG4gICAgICAgICAgICBzID0gJy0nICsgcztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENvbnZlcnQgYW55IGFyYWJpYyBudW1iZXJzIHRvIGxhdGluIG9uZXNcbiAgICAgICAgY29uc3QgdGVtcCA9IGFyYWJpY1RvTGF0aW5OdW1iZXJzKHMsIHRydWUsIGZhbHNlLCBmYWxzZSk7XG4gICAgICAgIGlmICghaXNOYU4odGVtcCkpIHtcbiAgICAgICAgICAgIHMgPSB0ZW1wLnRvU3RyaW5nKCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyB0aGUgSVNPIG51bWVyaWMgc3RyaW5nIHRvIHRoZSBsb2NhbGUgZGVjaW1hbCBhbmQgbWludXMgc2lnbiBwbGFjZW1lbnQuXG4gICAgICogU2VlIHRoZSBcIm91dHB1dEZvcm1hdFwiIG9wdGlvbiBkZWZpbml0aW9uIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ3xudWxsfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBsb2NhbGVcbiAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0b0xvY2FsZSh2YWx1ZSwgbG9jYWxlKSB7XG4gICAgICAgIGlmIChpc051bGwobG9jYWxlKSB8fCBsb2NhbGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgcmVzdWx0O1xuICAgICAgICBzd2l0Y2ggKGxvY2FsZSkge1xuICAgICAgICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBOdW1iZXIodmFsdWUpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnLi0nOlxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGlzTmVnYXRpdmUodmFsdWUpID8gdmFsdWUucmVwbGFjZSgnLScsICcnKSArICctJyA6IHZhbHVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnLCc6XG4gICAgICAgICAgICBjYXNlICctLCc6XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gdmFsdWUucmVwbGFjZSgnLicsICcsJyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICcsLSc6XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gdmFsdWUucmVwbGFjZSgnLicsICcsJyk7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gaXNOZWdhdGl2ZShyZXN1bHQpID8gcmVzdWx0LnJlcGxhY2UoJy0nLCAnJykgKyAnLScgOiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAvLyBUaGUgZGVmYXVsdCBjYXNlXG4gICAgICAgICAgICBjYXNlICcuJzpcbiAgICAgICAgICAgIGNhc2UgJy0uJzpcbiAgICAgICAgICAgICAgICByZXN1bHQgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQgOlxuICAgICAgICAgICAgICAgIHRocm93RXJyb3IoYFRoZSBnaXZlbiBvdXRwdXRGb3JtYXQgWyR7bG9jYWxlfV0gb3B0aW9uIGlzIG5vdCByZWNvZ25pemVkLmApO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNb2RpZnkgdGhlIG5lZ2F0aXZlIHNpZ24gYW5kIHRoZSBkZWNpbWFsIGNoYXJhY3RlciBvZiB0aGUgZ2l2ZW4gc3RyaW5nIHZhbHVlIHRvIGFuIGh5cGhlbiAoLSkgYW5kIGEgZG90ICguKSBpbiBvcmRlciB0byBtYWtlIHRoYXQgdmFsdWUgJ3R5cGVjYXN0YWJsZScgdG8gYSByZWFsIG51bWJlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHNldHRpbmdzXG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtb2RpZnlOZWdhdGl2ZVNpZ25BbmREZWNpbWFsQ2hhcmFjdGVyRm9yUmF3VmFsdWUocywgc2V0dGluZ3MpIHtcbiAgICAgICAgaWYgKHNldHRpbmdzLmRlY2ltYWxDaGFyYWN0ZXIgIT09ICcuJykge1xuICAgICAgICAgICAgcyA9IHMucmVwbGFjZShzZXR0aW5ncy5kZWNpbWFsQ2hhcmFjdGVyLCAnLicpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzZXR0aW5ncy5uZWdhdGl2ZVNpZ25DaGFyYWN0ZXIgIT09ICctJyAmJiBzZXR0aW5ncy5uZWdhdGl2ZVNpZ25DaGFyYWN0ZXIgIT09ICcnKSB7XG4gICAgICAgICAgICBzID0gcy5yZXBsYWNlKHNldHRpbmdzLm5lZ2F0aXZlU2lnbkNoYXJhY3RlciwgJy0nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXMubWF0Y2goL1xcZC8pKSB7XG4gICAgICAgICAgICAvLyBUaGUgZGVmYXVsdCB2YWx1ZSByZXR1cm5lZCBieSBgZ2V0YCBpcyBub3QgZm9ybWF0dGVkIHdpdGggZGVjaW1hbHNcbiAgICAgICAgICAgIHMgKz0gJzAnO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTW9kaWZ5IHRoZSBuZWdhdGl2ZSBzaWduIGFuZCB0aGUgZGVjaW1hbCBjaGFyYWN0ZXIgdG8gdXNlIHRob3NlIGRlZmluZWQgaW4gdGhlIHNldHRpbmdzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHNcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3NcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1vZGlmeU5lZ2F0aXZlU2lnbkFuZERlY2ltYWxDaGFyYWN0ZXJGb3JGb3JtYXR0ZWRWYWx1ZShzLCBzZXR0aW5ncykge1xuICAgICAgICBpZiAoc2V0dGluZ3MubmVnYXRpdmVTaWduQ2hhcmFjdGVyICE9PSAnLScgJiYgc2V0dGluZ3MubmVnYXRpdmVTaWduQ2hhcmFjdGVyICE9PSAnJykge1xuICAgICAgICAgICAgcyA9IHMucmVwbGFjZSgnLScsIHNldHRpbmdzLm5lZ2F0aXZlU2lnbkNoYXJhY3Rlcik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNldHRpbmdzLmRlY2ltYWxDaGFyYWN0ZXIgIT09ICcuJykge1xuICAgICAgICAgICAgcyA9IHMucmVwbGFjZSgnLicsIHNldHRpbmdzLmRlY2ltYWxDaGFyYWN0ZXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUHJpdmF0ZSBmdW5jdGlvbiB0byBjaGVjayBmb3IgZW1wdHkgdmFsdWVcbiAgICAgKiAvL1RPRE8gTW9kaWZ5IHRoaXMgZnVuY3Rpb24gc28gdGhhdCBpdCByZXR1cm4gZWl0aGVyIFRSVUUgb3IgRkFMU0UgaWYgdGhlIHZhbHVlIGlzIGVtcHR5LiBUaGVuIGNyZWF0ZSBhbm90aGVyIGZ1bmN0aW9uIHRvIHJldHVybiB0aGUgaW5wdXQgdmFsdWUgaWYgaXQncyBub3QgZW1wdHkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gaW5wdXRWYWx1ZVxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5nc1xuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gc2lnbk9uRW1wdHlcbiAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjaGVja0VtcHR5KGlucHV0VmFsdWUsIHNldHRpbmdzLCBzaWduT25FbXB0eSkge1xuICAgICAgICBpZiAoaW5wdXRWYWx1ZSA9PT0gJycgfHwgaW5wdXRWYWx1ZSA9PT0gc2V0dGluZ3MubmVnYXRpdmVTaWduQ2hhcmFjdGVyKSB7XG4gICAgICAgICAgICBpZiAoc2V0dGluZ3MuZW1wdHlJbnB1dEJlaGF2aW9yID09PSAnYWx3YXlzJyB8fCBzaWduT25FbXB0eSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAoc2V0dGluZ3MubmVnYXRpdmVQb3NpdGl2ZVNpZ25QbGFjZW1lbnQgPT09ICdsJykgPyBpbnB1dFZhbHVlICsgc2V0dGluZ3MuY3VycmVuY3lTeW1ib2wgKyBzZXR0aW5ncy5zdWZmaXhUZXh0IDogc2V0dGluZ3MuY3VycmVuY3lTeW1ib2wgKyBpbnB1dFZhbHVlICsgc2V0dGluZ3Muc3VmZml4VGV4dDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGlucHV0VmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNb2RpZnkgdGhlIGlucHV0IHZhbHVlIGJ5IGFkZGluZyB0aGUgZ3JvdXAgc2VwYXJhdG9ycywgYXMgZGVmaW5lZCBpbiB0aGUgc2V0dGluZ3MuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gaW5wdXRWYWx1ZVxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5nc1xuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGFkZEdyb3VwU2VwYXJhdG9ycyhpbnB1dFZhbHVlLCBzZXR0aW5ncykge1xuICAgICAgICBpZiAoc2V0dGluZ3Muc3RyaXApIHtcbiAgICAgICAgICAgIGlucHV0VmFsdWUgPSBzdHJpcEFsbE5vbk51bWJlckNoYXJhY3RlcnMoaW5wdXRWYWx1ZSwgc2V0dGluZ3MsIGZhbHNlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vVE9ETyBUaGlzIGZ1bmN0aW9uIGBhZGRHcm91cFNlcGFyYXRvcnMoKWAgYWRkIGdyb3VwIHNlcGFyYXRvcnMuIEFkZGluZyB0aGUgbmVnYXRpdmUgc2lnbiBhcyB3ZWxsIGlzIG91dCBvZiBpdHMgc2NvcGUuIE1vdmUgdGhhdCB0byBhbm90aGVyIGZ1bmN0aW9uLlxuICAgICAgICBpZiAoc2V0dGluZ3MudHJhaWxpbmdOZWdhdGl2ZSAmJiAhaXNOZWdhdGl2ZShpbnB1dFZhbHVlKSkge1xuICAgICAgICAgICAgaW5wdXRWYWx1ZSA9ICctJyArIGlucHV0VmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBlbXB0eSA9IGNoZWNrRW1wdHkoaW5wdXRWYWx1ZSwgc2V0dGluZ3MsIHRydWUpO1xuICAgICAgICBjb25zdCBpc1ZhbHVlTmVnYXRpdmUgPSBpc05lZ2F0aXZlKGlucHV0VmFsdWUpO1xuICAgICAgICBjb25zdCBpc1plcm8gPSBpc1plcm9Pckhhc05vVmFsdWUoaW5wdXRWYWx1ZSk7XG4gICAgICAgIGlmIChpc1ZhbHVlTmVnYXRpdmUpIHtcbiAgICAgICAgICAgIGlucHV0VmFsdWUgPSBpbnB1dFZhbHVlLnJlcGxhY2UoJy0nLCAnJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWlzTnVsbChlbXB0eSkpIHtcbiAgICAgICAgICAgIHJldHVybiBlbXB0eTtcbiAgICAgICAgfVxuXG4gICAgICAgIHNldHRpbmdzLmRpZ2l0YWxHcm91cFNwYWNpbmcgPSBzZXR0aW5ncy5kaWdpdGFsR3JvdXBTcGFjaW5nLnRvU3RyaW5nKCk7XG4gICAgICAgIGxldCBkaWdpdGFsR3JvdXA7XG4gICAgICAgIHN3aXRjaCAoc2V0dGluZ3MuZGlnaXRhbEdyb3VwU3BhY2luZykge1xuICAgICAgICAgICAgY2FzZSAnMic6XG4gICAgICAgICAgICAgICAgZGlnaXRhbEdyb3VwID0gLyhcXGQpKChcXGQpKFxcZHsyfT8pKykkLztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJzJzJzpcbiAgICAgICAgICAgICAgICBkaWdpdGFsR3JvdXAgPSAvKFxcZCkoKD86XFxkezJ9KXswLDJ9XFxkezN9KD86KD86XFxkezJ9KXsyfVxcZHszfSkqPykkLztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJzQnOlxuICAgICAgICAgICAgICAgIGRpZ2l0YWxHcm91cCA9IC8oXFxkKSgoXFxkezR9PykrKSQvO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdCA6XG4gICAgICAgICAgICAgICAgZGlnaXRhbEdyb3VwID0gLyhcXGQpKChcXGR7M30/KSspJC87XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTcGxpdHMgdGhlIHN0cmluZyBhdCB0aGUgZGVjaW1hbCBzdHJpbmdcbiAgICAgICAgbGV0IFtpbnRlZ2VyUGFydCwgZGVjaW1hbFBhcnRdID0gaW5wdXRWYWx1ZS5zcGxpdChzZXR0aW5ncy5kZWNpbWFsQ2hhcmFjdGVyKTtcbiAgICAgICAgaWYgKHNldHRpbmdzLmRlY2ltYWxDaGFyYWN0ZXJBbHRlcm5hdGl2ZSAmJiBpc1VuZGVmaW5lZChkZWNpbWFsUGFydCkpIHtcbiAgICAgICAgICAgIFtpbnRlZ2VyUGFydCwgZGVjaW1hbFBhcnRdID0gaW5wdXRWYWx1ZS5zcGxpdChzZXR0aW5ncy5kZWNpbWFsQ2hhcmFjdGVyQWx0ZXJuYXRpdmUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNldHRpbmdzLmRpZ2l0R3JvdXBTZXBhcmF0b3IgIT09ICcnKSB7XG4gICAgICAgICAgICAvLyBSZS1pbnNlcnRzIHRoZSB0aG91c2FuZCBzZXBhcmF0b3IgdmlhIGEgcmVndWxhciBleHByZXNzaW9uXG4gICAgICAgICAgICB3aGlsZSAoZGlnaXRhbEdyb3VwLnRlc3QoaW50ZWdlclBhcnQpKSB7XG4gICAgICAgICAgICAgICAgaW50ZWdlclBhcnQgPSBpbnRlZ2VyUGFydC5yZXBsYWNlKGRpZ2l0YWxHcm91cCwgYCQxJHtzZXR0aW5ncy5kaWdpdEdyb3VwU2VwYXJhdG9yfSQyYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc2V0dGluZ3MuZGVjaW1hbFBsYWNlc092ZXJyaWRlICE9PSAwICYmICFpc1VuZGVmaW5lZChkZWNpbWFsUGFydCkpIHtcbiAgICAgICAgICAgIGlmIChkZWNpbWFsUGFydC5sZW5ndGggPiBzZXR0aW5ncy5kZWNpbWFsUGxhY2VzT3ZlcnJpZGUpIHtcbiAgICAgICAgICAgICAgICBkZWNpbWFsUGFydCA9IGRlY2ltYWxQYXJ0LnN1YnN0cmluZygwLCBzZXR0aW5ncy5kZWNpbWFsUGxhY2VzT3ZlcnJpZGUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBKb2lucyB0aGUgd2hvbGUgbnVtYmVyIHdpdGggdGhlIGRlY2ltYWwgdmFsdWVcbiAgICAgICAgICAgIGlucHV0VmFsdWUgPSBpbnRlZ2VyUGFydCArIHNldHRpbmdzLmRlY2ltYWxDaGFyYWN0ZXIgKyBkZWNpbWFsUGFydDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIE90aGVyd2lzZSBpZiBpdCdzIGFuIGludGVnZXJcbiAgICAgICAgICAgIGlucHV0VmFsdWUgPSBpbnRlZ2VyUGFydDtcbiAgICAgICAgfVxuXG4gICAgICAgIHNldHRpbmdzLnRyYWlsaW5nTmVnYXRpdmUgPSBmYWxzZTtcblxuICAgICAgICBpZiAoc2V0dGluZ3MuY3VycmVuY3lTeW1ib2xQbGFjZW1lbnQgPT09ICdwJykge1xuICAgICAgICAgICAgaWYgKGlzVmFsdWVOZWdhdGl2ZSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoc2V0dGluZ3MubmVnYXRpdmVQb3NpdGl2ZVNpZ25QbGFjZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnbCc6XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnB1dFZhbHVlID0gYCR7c2V0dGluZ3MubmVnYXRpdmVTaWduQ2hhcmFjdGVyfSR7c2V0dGluZ3MuY3VycmVuY3lTeW1ib2x9JHtpbnB1dFZhbHVlfWA7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAncic6XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnB1dFZhbHVlID0gYCR7c2V0dGluZ3MuY3VycmVuY3lTeW1ib2x9JHtzZXR0aW5ncy5uZWdhdGl2ZVNpZ25DaGFyYWN0ZXJ9JHtpbnB1dFZhbHVlfWA7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAncyc6XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnB1dFZhbHVlID0gYCR7c2V0dGluZ3MuY3VycmVuY3lTeW1ib2x9JHtpbnB1dFZhbHVlfSR7c2V0dGluZ3MubmVnYXRpdmVTaWduQ2hhcmFjdGVyfWA7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXR0aW5ncy50cmFpbGluZ05lZ2F0aXZlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0IDpcbiAgICAgICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHNldHRpbmdzLnNob3dQb3NpdGl2ZVNpZ24gJiYgIWlzWmVybykge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoc2V0dGluZ3MubmVnYXRpdmVQb3NpdGl2ZVNpZ25QbGFjZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnbCc6XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnB1dFZhbHVlID0gYCR7c2V0dGluZ3MucG9zaXRpdmVTaWduQ2hhcmFjdGVyfSR7c2V0dGluZ3MuY3VycmVuY3lTeW1ib2x9JHtpbnB1dFZhbHVlfWA7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAncic6XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnB1dFZhbHVlID0gYCR7c2V0dGluZ3MuY3VycmVuY3lTeW1ib2x9JHtzZXR0aW5ncy5wb3NpdGl2ZVNpZ25DaGFyYWN0ZXJ9JHtpbnB1dFZhbHVlfWA7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAncyc6XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnB1dFZhbHVlID0gYCR7c2V0dGluZ3MuY3VycmVuY3lTeW1ib2x9JHtpbnB1dFZhbHVlfSR7c2V0dGluZ3MucG9zaXRpdmVTaWduQ2hhcmFjdGVyfWA7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdCA6XG4gICAgICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpbnB1dFZhbHVlID0gc2V0dGluZ3MuY3VycmVuY3lTeW1ib2wgKyBpbnB1dFZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNldHRpbmdzLmN1cnJlbmN5U3ltYm9sUGxhY2VtZW50ID09PSAncycpIHtcbiAgICAgICAgICAgIGlmIChpc1ZhbHVlTmVnYXRpdmUpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHNldHRpbmdzLm5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3InOlxuICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXRWYWx1ZSA9IGAke2lucHV0VmFsdWV9JHtzZXR0aW5ncy5jdXJyZW5jeVN5bWJvbH0ke3NldHRpbmdzLm5lZ2F0aXZlU2lnbkNoYXJhY3Rlcn1gO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3MudHJhaWxpbmdOZWdhdGl2ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnbCc6XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnB1dFZhbHVlID0gYCR7aW5wdXRWYWx1ZX0ke3NldHRpbmdzLm5lZ2F0aXZlU2lnbkNoYXJhY3Rlcn0ke3NldHRpbmdzLmN1cnJlbmN5U3ltYm9sfWA7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXR0aW5ncy50cmFpbGluZ05lZ2F0aXZlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdwJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlucHV0VmFsdWUgPSBgJHtzZXR0aW5ncy5uZWdhdGl2ZVNpZ25DaGFyYWN0ZXJ9JHtpbnB1dFZhbHVlfSR7c2V0dGluZ3MuY3VycmVuY3lTeW1ib2x9YDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0IDpcbiAgICAgICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHNldHRpbmdzLnNob3dQb3NpdGl2ZVNpZ24gJiYgIWlzWmVybykge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoc2V0dGluZ3MubmVnYXRpdmVQb3NpdGl2ZVNpZ25QbGFjZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAncic6XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnB1dFZhbHVlID0gYCR7aW5wdXRWYWx1ZX0ke3NldHRpbmdzLmN1cnJlbmN5U3ltYm9sfSR7c2V0dGluZ3MucG9zaXRpdmVTaWduQ2hhcmFjdGVyfWA7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnbCc6XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnB1dFZhbHVlID0gYCR7aW5wdXRWYWx1ZX0ke3NldHRpbmdzLnBvc2l0aXZlU2lnbkNoYXJhY3Rlcn0ke3NldHRpbmdzLmN1cnJlbmN5U3ltYm9sfWA7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAncCc6XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnB1dFZhbHVlID0gYCR7c2V0dGluZ3MucG9zaXRpdmVTaWduQ2hhcmFjdGVyfSR7aW5wdXRWYWx1ZX0ke3NldHRpbmdzLmN1cnJlbmN5U3ltYm9sfWA7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdCA6XG4gICAgICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpbnB1dFZhbHVlID0gaW5wdXRWYWx1ZSArIHNldHRpbmdzLmN1cnJlbmN5U3ltYm9sO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gUmVtb3ZlcyB0aGUgbmVnYXRpdmUgc2lnbiBhbmQgcGxhY2VzIGJyYWNrZXRzXG4gICAgICAgIGlmIChzZXR0aW5ncy5uZWdhdGl2ZUJyYWNrZXRzVHlwZU9uQmx1ciAhPT0gbnVsbCAmJiAoc2V0dGluZ3MucmF3VmFsdWUgPCAwIHx8IGlzTmVnYXRpdmVTdHJpY3QoaW5wdXRWYWx1ZSkpKSB7XG4gICAgICAgICAgICBpbnB1dFZhbHVlID0gdG9nZ2xlTmVnYXRpdmVCcmFja2V0KGlucHV0VmFsdWUsIHNldHRpbmdzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBpbnB1dFZhbHVlICsgc2V0dGluZ3Muc3VmZml4VGV4dDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcnVuY2F0ZSBub3QgbmVlZGVkIHplcm9zXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcm91bmRlZElucHV0VmFsdWVcbiAgICAgKiBAcGFyYW0ge2ludH0gdGVtcG9yYXJ5RGVjaW1hbFBsYWNlc092ZXJyaWRlXG4gICAgICogQHJldHVybnMge3ZvaWR8WE1MfHN0cmluZ3wqfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRydW5jYXRlWmVyb3Mocm91bmRlZElucHV0VmFsdWUsIHRlbXBvcmFyeURlY2ltYWxQbGFjZXNPdmVycmlkZSkge1xuICAgICAgICBsZXQgcmVnZXg7XG4gICAgICAgIHN3aXRjaCAodGVtcG9yYXJ5RGVjaW1hbFBsYWNlc092ZXJyaWRlKSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgLy8gUHJldmVudHMgcGFkZGluZyAtIHJlbW92ZXMgdHJhaWxpbmcgemVyb3MgdW50aWwgdGhlIGZpcnN0IHNpZ25pZmljYW50IGRpZ2l0IGlzIGVuY291bnRlcmVkXG4gICAgICAgICAgICAgICAgcmVnZXggPSAvKFxcLig/OlxcZCpbMS05XSk/KTAqJC87XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgLy8gQWxsb3dzIHBhZGRpbmcgd2hlbiBkZWNpbWFsUGxhY2VzT3ZlcnJpZGUgZXF1YWxzIG9uZSAtIGxlYXZlcyBvbmUgemVybyB0cmFpbGluZyB0aGUgZGVjaW1hbCBjaGFyYWN0ZXJcbiAgICAgICAgICAgICAgICByZWdleCA9IC8oXFwuXFxkKD86XFxkKlsxLTldKT8pMCokLztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQgOlxuICAgICAgICAgICAgICAgIC8vIFJlbW92ZXMgYWNjZXNzIHplcm9zIHRvIHRoZSBkZWNpbWFsUGxhY2VzT3ZlcnJpZGUgbGVuZ3RoIHdoZW4gYWxsb3dEZWNpbWFsUGFkZGluZyBpcyBzZXQgdG8gdHJ1ZVxuICAgICAgICAgICAgICAgIHJlZ2V4ID0gbmV3IFJlZ0V4cChgKFxcXFwuXFxcXGR7JHt0ZW1wb3JhcnlEZWNpbWFsUGxhY2VzT3ZlcnJpZGV9fSg/OlxcXFxkKlsxLTldKT8pMCpgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIHRoZXJlIGFyZSBubyBkZWNpbWFsIHBsYWNlcywgd2UgZG9uJ3QgbmVlZCBhIGRlY2ltYWwgcG9pbnQgYXQgdGhlIGVuZFxuICAgICAgICByb3VuZGVkSW5wdXRWYWx1ZSA9IHJvdW5kZWRJbnB1dFZhbHVlLnJlcGxhY2UocmVnZXgsICckMScpO1xuICAgICAgICBpZiAodGVtcG9yYXJ5RGVjaW1hbFBsYWNlc092ZXJyaWRlID09PSAwKSB7XG4gICAgICAgICAgICByb3VuZGVkSW5wdXRWYWx1ZSA9IHJvdW5kZWRJbnB1dFZhbHVlLnJlcGxhY2UoL1xcLiQvLCAnJyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcm91bmRlZElucHV0VmFsdWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUm91bmQgdGhlIGlucHV0IHZhbHVlIHVzaW5nIHRoZSByb3VuZGluZyBtZXRob2QgZGVmaW5lZCBpbiB0aGUgc2V0dGluZ3MuXG4gICAgICogVGhpcyBmdW5jdGlvbiBhY2NlcHRzIG11bHRpcGxlIHJvdW5kaW5nIG1ldGhvZHMuIFNlZSB0aGUgZG9jdW1lbnRhdGlvbiBmb3IgbW9yZSBkZXRhaWxzIGFib3V0IHRob3NlLlxuICAgICAqXG4gICAgICogTm90ZSA6IFRoaXMgaXMgaGFuZGxlZCBhcyB0ZXh0IHNpbmNlIEphdmFTY3JpcHQgbWF0aCBmdW5jdGlvbiBjYW4gcmV0dXJuIGluYWNjdXJhdGUgdmFsdWVzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGlucHV0VmFsdWVcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3NcbiAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiByb3VuZFZhbHVlKGlucHV0VmFsdWUsIHNldHRpbmdzKSB7XG4gICAgICAgIGlucHV0VmFsdWUgPSAoaW5wdXRWYWx1ZSA9PT0gJycpID8gJzAnIDogaW5wdXRWYWx1ZS50b1N0cmluZygpO1xuICAgICAgICBpZiAoc2V0dGluZ3Mucm91bmRpbmdNZXRob2QgPT09ICdOMDUnIHx8IHNldHRpbmdzLnJvdW5kaW5nTWV0aG9kID09PSAnQ0hGJyB8fCBzZXR0aW5ncy5yb3VuZGluZ01ldGhvZCA9PT0gJ1UwNScgfHwgc2V0dGluZ3Mucm91bmRpbmdNZXRob2QgPT09ICdEMDUnKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHNldHRpbmdzLnJvdW5kaW5nTWV0aG9kKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnTjA1JzpcbiAgICAgICAgICAgICAgICAgICAgaW5wdXRWYWx1ZSA9IChNYXRoLnJvdW5kKGlucHV0VmFsdWUgKiAyMCkgLyAyMCkudG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnVTA1JzpcbiAgICAgICAgICAgICAgICAgICAgaW5wdXRWYWx1ZSA9IChNYXRoLmNlaWwoaW5wdXRWYWx1ZSAqIDIwKSAvIDIwKS50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0IDpcbiAgICAgICAgICAgICAgICAgICAgaW5wdXRWYWx1ZSA9IChNYXRoLmZsb29yKGlucHV0VmFsdWUgKiAyMCkgLyAyMCkudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbGV0IHJlc3VsdDtcbiAgICAgICAgICAgIGlmICghY29udGFpbnMoaW5wdXRWYWx1ZSwgJy4nKSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGlucHV0VmFsdWUgKyAnLjAwJztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaW5wdXRWYWx1ZS5sZW5ndGggLSBpbnB1dFZhbHVlLmluZGV4T2YoJy4nKSA8IDMpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBpbnB1dFZhbHVlICsgJzAnO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBpbnB1dFZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBpdlJvdW5kZWQgPSAnJztcbiAgICAgICAgbGV0IGkgPSAwO1xuICAgICAgICBsZXQgblNpZ24gPSAnJztcbiAgICAgICAgbGV0IHRlbXBvcmFyeURlY2ltYWxQbGFjZXNPdmVycmlkZTtcblxuICAgICAgICAvLyBzZXRzIHRoZSB0cnVuY2F0ZSB6ZXJvIG1ldGhvZFxuICAgICAgICBpZiAoc2V0dGluZ3MuYWxsb3dEZWNpbWFsUGFkZGluZykge1xuICAgICAgICAgICAgdGVtcG9yYXJ5RGVjaW1hbFBsYWNlc092ZXJyaWRlID0gc2V0dGluZ3MuZGVjaW1hbFBsYWNlc092ZXJyaWRlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGVtcG9yYXJ5RGVjaW1hbFBsYWNlc092ZXJyaWRlID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENoZWNrcyBpZiB0aGUgaW5wdXRWYWx1ZSAoaW5wdXQgVmFsdWUpIGlzIGEgbmVnYXRpdmUgdmFsdWVcbiAgICAgICAgaWYgKGlzTmVnYXRpdmVTdHJpY3QoaW5wdXRWYWx1ZSkpIHtcbiAgICAgICAgICAgIG5TaWduID0gJy0nO1xuXG4gICAgICAgICAgICAvLyBSZW1vdmVzIHRoZSBuZWdhdGl2ZSBzaWduIHRoYXQgd2lsbCBiZSBhZGRlZCBiYWNrIGxhdGVyIGlmIHJlcXVpcmVkXG4gICAgICAgICAgICBpbnB1dFZhbHVlID0gaW5wdXRWYWx1ZS5yZXBsYWNlKCctJywgJycpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQXBwZW5kIGEgemVybyBpZiB0aGUgZmlyc3QgY2hhcmFjdGVyIGlzIG5vdCBhIGRpZ2l0ICh0aGVuIGl0IGlzIGxpa2VseSB0byBiZSBhIGRvdClcbiAgICAgICAgaWYgKCFpbnB1dFZhbHVlLm1hdGNoKC9eXFxkLykpIHtcbiAgICAgICAgICAgIGlucHV0VmFsdWUgPSAnMCcgKyBpbnB1dFZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRGV0ZXJtaW5lcyBpZiB0aGUgdmFsdWUgaXMgZXF1YWwgdG8gemVyby4gSWYgaXQgaXMsIHJlbW92ZSB0aGUgbmVnYXRpdmUgc2lnblxuICAgICAgICBpZiAoTnVtYmVyKGlucHV0VmFsdWUpID09PSAwKSB7XG4gICAgICAgICAgICBuU2lnbiA9ICcnO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVHJpbXMgbGVhZGluZyB6ZXJvJ3MgYXMgbmVlZGVkXG4gICAgICAgIGlmICgoTnVtYmVyKGlucHV0VmFsdWUpID4gMCAmJiBzZXR0aW5ncy5sZWFkaW5nWmVybyAhPT0gJ2tlZXAnKSB8fCAoaW5wdXRWYWx1ZS5sZW5ndGggPiAwICYmIHNldHRpbmdzLmxlYWRpbmdaZXJvID09PSAnYWxsb3cnKSkge1xuICAgICAgICAgICAgaW5wdXRWYWx1ZSA9IGlucHV0VmFsdWUucmVwbGFjZSgvXjAqKFxcZCkvLCAnJDEnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGRQb3MgPSBpbnB1dFZhbHVlLmxhc3RJbmRleE9mKCcuJyk7XG4gICAgICAgIGNvbnN0IGlucHV0VmFsdWVIYXNBRG90ID0gZFBvcyA9PT0gLTE7XG5cbiAgICAgICAgLy8gVmlydHVhbCBkZWNpbWFsIHBvc2l0aW9uXG4gICAgICAgIGNvbnN0IHZkUG9zID0gaW5wdXRWYWx1ZUhhc0FEb3QgPyBpbnB1dFZhbHVlLmxlbmd0aCAtIDEgOiBkUG9zO1xuXG4gICAgICAgIC8vIENoZWNrcyBkZWNpbWFsIHBsYWNlcyB0byBkZXRlcm1pbmUgaWYgcm91bmRpbmcgaXMgcmVxdWlyZWQgOlxuICAgICAgICAvLyBDaGVjayBpZiBubyByb3VuZGluZyBpcyByZXF1aXJlZFxuICAgICAgICBsZXQgY0RlYyA9IChpbnB1dFZhbHVlLmxlbmd0aCAtIDEpIC0gdmRQb3M7XG5cbiAgICAgICAgaWYgKGNEZWMgPD0gc2V0dGluZ3MuZGVjaW1hbFBsYWNlc092ZXJyaWRlKSB7XG4gICAgICAgICAgICAvLyBDaGVjayBpZiB3ZSBuZWVkIHRvIHBhZCB3aXRoIHplcm9zXG4gICAgICAgICAgICBpdlJvdW5kZWQgPSBpbnB1dFZhbHVlO1xuICAgICAgICAgICAgaWYgKGNEZWMgPCB0ZW1wb3JhcnlEZWNpbWFsUGxhY2VzT3ZlcnJpZGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoaW5wdXRWYWx1ZUhhc0FEb3QpIHtcbiAgICAgICAgICAgICAgICAgICAgaXZSb3VuZGVkICs9IHNldHRpbmdzLmRlY2ltYWxDaGFyYWN0ZXI7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgbGV0IHplcm9zID0gJzAwMDAwMCc7XG4gICAgICAgICAgICAgICAgd2hpbGUgKGNEZWMgPCB0ZW1wb3JhcnlEZWNpbWFsUGxhY2VzT3ZlcnJpZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgemVyb3MgPSB6ZXJvcy5zdWJzdHJpbmcoMCwgdGVtcG9yYXJ5RGVjaW1hbFBsYWNlc092ZXJyaWRlIC0gY0RlYyk7XG4gICAgICAgICAgICAgICAgICAgIGl2Um91bmRlZCArPSB6ZXJvcztcbiAgICAgICAgICAgICAgICAgICAgY0RlYyArPSB6ZXJvcy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChjRGVjID4gdGVtcG9yYXJ5RGVjaW1hbFBsYWNlc092ZXJyaWRlKSB7XG4gICAgICAgICAgICAgICAgaXZSb3VuZGVkID0gdHJ1bmNhdGVaZXJvcyhpdlJvdW5kZWQsIHRlbXBvcmFyeURlY2ltYWxQbGFjZXNPdmVycmlkZSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNEZWMgPT09IDAgJiYgdGVtcG9yYXJ5RGVjaW1hbFBsYWNlc092ZXJyaWRlID09PSAwKSB7XG4gICAgICAgICAgICAgICAgaXZSb3VuZGVkID0gaXZSb3VuZGVkLnJlcGxhY2UoL1xcLiQvLCAnJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiAoTnVtYmVyKGl2Um91bmRlZCkgPT09IDApID8gaXZSb3VuZGVkIDogblNpZ24gKyBpdlJvdW5kZWQ7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBSb3VuZGVkIGxlbmd0aCBvZiB0aGUgc3RyaW5nIGFmdGVyIHJvdW5kaW5nXG4gICAgICAgIGxldCByTGVuZ3RoO1xuICAgICAgICBpZiAoaW5wdXRWYWx1ZUhhc0FEb3QpIHtcbiAgICAgICAgICAgIHJMZW5ndGggPSBzZXR0aW5ncy5kZWNpbWFsUGxhY2VzT3ZlcnJpZGUgLSAxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgckxlbmd0aCA9IHNldHRpbmdzLmRlY2ltYWxQbGFjZXNPdmVycmlkZSArIGRQb3M7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB0Um91bmQgPSBOdW1iZXIoaW5wdXRWYWx1ZS5jaGFyQXQockxlbmd0aCArIDEpKTtcbiAgICAgICAgY29uc3Qgb2RkID0gKGlucHV0VmFsdWUuY2hhckF0KHJMZW5ndGgpID09PSAnLicpID8gKGlucHV0VmFsdWUuY2hhckF0KHJMZW5ndGggLSAxKSAlIDIpIDogKGlucHV0VmFsdWUuY2hhckF0KHJMZW5ndGgpICUgMik7XG4gICAgICAgIGxldCBpdkFycmF5ID0gaW5wdXRWYWx1ZS5zdWJzdHJpbmcoMCwgckxlbmd0aCArIDEpLnNwbGl0KCcnKTtcblxuICAgICAgICBpZiAoKHRSb3VuZCA+IDQgJiYgc2V0dGluZ3Mucm91bmRpbmdNZXRob2QgPT09ICdTJykgICAgICAgICAgICAgICAgICB8fCAvLyBSb3VuZCBoYWxmIHVwIHN5bW1ldHJpY1xuICAgICAgICAgICAgKHRSb3VuZCA+IDQgJiYgc2V0dGluZ3Mucm91bmRpbmdNZXRob2QgPT09ICdBJyAmJiBuU2lnbiA9PT0gJycpICB8fCAvLyBSb3VuZCBoYWxmIHVwIGFzeW1tZXRyaWMgcG9zaXRpdmUgdmFsdWVzXG4gICAgICAgICAgICAodFJvdW5kID4gNSAmJiBzZXR0aW5ncy5yb3VuZGluZ01ldGhvZCA9PT0gJ0EnICYmIG5TaWduID09PSAnLScpIHx8IC8vIFJvdW5kIGhhbGYgdXAgYXN5bW1ldHJpYyBuZWdhdGl2ZSB2YWx1ZXNcbiAgICAgICAgICAgICh0Um91bmQgPiA1ICYmIHNldHRpbmdzLnJvdW5kaW5nTWV0aG9kID09PSAncycpICAgICAgICAgICAgICAgICAgfHwgLy8gUm91bmQgaGFsZiBkb3duIHN5bW1ldHJpY1xuICAgICAgICAgICAgKHRSb3VuZCA+IDUgJiYgc2V0dGluZ3Mucm91bmRpbmdNZXRob2QgPT09ICdhJyAmJiBuU2lnbiA9PT0gJycpICB8fCAvLyBSb3VuZCBoYWxmIGRvd24gYXN5bW1ldHJpYyBwb3NpdGl2ZSB2YWx1ZXNcbiAgICAgICAgICAgICh0Um91bmQgPiA0ICYmIHNldHRpbmdzLnJvdW5kaW5nTWV0aG9kID09PSAnYScgJiYgblNpZ24gPT09ICctJykgfHwgLy8gUm91bmQgaGFsZiBkb3duIGFzeW1tZXRyaWMgbmVnYXRpdmUgdmFsdWVzXG4gICAgICAgICAgICAodFJvdW5kID4gNSAmJiBzZXR0aW5ncy5yb3VuZGluZ01ldGhvZCA9PT0gJ0InKSAgICAgICAgICAgICAgICAgIHx8IC8vIFJvdW5kIGhhbGYgZXZlbiBcIkJhbmtlcidzIFJvdW5kaW5nXCJcbiAgICAgICAgICAgICh0Um91bmQgPT09IDUgJiYgc2V0dGluZ3Mucm91bmRpbmdNZXRob2QgPT09ICdCJyAmJiBvZGQgPT09IDEpICAgfHwgLy8gUm91bmQgaGFsZiBldmVuIFwiQmFua2VyJ3MgUm91bmRpbmdcIlxuICAgICAgICAgICAgKHRSb3VuZCA+IDAgJiYgc2V0dGluZ3Mucm91bmRpbmdNZXRob2QgPT09ICdDJyAmJiBuU2lnbiA9PT0gJycpICB8fCAvLyBSb3VuZCB0byBjZWlsaW5nIHRvd2FyZCBwb3NpdGl2ZSBpbmZpbml0ZVxuICAgICAgICAgICAgKHRSb3VuZCA+IDAgJiYgc2V0dGluZ3Mucm91bmRpbmdNZXRob2QgPT09ICdGJyAmJiBuU2lnbiA9PT0gJy0nKSB8fCAvLyBSb3VuZCB0byBmbG9vciB0b3dhcmQgbmVnYXRpdmUgaW5maW5pdGVcbiAgICAgICAgICAgICh0Um91bmQgPiAwICYmIHNldHRpbmdzLnJvdW5kaW5nTWV0aG9kID09PSAnVScpKSB7ICAgICAgICAgICAgICAgICAgLy8gUm91bmQgdXAgYXdheSBmcm9tIHplcm9cbiAgICAgICAgICAgIC8vIFJvdW5kIHVwIHRoZSBsYXN0IGRpZ2l0IGlmIHJlcXVpcmVkLCBhbmQgY29udGludWUgdW50aWwgbm8gbW9yZSA5J3MgYXJlIGZvdW5kXG4gICAgICAgICAgICBmb3IgKGkgPSAoaXZBcnJheS5sZW5ndGggLSAxKTsgaSA+PSAwOyBpIC09IDEpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXZBcnJheVtpXSAhPT0gJy4nKSB7XG4gICAgICAgICAgICAgICAgICAgIGl2QXJyYXlbaV0gPSAraXZBcnJheVtpXSArIDE7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpdkFycmF5W2ldIDwgMTApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGkgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpdkFycmF5W2ldID0gJzAnO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gUmVjb25zdHJ1Y3QgdGhlIHN0cmluZywgY29udmVydGluZyBhbnkgMTAncyB0byAwJ3NcbiAgICAgICAgaXZBcnJheSA9IGl2QXJyYXkuc2xpY2UoMCwgckxlbmd0aCArIDEpO1xuXG4gICAgICAgIC8vIFJldHVybiB0aGUgcm91bmRlZCB2YWx1ZVxuICAgICAgICBpdlJvdW5kZWQgPSB0cnVuY2F0ZVplcm9zKGl2QXJyYXkuam9pbignJyksIHRlbXBvcmFyeURlY2ltYWxQbGFjZXNPdmVycmlkZSk7XG5cbiAgICAgICAgcmV0dXJuIChOdW1iZXIoaXZSb3VuZGVkKSA9PT0gMCkgPyBpdlJvdW5kZWQgOiBuU2lnbiArIGl2Um91bmRlZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcnVuY2F0ZXMgdGhlIGRlY2ltYWwgcGFydCBvZiBhIG51bWJlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHNldHRpbmdzXG4gICAgICogQHBhcmFtIHtib29sZWFufSBpc1Bhc3RlXG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICovXG4gICAgZnVuY3Rpb24gdHJ1bmNhdGVEZWNpbWFsKHMsIHNldHRpbmdzLCBpc1Bhc3RlKSB7XG4gICAgICAgIHMgPSAoaXNQYXN0ZSkgPyByb3VuZFZhbHVlKHMsIHNldHRpbmdzKSA6IHM7XG5cbiAgICAgICAgaWYgKHNldHRpbmdzLmRlY2ltYWxDaGFyYWN0ZXIgJiYgc2V0dGluZ3MuZGVjaW1hbFBsYWNlc092ZXJyaWRlKSB7XG4gICAgICAgICAgICBjb25zdCBbaW50ZWdlclBhcnQsIGRlY2ltYWxQYXJ0XSA9IHMuc3BsaXQoc2V0dGluZ3MuZGVjaW1hbENoYXJhY3Rlcik7XG5cbiAgICAgICAgICAgIC8vIHRydW5jYXRlIGRlY2ltYWwgcGFydCB0byBzYXRpc2Z5aW5nIGxlbmd0aCBzaW5jZSB3ZSB3b3VsZCByb3VuZCBpdCBhbnl3YXlcbiAgICAgICAgICAgIGlmIChkZWNpbWFsUGFydCAmJiBkZWNpbWFsUGFydC5sZW5ndGggPiBzZXR0aW5ncy5kZWNpbWFsUGxhY2VzT3ZlcnJpZGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoc2V0dGluZ3MuZGVjaW1hbFBsYWNlc092ZXJyaWRlID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBtb2RpZmllZERlY2ltYWxQYXJ0ID0gZGVjaW1hbFBhcnQuc3Vic3RyaW5nKDAsIHNldHRpbmdzLmRlY2ltYWxQbGFjZXNPdmVycmlkZSk7XG4gICAgICAgICAgICAgICAgICAgIHMgPSBgJHtpbnRlZ2VyUGFydH0ke3NldHRpbmdzLmRlY2ltYWxDaGFyYWN0ZXJ9JHttb2RpZmllZERlY2ltYWxQYXJ0fWA7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcyA9IGludGVnZXJQYXJ0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZ1bmN0aW9uIHRvIHBhcnNlIG1pbmltdW1WYWx1ZSwgbWF4aW11bVZhbHVlICYgdGhlIGlucHV0IHZhbHVlIHRvIHByZXBhcmUgZm9yIHRlc3RpbmcgdG8gZGV0ZXJtaW5lIGlmIHRoZSB2YWx1ZSBmYWxscyB3aXRoaW4gdGhlIG1pbiAvIG1heCByYW5nZS5cbiAgICAgKiBSZXR1cm4gYW4gb2JqZWN0IGV4YW1wbGU6IG1pbmltdW1WYWx1ZTogXCI5OTk5OTk5OTk5OTk5OTkuOTlcIiByZXR1cm5zIHRoZSBmb2xsb3dpbmcgXCJ7czogLTEsIGU6IDEyLCBjOiBBcnJheVsxNV19XCIuXG4gICAgICpcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIGlzIGFkYXB0ZWQgZnJvbSBCaWcuanMgaHR0cHM6Ly9naXRodWIuY29tL01pa2VNY2wvYmlnLmpzLy4gTWFueSB0aGFua3MgdG8gTWlrZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfHN0cmluZ30gbiBBIG51bWVyaWMgdmFsdWUuXG4gICAgICogQHJldHVybnMge3t9fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHBhcnNlU3RyKG4pIHtcbiAgICAgICAgY29uc3QgeCA9IHt9OyAvLyBBIEJpZyBudW1iZXIgaW5zdGFuY2UuXG4gICAgICAgIGxldCBlO1xuICAgICAgICBsZXQgaTtcbiAgICAgICAgbGV0IG5MO1xuICAgICAgICBsZXQgajtcblxuICAgICAgICAvLyBNaW51cyB6ZXJvP1xuICAgICAgICBpZiAobiA9PT0gMCAmJiAxIC8gbiA8IDApIHtcbiAgICAgICAgICAgIG4gPSAnLTAnO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRGV0ZXJtaW5lIHNpZ24uIDEgcG9zaXRpdmUsIC0xIG5lZ2F0aXZlXG4gICAgICAgIG4gPSBuLnRvU3RyaW5nKCk7XG4gICAgICAgIGlmIChpc05lZ2F0aXZlU3RyaWN0KG4pKSB7XG4gICAgICAgICAgICBuID0gbi5zbGljZSgxKTtcbiAgICAgICAgICAgIHgucyA9IC0xO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgeC5zID0gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIERlY2ltYWwgcG9pbnQ/XG4gICAgICAgIGUgPSBuLmluZGV4T2YoJy4nKTtcbiAgICAgICAgaWYgKGUgPiAtMSkge1xuICAgICAgICAgICAgbiA9IG4ucmVwbGFjZSgnLicsICcnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGxlbmd0aCBvZiBzdHJpbmcgaWYgbm8gZGVjaW1hbCBjaGFyYWN0ZXJcbiAgICAgICAgaWYgKGUgPCAwKSB7XG4gICAgICAgICAgICAvLyBJbnRlZ2VyXG4gICAgICAgICAgICBlID0gbi5sZW5ndGg7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBEZXRlcm1pbmUgbGVhZGluZyB6ZXJvc1xuICAgICAgICBpID0gKG4uc2VhcmNoKC9bMS05XS9pKSA9PT0gLTEpID8gbi5sZW5ndGggOiBuLnNlYXJjaCgvWzEtOV0vaSk7XG4gICAgICAgIG5MID0gbi5sZW5ndGg7XG4gICAgICAgIGlmIChpID09PSBuTCkge1xuICAgICAgICAgICAgLy8gWmVyb1xuICAgICAgICAgICAgeC5lID0gMDtcbiAgICAgICAgICAgIHguYyA9IFswXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIERldGVybWluZSB0cmFpbGluZyB6ZXJvc1xuICAgICAgICAgICAgZm9yIChqID0gbkwgLSAxOyBuLmNoYXJBdChqKSA9PT0gJzAnOyBqIC09IDEpIHtcbiAgICAgICAgICAgICAgICBuTCAtPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbkwgLT0gMTtcblxuICAgICAgICAgICAgLy8gRGVjaW1hbCBsb2NhdGlvblxuICAgICAgICAgICAgeC5lID0gZSAtIGkgLSAxO1xuICAgICAgICAgICAgeC5jID0gW107XG5cbiAgICAgICAgICAgIC8vIENvbnZlcnQgc3RyaW5nIHRvIGFycmF5IG9mIGRpZ2l0cyB3aXRob3V0IGxlYWRpbmcvdHJhaWxpbmcgemVyb3NcbiAgICAgICAgICAgIGZvciAoZSA9IDA7IGkgPD0gbkw7IGkgKz0gMSkge1xuICAgICAgICAgICAgICAgIHguY1tlXSA9ICtuLmNoYXJBdChpKTtcbiAgICAgICAgICAgICAgICBlICs9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4geDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGdW5jdGlvbiB0byB0ZXN0IGlmIHRoZSBpbnB1dCB2YWx1ZSBmYWxscyB3aXRoIHRoZSBNaW4gLyBNYXggc2V0dGluZ3MuXG4gICAgICogVGhpcyB1c2VzIHRoZSBwYXJzZWQgc3RyaW5ncyBmb3IgdGhlIGFib3ZlIHBhcnNlU3RyIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogVGhpcyBmdW5jdGlvbiBpcyBhZGFwdGVkIGZyb20gQmlnLmpzIGh0dHBzOi8vZ2l0aHViLmNvbS9NaWtlTWNsL2JpZy5qcy8uIE1hbnkgdGhhbmtzIHRvIE1pa2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0geSBCaWcgbnVtYmVyIGluc3RhbmNlXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHggQmlnIG51bWJlciBpbnN0YW5jZVxuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRlc3RNaW5NYXgoeSwgeCkge1xuICAgICAgICBjb25zdCB4YyA9IHguYztcbiAgICAgICAgY29uc3QgeWMgPSB5LmM7XG4gICAgICAgIGxldCBpID0geC5zO1xuICAgICAgICBsZXQgaiA9IHkucztcbiAgICAgICAgbGV0IGsgPSB4LmU7XG4gICAgICAgIGxldCBsID0geS5lO1xuXG4gICAgICAgIC8vIEVpdGhlciB6ZXJvP1xuICAgICAgICBpZiAoIXhjWzBdIHx8ICF5Y1swXSkge1xuICAgICAgICAgICAgbGV0IHJlc3VsdDtcbiAgICAgICAgICAgIGlmICgheGNbMF0pIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSAheWNbMF0/MDotajtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTaWducyBkaWZmZXI/XG4gICAgICAgIGlmIChpICE9PSBqKSB7XG4gICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB4TmVnID0gaSA8IDA7XG5cbiAgICAgICAgLy8gQ29tcGFyZSBleHBvbmVudHNcbiAgICAgICAgaWYgKGsgIT09IGwpIHtcbiAgICAgICAgICAgIHJldHVybiAoayA+IGwgXiB4TmVnKT8xOi0xO1xuICAgICAgICB9XG4gICAgICAgIGkgPSAtMTtcbiAgICAgICAgayA9IHhjLmxlbmd0aDtcbiAgICAgICAgbCA9IHljLmxlbmd0aDtcbiAgICAgICAgaiA9IChrIDwgbCkgPyBrIDogbDtcblxuICAgICAgICAvLyBDb21wYXJlIGRpZ2l0IGJ5IGRpZ2l0XG4gICAgICAgIGZvciAoaSArPSAxOyBpIDwgajsgaSArPSAxKSB7XG4gICAgICAgICAgICBpZiAoeGNbaV0gIT09IHljW2ldKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICh4Y1tpXSA+IHljW2ldIF4geE5lZyk/MTotMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENvbXBhcmUgbGVuZ3Roc1xuICAgICAgICBsZXQgcmVzdWx0O1xuICAgICAgICBpZiAoayA9PT0gbCkge1xuICAgICAgICAgICAgcmVzdWx0ID0gMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IChrID4gbCBeIHhOZWcpPzE6LTE7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrIHRoYXQgdGhlIG51bWJlciBzYXRpc2Z5IHRoZSBmb3JtYXQgY29uZGl0aW9uc1xuICAgICAqIGFuZCBsYXlzIGJldHdlZW4gc2V0dGluZ3MubWluaW11bVZhbHVlIGFuZCBzZXR0aW5ncy5tYXhpbXVtVmFsdWVcbiAgICAgKiBhbmQgdGhlIHN0cmluZyBsZW5ndGggZG9lcyBub3QgZXhjZWVkIHRoZSBkaWdpdHMgaW4gc2V0dGluZ3MubWluaW11bVZhbHVlIGFuZCBzZXR0aW5ncy5tYXhpbXVtVmFsdWVcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHNldHRpbmdzXG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICovXG4gICAgZnVuY3Rpb24gY2hlY2tJZkluUmFuZ2VXaXRoT3ZlcnJpZGVPcHRpb24ocywgc2V0dGluZ3MpIHtcbiAgICAgICAgcyA9IHMudG9TdHJpbmcoKTtcbiAgICAgICAgcyA9IHMucmVwbGFjZSgnLCcsICcuJyk7XG4gICAgICAgIGNvbnN0IG1pblBhcnNlID0gcGFyc2VTdHIoc2V0dGluZ3MubWluaW11bVZhbHVlKTtcbiAgICAgICAgY29uc3QgbWF4UGFyc2UgPSBwYXJzZVN0cihzZXR0aW5ncy5tYXhpbXVtVmFsdWUpO1xuICAgICAgICBjb25zdCB2YWxQYXJzZSA9IHBhcnNlU3RyKHMpO1xuXG4gICAgICAgIGxldCByZXN1bHQ7XG4gICAgICAgIHN3aXRjaCAoc2V0dGluZ3Mub3ZlcnJpZGVNaW5NYXhMaW1pdHMpIHtcbiAgICAgICAgICAgIGNhc2UgJ2Zsb29yJzpcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBbdGVzdE1pbk1heChtaW5QYXJzZSwgdmFsUGFyc2UpID4gLTEsIHRydWVdO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnY2VpbGluZyc6XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gW3RydWUsIHRlc3RNaW5NYXgobWF4UGFyc2UsIHZhbFBhcnNlKSA8IDFdO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnaWdub3JlJzpcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBbdHJ1ZSwgdHJ1ZV07XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IFt0ZXN0TWluTWF4KG1pblBhcnNlLCB2YWxQYXJzZSkgPiAtMSwgdGVzdE1pbk1heChtYXhQYXJzZSwgdmFsUGFyc2UpIDwgMV07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoYW5rcyB0byBBbnRob255ICYgRXZhbiBDXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0VsZW1lbnR8c3RyaW5nfSBlbGVtZW50XG4gICAgICogQHJldHVybnMgeyp8alF1ZXJ5fEhUTUxFbGVtZW50fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldEN1cnJlbnRFbGVtZW50KGVsZW1lbnQpIHtcbiAgICAgICAgLypcbiAgICAgICAgICogSWYgdGhlIHBhcmFtZXRlciBpcyBhIHN0cmluZyAoYW5kIHRoZXJlZm9yZSBpcyBhIENTUyBzZWxlY3RvciksIHRoZW4gd2UgbmVlZCB0byBtb2RpZnkgdGhpcyBzdHJpbmcgaW4gb3JkZXJcbiAgICAgICAgICogZm9yIGpRdWVyeSB0byBiZSBhYmxlIHRvIHBhcnNlIHRoZSBzZWxlY3RvciBjb3JyZWN0bHkuXG4gICAgICAgICAqIGNmLiBodHRwOi8vbGVhcm4uanF1ZXJ5LmNvbS91c2luZy1qcXVlcnktY29yZS9mYXEvaG93LWRvLWktc2VsZWN0LWFuLWVsZW1lbnQtYnktYW4taWQtdGhhdC1oYXMtY2hhcmFjdGVycy11c2VkLWluLWNzcy1ub3RhdGlvbi9cbiAgICAgICAgICovXG4gICAgICAgIGlmIChpc1N0cmluZyhlbGVtZW50KSkge1xuICAgICAgICAgICAgLy9UT0RPIFRoaXMgYmxvY2sgaXMgYXBwYXJlbnRseSBuZXZlciBlbnRlcmVkLiBXZSBzaG91bGQgcmVtb3ZlIGl0IGFmdGVyIG1ha2luZyBzdXJlIHRoYXQncyAxMDAlIHRoZSBjYXNlXG4gICAgICAgICAgICBlbGVtZW50ID0gYCMke2VsZW1lbnQucmVwbGFjZSgvKDp8XFwufFxcW3xdfCx8PSkvZywgJ1xcXFwkMScpfWA7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gJChlbGVtZW50KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGdW5jdGlvbiB0aGF0IGF0dGFjaCB0aGUgYXV0b051bWVyaWMgZmllbGQgcHJvcGVydGllcyB0byB0aGUgRE9NIGVsZW1lbnQgdmlhIGFuIEF1dG9OdW1lcmljSG9sZGVyIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSAkdGhpcyBqUXVlcnktc2VsZWN0ZWQgRE9NIGVsZW1lbnRcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3NcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHVwZGF0ZVxuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldEF1dG9OdW1lcmljSG9sZGVyKCR0aGlzLCBzZXR0aW5ncywgdXBkYXRlID0gZmFsc2UpIHtcbiAgICAgICAgbGV0IGRhdGEgPSAkdGhpcy5kYXRhKCdhdXRvTnVtZXJpYycpO1xuICAgICAgICBpZiAoIWRhdGEpIHtcbiAgICAgICAgICAgIGRhdGEgPSB7fTtcbiAgICAgICAgICAgICR0aGlzLmRhdGEoJ2F1dG9OdW1lcmljJywgZGF0YSk7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgaG9sZGVyID0gZGF0YS5ob2xkZXI7XG4gICAgICAgIGlmICh1cGRhdGUgfHwgKGlzVW5kZWZpbmVkKGhvbGRlcikgJiYgc2V0dGluZ3MpKSB7XG4gICAgICAgICAgICBob2xkZXIgPSBuZXcgQXV0b051bWVyaWNIb2xkZXIoJHRoaXMuZ2V0KDApLCBzZXR0aW5ncyk7XG4gICAgICAgICAgICBkYXRhLmhvbGRlciA9IGhvbGRlcjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBob2xkZXI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogT3JpZ2luYWwgc2V0dGluZ3Mgc2F2ZWQgZm9yIHVzZSB3aGVuIGRlY2ltYWxQbGFjZXNTaG93bk9uRm9jdXMgJiBub1NlcGFyYXRvck9uRm9jdXMgb3B0aW9ucyBhcmUgYmVpbmcgdXNlZC5cbiAgICAgKiBUaG9zZSBvcmlnaW5hbCBzZXR0aW5ncyBhcmUgdXNlZCBleGNsdXNpdmVseSBpbiB0aGUgYGZvY3VzaW5gIGFuZCBgZm9jdXNvdXRgIGV2ZW50IGhhbmRsZXJzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHNldHRpbmdzXG4gICAgICovXG4gICAgZnVuY3Rpb24ga2VlcEFuT3JpZ2luYWxTZXR0aW5nc0NvcHkoc2V0dGluZ3MpIHtcbiAgICAgICAgLy9UT0RPIFJlbmFtZSB0aGUgb2xkIG9wdGlvbiBuYW1lcyB0byB0aGUgbmV3IG9uZXNcbiAgICAgICAgc2V0dGluZ3Mub0RlYyAgICAgPSBzZXR0aW5ncy5kZWNpbWFsUGxhY2VzT3ZlcnJpZGU7XG4gICAgICAgIHNldHRpbmdzLm9QYWQgICAgID0gc2V0dGluZ3MuYWxsb3dEZWNpbWFsUGFkZGluZztcbiAgICAgICAgc2V0dGluZ3Mub0JyYWNrZXQgPSBzZXR0aW5ncy5uZWdhdGl2ZUJyYWNrZXRzVHlwZU9uQmx1cjtcbiAgICAgICAgc2V0dGluZ3Mub1NlcCAgICAgPSBzZXR0aW5ncy5kaWdpdEdyb3VwU2VwYXJhdG9yO1xuICAgICAgICBzZXR0aW5ncy5vU2lnbiAgICA9IHNldHRpbmdzLmN1cnJlbmN5U3ltYm9sO1xuICAgICAgICBzZXR0aW5ncy5vU3VmZml4ICA9IHNldHRpbmdzLnN1ZmZpeFRleHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogT3JpZ2luYWwgc2V0dGluZ3Mgc2F2ZWQgZm9yIHVzZSB3aGVuIGBkZWNpbWFsUGxhY2VzU2hvd25PbkZvY3VzYCAmIGBub1NlcGFyYXRvck9uRm9jdXNgIG9wdGlvbnMgYXJlIGJlaW5nIHVzZWQuXG4gICAgICogVGhpcyBpcyB0YWtlbiBmcm9tIFF1aXJrc21vZGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJlYWRDb29raWUobmFtZSkge1xuICAgICAgICBjb25zdCBuYW1lRVEgPSBuYW1lICsgJz0nO1xuICAgICAgICBjb25zdCBjYSA9IGRvY3VtZW50LmNvb2tpZS5zcGxpdCgnOycpO1xuICAgICAgICBsZXQgYyA9ICcnO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNhLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICBjID0gY2FbaV07XG4gICAgICAgICAgICB3aGlsZSAoYy5jaGFyQXQoMCkgPT09ICcgJykge1xuICAgICAgICAgICAgICAgIGMgPSBjLnN1YnN0cmluZygxLCBjLmxlbmd0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYy5pbmRleE9mKG5hbWVFUSkgPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYy5zdWJzdHJpbmcobmFtZUVRLmxlbmd0aCwgYy5sZW5ndGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGVzdCBpZiBzZXNzaW9uU3RvcmFnZSBpcyBzdXBwb3J0ZWQuXG4gICAgICogVGhpcyBpcyB0YWtlbiBmcm9tIE1vZGVybml6ci5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHN0b3JhZ2VUZXN0KCkge1xuICAgICAgICBjb25zdCBtb2QgPSAnbW9kZXJuaXpyJztcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHNlc3Npb25TdG9yYWdlLnNldEl0ZW0obW9kLCBtb2QpO1xuICAgICAgICAgICAgc2Vzc2lvblN0b3JhZ2UucmVtb3ZlSXRlbShtb2QpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHByb3Blcmx5IGZvcm1hdHMgdGhlIHN0cmluZyB0byBhIG51bWVyaWMgd2hlbiBsZWFkaW5nWmVybyBkb2VzIG5vdCAna2VlcCcuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3NcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNsZWFuTGVhZGluZ1RyYWlsaW5nWmVyb3ModmFsdWUsIHNldHRpbmdzKSB7XG4gICAgICAgIC8vIFJldHVybiB0aGUgZW1wdHkgc3RyaW5nIGlzIHRoZSB2YWx1ZSBpcyBhbHJlYWR5IGVtcHR5LiBUaGlzIHByZXZlbnQgY29udmVydGluZyB0aGF0IHZhbHVlIHRvICcwJy5cbiAgICAgICAgaWYgKHZhbHVlID09PSAnJykge1xuICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gUmV0dXJuICcwJyBpZiB0aGUgdmFsdWUgaXMgemVyb1xuICAgICAgICBpZiAoTnVtYmVyKHZhbHVlKSA9PT0gMCAmJiBzZXR0aW5ncy5sZWFkaW5nWmVybyAhPT0gJ2tlZXAnKSB7XG4gICAgICAgICAgICByZXR1cm4gJzAnO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNldHRpbmdzLmxlYWRpbmdaZXJvICE9PSAna2VlcCcpIHtcbiAgICAgICAgICAgIC8vIFRyaW0gbGVhZGluZyB6ZXJvJ3MgLSBsZWF2ZXMgb25lIHplcm8gdG8gdGhlIGxlZnQgb2YgdGhlIGRlY2ltYWwgcG9pbnRcbiAgICAgICAgICAgIHZhbHVlID0gdmFsdWUucmVwbGFjZSgvXigtKT8wKyg/PVxcZCkvZywnJDEnKTtcblxuICAgICAgICAgICAgLy9UT0RPIHJlbW92ZSB0aGlzIGZyb20gdGhhdCBmdW5jdGlvbiBhbmQgdXNlIGB0cmltUGFkZGVkWmVyb3NGcm9tRGVjaW1hbFBsYWNlcygpYCBpbnN0ZWFkLiBBbHNvIGNyZWF0ZSBhIG5ldyBgdHJhaWxpbmdaZXJvYCBvcHRpb24uXG4gICAgICAgICAgICBpZiAoY29udGFpbnModmFsdWUsICcuJykpIHtcbiAgICAgICAgICAgICAgICAvLyBUcmltcyB0cmFpbGluZyB6ZXJvcyBhZnRlciB0aGUgZGVjaW1hbCBwb2ludFxuICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUucmVwbGFjZSgvKFxcLlswLTldKj8pMCskLywgJyQxJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gU3RyaXBzIHRyYWlsaW5nIGRlY2ltYWwgcG9pbnRcbiAgICAgICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKC9cXC4kLywgJycpO1xuXG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmUgdGhlIHRyYWlsaW5nIHplcm9zIGluIHRoZSBkZWNpbWFsIHBhcnQgb2YgYSBudW1iZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbnVtZXJpY1N0cmluZ1xuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRyaW1QYWRkZWRaZXJvc0Zyb21EZWNpbWFsUGxhY2VzKG51bWVyaWNTdHJpbmcpIHtcbiAgICAgICAgY29uc3QgW2ludGVnZXJQYXJ0LCBkZWNpbWFsUGFydF0gPSBudW1lcmljU3RyaW5nLnNwbGl0KCcuJyk7XG4gICAgICAgIGlmIChpc1VuZGVmaW5lZE9yTnVsbE9yRW1wdHkoZGVjaW1hbFBhcnQpKSB7XG4gICAgICAgICAgICByZXR1cm4gaW50ZWdlclBhcnQ7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB0cmltbWVkRGVjaW1hbFBhcnQgPSBkZWNpbWFsUGFydC5yZXBsYWNlKC8wKyQvZywgJycpO1xuXG4gICAgICAgIGxldCByZXN1bHQ7XG4gICAgICAgIGlmICh0cmltbWVkRGVjaW1hbFBhcnQgPT09ICcnKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBpbnRlZ2VyUGFydDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IGAke2ludGVnZXJQYXJ0fS4ke3RyaW1tZWREZWNpbWFsUGFydH1gO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIG9yIHJlbW92ZXMgc2Vzc2lvblN0b3JhZ2Ugb3IgY29va2llIGRlcGVuZGluZyBvbiB3aGF0IHRoZSBicm93c2VyIGlzIHN1cHBvcnRpbmcuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0VsZW1lbnR8RXZlbnRUYXJnZXR9IGVsZW1lbnRcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3NcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWN0aW9uXG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICovXG4gICAgZnVuY3Rpb24gc2F2ZVZhbHVlVG9QZXJzaXN0ZW50U3RvcmFnZShlbGVtZW50LCBzZXR0aW5ncywgYWN0aW9uKSB7XG4gICAgICAgIGlmIChzZXR0aW5ncy5zYXZlVmFsdWVUb1Nlc3Npb25TdG9yYWdlKSB7XG4gICAgICAgICAgICBjb25zdCBzdG9yZWROYW1lID0gKGVsZW1lbnQubmFtZSAhPT0gJycgJiYgIWlzVW5kZWZpbmVkKGVsZW1lbnQubmFtZSkpID9gQVVUT18ke2RlY29kZVVSSUNvbXBvbmVudChlbGVtZW50Lm5hbWUpfWAgOmBBVVRPXyR7ZWxlbWVudC5pZH1gO1xuICAgICAgICAgICAgbGV0IGRhdGU7XG4gICAgICAgICAgICBsZXQgZXhwaXJlcztcblxuICAgICAgICAgICAgLy8gU2V0cyBjb29raWUgZm9yIGJyb3dzZXIgdGhhdCBkbyBub3Qgc3VwcG9ydCBzZXNzaW9uU3RvcmFnZSBJRSA2ICYgSUUgN1xuICAgICAgICAgICAgaWYgKHN0b3JhZ2VUZXN0KCkgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChhY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnc2V0JzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmNvb2tpZSA9IGAke3N0b3JlZE5hbWV9PSR7c2V0dGluZ3MucmF3VmFsdWV9OyBleHBpcmVzPSA7IHBhdGg9L2A7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnd2lwZSc6XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRlID0gbmV3IERhdGUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGUuc2V0VGltZShkYXRlLmdldFRpbWUoKSArICgtMSAqIDI0ICogNjAgKiA2MCAqIDEwMDApKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4cGlyZXMgPSAnOyBleHBpcmVzPScgKyBkYXRlLnRvVVRDU3RyaW5nKCk7IC8vIE5vdGUgOiBgdG9HTVRTdHJpbmcoKWAgaGFzIGJlZW4gZGVwcmVjYXRlZCAoY2YuIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0RhdGUvdG9HTVRTdHJpbmcpXG4gICAgICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5jb29raWUgPSBgJHtzdG9yZWROYW1lfT0nJyA7JHtleHBpcmVzfTsgcGF0aD0vYDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdnZXQnOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlYWRDb29raWUoc3RvcmVkTmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGFjdGlvbikge1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdzZXQnOlxuICAgICAgICAgICAgICAgICAgICAgICAgc2Vzc2lvblN0b3JhZ2Uuc2V0SXRlbShzdG9yZWROYW1lLCBzZXR0aW5ncy5yYXdWYWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnd2lwZSc6XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXNzaW9uU3RvcmFnZS5yZW1vdmVJdGVtKHN0b3JlZE5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2dldCc6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2Vzc2lvblN0b3JhZ2UuZ2V0SXRlbShzdG9yZWROYW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBIb2xkZXIgb2JqZWN0IGZvciBmaWVsZCBwcm9wZXJ0aWVzXG4gICAgICovXG4gICAgY2xhc3MgQXV0b051bWVyaWNIb2xkZXIge1xuICAgICAgICAvKipcbiAgICAgICAgICogQ2xhc3MgY29uc3RydWN0b3JcbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gdGhhdCAtIEEgcmVmZXJlbmNlIHRvIHRoZSBjdXJyZW50IERPTSBlbGVtZW50XG4gICAgICAgICAqIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5nc1xuICAgICAgICAgKi9cbiAgICAgICAgY29uc3RydWN0b3IodGhhdCwgc2V0dGluZ3MpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0dGluZ3MgPSBzZXR0aW5ncztcbiAgICAgICAgICAgIHRoaXMudGhhdCA9IHRoYXQ7XG4gICAgICAgICAgICB0aGlzLiR0aGF0ID0gJCh0aGF0KTtcbiAgICAgICAgICAgIHRoaXMuZm9ybWF0dGVkID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLnNldHRpbmdzQ2xvbmUgPSBzZXR0aW5ncztcbiAgICAgICAgICAgIHRoaXMudmFsdWUgPSB0aGF0LnZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFVwZGF0ZSB0aGUgdmFsdWUgYW5kIHRoZSBzZWxlY3Rpb24gdmFsdWVzIGluc2lkZSB0aGUgQXV0b051bWVyaWNIb2xkZXIgb2JqZWN0LlxuICAgICAgICAgKiBUaGlzIGtlZXBzIHRyYWNrcyBvZiB0aGUgaW5wdXQgdmFsdWUsIGFzIHdlbGwgYXMgdGhlIGN1cnJlbnQgc2VsZWN0aW9uLlxuICAgICAgICAgKiBUaGlzIGFsc28gcmVzZXRzIHRoZSAncHJvY2Vzc2VkJyBhbmQgJ2Zvcm1hdHRlZCcgc3RhdGUuXG4gICAgICAgICAqXG4gICAgICAgICAqIE5vdGUgOiBUaG9zZSB0d28gY2FuIGNoYW5nZSBiZXR3ZWVuIHRoZSBrZXlkb3duLCBrZXlwcmVzcyBhbmQga2V5dXAgZXZlbnRzLCB0aGF0J3Mgd2h5XG4gICAgICAgICAqICAgICAgICB0aGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCBvbiBlYWNoIGV2ZW50IGhhbmRsZXIuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICBfdXBkYXRlQXV0b051bWVyaWNIb2xkZXJQcm9wZXJ0aWVzKCkge1xuICAgICAgICAgICAgdGhpcy52YWx1ZSA9IHRoaXMudGhhdC52YWx1ZTtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0aW9uID0gZ2V0RWxlbWVudFNlbGVjdGlvbih0aGlzLnRoYXQpO1xuICAgICAgICAgICAgdGhpcy5wcm9jZXNzZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuZm9ybWF0dGVkID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogVXBkYXRlIHRoZSBrZXljb2RlIG9mIHRoZSBrZXkgdGhhdCB0cmlnZ2VyZWQgdGhlIGdpdmVuIGV2ZW50LlxuICAgICAgICAgKiBOb3RlIDogZS53aGljaCBpcyBzb21ldGltZXMgZGlmZmVyZW50IHRoYW4gZS5rZXlDb2RlIGR1cmluZyB0aGUga2V5cHJlc3MgZXZlbnQsIHdoZW4gZW50ZXJpbmcgYSBwcmludGFibGUgY2hhcmFjdGVyIGtleSAoaWUuICd0JykuIGBlLndoaWNoYCBlcXVhbHMgMCBmb3Igbm9uLXByaW50YWJsZSBjaGFyYWN0ZXJzLlxuICAgICAgICAgKlxuICAgICAgICAgKiAvL1RPRE8gU3dpdGNoIHRvIHRoZSBub24tZGVwcmVjYXRlZCBlLmtleSBhdHRyaWJ1dGUsIGluc3RlYWQgb2YgaW5jb25zaXN0YW50IGUud2hpY2ggYW5kIGUua2V5Q29kZS5cbiAgICAgICAgICogZS5rZXkgZGVzY3JpYmUgdGhlIGtleSBuYW1lIHVzZWQgdG8gdHJpZ2dlciB0aGUgZXZlbnQuXG4gICAgICAgICAqIGUua2V5Q29kZSBiZWluZyBkZXByZWNhdGVkIDogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0tleWJvYXJkRXZlbnQva2V5Q29kZVxuICAgICAgICAgKiBIb3cgZS5rZXkgd29ya3MgOiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvS2V5Ym9hcmRFdmVudC9rZXlcbiAgICAgICAgICogVGhlIGtleSBsaXN0IGlzIGRlc2NyaWJlZCBoZXJlXG4gICAgICAgICAqIEBsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9LZXlib2FyZEV2ZW50L2tleS9LZXlfVmFsdWVzXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7RXZlbnR9IGVcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIF91cGRhdGVBdXRvTnVtZXJpY0hvbGRlckV2ZW50S2V5Y29kZShlKSB7XG4gICAgICAgICAgICAvLyBOb3RlOiB0aGUga2V5cHJlc3MgZXZlbnQgb3ZlcndyaXRlcyBtZWFuaW5nZnVsIHZhbHVlIG9mIGUua2V5Q29kZSwgaGVuY2Ugd2UgZG8gbm90IHVwZGF0ZSB0aGF0IHZhbHVlIG9uICdrZXlwcmVzcydcbiAgICAgICAgICAgIHRoaXMuZXZlbnRLZXlDb2RlID0ga2V5Q29kZU51bWJlcihlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXQgdGhlIHRleHQgc2VsZWN0aW9uIGluc2lkZSB0aGUgaW5wdXQgd2l0aCB0aGUgZ2l2ZW4gc3RhcnQgYW5kIGVuZCBwb3NpdGlvbi5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtpbnR9IHN0YXJ0XG4gICAgICAgICAqIEBwYXJhbSB7aW50fSBlbmRcbiAgICAgICAgICogQHBhcmFtIHt1bmRlZmluZWR8Ym9vbGVhbn0gc2V0UmVhbFxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgX3NldFNlbGVjdGlvbihzdGFydCwgZW5kLCBzZXRSZWFsKSB7XG4gICAgICAgICAgICAvL1RPRE8gTW9kaWZ5IHNldFJlYWwgdG8gYmUgbW9yZSBleHBsaWNpdCAoYW5kIGEgYm9vbGVhbilcbiAgICAgICAgICAgIHN0YXJ0ID0gTWF0aC5tYXgoc3RhcnQsIDApO1xuICAgICAgICAgICAgZW5kID0gTWF0aC5taW4oZW5kLCB0aGlzLnRoYXQudmFsdWUubGVuZ3RoKTsgLy9UT0RPIFJlcGxhY2UgYHRoaXMudGhhdC52YWx1ZS5sZW5ndGhgIHdpdGggYHRoaXMudmFsdWUubGVuZ3RoYFxuICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb24gPSB7XG4gICAgICAgICAgICAgICAgc3RhcnQsXG4gICAgICAgICAgICAgICAgZW5kLFxuICAgICAgICAgICAgICAgIGxlbmd0aDogZW5kIC0gc3RhcnQsXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBpZiAoaXNVbmRlZmluZWQoc2V0UmVhbCkgfHwgc2V0UmVhbCkge1xuICAgICAgICAgICAgICAgIHNldEVsZW1lbnRTZWxlY3Rpb24odGhpcy50aGF0LCBzdGFydCwgZW5kKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXQgdGhlIGNhcmV0IHBvc2l0aW9uIGluc2lkZSB0aGUgaW5wdXQgYXQgdGhlIGdpdmVuIHBvc2l0aW9uLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge2ludH0gcG9zXG4gICAgICAgICAqIEBwYXJhbSB7dW5kZWZpbmVkfGJvb2xlYW59IHNldFJlYWxcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIF9zZXRDYXJldFBvc2l0aW9uKHBvcywgc2V0UmVhbCkge1xuICAgICAgICAgICAgLy9UT0RPIE1vZGlmeSBzZXRSZWFsIHRvIGJlIG1vcmUgZXhwbGljaXQgKGFuZCBhIGJvb2xlYW4pXG4gICAgICAgICAgICB0aGlzLl9zZXRTZWxlY3Rpb24ocG9zLCBwb3MsIHNldFJlYWwpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybiBhbiBhcnJheSBjb250YWluaW5nIHRoZSBzdHJpbmcgcGFydHMgbG9jYXRlZCBvbiB0aGUgbGVmdCBhbmQgcmlnaHQgc2lkZSBvZiB0aGUgY2FyZXQgb3Igc2VsZWN0aW9uLlxuICAgICAgICAgKiBUaG9zZSBwYXJ0cyBhcmUgbGVmdCAndW50b3VjaGVkJywgaWUuIGZvcm1hdHRlZCBieSBhdXRvTnVtZXJpYy5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybnMge1tzdHJpbmcsIHN0cmluZ119IFRoZSBwYXJ0cyBvbiB0aGUgbGVmdCBhbmQgcmlnaHQgb2YgdGhlIGNhcmV0IG9yIHNlbGVjdGlvblxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgX2dldExlZnRBbmRSaWdodFBhcnRBcm91bmRUaGVTZWxlY3Rpb24oKSB7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXMudmFsdWU7XG4gICAgICAgICAgICBjb25zdCBsZWZ0ID0gdmFsdWUuc3Vic3RyaW5nKDAsIHRoaXMuc2VsZWN0aW9uLnN0YXJ0KTtcbiAgICAgICAgICAgIGNvbnN0IHJpZ2h0ID0gdmFsdWUuc3Vic3RyaW5nKHRoaXMuc2VsZWN0aW9uLmVuZCwgdmFsdWUubGVuZ3RoKTtcblxuICAgICAgICAgICAgcmV0dXJuIFtsZWZ0LCByaWdodF07XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJuIGFuIGFycmF5IGNvbnRhaW5pbmcgdGhlIHN0cmluZyBwYXJ0cyBsb2NhdGVkIG9uIHRoZSBsZWZ0IGFuZCByaWdodCBzaWRlIG9mIHRoZSBjYXJldCBvciBzZWxlY3Rpb24uXG4gICAgICAgICAqIFRob3NlIHBhcnRzIGFyZSB1bmZvcm1hdHRlZCAoc3RyaXBwZWQpIG9mIGFueSBub24tbnVtYmVycyBjaGFyYWN0ZXJzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJucyB7W3N0cmluZywgc3RyaW5nXX0gVGhlIHBhcnRzIG9uIHRoZSBsZWZ0IGFuZCByaWdodCBvZiB0aGUgY2FyZXQgb3Igc2VsZWN0aW9uLCB1bmZvcm1hdHRlZC5cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIF9nZXRVbmZvcm1hdHRlZExlZnRBbmRSaWdodFBhcnRBcm91bmRUaGVTZWxlY3Rpb24oKSB7XG4gICAgICAgICAgICBjb25zdCBzZXR0aW5nc0Nsb25lID0gdGhpcy5zZXR0aW5nc0Nsb25lO1xuICAgICAgICAgICAgbGV0IFtsZWZ0LCByaWdodF0gPSB0aGlzLl9nZXRMZWZ0QW5kUmlnaHRQYXJ0QXJvdW5kVGhlU2VsZWN0aW9uKCk7XG4gICAgICAgICAgICBpZiAobGVmdCA9PT0gJycgJiYgcmlnaHQgPT09ICcnKSB7XG4gICAgICAgICAgICAgICAgc2V0dGluZ3NDbG9uZS50cmFpbGluZ05lZ2F0aXZlID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBpZiBjaGFuZ2luZyB0aGUgc2lnbiBhbmQgbGVmdCBpcyBlcXVhbCB0byB0aGUgbnVtYmVyIHplcm8gLSBwcmV2ZW50cyBzdHJpcHBpbmcgdGhlIGxlYWRpbmcgemVyb3NcbiAgICAgICAgICAgIGxldCBzdHJpcFplcm9zID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmICh0aGlzLmV2ZW50S2V5Q29kZSA9PT0ga2V5Q29kZS5IeXBoZW4gJiYgTnVtYmVyKGxlZnQpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgc3RyaXBaZXJvcyA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGVmdCA9IHN0cmlwQWxsTm9uTnVtYmVyQ2hhcmFjdGVycyhsZWZ0LCB0aGlzLnNldHRpbmdzQ2xvbmUsIHN0cmlwWmVyb3MpO1xuICAgICAgICAgICAgcmlnaHQgPSBzdHJpcEFsbE5vbk51bWJlckNoYXJhY3RlcnMocmlnaHQsIHRoaXMuc2V0dGluZ3NDbG9uZSwgZmFsc2UpO1xuXG4gICAgICAgICAgICBpZiAoc2V0dGluZ3NDbG9uZS50cmFpbGluZ05lZ2F0aXZlICYmICFpc05lZ2F0aXZlKGxlZnQpKSB7XG4gICAgICAgICAgICAgICAgbGVmdCA9ICctJyArIGxlZnQ7XG4gICAgICAgICAgICAgICAgcmlnaHQgPSAocmlnaHQgPT09ICctJykgPyAnJyA6IHJpZ2h0O1xuICAgICAgICAgICAgICAgIHNldHRpbmdzQ2xvbmUudHJhaWxpbmdOZWdhdGl2ZSA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gW2xlZnQsIHJpZ2h0XTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTdHJpcCBwYXJ0cyBmcm9tIGV4Y2VzcyBjaGFyYWN0ZXJzIGFuZCBsZWFkaW5nIHplcm9zLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gbGVmdFxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gcmlnaHRcbiAgICAgICAgICogQHJldHVybnMge1sqLCpdfVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgX25vcm1hbGl6ZVBhcnRzKGxlZnQsIHJpZ2h0KSB7XG4gICAgICAgICAgICBjb25zdCBzZXR0aW5nc0Nsb25lID0gdGhpcy5zZXR0aW5nc0Nsb25lO1xuXG4gICAgICAgICAgICAvLyBpZiBjaGFuZ2luZyB0aGUgc2lnbiBhbmQgbGVmdCBpcyBlcXVhbCB0byB0aGUgbnVtYmVyIHplcm8gLSBwcmV2ZW50cyBzdHJpcHBpbmcgdGhlIGxlYWRpbmcgemVyb3NcbiAgICAgICAgICAgIGxldCBzdHJpcFplcm9zID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmICh0aGlzLmV2ZW50S2V5Q29kZSA9PT0ga2V5Q29kZS5IeXBoZW4gJiYgTnVtYmVyKGxlZnQpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgc3RyaXBaZXJvcyA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGVmdCA9IHN0cmlwQWxsTm9uTnVtYmVyQ2hhcmFjdGVycyhsZWZ0LCBzZXR0aW5nc0Nsb25lLCBzdHJpcFplcm9zKTtcblxuICAgICAgICAgICAgLy8gSWYgcmlnaHQgaXMgbm90IGVtcHR5IGFuZCBmaXJzdCBjaGFyYWN0ZXIgaXMgbm90IGRlY2ltYWxDaGFyYWN0ZXJcbiAgICAgICAgICAgIHJpZ2h0ID0gc3RyaXBBbGxOb25OdW1iZXJDaGFyYWN0ZXJzKHJpZ2h0LCBzZXR0aW5nc0Nsb25lLCBmYWxzZSk7XG5cbiAgICAgICAgICAgIC8vIFByZXZlbnRzIG11bHRpcGxlIGxlYWRpbmcgemVyb3MgZnJvbSBiZWluZyBlbnRlcmVkXG4gICAgICAgICAgICBpZiAoc2V0dGluZ3NDbG9uZS5sZWFkaW5nWmVybyA9PT0gJ2RlbnknICYmXG4gICAgICAgICAgICAgICAgKHRoaXMuZXZlbnRLZXlDb2RlID09PSBrZXlDb2RlLm51bTAgfHwgdGhpcy5ldmVudEtleUNvZGUgPT09IGtleUNvZGUubnVtcGFkMCkgJiZcbiAgICAgICAgICAgICAgICBOdW1iZXIobGVmdCkgPT09IDAgJiZcbiAgICAgICAgICAgICAgICAhY29udGFpbnMobGVmdCwgc2V0dGluZ3NDbG9uZS5kZWNpbWFsQ2hhcmFjdGVyKSAgJiYgcmlnaHQgIT09ICcnKSB7XG4gICAgICAgICAgICAgICAgbGVmdCA9IGxlZnQuc3Vic3RyaW5nKDAsIGxlZnQubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChzZXR0aW5nc0Nsb25lLnRyYWlsaW5nTmVnYXRpdmUgJiYgIWlzTmVnYXRpdmUobGVmdCkpIHtcbiAgICAgICAgICAgICAgICBsZWZ0ID0gJy0nICsgbGVmdDtcbiAgICAgICAgICAgICAgICBzZXR0aW5nc0Nsb25lLnRyYWlsaW5nTmVnYXRpdmUgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gSW5zZXJ0IHplcm8gaWYgaGFzIGxlYWRpbmcgZG90XG4gICAgICAgICAgICB0aGlzLm5ld1ZhbHVlID0gbGVmdCArIHJpZ2h0O1xuICAgICAgICAgICAgaWYgKHNldHRpbmdzQ2xvbmUuZGVjaW1hbENoYXJhY3Rlcikge1xuICAgICAgICAgICAgICAgIGNvbnN0IG0gPSB0aGlzLm5ld1ZhbHVlLm1hdGNoKG5ldyBSZWdFeHAoYF4ke3NldHRpbmdzQ2xvbmUuYU5lZ1JlZ0F1dG9TdHJpcH1cXFxcJHtzZXR0aW5nc0Nsb25lLmRlY2ltYWxDaGFyYWN0ZXJ9YCkpO1xuICAgICAgICAgICAgICAgIGlmIChtKSB7XG4gICAgICAgICAgICAgICAgICAgIGxlZnQgPSBsZWZ0LnJlcGxhY2UobVsxXSwgbVsxXSArICcwJyk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubmV3VmFsdWUgPSBsZWZ0ICsgcmlnaHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gW2xlZnQsIHJpZ2h0XTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXQgcGFydCBvZiBudW1iZXIgdG8gdmFsdWUgd2hpbGUga2VlcGluZyB0aGUgY3Vyc29yIHBvc2l0aW9uLiAvL1RPRE8gV2hhdCBhYm91dCB0aGUgY3Vyc29yIHNlbGVjdGlvbj9cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGxlZnRcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHJpZ2h0XG4gICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNQYXN0ZVxuICAgICAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIF9zZXRWYWx1ZVBhcnRzKGxlZnQsIHJpZ2h0LCBpc1Bhc3RlID0gZmFsc2UpIHtcbiAgICAgICAgICAgIGNvbnN0IHNldHRpbmdzQ2xvbmUgPSB0aGlzLnNldHRpbmdzQ2xvbmU7XG4gICAgICAgICAgICBjb25zdCBwYXJ0cyA9IHRoaXMuX25vcm1hbGl6ZVBhcnRzKGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgICAgIGNvbnN0IFttaW5UZXN0LCBtYXhUZXN0XSA9IGNoZWNrSWZJblJhbmdlV2l0aE92ZXJyaWRlT3B0aW9uKHRoaXMubmV3VmFsdWUsIHNldHRpbmdzQ2xvbmUpO1xuICAgICAgICAgICAgbGV0IHBvc2l0aW9uID0gcGFydHNbMF0ubGVuZ3RoO1xuICAgICAgICAgICAgdGhpcy5uZXdWYWx1ZSA9IHBhcnRzLmpvaW4oJycpO1xuXG4gICAgICAgICAgICBpZiAobWluVGVzdCAmJiBtYXhUZXN0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5uZXdWYWx1ZSA9IHRydW5jYXRlRGVjaW1hbCh0aGlzLm5ld1ZhbHVlLCBzZXR0aW5nc0Nsb25lLCBpc1Bhc3RlKTtcbiAgICAgICAgICAgICAgICAvL1RPRE8gQ2hlY2sgaWYgd2UgbmVlZCB0byByZXBsYWNlIHRoZSBoYXJkLWNvZGVkICcsJyB3aXRoIHNldHRpbmdzLmRlY2ltYWxDaGFyYWN0ZXJcbiAgICAgICAgICAgICAgICBjb25zdCB0ZXN0VmFsdWUgPSAoY29udGFpbnModGhpcy5uZXdWYWx1ZSwgJywnKSkgPyB0aGlzLm5ld1ZhbHVlLnJlcGxhY2UoJywnLCAnLicpIDogdGhpcy5uZXdWYWx1ZTtcbiAgICAgICAgICAgICAgICBpZiAodGVzdFZhbHVlID09PSAnJyB8fCB0ZXN0VmFsdWUgPT09IHNldHRpbmdzQ2xvbmUubmVnYXRpdmVTaWduQ2hhcmFjdGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHNldHRpbmdzQ2xvbmUucmF3VmFsdWUgPSAoc2V0dGluZ3NDbG9uZS5lbXB0eUlucHV0QmVoYXZpb3IgPT09ICd6ZXJvJykgPyAnMCcgOiAnJztcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzZXR0aW5nc0Nsb25lLnJhd1ZhbHVlID0gY2xlYW5MZWFkaW5nVHJhaWxpbmdaZXJvcyh0ZXN0VmFsdWUsIHNldHRpbmdzQ2xvbmUpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChwb3NpdGlvbiA+IHRoaXMubmV3VmFsdWUubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uID0gdGhpcy5uZXdWYWx1ZS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gTWFrZSBzdXJlIHdoZW4gdGhlIHVzZXIgZW50ZXIgYSAnMCcgb24gdGhlIGZhciBsZWZ0IHdpdGggYSBsZWFkaW5nIHplcm8gb3B0aW9uIHNldCB0byAnZGVueScsIHRoYXQgdGhlIGNhcmV0IGRvZXMgbm90IG1vdmVzIHNpbmNlIHRoZSBpbnB1dCBpcyBkcm9wcGVkIChmaXggaXNzdWUgIzI4MylcbiAgICAgICAgICAgICAgICBpZiAocG9zaXRpb24gPT09IDEgJiYgcGFydHNbMF0gPT09ICcwJyAmJiBzZXR0aW5nc0Nsb25lLmxlYWRpbmdaZXJvID09PSAnZGVueScpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlIHVzZXIgZW50ZXIgYDBgLCB0aGVuIHRoZSBjYXJldCBpcyBwdXQgb24gdGhlIHJpZ2h0IHNpZGUgb2YgaXQgKEZpeCBpc3N1ZSAjMjk5KVxuICAgICAgICAgICAgICAgICAgICBpZiAocGFydHNbMV0gPT09ICcnIHx8IHBhcnRzWzBdID09PSAnMCcgJiYgcGFydHNbMV0gIT09ICcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbiA9IDE7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbiA9IDA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aGlzLnZhbHVlID0gdGhpcy5uZXdWYWx1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLl9zZXRDYXJldFBvc2l0aW9uKHBvc2l0aW9uLCBmYWxzZSk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCFtaW5UZXN0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy4kdGhhdC50cmlnZ2VyKCdhdXRvTnVtZXJpYzptaW5FeGNlZWRlZCcpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICghbWF4VGVzdCkge1xuICAgICAgICAgICAgICAgIHRoaXMuJHRoYXQudHJpZ2dlcignYXV0b051bWVyaWM6bWF4RXhjZWVkZWQnKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEhlbHBlciBmdW5jdGlvbiBmb3IgYF9leHBhbmRTZWxlY3Rpb25PblNpZ24oKWAuXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm5zIHsqfSBTaWduIHBvc2l0aW9uIG9mIGEgZm9ybWF0dGVkIHZhbHVlXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICBfZ2V0U2lnblBvc2l0aW9uKCkge1xuICAgICAgICAgICAgY29uc3Qgc2V0dGluZ3NDbG9uZSA9IHRoaXMuc2V0dGluZ3NDbG9uZTtcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbmN5U3ltYm9sID0gc2V0dGluZ3NDbG9uZS5jdXJyZW5jeVN5bWJvbDtcbiAgICAgICAgICAgIGNvbnN0IHRoYXQgPSB0aGlzLnRoYXQ7XG5cbiAgICAgICAgICAgIGlmIChjdXJyZW5jeVN5bWJvbCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGN1cnJlbmN5U3ltYm9sTGVuID0gY3VycmVuY3lTeW1ib2wubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGlmIChzZXR0aW5nc0Nsb25lLmN1cnJlbmN5U3ltYm9sUGxhY2VtZW50ID09PSAncCcpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaGFzTmVnID0gc2V0dGluZ3NDbG9uZS5uZWdhdGl2ZVNpZ25DaGFyYWN0ZXIgJiYgdGhhdC52YWx1ZSAmJiB0aGF0LnZhbHVlLmNoYXJBdCgwKSA9PT0gc2V0dGluZ3NDbG9uZS5uZWdhdGl2ZVNpZ25DaGFyYWN0ZXI7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBoYXNOZWcgPyBbMSwgY3VycmVuY3lTeW1ib2xMZW4gKyAxXSA6IFswLCBjdXJyZW5jeVN5bWJvbExlbl07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlTGVuID0gdGhhdC52YWx1ZS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFt2YWx1ZUxlbiAtIGN1cnJlbmN5U3ltYm9sTGVuLCB2YWx1ZUxlbl07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBbMTAwMCwgLTFdO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEV4cGFuZHMgc2VsZWN0aW9uIHRvIGNvdmVyIHdob2xlIHNpZ25cbiAgICAgICAgICogUHJldmVudHMgcGFydGlhbCBkZWxldGlvbi9jb3B5aW5nL292ZXJ3cml0aW5nIG9mIGEgc2lnblxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge3VuZGVmaW5lZHxib29sZWFufSBzZXRSZWFsXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICBfZXhwYW5kU2VsZWN0aW9uT25TaWduKHNldFJlYWwpIHtcbiAgICAgICAgICAgIC8vVE9ETyBNb2RpZnkgc2V0UmVhbCB0byBiZSBtb3JlIGV4cGxpY2l0IChhbmQgYSBib29sZWFuIG9ubHkpXG4gICAgICAgICAgICAvL1RPRE8gVXNlIGFycmF5IGRlc3RydWN0dXJpbmcgaGVyZSB0byBzZXQgc2lnblBvc2l0aW9uIHRvIG1vcmUgZXhwbGljaXQgdmFyaWFibGVzXG4gICAgICAgICAgICBjb25zdCBzaWduUG9zaXRpb24gPSB0aGlzLl9nZXRTaWduUG9zaXRpb24oKTtcbiAgICAgICAgICAgIGNvbnN0IHNlbGVjdGlvbiA9IHRoaXMuc2VsZWN0aW9uO1xuXG4gICAgICAgICAgICAvLyBJZiBzZWxlY3Rpb24gY2F0Y2hlcyBzb21ldGhpbmcgZXhjZXB0IHNpZ24gYW5kIGNhdGNoZXMgb25seSBzcGFjZSBmcm9tIHNpZ25cbiAgICAgICAgICAgIGlmIChzZWxlY3Rpb24uc3RhcnQgPCBzaWduUG9zaXRpb25bMV0gJiYgc2VsZWN0aW9uLmVuZCA+IHNpZ25Qb3NpdGlvblswXSkge1xuICAgICAgICAgICAgICAgIC8vIFRoZW4gc2VsZWN0IHdpdGhvdXQgZW1wdHkgc3BhY2VcbiAgICAgICAgICAgICAgICBpZiAoKHNlbGVjdGlvbi5zdGFydCA8IHNpZ25Qb3NpdGlvblswXSB8fCBzZWxlY3Rpb24uZW5kID4gc2lnblBvc2l0aW9uWzFdKSAmJiB0aGlzLnZhbHVlLnN1YnN0cmluZyhNYXRoLm1heChzZWxlY3Rpb24uc3RhcnQsIHNpZ25Qb3NpdGlvblswXSksIE1hdGgubWluKHNlbGVjdGlvbi5lbmQsIHNpZ25Qb3NpdGlvblsxXSkpLm1hdGNoKC9eXFxzKiQvKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZWN0aW9uLnN0YXJ0IDwgc2lnblBvc2l0aW9uWzBdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9zZXRTZWxlY3Rpb24oc2VsZWN0aW9uLnN0YXJ0LCBzaWduUG9zaXRpb25bMF0sIHNldFJlYWwpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2V0U2VsZWN0aW9uKHNpZ25Qb3NpdGlvblsxXSwgc2VsZWN0aW9uLmVuZCwgc2V0UmVhbCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBFbHNlIHNlbGVjdCB3aXRoIHdob2xlIHNpZ25cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2V0U2VsZWN0aW9uKE1hdGgubWluKHNlbGVjdGlvbi5zdGFydCwgc2lnblBvc2l0aW9uWzBdKSwgTWF0aC5tYXgoc2VsZWN0aW9uLmVuZCwgc2lnblBvc2l0aW9uWzFdKSwgc2V0UmVhbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRyeSB0byBzdHJpcCBwYXN0ZWQgdmFsdWUgdG8gZGlnaXRzXG4gICAgICAgICAqL1xuICAgICAgICBfY2hlY2tQYXN0ZSgpIHtcbiAgICAgICAgICAgIGlmICghaXNVbmRlZmluZWQodGhpcy52YWx1ZVBhcnRzQmVmb3JlUGFzdGUpKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgb2xkUGFydHMgPSB0aGlzLnZhbHVlUGFydHNCZWZvcmVQYXN0ZTtcbiAgICAgICAgICAgICAgICBjb25zdCBbbGVmdCwgcmlnaHRdID0gdGhpcy5fZ2V0TGVmdEFuZFJpZ2h0UGFydEFyb3VuZFRoZVNlbGVjdGlvbigpO1xuXG4gICAgICAgICAgICAgICAgLy8gVHJ5IHRvIHN0cmlwIHRoZSBwYXN0ZWQgdmFsdWUgZmlyc3RcbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy52YWx1ZVBhcnRzQmVmb3JlUGFzdGU7XG5cbiAgICAgICAgICAgICAgICBjb25zdCBtb2RpZmllZExlZnRQYXJ0ID0gbGVmdC5zdWJzdHIoMCwgb2xkUGFydHNbMF0ubGVuZ3RoKSArIHN0cmlwQWxsTm9uTnVtYmVyQ2hhcmFjdGVycyhsZWZ0LnN1YnN0cihvbGRQYXJ0c1swXS5sZW5ndGgpLCB0aGlzLnNldHRpbmdzQ2xvbmUsIHRydWUpO1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5fc2V0VmFsdWVQYXJ0cyhtb2RpZmllZExlZnRQYXJ0LCByaWdodCwgdHJ1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy52YWx1ZSA9IG9sZFBhcnRzLmpvaW4oJycpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zZXRDYXJldFBvc2l0aW9uKG9sZFBhcnRzWzBdLmxlbmd0aCwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQcm9jZXNzIHBhc3RpbmcsIGN1cnNvciBtb3ZpbmcgYW5kIHNraXBwaW5nIG9mIG5vdCBpbnRlcmVzdGluZyBrZXlzLlxuICAgICAgICAgKiBJZiB0aGlzIGZ1bmN0aW9uIHJldHVybnMgVFJVRSwgdGhlbiBmdXJ0aGVyIHByb2Nlc3NpbmcgaXMgbm90IHBlcmZvcm1lZC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtFdmVudH0gZVxuICAgICAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIF9za2lwQWx3YXlzKGUpIHtcbiAgICAgICAgICAgIC8vIENhdGNoIHRoZSBjdHJsIHVwIG9uIGN0cmwtdlxuICAgICAgICAgICAgaWYgKCgoZS5jdHJsS2V5IHx8IGUubWV0YUtleSkgJiYgZS50eXBlID09PSAna2V5dXAnICYmICFpc1VuZGVmaW5lZCh0aGlzLnZhbHVlUGFydHNCZWZvcmVQYXN0ZSkpIHx8IChlLnNoaWZ0S2V5ICYmIHRoaXMuZXZlbnRLZXlDb2RlID09PSBrZXlDb2RlLkluc2VydCkpIHtcbiAgICAgICAgICAgICAgICAvL1RPRE8gTW92ZSB0aGlzIHRlc3QgaW5zaWRlIHRoZSBgb25LZXl1cGAgaGFuZGxlclxuICAgICAgICAgICAgICAgIHRoaXMuX2NoZWNrUGFzdGUoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFNraXAgYWxsIGZ1bmN0aW9uIGtleXMgKEYxLUYxMiksIFdpbmRvd3Mga2V5cywgdGFiIGFuZCBvdGhlciBzcGVjaWFsIGtleXNcbiAgICAgICAgICAgIGlmICgodGhpcy5ldmVudEtleUNvZGUgPj0ga2V5Q29kZS5GMSAmJiB0aGlzLmV2ZW50S2V5Q29kZSA8PSBrZXlDb2RlLkYxMikgfHxcbiAgICAgICAgICAgICAgICAodGhpcy5ldmVudEtleUNvZGUgPj0ga2V5Q29kZS5XaW5kb3dzICYmIHRoaXMuZXZlbnRLZXlDb2RlIDw9IGtleUNvZGUuUmlnaHRDbGljaykgfHxcbiAgICAgICAgICAgICAgICAodGhpcy5ldmVudEtleUNvZGUgPj0ga2V5Q29kZS5UYWIgJiYgdGhpcy5ldmVudEtleUNvZGUgPCBrZXlDb2RlLlNwYWNlKSB8fFxuICAgICAgICAgICAgICAgIC8vIGBlLndoaWNoYCBpcyBzb21ldGltZXMgZGlmZmVyZW50IHRoYW4gYHRoaXMuZXZlbnRLZXlDb2RlYCBkdXJpbmcgdGhlIGtleXByZXNzIGV2ZW50IHdoZW4gZW50ZXJpbmcgYSBwcmludGFibGUgY2hhcmFjdGVyIGtleSAoaWUuICd0JykuIEFsc28sIGBlLndoaWNoYCBlcXVhbHMgMCBmb3Igbm9uLXByaW50YWJsZSBjaGFyYWN0ZXJzLlxuICAgICAgICAgICAgICAgICh0aGlzLmV2ZW50S2V5Q29kZSA8IGtleUNvZGUuQmFja3NwYWNlICYmXG4gICAgICAgICAgICAgICAgKGUud2hpY2ggPT09IDAgfHwgZS53aGljaCA9PT0gdGhpcy5ldmVudEtleUNvZGUpKSB8fFxuICAgICAgICAgICAgICAgIHRoaXMuZXZlbnRLZXlDb2RlID09PSBrZXlDb2RlLk51bUxvY2sgfHxcbiAgICAgICAgICAgICAgICB0aGlzLmV2ZW50S2V5Q29kZSA9PT0ga2V5Q29kZS5TY3JvbGxMb2NrIHx8XG4gICAgICAgICAgICAgICAgdGhpcy5ldmVudEtleUNvZGUgPT09IGtleUNvZGUuSW5zZXJ0IHx8XG4gICAgICAgICAgICAgICAgdGhpcy5ldmVudEtleUNvZGUgPT09IGtleUNvZGUuQ29tbWFuZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBJZiBhIFwiU2VsZWN0IGFsbFwiIGtleWJvYXJkIHNob3J0Y3V0IGlzIGRldGVjdGVkIChjdHJsICsgYSlcbiAgICAgICAgICAgIGlmICgoZS5jdHJsS2V5IHx8IGUubWV0YUtleSkgJiYgdGhpcy5ldmVudEtleUNvZGUgPT09IGtleUNvZGUuYSkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnNldHRpbmdzLnNlbGVjdE51bWJlck9ubHkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gYHByZXZlbnREZWZhdWx0KClgIGlzIHVzZWQgaGVyZSB0byBwcmV2ZW50IHRoZSBicm93c2VyIHRvIGZpcnN0IHNlbGVjdCBhbGwgdGhlIGlucHV0IHRleHQgKGluY2x1ZGluZyB0aGUgY3VycmVuY3kgc2lnbiksIG90aGVyd2lzZSB3ZSB3b3VsZCBzZWUgdGhhdCB3aG9sZSBzZWxlY3Rpb24gZmlyc3QgaW4gYSBmbGFzaCwgdGhlbiB0aGUgc2VsZWN0aW9uIHdpdGggb25seSB0aGUgbnVtYmVyIHBhcnQgd2l0aG91dCB0aGUgY3VycmVuY3kgc2lnbi5cbiAgICAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZUxlbiA9IHRoaXMudGhhdC52YWx1ZS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGN1cnJlbmN5U3ltYm9sTGVuID0gdGhpcy5zZXR0aW5ncy5jdXJyZW5jeVN5bWJvbC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5lZ0xlbiA9ICghaXNOZWdhdGl2ZSh0aGlzLnRoYXQudmFsdWUpKT8wOjE7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHN1ZmZpeFRleHRMZW4gPSB0aGlzLnNldHRpbmdzLnN1ZmZpeFRleHQubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjdXJyZW5jeVN5bWJvbFBsYWNlbWVudCA9IHRoaXMuc2V0dGluZ3MuY3VycmVuY3lTeW1ib2xQbGFjZW1lbnQ7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50ID0gdGhpcy5zZXR0aW5ncy5uZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudDtcblxuICAgICAgICAgICAgICAgICAgICBsZXQgc3RhcnQ7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjdXJyZW5jeVN5bWJvbFBsYWNlbWVudCA9PT0gJ3MnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFydCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFydCA9IChuZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudCA9PT0gJ2wnICYmIG5lZ0xlbiA9PT0gMSAmJiBjdXJyZW5jeVN5bWJvbExlbiA+IDApP2N1cnJlbmN5U3ltYm9sTGVuICsgMTpjdXJyZW5jeVN5bWJvbExlbjtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGxldCBlbmQ7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjdXJyZW5jeVN5bWJvbFBsYWNlbWVudCA9PT0gJ3AnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbmQgPSB2YWx1ZUxlbiAtIHN1ZmZpeFRleHRMZW47XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKG5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnbCc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZCA9IHZhbHVlTGVuIC0gKHN1ZmZpeFRleHRMZW4gKyBjdXJyZW5jeVN5bWJvbExlbik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3InOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmQgPSAoY3VycmVuY3lTeW1ib2xMZW4gPiAwKT92YWx1ZUxlbiAtIChjdXJyZW5jeVN5bWJvbExlbiArIG5lZ0xlbiArIHN1ZmZpeFRleHRMZW4pOnZhbHVlTGVuIC0gKGN1cnJlbmN5U3ltYm9sTGVuICsgc3VmZml4VGV4dExlbik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmQgPSB2YWx1ZUxlbiAtIChjdXJyZW5jeVN5bWJvbExlbiArIHN1ZmZpeFRleHRMZW4pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgc2V0RWxlbWVudFNlbGVjdGlvbih0aGlzLnRoYXQsIHN0YXJ0LCBlbmQpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBJZiBhIFwiQ29weVwiLCBcIlBhc3RlXCIgb3IgXCJDdXRcIiBrZXlib2FyZCBzaG9ydGN1dCBpcyBkZXRlY3RlZCAocmVzcGVjdGl2ZWx5ICdjdHJsICsgYycsICdjdHJsICsgdicgb3IgJ2N0cmwgKyB4JylcbiAgICAgICAgICAgIGlmICgoZS5jdHJsS2V5IHx8IGUubWV0YUtleSkgJiYgKHRoaXMuZXZlbnRLZXlDb2RlID09PSBrZXlDb2RlLmMgfHwgdGhpcy5ldmVudEtleUNvZGUgPT09IGtleUNvZGUudiB8fCB0aGlzLmV2ZW50S2V5Q29kZSA9PT0ga2V5Q29kZS54KSkge1xuICAgICAgICAgICAgICAgIGlmIChlLnR5cGUgPT09ICdrZXlkb3duJykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9leHBhbmRTZWxlY3Rpb25PblNpZ24oKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBUcnkgdG8gcHJldmVudCB3cm9uZyBwYXN0ZVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmV2ZW50S2V5Q29kZSA9PT0ga2V5Q29kZS52IHx8IHRoaXMuZXZlbnRLZXlDb2RlID09PSBrZXlDb2RlLkluc2VydCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZS50eXBlID09PSAna2V5ZG93bicgfHwgZS50eXBlID09PSAna2V5cHJlc3MnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNVbmRlZmluZWQodGhpcy52YWx1ZVBhcnRzQmVmb3JlUGFzdGUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy52YWx1ZVBhcnRzQmVmb3JlUGFzdGUgPSB0aGlzLl9nZXRMZWZ0QW5kUmlnaHRQYXJ0QXJvdW5kVGhlU2VsZWN0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9jaGVja1Bhc3RlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gZS50eXBlID09PSAna2V5ZG93bicgfHwgZS50eXBlID09PSAna2V5cHJlc3MnIHx8IHRoaXMuZXZlbnRLZXlDb2RlID09PSBrZXlDb2RlLmM7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChlLmN0cmxLZXkgfHwgZS5tZXRhS2V5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEp1bXAgb3ZlciB0aG91c2FuZCBzZXBhcmF0b3JcbiAgICAgICAgICAgIC8vVE9ETyBNb3ZlIHRoaXMgdGVzdCBpbnNpZGUgdGhlIGBvbktleWRvd25gIGhhbmRsZXJcbiAgICAgICAgICAgIGlmICh0aGlzLmV2ZW50S2V5Q29kZSA9PT0ga2V5Q29kZS5MZWZ0QXJyb3cgfHwgdGhpcy5ldmVudEtleUNvZGUgPT09IGtleUNvZGUuUmlnaHRBcnJvdykge1xuICAgICAgICAgICAgICAgIGlmIChlLnR5cGUgPT09ICdrZXlkb3duJyAmJiAhZS5zaGlmdEtleSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5ldmVudEtleUNvZGUgPT09IGtleUNvZGUuTGVmdEFycm93ICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAodGhpcy50aGF0LnZhbHVlLmNoYXJBdCh0aGlzLnNlbGVjdGlvbi5zdGFydCAtIDIpID09PSB0aGlzLnNldHRpbmdzQ2xvbmUuZGlnaXRHcm91cFNlcGFyYXRvciB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50aGF0LnZhbHVlLmNoYXJBdCh0aGlzLnNlbGVjdGlvbi5zdGFydCAtIDIpID09PSB0aGlzLnNldHRpbmdzQ2xvbmUuZGVjaW1hbENoYXJhY3RlcikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3NldENhcmV0UG9zaXRpb24odGhpcy5zZWxlY3Rpb24uc3RhcnQgLSAxKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLmV2ZW50S2V5Q29kZSA9PT0ga2V5Q29kZS5SaWdodEFycm93ICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAodGhpcy50aGF0LnZhbHVlLmNoYXJBdCh0aGlzLnNlbGVjdGlvbi5zdGFydCArIDEpID09PSB0aGlzLnNldHRpbmdzQ2xvbmUuZGlnaXRHcm91cFNlcGFyYXRvciB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50aGF0LnZhbHVlLmNoYXJBdCh0aGlzLnNlbGVjdGlvbi5zdGFydCArIDEpID09PSB0aGlzLnNldHRpbmdzQ2xvbmUuZGVjaW1hbENoYXJhY3RlcikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3NldENhcmV0UG9zaXRpb24odGhpcy5zZWxlY3Rpb24uc3RhcnQgKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXZlbnRLZXlDb2RlID49IGtleUNvZGUuUGFnZURvd24gJiYgdGhpcy5ldmVudEtleUNvZGUgPD0ga2V5Q29kZS5Eb3duQXJyb3c7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogUHJvY2VzcyBkZWxldGlvbiBvZiBjaGFyYWN0ZXJzIHdoZW4gdGhlIG1pbnVzIHNpZ24gaXMgdG8gdGhlIHJpZ2h0IG9mIHRoZSBudW1lcmljIGNoYXJhY3RlcnMuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBsZWZ0IFRoZSBwYXJ0IG9uIHRoZSBsZWZ0IG9mIHRoZSBjYXJldCBvciBzZWxlY3Rpb25cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHJpZ2h0IFRoZSBwYXJ0IG9uIHRoZSByaWdodCBvZiB0aGUgY2FyZXQgb3Igc2VsZWN0aW9uXG4gICAgICAgICAqIEByZXR1cm5zIHtbc3RyaW5nLCBzdHJpbmddfVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgX3Byb2Nlc3NDaGFyYWN0ZXJEZWxldGlvbklmVHJhaWxpbmdOZWdhdGl2ZVNpZ24oW2xlZnQsIHJpZ2h0XSkge1xuICAgICAgICAgICAgY29uc3Qgc2V0dGluZ3NDbG9uZSA9IHRoaXMuc2V0dGluZ3NDbG9uZTtcbiAgICAgICAgICAgIGlmIChzZXR0aW5nc0Nsb25lLmN1cnJlbmN5U3ltYm9sUGxhY2VtZW50ID09PSAncCcgJiYgc2V0dGluZ3NDbG9uZS5uZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudCA9PT0gJ3MnKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZXZlbnRLZXlDb2RlID09PSBrZXlDb2RlLkJhY2tzcGFjZSkge1xuICAgICAgICAgICAgICAgICAgICBzZXR0aW5nc0Nsb25lLmNhcmV0Rml4ID0gKHRoaXMuc2VsZWN0aW9uLnN0YXJ0ID49IHRoaXMudmFsdWUuaW5kZXhPZihzZXR0aW5nc0Nsb25lLnN1ZmZpeFRleHQpICYmIHNldHRpbmdzQ2xvbmUuc3VmZml4VGV4dCAhPT0gJycpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy52YWx1ZS5jaGFyQXQodGhpcy5zZWxlY3Rpb24uc3RhcnQgLSAxKSA9PT0gJy0nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0ID0gbGVmdC5zdWJzdHJpbmcoMSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5zZWxlY3Rpb24uc3RhcnQgPD0gdGhpcy52YWx1ZS5sZW5ndGggLSBzZXR0aW5nc0Nsb25lLnN1ZmZpeFRleHQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0ID0gbGVmdC5zdWJzdHJpbmcoMCwgbGVmdC5sZW5ndGggLSAxKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHNldHRpbmdzQ2xvbmUuY2FyZXRGaXggPSAodGhpcy5zZWxlY3Rpb24uc3RhcnQgPj0gdGhpcy52YWx1ZS5pbmRleE9mKHNldHRpbmdzQ2xvbmUuc3VmZml4VGV4dCkgJiYgc2V0dGluZ3NDbG9uZS5zdWZmaXhUZXh0ICE9PSAnJyk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnNlbGVjdGlvbi5zdGFydCA+PSB0aGlzLnZhbHVlLmluZGV4T2Yoc2V0dGluZ3NDbG9uZS5jdXJyZW5jeVN5bWJvbCkgKyBzZXR0aW5nc0Nsb25lLmN1cnJlbmN5U3ltYm9sLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmlnaHQgPSByaWdodC5zdWJzdHJpbmcoMSwgcmlnaHQubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNOZWdhdGl2ZShsZWZ0KSAmJiB0aGlzLnZhbHVlLmNoYXJBdCh0aGlzLnNlbGVjdGlvbi5zdGFydCkgPT09ICctJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdCA9IGxlZnQuc3Vic3RyaW5nKDEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvL1RPRE8gTWVyZ2UgdGhlIHR3byBmb2xsb3dpbmcgJ2lmJyBibG9ja3MgaW50byBvbmUgYGlmIChzZXR0aW5nc0Nsb25lLmN1cnJlbmN5U3ltYm9sUGxhY2VtZW50ID09PSAncycpIHtgIGFuZCBhIHN3aXRjaCBvbiBzZXR0aW5nc0Nsb25lLm5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50XG4gICAgICAgICAgICBpZiAoc2V0dGluZ3NDbG9uZS5jdXJyZW5jeVN5bWJvbFBsYWNlbWVudCA9PT0gJ3MnICYmIHNldHRpbmdzQ2xvbmUubmVnYXRpdmVQb3NpdGl2ZVNpZ25QbGFjZW1lbnQgPT09ICdsJykge1xuICAgICAgICAgICAgICAgIHNldHRpbmdzQ2xvbmUuY2FyZXRGaXggPSAodGhpcy5zZWxlY3Rpb24uc3RhcnQgPj0gdGhpcy52YWx1ZS5pbmRleE9mKHNldHRpbmdzQ2xvbmUubmVnYXRpdmVTaWduQ2hhcmFjdGVyKSArIHNldHRpbmdzQ2xvbmUubmVnYXRpdmVTaWduQ2hhcmFjdGVyLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZXZlbnRLZXlDb2RlID09PSBrZXlDb2RlLkJhY2tzcGFjZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5zZWxlY3Rpb24uc3RhcnQgPT09ICh0aGlzLnZhbHVlLmluZGV4T2Yoc2V0dGluZ3NDbG9uZS5uZWdhdGl2ZVNpZ25DaGFyYWN0ZXIpICsgc2V0dGluZ3NDbG9uZS5uZWdhdGl2ZVNpZ25DaGFyYWN0ZXIubGVuZ3RoKSAmJiBjb250YWlucyh0aGlzLnZhbHVlLCBzZXR0aW5nc0Nsb25lLm5lZ2F0aXZlU2lnbkNoYXJhY3RlcikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQgPSBsZWZ0LnN1YnN0cmluZygxKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChsZWZ0ICE9PSAnLScgJiYgKCh0aGlzLnNlbGVjdGlvbi5zdGFydCA8PSB0aGlzLnZhbHVlLmluZGV4T2Yoc2V0dGluZ3NDbG9uZS5uZWdhdGl2ZVNpZ25DaGFyYWN0ZXIpKSB8fCAhY29udGFpbnModGhpcy52YWx1ZSwgc2V0dGluZ3NDbG9uZS5uZWdhdGl2ZVNpZ25DaGFyYWN0ZXIpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdCA9IGxlZnQuc3Vic3RyaW5nKDAsIGxlZnQubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAobGVmdFswXSA9PT0gJy0nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByaWdodCA9IHJpZ2h0LnN1YnN0cmluZygxKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5zZWxlY3Rpb24uc3RhcnQgPT09IHRoaXMudmFsdWUuaW5kZXhPZihzZXR0aW5nc0Nsb25lLm5lZ2F0aXZlU2lnbkNoYXJhY3RlcikgJiYgY29udGFpbnModGhpcy52YWx1ZSwgc2V0dGluZ3NDbG9uZS5uZWdhdGl2ZVNpZ25DaGFyYWN0ZXIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0ID0gbGVmdC5zdWJzdHJpbmcoMSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChzZXR0aW5nc0Nsb25lLmN1cnJlbmN5U3ltYm9sUGxhY2VtZW50ID09PSAncycgJiYgc2V0dGluZ3NDbG9uZS5uZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudCA9PT0gJ3InKSB7XG4gICAgICAgICAgICAgICAgc2V0dGluZ3NDbG9uZS5jYXJldEZpeCA9ICh0aGlzLnNlbGVjdGlvbi5zdGFydCA+PSB0aGlzLnZhbHVlLmluZGV4T2Yoc2V0dGluZ3NDbG9uZS5uZWdhdGl2ZVNpZ25DaGFyYWN0ZXIpICsgc2V0dGluZ3NDbG9uZS5uZWdhdGl2ZVNpZ25DaGFyYWN0ZXIubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5ldmVudEtleUNvZGUgPT09IGtleUNvZGUuQmFja3NwYWNlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnNlbGVjdGlvbi5zdGFydCA9PT0gKHRoaXMudmFsdWUuaW5kZXhPZihzZXR0aW5nc0Nsb25lLm5lZ2F0aXZlU2lnbkNoYXJhY3RlcikgKyBzZXR0aW5nc0Nsb25lLm5lZ2F0aXZlU2lnbkNoYXJhY3Rlci5sZW5ndGgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0ID0gbGVmdC5zdWJzdHJpbmcoMSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobGVmdCAhPT0gJy0nICYmIHRoaXMuc2VsZWN0aW9uLnN0YXJ0IDw9ICh0aGlzLnZhbHVlLmluZGV4T2Yoc2V0dGluZ3NDbG9uZS5uZWdhdGl2ZVNpZ25DaGFyYWN0ZXIpIC0gc2V0dGluZ3NDbG9uZS5jdXJyZW5jeVN5bWJvbC5sZW5ndGgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0ID0gbGVmdC5zdWJzdHJpbmcoMCwgbGVmdC5sZW5ndGggLSAxKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChsZWZ0ICE9PSAnJyAmJiAhY29udGFpbnModGhpcy52YWx1ZSwgc2V0dGluZ3NDbG9uZS5uZWdhdGl2ZVNpZ25DaGFyYWN0ZXIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0ID0gbGVmdC5zdWJzdHJpbmcoMCwgbGVmdC5sZW5ndGggLSAxKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHNldHRpbmdzQ2xvbmUuY2FyZXRGaXggPSAodGhpcy5zZWxlY3Rpb24uc3RhcnQgPj0gdGhpcy52YWx1ZS5pbmRleE9mKHNldHRpbmdzQ2xvbmUuY3VycmVuY3lTeW1ib2wpICYmIHNldHRpbmdzQ2xvbmUuY3VycmVuY3lTeW1ib2wgIT09ICcnKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuc2VsZWN0aW9uLnN0YXJ0ID09PSB0aGlzLnZhbHVlLmluZGV4T2Yoc2V0dGluZ3NDbG9uZS5uZWdhdGl2ZVNpZ25DaGFyYWN0ZXIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0ID0gbGVmdC5zdWJzdHJpbmcoMSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmlnaHQgPSByaWdodC5zdWJzdHJpbmcoMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gW2xlZnQsIHJpZ2h0XTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQcm9jZXNzIHRoZSBkZWxldGlvbiBvZiBjaGFyYWN0ZXJzLlxuICAgICAgICAgKi9cbiAgICAgICAgX3Byb2Nlc3NDaGFyYWN0ZXJEZWxldGlvbigpIHtcbiAgICAgICAgICAgIGNvbnN0IHNldHRpbmdzQ2xvbmUgPSB0aGlzLnNldHRpbmdzQ2xvbmU7XG5cbiAgICAgICAgICAgIGxldCBsZWZ0O1xuICAgICAgICAgICAgbGV0IHJpZ2h0O1xuXG4gICAgICAgICAgICBpZiAoIXRoaXMuc2VsZWN0aW9uLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIFtsZWZ0LCByaWdodF0gPSB0aGlzLl9nZXRVbmZvcm1hdHRlZExlZnRBbmRSaWdodFBhcnRBcm91bmRUaGVTZWxlY3Rpb24oKTtcbiAgICAgICAgICAgICAgICBpZiAobGVmdCA9PT0gJycgJiYgcmlnaHQgPT09ICcnKSB7XG4gICAgICAgICAgICAgICAgICAgIHNldHRpbmdzQ2xvbmUudGhyb3dJbnB1dCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICgoKHNldHRpbmdzQ2xvbmUuY3VycmVuY3lTeW1ib2xQbGFjZW1lbnQgPT09ICdwJyAmJiBzZXR0aW5nc0Nsb25lLm5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50ID09PSAncycpIHx8XG4gICAgICAgICAgICAgICAgICAgIChzZXR0aW5nc0Nsb25lLmN1cnJlbmN5U3ltYm9sUGxhY2VtZW50ID09PSAncycgJiYgKHNldHRpbmdzQ2xvbmUubmVnYXRpdmVQb3NpdGl2ZVNpZ25QbGFjZW1lbnQgPT09ICdsJyB8fCBzZXR0aW5nc0Nsb25lLm5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50ID09PSAncicpKSkgJiZcbiAgICAgICAgICAgICAgICAgICAgaXNOZWdhdGl2ZSh0aGlzLnZhbHVlKSkgeyAvL1RPRE8gQ2hhbmdlIGB0aGlzLnZhbHVlYCB0byBgdGhpcy50aGF0LnZhbHVlYD9cbiAgICAgICAgICAgICAgICAgICAgW2xlZnQsIHJpZ2h0XSA9IHRoaXMuX3Byb2Nlc3NDaGFyYWN0ZXJEZWxldGlvbklmVHJhaWxpbmdOZWdhdGl2ZVNpZ24oW2xlZnQsIHJpZ2h0XSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuZXZlbnRLZXlDb2RlID09PSBrZXlDb2RlLkJhY2tzcGFjZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdCA9IGxlZnQuc3Vic3RyaW5nKDAsIGxlZnQubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByaWdodCA9IHJpZ2h0LnN1YnN0cmluZygxLCByaWdodC5sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9leHBhbmRTZWxlY3Rpb25PblNpZ24oZmFsc2UpO1xuICAgICAgICAgICAgICAgIFtsZWZ0LCByaWdodF0gPSB0aGlzLl9nZXRVbmZvcm1hdHRlZExlZnRBbmRSaWdodFBhcnRBcm91bmRUaGVTZWxlY3Rpb24oKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5fc2V0VmFsdWVQYXJ0cyhsZWZ0LCByaWdodCk7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhpcyBmdW5jdGlvbiBkZWNpZGVzIGlmIHRoZSBrZXkgcHJlc3NlZCBzaG91bGQgYmUgZHJvcHBlZCBvciBhY2NlcHRlZCwgYW5kIG1vZGlmeSB0aGUgdmFsdWUgJ29uLXRoZS1mbHknIGFjY29yZGluZ2x5LlxuICAgICAgICAgKiBSZXR1cm5zIFRSVUUgaWYgdGhlIGtleWNvZGUgaXMgYWxsb3dlZC5cbiAgICAgICAgICogVGhpcyBmdW5jdGlvbnMgYWxzbyBtb2RpZnkgdGhlIHZhbHVlIG9uLXRoZS1mbHkuIC8vRklYTUUgVGhpcyBzaG91bGQgdXNlIGFub3RoZXIgZnVuY3Rpb24gaW4gb3JkZXIgdG8gc2VwYXJhdGUgdGhlIHRlc3QgYW5kIHRoZSBtb2RpZmljYXRpb25cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtFdmVudH0gZVxuICAgICAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgICAgICovXG4gICAgICAgIF9wcm9jZXNzQ2hhcmFjdGVySW5zZXJ0aW9uKGUpIHtcbiAgICAgICAgICAgIGNvbnN0IHNldHRpbmdzQ2xvbmUgPSB0aGlzLnNldHRpbmdzQ2xvbmU7XG4gICAgICAgICAgICBsZXQgW2xlZnQsIHJpZ2h0XSA9IHRoaXMuX2dldFVuZm9ybWF0dGVkTGVmdEFuZFJpZ2h0UGFydEFyb3VuZFRoZVNlbGVjdGlvbigpO1xuICAgICAgICAgICAgc2V0dGluZ3NDbG9uZS50aHJvd0lucHV0ID0gdHJ1ZTtcblxuICAgICAgICAgICAgLy8gUmV0cmlldmUgdGhlIHJlYWwgY2hhcmFjdGVyIHRoYXQgaGFzIGJlZW4gZW50ZXJlZCAoaWUuICdhJyBpbnN0ZWFkIG9mIHRoZSBrZXkgY29kZSlcbiAgICAgICAgICAgIGNvbnN0IGV2ZW50Q2hhcmFjdGVyID0gY2hhcmFjdGVyKGUpO1xuXG4gICAgICAgICAgICAvLyBTdGFydCBydWxlcyB3aGVuIHRoZSBkZWNpbWFsIGNoYXJhY3RlciBrZXkgaXMgcHJlc3NlZCBhbHdheXMgdXNlIG51bWVyaWMgcGFkIGRvdCB0byBpbnNlcnQgZGVjaW1hbCBzZXBhcmF0b3JcbiAgICAgICAgICAgIC8vIERvIG5vdCBhbGxvdyBkZWNpbWFsIGNoYXJhY3RlciBpZiBubyBkZWNpbWFsIHBhcnQgYWxsb3dlZFxuICAgICAgICAgICAgaWYgKGV2ZW50Q2hhcmFjdGVyID09PSBzZXR0aW5nc0Nsb25lLmRlY2ltYWxDaGFyYWN0ZXIgfHxcbiAgICAgICAgICAgICAgICAoc2V0dGluZ3NDbG9uZS5kZWNpbWFsQ2hhcmFjdGVyQWx0ZXJuYXRpdmUgJiYgZXZlbnRDaGFyYWN0ZXIgPT09IHNldHRpbmdzQ2xvbmUuZGVjaW1hbENoYXJhY3RlckFsdGVybmF0aXZlKSB8fFxuICAgICAgICAgICAgICAgICgoZXZlbnRDaGFyYWN0ZXIgPT09ICcuJyB8fCBldmVudENoYXJhY3RlciA9PT0gJywnKSAmJiB0aGlzLmV2ZW50S2V5Q29kZSA9PT0ga2V5Q29kZS5Eb3ROdW1wYWQpKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFzZXR0aW5nc0Nsb25lLmRlY2ltYWxQbGFjZXNPdmVycmlkZSB8fCAhc2V0dGluZ3NDbG9uZS5kZWNpbWFsQ2hhcmFjdGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIERvIG5vdCBhbGxvdyBkZWNpbWFsIGNoYXJhY3RlciBiZWZvcmUgbmVnYXRpdmVTaWduQ2hhcmFjdGVyIGNoYXJhY3RlclxuICAgICAgICAgICAgICAgIGlmIChzZXR0aW5nc0Nsb25lLm5lZ2F0aXZlU2lnbkNoYXJhY3RlciAmJiBjb250YWlucyhyaWdodCwgc2V0dGluZ3NDbG9uZS5uZWdhdGl2ZVNpZ25DaGFyYWN0ZXIpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIERvIG5vdCBhbGxvdyBkZWNpbWFsIGNoYXJhY3RlciBpZiBvdGhlciBkZWNpbWFsIGNoYXJhY3RlciBwcmVzZW50XG4gICAgICAgICAgICAgICAgaWYgKGNvbnRhaW5zKGxlZnQsIHNldHRpbmdzQ2xvbmUuZGVjaW1hbENoYXJhY3RlcikpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHJpZ2h0LmluZGV4T2Yoc2V0dGluZ3NDbG9uZS5kZWNpbWFsQ2hhcmFjdGVyKSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHJpZ2h0LmluZGV4T2Yoc2V0dGluZ3NDbG9uZS5kZWNpbWFsQ2hhcmFjdGVyKSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICByaWdodCA9IHJpZ2h0LnN1YnN0cigxKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aGlzLl9zZXRWYWx1ZVBhcnRzKGxlZnQgKyBzZXR0aW5nc0Nsb25lLmRlY2ltYWxDaGFyYWN0ZXIsIHJpZ2h0KTtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBQcmV2ZW50IG1pbnVzIGlmIG5vdCBhbGxvd2VkXG4gICAgICAgICAgICBpZiAoKGV2ZW50Q2hhcmFjdGVyID09PSAnLScgfHwgZXZlbnRDaGFyYWN0ZXIgPT09ICcrJykgJiYgc2V0dGluZ3NDbG9uZS5uZWdhdGl2ZVNpZ25DaGFyYWN0ZXIgPT09ICctJykge1xuICAgICAgICAgICAgICAgIGlmICghc2V0dGluZ3NDbG9uZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBDYXJldCBpcyBhbHdheXMgYWZ0ZXIgbWludXNcbiAgICAgICAgICAgICAgICBpZiAoKHNldHRpbmdzQ2xvbmUuY3VycmVuY3lTeW1ib2xQbGFjZW1lbnQgPT09ICdwJyAmJiBzZXR0aW5nc0Nsb25lLm5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50ID09PSAncycpIHx8IChzZXR0aW5nc0Nsb25lLmN1cnJlbmN5U3ltYm9sUGxhY2VtZW50ID09PSAncycgJiYgc2V0dGluZ3NDbG9uZS5uZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudCAhPT0gJ3AnKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAobGVmdCA9PT0gJycgJiYgY29udGFpbnMocmlnaHQsIHNldHRpbmdzQ2xvbmUubmVnYXRpdmVTaWduQ2hhcmFjdGVyKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdCA9IHNldHRpbmdzQ2xvbmUubmVnYXRpdmVTaWduQ2hhcmFjdGVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmlnaHQgPSByaWdodC5zdWJzdHJpbmcoMSwgcmlnaHQubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIENoYW5nZSBudW1iZXIgc2lnbiwgcmVtb3ZlIHBhcnQgaWYgc2hvdWxkXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc05lZ2F0aXZlU3RyaWN0KGxlZnQpIHx8IGNvbnRhaW5zKGxlZnQsIHNldHRpbmdzQ2xvbmUubmVnYXRpdmVTaWduQ2hhcmFjdGVyKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdCA9IGxlZnQuc3Vic3RyaW5nKDEsIGxlZnQubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQgPSAoZXZlbnRDaGFyYWN0ZXIgPT09ICctJykgPyBzZXR0aW5nc0Nsb25lLm5lZ2F0aXZlU2lnbkNoYXJhY3RlciArIGxlZnQgOiBsZWZ0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxlZnQgPT09ICcnICYmIGNvbnRhaW5zKHJpZ2h0LCBzZXR0aW5nc0Nsb25lLm5lZ2F0aXZlU2lnbkNoYXJhY3RlcikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQgPSBzZXR0aW5nc0Nsb25lLm5lZ2F0aXZlU2lnbkNoYXJhY3RlcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJpZ2h0ID0gcmlnaHQuc3Vic3RyaW5nKDEsIHJpZ2h0Lmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBDaGFuZ2UgbnVtYmVyIHNpZ24sIHJlbW92ZSBwYXJ0IGlmIHNob3VsZFxuICAgICAgICAgICAgICAgICAgICBpZiAobGVmdC5jaGFyQXQoMCkgPT09IHNldHRpbmdzQ2xvbmUubmVnYXRpdmVTaWduQ2hhcmFjdGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0ID0gbGVmdC5zdWJzdHJpbmcoMSwgbGVmdC5sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdCA9IChldmVudENoYXJhY3RlciA9PT0gJy0nKSA/IHNldHRpbmdzQ2xvbmUubmVnYXRpdmVTaWduQ2hhcmFjdGVyICsgbGVmdCA6IGxlZnQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aGlzLl9zZXRWYWx1ZVBhcnRzKGxlZnQsIHJpZ2h0KTtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBJZiB0aGUgdXNlciB0cmllcyB0byBpbnNlcnQgZGlnaXQgYmVmb3JlIG1pbnVzIHNpZ25cbiAgICAgICAgICAgIGNvbnN0IGV2ZW50TnVtYmVyID0gTnVtYmVyKGV2ZW50Q2hhcmFjdGVyKTtcbiAgICAgICAgICAgIGlmIChldmVudE51bWJlciA+PSAwICYmIGV2ZW50TnVtYmVyIDw9IDkpIHtcbiAgICAgICAgICAgICAgICBpZiAoc2V0dGluZ3NDbG9uZS5uZWdhdGl2ZVNpZ25DaGFyYWN0ZXIgJiYgbGVmdCA9PT0gJycgJiYgY29udGFpbnMocmlnaHQsIHNldHRpbmdzQ2xvbmUubmVnYXRpdmVTaWduQ2hhcmFjdGVyKSkge1xuICAgICAgICAgICAgICAgICAgICBsZWZ0ID0gc2V0dGluZ3NDbG9uZS5uZWdhdGl2ZVNpZ25DaGFyYWN0ZXI7XG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0ID0gcmlnaHQuc3Vic3RyaW5nKDEsIHJpZ2h0Lmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHNldHRpbmdzQ2xvbmUubWF4aW11bVZhbHVlIDw9IDAgJiYgc2V0dGluZ3NDbG9uZS5taW5pbXVtVmFsdWUgPCBzZXR0aW5nc0Nsb25lLm1heGltdW1WYWx1ZSAmJiAhY29udGFpbnModGhpcy52YWx1ZSwgc2V0dGluZ3NDbG9uZS5uZWdhdGl2ZVNpZ25DaGFyYWN0ZXIpICYmIGV2ZW50Q2hhcmFjdGVyICE9PSAnMCcpIHtcbiAgICAgICAgICAgICAgICAgICAgbGVmdCA9IHNldHRpbmdzQ2xvbmUubmVnYXRpdmVTaWduQ2hhcmFjdGVyICsgbGVmdDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aGlzLl9zZXRWYWx1ZVBhcnRzKGxlZnQgKyBldmVudENoYXJhY3RlciwgcmlnaHQpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFByZXZlbnQgYW55IG90aGVyIGNoYXJhY3RlclxuICAgICAgICAgICAgc2V0dGluZ3NDbG9uZS50aHJvd0lucHV0ID0gZmFsc2U7XG5cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGb3JtYXR0aW5nIG9mIGp1c3QgcHJvY2Vzc2VkIHZhbHVlIHdoaWxlIGtlZXBpbmcgdGhlIGN1cnNvciBwb3NpdGlvblxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge0V2ZW50fSBlXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICBfZm9ybWF0VmFsdWUoZSkge1xuICAgICAgICAgICAgY29uc3Qgc2V0dGluZ3NDbG9uZSA9IHRoaXMuc2V0dGluZ3NDbG9uZTtcbiAgICAgICAgICAgIGNvbnN0IGxlZnRMZW5ndGggPSB0aGlzLnZhbHVlO1xuICAgICAgICAgICAgbGV0IFtsZWZ0XSA9IHRoaXMuX2dldFVuZm9ybWF0dGVkTGVmdEFuZFJpZ2h0UGFydEFyb3VuZFRoZVNlbGVjdGlvbigpO1xuXG4gICAgICAgICAgICAvLyBObyBncm91cGluZyBzZXBhcmF0b3IgYW5kIG5vIGN1cnJlbmN5IHNpZ25cbiAgICAgICAgICAgIGlmICgoc2V0dGluZ3NDbG9uZS5kaWdpdEdyb3VwU2VwYXJhdG9yICA9PT0gJycgfHwgKHNldHRpbmdzQ2xvbmUuZGlnaXRHcm91cFNlcGFyYXRvciAhPT0gJycgICYmICFjb250YWlucyhsZWZ0TGVuZ3RoLCBzZXR0aW5nc0Nsb25lLmRpZ2l0R3JvdXBTZXBhcmF0b3IpKSkgJiZcbiAgICAgICAgICAgICAgICAoc2V0dGluZ3NDbG9uZS5jdXJyZW5jeVN5bWJvbCA9PT0gJycgfHwgKHNldHRpbmdzQ2xvbmUuY3VycmVuY3lTeW1ib2wgIT09ICcnICYmICFjb250YWlucyhsZWZ0TGVuZ3RoLCBzZXR0aW5nc0Nsb25lLmN1cnJlbmN5U3ltYm9sKSkpKSB7XG4gICAgICAgICAgICAgICAgbGV0IFtzdWJQYXJ0c10gPSBsZWZ0TGVuZ3RoLnNwbGl0KHNldHRpbmdzQ2xvbmUuZGVjaW1hbENoYXJhY3Rlcik7XG4gICAgICAgICAgICAgICAgbGV0IG5TaWduID0gJyc7XG4gICAgICAgICAgICAgICAgaWYgKGlzTmVnYXRpdmUoc3ViUGFydHMpKSB7XG4gICAgICAgICAgICAgICAgICAgIG5TaWduID0gJy0nO1xuICAgICAgICAgICAgICAgICAgICBzdWJQYXJ0cyA9IHN1YlBhcnRzLnJlcGxhY2UoJy0nLCAnJyk7XG4gICAgICAgICAgICAgICAgICAgIGxlZnQgPSBsZWZ0LnJlcGxhY2UoJy0nLCAnJyk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gU3RyaXAgbGVhZGluZyB6ZXJvIG9uIHBvc2l0aXZlIHZhbHVlIGlmIG5lZWRlZFxuICAgICAgICAgICAgICAgIGlmIChuU2lnbiA9PT0gJycgJiYgc3ViUGFydHMubGVuZ3RoID4gc2V0dGluZ3NDbG9uZS5tSW50UG9zICYmIGxlZnQuY2hhckF0KDApID09PSAnMCcpIHtcbiAgICAgICAgICAgICAgICAgICAgbGVmdCA9IGxlZnQuc2xpY2UoMSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gU3RyaXAgbGVhZGluZyB6ZXJvIG9uIG5lZ2F0aXZlIHZhbHVlIGlmIG5lZWRlZFxuICAgICAgICAgICAgICAgIGlmIChuU2lnbiA9PT0gJy0nICYmIHN1YlBhcnRzLmxlbmd0aCA+IHNldHRpbmdzQ2xvbmUubUludE5lZyAmJiBsZWZ0LmNoYXJBdCgwKSA9PT0gJzAnKSB7XG4gICAgICAgICAgICAgICAgICAgIGxlZnQgPSBsZWZ0LnNsaWNlKDEpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGxlZnQgPSBuU2lnbiArIGxlZnQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gYWRkR3JvdXBTZXBhcmF0b3JzKHRoaXMudmFsdWUsIHRoaXMuc2V0dGluZ3NDbG9uZSk7XG4gICAgICAgICAgICBsZXQgcG9zaXRpb24gPSB2YWx1ZS5sZW5ndGg7XG4gICAgICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICAvLyBQcmVwYXJlIHJlZ2V4cCB3aGljaCBzZWFyY2hlcyBmb3IgY3Vyc29yIHBvc2l0aW9uIGZyb20gdW5mb3JtYXR0ZWQgbGVmdCBwYXJ0XG4gICAgICAgICAgICAgICAgY29uc3QgbGVmdEFyID0gbGVmdC5zcGxpdCgnJyk7XG5cbiAgICAgICAgICAgICAgICAvLyBGaXhlcyBjYXJldCBwb3NpdGlvbiB3aXRoIHRyYWlsaW5nIG1pbnVzIHNpZ25cbiAgICAgICAgICAgICAgICBpZiAoKHNldHRpbmdzQ2xvbmUubmVnYXRpdmVQb3NpdGl2ZVNpZ25QbGFjZW1lbnQgPT09ICdzJyB8fCAoc2V0dGluZ3NDbG9uZS5jdXJyZW5jeVN5bWJvbFBsYWNlbWVudCA9PT0gJ3MnICYmIHNldHRpbmdzQ2xvbmUubmVnYXRpdmVQb3NpdGl2ZVNpZ25QbGFjZW1lbnQgIT09ICdwJykpICYmXG4gICAgICAgICAgICAgICAgICAgIGxlZnRBclswXSA9PT0gJy0nICYmIHNldHRpbmdzQ2xvbmUubmVnYXRpdmVTaWduQ2hhcmFjdGVyICE9PSAnJykge1xuICAgICAgICAgICAgICAgICAgICBsZWZ0QXIuc2hpZnQoKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoKHRoaXMuZXZlbnRLZXlDb2RlID09PSBrZXlDb2RlLkJhY2tzcGFjZSB8fCB0aGlzLmV2ZW50S2V5Q29kZSA9PT0ga2V5Q29kZS5EZWxldGUpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXR0aW5nc0Nsb25lLmNhcmV0Rml4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2V0dGluZ3NDbG9uZS5jdXJyZW5jeVN5bWJvbFBsYWNlbWVudCA9PT0gJ3MnICYmIHNldHRpbmdzQ2xvbmUubmVnYXRpdmVQb3NpdGl2ZVNpZ25QbGFjZW1lbnQgPT09ICdsJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxlZnRBci5wdXNoKCctJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3NDbG9uZS5jYXJldEZpeCA9IGUudHlwZSA9PT0gJ2tleWRvd24nO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2V0dGluZ3NDbG9uZS5jdXJyZW5jeVN5bWJvbFBsYWNlbWVudCA9PT0gJ3AnICYmIHNldHRpbmdzQ2xvbmUubmVnYXRpdmVQb3NpdGl2ZVNpZ25QbGFjZW1lbnQgPT09ICdzJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxlZnRBci5wdXNoKCctJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3NDbG9uZS5jYXJldEZpeCA9IGUudHlwZSA9PT0gJ2tleWRvd24nO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2V0dGluZ3NDbG9uZS5jdXJyZW5jeVN5bWJvbFBsYWNlbWVudCA9PT0gJ3MnICYmIHNldHRpbmdzQ2xvbmUubmVnYXRpdmVQb3NpdGl2ZVNpZ25QbGFjZW1lbnQgPT09ICdyJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHNpZ25QYXJ0cyA9IHNldHRpbmdzQ2xvbmUuY3VycmVuY3lTeW1ib2wuc3BsaXQoJycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGVzY2FwZUNociA9IFsnXFxcXCcsICdeJywgJyQnLCAnLicsICd8JywgJz8nLCAnKicsICcrJywgJygnLCAnKScsICdbJ107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZXNjYXBlZFBhcnRzID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJC5lYWNoKHNpZ25QYXJ0cywgKGksIG1pbmlQYXJ0cykgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtaW5pUGFydHMgPSBzaWduUGFydHNbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc0luQXJyYXkobWluaVBhcnRzLCBlc2NhcGVDaHIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlc2NhcGVkUGFydHMucHVzaCgnXFxcXCcgKyBtaW5pUGFydHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXNjYXBlZFBhcnRzLnB1c2gobWluaVBhcnRzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuZXZlbnRLZXlDb2RlID09PSBrZXlDb2RlLkJhY2tzcGFjZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlc2NhcGVkUGFydHMucHVzaCgnLScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFB1c2hpbmcgdGhlIGVzY2FwZWQgc2lnblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxlZnRBci5wdXNoKGVzY2FwZWRQYXJ0cy5qb2luKCcnKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3NDbG9uZS5jYXJldEZpeCA9IGUudHlwZSA9PT0gJ2tleWRvd24nO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZWZ0QXIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFsZWZ0QXJbaV0ubWF0Y2goJ1xcXFxkJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnRBcltpXSA9ICdcXFxcJyArIGxlZnRBcltpXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGNvbnN0IGxlZnRSZWcgPSBuZXcgUmVnRXhwKCdeLio/JyArIGxlZnRBci5qb2luKCcuKj8nKSk7XG5cbiAgICAgICAgICAgICAgICAvLyBTZWFyY2ggY3Vyc29yIHBvc2l0aW9uIGluIGZvcm1hdHRlZCB2YWx1ZVxuICAgICAgICAgICAgICAgIGNvbnN0IG5ld0xlZnQgPSB2YWx1ZS5tYXRjaChsZWZ0UmVnKTtcbiAgICAgICAgICAgICAgICBpZiAobmV3TGVmdCkge1xuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbiA9IG5ld0xlZnRbMF0ubGVuZ3RoO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZSBwb3NpdGl2ZSBzaWduIGlzIHNob3duLCBjYWxjdWxhdGUgdGhlIGNhcmV0IHBvc2l0aW9uIGFjY29yZGluZ2x5XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZXR0aW5nc0Nsb25lLnNob3dQb3NpdGl2ZVNpZ24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwb3NpdGlvbiA9PT0gMCAmJiBuZXdMZWZ0LmlucHV0LmNoYXJBdCgwKSA9PT0gc2V0dGluZ3NDbG9uZS5wb3NpdGl2ZVNpZ25DaGFyYWN0ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbiA9IChuZXdMZWZ0LmlucHV0LmluZGV4T2Yoc2V0dGluZ3NDbG9uZS5jdXJyZW5jeVN5bWJvbCkgPT09IDEpID8gc2V0dGluZ3NDbG9uZS5jdXJyZW5jeVN5bWJvbC5sZW5ndGggKyAxIDogMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBvc2l0aW9uID09PSAwICYmIG5ld0xlZnQuaW5wdXQuY2hhckF0KHNldHRpbmdzQ2xvbmUuY3VycmVuY3lTeW1ib2wubGVuZ3RoKSA9PT0gc2V0dGluZ3NDbG9uZS5wb3NpdGl2ZVNpZ25DaGFyYWN0ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbiA9IHNldHRpbmdzQ2xvbmUuY3VycmVuY3lTeW1ib2wubGVuZ3RoICsgMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHdlIGFyZSBqdXN0IGJlZm9yZSB0aGUgc2lnbiB3aGljaCBpcyBpbiBwcmVmaXggcG9zaXRpb25cbiAgICAgICAgICAgICAgICAgICAgaWYgKCgocG9zaXRpb24gPT09IDAgJiYgdmFsdWUuY2hhckF0KDApICE9PSBzZXR0aW5nc0Nsb25lLm5lZ2F0aXZlU2lnbkNoYXJhY3RlcikgfHwgKHBvc2l0aW9uID09PSAxICYmIHZhbHVlLmNoYXJBdCgwKSA9PT0gc2V0dGluZ3NDbG9uZS5uZWdhdGl2ZVNpZ25DaGFyYWN0ZXIpKSAmJiBzZXR0aW5nc0Nsb25lLmN1cnJlbmN5U3ltYm9sICYmIHNldHRpbmdzQ2xvbmUuY3VycmVuY3lTeW1ib2xQbGFjZW1lbnQgPT09ICdwJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUGxhY2UgY2FyZXQgYWZ0ZXIgcHJlZml4IHNpZ25cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vVE9ETyBTaG91bGQgdGhlIHRlc3QgYmUgJ2lzTmVnYXRpdmUnIGluc3RlYWQgb2YgJ2lzTmVnYXRpdmVTdHJpY3QnIGluIG9yZGVyIHRvIHNlYXJjaCBmb3IgJy0nIGV2ZXJ5d2hlcmUgaW4gdGhlIHN0cmluZz9cbiAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uID0gdGhpcy5zZXR0aW5nc0Nsb25lLmN1cnJlbmN5U3ltYm9sLmxlbmd0aCArIChpc05lZ2F0aXZlU3RyaWN0KHZhbHVlKSA/IDEgOiAwKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZXR0aW5nc0Nsb25lLmN1cnJlbmN5U3ltYm9sICYmIHNldHRpbmdzQ2xvbmUuY3VycmVuY3lTeW1ib2xQbGFjZW1lbnQgPT09ICdzJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgd2UgY291bGQgbm90IGZpbmQgYSBwbGFjZSBmb3IgY3Vyc29yIGFuZCBoYXZlIGEgc2lnbiBhcyBhIHN1ZmZpeFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUGxhY2UgY2FyZXQgYmVmb3JlIHN1ZmZpeCBjdXJyZW5jeSBzaWduXG4gICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbiAtPSBzZXR0aW5nc0Nsb25lLmN1cnJlbmN5U3ltYm9sLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmIChzZXR0aW5nc0Nsb25lLnN1ZmZpeFRleHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHdlIGNvdWxkIG5vdCBmaW5kIGEgcGxhY2UgZm9yIGN1cnNvciBhbmQgaGF2ZSBhIHN1ZmZpeFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUGxhY2UgY2FyZXQgYmVmb3JlIHN1ZmZpeFxuICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb24gLT0gc2V0dGluZ3NDbG9uZS5zdWZmaXhUZXh0Lmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gT25seSB1cGRhdGUgdGhlIHZhbHVlIGlmIGl0IGhhcyBjaGFuZ2VkLiBUaGlzIHByZXZlbnRzIG1vZGlmeWluZyB0aGUgc2VsZWN0aW9uLCBpZiBhbnkuXG4gICAgICAgICAgICBpZiAodmFsdWUgIT09IHRoaXMudGhhdC52YWx1ZSB8fFxuICAgICAgICAgICAgICAgIHZhbHVlID09PSB0aGlzLnRoYXQudmFsdWUgJiYgKHRoaXMuZXZlbnRLZXlDb2RlID09PSBrZXlDb2RlLm51bTAgfHwgdGhpcy5ldmVudEtleUNvZGUgPT09IGtleUNvZGUubnVtcGFkMCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRoYXQudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLl9zZXRDYXJldFBvc2l0aW9uKHBvc2l0aW9uKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5mb3JtYXR0ZWQgPSB0cnVlOyAvL1RPRE8gUmVuYW1lIGB0aGlzLmZvcm1hdHRlZGAgdG8gYHRoaXMuX2Zvcm1hdEV4ZWN1dGVkYCwgc2luY2UgaXQncyBwb3NzaWJsZSB0aGlzIGZ1bmN0aW9uIGRvZXMgbm90IG5lZWQgdG8gZm9ybWF0IGFueXRoaW5nIChpbiB0aGUgY2FzZSB3aGVyZSB0aGUga2V5Y29kZSBpcyBkcm9wcGVkIGZvciBpbnN0YW5jZSlcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gZmFjdG9yaXNlIHRoZSBgZ2V0U3RyaW5nKClgIGFuZCBgZ2V0QXJyYXkoKWAgZnVuY3Rpb25zIHNpbmNlIHRoZXkgc2hhcmUgcXVpdGUgYSBsb3Qgb2YgY29kZS5cbiAgICAgKlxuICAgICAqIFRoZSBcImdldFN0cmluZ1wiIG1ldGhvZCB1c2VzIGpRdWVyeSdzIC5zZXJpYWxpemUoKSBtZXRob2QgdGhhdCBjcmVhdGVzIGEgdGV4dCBzdHJpbmcgaW4gc3RhbmRhcmQgVVJMLWVuY29kZWQgbm90YXRpb24uXG4gICAgICogVGhlIFwiZ2V0QXJyYXlcIiBtZXRob2Qgb24gdGhlIG90aGVyIGhhbmQgdXNlcyBqUXVlcnkncyAuc2VyaWFsaXplQXJyYXkoKSBtZXRob2QgdGhhdCBjcmVhdGVzIGFycmF5IG9yIG9iamVjdHMgdGhhdCBjYW4gYmUgZW5jb2RlZCBhcyBhIEpTT04gc3RyaW5nLlxuICAgICAqXG4gICAgICogSXQgdGhlbiBsb29wcyB0aHJvdWdoIHRoZSBzdHJpbmcgYW5kIHVuLWZvcm1hdHMgdGhlIGlucHV0cyB3aXRoIGF1dG9OdW1lcmljLlxuICAgICAqIEJ5IGRlZmF1bHRzIHZhbHVlcyByZXR1cm5lZCBhcyBJU08gbnVtZXJpYyBzdHJpbmcgXCIxMjM0LjU2XCIgb3IgXCItMTIzNC41NlwiIHdoZXJlIHRoZSBkZWNpbWFsIGNoYXJhY3RlciBpcyBhIHBlcmlvZFxuICAgICAqIExvY2FsZSBmb3JtYXRzIGFyZSBzdXBwb3J0ZWQgXCIxMjM0LjU2LVwiIG9yIFwiMTIzNCw1NlwiIG9yIFwiLTEyMzQsNTYgb3IgXCIxMjM0LDU2LVwiLCBvciBldmVuIHBsYWluIG51bWJlcnMgPT4gcGxlYXNlIHNlZSBvcHRpb24gXCJvdXRwdXRGb3JtYXRcIiBmb3IgbW9yZSBkZXRhaWxzXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGdldEFycmF5QmVoYXZpb3IgLSBJZiBzZXQgdG8gVFJVRSwgdGhlbiB0aGlzIGZ1bmN0aW9uIGJlaGF2ZSBsaWtlIGBnZXRBcnJheSgpYCwgb3RoZXJ3aXNlIGlmIHNldCB0byBGQUxTRSwgaXQgYmVoYXZlIGxpa2UgYGdldFN0cmluZygpYFxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHRoYXQgLSBBIHJlZmVyZW5jZSB0byB0aGUgY3VycmVudCBET00gZWxlbWVudFxuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgZnVuY3Rpb24gX2dldFN0cmluZ09yQXJyYXkoZ2V0QXJyYXlCZWhhdmlvciA9IHRydWUsIHRoYXQpIHtcbiAgICAgICAgY29uc3QgJHRoaXMgPSBnZXRDdXJyZW50RWxlbWVudCh0aGF0KTtcbiAgICAgICAgY29uc3QgZm9ybUluZGV4ID0gJCgnZm9ybScpLmluZGV4KCR0aGlzKTtcbiAgICAgICAgY29uc3QgYWxsRm9ybUVsZW1lbnRzID0gJChgZm9ybTplcSgke2Zvcm1JbmRleH0pYClbMF07XG4gICAgICAgIGNvbnN0IGFpSW5kZXggPSBbXTtcblxuICAgICAgICAvLyBhbGwgaW5wdXQgaW5kZXhcbiAgICAgICAgY29uc3Qgc2NJbmRleCA9IFtdO1xuXG4gICAgICAgIC8vIHN1Y2Nlc3NmdWwgY29udHJvbCBpbmRleFxuICAgICAgICBjb25zdCByU3VibWl0dGVyVHlwZXMgPSAvXig/OnN1Ym1pdHxidXR0b258aW1hZ2V8cmVzZXR8ZmlsZSkkL2k7XG5cbiAgICAgICAgLy8gZnJvbSBqUXVlcnkgc2VyaWFsaXplIG1ldGhvZFxuICAgICAgICBjb25zdCByU3VibWl0dGFibGUgPSAvXig/OmlucHV0fHNlbGVjdHx0ZXh0YXJlYXxrZXlnZW4pL2k7XG5cbiAgICAgICAgLy8gZnJvbSBqUXVlcnkgc2VyaWFsaXplIG1ldGhvZFxuICAgICAgICBjb25zdCByQ2hlY2thYmxlVHlwZSA9IC9eKD86Y2hlY2tib3h8cmFkaW8pJC9pO1xuICAgICAgICBjb25zdCByTm9uQXV0b051bWVyaWNUeXBlcyA9IC9eKD86YnV0dG9ufGNoZWNrYm94fGNvbG9yfGRhdGV8ZGF0ZXRpbWV8ZGF0ZXRpbWUtbG9jYWx8ZW1haWx8ZmlsZXxpbWFnZXxtb250aHxudW1iZXJ8cGFzc3dvcmR8cmFkaW98cmFuZ2V8cmVzZXR8c2VhcmNofHN1Ym1pdHx0aW1lfHVybHx3ZWVrKS9pO1xuXG4gICAgICAgIGxldCBjb3VudCA9IDA7XG5cbiAgICAgICAgLy8gaW5kZXggb2Ygc3VjY2Vzc2Z1bCBlbGVtZW50c1xuICAgICAgICAkLmVhY2goYWxsRm9ybUVsZW1lbnRzLCAoaSwgZmllbGQpID0+IHtcbiAgICAgICAgICAgIGlmIChmaWVsZC5uYW1lICE9PSAnJyAmJiByU3VibWl0dGFibGUudGVzdChmaWVsZC5sb2NhbE5hbWUpICYmICFyU3VibWl0dGVyVHlwZXMudGVzdChmaWVsZC50eXBlKSAmJiAhZmllbGQuZGlzYWJsZWQgJiYgKGZpZWxkLmNoZWNrZWQgfHwgIXJDaGVja2FibGVUeXBlLnRlc3QoZmllbGQudHlwZSkpKSB7XG4gICAgICAgICAgICAgICAgc2NJbmRleC5wdXNoKGNvdW50KTtcbiAgICAgICAgICAgICAgICBjb3VudCsrO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzY0luZGV4LnB1c2goLTEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBpbmRleCBvZiBhbGwgaW5wdXRzIHRhZ3MgZXhjZXB0IGNoZWNrYm94XG4gICAgICAgIGNvdW50ID0gMDtcbiAgICAgICAgJC5lYWNoKGFsbEZvcm1FbGVtZW50cywgKGksIGZpZWxkKSA9PiB7XG4gICAgICAgICAgICBpZiAoZmllbGQubG9jYWxOYW1lID09PSAnaW5wdXQnICYmIChmaWVsZC50eXBlID09PSAnJyB8fCBmaWVsZC50eXBlID09PSAndGV4dCcgfHwgZmllbGQudHlwZSA9PT0gJ2hpZGRlbicgfHwgZmllbGQudHlwZSA9PT0gJ3RlbCcpKSB7XG4gICAgICAgICAgICAgICAgYWlJbmRleC5wdXNoKGNvdW50KTtcbiAgICAgICAgICAgICAgICBjb3VudCsrO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBhaUluZGV4LnB1c2goLTEpO1xuICAgICAgICAgICAgICAgIGlmIChmaWVsZC5sb2NhbE5hbWUgPT09ICdpbnB1dCcgJiYgck5vbkF1dG9OdW1lcmljVHlwZXMudGVzdChmaWVsZC50eXBlKSkge1xuICAgICAgICAgICAgICAgICAgICBjb3VudCsrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKGdldEFycmF5QmVoYXZpb3IpIHtcbiAgICAgICAgICAgIGNvbnN0IGZvcm1GaWVsZHMgPSAkdGhpcy5zZXJpYWxpemVBcnJheSgpO1xuXG4gICAgICAgICAgICAkLmVhY2goZm9ybUZpZWxkcywgKGksIGZpZWxkKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2NFbGVtZW50ID0gc2NJbmRleC5pbmRleE9mKGkpO1xuXG4gICAgICAgICAgICAgICAgaWYgKHNjRWxlbWVudCA+IC0xICYmIGFpSW5kZXhbc2NFbGVtZW50XSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRlc3RJbnB1dCA9ICQoYGZvcm06ZXEoJHtmb3JtSW5kZXh9KSBpbnB1dDplcSgke2FpSW5kZXhbc2NFbGVtZW50XX0pYCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNldHRpbmdzID0gdGVzdElucHV0LmRhdGEoJ2F1dG9OdW1lcmljJyk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBzZXR0aW5ncyA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpZWxkLnZhbHVlID0gdGVzdElucHV0LmF1dG9OdW1lcmljKCdnZXRMb2NhbGl6ZWQnKS50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHJldHVybiBmb3JtRmllbGRzO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gZ2V0U3RyaW5nKCkgYmVoYXZpb3JcbiAgICAgICAgICAgIGNvbnN0IGZvcm1GaWVsZHMgPSAkdGhpcy5zZXJpYWxpemUoKTtcbiAgICAgICAgICAgIGNvbnN0IGZvcm1QYXJ0cyA9IGZvcm1GaWVsZHMuc3BsaXQoJyYnKTtcblxuICAgICAgICAgICAgJC5lYWNoKGZvcm1QYXJ0cywgaSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgW2lucHV0TmFtZSwgaW5wdXRWYWx1ZV0gPSBmb3JtUGFydHNbaV0uc3BsaXQoJz0nKTtcbiAgICAgICAgICAgICAgICBjb25zdCBzY0VsZW1lbnQgPSBzY0luZGV4LmluZGV4T2YoaSk7XG5cbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgY3VycmVudCBlbGVtZW50IGlzIGEgdmFsaWQgZWxlbWVudFxuICAgICAgICAgICAgICAgIGlmIChzY0VsZW1lbnQgPiAtMSAmJiBhaUluZGV4W3NjRWxlbWVudF0gPiAtMSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB0ZXN0SW5wdXQgPSAkKGBmb3JtOmVxKCR7Zm9ybUluZGV4fSkgaW5wdXQ6ZXEoJHthaUluZGV4W3NjRWxlbWVudF19KWApO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzZXR0aW5ncyA9IHRlc3RJbnB1dC5kYXRhKCdhdXRvTnVtZXJpYycpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygc2V0dGluZ3MgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5wdXRWYWx1ZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG1vZGlmaWVkSW5wdXRWYWx1ZSA9IHRlc3RJbnB1dC5hdXRvTnVtZXJpYygnZ2V0TG9jYWxpemVkJykudG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3JtUGFydHNbaV0gPSBgJHtpbnB1dE5hbWV9PSR7bW9kaWZpZWRJbnB1dFZhbHVlfWA7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcmV0dXJuIGZvcm1QYXJ0cy5qb2luKCcmJyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBIYW5kbGVyIGZvciAnZm9jdXNpbicgZXZlbnRzXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gJHRoaXMgalF1ZXJ5LXNlbGVjdGVkIERPTSBlbGVtZW50XG4gICAgICogQHBhcmFtIHtBdXRvTnVtZXJpY0hvbGRlcn0gaG9sZGVyXG4gICAgICogQHBhcmFtIHtFdmVudH0gZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG9uRm9jdXNJbkFuZE1vdXNlRW50ZXIoJHRoaXMsIGhvbGRlciwgZSkge1xuICAgICAgICBjb25zdCBzZXR0aW5ncyA9IGhvbGRlci5zZXR0aW5nc0Nsb25lO1xuXG4gICAgICAgIGlmIChlLnR5cGUgPT09ICdmb2N1c2luJyB8fCBlLnR5cGUgPT09ICdtb3VzZWVudGVyJyAmJiAhJHRoaXMuaXMoJzpmb2N1cycpICYmIHNldHRpbmdzLmVtcHR5SW5wdXRCZWhhdmlvciA9PT0gJ2ZvY3VzJykge1xuICAgICAgICAgICAgc2V0dGluZ3MuaGFzRm9jdXMgPSB0cnVlO1xuXG4gICAgICAgICAgICBpZiAoc2V0dGluZ3MubmVnYXRpdmVCcmFja2V0c1R5cGVPbkJsdXIgIT09IG51bGwgJiYgc2V0dGluZ3MubmVnYXRpdmVTaWduQ2hhcmFjdGVyICE9PSAnJykge1xuICAgICAgICAgICAgICAgICR0aGlzLnZhbCh0b2dnbGVOZWdhdGl2ZUJyYWNrZXQoZS50YXJnZXQudmFsdWUsIHNldHRpbmdzKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGNsZWFuIHRoZSB2YWx1ZSB0byBjb21wYXJlIHRvIHJhd1ZhbHVlXG4gICAgICAgICAgICBsZXQgcmVzdWx0ID0gc3RyaXBBbGxOb25OdW1iZXJDaGFyYWN0ZXJzKGUudGFyZ2V0LnZhbHVlLCBzZXR0aW5ncywgdHJ1ZSk7XG4gICAgICAgICAgICByZXN1bHQgPSBjb252ZXJ0VG9OdW1lcmljU3RyaW5nKHJlc3VsdCwgc2V0dGluZ3MpO1xuICAgICAgICAgICAgcmVzdWx0ID0gY2xlYW5MZWFkaW5nVHJhaWxpbmdaZXJvcyhyZXN1bHQsIHNldHRpbmdzKTtcbiAgICAgICAgICAgIGlmIChzZXR0aW5ncy50cmFpbGluZ05lZ2F0aXZlKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gJy0nICsgcmVzdWx0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsZXQgcm91bmRlZFZhbHVlO1xuICAgICAgICAgICAgaWYgKHNldHRpbmdzLmRlY2ltYWxQbGFjZXNTaG93bk9uRm9jdXMpIHtcbiAgICAgICAgICAgICAgICBzZXR0aW5ncy5kZWNpbWFsUGxhY2VzT3ZlcnJpZGUgPSBzZXR0aW5ncy5kZWNpbWFsUGxhY2VzU2hvd25PbkZvY3VzO1xuICAgICAgICAgICAgICAgIHJvdW5kZWRWYWx1ZSA9IHJvdW5kVmFsdWUoc2V0dGluZ3MucmF3VmFsdWUsIHNldHRpbmdzKTtcbiAgICAgICAgICAgICAgICAkdGhpcy52YWwoYWRkR3JvdXBTZXBhcmF0b3JzKHJvdW5kZWRWYWx1ZSwgc2V0dGluZ3MpKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc2V0dGluZ3Muc2NhbGVEaXZpc29yKSB7XG4gICAgICAgICAgICAgICAgc2V0dGluZ3MuZGVjaW1hbFBsYWNlc092ZXJyaWRlID0gTnVtYmVyKHNldHRpbmdzLm9EZWMpO1xuICAgICAgICAgICAgICAgIHJvdW5kZWRWYWx1ZSA9IHJvdW5kVmFsdWUoc2V0dGluZ3MucmF3VmFsdWUsIHNldHRpbmdzKTtcbiAgICAgICAgICAgICAgICAkdGhpcy52YWwoYWRkR3JvdXBTZXBhcmF0b3JzKHJvdW5kZWRWYWx1ZSwgc2V0dGluZ3MpKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc2V0dGluZ3Mubm9TZXBhcmF0b3JPbkZvY3VzKSB7XG4gICAgICAgICAgICAgICAgc2V0dGluZ3MuZGlnaXRHcm91cFNlcGFyYXRvciA9ICcnO1xuICAgICAgICAgICAgICAgIHNldHRpbmdzLmN1cnJlbmN5U3ltYm9sID0gJyc7XG4gICAgICAgICAgICAgICAgc2V0dGluZ3Muc3VmZml4VGV4dCA9ICcnO1xuICAgICAgICAgICAgICAgIHJvdW5kZWRWYWx1ZSA9IHJvdW5kVmFsdWUoc2V0dGluZ3MucmF3VmFsdWUsIHNldHRpbmdzKTtcbiAgICAgICAgICAgICAgICAkdGhpcy52YWwoYWRkR3JvdXBTZXBhcmF0b3JzKHJvdW5kZWRWYWx1ZSwgc2V0dGluZ3MpKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocmVzdWx0ICE9PSBzZXR0aW5ncy5yYXdWYWx1ZSkge1xuICAgICAgICAgICAgICAgIC8vIHVwZGF0ZXMgdGhlIHJhd1ZhbHVlXG4gICAgICAgICAgICAgICAgJHRoaXMuYXV0b051bWVyaWMoJ3NldCcsIHJlc3VsdCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEluIG9yZGVyIHRvIHNlbmQgYSAnbmF0aXZlJyBjaGFuZ2UgZXZlbnQgd2hlbiBibHVycmluZyB0aGUgaW5wdXQsIHdlIG5lZWQgdG8gZmlyc3Qgc3RvcmUgdGhlIGluaXRpYWwgaW5wdXQgdmFsdWUgb24gZm9jdXMuXG4gICAgICAgICAgICBob2xkZXIudmFsdWVPbkZvY3VzID0gZS50YXJnZXQudmFsdWU7XG4gICAgICAgICAgICBob2xkZXIubGFzdFZhbCA9IGhvbGRlci52YWx1ZU9uRm9jdXM7XG4gICAgICAgICAgICBjb25zdCBvbkVtcHR5ID0gY2hlY2tFbXB0eShob2xkZXIudmFsdWVPbkZvY3VzLCBzZXR0aW5ncywgdHJ1ZSk7XG4gICAgICAgICAgICBpZiAoKG9uRW1wdHkgIT09IG51bGwgJiYgb25FbXB0eSAhPT0gJycpICYmIHNldHRpbmdzLmVtcHR5SW5wdXRCZWhhdmlvciA9PT0gJ2ZvY3VzJykge1xuICAgICAgICAgICAgICAgICR0aGlzLnZhbChvbkVtcHR5KTtcbiAgICAgICAgICAgICAgICBpZiAob25FbXB0eSA9PT0gc2V0dGluZ3MuY3VycmVuY3lTeW1ib2wgJiYgc2V0dGluZ3MuY3VycmVuY3lTeW1ib2xQbGFjZW1lbnQgPT09ICdzJykge1xuICAgICAgICAgICAgICAgICAgICBzZXRFbGVtZW50U2VsZWN0aW9uKGUudGFyZ2V0LCAwLCAwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBIYW5kbGVyIGZvciAna2V5ZG93bicgZXZlbnRzLlxuICAgICAqIFRoZSB1c2VyIGp1c3Qgc3RhcnRlZCBwdXNoaW5nIGFueSBrZXksIGhlbmNlIG9uZSBldmVudCBpcyBzZW50LlxuICAgICAqXG4gICAgICogTm90ZSA6XG4gICAgICogQnkgZGVmYXVsdCBhICdub3JtYWwnIGlucHV0IG91dHB1dCB0aG9zZSBldmVudHMgaW4gdGhlIHJpZ2h0IG9yZGVyIHdoZW4gaW5wdXR0aW5nIGEgY2hhcmFjdGVyIGtleSAoaWUuICdhJykgOlxuICAgICAqIC0ga2V5ZG93blxuICAgICAqIC0ga2V5cHJlc3NcbiAgICAgKiAtIGlucHV0XG4gICAgICogLSBrZXl1cFxuICAgICAqXG4gICAgICogLi4ud2hlbiBpbnB1dHRpbmcgYSBtb2RpZmllciBrZXkgKGllLiAnY3RybCcpIDpcbiAgICAgKiAtIGtleWRvd25cbiAgICAgKiAtIGtleXVwXG4gICAgICpcbiAgICAgKiBJZiAnZGVsZXRlJyBvciAnYmFja3NwYWNlJyBpcyBlbnRlcmVkLCB0aGUgZm9sbG93aW5nIGV2ZW50cyBhcmUgc2VudCA6XG4gICAgICogLSBrZXlkb3duXG4gICAgICogLSBpbnB1dFxuICAgICAqIC0ga2V5dXBcbiAgICAgKlxuICAgICAqIElmICdlbnRlcicgaXMgZW50ZXJlZCBhbmQgdGhlIHZhbHVlIGhhcyBub3QgY2hhbmdlZCwgdGhlIGZvbGxvd2luZyBldmVudHMgYXJlIHNlbnQgOlxuICAgICAqIC0ga2V5ZG93blxuICAgICAqIC0ga2V5cHJlc3NcbiAgICAgKiAtIGtleXVwXG4gICAgICpcbiAgICAgKiBJZiAnZW50ZXInIGlzIGVudGVyZWQgYW5kIHRoZSB2YWx1ZSBoYXMgYmVlbiBjaGFuZ2VkLCB0aGUgZm9sbG93aW5nIGV2ZW50cyBhcmUgc2VudCA6XG4gICAgICogLSBrZXlkb3duXG4gICAgICogLSBrZXlwcmVzc1xuICAgICAqIC0gY2hhbmdlXG4gICAgICogLSBrZXl1cFxuICAgICAqXG4gICAgICogV2hlbiBhIHBhc3RlIGlzIGRvbmUsIHRoZSBmb2xsb3dpbmcgZXZlbnRzIGFyZSBzZW50IDpcbiAgICAgKiAtIGlucHV0IChpZiBwYXN0ZSBpcyBkb25lIHdpdGggdGhlIG1vdXNlKVxuICAgICAqXG4gICAgICogLSBrZXlkb3duIChpZiBwYXN0ZSBpcyBkb25lIHdpdGggY3RybCt2KVxuICAgICAqIC0ga2V5ZG93blxuICAgICAqIC0gaW5wdXRcbiAgICAgKiAtIGtleXVwXG4gICAgICogLSBrZXl1cFxuICAgICAqXG4gICAgICogQHBhcmFtIHtBdXRvTnVtZXJpY0hvbGRlcn0gaG9sZGVyXG4gICAgICogQHBhcmFtIHtFdmVudH0gZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG9uS2V5ZG93bihob2xkZXIsIGUpIHtcbiAgICAgICAgLy9UT0RPIENyZWF0ZSBhIGZ1bmN0aW9uIHRoYXQgcmV0cmlldmUgdGhlIGVsZW1lbnQgdmFsdWUgKGVpdGhlciBieSB1c2luZyBgZS50YXJnZXQudmFsdWVgIHdoZW4gdGhlIGVsZW1lbnQgaXMgYW4gPGlucHV0Piwgb3IgYnkgdXNpbmcgYGVsZW1lbnQudGV4dENvbnRlbnRgIHdoZW4gdGhlIGVsZW1lbnQgYXMgaXRzIGBjb250ZW50ZWRpdGFibGVgIHNldCB0byB0cnVlKVxuICAgICAgICBob2xkZXIuX3VwZGF0ZUF1dG9OdW1lcmljSG9sZGVyRXZlbnRLZXljb2RlKGUpO1xuICAgICAgICBob2xkZXIuaW5pdGlhbFZhbHVlT25LZXlkb3duID0gZS50YXJnZXQudmFsdWU7IC8vIFRoaXMgaXMgbmVlZGVkIGluIGBvbktleXVwKClgIHRvIGNoZWNrIGlmIHRoZSB2YWx1ZSBhcyBjaGFuZ2VkIGR1cmluZyB0aGUga2V5IHByZXNzXG5cbiAgICAgICAgaWYgKGhvbGRlci50aGF0LnJlYWRPbmx5KSB7XG4gICAgICAgICAgICBob2xkZXIucHJvY2Vzc2VkID0gdHJ1ZTtcblxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVGhlIFwiZW50ZXJcIiBrZXkgdGhyb3dzIGEgYGNoYW5nZWAgZXZlbnQgaWYgdGhlIHZhbHVlIGhhcyBjaGFuZ2VkIHNpbmNlIHRoZSBgZm9jdXNgIGV2ZW50XG4gICAgICAgIGlmIChob2xkZXIuZXZlbnRLZXlDb2RlID09PSBrZXlDb2RlLkVudGVyICYmIGhvbGRlci52YWx1ZU9uRm9jdXMgIT09IGUudGFyZ2V0LnZhbHVlKSB7XG4gICAgICAgICAgICB0cmlnZ2VyRXZlbnQoJ2NoYW5nZScsIGUudGFyZ2V0KTtcbiAgICAgICAgICAgIGhvbGRlci52YWx1ZU9uRm9jdXMgPSBlLnRhcmdldC52YWx1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGhvbGRlci5fdXBkYXRlQXV0b051bWVyaWNIb2xkZXJQcm9wZXJ0aWVzKGUpO1xuXG4gICAgICAgIGlmIChob2xkZXIuX3NraXBBbHdheXMoZSkpIHtcbiAgICAgICAgICAgIGhvbGRlci5wcm9jZXNzZWQgPSB0cnVlO1xuXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDaGVjayBpZiB0aGUga2V5IGlzIGEgZGVsZXRlL2JhY2tzcGFjZSBrZXlcbiAgICAgICAgaWYgKGhvbGRlci5ldmVudEtleUNvZGUgPT09IGtleUNvZGUuQmFja3NwYWNlIHx8IGhvbGRlci5ldmVudEtleUNvZGUgPT09IGtleUNvZGUuRGVsZXRlKSB7XG4gICAgICAgICAgICBob2xkZXIuX3Byb2Nlc3NDaGFyYWN0ZXJEZWxldGlvbigpOyAvLyBCZWNhdXNlIGJhY2tzcGFjZSBhbmQgZGVsZXRlIG9ubHkgdHJpZ2dlcnMga2V5ZG93biBhbmQga2V5dXAgZXZlbnRzLCBub3Qga2V5cHJlc3NcbiAgICAgICAgICAgIGhvbGRlci5wcm9jZXNzZWQgPSB0cnVlO1xuICAgICAgICAgICAgaG9sZGVyLl9mb3JtYXRWYWx1ZShlKTtcblxuICAgICAgICAgICAgLy8gSWYgYW5kIG9ubHkgaWYgdGhlIHJlc3VsdGluZyB2YWx1ZSBoYXMgY2hhbmdlZCBhZnRlciB0aGF0IGJhY2tzcGFjZS9kZWxldGUsIHRoZW4gd2UgaGF2ZSB0byBzZW5kIGFuICdpbnB1dCcgZXZlbnQgbGlrZSBicm93c2VycyBub3JtYWxseSBkby5cbiAgICAgICAgICAgIGlmICgoZS50YXJnZXQudmFsdWUgIT09IGhvbGRlci5sYXN0VmFsKSAmJiBob2xkZXIuc2V0dGluZ3NDbG9uZS50aHJvd0lucHV0KSB7XG4gICAgICAgICAgICAgICAgLy8gVGhyb3cgYW4gaW5wdXQgZXZlbnQgd2hlbiBhIGNoYXJhY3RlciBkZWxldGlvbiBpcyBkZXRlY3RlZFxuICAgICAgICAgICAgICAgIHRyaWdnZXJFdmVudCgnaW5wdXQnLCBlLnRhcmdldCk7XG4gICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpOyAvLyAuLi5hbmQgaW1tZWRpYXRlbHkgcHJldmVudCB0aGUgYnJvd3NlciB0byBkZWxldGUgYSBzZWNvbmQgY2hhcmFjdGVyXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGhvbGRlci5sYXN0VmFsID0gZS50YXJnZXQudmFsdWU7XG4gICAgICAgICAgICBob2xkZXIuc2V0dGluZ3NDbG9uZS50aHJvd0lucHV0ID0gdHJ1ZTtcblxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaG9sZGVyLmZvcm1hdHRlZCA9IGZhbHNlOyAvL1RPRE8gSXMgdGhpcyBsaW5lIG5lZWRlZD9cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBIYW5kbGVyIGZvciAna2V5cHJlc3MnIGV2ZW50cy5cbiAgICAgKiBUaGUgdXNlciBpcyBzdGlsbCBwcmVzc2luZyB0aGUga2V5LCB3aGljaCB3aWxsIG91dHB1dCBhIGNoYXJhY3RlciAoaWUuICcyJykgY29udGludW91c2x5IHVudGlsIGl0IHJlbGVhc2VzIHRoZSBrZXkuXG4gICAgICogTm90ZTogJ2tleXByZXNzJyBldmVudHMgYXJlIG5vdCBzZW50IGZvciBkZWxldGUga2V5cyBsaWtlIEJhY2tzcGFjZS9EZWxldGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0F1dG9OdW1lcmljSG9sZGVyfSBob2xkZXJcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBlXG4gICAgICovXG4gICAgZnVuY3Rpb24gb25LZXlwcmVzcyhob2xkZXIsIGUpIHtcbiAgICAgICAgLy8gUmV0cmlldmUgdGhlIHJlYWwgY2hhcmFjdGVyIHRoYXQgaGFzIGJlZW4gZW50ZXJlZCAoaWUuICdhJyBpbnN0ZWFkIG9mIHRoZSBrZXkgY29kZSlcbiAgICAgICAgY29uc3QgZXZlbnRDaGFyYWN0ZXIgPSBjaGFyYWN0ZXIoZSk7XG5cbiAgICAgICAgLy8gRmlyZWZveCBnZW5lcmF0ZSBhICdrZXlwcmVzcycgZXZlbnQgKGUua2V5Q29kZSA9PT0gMCkgZm9yIHRoZSBrZXlzIHRoYXQgZG8gbm90IHByaW50IGEgY2hhcmFjdGVyIChpZS4gJ0luc2VydCcsICdEZWxldGUnLCAnRm4nIGtleXMsICdQYWdlVXAnLCAnUGFnZURvd24nIGV0Yy4pLiAnU2hpZnQnIG9uIHRoZSBvdGhlciBoYW5kIGRvZXMgbm90IGdlbmVyYXRlIGEga2V5cHJlc3MgZXZlbnQuXG4gICAgICAgIGlmIChldmVudENoYXJhY3RlciA9PT0ga2V5TmFtZS5JbnNlcnQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHByb2Nlc3NlZCA9IGhvbGRlci5wcm9jZXNzZWQ7XG4gICAgICAgIGhvbGRlci5fdXBkYXRlQXV0b051bWVyaWNIb2xkZXJQcm9wZXJ0aWVzKGUpO1xuXG4gICAgICAgIGlmIChob2xkZXIuX3NraXBBbHdheXMoZSkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwcm9jZXNzZWQpIHtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgaXNDaGFyYWN0ZXJJbnNlcnRpb25BbGxvd2VkID0gaG9sZGVyLl9wcm9jZXNzQ2hhcmFjdGVySW5zZXJ0aW9uKGUpO1xuICAgICAgICBpZiAoaXNDaGFyYWN0ZXJJbnNlcnRpb25BbGxvd2VkKSB7XG4gICAgICAgICAgICBob2xkZXIuX2Zvcm1hdFZhbHVlKGUpO1xuICAgICAgICAgICAgaWYgKChlLnRhcmdldC52YWx1ZSAhPT0gaG9sZGVyLmxhc3RWYWwpICYmIGhvbGRlci5zZXR0aW5nc0Nsb25lLnRocm93SW5wdXQpIHtcbiAgICAgICAgICAgICAgICAvLyBUaHJvd3MgaW5wdXQgZXZlbnQgb24gYWRkaW5nIGEgY2hhcmFjdGVyXG4gICAgICAgICAgICAgICAgdHJpZ2dlckV2ZW50KCdpbnB1dCcsIGUudGFyZ2V0KTtcbiAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7IC8vIC4uLmFuZCBpbW1lZGlhdGVseSBwcmV2ZW50IHRoZSBicm93c2VyIHRvIGFkZCBhIHNlY29uZCBjaGFyYWN0ZXJcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICgoZXZlbnRDaGFyYWN0ZXIgPT09IGhvbGRlci5zZXR0aW5ncy5kZWNpbWFsQ2hhcmFjdGVyIHx8IGV2ZW50Q2hhcmFjdGVyID09PSBob2xkZXIuc2V0dGluZ3MuZGVjaW1hbENoYXJhY3RlckFsdGVybmF0aXZlKSAmJlxuICAgICAgICAgICAgICAgICAgICAoZ2V0RWxlbWVudFNlbGVjdGlvbihlLnRhcmdldCkuc3RhcnQgPT09IGdldEVsZW1lbnRTZWxlY3Rpb24oZS50YXJnZXQpLmVuZCkgJiZcbiAgICAgICAgICAgICAgICAgICAgZ2V0RWxlbWVudFNlbGVjdGlvbihlLnRhcmdldCkuc3RhcnQgPT09IGUudGFyZ2V0LnZhbHVlLmluZGV4T2YoaG9sZGVyLnNldHRpbmdzLmRlY2ltYWxDaGFyYWN0ZXIpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHBvc2l0aW9uID0gZ2V0RWxlbWVudFNlbGVjdGlvbihlLnRhcmdldCkuc3RhcnQgKyAxO1xuICAgICAgICAgICAgICAgICAgICBzZXRFbGVtZW50U2VsZWN0aW9uKGUudGFyZ2V0LCBwb3NpdGlvbiwgcG9zaXRpb24pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGhvbGRlci5sYXN0VmFsID0gZS50YXJnZXQudmFsdWU7XG4gICAgICAgICAgICBob2xkZXIuc2V0dGluZ3NDbG9uZS50aHJvd0lucHV0ID0gdHJ1ZTtcblxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAgIGhvbGRlci5mb3JtYXR0ZWQgPSBmYWxzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBIYW5kbGVyIGZvciAna2V5dXAnIGV2ZW50cy5cbiAgICAgKiBUaGUgdXNlciBqdXN0IHJlbGVhc2VkIGFueSBrZXksIGhlbmNlIG9uZSBldmVudCBpcyBzZW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtBdXRvTnVtZXJpY0hvbGRlcn0gaG9sZGVyXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHNldHRpbmdzXG4gICAgICogQHBhcmFtIHtFdmVudH0gZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG9uS2V5dXAoaG9sZGVyLCBzZXR0aW5ncywgZSkge1xuICAgICAgICBob2xkZXIuX3VwZGF0ZUF1dG9OdW1lcmljSG9sZGVyUHJvcGVydGllcyhlKTtcblxuICAgICAgICBjb25zdCBza2lwID0gaG9sZGVyLl9za2lwQWx3YXlzKGUpO1xuICAgICAgICBkZWxldGUgaG9sZGVyLnZhbHVlUGFydHNCZWZvcmVQYXN0ZTtcbiAgICAgICAgaWYgKHNraXAgfHwgZS50YXJnZXQudmFsdWUgPT09ICcnKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBBZGRlZCB0byBwcm9wZXJseSBwbGFjZSB0aGUgY2FyZXQgd2hlbiBvbmx5IHRoZSBjdXJyZW5jeSBzaWduIGlzIHByZXNlbnRcbiAgICAgICAgaWYgKGUudGFyZ2V0LnZhbHVlID09PSBob2xkZXIuc2V0dGluZ3NDbG9uZS5jdXJyZW5jeVN5bWJvbCkge1xuICAgICAgICAgICAgaWYgKGhvbGRlci5zZXR0aW5nc0Nsb25lLmN1cnJlbmN5U3ltYm9sUGxhY2VtZW50ID09PSAncycpIHtcbiAgICAgICAgICAgICAgICBzZXRFbGVtZW50U2VsZWN0aW9uKGUudGFyZ2V0LCAwLCAwKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc2V0RWxlbWVudFNlbGVjdGlvbihlLnRhcmdldCwgaG9sZGVyLnNldHRpbmdzQ2xvbmUuY3VycmVuY3lTeW1ib2wubGVuZ3RoLCBob2xkZXIuc2V0dGluZ3NDbG9uZS5jdXJyZW5jeVN5bWJvbC5sZW5ndGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGhvbGRlci5ldmVudEtleUNvZGUgPT09IGtleUNvZGUuVGFiKSB7XG4gICAgICAgICAgICBzZXRFbGVtZW50U2VsZWN0aW9uKGUudGFyZ2V0LCAwLCBlLnRhcmdldC52YWx1ZS5sZW5ndGgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKChlLnRhcmdldC52YWx1ZSA9PT0gaG9sZGVyLnNldHRpbmdzQ2xvbmUuc3VmZml4VGV4dCkgfHxcbiAgICAgICAgICAgIChob2xkZXIuc2V0dGluZ3NDbG9uZS5yYXdWYWx1ZSA9PT0gJycgJiYgaG9sZGVyLnNldHRpbmdzQ2xvbmUuY3VycmVuY3lTeW1ib2wgIT09ICcnICYmIGhvbGRlci5zZXR0aW5nc0Nsb25lLnN1ZmZpeFRleHQgIT09ICcnKSkge1xuICAgICAgICAgICAgc2V0RWxlbWVudFNlbGVjdGlvbihlLnRhcmdldCwgMCwgMCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTYXZlcyB0aGUgZXh0ZW5kZWQgZGVjaW1hbCB0byBwcmVzZXJ2ZSB0aGUgZGF0YSB3aGVuIG5hdmlnYXRpbmcgYXdheSBmcm9tIHRoZSBwYWdlXG4gICAgICAgIGlmIChob2xkZXIuc2V0dGluZ3NDbG9uZS5kZWNpbWFsUGxhY2VzU2hvd25PbkZvY3VzICE9PSBudWxsICYmIGhvbGRlci5zZXR0aW5nc0Nsb25lLnNhdmVWYWx1ZVRvU2Vzc2lvblN0b3JhZ2UpIHtcbiAgICAgICAgICAgIHNhdmVWYWx1ZVRvUGVyc2lzdGVudFN0b3JhZ2UoZS50YXJnZXQsIHNldHRpbmdzLCAnc2V0Jyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWhvbGRlci5mb3JtYXR0ZWQpIHtcbiAgICAgICAgICAgIGhvbGRlci5fZm9ybWF0VmFsdWUoZSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZiB0aGUgaW5wdXQgdmFsdWUgaGFzIGNoYW5nZWQgZHVyaW5nIHRoZSBrZXkgcHJlc3MgZXZlbnQgY2hhaW4sIGFuIGV2ZW50IGlzIHNlbnQgdG8gYWxlcnQgdGhhdCBhIGZvcm1hdHRpbmcgaGFzIGJlZW4gZG9uZSAoY2YuIElzc3VlICMxODcpXG4gICAgICAgIGlmIChlLnRhcmdldC52YWx1ZSAhPT0gaG9sZGVyLmluaXRpYWxWYWx1ZU9uS2V5ZG93bikge1xuICAgICAgICAgICAgdHJpZ2dlckV2ZW50KCdhdXRvTnVtZXJpYzpmb3JtYXR0ZWQnLCBlLnRhcmdldCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBIYW5kbGVyIGZvciAnZm9jdXNvdXQnIGV2ZW50c1xuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9ICR0aGlzIGpRdWVyeS1zZWxlY3RlZCBET00gZWxlbWVudFxuICAgICAqIEBwYXJhbSB7QXV0b051bWVyaWNIb2xkZXJ9IGhvbGRlclxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBvbkZvY3VzT3V0QW5kTW91c2VMZWF2ZSgkdGhpcywgaG9sZGVyLCBlKSB7XG4gICAgICAgIGlmICghJHRoaXMuaXMoJzpmb2N1cycpKSB7XG4gICAgICAgICAgICBsZXQgdmFsdWUgPSBlLnRhcmdldC52YWx1ZTtcbiAgICAgICAgICAgIGNvbnN0IG9yaWdWYWx1ZSA9IHZhbHVlO1xuICAgICAgICAgICAgY29uc3Qgc2V0dGluZ3MgPSBob2xkZXIuc2V0dGluZ3NDbG9uZTtcbiAgICAgICAgICAgIHNldHRpbmdzLmhhc0ZvY3VzID0gZmFsc2U7XG5cbiAgICAgICAgICAgIGlmIChzZXR0aW5ncy5zYXZlVmFsdWVUb1Nlc3Npb25TdG9yYWdlKSB7XG4gICAgICAgICAgICAgICAgc2F2ZVZhbHVlVG9QZXJzaXN0ZW50U3RvcmFnZShlLnRhcmdldCwgc2V0dGluZ3MsICdzZXQnKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHNldHRpbmdzLm5vU2VwYXJhdG9yT25Gb2N1cyA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIHNldHRpbmdzLmRpZ2l0R3JvdXBTZXBhcmF0b3IgPSBzZXR0aW5ncy5vU2VwO1xuICAgICAgICAgICAgICAgIHNldHRpbmdzLmN1cnJlbmN5U3ltYm9sID0gc2V0dGluZ3Mub1NpZ247XG4gICAgICAgICAgICAgICAgc2V0dGluZ3Muc3VmZml4VGV4dCA9IHNldHRpbmdzLm9TdWZmaXg7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChzZXR0aW5ncy5kZWNpbWFsUGxhY2VzU2hvd25PbkZvY3VzICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgc2V0dGluZ3MuZGVjaW1hbFBsYWNlc092ZXJyaWRlID0gc2V0dGluZ3Mub0RlYztcbiAgICAgICAgICAgICAgICBzZXR0aW5ncy5hbGxvd0RlY2ltYWxQYWRkaW5nID0gc2V0dGluZ3Mub1BhZDtcbiAgICAgICAgICAgICAgICBzZXR0aW5ncy5uZWdhdGl2ZUJyYWNrZXRzVHlwZU9uQmx1ciA9IHNldHRpbmdzLm9CcmFja2V0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YWx1ZSA9IHN0cmlwQWxsTm9uTnVtYmVyQ2hhcmFjdGVycyh2YWx1ZSwgc2V0dGluZ3MsIHRydWUpO1xuXG4gICAgICAgICAgICBpZiAodmFsdWUgIT09ICcnKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNldHRpbmdzLnRyYWlsaW5nTmVnYXRpdmUgJiYgIWlzTmVnYXRpdmUodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gJy0nICsgdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIHNldHRpbmdzLnRyYWlsaW5nTmVnYXRpdmUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjb25zdCBbbWluVGVzdCwgbWF4VGVzdF0gPSBjaGVja0lmSW5SYW5nZVdpdGhPdmVycmlkZU9wdGlvbih2YWx1ZSwgc2V0dGluZ3MpO1xuICAgICAgICAgICAgICAgIGlmIChjaGVja0VtcHR5KHZhbHVlLCBzZXR0aW5ncywgZmFsc2UpID09PSBudWxsICYmIG1pblRlc3QgJiYgbWF4VGVzdCkge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IG1vZGlmeU5lZ2F0aXZlU2lnbkFuZERlY2ltYWxDaGFyYWN0ZXJGb3JSYXdWYWx1ZSh2YWx1ZSwgc2V0dGluZ3MpO1xuICAgICAgICAgICAgICAgICAgICBzZXR0aW5ncy5yYXdWYWx1ZSA9IGNsZWFuTGVhZGluZ1RyYWlsaW5nWmVyb3ModmFsdWUsIHNldHRpbmdzKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoc2V0dGluZ3Muc2NhbGVEaXZpc29yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlIC8gc2V0dGluZ3Muc2NhbGVEaXZpc29yO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3MuZGVjaW1hbFBsYWNlc092ZXJyaWRlID0gKHNldHRpbmdzLnNjYWxlRGl2aXNvciAmJiBzZXR0aW5ncy5zY2FsZURlY2ltYWxQbGFjZXMpID8gTnVtYmVyKHNldHRpbmdzLnNjYWxlRGVjaW1hbFBsYWNlcykgOiBzZXR0aW5ncy5kZWNpbWFsUGxhY2VzT3ZlcnJpZGU7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gcm91bmRWYWx1ZSh2YWx1ZSwgc2V0dGluZ3MpO1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IG1vZGlmeU5lZ2F0aXZlU2lnbkFuZERlY2ltYWxDaGFyYWN0ZXJGb3JGb3JtYXR0ZWRWYWx1ZSh2YWx1ZSwgc2V0dGluZ3MpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghbWluVGVzdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgJHRoaXMudHJpZ2dlcignYXV0b051bWVyaWM6bWluRXhjZWVkZWQnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoIW1heFRlc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICR0aGlzLnRyaWdnZXIoJ2F1dG9OdW1lcmljOm1heEV4Y2VlZGVkJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHNldHRpbmdzLnJhd1ZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHNldHRpbmdzLmVtcHR5SW5wdXRCZWhhdmlvciA9PT0gJ3plcm8nKSB7XG4gICAgICAgICAgICAgICAgICAgIHNldHRpbmdzLnJhd1ZhbHVlID0gJzAnO1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHJvdW5kVmFsdWUoJzAnLCBzZXR0aW5ncyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3MucmF3VmFsdWUgPSAnJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxldCBncm91cGVkVmFsdWUgPSBjaGVja0VtcHR5KHZhbHVlLCBzZXR0aW5ncywgZmFsc2UpO1xuICAgICAgICAgICAgaWYgKGdyb3VwZWRWYWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGdyb3VwZWRWYWx1ZSA9IGFkZEdyb3VwU2VwYXJhdG9ycyh2YWx1ZSwgc2V0dGluZ3MpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZ3JvdXBlZFZhbHVlICE9PSBvcmlnVmFsdWUpIHtcbiAgICAgICAgICAgICAgICBncm91cGVkVmFsdWUgPSAoc2V0dGluZ3Muc2NhbGVTeW1ib2wpID8gZ3JvdXBlZFZhbHVlICsgc2V0dGluZ3Muc2NhbGVTeW1ib2wgOiBncm91cGVkVmFsdWU7XG4gICAgICAgICAgICAgICAgJHRoaXMudmFsKGdyb3VwZWRWYWx1ZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChncm91cGVkVmFsdWUgIT09IGhvbGRlci52YWx1ZU9uRm9jdXMpIHtcbiAgICAgICAgICAgICAgICAkdGhpcy5jaGFuZ2UoKTtcbiAgICAgICAgICAgICAgICBkZWxldGUgaG9sZGVyLnZhbHVlT25Gb2N1cztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEhhbmRsZXIgZm9yICdwYXN0ZScgZXZlbnRzXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gJHRoaXMgalF1ZXJ5LXNlbGVjdGVkIERPTSBlbGVtZW50XG4gICAgICogQHBhcmFtIHtBdXRvTnVtZXJpY0hvbGRlcn0gaG9sZGVyXG4gICAgICogQHBhcmFtIHtFdmVudH0gZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG9uUGFzdGUoJHRoaXMsIGhvbGRlciwgZSkge1xuICAgICAgICAvL1RPRE8gVXNpbmcgY3RybCt6IGFmdGVyIGEgcGFzdGUgc2hvdWxkIGNhbmNlbCBpdCAtPiBIb3cgd291bGQgdGhhdCBhZmZlY3Qgb3RoZXIgZnJhbWV3b3Jrcy9jb21wb25lbnQgYnVpbHQgd2l0aCB0aGF0IGZlYXR1cmUgaW4gbWluZCB0aG91Z2g/XG4gICAgICAgIC8vRklYTUUgV2hlbiBwYXN0aW5nICcwMDAnIG9uIGEgdGhvdXNhbmQgZ3JvdXAgc2VsZWN0aW9uLCB0aGUgd2hvbGUgc2VsZWN0aW9uIGdldHMgZGVsZXRlZCwgYW5kIG9ubHkgb25lICcwJyBpcyBwYXN0ZWQgKGNmLiBpc3N1ZSAjMzAyKVxuICAgICAgICAvLyBUaGUgZXZlbnQgaXMgcHJldmVudGVkIGJ5IGRlZmF1bHQsIHNpbmNlIG90aGVyd2lzZSB0aGUgdXNlciB3b3VsZCBiZSBhYmxlIHRvIHBhc3RlIGludmFsaWQgY2hhcmFjdGVycyBpbnRvIHRoZSBpbnB1dFxuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgbGV0IHJhd1Bhc3RlZFRleHQgPSBlLmNsaXBib2FyZERhdGEuZ2V0RGF0YSgndGV4dC9wbGFpbicpO1xuXG4gICAgICAgIC8vIDAuIFNwZWNpYWwgY2FzZSBpZiB0aGUgdXNlciBoYXMgc2VsZWN0ZWQgYWxsIHRoZSBpbnB1dCB0ZXh0IGJlZm9yZSBwYXN0aW5nXG4gICAgICAgIGNvbnN0IGluaXRpYWxGb3JtYXR0ZWRWYWx1ZSA9IGUudGFyZ2V0LnZhbHVlO1xuICAgICAgICBjb25zdCBzZWxlY3Rpb25TdGFydCA9IGUudGFyZ2V0LnNlbGVjdGlvblN0YXJ0IHx8IDA7XG4gICAgICAgIGNvbnN0IHNlbGVjdGlvbkVuZCA9IGUudGFyZ2V0LnNlbGVjdGlvbkVuZCB8fCAwO1xuICAgICAgICBjb25zdCBzZWxlY3Rpb25TaXplID0gc2VsZWN0aW9uRW5kIC0gc2VsZWN0aW9uU3RhcnQ7XG4gICAgICAgIGxldCBpc0FsbElucHV0VGV4dFNlbGVjdGVkID0gZmFsc2U7XG5cbiAgICAgICAgaWYgKHNlbGVjdGlvblNpemUgPT09IGluaXRpYWxGb3JtYXR0ZWRWYWx1ZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlzQWxsSW5wdXRUZXh0U2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gMS4gQ2hlY2sgaWYgdGhlIHBhc3RlIGhhcyBhIG5lZ2F0aXZlIHNpZ24gKG9ubHkgaWYgaXQncyB0aGUgZmlyc3QgY2hhcmFjdGVyKSwgYW5kIHN0b3JlIHRoYXQgaW5mb3JtYXRpb24gZm9yIGxhdGVyIHVzZVxuICAgICAgICBjb25zdCBpc1Bhc3RlTmVnYXRpdmUgPSBpc05lZ2F0aXZlU3RyaWN0KHJhd1Bhc3RlZFRleHQpO1xuICAgICAgICBpZiAoaXNQYXN0ZU5lZ2F0aXZlKSB7XG4gICAgICAgICAgICAvLyAxYS4gUmVtb3ZlIHRoZSBuZWdhdGl2ZSBzaWduIGZyb20gdGhlIHBhc3RlZCB0ZXh0XG4gICAgICAgICAgICByYXdQYXN0ZWRUZXh0ID0gcmF3UGFzdGVkVGV4dC5zbGljZSgxLCByYXdQYXN0ZWRUZXh0Lmxlbmd0aCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyAyLiBTdHJpcCBhbGwgdGhvdXNhbmQgc2VwYXJhdG9ycywgYnJhY2tldHMgYW5kIGN1cnJlbmN5IHNpZ24sIGFuZCBjb252ZXJ0IHRoZSBkZWNpbWFsIGNoYXJhY3RlciB0byBhIGRvdFxuICAgICAgICBjb25zdCB1bnRyYW5zbGF0ZWRQYXN0ZWRUZXh0ID0gcHJlcGFyZVBhc3RlZFRleHQocmF3UGFzdGVkVGV4dCwgaG9sZGVyKTtcblxuICAgICAgICBsZXQgcGFzdGVkVGV4dDtcbiAgICAgICAgaWYgKHVudHJhbnNsYXRlZFBhc3RlZFRleHQgPT09ICcuJykge1xuICAgICAgICAgICAgLy8gU3BlY2lhbCBjYXNlIDogSWYgdGhlIHVzZXIgdHJpZXMgdG8gcGFzdGUgYSBzaW5nbGUgZGVjaW1hbCBjaGFyYWN0ZXIgKHRoYXQgaGFzIGJlZW4gdHJhbnNsYXRlZCB0byAnLicgYWxyZWFkeSlcbiAgICAgICAgICAgIHBhc3RlZFRleHQgPSAnLic7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBOb3JtYWwgY2FzZVxuICAgICAgICAgICAgLy8gQWxsb3cgcGFzdGluZyBhcmFiaWMgbnVtYmVyc1xuICAgICAgICAgICAgcGFzdGVkVGV4dCA9IGFyYWJpY1RvTGF0aW5OdW1iZXJzKHVudHJhbnNsYXRlZFBhc3RlZFRleHQsIGZhbHNlLCBmYWxzZSwgZmFsc2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gMy4gVGVzdCBpZiB0aGUgcGFzdGUgaXMgdmFsaWQgKG9ubHkgaGFzIG51bWJlcnMgYW5kIGV2ZW50dWFsbHkgYSBkZWNpbWFsIGNoYXJhY3RlcikuIElmIGl0J3Mgbm90IHZhbGlkLCBzdG9wIGhlcmUuXG4gICAgICAgIGlmIChwYXN0ZWRUZXh0ICE9PSAnLicgJiYgKCFpc051bWJlcihwYXN0ZWRUZXh0KSB8fCBwYXN0ZWRUZXh0ID09PSAnJykpIHtcbiAgICAgICAgICAgIGlmIChob2xkZXIuc2V0dGluZ3Mub25JbnZhbGlkUGFzdGUgPT09ICdlcnJvcicpIHtcbiAgICAgICAgICAgICAgICAvL1RPRE8gU2hvdWxkIHdlIHNlbmQgYSB3YXJuaW5nIGluc3RlYWQgb2YgdGhyb3dpbmcgYW4gZXJyb3I/XG4gICAgICAgICAgICAgICAgdGhyb3dFcnJvcihgVGhlIHBhc3RlZCB2YWx1ZSAnJHtyYXdQYXN0ZWRUZXh0fScgaXMgbm90IGEgdmFsaWQgcGFzdGUgY29udGVudC5gKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gNC4gQ2FsY3VsYXRlIHRoZSBwYXN0ZSByZXN1bHRcbiAgICAgICAgbGV0IGNhcmV0UG9zaXRpb25PbkluaXRpYWxUZXh0QWZ0ZXJQYXN0aW5nO1xuICAgICAgICBsZXQgaW5pdGlhbFVuZm9ybWF0dGVkTnVtYmVyO1xuICAgICAgICBpZiAoZS50YXJnZXQudmFsdWUgPT09ICcnKSB7XG4gICAgICAgICAgICAvLyBhdXRvTnVtZXJpYyAnZ2V0JyByZXR1cm5zICcwLjAwJyBpZiB0aGUgaW5wdXQgaXMgZW1wdHksIGhlbmNlIHdlIG5lZWQgdG8gc3RvcmUgdGhlICdyZWFsJyBlbXB0eSBpbml0aWFsIHZhbHVlIHdoZW4gbmVlZGVkXG4gICAgICAgICAgICAvL0ZJWE1FIFRoaXMgaGFzIGJlZW4gZml4ZWQgaW4gYSBwcmV2aW91cyBjb21taXQsIGdldCBzaG91bGQgcmV0dXJuICcnIG9uIGFuIGVtcHR5IGlucHV0LiBSZW1vdmUgdGhpcyB1bm5lZWRlZCAnaWYnXG4gICAgICAgICAgICBpbml0aWFsVW5mb3JtYXR0ZWROdW1iZXIgPSAnJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGluaXRpYWxVbmZvcm1hdHRlZE51bWJlciA9ICR0aGlzLmF1dG9OdW1lcmljKCdnZXQnKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgaXNJbml0aWFsVmFsdWVOZWdhdGl2ZSA9IGlzTmVnYXRpdmVTdHJpY3QoaW5pdGlhbFVuZm9ybWF0dGVkTnVtYmVyKTtcbiAgICAgICAgbGV0IGlzUGFzdGVOZWdhdGl2ZUFuZEluaXRpYWxWYWx1ZUlzUG9zaXRpdmU7XG4gICAgICAgIGxldCByZXN1bHQ7XG5cbiAgICAgICAgLy8gSWYgdGhlIHBhc3RlZCBjb250ZW50IGlzIG5lZ2F0aXZlLCB0aGVuIHRoZSByZXN1bHQgd2lsbCBiZSBuZWdhdGl2ZSB0b29cbiAgICAgICAgaWYgKGlzUGFzdGVOZWdhdGl2ZSAmJiAhaXNJbml0aWFsVmFsdWVOZWdhdGl2ZSkge1xuICAgICAgICAgICAgaW5pdGlhbFVuZm9ybWF0dGVkTnVtYmVyID0gYC0ke2luaXRpYWxVbmZvcm1hdHRlZE51bWJlcn1gO1xuICAgICAgICAgICAgaXNJbml0aWFsVmFsdWVOZWdhdGl2ZSA9IHRydWU7XG4gICAgICAgICAgICBpc1Bhc3RlTmVnYXRpdmVBbmRJbml0aWFsVmFsdWVJc1Bvc2l0aXZlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlzUGFzdGVOZWdhdGl2ZUFuZEluaXRpYWxWYWx1ZUlzUG9zaXRpdmUgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBsZWZ0UGFydENvbnRhaW5lZEFEb3QgPSBmYWxzZTtcbiAgICAgICAgc3dpdGNoIChob2xkZXIuc2V0dGluZ3Mub25JbnZhbGlkUGFzdGUpIHtcbiAgICAgICAgICAgIC8qIDRhLiBUcnVuY2F0ZSBwYXN0ZSBiZWhhdmlvcjpcbiAgICAgICAgICAgICAqIEluc2VydCBhcyBtYW55IG51bWJlcnMgYXMgcG9zc2libGUgb24gdGhlIHJpZ2h0IGhhbmQgc2lkZSBvZiB0aGUgY2FyZXQgZnJvbSB0aGUgcGFzdGVkIHRleHQgY29udGVudCwgdW50aWwgdGhlIGlucHV0IHJlYWNoIGl0cyByYW5nZSBsaW1pdC5cbiAgICAgICAgICAgICAqIElmIHRoZXJlIGlzIG1vcmUgY2hhcmFjdGVycyBpbiB0aGUgY2xpcGJvYXJkIG9uY2UgYSBsaW1pdCBpcyByZWFjaGVkLCBkcm9wIHRoZSBleHRyYW5lb3VzIGNoYXJhY3RlcnMuXG4gICAgICAgICAgICAgKiBPdGhlcndpc2UgcGFzdGUgYWxsIHRoZSBudW1iZXJzIGluIHRoZSBjbGlwYm9hcmQuXG4gICAgICAgICAgICAgKiBXaGlsZSBkb2luZyBzbywgd2UgY2hlY2sgaWYgdGhlIHJlc3VsdCBpcyB3aXRoaW4gdGhlIG1pbmltdW0gYW5kIG1heGltdW0gdmFsdWVzIGFsbG93ZWQsIGFuZCBzdG9wIGFzIHNvb24gYXMgd2UgZW5jb3VudGVyIG9uZSBvZiB0aG9zZS5cbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiA0Yi4gUmVwbGFjZSBwYXN0ZSBiZWhhdmlvcjpcbiAgICAgICAgICAgICAqIElkZW0gdGhhbiB0aGUgJ3RydW5jYXRlJyBwYXN0ZSBiZWhhdmlvciwgZXhjZXB0IHRoYXQgd2hlbiBhIHJhbmdlIGxpbWl0IGlzIGhpdCwgd2UgdHJ5IHRvIHJlcGxhY2UgdGhlIHN1YnNlcXVlbnQgaW5pdGlhbCBudW1iZXJzIHdpdGggdGhlIHBhc3RlZCBvbmVzLCB1bnRpbCB3ZSBoaXQgdGhlIHJhbmdlIGxpbWl0IGEgc2Vjb25kIChhbmQgbGFzdCkgdGltZSwgb3Igd2UgcnVuIG91dCBvZiBudW1iZXJzIHRvIHBhc3RlXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIC8qIGVzbGludCBuby1jYXNlLWRlY2xhcmF0aW9uczogMCAqL1xuICAgICAgICAgICAgY2FzZSAndHJ1bmNhdGUnOlxuICAgICAgICAgICAgY2FzZSAncmVwbGFjZSc6XG4gICAgICAgICAgICAgICAgY29uc3QgbGVmdEZvcm1hdHRlZFBhcnQgPSBpbml0aWFsRm9ybWF0dGVkVmFsdWUuc2xpY2UoMCwgc2VsZWN0aW9uU3RhcnQpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJpZ2h0Rm9ybWF0dGVkUGFydCA9IGluaXRpYWxGb3JtYXR0ZWRWYWx1ZS5zbGljZShzZWxlY3Rpb25FbmQsIGluaXRpYWxGb3JtYXR0ZWRWYWx1ZS5sZW5ndGgpO1xuXG4gICAgICAgICAgICAgICAgaWYgKHNlbGVjdGlvblN0YXJ0ICE9PSBzZWxlY3Rpb25FbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gYS4gSWYgdGhlcmUgaXMgYSBzZWxlY3Rpb24sIHJlbW92ZSB0aGUgc2VsZWN0ZWQgcGFydCwgYW5kIHJldHVybiB0aGUgbGVmdCBhbmQgcmlnaHQgcGFydFxuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBwcmVwYXJlUGFzdGVkVGV4dChsZWZ0Rm9ybWF0dGVkUGFydCArIHJpZ2h0Rm9ybWF0dGVkUGFydCwgaG9sZGVyKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBiLiBFbHNlIGlmIHRoaXMgaXMgb25seSBvbmUgY2FyZXQgKGFuZCB0aGVyZWZvcmUgbm8gc2VsZWN0aW9uKSwgdGhlbiByZXR1cm4gdGhlIGxlZnQgYW5kIHJpZ2h0IHBhcnRcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gcHJlcGFyZVBhc3RlZFRleHQoaW5pdGlhbEZvcm1hdHRlZFZhbHVlLCBob2xkZXIpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIEFkZCBiYWNrIHRoZSBuZWdhdGl2ZSBzaWduIGlmIG5lZWRlZFxuICAgICAgICAgICAgICAgIGlmIChpc0luaXRpYWxWYWx1ZU5lZ2F0aXZlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHNldFJhd05lZ2F0aXZlU2lnbihyZXN1bHQpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIEJ1aWxkIHRoZSB1bmZvcm1hdHRlZCByZXN1bHQgc3RyaW5nXG4gICAgICAgICAgICAgICAgY2FyZXRQb3NpdGlvbk9uSW5pdGlhbFRleHRBZnRlclBhc3RpbmcgPSBjb252ZXJ0Q2hhcmFjdGVyQ291bnRUb0luZGV4UG9zaXRpb24oY291bnROdW1iZXJDaGFyYWN0ZXJzT25UaGVDYXJldExlZnRTaWRlKGluaXRpYWxGb3JtYXR0ZWRWYWx1ZSwgc2VsZWN0aW9uU3RhcnQsIGhvbGRlci5zZXR0aW5ncy5kZWNpbWFsQ2hhcmFjdGVyKSk7XG4gICAgICAgICAgICAgICAgaWYgKGlzUGFzdGVOZWdhdGl2ZUFuZEluaXRpYWxWYWx1ZUlzUG9zaXRpdmUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlIGluaXRpYWwgcGFzdGUgaXMgbmVnYXRpdmUgYW5kIHRoZSBpbml0aWFsIHZhbHVlIGlzIG5vdCwgdGhlbiBJIG11c3Qgb2Zmc2V0IHRoZSBjYXJldCBwb3NpdGlvbiBieSBvbmUgcGxhY2UgdG8gdGhlIHJpZ2h0IHRvIHRha2UgdGhlIGFkZGl0aW9uYWwgaHlwaGVuIGludG8gYWNjb3VudFxuICAgICAgICAgICAgICAgICAgICBjYXJldFBvc2l0aW9uT25Jbml0aWFsVGV4dEFmdGVyUGFzdGluZysrO1xuICAgICAgICAgICAgICAgICAgICAvL1RPRE8gUXVpZCBpZiB0aGUgbmVnYXRpdmUgc2lnbiBpcyBub3Qgb24gdGhlIGxlZnQgKG5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50IGFuZCBjdXJyZW5jeVN5bWJvbFBsYWNlbWVudCk/XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgbGV0IGxlZnRQYXJ0ID0gcmVzdWx0LnNsaWNlKDAsIGNhcmV0UG9zaXRpb25PbkluaXRpYWxUZXh0QWZ0ZXJQYXN0aW5nKTtcbiAgICAgICAgICAgICAgICBsZXQgcmlnaHRQYXJ0ID0gcmVzdWx0LnNsaWNlKGNhcmV0UG9zaXRpb25PbkluaXRpYWxUZXh0QWZ0ZXJQYXN0aW5nLCByZXN1bHQubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICBpZiAocGFzdGVkVGV4dCA9PT0gJy4nKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb250YWlucyhsZWZ0UGFydCwgJy4nKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgSSByZW1vdmUgYSBkb3QgaGVyZSwgdGhlbiBJIG5lZWQgdG8gdXBkYXRlIHRoZSBjYXJldCBwb3NpdGlvbiAoZGVjcmVtZW50IGl0IGJ5IDEpIHdoZW4gcG9zaXRpb25pbmcgaXRcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRvIGRvIHNvLCB3ZSBrZWVwIHRoYXQgaW5mbyBpbiBvcmRlciB0byBtb2RpZnkgdGhlIGNhcmV0IHBvc2l0aW9uIGxhdGVyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0UGFydENvbnRhaW5lZEFEb3QgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdFBhcnQgPSBsZWZ0UGFydC5yZXBsYWNlKCcuJywgJycpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0UGFydCA9IHJpZ2h0UGFydC5yZXBsYWNlKCcuJywgJycpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyAtLSBIZXJlLCB3ZSBhcmUgZ29vZCB0byBnbyB0byBjb250aW51ZSBvbiB0aGUgc2FtZSBiYXNpc1xuXG4gICAgICAgICAgICAgICAgLy8gYy4gQWRkIG51bWJlcnMgb25lIGJ5IG9uZSBhdCB0aGUgY2FyZXQgcG9zaXRpb24sIHdoaWxlIHRlc3RpbmcgaWYgdGhlIHJlc3VsdCBpcyB2YWxpZCBhbmQgd2l0aGluIHRoZSByYW5nZSBvZiB0aGUgbWluaW11bSBhbmQgbWF4aW11bSB2YWx1ZVxuICAgICAgICAgICAgICAgIC8vICAgIENvbnRpbnVlIHVudGlsIHlvdSBlaXRoZXIgcnVuIG91dCBvZiBudW1iZXJzIHRvIHBhc3RlLCBvciB0aGF0IHlvdSBnZXQgb3V0IG9mIHRoZSByYW5nZSBsaW1pdHNcbiAgICAgICAgICAgICAgICBjb25zdCBtaW5QYXJzZSA9IHBhcnNlU3RyKGhvbGRlci5zZXR0aW5ncy5taW5pbXVtVmFsdWUpO1xuICAgICAgICAgICAgICAgIGNvbnN0IG1heFBhcnNlID0gcGFyc2VTdHIoaG9sZGVyLnNldHRpbmdzLm1heGltdW1WYWx1ZSk7XG4gICAgICAgICAgICAgICAgbGV0IGxhc3RHb29kS25vd25SZXN1bHQgPSByZXN1bHQ7IC8vIFRoaXMgaXMgc2V0IGFzIHRoZSBkZWZhdWx0LCBpbiBjYXNlIHdlIGRvIG5vdCBhZGQgZXZlbiBvbmUgbnVtYmVyXG4gICAgICAgICAgICAgICAgbGV0IHBhc3RlZFRleHRJbmRleCA9IDA7XG4gICAgICAgICAgICAgICAgbGV0IG1vZGlmaWVkTGVmdFBhcnQgPSBsZWZ0UGFydDtcblxuICAgICAgICAgICAgICAgIHdoaWxlIChwYXN0ZWRUZXh0SW5kZXggPCBwYXN0ZWRUZXh0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBNb2RpZnkgdGhlIHJlc3VsdCB3aXRoIGFub3RoZXIgcGFzdGVkIGNoYXJhY3RlclxuICAgICAgICAgICAgICAgICAgICBtb2RpZmllZExlZnRQYXJ0ICs9IHBhc3RlZFRleHRbcGFzdGVkVGV4dEluZGV4XTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gbW9kaWZpZWRMZWZ0UGFydCArIHJpZ2h0UGFydDtcblxuICAgICAgICAgICAgICAgICAgICAvLyBDaGVjayB0aGUgcmFuZ2UgbGltaXRzXG4gICAgICAgICAgICAgICAgICAgIGlmICghY2hlY2tJZkluUmFuZ2UocmVzdWx0LCBtaW5QYXJzZSwgbWF4UGFyc2UpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgcmVzdWx0IGlzIG91dCBvZiB0aGUgcmFuZ2UgbGltaXRzLCBzdG9wIHRoZSBsb29wIGhlcmVcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gU2F2ZSB0aGUgbGFzdCBnb29kIGtub3duIHJlc3VsdFxuICAgICAgICAgICAgICAgICAgICBsYXN0R29vZEtub3duUmVzdWx0ID0gcmVzdWx0O1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgbG9jYWwgdmFyaWFibGVzIGZvciB0aGUgbmV4dCBsb29wXG4gICAgICAgICAgICAgICAgICAgIHBhc3RlZFRleHRJbmRleCsrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgbGFzdCBjYXJldCBwb3NpdGlvbiB3aGVyZSB0byBpbnNlcnQgYSBuZXcgbnVtYmVyXG4gICAgICAgICAgICAgICAgY2FyZXRQb3NpdGlvbk9uSW5pdGlhbFRleHRBZnRlclBhc3RpbmcgKz0gcGFzdGVkVGV4dEluZGV4O1xuXG4gICAgICAgICAgICAgICAgLy9YWFggSGVyZSB3ZSBoYXZlIHRoZSByZXN1bHQgZm9yIHRoZSBgdHJ1bmNhdGVgIG9wdGlvblxuICAgICAgICAgICAgICAgIGlmIChob2xkZXIuc2V0dGluZ3Mub25JbnZhbGlkUGFzdGUgPT09ICd0cnVuY2F0ZScpIHtcbiAgICAgICAgICAgICAgICAgICAgLy9UT0RPIElmIHRoZSB1c2VyIGFzIGRlZmluZWQgYSB0cnVuY2F0ZSBjYWxsYmFjayBhbmQgdGhlcmUgYXJlIHN0aWxsIHNvbWUgbnVtYmVycyAodGhhdCB3aWxsIGJlIGRyb3BwZWQpLCB0aGVuIGNhbGwgdGhpcyBjYWxsYmFjayB3aXRoIHRoZSBpbml0aWFsIHBhc3RlIGFzIHdlbGwgYXMgdGhlIHJlbWFpbmluZyBudW1iZXJzXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IGxhc3RHb29kS25vd25SZXN1bHQ7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGxlZnRQYXJ0Q29udGFpbmVkQURvdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgYSBkb3QgaGFzIGJlZW4gcmVtb3ZlZCBmb3IgdGhlIHBhcnQgb24gdGhlIGxlZnQgb2YgdGhlIGNhcmV0LCB3ZSBkZWNyZW1lbnQgdGhlIGNhcmV0IGluZGV4IHBvc2l0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXJldFBvc2l0aW9uT25Jbml0aWFsVGV4dEFmdGVyUGFzdGluZy0tO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvL1hYWCAuLi5lbHNlIHdlIG5lZWQgdG8gY29udGludWUgbW9kaWZ5aW5nIHRoZSByZXN1bHQgZm9yIHRoZSAncmVwbGFjZScgb3B0aW9uXG5cbiAgICAgICAgICAgICAgICAvLyBkLiBVbnRpbCB0aGVyZSBhcmUgbnVtYmVycyB0byBwYXN0ZSwgcmVwbGFjZSB0aGUgaW5pdGlhbCBudW1iZXJzIG9uZSBieSBvbmUsIGFuZCBzdGlsbCBkbyB0aGUgcmFuZ2UgdGVzdC5cbiAgICAgICAgICAgICAgICAvLyAgICBTdG9wIHdoZW4geW91IGhhdmUgbm8gbW9yZSBudW1iZXJzIHRvIHBhc3RlLCBvciBpZiB5b3UgYXJlIG91dCBvZiB0aGUgcmFuZ2UgbGltaXRzLlxuICAgICAgICAgICAgICAgIC8vICAgIElmIHlvdSBkbyBnZXQgdG8gdGhlIHJhbmdlIGxpbWl0cywgdXNlIHRoZSBwcmV2aW91cyBrbm93biBnb29kIHZhbHVlIHdpdGhpbiB0aG9zZSBsaW1pdHMuXG4gICAgICAgICAgICAgICAgLy8gICAgTm90ZTogVGhlIG51bWJlcnMgYXJlIHJlcGxhY2VkIG9uZSBieSBvbmUsIGluIHRoZSBpbnRlZ2VyIHRoZW4gZGVjaW1hbCBwYXJ0LCB3aGlsZSBpZ25vcmluZyB0aGUgZGVjaW1hbCBjaGFyYWN0ZXJcbiAgICAgICAgICAgICAgICAvL1RPRE8gV2hhdCBzaG91bGQgaGFwcGVuIGlmIHRoZSB1c2VyIHRyeSB0byBwYXN0ZSBhIGRlY2ltYWwgbnVtYmVyPyBTaG91bGQgd2Ugb3ZlcnJpZGUgdGhlIGN1cnJlbnQgaW5pdGlhbCBkZWNpbWFsIGNoYXJhY3RlciBpbiBmYXZvciBvZiB0aGlzIG5ldyBvbmU/IElmIHdlIGRvLCB0aGVuIHdlIGhhdmUgdG8gcmVjYWxjdWxhdGUgdGhlIHZNaW4vdk1heCBmcm9tIHRoZSBzdGFydCBpbiBvcmRlciB0byB0YWtlIGludG8gYWNjb3VudCB0aGlzIG5ldyBkZWNpbWFsIGNoYXJhY3RlciBwb3NpdGlvbi4uXG4gICAgICAgICAgICAgICAgbGV0IGxhc3RHb29kS25vd25SZXN1bHRJbmRleCA9IGNhcmV0UG9zaXRpb25PbkluaXRpYWxUZXh0QWZ0ZXJQYXN0aW5nO1xuICAgICAgICAgICAgICAgIGNvbnN0IGxhc3RHb29kS25vd25SZXN1bHRTaXplID0gbGFzdEdvb2RLbm93blJlc3VsdC5sZW5ndGg7XG5cbiAgICAgICAgICAgICAgICB3aGlsZSAocGFzdGVkVGV4dEluZGV4IDwgcGFzdGVkVGV4dC5sZW5ndGggJiYgbGFzdEdvb2RLbm93blJlc3VsdEluZGV4IDwgbGFzdEdvb2RLbm93blJlc3VsdFNpemUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxhc3RHb29kS25vd25SZXN1bHRbbGFzdEdvb2RLbm93blJlc3VsdEluZGV4XSA9PT0gJy4nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBXZSBza2lwIHRoZSBkZWNpbWFsIGNoYXJhY3RlciAncmVwbGFjZW1lbnQnLiBUaGF0IHdheSwgd2UgZG8gbm90IGNoYW5nZSB0aGUgZGVjaW1hbCBjaGFyYWN0ZXIgcG9zaXRpb24gcmVnYXJkaW5nIHRoZSByZW1haW5pbmcgbnVtYmVycy5cbiAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RHb29kS25vd25SZXN1bHRJbmRleCsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIHJlcGxhY2Ugb25lIGNoYXJhY3RlciBhdCBhIHRpbWVcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gcmVwbGFjZUNoYXJBdChsYXN0R29vZEtub3duUmVzdWx0LCBsYXN0R29vZEtub3duUmVzdWx0SW5kZXgsIHBhc3RlZFRleHRbcGFzdGVkVGV4dEluZGV4XSk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgdGhlIHJhbmdlIGxpbWl0c1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWNoZWNrSWZJblJhbmdlKHJlc3VsdCwgbWluUGFyc2UsIG1heFBhcnNlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlIHJlc3VsdCBpcyBvdXQgb2YgdGhlIHJhbmdlIGxpbWl0cywgc3RvcCB0aGUgbG9vcCBoZXJlXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIFNhdmUgdGhlIGxhc3QgZ29vZCBrbm93biByZXN1bHRcbiAgICAgICAgICAgICAgICAgICAgbGFzdEdvb2RLbm93blJlc3VsdCA9IHJlc3VsdDtcblxuICAgICAgICAgICAgICAgICAgICAvLyBVcGRhdGUgdGhlIGxvY2FsIHZhcmlhYmxlcyBmb3IgdGhlIG5leHQgbG9vcFxuICAgICAgICAgICAgICAgICAgICBwYXN0ZWRUZXh0SW5kZXgrKztcbiAgICAgICAgICAgICAgICAgICAgbGFzdEdvb2RLbm93blJlc3VsdEluZGV4Kys7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gVXBkYXRlIHRoZSBsYXN0IGNhcmV0IHBvc2l0aW9uIHdoZXJlIHRvIGluc2VydCBhIG5ldyBudW1iZXJcbiAgICAgICAgICAgICAgICBjYXJldFBvc2l0aW9uT25Jbml0aWFsVGV4dEFmdGVyUGFzdGluZyA9IGxhc3RHb29kS25vd25SZXN1bHRJbmRleDtcblxuICAgICAgICAgICAgICAgIGlmIChsZWZ0UGFydENvbnRhaW5lZEFEb3QpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgYSBkb3QgaGFzIGJlZW4gcmVtb3ZlZCBmb3IgdGhlIHBhcnQgb24gdGhlIGxlZnQgb2YgdGhlIGNhcmV0LCB3ZSBkZWNyZW1lbnQgdGhlIGNhcmV0IGluZGV4IHBvc2l0aW9uXG4gICAgICAgICAgICAgICAgICAgIGNhcmV0UG9zaXRpb25PbkluaXRpYWxUZXh0QWZ0ZXJQYXN0aW5nLS07XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gbGFzdEdvb2RLbm93blJlc3VsdDtcblxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgLyogNGMuIE5vcm1hbCBwYXN0ZSBiZWhhdmlvcjpcbiAgICAgICAgICAgICAqIEluc2VydCB0aGUgcGFzdGVkIG51bWJlciBpbnNpZGUgdGhlIGN1cnJlbnQgdW5mb3JtYXR0ZWQgdGV4dCwgYXQgdGhlIHJpZ2h0IGNhcmV0IHBvc2l0aW9uIG9yIHNlbGVjdGlvblxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBjYXNlICdlcnJvcic6XG4gICAgICAgICAgICBjYXNlICdpZ25vcmUnOlxuICAgICAgICAgICAgY2FzZSAnY2xhbXAnOlxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAvLyAxLiBHZW5lcmF0ZSB0aGUgdW5mb3JtYXR0ZWQgcmVzdWx0XG4gICAgICAgICAgICAgICAgY29uc3QgbGVmdEZvcm1hdHRlZFBhcnQyID0gaW5pdGlhbEZvcm1hdHRlZFZhbHVlLnNsaWNlKDAsIHNlbGVjdGlvblN0YXJ0KTtcbiAgICAgICAgICAgICAgICBjb25zdCByaWdodEZvcm1hdHRlZFBhcnQyID0gaW5pdGlhbEZvcm1hdHRlZFZhbHVlLnNsaWNlKHNlbGVjdGlvbkVuZCwgaW5pdGlhbEZvcm1hdHRlZFZhbHVlLmxlbmd0aCk7XG5cbiAgICAgICAgICAgICAgICBpZiAoc2VsZWN0aW9uU3RhcnQgIT09IHNlbGVjdGlvbkVuZCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBhLiBJZiB0aGVyZSBpcyBhIHNlbGVjdGlvbiwgcmVtb3ZlIHRoZSBzZWxlY3RlZCBwYXJ0LCBhbmQgcmV0dXJuIHRoZSBsZWZ0IGFuZCByaWdodCBwYXJ0XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHByZXBhcmVQYXN0ZWRUZXh0KGxlZnRGb3JtYXR0ZWRQYXJ0MiArIHJpZ2h0Rm9ybWF0dGVkUGFydDIsIGhvbGRlcik7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gYi4gRWxzZSBpZiB0aGlzIGlzIG9ubHkgb25lIGNhcmV0IChhbmQgdGhlcmVmb3JlIG5vIHNlbGVjdGlvbiksIHRoZW4gcmV0dXJuIHRoZSBsZWZ0IGFuZCByaWdodCBwYXJ0XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHByZXBhcmVQYXN0ZWRUZXh0KGluaXRpYWxGb3JtYXR0ZWRWYWx1ZSwgaG9sZGVyKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBBZGQgYmFjayB0aGUgbmVnYXRpdmUgc2lnbiBpZiBuZWVkZWRcbiAgICAgICAgICAgICAgICBpZiAoaXNJbml0aWFsVmFsdWVOZWdhdGl2ZSkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBzZXRSYXdOZWdhdGl2ZVNpZ24ocmVzdWx0KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBCdWlsZCB0aGUgdW5mb3JtYXR0ZWQgcmVzdWx0IHN0cmluZ1xuICAgICAgICAgICAgICAgIGNhcmV0UG9zaXRpb25PbkluaXRpYWxUZXh0QWZ0ZXJQYXN0aW5nID0gY29udmVydENoYXJhY3RlckNvdW50VG9JbmRleFBvc2l0aW9uKGNvdW50TnVtYmVyQ2hhcmFjdGVyc09uVGhlQ2FyZXRMZWZ0U2lkZShpbml0aWFsRm9ybWF0dGVkVmFsdWUsIHNlbGVjdGlvblN0YXJ0LCBob2xkZXIuc2V0dGluZ3MuZGVjaW1hbENoYXJhY3RlcikpO1xuICAgICAgICAgICAgICAgIGlmIChpc1Bhc3RlTmVnYXRpdmVBbmRJbml0aWFsVmFsdWVJc1Bvc2l0aXZlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZSBpbml0aWFsIHBhc3RlIGlzIG5lZ2F0aXZlIGFuZCB0aGUgaW5pdGlhbCB2YWx1ZSBpcyBub3QsIHRoZW4gSSBtdXN0IG9mZnNldCB0aGUgY2FyZXQgcG9zaXRpb24gYnkgb25lIHBsYWNlIHRvIHRoZSByaWdodCB0byB0YWtlIHRoZSBhZGRpdGlvbmFsIGh5cGhlbiBpbnRvIGFjY291bnRcbiAgICAgICAgICAgICAgICAgICAgY2FyZXRQb3NpdGlvbk9uSW5pdGlhbFRleHRBZnRlclBhc3RpbmcrKztcbiAgICAgICAgICAgICAgICAgICAgLy9UT0RPIFF1aWQgaWYgdGhlIG5lZ2F0aXZlIHNpZ24gaXMgbm90IG9uIHRoZSBsZWZ0IChuZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudCBhbmQgY3VycmVuY3lTeW1ib2xQbGFjZW1lbnQpP1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGxlZnRQYXJ0ID0gcmVzdWx0LnNsaWNlKDAsIGNhcmV0UG9zaXRpb25PbkluaXRpYWxUZXh0QWZ0ZXJQYXN0aW5nKTtcbiAgICAgICAgICAgICAgICByaWdodFBhcnQgPSByZXN1bHQuc2xpY2UoY2FyZXRQb3NpdGlvbk9uSW5pdGlhbFRleHRBZnRlclBhc3RpbmcsIHJlc3VsdC5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIGlmIChwYXN0ZWRUZXh0ID09PSAnLicpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlIHVzZXIgb25seSBwYXN0ZSBhIHNpbmdsZSBkZWNpbWFsIGNoYXJhY3RlciwgdGhlbiB3ZSByZW1vdmUgdGhlIHByZXZpb3VzbHkgZXhpc3Rpbmcgb25lIChpZiBhbnkpXG4gICAgICAgICAgICAgICAgICAgIGlmIChjb250YWlucyhsZWZ0UGFydCwgJy4nKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgSSByZW1vdmUgYSBkb3QgaGVyZSwgdGhlbiBJIG5lZWQgdG8gdXBkYXRlIHRoZSBjYXJldCBwb3NpdGlvbiAoZGVjcmVtZW50IGl0IGJ5IDEpIHdoZW4gcG9zaXRpb25pbmcgaXRcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRvIGRvIHNvLCB3ZSBrZWVwIHRoYXQgaW5mbyBpbiBvcmRlciB0byBtb2RpZnkgdGhlIGNhcmV0IHBvc2l0aW9uIGxhdGVyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0UGFydENvbnRhaW5lZEFEb3QgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdFBhcnQgPSBsZWZ0UGFydC5yZXBsYWNlKCcuJywgJycpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0UGFydCA9IHJpZ2h0UGFydC5yZXBsYWNlKCcuJywgJycpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyAtLSBIZXJlLCB3ZSBhcmUgZ29vZCB0byBnbyB0byBjb250aW51ZSBvbiB0aGUgc2FtZSBiYXNpc1xuXG4gICAgICAgICAgICAgICAgLy8gR2VuZXJhdGUgdGhlIHVuZm9ybWF0dGVkIHJlc3VsdFxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGAke2xlZnRQYXJ0fSR7cGFzdGVkVGV4dH0ke3JpZ2h0UGFydH1gO1xuXG4gICAgICAgICAgICAgICAgLy8gMi4gQ2FsY3VsYXRlIHRoZSBjYXJldCBwb3NpdGlvbiBpbiB0aGUgdW5mb3JtYXR0ZWQgdmFsdWUsIGZvciBsYXRlciB1c2VcbiAgICAgICAgICAgICAgICBpZiAoc2VsZWN0aW9uU3RhcnQgPT09IHNlbGVjdGlvbkVuZCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBUaGVyZSBpcyBubyBzZWxlY3Rpb24sIHRoZW4gdGhlIGNhcmV0IHBvc2l0aW9uIGlzIHNldCBhZnRlciB0aGUgcGFzdGVkIHRleHRcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaW5kZXhXaGVyZVBhc3RlZFRleHRIYXNCZWVuSW5zZXJ0ZWQgPSBjb252ZXJ0Q2hhcmFjdGVyQ291bnRUb0luZGV4UG9zaXRpb24oY291bnROdW1iZXJDaGFyYWN0ZXJzT25UaGVDYXJldExlZnRTaWRlKGluaXRpYWxGb3JtYXR0ZWRWYWx1ZSwgc2VsZWN0aW9uU3RhcnQsIGhvbGRlci5zZXR0aW5ncy5kZWNpbWFsQ2hhcmFjdGVyKSk7XG4gICAgICAgICAgICAgICAgICAgIGNhcmV0UG9zaXRpb25PbkluaXRpYWxUZXh0QWZ0ZXJQYXN0aW5nID0gaW5kZXhXaGVyZVBhc3RlZFRleHRIYXNCZWVuSW5zZXJ0ZWQgKyBwYXN0ZWRUZXh0Lmxlbmd0aDsgLy8gSSBtdXN0IG5vdCBjb3VudCB0aGUgY2hhcmFjdGVycyB0aGF0IGhhdmUgYmVlbiByZW1vdmVkIGZyb20gdGhlIHBhc3RlZCB0ZXh0IChpZS4gJy4nKVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0FsbElucHV0VGV4dFNlbGVjdGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBTcGVjaWFsIGNhc2Ugd2hlbiBhbGwgdGhlIGlucHV0IHRleHQgaXMgc2VsZWN0ZWQgYmVmb3JlIHBhc3RpbmcsIHdoaWNoIG1lYW5zIHdlJ2xsIGNvbXBsZXRlbHkgZXJhc2UgaXRzIGNvbnRlbnQgYW5kIHBhc3RlIG9ubHkgdGhlIGNsaXBib2FyZCBjb250ZW50XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXJldFBvc2l0aW9uT25Jbml0aWFsVGV4dEFmdGVyUGFzdGluZyA9IHJlc3VsdC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocmlnaHRQYXJ0ID09PSAnJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlIHVzZXIgc2VsZWN0ZWQgZnJvbSB0aGUgY2FyZXQgcG9zaXRpb24gdG8gdGhlIGVuZCBvZiB0aGUgaW5wdXQgKG9uIHRoZSBmYXIgcmlnaHQpXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXJldFBvc2l0aW9uT25Jbml0aWFsVGV4dEFmdGVyUGFzdGluZyA9IGNvbnZlcnRDaGFyYWN0ZXJDb3VudFRvSW5kZXhQb3NpdGlvbihjb3VudE51bWJlckNoYXJhY3RlcnNPblRoZUNhcmV0TGVmdFNpZGUoaW5pdGlhbEZvcm1hdHRlZFZhbHVlLCBzZWxlY3Rpb25TdGFydCwgaG9sZGVyLnNldHRpbmdzLmRlY2ltYWxDaGFyYWN0ZXIpKSArIHBhc3RlZFRleHQubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTm9ybWFsIGNhc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGluZGV4U2VsZWN0aW9uRW5kSW5SYXdWYWx1ZSA9IGNvbnZlcnRDaGFyYWN0ZXJDb3VudFRvSW5kZXhQb3NpdGlvbihjb3VudE51bWJlckNoYXJhY3RlcnNPblRoZUNhcmV0TGVmdFNpZGUoaW5pdGlhbEZvcm1hdHRlZFZhbHVlLCBzZWxlY3Rpb25FbmQsIGhvbGRlci5zZXR0aW5ncy5kZWNpbWFsQ2hhcmFjdGVyKSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEhlcmUgSSBtdXN0IG5vdCBjb3VudCB0aGUgY2hhcmFjdGVycyB0aGF0IGhhdmUgYmVlbiByZW1vdmVkIGZyb20gdGhlIHBhc3RlZCB0ZXh0IChpZS4gJy4nKSwgb3IgdGhlIHRob3VzYW5kIHNlcGFyYXRvcnMgaW4gdGhlIGluaXRpYWwgc2VsZWN0ZWQgdGV4dFxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2VsZWN0ZWRUZXh0ID0gZS50YXJnZXQudmFsdWUuc2xpY2Uoc2VsZWN0aW9uU3RhcnQsIHNlbGVjdGlvbkVuZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXJldFBvc2l0aW9uT25Jbml0aWFsVGV4dEFmdGVyUGFzdGluZyA9IGluZGV4U2VsZWN0aW9uRW5kSW5SYXdWYWx1ZSAtIHNlbGVjdGlvblNpemUgKyBjb3VudENoYXJJblRleHQoaG9sZGVyLnNldHRpbmdzLmRpZ2l0R3JvdXBTZXBhcmF0b3IsIHNlbGVjdGVkVGV4dCkgKyBwYXN0ZWRUZXh0Lmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIE1vZGlmeSB0aGUgY2FyZXQgcG9zaXRpb24gZm9yIHNwZWNpYWwgY2FzZXMsIG9ubHkgaWYgdGhlIHdob2xlIGlucHV0IGhhcyBub3QgYmVlbiBzZWxlY3RlZFxuICAgICAgICAgICAgICAgIGlmICghaXNBbGxJbnB1dFRleHRTZWxlY3RlZCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNQYXN0ZU5lZ2F0aXZlQW5kSW5pdGlhbFZhbHVlSXNQb3NpdGl2ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlIHBhc3RlZCB2YWx1ZSBoYXMgYSAnLScgc2lnbiwgYnV0IHRoZSBpbml0aWFsIHZhbHVlIGRvZXMgbm90LCBvZmZzZXQgdGhlIGluZGV4IGJ5IG9uZVxuICAgICAgICAgICAgICAgICAgICAgICAgY2FyZXRQb3NpdGlvbk9uSW5pdGlhbFRleHRBZnRlclBhc3RpbmcrKztcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmIChsZWZ0UGFydENvbnRhaW5lZEFEb3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIGEgZG90IGhhcyBiZWVuIHJlbW92ZWQgZm9yIHRoZSBwYXJ0IG9uIHRoZSBsZWZ0IG9mIHRoZSBjYXJldCwgd2UgZGVjcmVtZW50IHRoZSBjYXJldCBpbmRleCBwb3NpdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgY2FyZXRQb3NpdGlvbk9uSW5pdGlhbFRleHRBZnRlclBhc3RpbmctLTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIDUuIENoZWNrIGlmIHRoZSByZXN1bHQgaXMgYSB2YWxpZCBudW1iZXIsIGlmIG5vdCwgZHJvcCB0aGUgcGFzdGUgYW5kIGRvIG5vdGhpbmcuXG4gICAgICAgIGlmICghaXNOdW1iZXIocmVzdWx0KSB8fCByZXN1bHQgPT09ICcnKSB7XG4gICAgICAgICAgICBpZiAoaG9sZGVyLnNldHRpbmdzLm9uSW52YWxpZFBhc3RlID09PSAnZXJyb3InKSB7XG4gICAgICAgICAgICAgICAgdGhyb3dFcnJvcihgVGhlIHBhc3RlZCB2YWx1ZSAnJHtyYXdQYXN0ZWRUZXh0fScgd291bGQgcmVzdWx0IGludG8gYW4gaW52YWxpZCBjb250ZW50ICcke3Jlc3VsdH0nLmApOyAvL1RPRE8gU2hvdWxkIHdlIHNlbmQgYSB3YXJuaW5nIGluc3RlYWQgb2YgdGhyb3dpbmcgYW4gZXJyb3I/XG4gICAgICAgICAgICAgICAgLy9UT0RPIFRoaXMgaXMgbm90IERSWSA7IHJlZmFjdG9yIHdpdGggYWJvdmVcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIDYuIElmIGl0J3MgYSB2YWxpZCBudW1iZXIsIGNoZWNrIGlmIGl0IGZhbGxzIGluc2lkZSB0aGUgbWluaW11bSBhbmQgbWF4aW11bSB2YWx1ZS4gSWYgdGhpcyBmYWlscywgbW9kaWZ5IHRoZSB2YWx1ZSBmb2xsb3dpbmcgdGhpcyBwcm9jZWR1cmUgOlxuICAgICAgICAvKlxuICAgICAgICAgKiBJZiAnZXJyb3InICh0aGlzIGlzIHRoZSBkZWZhdWx0KSA6XG4gICAgICAgICAqICAgICAgLSBOb3JtYWwgcGFzdGUgYmVoYXZpb3IuXG4gICAgICAgICAqICAgICAgLSBUcnkgdG8gc2V0IHRoZSBuZXcgdmFsdWUsIGlmIGl0IGZhaWxzLCB0aGVuIHRocm93IGFuIGVycm9yIGluIHRoZSBjb25zb2xlLlxuICAgICAgICAgKiAgICAgIC0gRG8gbm90IGNoYW5nZSB0aGUgaW5wdXQgdmFsdWUsIGRvIG5vdCBjaGFuZ2UgdGhlIGN1cnJlbnQgc2VsZWN0aW9uLlxuICAgICAgICAgKiBJZiAnaWdub3JlJyA6XG4gICAgICAgICAqICAgICAgLSBOb3JtYWwgcGFzdGUgYmVoYXZpb3IuXG4gICAgICAgICAqICAgICAgLSBUcnkgdG8gc2V0IHRoZSBuZXcgdmFsdWUsIGlmIGl0IGZhaWxzLCBkbyBub3RoaW5nIG1vcmUuXG4gICAgICAgICAqICAgICAgLSBEbyBub3QgY2hhbmdlIHRoZSBpbnB1dCB2YWx1ZSwgZG8gbm90IGNoYW5nZSB0aGUgY3VycmVudCBzZWxlY3Rpb24uXG4gICAgICAgICAqIElmICdjbGFtcCcgOlxuICAgICAgICAgKiAgICAgIC0gTm9ybWFsIHBhc3RlIGJlaGF2aW9yLlxuICAgICAgICAgKiAgICAgIC0gVHJ5IHRvIHNldCB0aGUgbmV3IHZhbHVlLCBpZiBpdCBmYWlscywgc2V0IHRoZSB2YWx1ZSB0byB0aGUgbWluaW11bSBvciBtYXhpbXVtIGxpbWl0LCB3aGljaGV2ZXIgaXMgY2xvc2VzdCB0byB0aGVcbiAgICAgICAgICogICAgICAgIHBhc3RlIHJlc3VsdC5cbiAgICAgICAgICogICAgICAtIENoYW5nZSB0aGUgY2FyZXQgcG9zaXRpb24gdG8gYmUgcG9zaXRpb25lZCBvbiB0aGUgbGVmdCBoYW5kIHNpZGUgb2YgdGhlIGRlY2ltYWwgY2hhcmFjdGVyLlxuICAgICAgICAgKiBJZiAndHJ1bmNhdGUnIDpcbiAgICAgICAgICogICAgICAtIFRydW5jYXRlIHBhc3RlIGJlaGF2aW9yLlxuICAgICAgICAgKiAgICAgIC0gVHJ5IHRvIHNldCB0aGUgbmV3IHZhbHVlLCB1bnRpbCBpdCBmYWlscyAoaWYgdGhlIHJlc3VsdCBpcyBvdXQgb2YgdGhlIG1pbiBhbmQgbWF4IHZhbHVlIGxpbWl0cykuXG4gICAgICAgICAqICAgICAgLSBEcm9wIHRoZSByZW1haW5pbmcgbm9uLXBhc3RlZCBudW1iZXJzLCBhbmQga2VlcCB0aGUgbGFzdCBrbm93biBub24tZmFpbGluZyByZXN1bHQuXG4gICAgICAgICAqICAgICAgLSBDaGFuZ2UgdGhlIGNhcmV0IHBvc2l0aW9uIHRvIGJlIHBvc2l0aW9uZWQgYWZ0ZXIgdGhlIGxhc3QgcGFzdGVkIGNoYXJhY3Rlci5cbiAgICAgICAgICogSWYgJ3JlcGxhY2UnIDpcbiAgICAgICAgICogICAgICAtIFJlcGxhY2UgcGFzdGUgYmVoYXZpb3IuXG4gICAgICAgICAqICAgICAgLSBUcnkgdG8gc2V0IHRoZSBuZXcgdmFsdWUsIHVudGlsIGl0IGZhaWxzIChpZiB0aGUgcmVzdWx0IGlzIG91dCBvZiB0aGUgbWluIGFuZCBtYXggdmFsdWUgbGltaXRzKS5cbiAgICAgICAgICogICAgIC0gVGhlbiB0cnkgdG8gcmVwbGFjZSBhcyBtYW55IG51bWJlcnMgYXMgcG9zc2libGUgd2l0aCB0aGUgcGFzdGVkIG9uZXMuIE9uY2UgaXQgZmFpbHMsIGtlZXAgdGhlIGxhc3Qga25vd24gbm9uLWZhaWxpbmcgcmVzdWx0LlxuICAgICAgICAgKiAgICAgIC0gQ2hhbmdlIHRoZSBjYXJldCBwb3NpdGlvbiB0byBiZSBwb3NpdGlvbmVkIGFmdGVyIHRoZSBsYXN0IHBhc3RlZCBjaGFyYWN0ZXIuXG4gICAgICAgICAqL1xuICAgICAgICBsZXQgdmFsdWVIYXNCZWVuU2V0ID0gZmFsc2U7XG4gICAgICAgIGxldCB2YWx1ZUhhc0JlZW5DbGFtcGVkID0gZmFsc2U7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAkdGhpcy5hdXRvTnVtZXJpYygnc2V0JywgcmVzdWx0KTtcbiAgICAgICAgICAgIHZhbHVlSGFzQmVlblNldCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBsZXQgY2xhbXBlZFZhbHVlO1xuICAgICAgICAgICAgc3dpdGNoIChob2xkZXIuc2V0dGluZ3Mub25JbnZhbGlkUGFzdGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdjbGFtcCc6XG4gICAgICAgICAgICAgICAgICAgIGNsYW1wZWRWYWx1ZSA9IGNsYW1wVG9SYW5nZUxpbWl0cyhyZXN1bHQsIGhvbGRlci5zZXR0aW5ncyk7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAkdGhpcy5hdXRvTnVtZXJpYygnc2V0JywgY2xhbXBlZFZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93RXJyb3IoYEZhdGFsIGVycm9yOiBVbmFibGUgdG8gc2V0IHRoZSBjbGFtcGVkIHZhbHVlICcke2NsYW1wZWRWYWx1ZX0nLmApO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgdmFsdWVIYXNCZWVuQ2xhbXBlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlSGFzQmVlblNldCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IGNsYW1wZWRWYWx1ZTsgLy8gVGhpcyBpcyB1c2VkIG9ubHkgZm9yIHNldHRpbmcgdGhlIGNhcmV0IHBvc2l0aW9uIGxhdGVyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2Vycm9yJzpcbiAgICAgICAgICAgICAgICBjYXNlICd0cnVuY2F0ZSc6XG4gICAgICAgICAgICAgICAgY2FzZSAncmVwbGFjZSc6XG4gICAgICAgICAgICAgICAgICAgIC8vIFRocm93IGFuIGVycm9yIG1lc3NhZ2VcbiAgICAgICAgICAgICAgICAgICAgdGhyb3dFcnJvcihgVGhlIHBhc3RlZCB2YWx1ZSAnJHtyYXdQYXN0ZWRUZXh0fScgcmVzdWx0cyBpbiBhIHZhbHVlICcke3Jlc3VsdH0nIHRoYXQgaXMgb3V0c2lkZSBvZiB0aGUgbWluaW11bSBbJHtob2xkZXIuc2V0dGluZ3MubWluaW11bVZhbHVlfV0gYW5kIG1heGltdW0gWyR7aG9sZGVyLnNldHRpbmdzLm1heGltdW1WYWx1ZX1dIHZhbHVlIHJhbmdlLmApO1xuICAgICAgICAgICAgICAgIC8vIGZhbGxzIHRocm91Z2hcbiAgICAgICAgICAgICAgICBjYXNlICdpZ25vcmUnOlxuICAgICAgICAgICAgICAgIC8vIERvIG5vdGhpbmdcbiAgICAgICAgICAgICAgICAvLyBmYWxscyB0aHJvdWdoXG4gICAgICAgICAgICAgICAgZGVmYXVsdCA6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjsgLy8gLi4uYW5kIG5vdGhpbmcgZWxzZSBzaG91bGQgYmUgY2hhbmdlZFxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gNy4gVGhlbiBsYXN0bHksIHNldCB0aGUgY2FyZXQgcG9zaXRpb24gYXQgdGhlIHJpZ2h0IGxvZ2ljYWwgcGxhY2VcbiAgICAgICAgbGV0IGNhcmV0UG9zaXRpb25JbkZvcm1hdHRlZE51bWJlcjtcbiAgICAgICAgaWYgKHZhbHVlSGFzQmVlblNldCkge1xuICAgICAgICAgICAgc3dpdGNoIChob2xkZXIuc2V0dGluZ3Mub25JbnZhbGlkUGFzdGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdjbGFtcCc6XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZUhhc0JlZW5DbGFtcGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaG9sZGVyLnNldHRpbmdzLmN1cnJlbmN5U3ltYm9sUGxhY2VtZW50ID09PSAncycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRFbGVtZW50U2VsZWN0aW9uKGUudGFyZ2V0LCBlLnRhcmdldC52YWx1ZS5sZW5ndGggLSBob2xkZXIuc2V0dGluZ3MuY3VycmVuY3lTeW1ib2wubGVuZ3RoKTsgLy8gVGhpcyBwdXRzIHRoZSBjYXJldCBvbiB0aGUgcmlnaHQgb2YgdGhlIGxhc3QgZGVjaW1hbCBwbGFjZVxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRFbGVtZW50U2VsZWN0aW9uKGUudGFyZ2V0LCBlLnRhcmdldC52YWx1ZS5sZW5ndGgpOyAvLyAuLmFuZCB0aGlzIG9uIHRoZSBmYXIgcmlnaHRcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH0gLy8gZWxzZSBpZiB0aGUgdmFsdWUgaGFzIG5vdCBiZWVuIGNsYW1wZWQsIHRoZSBkZWZhdWx0IGJlaGF2aW9yIGlzIHVzZWQuLi5cbiAgICAgICAgICAgICAgICAvLyBmYWxscyB0aHJvdWdoXG4gICAgICAgICAgICAgICAgY2FzZSAnZXJyb3InOlxuICAgICAgICAgICAgICAgIGNhc2UgJ2lnbm9yZSc6XG4gICAgICAgICAgICAgICAgY2FzZSAndHJ1bmNhdGUnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ3JlcGxhY2UnOlxuICAgICAgICAgICAgICAgIGRlZmF1bHQgOlxuICAgICAgICAgICAgICAgICAgICAvLyBXaGVuZXZlciBvbmUgb3IgbXVsdGlwbGUgY2hhcmFjdGVycyBhcmUgcGFzdGVkLCB0aGlzIG1lYW5zIHdlIGhhdmUgdG8gbWFuYWdlIHRoZSBwb3RlbnRpYWwgdGhvdXNhbmQgc2VwYXJhdG9ycyB0aGF0IGNvdWxkIGJlIGFkZGVkIGJ5IHRoZSBmb3JtYXR0aW5nXG4gICAgICAgICAgICAgICAgICAgIGNhcmV0UG9zaXRpb25JbkZvcm1hdHRlZE51bWJlciA9IGZpbmRDYXJldFBvc2l0aW9uSW5Gb3JtYXR0ZWROdW1iZXIocmVzdWx0LCBjYXJldFBvc2l0aW9uT25Jbml0aWFsVGV4dEFmdGVyUGFzdGluZywgZS50YXJnZXQudmFsdWUsIGhvbGRlci5zZXR0aW5ncy5kZWNpbWFsQ2hhcmFjdGVyKTtcbiAgICAgICAgICAgICAgICAgICAgc2V0RWxlbWVudFNlbGVjdGlvbihlLnRhcmdldCwgY2FyZXRQb3NpdGlvbkluRm9ybWF0dGVkTnVtYmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIDguIFdlIG1ha2Ugc3VyZSB3ZSBzZW5kIGFuIGlucHV0IGV2ZW50IG9ubHkgaWYgdGhlIHJlc3VsdCBpcyBkaWZmZXJlbnQgdGhhbiB0aGUgaW5pdGlhbCB2YWx1ZSBiZWZvcmUgdGhlIHBhc3RlXG4gICAgICAgIGlmICh2YWx1ZUhhc0JlZW5TZXQgJiYgaW5pdGlhbEZvcm1hdHRlZFZhbHVlICE9PSBlLnRhcmdldC52YWx1ZSkge1xuICAgICAgICAgICAgLy8gT24gYSAnbm9ybWFsJyBub24tYXV0b051bWVyaWMgaW5wdXQsIGFuIGBpbnB1dGAgZXZlbnQgaXMgc2VudCB3aGVuIGEgcGFzdGUgaXMgZG9uZS4gV2UgbWltaWMgdGhhdC5cbiAgICAgICAgICAgIHRyaWdnZXJFdmVudCgnaW5wdXQnLCBlLnRhcmdldCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBXaGVuIGZvY3VzaW5nIG91dCBvZiB0aGUgaW5wdXQsIHdlIGNoZWNrIGlmIHRoZSB2YWx1ZSBoYXMgY2hhbmdlZCwgYW5kIGlmIGl0IGhhcywgdGhlbiB3ZSBzZW5kIGEgYGNoYW5nZWAgZXZlbnQgKHNpbmNlIHRoZSBuYXRpdmUgb25lIHdvdWxkIGhhdmUgYmVlbiBwcmV2ZW50ZWQgYnkgYGUucHJldmVudERlZmF1bHQoKWAgY2FsbGVkIGluIHRoZSBvdGhlciBldmVudCBsaXN0ZW5lcnMpLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtBdXRvTnVtZXJpY0hvbGRlcn0gaG9sZGVyXG4gICAgICogQHBhcmFtIHtFdmVudH0gZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG9uQmx1cihob2xkZXIsIGUpIHtcbiAgICAgICAgaWYgKGUudGFyZ2V0LnZhbHVlICE9PSBob2xkZXIudmFsdWVPbkZvY3VzKSB7XG4gICAgICAgICAgICB0cmlnZ2VyRXZlbnQoJ2NoYW5nZScsIGUudGFyZ2V0KTtcbiAgICAgICAgICAgIC8vIGUucHJldmVudERlZmF1bHQoKTsgLy8gLi4uYW5kIGltbWVkaWF0ZWx5IHByZXZlbnQgdGhlIGJyb3dzZXIgdG8gc2VuZCBhIHNlY29uZCBjaGFuZ2UgZXZlbnQgKHRoYXQgc29tZWhvdyBnZXRzIHBpY2tlZCB1cCBieSBqUXVlcnksIGJ1dCBub3QgYnkgYGFkZEV2ZW50TGlzdGVuZXIoKWAgLy9GSVhNRSBLTk9XTiBCVUcgOiBUaGlzIGRvZXMgbm90IHByZXZlbnQgdGhlIHNlY29uZCBjaGFuZ2UgZXZlbnQgdG8gYmUgcGlja2VkIHVwIGJ5IGpRdWVyeSwgd2hpY2ggYWRkcyAnLjAwJyBhdCB0aGUgZW5kIG9mIGFuIGludGVnZXJcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEhhbmRsZXIgZm9yICdzdWJtaXQnIGV2ZW50c1xuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9ICR0aGlzIGpRdWVyeS1zZWxlY3RlZCBET00gZWxlbWVudFxuICAgICAqIEBwYXJhbSB7QXV0b051bWVyaWNIb2xkZXJ9IGhvbGRlclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG9uU3VibWl0KCR0aGlzLCBob2xkZXIpIHtcbiAgICAgICAgJHRoaXMuY2xvc2VzdCgnZm9ybScpLm9uKCdzdWJtaXQuYXV0b051bWVyaWMnLCAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoaG9sZGVyKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgJHNldHRpbmdzID0gaG9sZGVyLnNldHRpbmdzQ2xvbmU7XG5cbiAgICAgICAgICAgICAgICBpZiAoJHNldHRpbmdzLnVuZm9ybWF0T25TdWJtaXQpIHtcbiAgICAgICAgICAgICAgICAgICAgJHRoaXMudmFsKCRzZXR0aW5ncy5yYXdWYWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdGhlIGpRdWVyeSBzZWxlY3RlZCBpbnB1dCBpZiB0aGUgdGFnIGFuZCB0eXBlIGFyZSBzdXBwb3J0ZWQgYnkgYXV0b051bWVyaWMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gJHRoaXMgalF1ZXJ5LXNlbGVjdGVkIERPTSBlbGVtZW50XG4gICAgICogQHJldHVybnMge2Jvb2xlYW58Kn1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRJbnB1dElmU3VwcG9ydGVkVGFnQW5kVHlwZSgkdGhpcykge1xuICAgICAgICAvLyBTdXBwb3J0ZWQgaW5wdXQgdHlwZVxuICAgICAgICBjb25zdCAkaW5wdXQgPSAkdGhpcy5pcygnaW5wdXRbdHlwZT10ZXh0XSwgaW5wdXRbdHlwZT1oaWRkZW5dLCBpbnB1dFt0eXBlPXRlbF0sIGlucHV0Om5vdChbdHlwZV0pJyk7XG5cbiAgICAgICAgLy8gQ2hlY2tzIGZvciBub24tc3VwcG9ydGVkIGlucHV0IHR5cGVzXG4gICAgICAgIGlmICghJGlucHV0ICYmICR0aGlzLnByb3AoJ3RhZ05hbWUnKS50b0xvd2VyQ2FzZSgpID09PSAnaW5wdXQnKSB7XG4gICAgICAgICAgICB0aHJvd0Vycm9yKGBUaGUgaW5wdXQgdHlwZSBcIiR7JHRoaXMucHJvcCgndHlwZScpfVwiIGlzIG5vdCBzdXBwb3J0ZWQgYnkgYXV0b051bWVyaWNgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENoZWNrcyBmb3Igbm9uLXN1cHBvcnRlZCB0YWdzXG4gICAgICAgIGNvbnN0IGN1cnJlbnRFbGVtZW50VGFnID0gJHRoaXMucHJvcCgndGFnTmFtZScpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGlmIChjdXJyZW50RWxlbWVudFRhZyAhPT0gJ2lucHV0JyAmJiAhaXNJbkFycmF5KGN1cnJlbnRFbGVtZW50VGFnLCBhbGxvd2VkVGFnTGlzdCkpIHtcbiAgICAgICAgICAgIHRocm93RXJyb3IoYFRoZSA8JHtjdXJyZW50RWxlbWVudFRhZ30+IHRhZyBpcyBub3Qgc3VwcG9ydGVkIGJ5IGF1dG9OdW1lcmljYCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gJGlucHV0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZvcm1hdHMgdGhlIGRlZmF1bHQgdmFsdWUgb24gcGFnZSBsb2FkLlxuICAgICAqIFRoaXMgaXMgY2FsbGVkIG9ubHkgaWYgdGhlIGBmb3JtYXRPblBhZ2VMb2FkYCBvcHRpb24gaXMgc2V0IHRvIGB0cnVlYC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5nc1xuICAgICAqIEBwYXJhbSB7b2JqZWN0fSAkaW5wdXQgalF1ZXJ5LXNlbGVjdGVkIDxpbnB1dD4gZWxlbWVudFxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSAkdGhpcyBqUXVlcnktc2VsZWN0ZWQgRE9NIGVsZW1lbnRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmb3JtYXREZWZhdWx0VmFsdWVPblBhZ2VMb2FkKHNldHRpbmdzLCAkaW5wdXQsICR0aGlzKSB7XG4gICAgICAgIGxldCBzZXRWYWx1ZSA9IHRydWU7XG5cbiAgICAgICAgaWYgKCRpbnB1dCkge1xuICAgICAgICAgICAgY29uc3QgY3VycmVudFZhbHVlID0gJHRoaXMudmFsKCk7XG4gICAgICAgICAgICAvKlxuICAgICAgICAgICAgICogSWYgdGhlIGlucHV0IHZhbHVlIGhhcyBiZWVuIHNldCBieSB0aGUgZGV2LCBidXQgbm90IGRpcmVjdGx5IGFzIGFuIGF0dHJpYnV0ZSBpbiB0aGUgaHRtbCwgdGhlbiBpdCB0YWtlc1xuICAgICAgICAgICAgICogcHJlY2VkZW5jZSBhbmQgc2hvdWxkIGdldCBmb3JtYXR0ZWQgb24gaW5pdCAoaWYgdGhpcyBpbnB1dCB2YWx1ZSBpcyBhIHZhbGlkIG51bWJlciBhbmQgdGhhdCB0aGVcbiAgICAgICAgICAgICAqIGRldmVsb3BlciB3YW50cyBpdCBmb3JtYXR0ZWQgb24gaW5pdCAoY2YuIGBzZXR0aW5ncy5mb3JtYXRPblBhZ2VMb2FkYCkpLlxuICAgICAgICAgICAgICogTm90ZTsgdGhpcyBpcyB0cnVlIHdoYXRldmVyIHRoZSBkZXZlbG9wZXIgaGFzIHNldCBmb3IgYGRhdGEtYW4tZGVmYXVsdGAgaW4gdGhlIGh0bWwgKGFzcC5uZXQgdXNlcnMpLlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIEluIG90aGVyIHdvcmRzIDogaWYgYGRlZmF1bHRWYWx1ZU92ZXJyaWRlYCBpcyBub3QgbnVsbCwgaXQgbWVhbnMgdGhlIGRldmVsb3BlciBpcyB0cnlpbmcgdG8gcHJldmVudCBwb3N0YmFjayBwcm9ibGVtcy5cbiAgICAgICAgICAgICAqIEJ1dCBpZiBgaW5wdXQudmFsdWVgIGlzIHNldCB0byBhIG51bWJlciwgYW5kIGAkdGhpcy5hdHRyKCd2YWx1ZScpYCBpcyBub3Qgc2V0LCB0aGVuIGl0IG1lYW5zIHRoZSBkZXYgaGFzXG4gICAgICAgICAgICAgKiBjaGFuZ2VkIHRoZSBpbnB1dCB2YWx1ZSwgYW5kIHRoZW4gaXQgbWVhbnMgd2Ugc2hvdWxkIG5vdCBvdmVyd3JpdGUgaGlzIG93biBkZWNpc2lvbiB0byBkbyBzby5cbiAgICAgICAgICAgICAqIEhlbmNlLCBpZiBgZGVmYXVsdFZhbHVlT3ZlcnJpZGVgIGlzIG5vdCBudWxsLCBidXQgYGlucHV0LnZhbHVlYCBpcyBhIG51bWJlciBhbmQgYCR0aGlzLmF0dHIoJ3ZhbHVlJylgIGlzIG5vdCBzZXQsXG4gICAgICAgICAgICAgKiB3ZSBzaG91bGQgaWdub3JlIGBkZWZhdWx0VmFsdWVPdmVycmlkZWAgYWx0b2dldGhlci5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgY29uc3QgdW5Mb2NhbGl6ZWRDdXJyZW50VmFsdWUgPSB0b051bWVyaWNWYWx1ZShjdXJyZW50VmFsdWUsIHNldHRpbmdzKTsgLy8gVGhpcyBhbGxvd3MgdG8gdXNlIGEgbG9jYWxpemVkIHZhbHVlIG9uIHN0YXJ0dXAgb0RlY1xuICAgICAgICAgICAgaWYgKHNldHRpbmdzLmZvcm1hdE9uUGFnZUxvYWQgJiYgY3VycmVudFZhbHVlICE9PSAnJyAmJiBpc1VuZGVmaW5lZE9yTnVsbE9yRW1wdHkoJHRoaXMuYXR0cigndmFsdWUnKSkpIHtcbiAgICAgICAgICAgICAgICAvLyBDaGVjayBpZiB0aGUgYHZhbHVlYCBpcyB2YWxpZCBvciBub3RcbiAgICAgICAgICAgICAgICBpZiAoIWlzTmFOKHVuTG9jYWxpemVkQ3VycmVudFZhbHVlKSAmJiBJbmZpbml0eSAhPT0gdW5Mb2NhbGl6ZWRDdXJyZW50VmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgJHRoaXMuYXV0b051bWVyaWMoJ3NldCcsIHVuTG9jYWxpemVkQ3VycmVudFZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgc2V0VmFsdWUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBJZiBub3QsIGluZm9ybSB0aGUgZGV2ZWxvcGVyIHRoYXQgbm90aGluZyB1c2FibGUgaGFzIGJlZW4gcHJvdmlkZWRcbiAgICAgICAgICAgICAgICAgICAgdGhyb3dFcnJvcihgVGhlIHZhbHVlIFske2N1cnJlbnRWYWx1ZX1dIHVzZWQgaW4gdGhlIGlucHV0IGlzIG5vdCBhIHZhbGlkIHZhbHVlIGF1dG9OdW1lcmljIGNhbiB3b3JrIHdpdGguYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvKiBDaGVja3MgZm9yIDpcbiAgICAgICAgICAgICAgICAgKiAtIHBhZ2UgcmVsb2FkIGZyb20gYmFjayBidXR0b24sIGFuZFxuICAgICAgICAgICAgICAgICAqIC0gQVNQLm5ldCBmb3JtIHBvc3QgYmFja1xuICAgICAgICAgICAgICAgICAqICAgICAgVGhlIGZvbGxvd2luZyBIVE1MIGRhdGEgYXR0cmlidXRlIGlzIFJFUVVJUkVEIChkYXRhLWFuLWRlZmF1bHQ9XCJzYW1lIHZhbHVlIGFzIHRoZSB2YWx1ZSBhdHRyaWJ1dGVcIilcbiAgICAgICAgICAgICAgICAgKiAgICAgIGV4YW1wbGU6IDxhc3A6VGV4dEJveCBydW5hdD1cInNlcnZlclwiIGlkPVwic29tZUlEXCIgdGV4dD1cIjEyMzQuNTZcIiBkYXRhLWFuLWRlZmF1bHQ9XCIxMjM0LjU2XCI+XG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgaWYgKChzZXR0aW5ncy5kZWZhdWx0VmFsdWVPdmVycmlkZSAhPT0gbnVsbCAmJiBzZXR0aW5ncy5kZWZhdWx0VmFsdWVPdmVycmlkZS50b1N0cmluZygpICE9PSBjdXJyZW50VmFsdWUpIHx8XG4gICAgICAgICAgICAgICAgICAgIChzZXR0aW5ncy5kZWZhdWx0VmFsdWVPdmVycmlkZSA9PT0gbnVsbCAmJiBjdXJyZW50VmFsdWUgIT09ICcnICYmIGN1cnJlbnRWYWx1ZSAhPT0gJHRoaXMuYXR0cigndmFsdWUnKSkgfHxcbiAgICAgICAgICAgICAgICAgICAgKGN1cnJlbnRWYWx1ZSAhPT0gJycgJiYgJHRoaXMuYXR0cigndHlwZScpID09PSAnaGlkZGVuJyAmJiAhaXNOdW1iZXIodW5Mb2NhbGl6ZWRDdXJyZW50VmFsdWUpKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoKHNldHRpbmdzLmRlY2ltYWxQbGFjZXNTaG93bk9uRm9jdXMgIT09IG51bGwgJiYgc2V0dGluZ3Muc2F2ZVZhbHVlVG9TZXNzaW9uU3RvcmFnZSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIChzZXR0aW5ncy5zY2FsZURpdmlzb3IgJiYgc2V0dGluZ3Muc2F2ZVZhbHVlVG9TZXNzaW9uU3RvcmFnZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldHRpbmdzLnJhd1ZhbHVlID0gc2F2ZVZhbHVlVG9QZXJzaXN0ZW50U3RvcmFnZSgkdGhpc1swXSwgc2V0dGluZ3MsICdnZXQnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZSBkZWNpbWFsUGxhY2VzU2hvd25PbkZvY3VzIHZhbHVlIHNob3VsZCBOT1QgYmUgc2F2ZWQgaW4gc2Vzc2lvblN0b3JhZ2VcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFzZXR0aW5ncy5zYXZlVmFsdWVUb1Nlc3Npb25TdG9yYWdlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgdG9TdHJpcDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNldHRpbmdzLm5lZ2F0aXZlQnJhY2tldHNUeXBlT25CbHVyICE9PSBudWxsICYmIHNldHRpbmdzLm5lZ2F0aXZlU2lnbkNoYXJhY3RlciAhPT0gJycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXR0aW5ncy5oYXNGb2N1cyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9TdHJpcCA9IHRvZ2dsZU5lZ2F0aXZlQnJhY2tldChjdXJyZW50VmFsdWUsIHNldHRpbmdzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9TdHJpcCA9IGN1cnJlbnRWYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChzZXR0aW5ncy5uZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudCA9PT0gJ3MnIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKHNldHRpbmdzLm5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50ICE9PSAncCcgJiYgc2V0dGluZ3MuY3VycmVuY3lTeW1ib2xQbGFjZW1lbnQgPT09ICdzJykpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3MubmVnYXRpdmVTaWduQ2hhcmFjdGVyICE9PSAnJyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzTmVnYXRpdmUoY3VycmVudFZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldHRpbmdzLnJhd1ZhbHVlID0gc2V0dGluZ3MubmVnYXRpdmVTaWduQ2hhcmFjdGVyICsgc3RyaXBBbGxOb25OdW1iZXJDaGFyYWN0ZXJzKHRvU3RyaXAsIHNldHRpbmdzLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3MucmF3VmFsdWUgPSBzdHJpcEFsbE5vbk51bWJlckNoYXJhY3RlcnModG9TdHJpcCwgc2V0dGluZ3MsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgc2V0VmFsdWUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChjdXJyZW50VmFsdWUgPT09ICcnKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChzZXR0aW5ncy5lbXB0eUlucHV0QmVoYXZpb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnZm9jdXMnOlxuICAgICAgICAgICAgICAgICAgICAgICAgc2V0VmFsdWUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdhbHdheXMnOlxuICAgICAgICAgICAgICAgICAgICAgICAgJHRoaXMudmFsKHNldHRpbmdzLmN1cnJlbmN5U3ltYm9sKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldFZhbHVlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnemVybyc6XG4gICAgICAgICAgICAgICAgICAgICAgICAkdGhpcy5hdXRvTnVtZXJpYygnc2V0JywgJzAnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldFZhbHVlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdCA6XG4gICAgICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChzZXRWYWx1ZSAmJiBjdXJyZW50VmFsdWUgPT09ICR0aGlzLmF0dHIoJ3ZhbHVlJykpIHtcbiAgICAgICAgICAgICAgICAkdGhpcy5hdXRvTnVtZXJpYygnc2V0JywgY3VycmVudFZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc0luQXJyYXkoJHRoaXMucHJvcCgndGFnTmFtZScpLnRvTG93ZXJDYXNlKCksIHNldHRpbmdzLnRhZ0xpc3QpICYmICR0aGlzLnRleHQoKSAhPT0gJycpIHtcbiAgICAgICAgICAgIGlmIChzZXR0aW5ncy5kZWZhdWx0VmFsdWVPdmVycmlkZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmIChzZXR0aW5ncy5kZWZhdWx0VmFsdWVPdmVycmlkZSA9PT0gJHRoaXMudGV4dCgpKSB7XG4gICAgICAgICAgICAgICAgICAgICR0aGlzLmF1dG9OdW1lcmljKCdzZXQnLCAkdGhpcy50ZXh0KCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgJHRoaXMuYXV0b051bWVyaWMoJ3NldCcsICR0aGlzLnRleHQoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFbmhhbmNlIHRoZSB1c2VyIGV4cGVyaWVuY2UgYnkgbW9kaWZ5aW5nIHRoZSBkZWZhdWx0IGBuZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudGAgb3B0aW9uIGRlcGVuZGluZyBvbiBgY3VycmVuY3lTeW1ib2xgIGFuZCBgY3VycmVuY3lTeW1ib2xQbGFjZW1lbnRgLlxuICAgICAqXG4gICAgICogSWYgdGhlIHVzZXIgaGFzIG5vdCBzZXQgdGhlIHBsYWNlbWVudCBvZiB0aGUgbmVnYXRpdmUgc2lnbiAoYG5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50YCksIGJ1dCBoYXMgc2V0IGEgY3VycmVuY3kgc3ltYm9sIChgY3VycmVuY3lTeW1ib2xgKSxcbiAgICAgKiB0aGVuIHdlIG1vZGlmeSB0aGUgZGVmYXVsdCB2YWx1ZSBvZiBgbmVnYXRpdmVQb3NpdGl2ZVNpZ25QbGFjZW1lbnRgIGluIG9yZGVyIHRvIGtlZXAgdGhlIHJlc3VsdGluZyBvdXRwdXQgbG9naWNhbCBieSBkZWZhdWx0IDpcbiAgICAgKiAtIFwiJC0xLDIzNC41NlwiIGluc3RlYWQgb2YgXCItJDEsMjM0LjU2XCIgKHtjdXJyZW5jeVN5bWJvbDogXCIkXCIsIG5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50OiBcInJcIn0pXG4gICAgICogLSBcIi0xLDIzNC41NiRcIiBpbnN0ZWFkIG9mIFwiMSwyMzQuNTYtJFwiICh7Y3VycmVuY3lTeW1ib2w6IFwiJFwiLCBjdXJyZW5jeVN5bWJvbFBsYWNlbWVudDogXCJzXCIsIG5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50OiBcInBcIn0pXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3NcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjb3JyZWN0TmVnYXRpdmVQb3NpdGl2ZVNpZ25QbGFjZW1lbnRPcHRpb24oc2V0dGluZ3MpIHtcbiAgICAgICAgLy8gSWYgbmVnYXRpdmVQb3NpdGl2ZVNpZ25QbGFjZW1lbnQgaXMgYWxyZWFkeSBzZXQsIHdlIGRvIG5vdCBvdmVyd3JpdGUgaXRcbiAgICAgICAgaWYgKCFpc051bGwoc2V0dGluZ3MubmVnYXRpdmVQb3NpdGl2ZVNpZ25QbGFjZW1lbnQpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKHNldHRpbmdzKSAmJlxuICAgICAgICAgICAgaXNVbmRlZmluZWRPck51bGxPckVtcHR5KHNldHRpbmdzLm5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50KSAmJlxuICAgICAgICAgICAgIWlzVW5kZWZpbmVkT3JOdWxsT3JFbXB0eShzZXR0aW5ncy5jdXJyZW5jeVN5bWJvbCkpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoc2V0dGluZ3MuY3VycmVuY3lTeW1ib2xQbGFjZW1lbnQpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdzJzpcbiAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3MubmVnYXRpdmVQb3NpdGl2ZVNpZ25QbGFjZW1lbnQgPSAncCc7IC8vIERlZmF1bHQgLTEsMjM0LjU2IOKCrFxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdwJzpcbiAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3MubmVnYXRpdmVQb3NpdGl2ZVNpZ25QbGFjZW1lbnQgPSAnbCc7IC8vIERlZmF1bHQgLSQxLDIzNC41NlxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0IDpcbiAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gU2V0cyB0aGUgZGVmYXVsdCB2YWx1ZSBpZiBgbmVnYXRpdmVQb3NpdGl2ZVNpZ25QbGFjZW1lbnRgIGlzIGBudWxsYFxuICAgICAgICAgICAgc2V0dGluZ3MubmVnYXRpdmVQb3NpdGl2ZVNpZ25QbGFjZW1lbnQgPSAnbCc7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBbmFseXplIGFuZCBzYXZlIHRoZSBtaW5pbXVtVmFsdWUgYW5kIG1heGltdW1WYWx1ZSBpbnRlZ2VyIHNpemUgZm9yIGxhdGVyIHVzZXNcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5nc1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNhbGN1bGF0ZVZNaW5BbmRWTWF4SW50ZWdlclNpemVzKHNldHRpbmdzKSB7XG4gICAgICAgIGxldCBbbWF4aW11bVZhbHVlSW50ZWdlclBhcnRdID0gc2V0dGluZ3MubWF4aW11bVZhbHVlLnRvU3RyaW5nKCkuc3BsaXQoJy4nKTtcbiAgICAgICAgbGV0IFttaW5pbXVtVmFsdWVJbnRlZ2VyUGFydF0gPSAoIXNldHRpbmdzLm1pbmltdW1WYWx1ZSAmJiBzZXR0aW5ncy5taW5pbXVtVmFsdWUgIT09IDApP1tdOnNldHRpbmdzLm1pbmltdW1WYWx1ZS50b1N0cmluZygpLnNwbGl0KCcuJyk7XG4gICAgICAgIG1heGltdW1WYWx1ZUludGVnZXJQYXJ0ID0gbWF4aW11bVZhbHVlSW50ZWdlclBhcnQucmVwbGFjZSgnLScsICcnKTtcbiAgICAgICAgbWluaW11bVZhbHVlSW50ZWdlclBhcnQgPSBtaW5pbXVtVmFsdWVJbnRlZ2VyUGFydC5yZXBsYWNlKCctJywgJycpO1xuXG4gICAgICAgIHNldHRpbmdzLm1JbnRQb3MgPSBNYXRoLm1heChtYXhpbXVtVmFsdWVJbnRlZ2VyUGFydC5sZW5ndGgsIDEpO1xuICAgICAgICBzZXR0aW5ncy5tSW50TmVnID0gTWF0aC5tYXgobWluaW11bVZhbHVlSW50ZWdlclBhcnQubGVuZ3RoLCAxKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNb2RpZnkgYGRlY2ltYWxQbGFjZXNPdmVycmlkZWAgYXMgbmVlZGVkXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3NcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjb3JyZWN0RGVjaW1hbFBsYWNlc092ZXJyaWRlT3B0aW9uKHNldHRpbmdzKSB7XG4gICAgICAgIGlmIChpc051bGwoc2V0dGluZ3MuZGVjaW1hbFBsYWNlc092ZXJyaWRlKSkge1xuICAgICAgICAgICAgc2V0dGluZ3MuZGVjaW1hbFBsYWNlc092ZXJyaWRlID0gbWF4aW11bVZNaW5BbmRWTWF4RGVjaW1hbExlbmd0aChzZXR0aW5ncy5taW5pbXVtVmFsdWUsIHNldHRpbmdzLm1heGltdW1WYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0dGluZ3Mub0RlYyA9IFN0cmluZyhzZXR0aW5ncy5kZWNpbWFsUGxhY2VzT3ZlcnJpZGUpO1xuXG4gICAgICAgIC8vIE1vc3QgY2FsY3VsdXMgYXNzdW1lIGBkZWNpbWFsUGxhY2VzT3ZlcnJpZGVgIGlzIGFuIGludGVnZXIsIHRoZSBmb2xsb3dpbmcgc3RhdGVtZW50IG1ha2VzIGl0IGNsZWFyIChvdGhlcndpc2UgaGF2aW5nIGl0IGFzIGEgc3RyaW5nIGxlYWRzIHRvIHByb2JsZW1zIGluIHJvdW5kaW5nIGZvciBpbnN0YW5jZSlcbiAgICAgICAgc2V0dGluZ3MuZGVjaW1hbFBsYWNlc092ZXJyaWRlID0gTnVtYmVyKHNldHRpbmdzLmRlY2ltYWxQbGFjZXNPdmVycmlkZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgYWx0ZXJuYXRpdmUgZGVjaW1hbCBzZXBhcmF0b3Iga2V5LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHNldHRpbmdzXG4gICAgICovXG4gICAgZnVuY3Rpb24gc2V0c0FsdGVybmF0aXZlRGVjaW1hbFNlcGFyYXRvckNoYXJhY3RlcihzZXR0aW5ncykge1xuICAgICAgICBpZiAoaXNOdWxsKHNldHRpbmdzLmRlY2ltYWxDaGFyYWN0ZXJBbHRlcm5hdGl2ZSkgJiYgTnVtYmVyKHNldHRpbmdzLmRlY2ltYWxQbGFjZXNPdmVycmlkZSkgPiAwKSB7XG4gICAgICAgICAgICBpZiAoc2V0dGluZ3MuZGVjaW1hbENoYXJhY3RlciA9PT0gJy4nICYmIHNldHRpbmdzLmRpZ2l0R3JvdXBTZXBhcmF0b3IgIT09ICcsJykge1xuICAgICAgICAgICAgICAgIHNldHRpbmdzLmRlY2ltYWxDaGFyYWN0ZXJBbHRlcm5hdGl2ZSA9ICcsJztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc2V0dGluZ3MuZGVjaW1hbENoYXJhY3RlciA9PT0gJywnICYmIHNldHRpbmdzLmRpZ2l0R3JvdXBTZXBhcmF0b3IgIT09ICcuJykge1xuICAgICAgICAgICAgICAgIHNldHRpbmdzLmRlY2ltYWxDaGFyYWN0ZXJBbHRlcm5hdGl2ZSA9ICcuJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhY2hlcyByZWd1bGFyIGV4cHJlc3Npb25zIGZvciBzdHJpcEFsbE5vbk51bWJlckNoYXJhY3RlcnNcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5nc1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNhY2hlc1VzdWFsUmVndWxhckV4cHJlc3Npb25zKHNldHRpbmdzKSB7XG4gICAgICAgIGNvbnN0IGFsbE51bWJlcnNSZWcgPSAnWzAtOV0nO1xuICAgICAgICBjb25zdCBub0FsbE51bWJlcnNSZWcgPSAnW14wLTldJztcblxuICAgICAgICAvLyBUZXN0IGlmIHRoZXJlIGlzIGEgbmVnYXRpdmUgY2hhcmFjdGVyIGluIHRoZSBzdHJpbmdcbiAgICAgICAgY29uc3QgYU5lZ1JlZyA9IHNldHRpbmdzLm5lZ2F0aXZlU2lnbkNoYXJhY3Rlcj9gKFstXFxcXCR7c2V0dGluZ3MubmVnYXRpdmVTaWduQ2hhcmFjdGVyfV0/KWA6JygtPyknO1xuICAgICAgICBzZXR0aW5ncy5hTmVnUmVnQXV0b1N0cmlwID0gYU5lZ1JlZztcblxuICAgICAgICBsZXQgbmVnYXRpdmVTaWduUmVnUGFydDtcbiAgICAgICAgaWYgKHNldHRpbmdzLm5lZ2F0aXZlU2lnbkNoYXJhY3Rlcikge1xuICAgICAgICAgICAgbmVnYXRpdmVTaWduUmVnUGFydCA9IGBcXFxcJHtzZXR0aW5ncy5uZWdhdGl2ZVNpZ25DaGFyYWN0ZXJ9YDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5lZ2F0aXZlU2lnblJlZ1BhcnQgPSAnJztcbiAgICAgICAgfVxuICAgICAgICBzZXR0aW5ncy5za2lwRmlyc3RBdXRvU3RyaXAgPSBuZXcgUmVnRXhwKGAke2FOZWdSZWd9W14tJHtuZWdhdGl2ZVNpZ25SZWdQYXJ0fVxcXFwke3NldHRpbmdzLmRlY2ltYWxDaGFyYWN0ZXJ9JHthbGxOdW1iZXJzUmVnfV0uKj8oJHthbGxOdW1iZXJzUmVnfXxcXFxcJHtzZXR0aW5ncy5kZWNpbWFsQ2hhcmFjdGVyfSR7YWxsTnVtYmVyc1JlZ30pYCk7XG4gICAgICAgIHNldHRpbmdzLnNraXBMYXN0QXV0b1N0cmlwID0gbmV3IFJlZ0V4cChgKCR7YWxsTnVtYmVyc1JlZ31cXFxcJHtzZXR0aW5ncy5kZWNpbWFsQ2hhcmFjdGVyfT8pW15cXFxcJHtzZXR0aW5ncy5kZWNpbWFsQ2hhcmFjdGVyfSR7YWxsTnVtYmVyc1JlZ31dJHtub0FsbE51bWJlcnNSZWd9KiRgKTtcblxuICAgICAgICBjb25zdCBhbGxvd2VkID0gYC0wMTIzNDU2Nzg5XFxcXCR7c2V0dGluZ3MuZGVjaW1hbENoYXJhY3Rlcn1gO1xuICAgICAgICBzZXR0aW5ncy5hbGxvd2VkQXV0b1N0cmlwID0gbmV3IFJlZ0V4cChgW14ke2FsbG93ZWR9XWAsICdnJyk7XG4gICAgICAgIHNldHRpbmdzLm51bVJlZ0F1dG9TdHJpcCA9IG5ldyBSZWdFeHAoYCR7YU5lZ1JlZ30oPzpcXFxcJHtzZXR0aW5ncy5kZWNpbWFsQ2hhcmFjdGVyfT8oJHthbGxOdW1iZXJzUmVnfStcXFxcJHtzZXR0aW5ncy5kZWNpbWFsQ2hhcmFjdGVyfSR7YWxsTnVtYmVyc1JlZ30rKXwoJHthbGxOdW1iZXJzUmVnfSooPzpcXFxcJHtzZXR0aW5ncy5kZWNpbWFsQ2hhcmFjdGVyfSR7YWxsTnVtYmVyc1JlZ30qKT8pKWApO1xuXG4gICAgICAgIC8vIFVzaW5nIHRoaXMgcmVnZXggdmVyc2lvbiBgXiR7c2V0dGluZ3MuYU5lZ1JlZ0F1dG9TdHJpcH0wKihcXFxcZHwkKWAgZW50aXJlbHkgY2xlYXIgdGhlIGlucHV0IG9uIGJsdXJcbiAgICAgICAgc2V0dGluZ3Muc3RyaXBSZWcgPSBuZXcgUmVnRXhwKGBeJHtzZXR0aW5ncy5hTmVnUmVnQXV0b1N0cmlwfTAqKCR7YWxsTnVtYmVyc1JlZ30pYCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTW9kaWZ5IHRoZSB1c2VyIHNldHRpbmdzIHRvIG1ha2UgdGhlbSAnZXhwbG9pdGFibGUnIGxhdGVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHNldHRpbmdzXG4gICAgICovXG4gICAgZnVuY3Rpb24gdHJhbnNmb3JtT3B0aW9uc1ZhbHVlc1RvRGVmYXVsdFR5cGVzKHNldHRpbmdzKSB7XG4gICAgICAgICQuZWFjaChzZXR0aW5ncywgKGtleSwgdmFsdWUpID0+IHtcbiAgICAgICAgICAgIC8vIENvbnZlcnQgdGhlIHN0cmluZyAndHJ1ZScgYW5kICdmYWxzZScgdG8gcmVhbCBCb29sZWFuXG4gICAgICAgICAgICBpZiAodmFsdWUgPT09ICd0cnVlJyB8fCB2YWx1ZSA9PT0gJ2ZhbHNlJykge1xuICAgICAgICAgICAgICAgIHNldHRpbmdzW2tleV0gPSB2YWx1ZSA9PT0gJ3RydWUnO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBDb252ZXJ0IG51bWJlcnMgaW4gb3B0aW9ucyB0byBzdHJpbmdzXG4gICAgICAgICAgICAvL1RPRE8gaWYgYSB2YWx1ZSBpcyBhbHJlYWR5IG9mIHR5cGUgJ051bWJlcicsIHNob3VsZG4ndCB3ZSBrZWVwIGl0IGFzIGEgbnVtYmVyIGZvciBmdXJ0aGVyIG1hbmlwdWxhdGlvbiwgaW5zdGVhZCBvZiB1c2luZyBhIHN0cmluZz9cbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInICYmIGtleSAhPT0gJ2FTY2FsZScpIHtcbiAgICAgICAgICAgICAgICBzZXR0aW5nc1trZXldID0gdmFsdWUudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydCB0aGUgb2xkIHNldHRpbmdzIG9wdGlvbnMgbmFtZSB0byBuZXcgb25lcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gICAgICovXG4gICAgZnVuY3Rpb24gY29udmVydE9sZE9wdGlvbnNUb05ld09uZXMob3B0aW9ucykge1xuICAgICAgICAvL1RPRE8gRGVsZXRlIHRoaXMgZnVuY3Rpb24gb25jZSB0aGUgb2xkIG9wdGlvbnMgYXJlIG5vdCB1c2VkIGFueW1vcmVcbiAgICAgICAgY29uc3Qgb2xkT3B0aW9uc0NvbnZlcnRlciA9IHtcbiAgICAgICAgICAgIC8vIE9sZCBvcHRpb24gbmFtZSwgd2l0aCB0aGVpciBjb3JyZXNwb25kaW5nIG5ldyBvcHRpb25cbiAgICAgICAgICAgIGFTZXAgICAgICAgICAgICAgICAgICAgICAgICAgOiAnZGlnaXRHcm91cFNlcGFyYXRvcicsXG4gICAgICAgICAgICBuU2VwICAgICAgICAgICAgICAgICAgICAgICAgIDogJ25vU2VwYXJhdG9yT25Gb2N1cycsXG4gICAgICAgICAgICBkR3JvdXAgICAgICAgICAgICAgICAgICAgICAgIDogJ2RpZ2l0YWxHcm91cFNwYWNpbmcnLFxuICAgICAgICAgICAgYURlYyAgICAgICAgICAgICAgICAgICAgICAgICA6ICdkZWNpbWFsQ2hhcmFjdGVyJyxcbiAgICAgICAgICAgIGFsdERlYyAgICAgICAgICAgICAgICAgICAgICAgOiAnZGVjaW1hbENoYXJhY3RlckFsdGVybmF0aXZlJyxcbiAgICAgICAgICAgIGFTaWduICAgICAgICAgICAgICAgICAgICAgICAgOiAnY3VycmVuY3lTeW1ib2wnLFxuICAgICAgICAgICAgcFNpZ24gICAgICAgICAgICAgICAgICAgICAgICA6ICdjdXJyZW5jeVN5bWJvbFBsYWNlbWVudCcsXG4gICAgICAgICAgICBwTmVnICAgICAgICAgICAgICAgICAgICAgICAgIDogJ25lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50JyxcbiAgICAgICAgICAgIGFTdWZmaXggICAgICAgICAgICAgICAgICAgICAgOiAnc3VmZml4VGV4dCcsXG4gICAgICAgICAgICBvTGltaXRzICAgICAgICAgICAgICAgICAgICAgIDogJ292ZXJyaWRlTWluTWF4TGltaXRzJyxcbiAgICAgICAgICAgIHZNYXggICAgICAgICAgICAgICAgICAgICAgICAgOiAnbWF4aW11bVZhbHVlJyxcbiAgICAgICAgICAgIHZNaW4gICAgICAgICAgICAgICAgICAgICAgICAgOiAnbWluaW11bVZhbHVlJyxcbiAgICAgICAgICAgIG1EZWMgICAgICAgICAgICAgICAgICAgICAgICAgOiAnZGVjaW1hbFBsYWNlc092ZXJyaWRlJyxcbiAgICAgICAgICAgIGVEZWMgICAgICAgICAgICAgICAgICAgICAgICAgOiAnZGVjaW1hbFBsYWNlc1Nob3duT25Gb2N1cycsXG4gICAgICAgICAgICBzY2FsZURlY2ltYWwgICAgICAgICAgICAgICAgIDogJ3NjYWxlRGVjaW1hbFBsYWNlcycsXG4gICAgICAgICAgICBhU3RvciAgICAgICAgICAgICAgICAgICAgICAgIDogJ3NhdmVWYWx1ZVRvU2Vzc2lvblN0b3JhZ2UnLFxuICAgICAgICAgICAgbVJvdW5kICAgICAgICAgICAgICAgICAgICAgICA6ICdyb3VuZGluZ01ldGhvZCcsXG4gICAgICAgICAgICBhUGFkICAgICAgICAgICAgICAgICAgICAgICAgIDogJ2FsbG93RGVjaW1hbFBhZGRpbmcnLFxuICAgICAgICAgICAgbkJyYWNrZXQgICAgICAgICAgICAgICAgICAgICA6ICduZWdhdGl2ZUJyYWNrZXRzVHlwZU9uQmx1cicsXG4gICAgICAgICAgICB3RW1wdHkgICAgICAgICAgICAgICAgICAgICAgIDogJ2VtcHR5SW5wdXRCZWhhdmlvcicsXG4gICAgICAgICAgICBsWmVybyAgICAgICAgICAgICAgICAgICAgICAgIDogJ2xlYWRpbmdaZXJvJyxcbiAgICAgICAgICAgIGFGb3JtICAgICAgICAgICAgICAgICAgICAgICAgOiAnZm9ybWF0T25QYWdlTG9hZCcsXG4gICAgICAgICAgICBzTnVtYmVyICAgICAgICAgICAgICAgICAgICAgIDogJ3NlbGVjdE51bWJlck9ubHknLFxuICAgICAgICAgICAgYW5EZWZhdWx0ICAgICAgICAgICAgICAgICAgICA6ICdkZWZhdWx0VmFsdWVPdmVycmlkZScsXG4gICAgICAgICAgICB1blNldE9uU3VibWl0ICAgICAgICAgICAgICAgIDogJ3VuZm9ybWF0T25TdWJtaXQnLFxuICAgICAgICAgICAgb3V0cHV0VHlwZSAgICAgICAgICAgICAgICAgICA6ICdvdXRwdXRGb3JtYXQnLFxuICAgICAgICAgICAgZGVidWcgICAgICAgICAgICAgICAgICAgICAgICA6ICdzaG93V2FybmluZ3MnLFxuICAgICAgICAgICAgLy8gQ3VycmVudCBvcHRpb25zIDpcbiAgICAgICAgICAgIGRpZ2l0R3JvdXBTZXBhcmF0b3IgICAgICAgICAgOiB0cnVlLFxuICAgICAgICAgICAgbm9TZXBhcmF0b3JPbkZvY3VzICAgICAgICAgICA6IHRydWUsXG4gICAgICAgICAgICBkaWdpdGFsR3JvdXBTcGFjaW5nICAgICAgICAgIDogdHJ1ZSxcbiAgICAgICAgICAgIGRlY2ltYWxDaGFyYWN0ZXIgICAgICAgICAgICAgOiB0cnVlLFxuICAgICAgICAgICAgZGVjaW1hbENoYXJhY3RlckFsdGVybmF0aXZlICA6IHRydWUsXG4gICAgICAgICAgICBjdXJyZW5jeVN5bWJvbCAgICAgICAgICAgICAgIDogdHJ1ZSxcbiAgICAgICAgICAgIGN1cnJlbmN5U3ltYm9sUGxhY2VtZW50ICAgICAgOiB0cnVlLFxuICAgICAgICAgICAgbmVnYXRpdmVQb3NpdGl2ZVNpZ25QbGFjZW1lbnQ6IHRydWUsXG4gICAgICAgICAgICBzaG93UG9zaXRpdmVTaWduICAgICAgICAgICAgIDogdHJ1ZSxcbiAgICAgICAgICAgIHN1ZmZpeFRleHQgICAgICAgICAgICAgICAgICAgOiB0cnVlLFxuICAgICAgICAgICAgb3ZlcnJpZGVNaW5NYXhMaW1pdHMgICAgICAgICA6IHRydWUsXG4gICAgICAgICAgICBtYXhpbXVtVmFsdWUgICAgICAgICAgICAgICAgIDogdHJ1ZSxcbiAgICAgICAgICAgIG1pbmltdW1WYWx1ZSAgICAgICAgICAgICAgICAgOiB0cnVlLFxuICAgICAgICAgICAgZGVjaW1hbFBsYWNlc092ZXJyaWRlICAgICAgICA6IHRydWUsXG4gICAgICAgICAgICBkZWNpbWFsUGxhY2VzU2hvd25PbkZvY3VzICAgIDogdHJ1ZSxcbiAgICAgICAgICAgIHNjYWxlRGl2aXNvciAgICAgICAgICAgICAgICAgOiB0cnVlLFxuICAgICAgICAgICAgc2NhbGVEZWNpbWFsUGxhY2VzICAgICAgICAgICA6IHRydWUsXG4gICAgICAgICAgICBzY2FsZVN5bWJvbCAgICAgICAgICAgICAgICAgIDogdHJ1ZSxcbiAgICAgICAgICAgIHNhdmVWYWx1ZVRvU2Vzc2lvblN0b3JhZ2UgICAgOiB0cnVlLFxuICAgICAgICAgICAgb25JbnZhbGlkUGFzdGUgICAgICAgICAgICAgICA6IHRydWUsXG4gICAgICAgICAgICByb3VuZGluZ01ldGhvZCAgICAgICAgICAgICAgIDogdHJ1ZSxcbiAgICAgICAgICAgIGFsbG93RGVjaW1hbFBhZGRpbmcgICAgICAgICAgOiB0cnVlLFxuICAgICAgICAgICAgbmVnYXRpdmVCcmFja2V0c1R5cGVPbkJsdXIgICA6IHRydWUsXG4gICAgICAgICAgICBlbXB0eUlucHV0QmVoYXZpb3IgICAgICAgICAgIDogdHJ1ZSxcbiAgICAgICAgICAgIGxlYWRpbmdaZXJvICAgICAgICAgICAgICAgICAgOiB0cnVlLFxuICAgICAgICAgICAgZm9ybWF0T25QYWdlTG9hZCAgICAgICAgICAgICA6IHRydWUsXG4gICAgICAgICAgICBzZWxlY3ROdW1iZXJPbmx5ICAgICAgICAgICAgIDogdHJ1ZSxcbiAgICAgICAgICAgIGRlZmF1bHRWYWx1ZU92ZXJyaWRlICAgICAgICAgOiB0cnVlLFxuICAgICAgICAgICAgdW5mb3JtYXRPblN1Ym1pdCAgICAgICAgICAgICA6IHRydWUsXG4gICAgICAgICAgICBvdXRwdXRGb3JtYXQgICAgICAgICAgICAgICAgIDogdHJ1ZSxcbiAgICAgICAgICAgIHNob3dXYXJuaW5ncyAgICAgICAgICAgICAgICAgOiB0cnVlLFxuICAgICAgICAgICAgZmFpbE9uVW5rbm93bk9wdGlvbiAgICAgICAgICA6IHRydWUsXG4gICAgICAgICAgICAvL0ZJWE1FIEZpbmQgYSB3YXkgdG8gZXhjbHVkZSB0aG9zZSBpbnRlcm5hbCBkYXRhIGZyb20gdGhlIHNldHRpbmdzIG9iamVjdCAoaWRlYWxseSBieSB1c2luZyBhbm90aGVyIG9iamVjdCwgb3IgYmV0dGVyIHlldCwgY2xhc3MgYXR0cmlidXRlcykgLS0+XG4gICAgICAgICAgICBoYXNGb2N1cyAgICAgICAgICAgICA6IHRydWUsXG4gICAgICAgICAgICBydW5PbmNlICAgICAgICAgICAgICA6IHRydWUsXG4gICAgICAgICAgICByYXdWYWx1ZSAgICAgICAgICAgICA6IHRydWUsXG4gICAgICAgICAgICB0cmFpbGluZ05lZ2F0aXZlICAgICA6IHRydWUsXG4gICAgICAgICAgICBjYXJldEZpeCAgICAgICAgICAgICA6IHRydWUsXG4gICAgICAgICAgICB0aHJvd0lucHV0ICAgICAgICAgICA6IHRydWUsXG4gICAgICAgICAgICBzdHJpcCAgICAgICAgICAgICAgICA6IHRydWUsXG4gICAgICAgICAgICB0YWdMaXN0ICAgICAgICAgICAgICA6IHRydWUsXG4gICAgICAgICAgICBuZWdhdGl2ZVNpZ25DaGFyYWN0ZXI6IHRydWUsXG4gICAgICAgICAgICBwb3NpdGl2ZVNpZ25DaGFyYWN0ZXI6IHRydWUsXG4gICAgICAgICAgICBtSW50UG9zICAgICAgICAgICAgICA6IHRydWUsXG4gICAgICAgICAgICBtSW50TmVnICAgICAgICAgICAgICA6IHRydWUsXG4gICAgICAgICAgICBvRGVjICAgICAgICAgICAgICAgICA6IHRydWUsXG4gICAgICAgICAgICBvUGFkICAgICAgICAgICAgICAgICA6IHRydWUsXG4gICAgICAgICAgICBvQnJhY2tldCAgICAgICAgICAgICA6IHRydWUsXG4gICAgICAgICAgICBvU2VwICAgICAgICAgICAgICAgICA6IHRydWUsXG4gICAgICAgICAgICBvU2lnbiAgICAgICAgICAgICAgICA6IHRydWUsXG4gICAgICAgICAgICBvU3VmZml4ICAgICAgICAgICAgICA6IHRydWUsXG4gICAgICAgICAgICBhTmVnUmVnQXV0b1N0cmlwICAgICA6IHRydWUsXG4gICAgICAgICAgICBza2lwRmlyc3RBdXRvU3RyaXAgICA6IHRydWUsXG4gICAgICAgICAgICBza2lwTGFzdEF1dG9TdHJpcCAgICA6IHRydWUsXG4gICAgICAgICAgICBhbGxvd2VkQXV0b1N0cmlwICAgICA6IHRydWUsXG4gICAgICAgICAgICBudW1SZWdBdXRvU3RyaXAgICAgICA6IHRydWUsXG4gICAgICAgICAgICBzdHJpcFJlZyAgICAgICAgICAgICA6IHRydWUsXG4gICAgICAgICAgICBob2xkZXIgICAgICAgICAgICAgICA6IHRydWUsXG4gICAgICAgIH07XG5cbiAgICAgICAgZm9yIChjb25zdCBvcHRpb24gaW4gb3B0aW9ucykge1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMuaGFzT3duUHJvcGVydHkob3B0aW9uKSkge1xuICAgICAgICAgICAgICAgIGlmIChvbGRPcHRpb25zQ29udmVydGVyW29wdGlvbl0gPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlIG9wdGlvbiBpcyBhICduZXcnIG9wdGlvbiwgd2UgY29udGludWUgbG9vcGluZ1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAob2xkT3B0aW9uc0NvbnZlcnRlci5oYXNPd25Qcm9wZXJ0eShvcHRpb24pKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEVsc2Ugd2UgaGF2ZSBhbiAnb2xkJyBvcHRpb24gbmFtZVxuICAgICAgICAgICAgICAgICAgICB3YXJuaW5nKGBZb3UgYXJlIHVzaW5nIHRoZSBkZXByZWNhdGVkIG9wdGlvbiBuYW1lICcke29wdGlvbn0nLiBQbGVhc2UgdXNlICcke29sZE9wdGlvbnNDb252ZXJ0ZXJbb3B0aW9uXX0nIGluc3RlYWQgZnJvbSBub3cgb24uIFRoZSBvbGQgb3B0aW9uIG5hbWUgd2lsbCBiZSBkcm9wcGVkIHNvb24uYCwgdHJ1ZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlbiB3ZSBtb2RpZnkgdGhlIGluaXRpYWwgb3B0aW9uIG9iamVjdCB0byB1c2UgdGhlIG5ldyBvcHRpb25zIGluc3RlYWQgb2YgdGhlIG9sZCBvbmVzXG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnNbb2xkT3B0aW9uc0NvbnZlcnRlcltvcHRpb25dXSA9IG9wdGlvbnNbb3B0aW9uXTtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIG9wdGlvbnNbb3B0aW9uXTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG9wdGlvbnMuZmFpbE9uVW5rbm93bk9wdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAvLyAuLi5vciB0aGUgb3B0aW9uIG5hbWUgaXMgdW5rbm93bi4gVGhpcyBtZWFucyB0aGVyZSBpcyBhIHByb2JsZW0gd2l0aCB0aGUgb3B0aW9ucyBvYmplY3QsIHRoZXJlZm9yZSB3ZSB0aHJvdyBhbiBlcnJvci5cbiAgICAgICAgICAgICAgICAgICAgdGhyb3dFcnJvcihgT3B0aW9uIG5hbWUgJyR7b3B0aW9ufScgaXMgdW5rbm93bi4gUGxlYXNlIGZpeCB0aGUgb3B0aW9ucyBwYXNzZWQgdG8gYXV0b051bWVyaWNgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBbmFseXNlIHRoZSBzZXR0aW5ncy9vcHRpb25zIHBhc3NlZCBieSB0aGUgdXNlciwgdmFsaWRhdGUgYW5kIGNsZWFuIHRoZW0sIHRoZW4gcmV0dXJuIHRoZW0uXG4gICAgICogTm90ZTogVGhpcyByZXR1cm5zIGBudWxsYCBpZiBzb21laG93IHRoZSBzZXR0aW5ncyByZXR1cm5lZCBieSBqUXVlcnkgaXMgbm90IGFuIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gICAgICogQHBhcmFtIHtvYmplY3R9ICR0aGlzIGpRdWVyeS1zZWxlY3RlZCBET00gZWxlbWVudFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gdXBkYXRlIC0gSWYgVFJVRSwgdGhlbiB0aGUgc2V0dGluZ3MgYWxyZWFkeSBleGlzdHMgYW5kIHRoaXMgZnVuY3Rpb24gb25seSB1cGRhdGVzIHRoZW0gaW5zdGVhZCBvZiByZWNyZWF0aW5nIHRoZW0gZnJvbSBzY3JhdGNoXG4gICAgICogQHJldHVybnMge29iamVjdHxudWxsfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldEluaXRpYWxTZXR0aW5ncyhvcHRpb25zLCAkdGhpcywgdXBkYXRlID0gZmFsc2UpIHtcbiAgICAgICAgLy8gQXR0ZW1wdCB0byBncmFiIFwiYXV0b051bWVyaWNcIiBzZXR0aW5ncy4gSWYgdGhleSBkbyBub3QgZXhpc3QsIGl0IHJldHVybnMgXCJ1bmRlZmluZWRcIi5cbiAgICAgICAgbGV0IHNldHRpbmdzID0gJHRoaXMuZGF0YSgnYXV0b051bWVyaWMnKTtcblxuICAgICAgICAvLyBJZiB0aGUgdXNlciB1c2VkIG9sZCBvcHRpb25zLCB3ZSBjb252ZXJ0IHRoZW0gdG8gbmV3IG9uZXNcbiAgICAgICAgaWYgKHVwZGF0ZSB8fCAhaXNOdWxsKG9wdGlvbnMpKSB7XG4gICAgICAgICAgICBjb252ZXJ0T2xkT3B0aW9uc1RvTmV3T25lcyhvcHRpb25zKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh1cGRhdGUgfHwgaXNVbmRlZmluZWQoc2V0dGluZ3MpKSB7XG4gICAgICAgICAgICBpZiAodXBkYXRlKSB7XG4gICAgICAgICAgICAgICAgLy8gVGhlIHNldHRpbmdzIGFyZSB1cGRhdGVkXG4gICAgICAgICAgICAgICAgc2V0dGluZ3MgPSAkLmV4dGVuZChzZXR0aW5ncywgb3B0aW9ucyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIElmIHdlIGNvdWxkbid0IGdyYWIgYW55IHNldHRpbmdzLCBjcmVhdGUgdGhlbSBmcm9tIHRoZSBkZWZhdWx0IG9uZXMgYW5kIGNvbWJpbmUgdGhlbSB3aXRoIHRoZSBvcHRpb25zIHBhc3NlZFxuICAgICAgICAgICAgICAgIC8vIFRoZSBzZXR0aW5ncyBhcmUgZ2VuZXJhdGVkIGZvciB0aGUgZmlyc3QgdGltZVxuICAgICAgICAgICAgICAgIC8vIFRoaXMgYWxzbyBhdHRlbXB0IHRvIGdyYWIgdGhlIEhUTUw1IGRhdGEuIElmIGl0IGRvZXNuJ3QgZXhpc3QsIHdlJ2xsIGdldCBcInVuZGVmaW5lZFwiXG4gICAgICAgICAgICAgICAgY29uc3QgdGFnRGF0YSA9ICR0aGlzLmRhdGEoKTtcbiAgICAgICAgICAgICAgICBzZXR0aW5ncyA9ICQuZXh0ZW5kKHt9LCBkZWZhdWx0U2V0dGluZ3MsIHRhZ0RhdGEsIG9wdGlvbnMsIHtcbiAgICAgICAgICAgICAgICAgICAgaGFzRm9jdXMgICAgICAgIDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIHJ1bk9uY2UgICAgICAgICA6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICByYXdWYWx1ZSAgICAgICAgOiAnJyxcbiAgICAgICAgICAgICAgICAgICAgdHJhaWxpbmdOZWdhdGl2ZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIGNhcmV0Rml4ICAgICAgICA6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICB0aHJvd0lucHV0ICAgICAgOiB0cnVlLCAvLyBUaHJvdyBpbnB1dCBldmVudFxuICAgICAgICAgICAgICAgICAgICBzdHJpcCAgICAgICAgICAgOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICB0YWdMaXN0ICAgICAgICAgOiBhbGxvd2VkVGFnTGlzdCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gTW9kaWZ5IHRoZSB1c2VyIHNldHRpbmdzIHRvIG1ha2UgdGhlbSAnZXhwbG9pdGFibGUnXG4gICAgICAgICAgICB0cmFuc2Zvcm1PcHRpb25zVmFsdWVzVG9EZWZhdWx0VHlwZXMoc2V0dGluZ3MpO1xuXG4gICAgICAgICAgICAvLyBJbXByb3ZlIHRoZSBgbmVnYXRpdmVQb3NpdGl2ZVNpZ25QbGFjZW1lbnRgIG9wdGlvbiBpZiBuZWVkZWRcbiAgICAgICAgICAgIGNvcnJlY3ROZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudE9wdGlvbihzZXR0aW5ncyk7XG5cbiAgICAgICAgICAgIC8vIFNldCB0aGUgbmVnYXRpdmUgYW5kIHBvc2l0aXZlIHNpZ25zLCBhcyBuZWVkZWRcbiAgICAgICAgICAgIHNldHRpbmdzLm5lZ2F0aXZlU2lnbkNoYXJhY3RlciA9IHNldHRpbmdzLm1pbmltdW1WYWx1ZSA8IDAgPyAnLScgOiAnJztcbiAgICAgICAgICAgIHNldHRpbmdzLnBvc2l0aXZlU2lnbkNoYXJhY3RlciA9IHNldHRpbmdzLm1heGltdW1WYWx1ZSA+PSAwID8gJysnIDogJyc7XG5cbiAgICAgICAgICAgIC8vIEFkZGl0aW9uYWwgY2hhbmdlcyB0byB0aGUgc2V0dGluZ3Mgb2JqZWN0IChmcm9tIHRoZSBvcmlnaW5hbCBhdXRvQ29kZSgpIGZ1bmN0aW9uKVxuICAgICAgICAgICAgcnVuQ2FsbGJhY2tzRm91bmRJblRoZVNldHRpbmdzT2JqZWN0KCR0aGlzLCBzZXR0aW5ncyk7XG4gICAgICAgICAgICBjYWxjdWxhdGVWTWluQW5kVk1heEludGVnZXJTaXplcyhzZXR0aW5ncyk7XG4gICAgICAgICAgICBjb3JyZWN0RGVjaW1hbFBsYWNlc092ZXJyaWRlT3B0aW9uKHNldHRpbmdzKTtcbiAgICAgICAgICAgIHNldHNBbHRlcm5hdGl2ZURlY2ltYWxTZXBhcmF0b3JDaGFyYWN0ZXIoc2V0dGluZ3MpO1xuICAgICAgICAgICAgY2FjaGVzVXN1YWxSZWd1bGFyRXhwcmVzc2lvbnMoc2V0dGluZ3MpO1xuXG4gICAgICAgICAgICAvLyBWYWxpZGF0ZSB0aGUgc2V0dGluZ3NcbiAgICAgICAgICAgIHZhbGlkYXRlKHNldHRpbmdzLCBmYWxzZSk7IC8vIFRocm93cyBpZiBuZWNlc3NhcnlcblxuICAgICAgICAgICAgLy8gT3JpZ2luYWwgc2V0dGluZ3Mgc2F2ZWQgZm9yIHVzZSB3aGVuIGRlY2ltYWxQbGFjZXNTaG93bk9uRm9jdXMsIHNjYWxlRGl2aXNvciAmIG5vU2VwYXJhdG9yT25Gb2N1cyBvcHRpb25zIGFyZSBiZWluZyB1c2VkXG4gICAgICAgICAgICBrZWVwQW5PcmlnaW5hbFNldHRpbmdzQ29weShzZXR0aW5ncyk7XG5cbiAgICAgICAgICAgIC8vIFNhdmUgb3VyIG5ldyBzZXR0aW5nc1xuICAgICAgICAgICAgJHRoaXMuZGF0YSgnYXV0b051bWVyaWMnLCBzZXR0aW5ncyk7XG5cbiAgICAgICAgICAgIHJldHVybiBzZXR0aW5ncztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydCB0aGUgYHZhbHVlYCBwYXJhbWV0ZXIgdGhhdCBjYW4gZWl0aGVyIGJlIDpcbiAgICAgKiAtIGEgcmVhbCBudW1iZXIsXG4gICAgICogLSBhIHN0cmluZyByZXByZXNlbnRpbmcgYSByZWFsIG51bWJlciwgb3JcbiAgICAgKiAtIGEgc3RyaW5nIHJlcHJlc2VudGluZyBhIGxvY2FsaXplZCBudW1iZXIgKHdpdGggc3BlY2lmaWMgZ3JvdXAgc2VwYXJhdG9ycyBhbmQgZGVjaW1hbCBjaGFyYWN0ZXIpLFxuICAgICAqIC4uLnRvIGEgc3RyaW5nIHJlcHJlc2VudGluZyBhIHJlYWwgJ2phdmFzY3JpcHQnIG51bWJlciAoaWUuICcxMjM0JyBvciAnMTIzNC41NjcnKS5cbiAgICAgKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gcmV0dXJucyBgTmFOYCBpZiBzdWNoIGNvbnZlcnNpb24gZmFpbHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2ludHxmbG9hdHxzdHJpbmd9IHZhbHVlXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHNldHRpbmdzXG4gICAgICogQHJldHVybnMge3N0cmluZ3xOYU59XG4gICAgICovXG4gICAgZnVuY3Rpb24gdG9OdW1lcmljVmFsdWUodmFsdWUsIHNldHRpbmdzKSB7XG4gICAgICAgIGxldCByZXN1bHQ7XG4gICAgICAgIGlmIChpc051bWJlcihOdW1iZXIodmFsdWUpKSkge1xuICAgICAgICAgICAgLy8gVGhlIHZhbHVlIGhhcyBlaXRoZXIgYWxyZWFkeSBiZWVuIHN0cmlwcGVkLCBvciBhICdyZWFsJyBqYXZhc2NyaXB0IG51bWJlciBpcyBwYXNzZWQgYXMgYSBwYXJhbWV0ZXJcbiAgICAgICAgICAgIHJlc3VsdCA9IHZhbHVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gRWxzZSBpZiBpdCdzIGEgc3RyaW5nIHRoYXQgYE51bWJlcigpYCBjYW5ub3QgdHlwZWNhc3QsIHRoZW4gd2UgdHJ5IHRvIGNvbnZlcnQgdGhlIGxvY2FsaXplZCBudW1lcmljIHN0cmluZyB0byBhIG51bWVyaWMgb25lXG4gICAgICAgICAgICAvLyBDb252ZXJ0IHRoZSB2YWx1ZSB0byBhIG51bWVyaWMgc3RyaW5nLCBzdHJpcHBpbmcgdW5uZWNlc3NhcnkgY2hhcmFjdGVycyBpbiB0aGUgcHJvY2Vzc1xuICAgICAgICAgICAgcmVzdWx0ID0gY29udmVydFRvTnVtZXJpY1N0cmluZyh2YWx1ZS50b1N0cmluZygpLCBzZXR0aW5ncyk7XG5cbiAgICAgICAgICAgIC8vIElmIHRoZSByZXN1bHQgaXMgc3RpbGwgbm90IGEgbnVtZXJpYyBzdHJpbmcsIHRoZW4gd2UgdGhyb3cgYSB3YXJuaW5nXG4gICAgICAgICAgICBpZiAoIWlzTnVtYmVyKE51bWJlcihyZXN1bHQpKSkge1xuICAgICAgICAgICAgICAgIHdhcm5pbmcoYFRoZSB2YWx1ZSBcIiR7dmFsdWV9XCIgYmVpbmcgXCJzZXRcIiBpcyBub3QgbnVtZXJpYyBhbmQgdGhlcmVmb3JlIGNhbm5vdCBiZSB1c2VkIGFwcHJvcHJpYXRlbHkuYCwgc2V0dGluZ3Muc2hvd1dhcm5pbmdzKTtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBOYU47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1ldGhvZHMgc3VwcG9ydGVkIGJ5IGF1dG9OdW1lcmljXG4gICAgICovXG4gICAgY29uc3QgbWV0aG9kcyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE1ldGhvZCB0byBpbml0aWFsaXplIGF1dG9OdW1lcmljIGFuZCBhdHRhY2ggdGhlIHNldHRpbmdzIChvcHRpb25zIGNhbiBiZSBwYXNzZWQgYXMgYSBwYXJhbWV0ZXIpXG4gICAgICAgICAqIFRoZSBvcHRpb25zIHBhc3NlZCBhcyBhIHBhcmFtZXRlciBpcyBhbiBvYmplY3QgdGhhdCBjb250YWlucyB0aGUgc2V0dGluZ3MgKGllLiB7ZGlnaXRHcm91cFNlcGFyYXRvcjogXCIuXCIsIGRlY2ltYWxDaGFyYWN0ZXI6IFwiLFwiLCBjdXJyZW5jeVN5bWJvbDogJ+KCrCAnfSlcbiAgICAgICAgICpcbiAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICogJChzb21lU2VsZWN0b3IpLmF1dG9OdW1lcmljKCdpbml0Jyk7ICAgICAgICAgICAgLy8gSW5pdGlhdGUgYXV0b051bWVyaWMgd2l0aCBkZWZhdWx0c1xuICAgICAgICAgKiAkKHNvbWVTZWxlY3RvcikuYXV0b051bWVyaWMoKTsgICAgICAgICAgICAgICAgICAvLyBJbml0aWF0ZSBhdXRvTnVtZXJpYyB3aXRoIGRlZmF1bHRzXG4gICAgICAgICAqICQoc29tZVNlbGVjdG9yKS5hdXRvTnVtZXJpYygnaW5pdCcsIHtvcHRpb25zfSk7IC8vIEluaXRpYXRlIGF1dG9OdW1lcmljIHdpdGggb3B0aW9uc1xuICAgICAgICAgKiAkKHNvbWVTZWxlY3RvcikuYXV0b051bWVyaWMoe29wdGlvbnN9KTsgICAgICAgICAvLyBJbml0aWF0ZSBhdXRvTnVtZXJpYyB3aXRoIG9wdGlvbnNcbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcbiAgICAgICAgICogQHJldHVybnMgeyp8e3N0YXRlbWVudHMsIGJyYW5jaGVzLCBsaW5lcywgZnVuY3Rpb25zLCBleGNsdWRlcywgb3ZlcnJpZGVzfXx7c3RhdGVtZW50cywgYnJhbmNoZXMsIGxpbmVzLCBmdW5jdGlvbnMsIGV4Y2x1ZGVzfXx7c3RhdGVtZW50cywgbGluZXMsIGJyYW5jaGVzLCBmdW5jdGlvbnMsIGV4Y2x1ZGVzfX1cbiAgICAgICAgICovXG4gICAgICAgIGluaXQob3B0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBjb25zdCAkdGhpcyA9ICQodGhpcyk7XG4gICAgICAgICAgICAgICAgY29uc3QgJGlucHV0ID0gZ2V0SW5wdXRJZlN1cHBvcnRlZFRhZ0FuZFR5cGUoJHRoaXMpO1xuXG4gICAgICAgICAgICAgICAgY29uc3Qgc2V0dGluZ3MgPSBnZXRJbml0aWFsU2V0dGluZ3Mob3B0aW9ucywgJHRoaXMsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICBpZiAoaXNOdWxsKHNldHRpbmdzKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBDcmVhdGUgdGhlIEF1dG9OdW1lcmljSG9sZGVyIG9iamVjdCB0aGF0IHN0b3JlIHRoZSBmaWVsZCBwcm9wZXJ0aWVzXG4gICAgICAgICAgICAgICAgY29uc3QgaG9sZGVyID0gZ2V0QXV0b051bWVyaWNIb2xkZXIoJHRoaXMsIHNldHRpbmdzLCBmYWxzZSk7XG5cbiAgICAgICAgICAgICAgICBpZiAoIXNldHRpbmdzLnJ1bk9uY2UgJiYgc2V0dGluZ3MuZm9ybWF0T25QYWdlTG9hZCkge1xuICAgICAgICAgICAgICAgICAgICBmb3JtYXREZWZhdWx0VmFsdWVPblBhZ2VMb2FkKHNldHRpbmdzLCAkaW5wdXQsICR0aGlzKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBzZXR0aW5ncy5ydW5PbmNlID0gdHJ1ZTtcblxuICAgICAgICAgICAgICAgIC8vIEFkZCB0aGUgZXZlbnRzIGxpc3RlbmVycyB0byBzdXBwb3J0ZWQgaW5wdXQgdHlwZXMgKFwidGV4dFwiLCBcImhpZGRlblwiLCBcInRlbFwiIGFuZCBubyB0eXBlKVxuICAgICAgICAgICAgICAgIGlmICgkaW5wdXQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCdmb2N1c2luJywgZSA9PiB7IG9uRm9jdXNJbkFuZE1vdXNlRW50ZXIoJHRoaXMsIGhvbGRlciwgZSk7IH0sIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWVudGVyJywgZSA9PiB7IG9uRm9jdXNJbkFuZE1vdXNlRW50ZXIoJHRoaXMsIGhvbGRlciwgZSk7IH0sIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCdibHVyJywgZSA9PiB7IG9uRm9jdXNPdXRBbmRNb3VzZUxlYXZlKCR0aGlzLCBob2xkZXIsIGUpOyB9LCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcignbW91c2VsZWF2ZScsIGUgPT4geyBvbkZvY3VzT3V0QW5kTW91c2VMZWF2ZSgkdGhpcywgaG9sZGVyLCBlKTsgfSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBlID0+IHsgb25LZXlkb3duKGhvbGRlciwgZSk7IH0sIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCdrZXlwcmVzcycsIGUgPT4geyBvbktleXByZXNzKGhvbGRlciwgZSk7IH0sIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCdrZXl1cCcsIGUgPT4geyBvbktleXVwKGhvbGRlciwgc2V0dGluZ3MsIGUpOyB9LCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcignYmx1cicsIGUgPT4geyBvbkJsdXIoaG9sZGVyLCBlKTsgfSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ3Bhc3RlJywgZSA9PiB7IG9uUGFzdGUoJHRoaXMsIGhvbGRlciwgZSk7IH0sIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgb25TdWJtaXQoJHRoaXMsIGhvbGRlcik7IC8vVE9ETyBTd2l0Y2ggdG8gYGFkZEV2ZW50TGlzdGVuZXInXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIE1ldGhvZCB0byBzdG9wIGFuZCByZW1vdmUgYXV0b051bWVyaWMgZm9yIHRoZSBjdXJyZW50IGVsZW1lbnQuXG4gICAgICAgICAqIE5vdGU6IHRoaXMgZG9lcyBub3QgcmVtb3ZlIHRoZSBmb3JtYXR0aW5nLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZXhhbXBsZSAkKHNvbWVTZWxlY3RvcikuYXV0b051bWVyaWMoXCJkZXN0cm95XCIpOyAvLyBEZXN0cm95cyBhdXRvTnVtZXJpYyBvbiB0aGlzIHNlbGVjdGVkIGVsZW1lbnRcbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybnMgeyp8alF1ZXJ5fVxuICAgICAgICAgKi9cbiAgICAgICAgZGVzdHJveSgpIHtcbiAgICAgICAgICAgIHJldHVybiAkKHRoaXMpLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgJHRoaXMgPSBnZXRDdXJyZW50RWxlbWVudCh0aGlzKTtcbiAgICAgICAgICAgICAgICBjb25zdCBzZXR0aW5ncyA9ICR0aGlzLmRhdGEoJ2F1dG9OdW1lcmljJyk7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBzZXR0aW5ncyA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgJHRoaXMudmFsKCcnKTtcbiAgICAgICAgICAgICAgICAgICAgc2F2ZVZhbHVlVG9QZXJzaXN0ZW50U3RvcmFnZSgkdGhpc1swXSwgc2V0dGluZ3MsICd3aXBlJyk7XG4gICAgICAgICAgICAgICAgICAgICR0aGlzLnJlbW92ZURhdGEoJ2F1dG9OdW1lcmljJyk7XG4gICAgICAgICAgICAgICAgICAgICR0aGlzLm9mZignLmF1dG9OdW1lcmljJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIE1ldGhvZCB0byBjbGVhciB0aGUgdmFsdWUgZnJvbSBzZXNzaW9uU3RvcmFnZSAob3IgY29va2llLCBkZXBlbmRpbmcgb24gYnJvd3NlciBzdXBwb3J0cykuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBleGFtcGxlICQoc29tZVNlbGVjdG9yKS5hdXRvTnVtZXJpYyhcIndpcGVcIik7IC8vIFJlbW92ZXMgc2Vzc2lvbiBzdG9yYWdlIGFuZCBjb29raWVzIGZyb20gbWVtb3J5XG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm5zIHsqfGpRdWVyeX1cbiAgICAgICAgICovXG4gICAgICAgIHdpcGUoKSB7XG4gICAgICAgICAgICByZXR1cm4gJCh0aGlzKS5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGNvbnN0ICR0aGlzID0gZ2V0Q3VycmVudEVsZW1lbnQodGhpcyk7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2V0dGluZ3MgPSAkdGhpcy5kYXRhKCdhdXRvTnVtZXJpYycpO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygc2V0dGluZ3MgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgICAgICR0aGlzLnZhbCgnJyk7XG4gICAgICAgICAgICAgICAgICAgIHNldHRpbmdzLnJhd1ZhbHVlID0gJyc7XG4gICAgICAgICAgICAgICAgICAgIHNhdmVWYWx1ZVRvUGVyc2lzdGVudFN0b3JhZ2UoJHRoaXNbMF0sIHNldHRpbmdzLCAnd2lwZScpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNZXRob2QgdGhhdCB1cGRhdGVzIHRoZSBhdXRvTnVtZXJpYyBzZXR0aW5ncy5cbiAgICAgICAgICogSXQgY2FuIGJlIGNhbGxlZCBtdWx0aXBsZSB0aW1lcyBpZiBuZWVkZWQuXG4gICAgICAgICAqIFRoZSBvcHRpb25zIHBhc3NlZCBhcyBhIHBhcmFtZXRlciBpcyBhbiBvYmplY3QgdGhhdCBjb250YWlucyB0aGUgc2V0dGluZ3MgKGllLiB7ZGlnaXRHcm91cFNlcGFyYXRvcjogXCIuXCIsIGRlY2ltYWxDaGFyYWN0ZXI6IFwiLFwiLCBjdXJyZW5jeVN5bWJvbDogJ+KCrCAnfSkuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBleGFtcGxlICQoc29tZVNlbGVjdG9yKS5hdXRvTnVtZXJpYyhcInVwZGF0ZVwiLCB7b3B0aW9uc30pOyAvLyBVcGRhdGVzIHRoZSBzZXR0aW5nc1xuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICAgICAgICAgKiBAcmV0dXJucyB7KnxqUXVlcnl9XG4gICAgICAgICAqL1xuICAgICAgICB1cGRhdGUob3B0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuICQodGhpcykuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAvLyBSZXRyaWV2ZSB0aGUgY3VycmVudCB1bmZvcm1hdHRlZCBpbnB1dCB2YWx1ZVxuICAgICAgICAgICAgICAgIGNvbnN0ICR0aGlzID0gZ2V0Q3VycmVudEVsZW1lbnQodGhpcyk7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3RyaXAgPSAkdGhpcy5hdXRvTnVtZXJpYygnZ2V0Jyk7XG5cbiAgICAgICAgICAgICAgICAvLyBVcGRhdGUgdGhlIHNldHRpbmdzXG4gICAgICAgICAgICAgICAgY29uc3Qgc2V0dGluZ3MgPSBnZXRJbml0aWFsU2V0dGluZ3Mob3B0aW9ucywgJHRoaXMsIHRydWUpO1xuXG4gICAgICAgICAgICAgICAgLy8gVXBkYXRlIHRoZSBBdXRvTnVtZXJpY0hvbGRlciBvYmplY3QgdGhhdCBzdG9yZSB0aGUgZmllbGQgcHJvcGVydGllc1xuICAgICAgICAgICAgICAgIGdldEF1dG9OdW1lcmljSG9sZGVyKCR0aGlzLCBzZXR0aW5ncywgdHJ1ZSk7XG5cbiAgICAgICAgICAgICAgICAvLyBSZWZvcm1hdCB0aGUgaW5wdXQgdmFsdWUgd2l0aCB0aGUgbmV3IHNldHRpbmdzXG4gICAgICAgICAgICAgICAgaWYgKCR0aGlzLnZhbCgpICE9PSAnJyB8fCAkdGhpcy50ZXh0KCkgIT09ICcnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAkdGhpcy5hdXRvTnVtZXJpYygnc2V0Jywgc3RyaXApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNZXRob2QgdG8gZm9ybWF0IHRoZSB2YWx1ZSBwYXNzZWQgYXMgYSBwYXJhbWV0ZXIuXG4gICAgICAgICAqIElmIHRoZSB2YWx1ZSBpcyBwYXNzZWQgYXMgYSBzdHJpbmcsIGl0IGNhbiBiZSBhbiBpbnRlZ2VyICcxMjM0JyBvciBhIGRvdWJsZSAnMTIzNC41Njc4OSdcbiAgICAgICAgICogYW5kIG11c3QgY29udGFpbiBvbmx5IG51bWJlcnMgYW5kIG9uZSBkZWNpbWFsIChwZXJpb2QpIGNoYXJhY3RlclxuICAgICAgICAgKlxuICAgICAgICAgKiBAZXhhbXBsZSAkKHNvbWVTZWxlY3RvcikuYXV0b051bWVyaWMoJ3NldCcsICcxMjM0NS42NycpOyAvLyBGb3JtYXRzIHRoZSB2YWx1ZSBiZWluZyBwYXNzZWQgYXMgdGhlIHNlY29uZCBwYXJhbWV0ZXJcbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHsqfSBuZXdWYWx1ZVxuICAgICAgICAgKiBAcmV0dXJucyB7KnxqUXVlcnl9XG4gICAgICAgICAqL1xuICAgICAgICBzZXQobmV3VmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiAkKHRoaXMpLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgaWYgKG5ld1ZhbHVlID09PSBudWxsIHx8IGlzVW5kZWZpbmVkKG5ld1ZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy9UT0RPIFRoaXMgbG9va3MgYSBsb3QgbGlrZSBgZ2V0SW5wdXRJZlN1cHBvcnRlZFRhZ0FuZFR5cGUoKWAuIElzIHRoYXQgbmVjZXNzYXJ5PyBDYW4gdGhlIGlucHV0IGVsZW1lbnQgYmUgY2hhbmdlZCBzaW5jZSBhdXRvTnVtZXJpYyBoYXMgYmVlbiBpbml0aWFsaXplZD9cbiAgICAgICAgICAgICAgICBjb25zdCAkdGhpcyA9IGdldEN1cnJlbnRFbGVtZW50KHRoaXMpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHNldHRpbmdzID0gJHRoaXMuZGF0YSgnYXV0b051bWVyaWMnKTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHNldHRpbmdzICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgICAgICB0aHJvd0Vycm9yKGBJbml0aWFsaXppbmcgYXV0b051bWVyaWMgaXMgcmVxdWlyZWQgcHJpb3IgdG8gY2FsbGluZyB0aGUgXCJzZXRcIiBtZXRob2QuYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFJlc2V0IHRoZSB0cmFpbGluZyBuZWdhdGl2ZSBzZXR0aW5ncywgc2luY2UgaXQncyBwb3NzaWJsZSB0aGUgcHJldmlvdXMgdmFsdWUgd2FzIG5lZ2F0aXZlLCBidXQgbm90IHRoZSBuZXdseSBzZXQgb25lXG4gICAgICAgICAgICAgICAgc2V0dGluZ3MudHJhaWxpbmdOZWdhdGl2ZSA9IGZhbHNlO1xuXG4gICAgICAgICAgICAgICAgY29uc3QgJGlucHV0ID0gJHRoaXMuaXMoJ2lucHV0W3R5cGU9dGV4dF0sIGlucHV0W3R5cGU9aGlkZGVuXSwgaW5wdXRbdHlwZT10ZWxdLCBpbnB1dDpub3QoW3R5cGVdKScpO1xuXG4gICAgICAgICAgICAgICAgbGV0IHZhbHVlID0gdG9OdW1lcmljVmFsdWUobmV3VmFsdWUsIHNldHRpbmdzKTtcbiAgICAgICAgICAgICAgICBpZiAoaXNOYU4odmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAkdGhpcy52YWwoJycpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gJycpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgW21pblRlc3QsIG1heFRlc3RdID0gY2hlY2tJZkluUmFuZ2VXaXRoT3ZlcnJpZGVPcHRpb24odmFsdWUsIHNldHRpbmdzKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyB0ZXN0IGlzIG5lZWRlZCBieSB0aGUgc2hvd1Bvc2l0aXZlU2lnbiBvcHRpb25cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaXNaZXJvID0gaXNaZXJvT3JIYXNOb1ZhbHVlKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzWmVybykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSAnMCc7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAobWluVGVzdCAmJiBtYXhUZXN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoJGlucHV0IHx8IGlzSW5BcnJheSgkdGhpcy5wcm9wKCd0YWdOYW1lJykudG9Mb3dlckNhc2UoKSwgc2V0dGluZ3MudGFnTGlzdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0byBlbnN1cmUgcm91bmRpbmcgZG9lcyBub3QgaGFwcGVuIHR3aWNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGhhc0JlZW5Sb3VuZGVkID0gZmFsc2U7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyByb3VuZHMgdGhlIHRoZSBleHRlbmRlZCBkZWNpbWFsIHBsYWNlc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCB0ZW1wRGVjaW1hbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2V0dGluZ3MuZGVjaW1hbFBsYWNlc1Nob3duT25Gb2N1cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZW1wRGVjaW1hbCA9IHNldHRpbmdzLmRlY2ltYWxQbGFjZXNPdmVycmlkZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3MuZGVjaW1hbFBsYWNlc092ZXJyaWRlID0gTnVtYmVyKHNldHRpbmdzLmRlY2ltYWxQbGFjZXNTaG93bk9uRm9jdXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHJvdW5kVmFsdWUodmFsdWUsIHNldHRpbmdzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGFzQmVlblJvdW5kZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXR0aW5ncy5kZWNpbWFsUGxhY2VzT3ZlcnJpZGUgPSB0ZW1wRGVjaW1hbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2V0dGluZ3Muc2NhbGVEaXZpc29yICYmICFzZXR0aW5ncy5vbk9mZikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHJvdW5kVmFsdWUodmFsdWUsIHNldHRpbmdzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3MucmF3VmFsdWUgPSBjbGVhbkxlYWRpbmdUcmFpbGluZ1plcm9zKHZhbHVlLnJlcGxhY2Uoc2V0dGluZ3MuZGVjaW1hbENoYXJhY3RlciwgJy4nKSwgc2V0dGluZ3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHRvTnVtZXJpY1ZhbHVlKHZhbHVlLCBzZXR0aW5ncyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUgLyBzZXR0aW5ncy5zY2FsZURpdmlzb3I7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUudG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNldHRpbmdzLnNjYWxlRGVjaW1hbFBsYWNlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGVtcERlY2ltYWwgPSBzZXR0aW5ncy5kZWNpbWFsUGxhY2VzT3ZlcnJpZGU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXR0aW5ncy5kZWNpbWFsUGxhY2VzT3ZlcnJpZGUgPSBOdW1iZXIoc2V0dGluZ3Muc2NhbGVEZWNpbWFsUGxhY2VzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gcm91bmRWYWx1ZSh2YWx1ZSwgc2V0dGluZ3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGFzQmVlblJvdW5kZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUm91bmRzIGlmIHRoaXMgaGFzIG5vdCBiZWVuIGRvbmUgYWxyZWFkeVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaGFzQmVlblJvdW5kZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSByb3VuZFZhbHVlKHZhbHVlLCBzZXR0aW5ncyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU3RvcmVzIHJhd1ZhbHVlIGluY2x1ZGluZyB0aGUgZGVjaW1hbFBsYWNlc1Nob3duT25Gb2N1c1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghc2V0dGluZ3Muc2NhbGVEaXZpc29yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldHRpbmdzLnJhd1ZhbHVlID0gY2xlYW5MZWFkaW5nVHJhaWxpbmdaZXJvcyh2YWx1ZS5yZXBsYWNlKHNldHRpbmdzLmRlY2ltYWxDaGFyYWN0ZXIsICcuJyksIHNldHRpbmdzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IG1vZGlmeU5lZ2F0aXZlU2lnbkFuZERlY2ltYWxDaGFyYWN0ZXJGb3JGb3JtYXR0ZWRWYWx1ZSh2YWx1ZSwgc2V0dGluZ3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gYWRkR3JvdXBTZXBhcmF0b3JzKHZhbHVlLCBzZXR0aW5ncyk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2V0dGluZ3Muc2NhbGVEaXZpc29yICYmIHNldHRpbmdzLnNjYWxlRGVjaW1hbFBsYWNlcyAmJiAhc2V0dGluZ3Mub25PZmYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3MuZGVjaW1hbFBsYWNlc092ZXJyaWRlID0gdGVtcERlY2ltYWw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2V0dGluZ3Muc2F2ZVZhbHVlVG9TZXNzaW9uU3RvcmFnZSAmJiAoc2V0dGluZ3MuZGVjaW1hbFBsYWNlc1Nob3duT25Gb2N1cyB8fCBzZXR0aW5ncy5zY2FsZURpdmlzb3IpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2F2ZVZhbHVlVG9QZXJzaXN0ZW50U3RvcmFnZSgkdGhpc1swXSwgc2V0dGluZ3MsICdzZXQnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldHRpbmdzLnJhd1ZhbHVlID0gJyc7XG4gICAgICAgICAgICAgICAgICAgICAgICBzYXZlVmFsdWVUb1BlcnNpc3RlbnRTdG9yYWdlKCR0aGlzWzBdLCBzZXR0aW5ncywgJ3dpcGUnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGF0dGVtcHRlZFZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9ICcnO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFtaW5UZXN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJHRoaXMudHJpZ2dlcignYXV0b051bWVyaWM6bWluRXhjZWVkZWQnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFtYXhUZXN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJHRoaXMudHJpZ2dlcignYXV0b051bWVyaWM6bWF4RXhjZWVkZWQnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3dFcnJvcihgVGhlIHZhbHVlIFske2F0dGVtcHRlZFZhbHVlfV0gYmVpbmcgc2V0IGZhbGxzIG91dHNpZGUgb2YgdGhlIG1pbmltdW1WYWx1ZSBbJHtzZXR0aW5ncy5taW5pbXVtVmFsdWV9XSBhbmQgbWF4aW11bVZhbHVlIFske3NldHRpbmdzLm1heGltdW1WYWx1ZX1dIHJhbmdlIHNldCBmb3IgdGhpcyBlbGVtZW50YCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAkdGhpcy52YWwoJycpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICR0aGlzLnZhbCgnJyk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKCFzZXR0aW5ncy5oYXNGb2N1cyAmJiBzZXR0aW5ncy5zY2FsZVN5bWJvbCkge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlICsgc2V0dGluZ3Muc2NhbGVTeW1ib2w7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKCRpbnB1dCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJHRoaXMudmFsKHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoaXNJbkFycmF5KCR0aGlzLnByb3AoJ3RhZ05hbWUnKS50b0xvd2VyQ2FzZSgpLCBzZXR0aW5ncy50YWdMaXN0KSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJHRoaXMudGV4dCh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIE1ldGhvZCB0byB1bi1mb3JtYXQgaW5wdXRzLlxuICAgICAgICAgKiBUaGlzIGlzIGhhbmR5IHRvIHVzZSByaWdodCBiZWZvcmUgZm9ybSBzdWJtaXNzaW9uLlxuICAgICAgICAgKlxuICAgICAgICAgKiBCeSBkZWZhdWx0LCB2YWx1ZXMgYXJlIHJldHVybmVkIGFzIElTTyBudW1lcmljIHN0cmluZ3MgKGllLiBcIjEyMzQuNTZcIiBvciBcIi0xMjM0LjU2XCIpLCB3aGVyZSB0aGUgZGVjaW1hbCBjaGFyYWN0ZXIgaXMgYSBwZXJpb2QuXG4gICAgICAgICAqIExvY2FsZSBmb3JtYXRzIGFyZSBzdXBwb3J0ZWQgXCIxMjM0LjU2LVwiIG9yIFwiMTIzNCw1NlwiIG9yIFwiLTEyMzQsNTYgb3IgXCIxMjM0LDU2LVwiLCBvciBldmVuIHBsYWluIG51bWJlcnMuXG4gICAgICAgICAqIFBsZWFzZSBzZWUgb3B0aW9uIFwib3V0cHV0Rm9ybWF0XCIgZm9yIG1vcmUgZGV0YWlsc1xuICAgICAgICAgKlxuICAgICAgICAgKiBAZXhhbXBsZSAkKHNvbWVTZWxlY3RvcikuYXV0b051bWVyaWMoJ3VuU2V0Jyk7XG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm5zIHsqfGpRdWVyeX1cbiAgICAgICAgICovXG4gICAgICAgIHVuU2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuICQodGhpcykuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBjb25zdCAkdGhpcyA9IGdldEN1cnJlbnRFbGVtZW50KHRoaXMpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHNldHRpbmdzID0gJHRoaXMuZGF0YSgnYXV0b051bWVyaWMnKTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHNldHRpbmdzID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgICAgICBzZXR0aW5ncy5oYXNGb2N1cyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICR0aGlzLnZhbCgkdGhpcy5hdXRvTnVtZXJpYygnZ2V0TG9jYWxpemVkJykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNZXRob2QgdG8gcmUtZm9ybWF0IGlucHV0cy5cbiAgICAgICAgICogVGhpcyBpcyBoYW5keSB0byB1c2UgcmlnaHQgYWZ0ZXIgZm9ybSBzdWJtaXNzaW9uLlxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGlzIGlzIGNhbGxlZCBhZnRlciB0aGUgJ3VuU2V0JyBtZXRob2QgdG8gcmVmb3JtYXQgdGhlIGlucHV0XG4gICAgICAgICAqXG4gICAgICAgICAqIEBleGFtcGxlICQoc29tZVNlbGVjdG9yKS5hdXRvTnVtZXJpYygncmVTZXQnKTtcbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybnMgeyp8alF1ZXJ5fVxuICAgICAgICAgKi9cbiAgICAgICAgcmVTZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gJCh0aGlzKS5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGNvbnN0ICR0aGlzID0gZ2V0Q3VycmVudEVsZW1lbnQodGhpcyk7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2V0dGluZ3MgPSAkdGhpcy5kYXRhKCdhdXRvTnVtZXJpYycpO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygc2V0dGluZ3MgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgICAgICR0aGlzLmF1dG9OdW1lcmljKCdzZXQnLCAkdGhpcy52YWwoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybiB0aGUgdW5mb3JtYXR0ZWQgdmFsdWUgYXMgYSBzdHJpbmcuXG4gICAgICAgICAqXG4gICAgICAgICAqIEB1c2FnZSAkKHNvbWVTZWxlY3RvcikuYXV0b051bWVyaWMoJ2dldCcpO1xuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0KCkge1xuICAgICAgICAgICAgLy9UT0RPIFdoeSB3b3VsZCB3ZSBuZWVkIHRvIGdldCBhIG5ldyByZWZlcmVuY2UgdG8gJHRoaXMgc2luY2UgaXQgaGFzIGJlZW4gZG9uZSBpbiBgaW5pdCgpYD9cbiAgICAgICAgICAgIGNvbnN0ICR0aGlzID0gZ2V0Q3VycmVudEVsZW1lbnQodGhpcyk7XG4gICAgICAgICAgICAvL1RPRE8gVGhpcyBsb29rcyBhIGxvdCBsaWtlIGBnZXRJbnB1dElmU3VwcG9ydGVkVGFnQW5kVHlwZSgpYC4gSXMgdGhhdCBuZWNlc3Nhcnk/IENhbiB0aGUgaW5wdXQgZWxlbWVudCBiZSBjaGFuZ2VkIHNpbmNlIGF1dG9OdW1lcmljIGhhcyBiZWVuIGluaXRpYWxpemVkP1xuICAgICAgICAgICAgY29uc3QgJGlucHV0ID0gJHRoaXMuaXMoJ2lucHV0W3R5cGU9dGV4dF0sIGlucHV0W3R5cGU9aGlkZGVuXSwgaW5wdXRbdHlwZT10ZWxdLCBpbnB1dDpub3QoW3R5cGVdKScpO1xuICAgICAgICAgICAgY29uc3Qgc2V0dGluZ3MgPSAkdGhpcy5kYXRhKCdhdXRvTnVtZXJpYycpO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBzZXR0aW5ncyAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICB0aHJvd0Vycm9yKGBJbml0aWFsaXppbmcgYXV0b051bWVyaWMgaXMgcmVxdWlyZWQgcHJpb3IgdG8gY2FsbGluZyB0aGUgXCJnZXRcIiBtZXRob2QuYCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGRldGVybWluZSB0aGUgZWxlbWVudCB0eXBlIHRoZW4gdXNlIC5lcSgwKSBzZWxlY3RvciB0byBncmFiIHRoZSB2YWx1ZSBvZiB0aGUgZmlyc3QgZWxlbWVudCBpbiBzZWxlY3RvclxuICAgICAgICAgICAgbGV0IHZhbHVlID0gJyc7XG4gICAgICAgICAgICBpZiAoJGlucHV0KSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSAkdGhpcy5lcSgwKS52YWwoKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaXNJbkFycmF5KCR0aGlzLnByb3AoJ3RhZ05hbWUnKS50b0xvd2VyQ2FzZSgpLCBzZXR0aW5ncy50YWdMaXN0KSkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gJHRoaXMuZXEoMCkudGV4dCgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvd0Vycm9yKGBUaGUgXCI8JHskdGhpcy5wcm9wKCd0YWdOYW1lJykudG9Mb3dlckNhc2UoKX0+XCIgdGFnIGlzIG5vdCBzdXBwb3J0ZWQgYnkgYXV0b051bWVyaWNgKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHNldHRpbmdzLmRlY2ltYWxQbGFjZXNTaG93bk9uRm9jdXMgfHwgc2V0dGluZ3Muc2NhbGVEaXZpc29yKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBzZXR0aW5ncy5yYXdWYWx1ZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gVGVzdCBpZiB0aGUgdmFsdWUgaXMgbmVnYXRpdmVcbiAgICAgICAgICAgICAgICBjb25zdCBpc1ZhbHVlTmVnYXRpdmUgPSBpc05lZ2F0aXZlKHZhbHVlKTtcblxuICAgICAgICAgICAgICAgIGlmICghKC9cXGQvKS50ZXN0KHZhbHVlKSAmJiBzZXR0aW5ncy5lbXB0eUlucHV0QmVoYXZpb3IgPT09ICdmb2N1cycpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gJycgJiYgc2V0dGluZ3MubmVnYXRpdmVCcmFja2V0c1R5cGVPbkJsdXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3MuaGFzRm9jdXMgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHRvZ2dsZU5lZ2F0aXZlQnJhY2tldCh2YWx1ZSwgc2V0dGluZ3MpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChzZXR0aW5ncy5ydW5PbmNlIHx8IHNldHRpbmdzLmZvcm1hdE9uUGFnZUxvYWQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFN0cmlwcyB0cmFpbGluZyBuZWdhdGl2ZSBzeW1ib2xcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBzdHJpcEFsbE5vbk51bWJlckNoYXJhY3RlcnModmFsdWUsIHNldHRpbmdzLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gVHJpbXMgbGVhZGluZyBhbmQgdHJhaWxpbmcgemVyb3Mgd2hlbiBsZWFkaW5nWmVybyBkb2VzIE5PVCBlcXVhbCBcImtlZXBcIi5cbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBjbGVhbkxlYWRpbmdUcmFpbGluZ1plcm9zKHZhbHVlLnJlcGxhY2Uoc2V0dGluZ3MuZGVjaW1hbENoYXJhY3RlciwgJy4nKSwgc2V0dGluZ3MpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIFBsYWNlcyB0aGUgbmVnYXRpdmUgc3ltYm9sIGluIGZyb250IG9mIHRoZSB0cmFpbGluZyBuZWdhdGl2ZVxuICAgICAgICAgICAgICAgICAgICBpZiAoc2V0dGluZ3MudHJhaWxpbmdOZWdhdGl2ZSAmJiBpc1ZhbHVlTmVnYXRpdmUgJiYgIWlzTmVnYXRpdmUodmFsdWUpICYmIE51bWJlcih2YWx1ZSkgIT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gJy0nICsgdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgIT09ICcnIHx8IHZhbHVlID09PSAnJyAmJiBzZXR0aW5ncy5lbXB0eUlucHV0QmVoYXZpb3IgPT09ICd6ZXJvJykge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IG1vZGlmeU5lZ2F0aXZlU2lnbkFuZERlY2ltYWxDaGFyYWN0ZXJGb3JSYXdWYWx1ZSh2YWx1ZSwgc2V0dGluZ3MpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQWx3YXlzIHJldHVybiBhIG51bWVyaWMgc3RyaW5nXG4gICAgICAgICAgICAvLyBUaGlzIGdldHMgcmlkIG9mIHRoZSB0cmFpbGluZyB6ZXJvcyBpbiB0aGUgZGVjaW1hbCBwbGFjZXMgc2luY2UgYGdldGAgZG9lcyBub3QgcGFkIGRlY2ltYWxzXG4gICAgICAgICAgICByZXR1cm4gdHJpbVBhZGRlZFplcm9zRnJvbURlY2ltYWxQbGFjZXModmFsdWUpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIHRoZSB1bmZvcm1hdHRlZCB2YWx1ZSwgYnV0IGZvbGxvd2luZyB0aGUgYG91dHB1dEZvcm1hdGAgc2V0dGluZywgd2hpY2ggbWVhbnMgdGhlIG91dHB1dCBjYW4gZWl0aGVyIGJlIDpcbiAgICAgICAgICogLSBhIHN0cmluZyAodGhhdCBjb3VsZCBvciBjb3VsZCBub3QgcmVwcmVzZW50IGEgbnVtYmVyIChpZS4gXCIxMjM0NSw2Ny1cIikpLCBvclxuICAgICAgICAgKiAtIGEgcGxhaW4gbnVtYmVyIChpZiB0aGUgc2V0dGluZyAnbnVtYmVyJyBpcyB1c2VkKS5cbiAgICAgICAgICpcbiAgICAgICAgICogQnkgZGVmYXVsdCB0aGUgcmV0dXJuZWQgdmFsdWVzIGFyZSBhbiBJU08gbnVtZXJpYyBzdHJpbmcgXCIxMjM0LjU2XCIgb3IgXCItMTIzNC41NlwiIHdoZXJlIHRoZSBkZWNpbWFsIGNoYXJhY3RlciBpcyBhIHBlcmlvZC5cbiAgICAgICAgICogQ2hlY2sgdGhlIFwib3V0cHV0Rm9ybWF0XCIgb3B0aW9uIGRlZmluaXRpb24gZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgICAgICpcbiAgICAgICAgICogQHVzYWdlICQoc29tZVNlbGVjdG9yKS5hdXRvTnVtZXJpYygnZ2V0TG9jYWxpemVkJyk7XG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0TG9jYWxpemVkKCkge1xuICAgICAgICAgICAgY29uc3QgJHRoaXMgPSBnZXRDdXJyZW50RWxlbWVudCh0aGlzKTtcbiAgICAgICAgICAgIGxldCB2YWx1ZSA9ICR0aGlzLmF1dG9OdW1lcmljKCdnZXQnKTtcbiAgICAgICAgICAgIGNvbnN0IHNldHRpbmdzID0gJHRoaXMuZGF0YSgnYXV0b051bWVyaWMnKTtcblxuICAgICAgICAgICAgaWYgKE51bWJlcih2YWx1ZSkgPT09IDAgJiYgc2V0dGluZ3MubGVhZGluZ1plcm8gIT09ICdrZWVwJykge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gJzAnO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdG9Mb2NhbGUodmFsdWUsIHNldHRpbmdzLm91dHB1dEZvcm1hdCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybiB0aGUgaW5wdXQgdW5mb3JtYXR0ZWQgdmFsdWUgYXMgYSByZWFsIEphdmFzY3JpcHQgbnVtYmVyLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAdXNhZ2UgJChzb21lU2VsZWN0b3IpLmF1dG9OdW1lcmljKCdnZXROdW1iZXInKTtcbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIGdldE51bWJlcigpIHtcbiAgICAgICAgICAgIGNvbnN0ICR0aGlzID0gZ2V0Q3VycmVudEVsZW1lbnQodGhpcyk7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9ICR0aGlzLmF1dG9OdW1lcmljKCdnZXQnKTtcblxuICAgICAgICAgICAgcmV0dXJuIHRvTG9jYWxlKHZhbHVlLCAnbnVtYmVyJyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybiB0aGUgY3VycmVudCBmb3JtYXR0ZWQgdmFsdWUgb2YgdGhlIGF1dG9OdW1lcmljIGVsZW1lbnQuXG4gICAgICAgICAqIEB1c2FnZSBhTklucHV0LmF1dG9OdW1lcmljKCdnZXRGb3JtYXR0ZWQnKSlcbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgICAgICovXG4gICAgICAgIGdldEZvcm1hdHRlZCgpIHtcbiAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSBgdGhpc1swXWAgZXhpc3RzIGFzIHdlbGwgYXMgYC52YWx1ZWAgYmVmb3JlIHRyeWluZyB0byBhY2Nlc3MgdGhhdCBwcm9wZXJ0eVxuICAgICAgICAgICAgaWYgKCF0aGlzLmhhc093blByb3BlcnR5KCcwJykgfHwgISgndmFsdWUnIGluIHRoaXNbMF0pKSB7XG4gICAgICAgICAgICAgICAgdGhyb3dFcnJvcignVW5hYmxlIHRvIGdldCB0aGUgZm9ybWF0dGVkIHN0cmluZyBmcm9tIHRoZSBlbGVtZW50LicpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdGhpc1swXS52YWx1ZTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIFwiZ2V0U3RyaW5nXCIgbWV0aG9kIHVzZXMgalF1ZXJ5J3MgLnNlcmlhbGl6ZSgpIG1ldGhvZCB0aGF0IGNyZWF0ZXMgYSB0ZXh0IHN0cmluZyBpbiBzdGFuZGFyZCBVUkwtZW5jb2RlZCBub3RhdGlvbi5cbiAgICAgICAgICpcbiAgICAgICAgICogSXQgdGhlbiBsb29wcyB0aHJvdWdoIHRoZSBzdHJpbmcgYW5kIHVuLWZvcm1hdHMgdGhlIGlucHV0cyB3aXRoIGF1dG9OdW1lcmljLlxuICAgICAgICAgKiBCeSBkZWZhdWx0cyB2YWx1ZXMgcmV0dXJuZWQgYXMgSVNPIG51bWVyaWMgc3RyaW5nIFwiMTIzNC41NlwiIG9yIFwiLTEyMzQuNTZcIiB3aGVyZSB0aGUgZGVjaW1hbCBjaGFyYWN0ZXIgaXMgYSBwZXJpb2RcbiAgICAgICAgICogTG9jYWxlIGZvcm1hdHMgYXJlIHN1cHBvcnRlZCBcIjEyMzQuNTYtXCIgb3IgXCIxMjM0LDU2XCIgb3IgXCItMTIzNCw1NiBvciBcIjEyMzQsNTYtXCIgb3IgcGxhaW4gbnVtYmVycyA9PiBwbGVhc2Ugc2VlIG9wdGlvbiBcIm91dHB1dEZvcm1hdFwiIGZvciBkZXRhaWxzXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICAgICAqL1xuICAgICAgICBnZXRTdHJpbmcoKSB7XG4gICAgICAgICAgICByZXR1cm4gX2dldFN0cmluZ09yQXJyYXkoZmFsc2UsIHRoaXMpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgXCJnZXRBcnJheVwiIG1ldGhvZCBvbiB0aGUgb3RoZXIgaGFuZCB1c2VzIGpRdWVyeSdzIC5zZXJpYWxpemVBcnJheSgpIG1ldGhvZCB0aGF0IGNyZWF0ZXMgYXJyYXkgb3Igb2JqZWN0cyB0aGF0IGNhbiBiZSBlbmNvZGVkIGFzIGEgSlNPTiBzdHJpbmcuXG4gICAgICAgICAqXG4gICAgICAgICAqIEl0IHRoZW4gbG9vcHMgdGhyb3VnaCB0aGUgc3RyaW5nIGFuZCB1bi1mb3JtYXRzIHRoZSBpbnB1dHMgd2l0aCBhdXRvTnVtZXJpYy5cbiAgICAgICAgICogQnkgZGVmYXVsdHMgdmFsdWVzIHJldHVybmVkIGFzIElTTyBudW1lcmljIHN0cmluZyBcIjEyMzQuNTZcIiBvciBcIi0xMjM0LjU2XCIgd2hlcmUgdGhlIGRlY2ltYWwgY2hhcmFjdGVyIGlzIGEgcGVyaW9kXG4gICAgICAgICAqIExvY2FsZSBmb3JtYXRzIGFyZSBzdXBwb3J0ZWQgXCIxMjM0LjU2LVwiIG9yIFwiMTIzNCw1NlwiIG9yIFwiLTEyMzQsNTYgb3IgXCIxMjM0LDU2LVwiIG9yIHBsYWluIG51bWJlcnMgPT4gcGxlYXNlIHNlZSBvcHRpb24gXCJvdXRwdXRGb3JtYXRcIiBmb3IgZGV0YWlsc1xuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJucyB7e318W119XG4gICAgICAgICAqL1xuICAgICAgICBnZXRBcnJheSgpIHtcbiAgICAgICAgICAgIHJldHVybiBfZ2V0U3RyaW5nT3JBcnJheSh0cnVlLCB0aGlzKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlICdnZXRTZXR0aW5ncycgZnVuY3Rpb24gcmV0dXJucyBhbiBvYmplY3QgY29udGFpbmluZyBhbGwgdGhlIGN1cnJlbnQgYXV0b051bWVyaWMgc2V0dGluZ3MuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqICQoc29tZVNlbGVjdG9yKS5hdXRvTnVtZXJpYygnZ2V0U2V0dGluZ3MnKTtcbiAgICAgICAgICogJChzb21lU2VsZWN0b3IpLmF1dG9OdW1lcmljKCdnZXRTZXR0aW5ncycpLmRlY2ltYWxDaGFyYWN0ZXI7IC8vIFJldHVybiB0aGUgZGVjaW1hbENoYXJhY3RlciBzZXR0aW5nIGFzIGEgc3RyaW5nIC0gYW55IHZhbGlkIG9wdGlvbiBuYW1lIGNhbiBiZSB1c2VkXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm5zIHtvYmplY3R9XG4gICAgICAgICAqL1xuICAgICAgICBnZXRTZXR0aW5ncygpIHtcbiAgICAgICAgICAgIC8vVE9ETyBBZGQgYW4gb3B0aW9uIGFyZ3VtZW50IGBvcHRpb25OYW1lYCB0byB0aGlzIGZ1bmN0aW9uIHNvIHRoYXQgaXQgcmV0dXJuIG9ubHkgdGhlIHZhbHVlIG9mIHRoYXQgb3B0aW9uLCBub3QgdGhlIGVudGlyZSBzZXR0aW5ncyBvYmplY3RcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRhdGEoJ2F1dG9OdW1lcmljJyk7XG4gICAgICAgIH0sXG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBhdXRvTnVtZXJpYyBmdW5jdGlvbiBhY2NlcHRzIG1ldGhvZHMgbmFtZXMgKGluIHN0cmluZyBmb3JtYXQpIGFuZCB0aG9zZSBtZXRob2QgcGFyYW1ldGVycyBpZiBuZWVkZWQuXG4gICAgICogSXQgaW5pdGlhbGl6ZSBhdXRvTnVtZXJpYyBvbiB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBtZXRob2QgVGhlIG1ldGhvZCBuYW1lIChpZS4gJ3NldCcsICdnZXQnLCBldGMuKVxuICAgICAqIEBwYXJhbSB7Kn0gYXJnc1xuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqL1xuICAgICQuZm4uYXV0b051bWVyaWMgPSBmdW5jdGlvbihtZXRob2QsIC4uLmFyZ3MpIHtcbiAgICAgICAgaWYgKG1ldGhvZHNbbWV0aG9kXSkge1xuICAgICAgICAgICAgcmV0dXJuIG1ldGhvZHNbbWV0aG9kXS5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgbWV0aG9kID09PSAnb2JqZWN0JyB8fCAhbWV0aG9kKSB7XG4gICAgICAgICAgICAvLyBUaGUgb3B0aW9ucyBoYXZlIGJlZW4gcGFzc2VkIGRpcmVjdGx5LCB3aXRob3V0IHVzaW5nIGEgbmFtZWQgbWV0aG9kXG4gICAgICAgICAgICByZXR1cm4gbWV0aG9kcy5pbml0LmFwcGx5KHRoaXMsIFttZXRob2RdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRocm93RXJyb3IoYE1ldGhvZCBcIiR7bWV0aG9kfVwiIGlzIG5vdCBzdXBwb3J0ZWQgYnkgYXV0b051bWVyaWNgKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSBkZWZhdWx0IGF1dG9OdW1lcmljIHNldHRpbmdzLlxuICAgICAqXG4gICAgICogQHJldHVybnMge29iamVjdH1cbiAgICAgKi9cbiAgICBnZXREZWZhdWx0Q29uZmlnID0gKCkgPT4gZGVmYXVsdFNldHRpbmdzO1xuXG4gICAgJC5mbi5hdXRvTnVtZXJpYy5kZWZhdWx0cyA9IGRlZmF1bHRTZXR0aW5nczsgLy8gTWFrZSB0aG9zZSBzZXR0aW5ncyBwdWJsaWMgdmlhIGpRdWVyeSB0b28uXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gYWxsIHRoZSBwcmVkZWZpbmVkIGxhbmd1YWdlIG9wdGlvbnMgaW4gb25lIG9iamVjdC5cbiAgICAgKiBZb3UgY2FuIGFsc28gYWNjZXNzIGEgc3BlY2lmaWMgbGFuZ3VhZ2Ugb2JqZWN0IGRpcmVjdGx5IGJ5IHVzaW5nIGBhbi5nZXRMYW5ndWFnZXMoKS5GcmVuY2hgIGZvciBpbnN0YW5jZS5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtvYmplY3R9XG4gICAgICovXG4gICAgZ2V0TGFuZ3VhZ2VzID0gKCkgPT4gbGFuZ3VhZ2VPcHRpb247XG5cbiAgICAkLmZuLmF1dG9OdW1lcmljLmxhbmcgPSBsYW5ndWFnZU9wdGlvbjsgLy8gTWFrZSB0aG9zZSBwcmVkZWZpbmVkIGxhbmd1YWdlIG9wdGlvbnMgcHVibGljIHZpYSBqUXVlcnkgdG9vLlxuXG4gICAgLyoqXG4gICAgICogUHVibGljIGZ1bmN0aW9uIHRoYXQgYWxsb3dzIGZvcm1hdHRpbmcgd2l0aG91dCBhbiBlbGVtZW50IHRyaWdnZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcnxzdHJpbmd9IHZhbHVlIEEgbnVtYmVyLCBvciBhIHN0cmluZyB0aGF0IHJlcHJlc2VudCBhIGphdmFzY3JpcHQgbnVtYmVyXG4gICAgICogQHBhcmFtIHtvYmplY3R8bnVsbH0gb3B0aW9uc1xuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqL1xuICAgIGF1dG9Gb3JtYXQgPSAodmFsdWUsIG9wdGlvbnMgPSBudWxsKSA9PiB7XG4gICAgICAgIGlmIChpc1VuZGVmaW5lZCh2YWx1ZSkgfHwgdmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFpc1N0cmluZyh2YWx1ZSkgJiYgIWlzTnVtYmVyKHZhbHVlKSkge1xuICAgICAgICAgICAgdGhyb3dFcnJvcihgVGhlIHZhbHVlIFwiJHt2YWx1ZX1cIiBiZWluZyBcInNldFwiIGlzIG5vdCBudW1lcmljIGFuZCB0aGVyZWZvcmUgY2Fubm90IGJlIHVzZWQgYXBwcm9wcmlhdGVseS5gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEluaXRpYXRlIGEgdmVyeSBiYXNpYyBzZXR0aW5ncyBvYmplY3RcbiAgICAgICAgY29uc3Qgc2V0dGluZ3MgPSAkLmV4dGVuZCh7fSwgZGVmYXVsdFNldHRpbmdzLCB7IHN0cmlwOiBmYWxzZSB9LCBvcHRpb25zKTtcbiAgICAgICAgaWYgKHZhbHVlIDwgMCkge1xuICAgICAgICAgICAgc2V0dGluZ3MubmVnYXRpdmVTaWduQ2hhcmFjdGVyID0gJy0nO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzTnVsbChzZXR0aW5ncy5kZWNpbWFsUGxhY2VzT3ZlcnJpZGUpKSB7XG4gICAgICAgICAgICBzZXR0aW5ncy5kZWNpbWFsUGxhY2VzT3ZlcnJpZGUgPSBtYXhpbXVtVk1pbkFuZFZNYXhEZWNpbWFsTGVuZ3RoKHNldHRpbmdzLm1pbmltdW1WYWx1ZSwgc2V0dGluZ3MubWF4aW11bVZhbHVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENoZWNrIHRoZSB2YWxpZGl0eSBvZiB0aGUgYHZhbHVlYCBwYXJhbWV0ZXJcbiAgICAgICAgLy8gQ29udmVydCB0aGUgdmFsdWUgdG8gYSBudW1lcmljIHN0cmluZywgc3RyaXBwaW5nIHVubmVjZXNzYXJ5IGNoYXJhY3RlcnMgaW4gdGhlIHByb2Nlc3NcbiAgICAgICAgbGV0IHZhbHVlU3RyaW5nID0gdG9OdW1lcmljVmFsdWUodmFsdWUsIHNldHRpbmdzKTtcbiAgICAgICAgaWYgKGlzTmFOKHZhbHVlU3RyaW5nKSkge1xuICAgICAgICAgICAgdGhyb3dFcnJvcihgVGhlIHZhbHVlIFske3ZhbHVlU3RyaW5nfV0gdGhhdCB5b3UgYXJlIHRyeWluZyB0byBmb3JtYXQgaXMgbm90IGEgcmVjb2duaXplZCBudW1iZXIuYCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBCYXNpYyB0ZXN0cyB0byBjaGVjayBpZiB0aGUgZ2l2ZW4gdmFsdWVTdHJpbmcgaXMgdmFsaWRcbiAgICAgICAgY29uc3QgW21pblRlc3QsIG1heFRlc3RdID0gY2hlY2tJZkluUmFuZ2VXaXRoT3ZlcnJpZGVPcHRpb24odmFsdWVTdHJpbmcsIHNldHRpbmdzKTtcbiAgICAgICAgaWYgKCFtaW5UZXN0IHx8ICFtYXhUZXN0KSB7XG4gICAgICAgICAgICAvLyBUaHJvdyBhIGN1c3RvbSBldmVudFxuICAgICAgICAgICAgdHJpZ2dlckV2ZW50KCdhdXRvRm9ybWF0LmF1dG9OdW1lcmljJywgZG9jdW1lbnQsIGBSYW5nZSB0ZXN0IGZhaWxlZGApO1xuICAgICAgICAgICAgdGhyb3dFcnJvcihgVGhlIHZhbHVlIFske3ZhbHVlU3RyaW5nfV0gYmVpbmcgc2V0IGZhbGxzIG91dHNpZGUgb2YgdGhlIG1pbmltdW1WYWx1ZSBbJHtzZXR0aW5ncy5taW5pbXVtVmFsdWV9XSBhbmQgbWF4aW11bVZhbHVlIFske3NldHRpbmdzLm1heGltdW1WYWx1ZX1dIHJhbmdlIHNldCBmb3IgdGhpcyBlbGVtZW50YCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBFdmVyeXRoaW5nIGlzIG9rLCBwcm9jZWVkIHRvIHJvdW5kaW5nLCBmb3JtYXR0aW5nIGFuZCBncm91cGluZ1xuICAgICAgICB2YWx1ZVN0cmluZyA9IHJvdW5kVmFsdWUodmFsdWVTdHJpbmcsIHNldHRpbmdzKTtcbiAgICAgICAgdmFsdWVTdHJpbmcgPSBtb2RpZnlOZWdhdGl2ZVNpZ25BbmREZWNpbWFsQ2hhcmFjdGVyRm9yRm9ybWF0dGVkVmFsdWUodmFsdWVTdHJpbmcsIHNldHRpbmdzKTtcbiAgICAgICAgdmFsdWVTdHJpbmcgPSBhZGRHcm91cFNlcGFyYXRvcnModmFsdWVTdHJpbmcsIHNldHRpbmdzKTtcblxuICAgICAgICByZXR1cm4gdmFsdWVTdHJpbmc7XG4gICAgfTtcblxuICAgICQuZm4uYXV0b0Zvcm1hdCA9IGF1dG9Gb3JtYXQ7IC8vIFRoZSBqUXVlcnkgZXhwb3J0XG5cbiAgICAvKipcbiAgICAgKiBQdWJsaWMgZnVuY3Rpb24gdGhhdCBhbGxvd3MgdW5mb3JtYXR0aW5nIHdpdGhvdXQgYW4gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqL1xuICAgIGF1dG9VbkZvcm1hdCA9ICh2YWx1ZSwgb3B0aW9ucykgPT4ge1xuICAgICAgICBpZiAoaXNVbmRlZmluZWQodmFsdWUpIHx8IHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEdpdmluZyBhbiB1bmZvcm1hdHRlZCB2YWx1ZSBzaG91bGQgcmV0dXJuIHRoZSBzYW1lIHVuZm9ybWF0dGVkIHZhbHVlLCB3aGF0ZXZlciB0aGUgb3B0aW9ucyBwYXNzZWQgYXMgYSBwYXJhbWV0ZXJcbiAgICAgICAgaWYgKGlzTnVtYmVyKHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIE51bWJlcih2YWx1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNBcnJheSh2YWx1ZSkgfHwgaXNPYmplY3QodmFsdWUpKSB7IC8vVE9ETyBDb21wbGV0ZSB0aGUgdGVzdCB0byB0aHJvdyB3aGVuIGdpdmVuIGEgd3JvbmdseSBmb3JtYXR0ZWQgbnVtYmVyIChpZS4gJ2Zvb2JhcicpXG4gICAgICAgICAgICAvLyBDaGVjayB0aGUgdmFsaWRpdHkgb2YgdGhlIGB2YWx1ZWAgcGFyYW1ldGVyXG4gICAgICAgICAgICB0aHJvd0Vycm9yKGBBIG51bWJlciBvciBhIHN0cmluZyByZXByZXNlbnRpbmcgYSBudW1iZXIgaXMgbmVlZGVkIHRvIGJlIGFibGUgdG8gdW5mb3JtYXQgaXQsIFske3ZhbHVlfV0gZ2l2ZW4uYCk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBzZXR0aW5ncyA9ICQuZXh0ZW5kKHt9LCBkZWZhdWx0U2V0dGluZ3MsIHsgc3RyaXA6IGZhbHNlIH0sIG9wdGlvbnMpO1xuICAgICAgICBjb25zdCBhbGxvd2VkID0gYC0wMTIzNDU2Nzg5XFxcXCR7c2V0dGluZ3MuZGVjaW1hbENoYXJhY3Rlcn1gO1xuICAgICAgICBjb25zdCBhdXRvU3RyaXAgPSBuZXcgUmVnRXhwKGBbXiR7YWxsb3dlZH1dYCwgJ2dpJyk7XG4gICAgICAgIHZhbHVlID0gdmFsdWUudG9TdHJpbmcoKTtcblxuICAgICAgICAvLyBUaGlzIGNoZWNrcyBpcyBhIG5lZ2F0aXZlIHNpZ24gaXMgYW55d2hlcmUgaW4gdGhlIGB2YWx1ZWAsIG5vdCBqdXN0IG9uIHRoZSB2ZXJ5IGZpcnN0IGNoYXJhY3RlciAoaWUuICcxMjM0NS42Ny0nKVxuICAgICAgICBpZiAoaXNOZWdhdGl2ZSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHNldHRpbmdzLm5lZ2F0aXZlU2lnbkNoYXJhY3RlciA9ICctJztcbiAgICAgICAgfSBlbHNlIGlmIChzZXR0aW5ncy5uZWdhdGl2ZUJyYWNrZXRzVHlwZU9uQmx1ciAmJiBzZXR0aW5ncy5uZWdhdGl2ZUJyYWNrZXRzVHlwZU9uQmx1ci5zcGxpdCgnLCcpWzBdID09PSB2YWx1ZS5jaGFyQXQoMCkpIHtcbiAgICAgICAgICAgIHNldHRpbmdzLm5lZ2F0aXZlU2lnbkNoYXJhY3RlciA9ICctJztcbiAgICAgICAgICAgIHNldHRpbmdzLmhhc0ZvY3VzID0gdHJ1ZTtcbiAgICAgICAgICAgIHZhbHVlID0gdG9nZ2xlTmVnYXRpdmVCcmFja2V0KHZhbHVlLCBzZXR0aW5ncyk7XG4gICAgICAgIH1cblxuICAgICAgICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UoYXV0b1N0cmlwLCAnJyk7XG4gICAgICAgIHZhbHVlID0gdmFsdWUucmVwbGFjZShzZXR0aW5ncy5kZWNpbWFsQ2hhcmFjdGVyLCAnLicpO1xuICAgICAgICB2YWx1ZSA9IHRvTG9jYWxlKHZhbHVlLCBzZXR0aW5ncy5vdXRwdXRGb3JtYXQpO1xuXG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9O1xuXG4gICAgJC5mbi5hdXRvVW5mb3JtYXQgPSBhdXRvVW5Gb3JtYXQ7IC8vIFRoZSBqUXVlcnkgZXhwb3J0XG5cbiAgICAvKipcbiAgICAgKiBWYWxpZGF0ZSB0aGUgZ2l2ZW4gb3B0aW9uIG9iamVjdC5cbiAgICAgKiBJZiB0aGUgb3B0aW9ucyBhcmUgdmFsaWQsIHRoaXMgZnVuY3Rpb24gcmV0dXJucyBub3RoaW5nLCBvdGhlcndpc2UgaWYgdGhlIG9wdGlvbnMgYXJlIGludmFsaWQsIHRoaXMgZnVuY3Rpb24gdGhyb3dzIGFuIGVycm9yLlxuICAgICAqXG4gICAgICogVGhpcyB0ZXN0cyBpZiB0aGUgb3B0aW9ucyBhcmUgbm90IGNvbmZsaWN0aW5nIGFuZCBhcmUgd2VsbCBmb3JtYXR0ZWQuXG4gICAgICogVGhpcyBmdW5jdGlvbiBpcyBsZW5pZW50IHNpbmNlIGl0IG9ubHkgdGVzdHMgdGhlIHNldHRpbmdzIHByb3BlcnRpZXMgOyBpdCBpZ25vcmVzIGFueSBvdGhlciBwcm9wZXJ0aWVzIHRoZSBvcHRpb25zIG9iamVjdCBjb3VsZCBoYXZlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHsqfSB1c2VyT3B0aW9uc1xuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gc2hvdWxkRXh0ZW5kRGVmYXVsdE9wdGlvbnMgSWYgVFJVRSwgdGhlbiB0aGlzIGZ1bmN0aW9uIHdpbGwgZXh0ZW5kcyB0aGUgYHVzZXJPcHRpb25zYCBwYXNzZWQgYnkgdGhlIHVzZXIsIHdpdGggdGhlIGRlZmF1bHQgb3B0aW9ucy5cbiAgICAgKiBAdGhyb3dzIEVycm9yXG4gICAgICovXG4gICAgdmFsaWRhdGUgPSAodXNlck9wdGlvbnMsIHNob3VsZEV4dGVuZERlZmF1bHRPcHRpb25zID0gdHJ1ZSkgPT4ge1xuICAgICAgICBpZiAoaXNVbmRlZmluZWRPck51bGxPckVtcHR5KHVzZXJPcHRpb25zKSB8fCAhaXNPYmplY3QodXNlck9wdGlvbnMpIHx8IGlzRW1wdHlPYmoodXNlck9wdGlvbnMpKSB7XG4gICAgICAgICAgICB0aHJvd0Vycm9yKGBUaGUgdXNlck9wdGlvbnMgYXJlIGludmFsaWQgOyBpdCBzaG91bGQgYmUgYSB2YWxpZCBvYmplY3QsIFske3VzZXJPcHRpb25zfV0gZ2l2ZW4uYCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZiB0aGUgdXNlciB1c2VkIG9sZCBvcHRpb25zLCB3ZSBjb252ZXJ0IHRoZW0gdG8gbmV3IG9uZXNcbiAgICAgICAgaWYgKCFpc051bGwodXNlck9wdGlvbnMpKSB7XG4gICAgICAgICAgICBjb252ZXJ0T2xkT3B0aW9uc1RvTmV3T25lcyh1c2VyT3B0aW9ucyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUaGUgdXNlciBjYW4gY2hvb3NlIGlmIHRoZSBgdXNlck9wdGlvbnNgIGhhcyBhbHJlYWR5IGJlZW4gZXh0ZW5kZWQgd2l0aCB0aGUgZGVmYXVsdCBvcHRpb25zLCBvciBub3RcbiAgICAgICAgbGV0IG9wdGlvbnM7XG4gICAgICAgIGlmIChzaG91bGRFeHRlbmREZWZhdWx0T3B0aW9ucykge1xuICAgICAgICAgICAgb3B0aW9ucyA9ICQuZXh0ZW5kKHt9LCBkZWZhdWx0U2V0dGluZ3MsIHVzZXJPcHRpb25zKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSB1c2VyT3B0aW9ucztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEZpcnN0IHRoaW5ncyBmaXJzdCwgd2UgdGVzdCB0aGF0IHRoZSBgc2hvd1dhcm5pbmdzYCBvcHRpb24gaXMgdmFsaWRcbiAgICAgICAgaWYgKCFpc1RydWVPckZhbHNlU3RyaW5nKG9wdGlvbnMuc2hvd1dhcm5pbmdzKSAmJiAhaXNCb29sZWFuKG9wdGlvbnMuc2hvd1dhcm5pbmdzKSkge1xuICAgICAgICAgICAgdGhyb3dFcnJvcihgVGhlIGRlYnVnIG9wdGlvbiAnc2hvd1dhcm5pbmdzJyBpcyBpbnZhbGlkIDsgaXQgc2hvdWxkIGJlIGVpdGhlciAnZmFsc2UnIG9yICd0cnVlJywgWyR7b3B0aW9ucy5zaG93V2FybmluZ3N9XSBnaXZlbi5gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIERlZmluZSB0aGUgcmVndWxhciBleHByZXNzaW9ucyBuZWVkZWQgZm9yIHRoZSBmb2xsb3dpbmcgdGVzdHNcbiAgICAgICAgY29uc3QgdGVzdFBvc2l0aXZlSW50ZWdlciA9IC9eWzAtOV0rJC87XG4gICAgICAgIGNvbnN0IHRlc3ROdW1lcmljYWxDaGFyYWN0ZXJzID0gL1swLTldKy87XG4gICAgICAgIC8vIGNvbnN0IHRlc3RGbG9hdEFuZFBvc3NpYmxlTmVnYXRpdmVTaWduID0gL14tP1swLTldKyhcXC4/WzAtOV0rKSQvO1xuICAgICAgICBjb25zdCB0ZXN0RmxvYXRPckludGVnZXJBbmRQb3NzaWJsZU5lZ2F0aXZlU2lnbiA9IC9eLT9bMC05XSsoXFwuP1swLTldKyk/JC87XG4gICAgICAgIGNvbnN0IHRlc3RQb3NpdGl2ZUZsb2F0T3JJbnRlZ2VyID0gL15bMC05XSsoXFwuP1swLTldKyk/JC87XG5cbiAgICAgICAgLy8gVGhlbiB0ZXN0cyB0aGUgb3B0aW9ucyBpbmRpdmlkdWFsbHlcbiAgICAgICAgaWYgKCFpc0luQXJyYXkob3B0aW9ucy5kaWdpdEdyb3VwU2VwYXJhdG9yLCBbXG4gICAgICAgICAgICAnLCcsICAgICAgLy8gQ29tbWFcbiAgICAgICAgICAgICcuJywgICAgICAvLyBEb3RcbiAgICAgICAgICAgICcgJywgICAgICAvLyBOb3JtYWwgc3BhY2VcbiAgICAgICAgICAgICdcXHUyMDA5JywgLy8gVGhpbi1zcGFjZVxuICAgICAgICAgICAgJ1xcdTIwMmYnLCAvLyBOYXJyb3cgbm8tYnJlYWsgc3BhY2VcbiAgICAgICAgICAgICdcXHUwMGEwJywgLy8gTm8tYnJlYWsgc3BhY2VcbiAgICAgICAgICAgICcnLCAgICAgICAvLyBObyBzZXBhcmF0b3JcbiAgICAgICAgICAgIFwiJ1wiLCAgICAgIC8vIEFwb3N0cm9waGVcbiAgICAgICAgICAgICfZrCcsICAgICAgLy8gQXJhYmljIHRob3VzYW5kcyBzZXBhcmF0b3JcbiAgICAgICAgICAgICfLmScsICAgICAgLy8gRG90IGFib3ZlXG4gICAgICAgIF0pKSB7XG4gICAgICAgICAgICB0aHJvd0Vycm9yKGBUaGUgdGhvdXNhbmQgc2VwYXJhdG9yIGNoYXJhY3RlciBvcHRpb24gJ2RpZ2l0R3JvdXBTZXBhcmF0b3InIGlzIGludmFsaWQgOyBpdCBzaG91bGQgYmUgJywnLCAnLicsICfZrCcsICfLmScsIFwiJ1wiLCAnICcsICdcXHUyMDA5JywgJ1xcdTIwMmYnLCAnXFx1MDBhMCcgb3IgZW1wdHkgKCcnKSwgWyR7b3B0aW9ucy5kaWdpdEdyb3VwU2VwYXJhdG9yfV0gZ2l2ZW4uYCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWlzVHJ1ZU9yRmFsc2VTdHJpbmcob3B0aW9ucy5ub1NlcGFyYXRvck9uRm9jdXMpICYmICFpc0Jvb2xlYW4ob3B0aW9ucy5ub1NlcGFyYXRvck9uRm9jdXMpKSB7XG4gICAgICAgICAgICB0aHJvd0Vycm9yKGBUaGUgJ25vU2VwYXJhdG9yT25Gb2N1cycgb3B0aW9uIGlzIGludmFsaWQgOyBpdCBzaG91bGQgYmUgZWl0aGVyICdmYWxzZScgb3IgJ3RydWUnLCBbJHtvcHRpb25zLm5vU2VwYXJhdG9yT25Gb2N1c31dIGdpdmVuLmApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0ZXN0UG9zaXRpdmVJbnRlZ2VyLnRlc3Qob3B0aW9ucy5kaWdpdGFsR3JvdXBTcGFjaW5nKSkge1xuICAgICAgICAgICAgdGhyb3dFcnJvcihgVGhlIGRpZ2l0YWwgZ3JvdXBpbmcgZm9yIHRob3VzYW5kIHNlcGFyYXRvciBvcHRpb24gJ2RpZ2l0YWxHcm91cFNwYWNpbmcnIGlzIGludmFsaWQgOyBpdCBzaG91bGQgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyLCBbJHtvcHRpb25zLmRpZ2l0YWxHcm91cFNwYWNpbmd9XSBnaXZlbi5gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghaXNJbkFycmF5KG9wdGlvbnMuZGVjaW1hbENoYXJhY3RlciwgW1xuICAgICAgICAgICAgJywnLCAvLyBDb21tYVxuICAgICAgICAgICAgJy4nLCAvLyBEb3RcbiAgICAgICAgICAgICfCtycsIC8vIE1pZGRsZS1kb3RcbiAgICAgICAgICAgICfZqycsIC8vIEFyYWJpYyBkZWNpbWFsIHNlcGFyYXRvclxuICAgICAgICAgICAgJ+KOlicsIC8vIERlY2ltYWwgc2VwYXJhdG9yIGtleSBzeW1ib2xcbiAgICAgICAgXSkpIHtcbiAgICAgICAgICAgIHRocm93RXJyb3IoYFRoZSBkZWNpbWFsIHNlcGFyYXRvciBjaGFyYWN0ZXIgb3B0aW9uICdkZWNpbWFsQ2hhcmFjdGVyJyBpcyBpbnZhbGlkIDsgaXQgc2hvdWxkIGJlICcuJywgJywnLCAnwrcnLCAn4o6WJyBvciAn2asnLCBbJHtvcHRpb25zLmRlY2ltYWxDaGFyYWN0ZXJ9XSBnaXZlbi5gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENoZWNrcyBpZiB0aGUgZGVjaW1hbCBhbmQgdGhvdXNhbmQgY2hhcmFjdGVycyBhcmUgdGhlIHNhbWVcbiAgICAgICAgaWYgKG9wdGlvbnMuZGVjaW1hbENoYXJhY3RlciA9PT0gb3B0aW9ucy5kaWdpdEdyb3VwU2VwYXJhdG9yKSB7XG4gICAgICAgICAgICB0aHJvd0Vycm9yKGBhdXRvTnVtZXJpYyB3aWxsIG5vdCBmdW5jdGlvbiBwcm9wZXJseSB3aGVuIHRoZSBkZWNpbWFsIGNoYXJhY3RlciAnZGVjaW1hbENoYXJhY3RlcicgWyR7b3B0aW9ucy5kZWNpbWFsQ2hhcmFjdGVyfV0gYW5kIHRoZSB0aG91c2FuZCBzZXBhcmF0b3IgJ2RpZ2l0R3JvdXBTZXBhcmF0b3InIFske29wdGlvbnMuZGlnaXRHcm91cFNlcGFyYXRvcn1dIGFyZSB0aGUgc2FtZSBjaGFyYWN0ZXIuYCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWlzTnVsbChvcHRpb25zLmRlY2ltYWxDaGFyYWN0ZXJBbHRlcm5hdGl2ZSkgJiYgIWlzU3RyaW5nKG9wdGlvbnMuZGVjaW1hbENoYXJhY3RlckFsdGVybmF0aXZlKSkge1xuICAgICAgICAgICAgdGhyb3dFcnJvcihgVGhlIGFsdGVybmF0ZSBkZWNpbWFsIHNlcGFyYXRvciBjaGFyYWN0ZXIgb3B0aW9uICdkZWNpbWFsQ2hhcmFjdGVyQWx0ZXJuYXRpdmUnIGlzIGludmFsaWQgOyBpdCBzaG91bGQgYmUgYSBzdHJpbmcsIFske29wdGlvbnMuZGVjaW1hbENoYXJhY3RlckFsdGVybmF0aXZlfV0gZ2l2ZW4uYCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob3B0aW9ucy5jdXJyZW5jeVN5bWJvbCAhPT0gJycgJiYgIWlzU3RyaW5nKG9wdGlvbnMuY3VycmVuY3lTeW1ib2wpKSB7XG4gICAgICAgICAgICB0aHJvd0Vycm9yKGBUaGUgY3VycmVuY3kgc3ltYm9sIG9wdGlvbiAnY3VycmVuY3lTeW1ib2wnIGlzIGludmFsaWQgOyBpdCBzaG91bGQgYmUgYSBzdHJpbmcsIFske29wdGlvbnMuY3VycmVuY3lTeW1ib2x9XSBnaXZlbi5gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghaXNJbkFycmF5KG9wdGlvbnMuY3VycmVuY3lTeW1ib2xQbGFjZW1lbnQsIFsncCcsICdzJ10pKSB7XG4gICAgICAgICAgICB0aHJvd0Vycm9yKGBUaGUgcGxhY2VtZW50IG9mIHRoZSBjdXJyZW5jeSBzaWduIG9wdGlvbiAnY3VycmVuY3lTeW1ib2xQbGFjZW1lbnQnIGlzIGludmFsaWQgOyBpdCBzaG91bGQgZWl0aGVyIGJlICdwJyAocHJlZml4KSBvciAncycgKHN1ZmZpeCksIFske29wdGlvbnMuY3VycmVuY3lTeW1ib2xQbGFjZW1lbnR9XSBnaXZlbi5gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghaXNJbkFycmF5KG9wdGlvbnMubmVnYXRpdmVQb3NpdGl2ZVNpZ25QbGFjZW1lbnQsIFsncCcsICdzJywgJ2wnLCAncicsIG51bGxdKSkge1xuICAgICAgICAgICAgdGhyb3dFcnJvcihgVGhlIHBsYWNlbWVudCBvZiB0aGUgbmVnYXRpdmUgc2lnbiBvcHRpb24gJ25lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50JyBpcyBpbnZhbGlkIDsgaXQgc2hvdWxkIGVpdGhlciBiZSAncCcgKHByZWZpeCksICdzJyAoc3VmZml4KSwgJ2wnIChsZWZ0KSwgJ3InIChyaWdodCkgb3IgJ251bGwnLCBbJHtvcHRpb25zLm5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50fV0gZ2l2ZW4uYCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWlzVHJ1ZU9yRmFsc2VTdHJpbmcob3B0aW9ucy5zaG93UG9zaXRpdmVTaWduKSAmJiAhaXNCb29sZWFuKG9wdGlvbnMuc2hvd1Bvc2l0aXZlU2lnbikpIHtcbiAgICAgICAgICAgIHRocm93RXJyb3IoYFRoZSBzaG93IHBvc2l0aXZlIHNpZ24gb3B0aW9uICdzaG93UG9zaXRpdmVTaWduJyBpcyBpbnZhbGlkIDsgaXQgc2hvdWxkIGJlIGVpdGhlciAnZmFsc2UnIG9yICd0cnVlJywgWyR7b3B0aW9ucy5zaG93UG9zaXRpdmVTaWdufV0gZ2l2ZW4uYCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWlzU3RyaW5nKG9wdGlvbnMuc3VmZml4VGV4dCkgfHwgKG9wdGlvbnMuc3VmZml4VGV4dCAhPT0gJycgJiYgKGlzTmVnYXRpdmUob3B0aW9ucy5zdWZmaXhUZXh0KSB8fCB0ZXN0TnVtZXJpY2FsQ2hhcmFjdGVycy50ZXN0KG9wdGlvbnMuc3VmZml4VGV4dCkpKSkge1xuICAgICAgICAgICAgdGhyb3dFcnJvcihgVGhlIGFkZGl0aW9uYWwgc3VmZml4IG9wdGlvbiAnc3VmZml4VGV4dCcgaXMgaW52YWxpZCA7IGl0IHNob3VsZCBub3QgY29udGFpbnMgdGhlIG5lZ2F0aXZlIHNpZ24gJy0nIG5vciBhbnkgbnVtZXJpY2FsIGNoYXJhY3RlcnMsIFske29wdGlvbnMuc3VmZml4VGV4dH1dIGdpdmVuLmApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFpc051bGwob3B0aW9ucy5vdmVycmlkZU1pbk1heExpbWl0cykgJiYgIWlzSW5BcnJheShvcHRpb25zLm92ZXJyaWRlTWluTWF4TGltaXRzLCBbJ2NlaWxpbmcnLCAnZmxvb3InLCAnaWdub3JlJ10pKSB7XG4gICAgICAgICAgICB0aHJvd0Vycm9yKGBUaGUgb3ZlcnJpZGUgbWluICYgbWF4IGxpbWl0cyBvcHRpb24gJ292ZXJyaWRlTWluTWF4TGltaXRzJyBpcyBpbnZhbGlkIDsgaXQgc2hvdWxkIGVpdGhlciBiZSAnY2VpbGluZycsICdmbG9vcicgb3IgJ2lnbm9yZScsIFske29wdGlvbnMub3ZlcnJpZGVNaW5NYXhMaW1pdHN9XSBnaXZlbi5gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghaXNTdHJpbmcob3B0aW9ucy5tYXhpbXVtVmFsdWUpIHx8ICF0ZXN0RmxvYXRPckludGVnZXJBbmRQb3NzaWJsZU5lZ2F0aXZlU2lnbi50ZXN0KG9wdGlvbnMubWF4aW11bVZhbHVlKSkge1xuICAgICAgICAgICAgdGhyb3dFcnJvcihgVGhlIG1heGltdW0gcG9zc2libGUgdmFsdWUgb3B0aW9uICdtYXhpbXVtVmFsdWUnIGlzIGludmFsaWQgOyBpdCBzaG91bGQgYmUgYSBzdHJpbmcgdGhhdCByZXByZXNlbnRzIGEgcG9zaXRpdmUgb3IgbmVnYXRpdmUgbnVtYmVyLCBbJHtvcHRpb25zLm1heGltdW1WYWx1ZX1dIGdpdmVuLmApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFpc1N0cmluZyhvcHRpb25zLm1pbmltdW1WYWx1ZSkgfHwgIXRlc3RGbG9hdE9ySW50ZWdlckFuZFBvc3NpYmxlTmVnYXRpdmVTaWduLnRlc3Qob3B0aW9ucy5taW5pbXVtVmFsdWUpKSB7XG4gICAgICAgICAgICB0aHJvd0Vycm9yKGBUaGUgbWluaW11bSBwb3NzaWJsZSB2YWx1ZSBvcHRpb24gJ21pbmltdW1WYWx1ZScgaXMgaW52YWxpZCA7IGl0IHNob3VsZCBiZSBhIHN0cmluZyB0aGF0IHJlcHJlc2VudHMgYSBwb3NpdGl2ZSBvciBuZWdhdGl2ZSBudW1iZXIsIFske29wdGlvbnMubWluaW11bVZhbHVlfV0gZ2l2ZW4uYCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocGFyc2VGbG9hdChvcHRpb25zLm1pbmltdW1WYWx1ZSkgPiBwYXJzZUZsb2F0KG9wdGlvbnMubWF4aW11bVZhbHVlKSkge1xuICAgICAgICAgICAgdGhyb3dFcnJvcihgVGhlIG1pbmltdW0gcG9zc2libGUgdmFsdWUgb3B0aW9uIGlzIGdyZWF0ZXIgdGhhbiB0aGUgbWF4aW11bSBwb3NzaWJsZSB2YWx1ZSBvcHRpb24gOyAnbWluaW11bVZhbHVlJyBbJHtvcHRpb25zLm1pbmltdW1WYWx1ZX1dIHNob3VsZCBiZSBzbWFsbGVyIHRoYW4gJ21heGltdW1WYWx1ZScgWyR7b3B0aW9ucy5tYXhpbXVtVmFsdWV9XS5gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghKGlzTnVsbChvcHRpb25zLmRlY2ltYWxQbGFjZXNPdmVycmlkZSkgfHxcbiAgICAgICAgICAgIChpc0ludChvcHRpb25zLmRlY2ltYWxQbGFjZXNPdmVycmlkZSkgJiYgb3B0aW9ucy5kZWNpbWFsUGxhY2VzT3ZlcnJpZGUgPj0gMCkgfHwgLy8gSWYgaW50ZWdlciBvcHRpb25cbiAgICAgICAgICAgIChpc1N0cmluZyhvcHRpb25zLmRlY2ltYWxQbGFjZXNPdmVycmlkZSkgJiYgdGVzdFBvc2l0aXZlSW50ZWdlci50ZXN0KG9wdGlvbnMuZGVjaW1hbFBsYWNlc092ZXJyaWRlKSkpICAvLyBJZiBzdHJpbmcgb3B0aW9uXG4gICAgICAgICkge1xuICAgICAgICAgICAgdGhyb3dFcnJvcihgVGhlIG1heGltdW0gbnVtYmVyIG9mIGRlY2ltYWwgcGxhY2VzIG9wdGlvbiAnZGVjaW1hbFBsYWNlc092ZXJyaWRlJyBpcyBpbnZhbGlkIDsgaXQgc2hvdWxkIGJlIGEgcG9zaXRpdmUgaW50ZWdlciwgWyR7b3B0aW9ucy5kZWNpbWFsUGxhY2VzT3ZlcnJpZGV9XSBnaXZlbi5gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFdyaXRlIGEgd2FybmluZyBtZXNzYWdlIGluIHRoZSBjb25zb2xlIGlmIHRoZSBudW1iZXIgb2YgZGVjaW1hbCBpbiBtaW5pbXVtVmFsdWUvbWF4aW11bVZhbHVlIGlzIG92ZXJyaWRkZW4gYnkgZGVjaW1hbFBsYWNlc092ZXJyaWRlIChhbmQgbm90IGlmIGRlY2ltYWxQbGFjZXNPdmVycmlkZSBpcyBlcXVhbCB0byB0aGUgbnVtYmVyIG9mIGRlY2ltYWwgdXNlZCBpbiBtaW5pbXVtVmFsdWUvbWF4aW11bVZhbHVlKVxuICAgICAgICBjb25zdCB2TWluQW5kVk1heE1heGltdW1EZWNpbWFsUGxhY2VzID0gbWF4aW11bVZNaW5BbmRWTWF4RGVjaW1hbExlbmd0aChvcHRpb25zLm1pbmltdW1WYWx1ZSwgb3B0aW9ucy5tYXhpbXVtVmFsdWUpO1xuICAgICAgICBpZiAoIWlzTnVsbChvcHRpb25zLmRlY2ltYWxQbGFjZXNPdmVycmlkZSkgJiYgdk1pbkFuZFZNYXhNYXhpbXVtRGVjaW1hbFBsYWNlcyAhPT0gTnVtYmVyKG9wdGlvbnMuZGVjaW1hbFBsYWNlc092ZXJyaWRlKSkge1xuICAgICAgICAgICAgd2FybmluZyhgU2V0dGluZyAnZGVjaW1hbFBsYWNlc092ZXJyaWRlJyB0byBbJHtvcHRpb25zLmRlY2ltYWxQbGFjZXNPdmVycmlkZX1dIHdpbGwgb3ZlcnJpZGUgdGhlIGRlY2ltYWxzIGRlY2xhcmVkIGluICdtaW5pbXVtVmFsdWUnIFske29wdGlvbnMubWluaW11bVZhbHVlfV0gYW5kICdtYXhpbXVtVmFsdWUnIFske29wdGlvbnMubWF4aW11bVZhbHVlfV0uYCwgb3B0aW9ucy5zaG93V2FybmluZ3MpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFvcHRpb25zLmFsbG93RGVjaW1hbFBhZGRpbmcgJiYgIWlzTnVsbChvcHRpb25zLmRlY2ltYWxQbGFjZXNPdmVycmlkZSkpIHtcbiAgICAgICAgICAgIHdhcm5pbmcoYFNldHRpbmcgJ2FsbG93RGVjaW1hbFBhZGRpbmcnIHRvIFtmYWxzZV0gd2lsbCBvdmVycmlkZSB0aGUgY3VycmVudCAnZGVjaW1hbFBsYWNlc092ZXJyaWRlJyBzZXR0aW5nIFske29wdGlvbnMuZGVjaW1hbFBsYWNlc092ZXJyaWRlfV0uYCwgb3B0aW9ucy5zaG93V2FybmluZ3MpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFpc051bGwob3B0aW9ucy5kZWNpbWFsUGxhY2VzU2hvd25PbkZvY3VzKSAmJiAoIWlzU3RyaW5nKG9wdGlvbnMuZGVjaW1hbFBsYWNlc1Nob3duT25Gb2N1cykgfHwgIXRlc3RQb3NpdGl2ZUludGVnZXIudGVzdChvcHRpb25zLmRlY2ltYWxQbGFjZXNTaG93bk9uRm9jdXMpKSkge1xuICAgICAgICAgICAgdGhyb3dFcnJvcihgVGhlIG51bWJlciBvZiBleHBhbmRlZCBkZWNpbWFsIHBsYWNlcyBvcHRpb24gJ2RlY2ltYWxQbGFjZXNTaG93bk9uRm9jdXMnIGlzIGludmFsaWQgOyBpdCBzaG91bGQgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyLCBbJHtvcHRpb25zLmRlY2ltYWxQbGFjZXNTaG93bk9uRm9jdXN9XSBnaXZlbi5gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENoZWNrcyBpZiB0aGUgZXh0ZW5kZWQgZGVjaW1hbCBwbGFjZXMgXCJkZWNpbWFsUGxhY2VzU2hvd25PbkZvY3VzXCIgaXMgZ3JlYXRlciB0aGFuIHRoZSBub3JtYWwgZGVjaW1hbCBwbGFjZXMgXCJkZWNpbWFsUGxhY2VzT3ZlcnJpZGVcIlxuICAgICAgICBpZiAoIWlzTnVsbChvcHRpb25zLmRlY2ltYWxQbGFjZXNTaG93bk9uRm9jdXMpICYmICFpc051bGwob3B0aW9ucy5kZWNpbWFsUGxhY2VzT3ZlcnJpZGUpICYmIE51bWJlcihvcHRpb25zLmRlY2ltYWxQbGFjZXNPdmVycmlkZSkgPiBOdW1iZXIob3B0aW9ucy5kZWNpbWFsUGxhY2VzU2hvd25PbkZvY3VzKSkge1xuICAgICAgICAgICAgd2FybmluZyhgVGhlIGV4dGVuZGVkIGRlY2ltYWwgcGxhY2VzICdkZWNpbWFsUGxhY2VzU2hvd25PbkZvY3VzJyBbJHtvcHRpb25zLmRlY2ltYWxQbGFjZXNTaG93bk9uRm9jdXN9XSBzaG91bGQgYmUgZ3JlYXRlciB0aGFuIHRoZSAnZGVjaW1hbFBsYWNlc092ZXJyaWRlJyBbJHtvcHRpb25zLmRlY2ltYWxQbGFjZXNPdmVycmlkZX1dIHZhbHVlLiBDdXJyZW50bHksIHRoaXMgd2lsbCBsaW1pdCB0aGUgYWJpbGl0eSBvZiB5b3VyIGNsaWVudCB0byBtYW51YWxseSBjaGFuZ2Ugc29tZSBvZiB0aGUgZGVjaW1hbCBwbGFjZXMuIERvIHlvdSByZWFsbHkgd2FudCB0byBkbyB0aGF0P2AsIG9wdGlvbnMuc2hvd1dhcm5pbmdzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghaXNOdWxsKG9wdGlvbnMuc2NhbGVEaXZpc29yKSAmJiAhdGVzdFBvc2l0aXZlRmxvYXRPckludGVnZXIudGVzdChvcHRpb25zLnNjYWxlRGl2aXNvcikpIHtcbiAgICAgICAgICAgIHRocm93RXJyb3IoYFRoZSBzY2FsZSBkaXZpc29yIG9wdGlvbiAnc2NhbGVEaXZpc29yJyBpcyBpbnZhbGlkIDsgaXQgc2hvdWxkIGJlIGEgcG9zaXRpdmUgbnVtYmVyLCBwcmVmZXJhYmx5IGFuIGludGVnZXIsIFske29wdGlvbnMuc2NhbGVEaXZpc29yfV0gZ2l2ZW4uYCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWlzTnVsbChvcHRpb25zLnNjYWxlRGVjaW1hbFBsYWNlcykgJiYgIXRlc3RQb3NpdGl2ZUludGVnZXIudGVzdChvcHRpb25zLnNjYWxlRGVjaW1hbFBsYWNlcykpIHtcbiAgICAgICAgICAgIHRocm93RXJyb3IoYFRoZSBzY2FsZSBudW1iZXIgb2YgZGVjaW1hbHMgb3B0aW9uICdzY2FsZURlY2ltYWxQbGFjZXMnIGlzIGludmFsaWQgOyBpdCBzaG91bGQgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyLCBbJHtvcHRpb25zLnNjYWxlRGVjaW1hbFBsYWNlc31dIGdpdmVuLmApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFpc051bGwob3B0aW9ucy5zY2FsZVN5bWJvbCkgJiYgIWlzU3RyaW5nKG9wdGlvbnMuc2NhbGVTeW1ib2wpKSB7XG4gICAgICAgICAgICB0aHJvd0Vycm9yKGBUaGUgc2NhbGUgc3ltYm9sIG9wdGlvbiAnc2NhbGVTeW1ib2wnIGlzIGludmFsaWQgOyBpdCBzaG91bGQgYmUgYSBzdHJpbmcsIFske29wdGlvbnMuc2NhbGVTeW1ib2x9XSBnaXZlbi5gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghaXNUcnVlT3JGYWxzZVN0cmluZyhvcHRpb25zLnNhdmVWYWx1ZVRvU2Vzc2lvblN0b3JhZ2UpICYmICFpc0Jvb2xlYW4ob3B0aW9ucy5zYXZlVmFsdWVUb1Nlc3Npb25TdG9yYWdlKSkge1xuICAgICAgICAgICAgdGhyb3dFcnJvcihgVGhlIHNhdmUgdG8gc2Vzc2lvbiBzdG9yYWdlIG9wdGlvbiAnc2F2ZVZhbHVlVG9TZXNzaW9uU3RvcmFnZScgaXMgaW52YWxpZCA7IGl0IHNob3VsZCBiZSBlaXRoZXIgJ2ZhbHNlJyBvciAndHJ1ZScsIFske29wdGlvbnMuc2F2ZVZhbHVlVG9TZXNzaW9uU3RvcmFnZX1dIGdpdmVuLmApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFpc0luQXJyYXkob3B0aW9ucy5vbkludmFsaWRQYXN0ZSwgW1xuICAgICAgICAgICAgJ2Vycm9yJyxcbiAgICAgICAgICAgICdpZ25vcmUnLFxuICAgICAgICAgICAgJ2NsYW1wJyxcbiAgICAgICAgICAgICd0cnVuY2F0ZScsXG4gICAgICAgICAgICAncmVwbGFjZScsXG4gICAgICAgIF0pKSB7XG4gICAgICAgICAgICB0aHJvd0Vycm9yKGBUaGUgcGFzdGUgYmVoYXZpb3Igb3B0aW9uICdvbkludmFsaWRQYXN0ZScgaXMgaW52YWxpZCA7IGl0IHNob3VsZCBlaXRoZXIgYmUgJ2Vycm9yJywgJ2lnbm9yZScsICdjbGFtcCcsICd0cnVuY2F0ZScgb3IgJ3JlcGxhY2UnIChjZi4gZG9jdW1lbnRhdGlvbiksIFske29wdGlvbnMub25JbnZhbGlkUGFzdGV9XSBnaXZlbi5gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghaXNJbkFycmF5KG9wdGlvbnMucm91bmRpbmdNZXRob2QsIFtcbiAgICAgICAgICAgICdTJyxcbiAgICAgICAgICAgICdBJyxcbiAgICAgICAgICAgICdzJyxcbiAgICAgICAgICAgICdhJyxcbiAgICAgICAgICAgICdCJyxcbiAgICAgICAgICAgICdVJyxcbiAgICAgICAgICAgICdEJyxcbiAgICAgICAgICAgICdDJyxcbiAgICAgICAgICAgICdGJyxcbiAgICAgICAgICAgICdOMDUnLFxuICAgICAgICAgICAgJ0NIRicsXG4gICAgICAgICAgICAnVTA1JyxcbiAgICAgICAgICAgICdEMDUnLFxuICAgICAgICBdKSkge1xuICAgICAgICAgICAgdGhyb3dFcnJvcihgVGhlIHJvdW5kaW5nIG1ldGhvZCBvcHRpb24gJ3JvdW5kaW5nTWV0aG9kJyBpcyBpbnZhbGlkIDsgaXQgc2hvdWxkIGVpdGhlciBiZSAnUycsICdBJywgJ3MnLCAnYScsICdCJywgJ1UnLCAnRCcsICdDJywgJ0YnLCAnTjA1JywgJ0NIRicsICdVMDUnIG9yICdEMDUnIChjZi4gZG9jdW1lbnRhdGlvbiksIFske29wdGlvbnMucm91bmRpbmdNZXRob2R9XSBnaXZlbi5gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghaXNUcnVlT3JGYWxzZVN0cmluZyhvcHRpb25zLmFsbG93RGVjaW1hbFBhZGRpbmcpICYmICFpc0Jvb2xlYW4ob3B0aW9ucy5hbGxvd0RlY2ltYWxQYWRkaW5nKSkge1xuICAgICAgICAgICAgdGhyb3dFcnJvcihgVGhlIGNvbnRyb2wgZGVjaW1hbCBwYWRkaW5nIG9wdGlvbiAnYWxsb3dEZWNpbWFsUGFkZGluZycgaXMgaW52YWxpZCA7IGl0IHNob3VsZCBiZSBlaXRoZXIgJ2ZhbHNlJyBvciAndHJ1ZScsIFske29wdGlvbnMuYWxsb3dEZWNpbWFsUGFkZGluZ31dIGdpdmVuLmApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFpc051bGwob3B0aW9ucy5uZWdhdGl2ZUJyYWNrZXRzVHlwZU9uQmx1cikgJiYgIWlzSW5BcnJheShvcHRpb25zLm5lZ2F0aXZlQnJhY2tldHNUeXBlT25CbHVyLCBbJygsKScsICdbLF0nLCAnPCw+JywgJ3ssfSddKSkge1xuICAgICAgICAgICAgdGhyb3dFcnJvcihgVGhlIGJyYWNrZXRzIGZvciBuZWdhdGl2ZSB2YWx1ZXMgb3B0aW9uICduZWdhdGl2ZUJyYWNrZXRzVHlwZU9uQmx1cicgaXMgaW52YWxpZCA7IGl0IHNob3VsZCBlaXRoZXIgYmUgJygsKScsICdbLF0nLCAnPCw+JyBvciAneyx9JywgWyR7b3B0aW9ucy5uZWdhdGl2ZUJyYWNrZXRzVHlwZU9uQmx1cn1dIGdpdmVuLmApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFpc0luQXJyYXkob3B0aW9ucy5lbXB0eUlucHV0QmVoYXZpb3IsIFsnZm9jdXMnLCAncHJlc3MnLCAnYWx3YXlzJywgJ3plcm8nXSkpIHtcbiAgICAgICAgICAgIHRocm93RXJyb3IoYFRoZSBkaXNwbGF5IG9uIGVtcHR5IHN0cmluZyBvcHRpb24gJ2VtcHR5SW5wdXRCZWhhdmlvcicgaXMgaW52YWxpZCA7IGl0IHNob3VsZCBlaXRoZXIgYmUgJ2ZvY3VzJywgJ3ByZXNzJywgJ2Fsd2F5cycgb3IgJ3plcm8nLCBbJHtvcHRpb25zLmVtcHR5SW5wdXRCZWhhdmlvcn1dIGdpdmVuLmApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFpc0luQXJyYXkob3B0aW9ucy5sZWFkaW5nWmVybywgWydhbGxvdycsICdkZW55JywgJ2tlZXAnXSkpIHtcbiAgICAgICAgICAgIHRocm93RXJyb3IoYFRoZSBsZWFkaW5nIHplcm8gYmVoYXZpb3Igb3B0aW9uICdsZWFkaW5nWmVybycgaXMgaW52YWxpZCA7IGl0IHNob3VsZCBlaXRoZXIgYmUgJ2FsbG93JywgJ2RlbnknIG9yICdrZWVwJywgWyR7b3B0aW9ucy5sZWFkaW5nWmVyb31dIGdpdmVuLmApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFpc1RydWVPckZhbHNlU3RyaW5nKG9wdGlvbnMuZm9ybWF0T25QYWdlTG9hZCkgJiYgIWlzQm9vbGVhbihvcHRpb25zLmZvcm1hdE9uUGFnZUxvYWQpKSB7XG4gICAgICAgICAgICB0aHJvd0Vycm9yKGBUaGUgZm9ybWF0IG9uIGluaXRpYWxpemF0aW9uIG9wdGlvbiAnZm9ybWF0T25QYWdlTG9hZCcgaXMgaW52YWxpZCA7IGl0IHNob3VsZCBiZSBlaXRoZXIgJ2ZhbHNlJyBvciAndHJ1ZScsIFske29wdGlvbnMuZm9ybWF0T25QYWdlTG9hZH1dIGdpdmVuLmApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFpc1RydWVPckZhbHNlU3RyaW5nKG9wdGlvbnMuc2VsZWN0TnVtYmVyT25seSkgJiYgIWlzQm9vbGVhbihvcHRpb25zLnNlbGVjdE51bWJlck9ubHkpKSB7XG4gICAgICAgICAgICB0aHJvd0Vycm9yKGBUaGUgc2VsZWN0IG51bWJlciBvbmx5IG9wdGlvbiAnc2VsZWN0TnVtYmVyT25seScgaXMgaW52YWxpZCA7IGl0IHNob3VsZCBiZSBlaXRoZXIgJ2ZhbHNlJyBvciAndHJ1ZScsIFske29wdGlvbnMuc2VsZWN0TnVtYmVyT25seX1dIGdpdmVuLmApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFpc051bGwob3B0aW9ucy5kZWZhdWx0VmFsdWVPdmVycmlkZSkgJiYgKG9wdGlvbnMuZGVmYXVsdFZhbHVlT3ZlcnJpZGUgIT09ICcnICYmICF0ZXN0RmxvYXRPckludGVnZXJBbmRQb3NzaWJsZU5lZ2F0aXZlU2lnbi50ZXN0KG9wdGlvbnMuZGVmYXVsdFZhbHVlT3ZlcnJpZGUpKSkge1xuICAgICAgICAgICAgdGhyb3dFcnJvcihgVGhlIHVuZm9ybWF0dGVkIGRlZmF1bHQgdmFsdWUgb3B0aW9uICdkZWZhdWx0VmFsdWVPdmVycmlkZScgaXMgaW52YWxpZCA7IGl0IHNob3VsZCBiZSBhIHN0cmluZyB0aGF0IHJlcHJlc2VudHMgYSBwb3NpdGl2ZSBvciBuZWdhdGl2ZSBudW1iZXIsIFske29wdGlvbnMuZGVmYXVsdFZhbHVlT3ZlcnJpZGV9XSBnaXZlbi5gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghaXNUcnVlT3JGYWxzZVN0cmluZyhvcHRpb25zLnVuZm9ybWF0T25TdWJtaXQpICYmICFpc0Jvb2xlYW4ob3B0aW9ucy51bmZvcm1hdE9uU3VibWl0KSkge1xuICAgICAgICAgICAgdGhyb3dFcnJvcihgVGhlIHJlbW92ZSBmb3JtYXR0aW5nIG9uIHN1Ym1pdCBvcHRpb24gJ3VuZm9ybWF0T25TdWJtaXQnIGlzIGludmFsaWQgOyBpdCBzaG91bGQgYmUgZWl0aGVyICdmYWxzZScgb3IgJ3RydWUnLCBbJHtvcHRpb25zLnVuZm9ybWF0T25TdWJtaXR9XSBnaXZlbi5gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghaXNOdWxsKG9wdGlvbnMub3V0cHV0Rm9ybWF0KSAmJiAhaXNJbkFycmF5KG9wdGlvbnMub3V0cHV0Rm9ybWF0LCBbXG4gICAgICAgICAgICAnc3RyaW5nJyxcbiAgICAgICAgICAgICdudW1iZXInLFxuICAgICAgICAgICAgJy4nLFxuICAgICAgICAgICAgJy0uJyxcbiAgICAgICAgICAgICcsJyxcbiAgICAgICAgICAgICctLCcsXG4gICAgICAgICAgICAnLi0nLFxuICAgICAgICAgICAgJywtJyxcbiAgICAgICAgXSkpIHtcbiAgICAgICAgICAgIHRocm93RXJyb3IoYFRoZSBjdXN0b20gbG9jYWxlIGZvcm1hdCBvcHRpb24gJ291dHB1dEZvcm1hdCcgaXMgaW52YWxpZCA7IGl0IHNob3VsZCBlaXRoZXIgYmUgbnVsbCwgJ3N0cmluZycsICdudW1iZXInLCAnLicsICctLicsICcsJywgJy0sJywgJy4tJyBvciAnLC0nLCBbJHtvcHRpb25zLm91dHB1dEZvcm1hdH1dIGdpdmVuLmApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFpc1RydWVPckZhbHNlU3RyaW5nKG9wdGlvbnMuZmFpbE9uVW5rbm93bk9wdGlvbikgJiYgIWlzQm9vbGVhbihvcHRpb25zLmZhaWxPblVua25vd25PcHRpb24pKSB7XG4gICAgICAgICAgICB0aHJvd0Vycm9yKGBUaGUgZGVidWcgb3B0aW9uICdmYWlsT25Vbmtub3duT3B0aW9uJyBpcyBpbnZhbGlkIDsgaXQgc2hvdWxkIGJlIGVpdGhlciAnZmFsc2UnIG9yICd0cnVlJywgWyR7b3B0aW9ucy5mYWlsT25Vbmtub3duT3B0aW9ufV0gZ2l2ZW4uYCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgJC5mbi5hdXRvVmFsaWRhdGUgPSB2YWxpZGF0ZTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybiBUUlVFIGlzIHRoZSBzZXR0aW5ncy9vcHRpb25zIGFyZSB2YWxpZCwgRkFMU0Ugb3RoZXJ3aXNlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBhcmVTZXR0aW5nc1ZhbGlkID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgICBsZXQgaXNWYWxpZCA9IHRydWU7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2YWxpZGF0ZShvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGlzVmFsaWQgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBpc1ZhbGlkO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBUYWtlIGFuIGFyYWJpYyBudW1iZXIgYXMgYSBzdHJpbmcgYW5kIHJldHVybiBhIGphdmFzY3JpcHQgbnVtYmVyLlxuICAgICAqIEJ5IGRlZmF1bHQsIHRoaXMgZnVuY3Rpb24gZG9lcyBub3QgdHJ5IHRvIGNvbnZlcnQgdGhlIGFyYWJpYyBkZWNpbWFsIGFuZCB0aG91c2FuZCBzZXBhcmF0b3IgY2hhcmFjdGVycy5cbiAgICAgKiBUaGlzIHJldHVybnMgYE5hTmAgaXMgdGhlIGNvbnZlcnNpb24gaXMgbm90IHBvc3NpYmxlLlxuICAgICAqIEJhc2VkIG9uIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzE3MDI1MzkyLzI4MzQ4OThcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhcmFiaWNOdW1iZXJzXG4gICAgICogQHBhcmFtIHtib29sZWFufSByZXR1cm5BTnVtYmVyIElmIGB0cnVlYCwgcmV0dXJuIGEgTnVtYmVyLCBvdGhlcndpc2UgcmV0dXJuIGEgU3RyaW5nXG4gICAgICogQHBhcmFtIHtib29sZWFufSBwYXJzZURlY2ltYWxDaGFyYWN0ZXJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHBhcnNlVGhvdXNhbmRTZXBhcmF0b3JcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfG51bWJlcnxOYU59XG4gICAgICovXG4gICAgZnVuY3Rpb24gYXJhYmljVG9MYXRpbk51bWJlcnMoYXJhYmljTnVtYmVycywgcmV0dXJuQU51bWJlciA9IHRydWUsIHBhcnNlRGVjaW1hbENoYXJhY3RlciA9IGZhbHNlLCBwYXJzZVRob3VzYW5kU2VwYXJhdG9yID0gZmFsc2UpIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IGFyYWJpY051bWJlcnMudG9TdHJpbmcoKTtcbiAgICAgICAgaWYgKHJlc3VsdCA9PT0gJycpIHtcbiAgICAgICAgICAgIHJldHVybiBhcmFiaWNOdW1iZXJzO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHBhcnNlRGVjaW1hbENoYXJhY3Rlcikge1xuICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0LnJlcGxhY2UoL9mrLywgJy4nKTsgLy8gRGVjaW1hbCBjaGFyYWN0ZXJcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwYXJzZVRob3VzYW5kU2VwYXJhdG9yKSB7XG4gICAgICAgICAgICByZXN1bHQgPSByZXN1bHQucmVwbGFjZSgv2awvZywgJycpOyAvLyBUaG91c2FuZCBzZXBhcmF0b3JcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFJlcGxhY2UgdGhlIG51bWJlcnMgb25seVxuICAgICAgICByZXN1bHQgPSByZXN1bHQucmVwbGFjZSgvW9mg2aHZotmj2aTZpdmm2afZqNmpXS9nLCBkID0+IGQuY2hhckNvZGVBdCgwKSAtIDE2MzIpIC8vIEFyYWJpYyBudW1iZXJzXG4gICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9b27Dbsduy27PbtNu127bbt9u427ldL2csIGQgPT4gZC5jaGFyQ29kZUF0KDApIC0gMTc3Nik7IC8vIFBlcnNpYW4gbnVtYmVyc1xuXG4gICAgICAgIC8vIGBOYU5gIGhhcyBwcmVjZWRlbmNlIG92ZXIgdGhlIHN0cmluZyBgJ05hTidgXG4gICAgICAgIGNvbnN0IHJlc3VsdEFzTnVtYmVyID0gTnVtYmVyKHJlc3VsdCk7XG4gICAgICAgIGlmIChpc05hTihyZXN1bHRBc051bWJlcikpIHtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHRBc051bWJlcjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChyZXR1cm5BTnVtYmVyKSB7XG4gICAgICAgICAgICByZXN1bHQgPSByZXN1bHRBc051bWJlcjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgY3VzdG9tIGV2ZW50IGFuZCBpbW1lZGlhdGVseSBzZW50IGl0IGZyb20gdGhlIGdpdmVuIGVsZW1lbnQuXG4gICAgICogQnkgZGVmYXVsdCwgaWYgbm8gZWxlbWVudCBpcyBnaXZlbiwgdGhlIGV2ZW50IGlzIHRocm93biBmcm9tIGBkb2N1bWVudGAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lXG4gICAgICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50XG4gICAgICogQHBhcmFtIHtvYmplY3R9IGRldGFpbFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRyaWdnZXJFdmVudChldmVudE5hbWUsIGVsZW1lbnQgPSBkb2N1bWVudCwgZGV0YWlsID0gbnVsbCkge1xuICAgICAgICBsZXQgZXZlbnQ7XG4gICAgICAgIGlmICh3aW5kb3cuQ3VzdG9tRXZlbnQpIHtcbiAgICAgICAgICAgIGV2ZW50ID0gbmV3IEN1c3RvbUV2ZW50KGV2ZW50TmFtZSwgeyBkZXRhaWwsIGJ1YmJsZXM6IGZhbHNlLCBjYW5jZWxhYmxlOiBmYWxzZSB9KTsgLy8gVGhpcyBpcyBub3Qgc3VwcG9ydGVkIGJ5IGRlZmF1bHQgYnkgSUUgOyBXZSB1c2UgdGhlIHBvbHlmaWxsIGZvciBJRTkgYW5kIGxhdGVyLlxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZXZlbnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnQ3VzdG9tRXZlbnQnKTtcbiAgICAgICAgICAgIGV2ZW50LmluaXRDdXN0b21FdmVudChldmVudE5hbWUsIHRydWUsIHRydWUsIHsgZGV0YWlsIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgZWxlbWVudC5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQb2x5ZmlsbCBmcm9tIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9DdXN0b21FdmVudC9DdXN0b21FdmVudCBmb3Igb2Jzb2xldGUgYnJvd3NlcnMgKElFKVxuICAgICAqL1xuICAgIChmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cuQ3VzdG9tRXZlbnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIEN1c3RvbUV2ZW50KGV2ZW50LCBwYXJhbXMpIHtcbiAgICAgICAgICAgIHBhcmFtcyA9IHBhcmFtcyB8fCB7IGJ1YmJsZXM6IGZhbHNlLCBjYW5jZWxhYmxlOiBmYWxzZSwgZGV0YWlsOiB2b2lkKDApIH07XG4gICAgICAgICAgICBjb25zdCBldnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnQ3VzdG9tRXZlbnQnKTtcbiAgICAgICAgICAgIGV2dC5pbml0Q3VzdG9tRXZlbnQoZXZlbnQsIHBhcmFtcy5idWJibGVzLCBwYXJhbXMuY2FuY2VsYWJsZSwgcGFyYW1zLmRldGFpbCk7XG4gICAgICAgICAgICByZXR1cm4gZXZ0O1xuICAgICAgICB9XG5cbiAgICAgICAgQ3VzdG9tRXZlbnQucHJvdG90eXBlID0gd2luZG93LkV2ZW50LnByb3RvdHlwZTtcbiAgICAgICAgd2luZG93LkN1c3RvbUV2ZW50ID0gQ3VzdG9tRXZlbnQ7XG4gICAgfSkoKTtcbn0pKTtcblxuLyoqXG4gKiBUaGlzIGV4cG9ydHMgdGhlIGludGVyZmFjZSBmb3IgdGhlIGF1dG9OdW1lcmljIG9iamVjdFxuICovXG5leHBvcnQgZGVmYXVsdCB7XG4gICAgZm9ybWF0ICA6IGF1dG9Gb3JtYXQsXG4gICAgdW5Gb3JtYXQ6IGF1dG9VbkZvcm1hdCxcbiAgICBnZXREZWZhdWx0Q29uZmlnLFxuICAgIGdldExhbmd1YWdlcyxcbiAgICB2YWxpZGF0ZSwgLy8gYW4udmFsaWRhdGUob3B0aW9ucykgOiB0aHJvd3MgaWYgbmVjZXNzYXJ5XG4gICAgYXJlU2V0dGluZ3NWYWxpZCwgLy8gYW4uYXJlU2V0dGluZ3NWYWxpZChvcHRpb25zKSA6IHJldHVybiB0cnVlIG9yIGZhbHNlIC8vVE9ETyBJcyB0aGlzIHJlZHVuZGFudD8gU2hvdWxkIHdlIGxldCB0aGUgZGV2ZWxvcGVycyB3cmFwIGVhY2ggYXV0b051bWVyaWMudmFsaWRhdGUoKSBjYWxscyBpbiB0cnkvY2F0Y2ggYmxvY2s/IE9yIHNob3VsZCB3ZSBqdXN0IGZhY2lsaXRhdGUgdGhlaXIgbGlmZSBieSBkb2luZyBpdCBhbHJlYWR5P1xuXG4gICAgLy9UT0RPIENvbXBsZXRlIHRoZSBpbnRlcmZhY2Ugd2l0aCBmdW5jdGlvbnMgaGF2aW5nIHRoZSBmb2xsb3dpbmcgc2lnbmF0dXJlcyA6XG4gICAgLy9pbml0ICAgICAgICAgOiBhbi5pbml0KG9wdGlvbnMsIGlucHV0KVxuICAgIC8vZ2V0ICAgICAgICAgIDogYW4uZ2V0KGlucHV0KVxuICAgIC8vc2V0ICAgICAgICAgIDogYW4uc2V0KHZhbHVlLCBpbnB1dClcbiAgICAvL2Zvcm1TdHJpbmcgICA6IGFuLmZvcm1TdHJpbmcoZm9ybSlcbiAgICAvL2Zvcm1BcnJheSAgICA6IGFuLmZvcm1BcnJheShmb3JtKVxuICAgIC8vZ2V0Rm9ybWF0dGVkIDogYW4uZ2V0Rm9ybWF0dGVkKGlucHV0KVxuICAgIC8vdW5zZXQgICAgICAgIDogYW4udW5zZXQoaW5wdXQpIC8vdG8gcmVuYW1lIHRvICd1bmZvcm1hdCc/IChhbmQgbWVyZ2Ugd2l0aCBhdXRvVW5Gb3JtYXQvdW5Gb3JtYXQ/KVxuICAgIC8vcmVmb3JtYXQgICAgIDogYW4ucmVmb3JtYXQoaW5wdXQpIC8vICdyZVNldCcgaXMgdmVyeSB0byBjbG9zZSB0byAncmVzZXQnIGFuZCB0aGVyZWZvcmUgc2hvdWxkIGJlIHJlbmFtZWQuIFdlIGNvdWxkIHN0aWxsIGV4cG9zZSAncmVTZXQnLCBidXQgYWRkIGEgQGRlcHJlY2F0ZWQgdGFnIG9uIGl0cyBkZWNsYXJhdGlvbi5cbiAgICAvL3NldHRpbmdzICAgICA6IGFuLnNldHRpbmdzKGlucHV0KVxuICAgIC8vdXBkYXRlICAgICAgIDogYW4udXBkYXRlKG9wdGlvbnMsIGlucHV0KVxuICAgIC8vd2lwZSAgICAgICAgIDogYW4ud2lwZShpbnB1dClcbiAgICAvL2Rlc3Ryb3kgICAgICA6IGFuLmRlc3Ryb3koaW5wdXQpXG5cbiAgICAvL3JhdyAgICAgICAgICA6IGFuLnJhdyhpbnB1dCkgLy8gUmV0dXJuIHRoZSB1bmZvcm1hdHRlZCB2YWx1ZSBhcyBhIHN0cmluZ1xuICAgIC8vbnVtYmVyICAgICAgIDogYW4ubnVtYmVyKGlucHV0KSAvLyBSZXR1cm4gdGhlIHVuZm9ybWF0dGVkIHZhbHVlIGFzIGEgbnVtYmVyIChXYXJuaW5nOiBUaGlzIGNhbiBsZWFkIHRvIHByZWNpc2lvbiBwcm9ibGVtcyB3aXRoIGJpZyBudW1iZXJzKVxufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9hdXRvTnVtZXJpYy5qcyJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 1 */
/***/ function(module, exports) {

	eval("module.exports = __WEBPACK_EXTERNAL_MODULE_1__;//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vZXh0ZXJuYWwge1wicm9vdFwiOlwialF1ZXJ5XCIsXCJjb21tb25qc1wiOlwianF1ZXJ5XCIsXCJjb21tb25qczJcIjpcImpxdWVyeVwiLFwiYW1kXCI6XCJqcXVlcnlcIn0/NWNiYyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSIsImZpbGUiOiIxLmpzIiwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFXzFfXztcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyBleHRlcm5hbCB7XCJyb290XCI6XCJqUXVlcnlcIixcImNvbW1vbmpzXCI6XCJqcXVlcnlcIixcImNvbW1vbmpzMlwiOlwianF1ZXJ5XCIsXCJhbWRcIjpcImpxdWVyeVwifVxuLy8gbW9kdWxlIGlkID0gMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }
/******/ ])
});
;